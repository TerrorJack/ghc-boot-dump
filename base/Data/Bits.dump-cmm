
==================== Output Cmm ====================
2018-03-16 15:56:23.107775654 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:23.138233434 UTC

[section ""data" . Data.Bits.$p1FiniteBits_closure" {
     Data.Bits.$p1FiniteBits_closure:
         const Data.Bits.$p1FiniteBits_info;
 },
 Data.Bits.$p1FiniteBits_entry() //  [R2]
         { info_tbl: [(c1CZq,
                       label: Data.Bits.$p1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1CZq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1CZr; else goto c1CZs;
       c1CZr: // global
           R2 = R2;
           R1 = Data.Bits.$p1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1CZs: // global
           I64[Sp - 8] = block_c1CZn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1CZw; else goto c1CZo;
       u1CZw: // global
           call _c1CZn(R1) args: 0, res: 0, upd: 0;
       c1CZo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1CZn() //  [R1]
         { info_tbl: [(c1CZn,
                       label: block_c1CZn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1CZn: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.139604083 UTC

[section ""data" . Data.Bits.finiteBitSize_closure" {
     Data.Bits.finiteBitSize_closure:
         const Data.Bits.finiteBitSize_info;
 },
 Data.Bits.finiteBitSize_entry() //  [R2]
         { info_tbl: [(c1CZE,
                       label: Data.Bits.finiteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1CZE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1CZF; else goto c1CZG;
       c1CZF: // global
           R2 = R2;
           R1 = Data.Bits.finiteBitSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1CZG: // global
           I64[Sp - 8] = block_c1CZB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1CZK; else goto c1CZC;
       u1CZK: // global
           call _c1CZB(R1) args: 0, res: 0, upd: 0;
       c1CZC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1CZB() //  [R1]
         { info_tbl: [(c1CZB,
                       label: block_c1CZB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1CZB: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.140783173 UTC

[section ""data" . Data.Bits.countLeadingZeros_closure" {
     Data.Bits.countLeadingZeros_closure:
         const Data.Bits.countLeadingZeros_info;
 },
 Data.Bits.countLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1CZS,
                       label: Data.Bits.countLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1CZS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1CZT; else goto c1CZU;
       c1CZT: // global
           R2 = R2;
           R1 = Data.Bits.countLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1CZU: // global
           I64[Sp - 8] = block_c1CZP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1CZY; else goto c1CZQ;
       u1CZY: // global
           call _c1CZP(R1) args: 0, res: 0, upd: 0;
       c1CZQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1CZP() //  [R1]
         { info_tbl: [(c1CZP,
                       label: block_c1CZP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1CZP: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.142060859 UTC

[section ""data" . Data.Bits.countTrailingZeros_closure" {
     Data.Bits.countTrailingZeros_closure:
         const Data.Bits.countTrailingZeros_info;
 },
 Data.Bits.countTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1D06,
                       label: Data.Bits.countTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D06: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D07; else goto c1D08;
       c1D07: // global
           R2 = R2;
           R1 = Data.Bits.countTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D08: // global
           I64[Sp - 8] = block_c1D03_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D0c; else goto c1D04;
       u1D0c: // global
           call _c1D03(R1) args: 0, res: 0, upd: 0;
       c1D04: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D03() //  [R1]
         { info_tbl: [(c1D03,
                       label: block_c1D03_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D03: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.147148016 UTC

[section ""data" . Data.Bits.$p1Bits_closure" {
     Data.Bits.$p1Bits_closure:
         const Data.Bits.$p1Bits_info;
 },
 Data.Bits.$p1Bits_entry() //  [R2]
         { info_tbl: [(c1D0k,
                       label: Data.Bits.$p1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D0k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D0l; else goto c1D0m;
       c1D0l: // global
           R2 = R2;
           R1 = Data.Bits.$p1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D0m: // global
           I64[Sp - 8] = block_c1D0h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D0q; else goto c1D0i;
       u1D0q: // global
           call _c1D0h(R1) args: 0, res: 0, upd: 0;
       c1D0i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D0h() //  [R1]
         { info_tbl: [(c1D0h,
                       label: block_c1D0h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D0h: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.148275046 UTC

[section ""data" . Data.Bits..&._closure" {
     Data.Bits..&._closure:
         const Data.Bits..&._info;
 },
 Data.Bits..&._entry() //  [R2]
         { info_tbl: [(c1D0y,
                       label: Data.Bits..&._info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D0y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D0z; else goto c1D0A;
       c1D0z: // global
           R2 = R2;
           R1 = Data.Bits..&._closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D0A: // global
           I64[Sp - 8] = block_c1D0v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D0E; else goto c1D0w;
       u1D0E: // global
           call _c1D0v(R1) args: 0, res: 0, upd: 0;
       c1D0w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D0v() //  [R1]
         { info_tbl: [(c1D0v,
                       label: block_c1D0v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D0v: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.149429076 UTC

[section ""data" . Data.Bits..|._closure" {
     Data.Bits..|._closure:
         const Data.Bits..|._info;
 },
 Data.Bits..|._entry() //  [R2]
         { info_tbl: [(c1D0M,
                       label: Data.Bits..|._info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D0M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D0N; else goto c1D0O;
       c1D0N: // global
           R2 = R2;
           R1 = Data.Bits..|._closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D0O: // global
           I64[Sp - 8] = block_c1D0J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D0S; else goto c1D0K;
       u1D0S: // global
           call _c1D0J(R1) args: 0, res: 0, upd: 0;
       c1D0K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D0J() //  [R1]
         { info_tbl: [(c1D0J,
                       label: block_c1D0J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D0J: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.150579387 UTC

[section ""data" . Data.Bits.xor_closure" {
     Data.Bits.xor_closure:
         const Data.Bits.xor_info;
 },
 Data.Bits.xor_entry() //  [R2]
         { info_tbl: [(c1D10,
                       label: Data.Bits.xor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D10: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D11; else goto c1D12;
       c1D11: // global
           R2 = R2;
           R1 = Data.Bits.xor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D12: // global
           I64[Sp - 8] = block_c1D0X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D16; else goto c1D0Y;
       u1D16: // global
           call _c1D0X(R1) args: 0, res: 0, upd: 0;
       c1D0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D0X() //  [R1]
         { info_tbl: [(c1D0X,
                       label: block_c1D0X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D0X: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.151751967 UTC

[section ""data" . Data.Bits.complement_closure" {
     Data.Bits.complement_closure:
         const Data.Bits.complement_info;
 },
 Data.Bits.complement_entry() //  [R2]
         { info_tbl: [(c1D1e,
                       label: Data.Bits.complement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D1e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D1f; else goto c1D1g;
       c1D1f: // global
           R2 = R2;
           R1 = Data.Bits.complement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D1g: // global
           I64[Sp - 8] = block_c1D1b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D1k; else goto c1D1c;
       u1D1k: // global
           call _c1D1b(R1) args: 0, res: 0, upd: 0;
       c1D1c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D1b() //  [R1]
         { info_tbl: [(c1D1b,
                       label: block_c1D1b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D1b: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.152924645 UTC

[section ""data" . Data.Bits.shift_closure" {
     Data.Bits.shift_closure:
         const Data.Bits.shift_info;
 },
 Data.Bits.shift_entry() //  [R2]
         { info_tbl: [(c1D1s,
                       label: Data.Bits.shift_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D1s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D1t; else goto c1D1u;
       c1D1t: // global
           R2 = R2;
           R1 = Data.Bits.shift_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D1u: // global
           I64[Sp - 8] = block_c1D1p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D1y; else goto c1D1q;
       u1D1y: // global
           call _c1D1p(R1) args: 0, res: 0, upd: 0;
       c1D1q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D1p() //  [R1]
         { info_tbl: [(c1D1p,
                       label: block_c1D1p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D1p: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.154158963 UTC

[section ""data" . Data.Bits.rotate_closure" {
     Data.Bits.rotate_closure:
         const Data.Bits.rotate_info;
 },
 Data.Bits.rotate_entry() //  [R2]
         { info_tbl: [(c1D1G,
                       label: Data.Bits.rotate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D1G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D1H; else goto c1D1I;
       c1D1H: // global
           R2 = R2;
           R1 = Data.Bits.rotate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D1I: // global
           I64[Sp - 8] = block_c1D1D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D1M; else goto c1D1E;
       u1D1M: // global
           call _c1D1D(R1) args: 0, res: 0, upd: 0;
       c1D1E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D1D() //  [R1]
         { info_tbl: [(c1D1D,
                       label: block_c1D1D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D1D: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.155361633 UTC

[section ""data" . Data.Bits.zeroBits_closure" {
     Data.Bits.zeroBits_closure:
         const Data.Bits.zeroBits_info;
 },
 Data.Bits.zeroBits_entry() //  [R2]
         { info_tbl: [(c1D1U,
                       label: Data.Bits.zeroBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D1U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D1V; else goto c1D1W;
       c1D1V: // global
           R2 = R2;
           R1 = Data.Bits.zeroBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D1W: // global
           I64[Sp - 8] = block_c1D1R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D20; else goto c1D1S;
       u1D20: // global
           call _c1D1R(R1) args: 0, res: 0, upd: 0;
       c1D1S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D1R() //  [R1]
         { info_tbl: [(c1D1R,
                       label: block_c1D1R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D1R: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.157216959 UTC

[section ""data" . Data.Bits.bit_closure" {
     Data.Bits.bit_closure:
         const Data.Bits.bit_info;
 },
 Data.Bits.bit_entry() //  [R2]
         { info_tbl: [(c1D28,
                       label: Data.Bits.bit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D28: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D29; else goto c1D2a;
       c1D29: // global
           R2 = R2;
           R1 = Data.Bits.bit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D2a: // global
           I64[Sp - 8] = block_c1D25_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D2e; else goto c1D26;
       u1D2e: // global
           call _c1D25(R1) args: 0, res: 0, upd: 0;
       c1D26: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D25() //  [R1]
         { info_tbl: [(c1D25,
                       label: block_c1D25_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D25: // global
           R1 = P64[R1 + 71];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.159126374 UTC

[section ""data" . Data.Bits.setBit_closure" {
     Data.Bits.setBit_closure:
         const Data.Bits.setBit_info;
 },
 Data.Bits.setBit_entry() //  [R2]
         { info_tbl: [(c1D2m,
                       label: Data.Bits.setBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D2m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D2n; else goto c1D2o;
       c1D2n: // global
           R2 = R2;
           R1 = Data.Bits.setBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D2o: // global
           I64[Sp - 8] = block_c1D2j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D2s; else goto c1D2k;
       u1D2s: // global
           call _c1D2j(R1) args: 0, res: 0, upd: 0;
       c1D2k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D2j() //  [R1]
         { info_tbl: [(c1D2j,
                       label: block_c1D2j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D2j: // global
           R1 = P64[R1 + 79];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.161769732 UTC

[section ""data" . Data.Bits.clearBit_closure" {
     Data.Bits.clearBit_closure:
         const Data.Bits.clearBit_info;
 },
 Data.Bits.clearBit_entry() //  [R2]
         { info_tbl: [(c1D2A,
                       label: Data.Bits.clearBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D2A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D2B; else goto c1D2C;
       c1D2B: // global
           R2 = R2;
           R1 = Data.Bits.clearBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D2C: // global
           I64[Sp - 8] = block_c1D2x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D2G; else goto c1D2y;
       u1D2G: // global
           call _c1D2x(R1) args: 0, res: 0, upd: 0;
       c1D2y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D2x() //  [R1]
         { info_tbl: [(c1D2x,
                       label: block_c1D2x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D2x: // global
           R1 = P64[R1 + 87];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.163659187 UTC

[section ""data" . Data.Bits.complementBit_closure" {
     Data.Bits.complementBit_closure:
         const Data.Bits.complementBit_info;
 },
 Data.Bits.complementBit_entry() //  [R2]
         { info_tbl: [(c1D2O,
                       label: Data.Bits.complementBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D2O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D2P; else goto c1D2Q;
       c1D2P: // global
           R2 = R2;
           R1 = Data.Bits.complementBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D2Q: // global
           I64[Sp - 8] = block_c1D2L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D2U; else goto c1D2M;
       u1D2U: // global
           call _c1D2L(R1) args: 0, res: 0, upd: 0;
       c1D2M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D2L() //  [R1]
         { info_tbl: [(c1D2L,
                       label: block_c1D2L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D2L: // global
           R1 = P64[R1 + 95];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.165651659 UTC

[section ""data" . Data.Bits.testBit_closure" {
     Data.Bits.testBit_closure:
         const Data.Bits.testBit_info;
 },
 Data.Bits.testBit_entry() //  [R2]
         { info_tbl: [(c1D32,
                       label: Data.Bits.testBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D32: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D33; else goto c1D34;
       c1D33: // global
           R2 = R2;
           R1 = Data.Bits.testBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D34: // global
           I64[Sp - 8] = block_c1D2Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D38; else goto c1D30;
       u1D38: // global
           call _c1D2Z(R1) args: 0, res: 0, upd: 0;
       c1D30: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D2Z() //  [R1]
         { info_tbl: [(c1D2Z,
                       label: block_c1D2Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D2Z: // global
           R1 = P64[R1 + 103];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.167617086 UTC

[section ""data" . Data.Bits.bitSizeMaybe_closure" {
     Data.Bits.bitSizeMaybe_closure:
         const Data.Bits.bitSizeMaybe_info;
 },
 Data.Bits.bitSizeMaybe_entry() //  [R2]
         { info_tbl: [(c1D3g,
                       label: Data.Bits.bitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D3g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D3h; else goto c1D3i;
       c1D3h: // global
           R2 = R2;
           R1 = Data.Bits.bitSizeMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D3i: // global
           I64[Sp - 8] = block_c1D3d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D3m; else goto c1D3e;
       u1D3m: // global
           call _c1D3d(R1) args: 0, res: 0, upd: 0;
       c1D3e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D3d() //  [R1]
         { info_tbl: [(c1D3d,
                       label: block_c1D3d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D3d: // global
           R1 = P64[R1 + 111];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.169559541 UTC

[section ""data" . Data.Bits.bitSize_closure" {
     Data.Bits.bitSize_closure:
         const Data.Bits.bitSize_info;
 },
 Data.Bits.bitSize_entry() //  [R2]
         { info_tbl: [(c1D3u,
                       label: Data.Bits.bitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D3u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D3v; else goto c1D3w;
       c1D3v: // global
           R2 = R2;
           R1 = Data.Bits.bitSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D3w: // global
           I64[Sp - 8] = block_c1D3r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D3A; else goto c1D3s;
       u1D3A: // global
           call _c1D3r(R1) args: 0, res: 0, upd: 0;
       c1D3s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D3r() //  [R1]
         { info_tbl: [(c1D3r,
                       label: block_c1D3r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D3r: // global
           R1 = P64[R1 + 119];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.170748281 UTC

[section ""data" . Data.Bits.isSigned_closure" {
     Data.Bits.isSigned_closure:
         const Data.Bits.isSigned_info;
 },
 Data.Bits.isSigned_entry() //  [R2]
         { info_tbl: [(c1D3I,
                       label: Data.Bits.isSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D3I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D3J; else goto c1D3K;
       c1D3J: // global
           R2 = R2;
           R1 = Data.Bits.isSigned_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D3K: // global
           I64[Sp - 8] = block_c1D3F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D3O; else goto c1D3G;
       u1D3O: // global
           call _c1D3F(R1) args: 0, res: 0, upd: 0;
       c1D3G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D3F() //  [R1]
         { info_tbl: [(c1D3F,
                       label: block_c1D3F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D3F: // global
           R1 = P64[R1 + 127];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.171931847 UTC

[section ""data" . Data.Bits.shiftL_closure" {
     Data.Bits.shiftL_closure:
         const Data.Bits.shiftL_info;
 },
 Data.Bits.shiftL_entry() //  [R2]
         { info_tbl: [(c1D3W,
                       label: Data.Bits.shiftL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D3W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D3X; else goto c1D3Y;
       c1D3X: // global
           R2 = R2;
           R1 = Data.Bits.shiftL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D3Y: // global
           I64[Sp - 8] = block_c1D3T_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D42; else goto c1D3U;
       u1D42: // global
           call _c1D3T(R1) args: 0, res: 0, upd: 0;
       c1D3U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D3T() //  [R1]
         { info_tbl: [(c1D3T,
                       label: block_c1D3T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D3T: // global
           R1 = P64[R1 + 135];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.173229346 UTC

[section ""data" . Data.Bits.unsafeShiftL_closure" {
     Data.Bits.unsafeShiftL_closure:
         const Data.Bits.unsafeShiftL_info;
 },
 Data.Bits.unsafeShiftL_entry() //  [R2]
         { info_tbl: [(c1D4a,
                       label: Data.Bits.unsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D4a: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D4b; else goto c1D4c;
       c1D4b: // global
           R2 = R2;
           R1 = Data.Bits.unsafeShiftL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D4c: // global
           I64[Sp - 8] = block_c1D47_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D4g; else goto c1D48;
       u1D4g: // global
           call _c1D47(R1) args: 0, res: 0, upd: 0;
       c1D48: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D47() //  [R1]
         { info_tbl: [(c1D47,
                       label: block_c1D47_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D47: // global
           R1 = P64[R1 + 143];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.17460215 UTC

[section ""data" . Data.Bits.shiftR_closure" {
     Data.Bits.shiftR_closure:
         const Data.Bits.shiftR_info;
 },
 Data.Bits.shiftR_entry() //  [R2]
         { info_tbl: [(c1D4o,
                       label: Data.Bits.shiftR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D4o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D4p; else goto c1D4q;
       c1D4p: // global
           R2 = R2;
           R1 = Data.Bits.shiftR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D4q: // global
           I64[Sp - 8] = block_c1D4l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D4u; else goto c1D4m;
       u1D4u: // global
           call _c1D4l(R1) args: 0, res: 0, upd: 0;
       c1D4m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D4l() //  [R1]
         { info_tbl: [(c1D4l,
                       label: block_c1D4l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D4l: // global
           R1 = P64[R1 + 151];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.175732985 UTC

[section ""data" . Data.Bits.unsafeShiftR_closure" {
     Data.Bits.unsafeShiftR_closure:
         const Data.Bits.unsafeShiftR_info;
 },
 Data.Bits.unsafeShiftR_entry() //  [R2]
         { info_tbl: [(c1D4C,
                       label: Data.Bits.unsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D4C: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D4D; else goto c1D4E;
       c1D4D: // global
           R2 = R2;
           R1 = Data.Bits.unsafeShiftR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D4E: // global
           I64[Sp - 8] = block_c1D4z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D4I; else goto c1D4A;
       u1D4I: // global
           call _c1D4z(R1) args: 0, res: 0, upd: 0;
       c1D4A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D4z() //  [R1]
         { info_tbl: [(c1D4z,
                       label: block_c1D4z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D4z: // global
           R1 = P64[R1 + 159];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.177484251 UTC

[section ""data" . Data.Bits.rotateL_closure" {
     Data.Bits.rotateL_closure:
         const Data.Bits.rotateL_info;
 },
 Data.Bits.rotateL_entry() //  [R2]
         { info_tbl: [(c1D4Q,
                       label: Data.Bits.rotateL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D4Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D4R; else goto c1D4S;
       c1D4R: // global
           R2 = R2;
           R1 = Data.Bits.rotateL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D4S: // global
           I64[Sp - 8] = block_c1D4N_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D4W; else goto c1D4O;
       u1D4W: // global
           call _c1D4N(R1) args: 0, res: 0, upd: 0;
       c1D4O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D4N() //  [R1]
         { info_tbl: [(c1D4N,
                       label: block_c1D4N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D4N: // global
           R1 = P64[R1 + 167];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.178668555 UTC

[section ""data" . Data.Bits.rotateR_closure" {
     Data.Bits.rotateR_closure:
         const Data.Bits.rotateR_info;
 },
 Data.Bits.rotateR_entry() //  [R2]
         { info_tbl: [(c1D54,
                       label: Data.Bits.rotateR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D54: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D55; else goto c1D56;
       c1D55: // global
           R2 = R2;
           R1 = Data.Bits.rotateR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D56: // global
           I64[Sp - 8] = block_c1D51_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D5a; else goto c1D52;
       u1D5a: // global
           call _c1D51(R1) args: 0, res: 0, upd: 0;
       c1D52: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D51() //  [R1]
         { info_tbl: [(c1D51,
                       label: block_c1D51_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D51: // global
           R1 = P64[R1 + 175];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.179832759 UTC

[section ""data" . Data.Bits.popCount_closure" {
     Data.Bits.popCount_closure:
         const Data.Bits.popCount_info;
 },
 Data.Bits.popCount_entry() //  [R2]
         { info_tbl: [(c1D5i,
                       label: Data.Bits.popCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D5i: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D5j; else goto c1D5k;
       c1D5j: // global
           R2 = R2;
           R1 = Data.Bits.popCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D5k: // global
           I64[Sp - 8] = block_c1D5f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D5o; else goto c1D5g;
       u1D5o: // global
           call _c1D5f(R1) args: 0, res: 0, upd: 0;
       c1D5g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D5f() //  [R1]
         { info_tbl: [(c1D5f,
                       label: block_c1D5f_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D5f: // global
           R1 = P64[R1 + 183];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.180802441 UTC

[section ""data" . Data.Bits.$fBitsBool2_closure" {
     Data.Bits.$fBitsBool2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.181400792 UTC

[section ""data" . Data.Bits.$fBitsBool1_closure" {
     Data.Bits.$fBitsBool1_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.182209222 UTC

[section ""data" . Data.Bits.$fBitsBool_$cpopCount_closure" {
     Data.Bits.$fBitsBool_$cpopCount_closure:
         const Data.Bits.$fBitsBool_$cpopCount_info;
 },
 Data.Bits.$fBitsBool_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1D5A,
                       label: Data.Bits.$fBitsBool_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D5A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D5B; else goto c1D5C;
       c1D5B: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D5C: // global
           I64[Sp - 8] = block_c1D5t_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D5J; else goto c1D5u;
       u1D5J: // global
           call _c1D5t(R1) args: 0, res: 0, upd: 0;
       c1D5u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D5t() //  [R1]
         { info_tbl: [(c1D5t,
                       label: block_c1D5t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D5t: // global
           if (R1 & 7 == 1) goto c1D5x; else goto c1D5y;
       c1D5x: // global
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1D5y: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.183305257 UTC

[section ""data" . Data.Bits.$fBitsBool_$cisSigned_closure" {
     Data.Bits.$fBitsBool_$cisSigned_closure:
         const Data.Bits.$fBitsBool_$cisSigned_info;
 },
 Data.Bits.$fBitsBool_$cisSigned_entry() //  []
         { info_tbl: [(c1D5O,
                       label: Data.Bits.$fBitsBool_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D5O: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.184085115 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbitSize_closure" {
     Data.Bits.$fBitsBool_$cbitSize_closure:
         const Data.Bits.$fBitsBool_$cbitSize_info;
 },
 Data.Bits.$fBitsBool_$cbitSize_entry() //  []
         { info_tbl: [(c1D5V,
                       label: Data.Bits.$fBitsBool_$cbitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D5V: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.184797106 UTC

[section ""data" . Data.Bits.$fBitsBool3_closure" {
     Data.Bits.$fBitsBool3_closure:
         const GHC.Base.Just_con_info;
         const Data.Bits.$fBitsBool1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.185513148 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsBool_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsBool_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsBool_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1D62,
                       label: Data.Bits.$fBitsBool_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D62: // global
           R1 = Data.Bits.$fBitsBool3_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.186565794 UTC

[section ""data" . Data.Bits.$fBitsBool_$ctestBit_closure" {
     Data.Bits.$fBitsBool_$ctestBit_closure:
         const Data.Bits.$fBitsBool_$ctestBit_info;
 },
 Data.Bits.$fBitsBool_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1D6c,
                       label: Data.Bits.$fBitsBool_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D6c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1D6d; else goto c1D6e;
       c1D6d: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1D6e: // global
           I64[Sp - 16] = block_c1D69_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1D6m; else goto c1D6a;
       u1D6m: // global
           call _c1D69(R1) args: 0, res: 0, upd: 0;
       c1D6a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D69() //  [R1]
         { info_tbl: [(c1D69,
                       label: block_c1D69_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D69: // global
           if (I64[R1 + 7] == 0) goto c1D6l; else goto c1D6k;
       c1D6l: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1D6k: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.187893214 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbit_closure" {
     Data.Bits.$fBitsBool_$cbit_closure:
         const Data.Bits.$fBitsBool_$cbit_info;
 },
 Data.Bits.$fBitsBool_$cbit_entry() //  [R2]
         { info_tbl: [(c1D6u,
                       label: Data.Bits.$fBitsBool_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D6u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D6v; else goto c1D6w;
       c1D6v: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D6w: // global
           I64[Sp - 8] = block_c1D6r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D6E; else goto c1D6s;
       u1D6E: // global
           call _c1D6r(R1) args: 0, res: 0, upd: 0;
       c1D6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D6r() //  [R1]
         { info_tbl: [(c1D6r,
                       label: block_c1D6r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D6r: // global
           if (I64[R1 + 7] == 0) goto c1D6D; else goto c1D6C;
       c1D6D: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1D6C: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.189101654 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotate_closure" {
     Data.Bits.$fBitsBool_$crotate_closure:
         const Data.Bits.$fBitsBool_$crotate_info;
 },
 Data.Bits.$fBitsBool_$crotate_entry() //  [R2]
         { info_tbl: [(c1D6J,
                       label: Data.Bits.$fBitsBool_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D6J: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.19044951 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cisSigned_closure" {
     Data.Bits.$fBitsInteger_$cisSigned_closure:
         const Data.Bits.$fBitsInteger_$cisSigned_info;
 },
 Data.Bits.$fBitsInteger_$cisSigned_entry() //  []
         { info_tbl: [(c1D6Q,
                       label: Data.Bits.$fBitsInteger_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D6Q: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.191155479 UTC

[section ""cstring" . Data.Bits.$fBitsInteger2_bytes" {
     Data.Bits.$fBitsInteger2_bytes:
         I8[] [68,97,116,97,46,66,105,116,115,46,98,105,116,83,105,122,101,40,73,110,116,101,103,101,114,41]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.191884868 UTC

[section ""data" . Data.Bits.$fBitsInteger1_closure" {
     Data.Bits.$fBitsInteger1_closure:
         const Data.Bits.$fBitsInteger1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger1_entry() //  [R1]
         { info_tbl: [(c1D6Z,
                       label: Data.Bits.$fBitsInteger1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D6Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1D70; else goto c1D71;
       c1D70: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1D71: // global
           (_c1D6W::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1D6W::I64 == 0) goto c1D6Y; else goto c1D6X;
       c1D6Y: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1D6X: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1D6W::I64;
           R2 = Data.Bits.$fBitsInteger2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.192891442 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbitSize_closure" {
     Data.Bits.$fBitsInteger_$cbitSize_closure:
         const Data.Bits.$fBitsInteger_$cbitSize_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cbitSize_entry() //  []
         { info_tbl: [(c1D76,
                       label: Data.Bits.$fBitsInteger_$cbitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D76: // global
           R2 = Data.Bits.$fBitsInteger1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.193804299 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsInteger_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsInteger_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1D7e,
                       label: Data.Bits.$fBitsInteger_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D7e: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.194786019 UTC

[section ""data" . Data.Bits.$fBitsInteger_$ctestBit_closure" {
     Data.Bits.$fBitsInteger_$ctestBit_closure:
         const Data.Bits.$fBitsInteger_$ctestBit_info;
 },
 Data.Bits.$fBitsInteger_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1D7o,
                       label: Data.Bits.$fBitsInteger_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D7o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1D7p; else goto c1D7q;
       c1D7p: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1D7q: // global
           I64[Sp - 16] = block_c1D7l_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1D7u; else goto c1D7m;
       u1D7u: // global
           call _c1D7l(R1) args: 0, res: 0, upd: 0;
       c1D7m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D7l() //  [R1]
         { info_tbl: [(c1D7l,
                       label: block_c1D7l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D7l: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.testBitInteger_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.19606669 UTC

[section ""data" . Data.Bits.$fBitsInteger_$czeroBits_closure" {
     Data.Bits.$fBitsInteger_$czeroBits_closure:
         const Data.Bits.$fBitsInteger_$czeroBits_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger_$czeroBits_entry() //  [R1]
         { info_tbl: [(c1D7B,
                       label: Data.Bits.$fBitsInteger_$czeroBits_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D7B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1D7C; else goto c1D7D;
       c1D7C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1D7D: // global
           (_c1D7y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1D7y::I64 == 0) goto c1D7A; else goto c1D7z;
       c1D7A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1D7z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1D7y::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.197267545 UTC

[section ""data" . Data.Bits.$w$cshift_closure" {
     Data.Bits.$w$cshift_closure:
         const Data.Bits.$w$cshift_info;
         const 0;
 },
 Data.Bits.$w$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1D7N,
                       label: Data.Bits.$w$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D7N: // global
           if (%MO_S_Lt_W64(R3, 0)) goto c1D7L; else goto c1D7M;
       c1D7L: // global
           R3 = -R3;
           R2 = R2;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1D7M: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.198275827 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshift_closure" {
     Data.Bits.$fBitsInteger_$cshift_closure:
         const Data.Bits.$fBitsInteger_$cshift_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1D7Z,
                       label: Data.Bits.$fBitsInteger_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D7Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1D80; else goto c1D81;
       c1D80: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1D81: // global
           I64[Sp - 16] = block_c1D7W_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1D85; else goto c1D7X;
       u1D85: // global
           call _c1D7W(R1) args: 0, res: 0, upd: 0;
       c1D7X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D7W() //  [R1]
         { info_tbl: [(c1D7W,
                       label: block_c1D7W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D7W: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Bits.$w$cshift_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.199284091 UTC

[section ""data" . sat_s1COx_closure" {
     sat_s1COx_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.199853386 UTC

[section ""data" . sat_s1COy_closure" {
     sat_s1COy_closure:
         const :_con_info;
         const sat_s1COx_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.200554492 UTC

[section ""data" . Data.Bits.$fBitsInteger3_closure" {
     Data.Bits.$fBitsInteger3_closure:
         const Data.Bits.$fBitsInteger3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger3_entry() //  [R1]
         { info_tbl: [(c1D8c,
                       label: Data.Bits.$fBitsInteger3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D8c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1D8d; else goto c1D8e;
       c1D8d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1D8e: // global
           (_c1D89::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1D89::I64 == 0) goto c1D8b; else goto c1D8a;
       c1D8b: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1D8a: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1D89::I64;
           R3 = sat_s1COy_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.20236666 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbit_closure" {
     Data.Bits.$fBitsInteger_$cbit_closure:
         const Data.Bits.$fBitsInteger_$cbit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cbit_entry() //  [R2]
         { info_tbl: [(c1D8m,
                       label: Data.Bits.$fBitsInteger_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D8m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1D8n; else goto c1D8o;
       c1D8n: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1D8o: // global
           I64[Sp - 8] = block_c1D8j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1D8z; else goto c1D8k;
       u1D8z: // global
           call _c1D8j(R1) args: 0, res: 0, upd: 0;
       c1D8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D8j() //  [R1]
         { info_tbl: [(c1D8j,
                       label: block_c1D8j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D8j: // global
           _s1COB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COB::I64, 0)) goto c1D8v; else goto c1D8w;
       c1D8v: // global
           R3 = -_s1COB::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1D8w: // global
           R3 = _s1COB::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.203827031 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cclearBit_closure" {
     Data.Bits.$fBitsInteger_$cclearBit_closure:
         const Data.Bits.$fBitsInteger_$cclearBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1D8H,
                       label: Data.Bits.$fBitsInteger_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D8H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1D8I; else goto c1D8J;
       c1D8I: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1D8J: // global
           I64[Sp - 16] = block_c1D8E_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1D9h; else goto c1D8F;
       u1D9h: // global
           call _c1D8E(R1) args: 0, res: 0, upd: 0;
       c1D8F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D8E() //  [R1]
         { info_tbl: [(c1D8E,
                       label: block_c1D8E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D8E: // global
           _s1COH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COH::I64, 0)) goto c1D8Z; else goto c1D9b;
       c1D8Z: // global
           I64[Sp] = block_c1D8T_info;
           R3 = -_s1COH::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1D9b: // global
           I64[Sp] = block_c1D96_info;
           R3 = _s1COH::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1D8T() //  [R1]
         { info_tbl: [(c1D8T,
                       label: block_c1D8T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D8T: // global
           I64[Sp] = block_c1D8X_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1D8X() //  [R1]
         { info_tbl: [(c1D8X,
                       label: block_c1D8X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D8X: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1D96() //  [R1]
         { info_tbl: [(c1D96,
                       label: block_c1D96_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D96: // global
           I64[Sp] = block_c1D9a_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1D9a() //  [R1]
         { info_tbl: [(c1D9a,
                       label: block_c1D9a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D9a: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.205803639 UTC

[section ""data" . Data.Bits.$fBitsInteger_$ccomplementBit_closure" {
     Data.Bits.$fBitsInteger_$ccomplementBit_closure:
         const Data.Bits.$fBitsInteger_$ccomplementBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1D9p,
                       label: Data.Bits.$fBitsInteger_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D9p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1D9q; else goto c1D9r;
       c1D9q: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1D9r: // global
           I64[Sp - 16] = block_c1D9m_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1D9P; else goto c1D9n;
       u1D9P: // global
           call _c1D9m(R1) args: 0, res: 0, upd: 0;
       c1D9n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D9m() //  [R1]
         { info_tbl: [(c1D9m,
                       label: block_c1D9m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D9m: // global
           _s1COR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COR::I64, 0)) goto c1D9D; else goto c1D9K;
       c1D9D: // global
           I64[Sp] = block_c1D9B_info;
           R3 = -_s1COR::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1D9K: // global
           I64[Sp] = block_c1D9J_info;
           R3 = _s1COR::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1D9B() //  [R1]
         { info_tbl: [(c1D9B,
                       label: block_c1D9B_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D9B: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1D9J() //  [R1]
         { info_tbl: [(c1D9J,
                       label: block_c1D9J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D9J: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.207533695 UTC

[section ""data" . Data.Bits.$fBitsInteger_$csetBit_closure" {
     Data.Bits.$fBitsInteger_$csetBit_closure:
         const Data.Bits.$fBitsInteger_$csetBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1D9X,
                       label: Data.Bits.$fBitsInteger_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D9X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1D9Y; else goto c1D9Z;
       c1D9Y: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1D9Z: // global
           I64[Sp - 16] = block_c1D9U_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dan; else goto c1D9V;
       u1Dan: // global
           call _c1D9U(R1) args: 0, res: 0, upd: 0;
       c1D9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1D9U() //  [R1]
         { info_tbl: [(c1D9U,
                       label: block_c1D9U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1D9U: // global
           _s1COZ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COZ::I64, 0)) goto c1Dab; else goto c1Dai;
       c1Dab: // global
           I64[Sp] = block_c1Da9_info;
           R3 = -_s1COZ::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1Dai: // global
           I64[Sp] = block_c1Dah_info;
           R3 = _s1COZ::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Da9() //  [R1]
         { info_tbl: [(c1Da9,
                       label: block_c1Da9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Da9: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1Dah() //  [R1]
         { info_tbl: [(c1Dah,
                       label: block_c1Dah_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dah: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.208995942 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsInteger_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsInteger_$cunsafeShiftL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Das,
                       label: Data.Bits.$fBitsInteger_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Das: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.209936808 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshiftL_closure" {
     Data.Bits.$fBitsInteger_$cshiftL_closure:
         const Data.Bits.$fBitsInteger_$cshiftL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Daz,
                       label: Data.Bits.$fBitsInteger_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Daz: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.210992223 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshiftR_closure" {
     Data.Bits.$fBitsInteger_$cshiftR_closure:
         const Data.Bits.$fBitsInteger_$cshiftR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1DaJ,
                       label: Data.Bits.$fBitsInteger_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DaJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DaK; else goto c1DaL;
       c1DaK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DaL: // global
           I64[Sp - 16] = block_c1DaG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DaZ; else goto c1DaH;
       u1DaZ: // global
           call _c1DaG(R1) args: 0, res: 0, upd: 0;
       c1DaH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DaG() //  [R1]
         { info_tbl: [(c1DaG,
                       label: block_c1DaG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DaG: // global
           _s1CP4::P64 = P64[Sp + 8];
           _s1CP8::I64 = -I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CP8::I64, 0)) goto c1DaV; else goto c1DaW;
       c1DaV: // global
           R3 = -_s1CP8::I64;
           R2 = _s1CP4::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1DaW: // global
           R3 = _s1CP8::I64;
           R2 = _s1CP4::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.21230226 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsInteger_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsInteger_$cunsafeShiftR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1Db4,
                       label: Data.Bits.$fBitsInteger_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Db4: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.213646041 UTC

[section ""data" . Data.Bits.$fBitsInteger_$crotateR_closure" {
     Data.Bits.$fBitsInteger_$crotateR_closure:
         const Data.Bits.$fBitsInteger_$crotateR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1Dbe,
                       label: Data.Bits.$fBitsInteger_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dbe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dbf; else goto c1Dbg;
       c1Dbf: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dbg: // global
           I64[Sp - 16] = block_c1Dbb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dbu; else goto c1Dbc;
       u1Dbu: // global
           call _c1Dbb(R1) args: 0, res: 0, upd: 0;
       c1Dbc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dbb() //  [R1]
         { info_tbl: [(c1Dbb,
                       label: block_c1Dbb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dbb: // global
           _s1CPb::P64 = P64[Sp + 8];
           _s1CPf::I64 = -I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CPf::I64, 0)) goto c1Dbq; else goto c1Dbr;
       c1Dbq: // global
           R3 = -_s1CPf::I64;
           R2 = _s1CPb::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1Dbr: // global
           R3 = _s1CPf::I64;
           R2 = _s1CPb::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.215492058 UTC

[section ""data" . Data.Bits.$fBitsInteger_$crotateL_closure" {
     Data.Bits.$fBitsInteger_$crotateL_closure:
         const Data.Bits.$fBitsInteger_$crotateL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1Dbz,
                       label: Data.Bits.$fBitsInteger_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dbz: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.216494093 UTC

[section ""data" . Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1DbN,
                       label: Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DbN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1DbO; else goto c1DbP;
       c1DbO: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1DbP: // global
           I64[Sp - 8] = block_c1DbG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1DbW; else goto c1DbH;
       u1DbW: // global
           call _c1DbG(R1) args: 0, res: 0, upd: 0;
       c1DbH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DbG() //  [R1]
         { info_tbl: [(c1DbG,
                       label: block_c1DbG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DbG: // global
           if (R1 & 7 == 1) goto c1DbK; else goto c1DbL;
       c1DbK: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DbL: // global
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.217855657 UTC

[section ""data" . Data.Bits.$fBitsInt_$cpopCount_closure" {
     Data.Bits.$fBitsInt_$cpopCount_closure:
         const Data.Bits.$fBitsInt_$cpopCount_info;
 },
 Data.Bits.$fBitsInt_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1Dc4,
                       label: Data.Bits.$fBitsInt_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dc4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Dci; else goto c1Dcj;
       c1Dci: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Dcj: // global
           I64[Sp - 8] = block_c1Dc1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Dcn; else goto c1Dc2;
       u1Dcn: // global
           call _c1Dc1(R1) args: 0, res: 0, upd: 0;
       c1Dc2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dc1() //  [R1]
         { info_tbl: [(c1Dc1,
                       label: block_c1Dc1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dc1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dcm; else goto c1Dcl;
       c1Dcm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dcl: // global
           (_c1Dca::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1Dca::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.219301706 UTC

[section ""data" . Data.Bits.$fBitsInt_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsInt_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsInt_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsInt_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1Dcv,
                       label: Data.Bits.$fBitsInt_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dcv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DcH; else goto c1DcI;
       c1DcH: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DcI: // global
           I64[Sp - 16] = block_c1Dcs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DcO; else goto c1Dct;
       u1DcO: // global
           call _c1Dcs(R1) args: 0, res: 0, upd: 0;
       c1Dct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dcs() //  [R1]
         { info_tbl: [(c1Dcs,
                       label: block_c1Dcs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dcs: // global
           I64[Sp] = block_c1Dcy_info;
           _s1CPt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPt::I64;
           if (R1 & 7 != 0) goto u1DcN; else goto c1Dcz;
       u1DcN: // global
           call _c1Dcy(R1) args: 0, res: 0, upd: 0;
       c1Dcz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dcy() //  [R1]
         { info_tbl: [(c1Dcy,
                       label: block_c1Dcy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dcy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DcM; else goto c1DcL;
       c1DcM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DcL: // global
           _s1CPw::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CPw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.220699821 UTC

[section ""data" . lvl_r1CDD_closure" {
     lvl_r1CDD_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.222138699 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshiftR_closure" {
     Data.Bits.$fBitsInt_$cshiftR_closure:
         const Data.Bits.$fBitsInt_$cshiftR_info;
 },
 Data.Bits.$fBitsInt_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1DcW,
                       label: Data.Bits.$fBitsInt_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DcW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dd0; else goto c1Dd1;
       c1Dd0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dd1: // global
           I64[Sp - 16] = block_c1DcT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Ddr; else goto c1DcU;
       u1Ddr: // global
           call _c1DcT(R1) args: 0, res: 0, upd: 0;
       c1DcU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DcT() //  [R1]
         { info_tbl: [(c1DcT,
                       label: block_c1DcT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DcT: // global
           I64[Sp] = block_c1DcZ_info;
           _s1CPA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPA::I64;
           if (R1 & 7 != 0) goto u1Ddq; else goto c1Dd3;
       u1Ddq: // global
           call _c1DcZ(R1) args: 0, res: 0, upd: 0;
       c1Dd3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DcZ() //  [R1]
         { info_tbl: [(c1DcZ,
                       label: block_c1DcZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DcZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dd9; else goto c1Dd8;
       c1Dd9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dd8: // global
           _s1CPA::I64 = I64[Sp + 8];
           _s1CPC::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CPC::I64, 64)) goto c1Ddi; else goto c1Ddp;
       c1Ddi: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s1CPA::I64, _s1CPC::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Ddp: // global
           if (%MO_S_Ge_W64(_s1CPA::I64, 0)) goto c1Ddn; else goto c1Ddo;
       c1Ddn: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Ddo: // global
           Hp = Hp - 16;
           R1 = lvl_r1CDD_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.223950339 UTC

[section ""data" . Data.Bits.$fBitsInt_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsInt_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsInt_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsInt_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Ddz,
                       label: Data.Bits.$fBitsInt_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ddz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DdL; else goto c1DdM;
       c1DdL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DdM: // global
           I64[Sp - 16] = block_c1Ddw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DdS; else goto c1Ddx;
       u1DdS: // global
           call _c1Ddw(R1) args: 0, res: 0, upd: 0;
       c1Ddx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ddw() //  [R1]
         { info_tbl: [(c1Ddw,
                       label: block_c1Ddw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ddw: // global
           I64[Sp] = block_c1DdC_info;
           _s1CPJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPJ::I64;
           if (R1 & 7 != 0) goto u1DdR; else goto c1DdD;
       u1DdR: // global
           call _c1DdC(R1) args: 0, res: 0, upd: 0;
       c1DdD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DdC() //  [R1]
         { info_tbl: [(c1DdC,
                       label: block_c1DdC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DdC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DdQ; else goto c1DdP;
       c1DdQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DdP: // global
           _s1CPM::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CPM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.22575724 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshiftL_closure" {
     Data.Bits.$fBitsInt_$cshiftL_closure:
         const Data.Bits.$fBitsInt_$cshiftL_info;
 },
 Data.Bits.$fBitsInt_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1De0,
                       label: Data.Bits.$fBitsInt_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1De0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1De4; else goto c1De5;
       c1De4: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1De5: // global
           I64[Sp - 16] = block_c1DdX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dep; else goto c1DdY;
       u1Dep: // global
           call _c1DdX(R1) args: 0, res: 0, upd: 0;
       c1DdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DdX() //  [R1]
         { info_tbl: [(c1DdX,
                       label: block_c1DdX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DdX: // global
           I64[Sp] = block_c1De3_info;
           _s1CPQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPQ::I64;
           if (R1 & 7 != 0) goto u1Deo; else goto c1De7;
       u1Deo: // global
           call _c1De3(R1) args: 0, res: 0, upd: 0;
       c1De7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1De3() //  [R1]
         { info_tbl: [(c1De3,
                       label: block_c1De3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1De3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ded; else goto c1Dec;
       c1Ded: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dec: // global
           _s1CPS::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CPS::I64, 64)) goto c1Dem; else goto c1Den;
       c1Dem: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] << _s1CPS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Den: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.227221547 UTC

[section ""data" . Data.Bits.$fBitsInt_$cisSigned_closure" {
     Data.Bits.$fBitsInt_$cisSigned_closure:
         const Data.Bits.$fBitsInt_$cisSigned_info;
 },
 Data.Bits.$fBitsInt_$cisSigned_entry() //  []
         { info_tbl: [(c1Deu,
                       label: Data.Bits.$fBitsInt_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Deu: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.228950675 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotate_closure" {
     Data.Bits.$fBitsInt_$crotate_closure:
         const Data.Bits.$fBitsInt_$crotate_info;
 },
 Data.Bits.$fBitsInt_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c1DeE,
                       label: Data.Bits.$fBitsInt_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DeE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Df2; else goto c1Df3;
       c1Df2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Df3: // global
           I64[Sp - 16] = block_c1DeB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Df9; else goto c1DeC;
       u1Df9: // global
           call _c1DeB(R1) args: 0, res: 0, upd: 0;
       c1DeC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DeB() //  [R1]
         { info_tbl: [(c1DeB,
                       label: block_c1DeB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DeB: // global
           I64[Sp] = block_c1DeH_info;
           _s1CPZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPZ::I64;
           if (R1 & 7 != 0) goto u1Df8; else goto c1DeI;
       u1Df8: // global
           call _c1DeH(R1) args: 0, res: 0, upd: 0;
       c1DeI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DeH() //  [R1]
         { info_tbl: [(c1DeH,
                       label: block_c1DeH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DeH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Df7; else goto c1Df6;
       c1Df7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Df6: // global
           _s1CQ2::I64 = I64[R1 + 7] & 63;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _s1CPZ::I64 = I64[Sp + 8];
           I64[Hp] = (_s1CPZ::I64 << _s1CQ2::I64) | (_s1CPZ::I64 >> 64 - _s1CQ2::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.230924554 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshift_closure" {
     Data.Bits.$fBitsInt_$cshift_closure:
         const Data.Bits.$fBitsInt_$cshift_info;
 },
 Data.Bits.$fBitsInt_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1Dfh,
                       label: Data.Bits.$fBitsInt_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dfh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dfl; else goto c1Dfm;
       c1Dfl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dfm: // global
           I64[Sp - 16] = block_c1Dfe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dg6; else goto c1Dff;
       u1Dg6: // global
           call _c1Dfe(R1) args: 0, res: 0, upd: 0;
       c1Dff: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dfe() //  [R1]
         { info_tbl: [(c1Dfe,
                       label: block_c1Dfe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dfe: // global
           I64[Sp] = block_c1Dfk_info;
           _s1CQa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQa::I64;
           if (R1 & 7 != 0) goto u1Dg5; else goto c1Dfo;
       u1Dg5: // global
           call _c1Dfk(R1) args: 0, res: 0, upd: 0;
       c1Dfo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dfk() //  [R1]
         { info_tbl: [(c1Dfk,
                       label: block_c1Dfk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dfk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dfu; else goto c1Dft;
       c1Dfu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dft: // global
           _s1CQa::I64 = I64[Sp + 8];
           _s1CQc::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CQc::I64, 0)) goto c1DfS; else goto c1Dg4;
       c1DfS: // global
           _s1CQe::I64 = -_s1CQc::I64;
           if (%MO_S_Lt_W64(_s1CQe::I64, 64)) goto c1DfJ; else goto c1DfQ;
       c1DfJ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s1CQa::I64, _s1CQe::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DfQ: // global
           if (%MO_S_Ge_W64(_s1CQa::I64, 0)) goto c1Dg3; else goto c1DfP;
       c1DfP: // global
           Hp = Hp - 16;
           R1 = lvl_r1CDD_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Dg4: // global
           if (%MO_S_Ge_W64(_s1CQc::I64, 64)) goto c1Dg3; else goto c1Dg2;
       c1Dg3: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Dg2: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQa::I64 << _s1CQc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.23280978 UTC

[section ""data" . Data.Bits.$fBitsInt_$ccomplement_closure" {
     Data.Bits.$fBitsInt_$ccomplement_closure:
         const Data.Bits.$fBitsInt_$ccomplement_info;
 },
 Data.Bits.$fBitsInt_$ccomplement_entry() //  [R2]
         { info_tbl: [(c1Dge,
                       label: Data.Bits.$fBitsInt_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dge: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Dgl; else goto c1Dgm;
       c1Dgl: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Dgm: // global
           I64[Sp - 8] = block_c1Dgb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Dgq; else goto c1Dgc;
       u1Dgq: // global
           call _c1Dgb(R1) args: 0, res: 0, upd: 0;
       c1Dgc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dgb() //  [R1]
         { info_tbl: [(c1Dgb,
                       label: block_c1Dgb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dgb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dgp; else goto c1Dgo;
       c1Dgp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dgo: // global
           _s1CQn::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQn::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.234459306 UTC

[section ""data" . Data.Bits.$fBitsInt_$cxor_closure" {
     Data.Bits.$fBitsInt_$cxor_closure:
         const Data.Bits.$fBitsInt_$cxor_info;
 },
 Data.Bits.$fBitsInt_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c1Dgy,
                       label: Data.Bits.$fBitsInt_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dgy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DgK; else goto c1DgL;
       c1DgK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DgL: // global
           I64[Sp - 16] = block_c1Dgv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DgR; else goto c1Dgw;
       u1DgR: // global
           call _c1Dgv(R1) args: 0, res: 0, upd: 0;
       c1Dgw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dgv() //  [R1]
         { info_tbl: [(c1Dgv,
                       label: block_c1Dgv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dgv: // global
           I64[Sp] = block_c1DgB_info;
           _s1CQr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQr::I64;
           if (R1 & 7 != 0) goto u1DgQ; else goto c1DgC;
       u1DgQ: // global
           call _c1DgB(R1) args: 0, res: 0, upd: 0;
       c1DgC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DgB() //  [R1]
         { info_tbl: [(c1DgB,
                       label: block_c1DgB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DgB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DgP; else goto c1DgO;
       c1DgP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DgO: // global
           _s1CQu::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.236132154 UTC

[section ""data" . Data.Bits.$fBitsInt_$c.|._closure" {
     Data.Bits.$fBitsInt_$c.|._closure:
         const Data.Bits.$fBitsInt_$c.|._info;
 },
 Data.Bits.$fBitsInt_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c1DgZ,
                       label: Data.Bits.$fBitsInt_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DgZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dhb; else goto c1Dhc;
       c1Dhb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dhc: // global
           I64[Sp - 16] = block_c1DgW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dhi; else goto c1DgX;
       u1Dhi: // global
           call _c1DgW(R1) args: 0, res: 0, upd: 0;
       c1DgX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DgW() //  [R1]
         { info_tbl: [(c1DgW,
                       label: block_c1DgW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DgW: // global
           I64[Sp] = block_c1Dh2_info;
           _s1CQy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQy::I64;
           if (R1 & 7 != 0) goto u1Dhh; else goto c1Dh3;
       u1Dhh: // global
           call _c1Dh2(R1) args: 0, res: 0, upd: 0;
       c1Dh3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dh2() //  [R1]
         { info_tbl: [(c1Dh2,
                       label: block_c1Dh2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dh2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dhg; else goto c1Dhf;
       c1Dhg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dhf: // global
           _s1CQB::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.237776252 UTC

[section ""data" . Data.Bits.$fBitsInt_$c.&._closure" {
     Data.Bits.$fBitsInt_$c.&._closure:
         const Data.Bits.$fBitsInt_$c.&._info;
 },
 Data.Bits.$fBitsInt_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c1Dhq,
                       label: Data.Bits.$fBitsInt_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dhq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DhC; else goto c1DhD;
       c1DhC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DhD: // global
           I64[Sp - 16] = block_c1Dhn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DhJ; else goto c1Dho;
       u1DhJ: // global
           call _c1Dhn(R1) args: 0, res: 0, upd: 0;
       c1Dho: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dhn() //  [R1]
         { info_tbl: [(c1Dhn,
                       label: block_c1Dhn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dhn: // global
           I64[Sp] = block_c1Dht_info;
           _s1CQF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQF::I64;
           if (R1 & 7 != 0) goto u1DhI; else goto c1Dhu;
       u1DhI: // global
           call _c1Dht(R1) args: 0, res: 0, upd: 0;
       c1Dhu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dht() //  [R1]
         { info_tbl: [(c1Dht,
                       label: block_c1Dht_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dht: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DhH; else goto c1DhG;
       c1DhH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DhG: // global
           _s1CQI::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.239390539 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1DhR,
                       label: Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DhR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Di5; else goto c1Di6;
       c1Di5: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Di6: // global
           I64[Sp - 8] = block_c1DhO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Dia; else goto c1DhP;
       u1Dia: // global
           call _c1DhO(R1) args: 0, res: 0, upd: 0;
       c1DhP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DhO() //  [R1]
         { info_tbl: [(c1DhO,
                       label: block_c1DhO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DhO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Di9; else goto c1Di8;
       c1Di9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Di8: // global
           (_c1DhX::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1DhX::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.240848964 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure" {
     Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure:
         const Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_info;
 },
 Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1Dii,
                       label: Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dii: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Diw; else goto c1Dix;
       c1Diw: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Dix: // global
           I64[Sp - 8] = block_c1Dif_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1DiB; else goto c1Dig;
       u1DiB: // global
           call _c1Dif(R1) args: 0, res: 0, upd: 0;
       c1Dig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dif() //  [R1]
         { info_tbl: [(c1Dif,
                       label: block_c1Dif_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dif: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DiA; else goto c1Diz;
       c1DiA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Diz: // global
           (_c1Dio::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1Dio::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.242624195 UTC

[section ""data" . Data.Bits.$fBitsInt1_closure" {
     Data.Bits.$fBitsInt1_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.243301913 UTC

[section ""data" . Data.Bits.$fBitsInt_$cfiniteBitSize_closure" {
     Data.Bits.$fBitsInt_$cfiniteBitSize_closure:
         const Data.Bits.$fBitsInt_$cfiniteBitSize_info;
 },
 Data.Bits.$fBitsInt_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c1DiG,
                       label: Data.Bits.$fBitsInt_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DiG: // global
           R1 = Data.Bits.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.24428175 UTC

[section ""data" . Data.Bits.$fBitsWord_$cpopCount_closure" {
     Data.Bits.$fBitsWord_$cpopCount_closure:
         const Data.Bits.$fBitsWord_$cpopCount_info;
 },
 Data.Bits.$fBitsWord_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1DiQ,
                       label: Data.Bits.$fBitsWord_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DiQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Dj1; else goto c1Dj2;
       c1Dj1: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Dj2: // global
           I64[Sp - 8] = block_c1DiN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Dj6; else goto c1DiO;
       u1Dj6: // global
           call _c1DiN(R1) args: 0, res: 0, upd: 0;
       c1DiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DiN() //  [R1]
         { info_tbl: [(c1DiN,
                       label: block_c1DiN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DiN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dj5; else goto c1Dj4;
       c1Dj5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dj4: // global
           (_c1DiT::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1DiT::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.245757159 UTC

[section ""data" . Data.Bits.$fBitsWord_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsWord_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsWord_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsWord_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1Dje,
                       label: Data.Bits.$fBitsWord_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dje: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Djq; else goto c1Djr;
       c1Djq: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Djr: // global
           I64[Sp - 16] = block_c1Djb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Djx; else goto c1Djc;
       u1Djx: // global
           call _c1Djb(R1) args: 0, res: 0, upd: 0;
       c1Djc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Djb() //  [R1]
         { info_tbl: [(c1Djb,
                       label: block_c1Djb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Djb: // global
           I64[Sp] = block_c1Djh_info;
           _s1CR4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CR4::I64;
           if (R1 & 7 != 0) goto u1Djw; else goto c1Dji;
       u1Djw: // global
           call _c1Djh(R1) args: 0, res: 0, upd: 0;
       c1Dji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Djh() //  [R1]
         { info_tbl: [(c1Djh,
                       label: block_c1Djh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Djh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Djv; else goto c1Dju;
       c1Djv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dju: // global
           _s1CR7::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CR7::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.24711321 UTC

[section ""data" . Data.Bits.$fBitsWord1_closure" {
     Data.Bits.$fBitsWord1_closure:
         const GHC.Types.W#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.248090113 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshiftR_closure" {
     Data.Bits.$fBitsWord_$cshiftR_closure:
         const Data.Bits.$fBitsWord_$cshiftR_info;
 },
 Data.Bits.$fBitsWord_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1DjF,
                       label: Data.Bits.$fBitsWord_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DjF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DjJ; else goto c1DjK;
       c1DjJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DjK: // global
           I64[Sp - 16] = block_c1DjC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dk4; else goto c1DjD;
       u1Dk4: // global
           call _c1DjC(R1) args: 0, res: 0, upd: 0;
       c1DjD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DjC() //  [R1]
         { info_tbl: [(c1DjC,
                       label: block_c1DjC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DjC: // global
           I64[Sp] = block_c1DjI_info;
           _s1CRb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRb::I64;
           if (R1 & 7 != 0) goto u1Dk3; else goto c1DjM;
       u1Dk3: // global
           call _c1DjI(R1) args: 0, res: 0, upd: 0;
       c1DjM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DjI() //  [R1]
         { info_tbl: [(c1DjI,
                       label: block_c1DjI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DjI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DjS; else goto c1DjR;
       c1DjS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DjR: // global
           _s1CRd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CRd::I64, 64)) goto c1Dk1; else goto c1Dk2;
       c1Dk1: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s1CRd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Dk2: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.25017821 UTC

[section ""data" . Data.Bits.$fBitsWord_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsWord_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsWord_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsWord_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Dkc,
                       label: Data.Bits.$fBitsWord_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dkc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dko; else goto c1Dkp;
       c1Dko: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dkp: // global
           I64[Sp - 16] = block_c1Dk9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dkv; else goto c1Dka;
       u1Dkv: // global
           call _c1Dk9(R1) args: 0, res: 0, upd: 0;
       c1Dka: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dk9() //  [R1]
         { info_tbl: [(c1Dk9,
                       label: block_c1Dk9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dk9: // global
           I64[Sp] = block_c1Dkf_info;
           _s1CRj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRj::I64;
           if (R1 & 7 != 0) goto u1Dku; else goto c1Dkg;
       u1Dku: // global
           call _c1Dkf(R1) args: 0, res: 0, upd: 0;
       c1Dkg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dkf() //  [R1]
         { info_tbl: [(c1Dkf,
                       label: block_c1Dkf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dkf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dkt; else goto c1Dks;
       c1Dkt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dks: // global
           _s1CRm::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.251890922 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshiftL_closure" {
     Data.Bits.$fBitsWord_$cshiftL_closure:
         const Data.Bits.$fBitsWord_$cshiftL_info;
 },
 Data.Bits.$fBitsWord_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1DkD,
                       label: Data.Bits.$fBitsWord_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DkD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DkH; else goto c1DkI;
       c1DkH: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DkI: // global
           I64[Sp - 16] = block_c1DkA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dl2; else goto c1DkB;
       u1Dl2: // global
           call _c1DkA(R1) args: 0, res: 0, upd: 0;
       c1DkB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DkA() //  [R1]
         { info_tbl: [(c1DkA,
                       label: block_c1DkA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DkA: // global
           I64[Sp] = block_c1DkG_info;
           _s1CRq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRq::I64;
           if (R1 & 7 != 0) goto u1Dl1; else goto c1DkK;
       u1Dl1: // global
           call _c1DkG(R1) args: 0, res: 0, upd: 0;
       c1DkK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DkG() //  [R1]
         { info_tbl: [(c1DkG,
                       label: block_c1DkG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DkG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DkQ; else goto c1DkP;
       c1DkQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DkP: // global
           _s1CRs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CRs::I64, 64)) goto c1DkZ; else goto c1Dl0;
       c1DkZ: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] << _s1CRs::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Dl0: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.253501381 UTC

[section ""data" . Data.Bits.$fBitsWord_$cisSigned_closure" {
     Data.Bits.$fBitsWord_$cisSigned_closure:
         const Data.Bits.$fBitsWord_$cisSigned_info;
 },
 Data.Bits.$fBitsWord_$cisSigned_entry() //  []
         { info_tbl: [(c1Dl7,
                       label: Data.Bits.$fBitsWord_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dl7: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.255378134 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotate_closure" {
     Data.Bits.$fBitsWord_$crotate_closure:
         const Data.Bits.$fBitsWord_$crotate_info;
 },
 Data.Bits.$fBitsWord_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c1Dlh,
                       label: Data.Bits.$fBitsWord_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dlh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dll; else goto c1Dlm;
       c1Dll: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dlm: // global
           I64[Sp - 16] = block_c1Dle_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dm0; else goto c1Dlf;
       u1Dm0: // global
           call _c1Dle(R1) args: 0, res: 0, upd: 0;
       c1Dlf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dle() //  [R1]
         { info_tbl: [(c1Dle,
                       label: block_c1Dle_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dle: // global
           I64[Sp - 8] = block_c1Dlk_info;
           _s1CRy::P64 = R1;
           _s1CRz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CRz::I64;
           P64[Sp + 8] = _s1CRy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1DlZ; else goto c1Dlo;
       u1DlZ: // global
           call _c1Dlk(R1) args: 0, res: 0, upd: 0;
       c1Dlo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dlk() //  [R1]
         { info_tbl: [(c1Dlk,
                       label: block_c1Dlk_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dlk: // global
           _s1CRC::I64 = I64[R1 + 7] & 63;
           if (_s1CRC::I64 != 0) goto u1DlX; else goto c1DlT;
       u1DlX: // global
           I64[Sp + 16] = _s1CRC::I64;
           Sp = Sp + 8;
           call _c1Dlx() args: 0, res: 0, upd: 0;
       c1DlT: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Dlx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dlx: // global
           Hp = Hp + 16;
           _s1CRC::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1DlQ; else goto c1DlP;
       c1DlQ: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1Dlw_info;
           R1 = _s1CRC::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1DlP: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           _s1CRz::I64 = I64[Sp];
           I64[Hp] = (_s1CRz::I64 << _s1CRC::I64) | (_s1CRz::I64 >> 64 - _s1CRC::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Dlw() //  [R1]
         { info_tbl: [(c1Dlw,
                       label: block_c1Dlw_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dlw: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1Dlx() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.257707181 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshift_closure" {
     Data.Bits.$fBitsWord_$cshift_closure:
         const Data.Bits.$fBitsWord_$cshift_info;
 },
 Data.Bits.$fBitsWord_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1Dma,
                       label: Data.Bits.$fBitsWord_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dma: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dme; else goto c1Dmf;
       c1Dme: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dmf: // global
           I64[Sp - 16] = block_c1Dm7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DmT; else goto c1Dm8;
       u1DmT: // global
           call _c1Dm7(R1) args: 0, res: 0, upd: 0;
       c1Dm8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dm7() //  [R1]
         { info_tbl: [(c1Dm7,
                       label: block_c1Dm7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dm7: // global
           I64[Sp] = block_c1Dmd_info;
           _s1CRK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRK::I64;
           if (R1 & 7 != 0) goto u1DmS; else goto c1Dmh;
       u1DmS: // global
           call _c1Dmd(R1) args: 0, res: 0, upd: 0;
       c1Dmh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dmd() //  [R1]
         { info_tbl: [(c1Dmd,
                       label: block_c1Dmd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dmd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dmn; else goto c1Dmm;
       c1Dmn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dmm: // global
           _s1CRK::I64 = I64[Sp + 8];
           _s1CRM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CRM::I64, 0)) goto c1DmF; else goto c1DmR;
       c1DmF: // global
           _s1CRO::I64 = -_s1CRM::I64;
           if (%MO_S_Ge_W64(_s1CRO::I64, 64)) goto c1DmQ; else goto c1DmC;
       c1DmC: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRK::I64 >> _s1CRO::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DmR: // global
           if (%MO_S_Ge_W64(_s1CRM::I64, 64)) goto c1DmQ; else goto c1DmP;
       c1DmQ: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DmP: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRK::I64 << _s1CRM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.259545028 UTC

[section ""data" . Data.Bits.$fBitsWord_$ccomplement_closure" {
     Data.Bits.$fBitsWord_$ccomplement_closure:
         const Data.Bits.$fBitsWord_$ccomplement_info;
 },
 Data.Bits.$fBitsWord_$ccomplement_entry() //  [R2]
         { info_tbl: [(c1Dn1,
                       label: Data.Bits.$fBitsWord_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dn1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Dn8; else goto c1Dn9;
       c1Dn8: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Dn9: // global
           I64[Sp - 8] = block_c1DmY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Dnd; else goto c1DmZ;
       u1Dnd: // global
           call _c1DmY(R1) args: 0, res: 0, upd: 0;
       c1DmZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DmY() //  [R1]
         { info_tbl: [(c1DmY,
                       label: block_c1DmY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DmY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dnc; else goto c1Dnb;
       c1Dnc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dnb: // global
           _s1CRW::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.260994779 UTC

[section ""data" . Data.Bits.$fBitsWord_$cxor_closure" {
     Data.Bits.$fBitsWord_$cxor_closure:
         const Data.Bits.$fBitsWord_$cxor_info;
 },
 Data.Bits.$fBitsWord_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c1Dnl,
                       label: Data.Bits.$fBitsWord_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dnl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dnx; else goto c1Dny;
       c1Dnx: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dny: // global
           I64[Sp - 16] = block_c1Dni_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DnE; else goto c1Dnj;
       u1DnE: // global
           call _c1Dni(R1) args: 0, res: 0, upd: 0;
       c1Dnj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dni() //  [R1]
         { info_tbl: [(c1Dni,
                       label: block_c1Dni_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dni: // global
           I64[Sp] = block_c1Dno_info;
           _s1CS0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CS0::I64;
           if (R1 & 7 != 0) goto u1DnD; else goto c1Dnp;
       u1DnD: // global
           call _c1Dno(R1) args: 0, res: 0, upd: 0;
       c1Dnp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dno() //  [R1]
         { info_tbl: [(c1Dno,
                       label: block_c1Dno_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dno: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DnC; else goto c1DnB;
       c1DnC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DnB: // global
           _s1CS3::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CS3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.262668722 UTC

[section ""data" . Data.Bits.$fBitsWord_$c.|._closure" {
     Data.Bits.$fBitsWord_$c.|._closure:
         const Data.Bits.$fBitsWord_$c.|._info;
 },
 Data.Bits.$fBitsWord_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c1DnM,
                       label: Data.Bits.$fBitsWord_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DnM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DnY; else goto c1DnZ;
       c1DnY: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DnZ: // global
           I64[Sp - 16] = block_c1DnJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Do5; else goto c1DnK;
       u1Do5: // global
           call _c1DnJ(R1) args: 0, res: 0, upd: 0;
       c1DnK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DnJ() //  [R1]
         { info_tbl: [(c1DnJ,
                       label: block_c1DnJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DnJ: // global
           I64[Sp] = block_c1DnP_info;
           _s1CS7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CS7::I64;
           if (R1 & 7 != 0) goto u1Do4; else goto c1DnQ;
       u1Do4: // global
           call _c1DnP(R1) args: 0, res: 0, upd: 0;
       c1DnQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DnP() //  [R1]
         { info_tbl: [(c1DnP,
                       label: block_c1DnP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DnP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Do3; else goto c1Do2;
       c1Do3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Do2: // global
           _s1CSa::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CSa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.264376773 UTC

[section ""data" . Data.Bits.$fBitsWord_$c.&._closure" {
     Data.Bits.$fBitsWord_$c.&._closure:
         const Data.Bits.$fBitsWord_$c.&._info;
 },
 Data.Bits.$fBitsWord_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c1Dod,
                       label: Data.Bits.$fBitsWord_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dod: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dop; else goto c1Doq;
       c1Dop: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Doq: // global
           I64[Sp - 16] = block_c1Doa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dow; else goto c1Dob;
       u1Dow: // global
           call _c1Doa(R1) args: 0, res: 0, upd: 0;
       c1Dob: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Doa() //  [R1]
         { info_tbl: [(c1Doa,
                       label: block_c1Doa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Doa: // global
           I64[Sp] = block_c1Dog_info;
           _s1CSe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CSe::I64;
           if (R1 & 7 != 0) goto u1Dov; else goto c1Doh;
       u1Dov: // global
           call _c1Dog(R1) args: 0, res: 0, upd: 0;
       c1Doh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dog() //  [R1]
         { info_tbl: [(c1Dog,
                       label: block_c1Dog_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dog: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dou; else goto c1Dot;
       c1Dou: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dot: // global
           _s1CSh::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CSh::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.266321186 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1DoE,
                       label: Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DoE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1DoP; else goto c1DoQ;
       c1DoP: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1DoQ: // global
           I64[Sp - 8] = block_c1DoB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1DoU; else goto c1DoC;
       u1DoU: // global
           call _c1DoB(R1) args: 0, res: 0, upd: 0;
       c1DoC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DoB() //  [R1]
         { info_tbl: [(c1DoB,
                       label: block_c1DoB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DoB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DoT; else goto c1DoS;
       c1DoT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DoS: // global
           (_c1DoH::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1DoH::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.26830143 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure" {
     Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure:
         const Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_info;
 },
 Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1Dp2,
                       label: Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dp2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Dpd; else goto c1Dpe;
       c1Dpd: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Dpe: // global
           I64[Sp - 8] = block_c1DoZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Dpi; else goto c1Dp0;
       u1Dpi: // global
           call _c1DoZ(R1) args: 0, res: 0, upd: 0;
       c1Dp0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DoZ() //  [R1]
         { info_tbl: [(c1DoZ,
                       label: block_c1DoZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DoZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dph; else goto c1Dpg;
       c1Dph: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dpg: // global
           (_c1Dp5::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1Dp5::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.269544867 UTC

[section ""data" . Data.Bits.$fBitsWord_$cfiniteBitSize_closure" {
     Data.Bits.$fBitsWord_$cfiniteBitSize_closure:
         const Data.Bits.$fBitsWord_$cfiniteBitSize_info;
 },
 Data.Bits.$fBitsWord_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c1Dpn,
                       label: Data.Bits.$fBitsWord_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dpn: // global
           R1 = Data.Bits.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.271149353 UTC

[section ""data" . Data.Bits.$dmcountTrailingZeros_closure" {
     Data.Bits.$dmcountTrailingZeros_closure:
         const Data.Bits.$dmcountTrailingZeros_info;
 },
 $dBits_s1CSx_entry() //  [R1]
         { info_tbl: [(c1DpC,
                       label: $dBits_s1CSx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DpC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DpD; else goto c1DpE;
       c1DpD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DpE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcountTrailingZeros_entry() //  [R2, R3]
         { info_tbl: [(c1DpF,
                       label: Data.Bits.$dmcountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DpF: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1DpG; else goto c1DpH;
       c1DpG: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmcountTrailingZeros_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DpH: // global
           I64[Sp - 24] = block_c1Dpu_info;
           _s1CSt::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R3;
           P64[Sp - 16] = _s1CSt::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1Dpu() //  [R1]
         { info_tbl: [(c1Dpu,
                       label: block_c1Dpu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dpu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1DpK; else goto c1DpJ;
       c1DpK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DpJ: // global
           _s1CSw::I64 = I64[R1 + 7];
           I64[Hp - 16] = $dBits_s1CSx_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           I64[Sp] = _s1CSw::I64;
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call _c1DpO() args: 0, res: 0, upd: 0;
     }
 },
 _c1DpO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DpO: // global
           Hp = Hp + 16;
           _s1CSz::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c1DpS; else goto c1DpR;
       c1DpS: // global
           HpAlloc = 16;
           I64[Sp] = block_c1DpN_info;
           R1 = _s1CSz::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1DpR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CSz::I64;
           _c1DpT::P64 = Hp - 7;
           if (%MO_S_Lt_W64(_s1CSz::I64,
                            I64[Sp + 8])) goto c1DpZ; else goto u1Dqf;
       c1DpZ: // global
           I64[Sp - 16] = block_c1DpX_info;
           R2 = P64[Sp + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[Sp + 24];
           P64[Sp - 24] = _c1DpT::P64;
           P64[Sp - 8] = _c1DpT::P64;
           Sp = Sp - 40;
           call Data.Bits.testBit_entry(R2) args: 32, res: 8, upd: 8;
       u1Dqf: // global
           P64[Sp + 24] = _c1DpT::P64;
           Sp = Sp + 24;
           call _c1Dqa() args: 0, res: 0, upd: 0;
     }
 },
 _c1DpN() //  [R1]
         { info_tbl: [(c1DpN,
                       label: block_c1DpN_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DpN: // global
           I64[Sp] = R1;
           call _c1DpO() args: 0, res: 0, upd: 0;
     }
 },
 _c1DpX() //  [R1]
         { info_tbl: [(c1DpX,
                       label: block_c1DpX_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DpX: // global
           if (R1 & 7 == 1) goto c1Dq5; else goto u1Dqg;
       c1Dq5: // global
           I64[Sp + 16] = I64[Sp + 16] + 1;
           Sp = Sp + 16;
           call _c1DpO() args: 0, res: 0, upd: 0;
       u1Dqg: // global
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call _c1Dqa() args: 0, res: 0, upd: 0;
     }
 },
 _c1Dqa() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dqa: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.274445795 UTC

[section ""data" . Data.Bits.$dmcountLeadingZeros_closure" {
     Data.Bits.$dmcountLeadingZeros_closure:
         const Data.Bits.$dmcountLeadingZeros_info;
 },
 $dBits_s1CSI_entry() //  [R1]
         { info_tbl: [(c1Dqz,
                       label: $dBits_s1CSI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dqz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DqA; else goto c1DqB;
       c1DqA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DqB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcountLeadingZeros_entry() //  [R2, R3]
         { info_tbl: [(c1DqC,
                       label: Data.Bits.$dmcountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DqC: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1DqD; else goto c1DqE;
       c1DqD: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmcountLeadingZeros_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DqE: // global
           I64[Sp - 24] = block_c1Dqr_info;
           _s1CSE::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R3;
           P64[Sp - 16] = _s1CSE::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1Dqr() //  [R1]
         { info_tbl: [(c1Dqr,
                       label: block_c1Dqr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dqr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1DqH; else goto c1DqG;
       c1DqH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DqG: // global
           _s1CSH::I64 = I64[R1 + 7];
           I64[Hp - 16] = $dBits_s1CSI_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = _s1CSH::I64 - 1;
           I64[Sp] = _s1CSH::I64;
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call _c1Dri() args: 0, res: 0, upd: 0;
     }
 },
 _c1Dri() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dri: // global
           Hp = Hp + 16;
           _s1CSS::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c1Drm; else goto c1Drl;
       c1Drm: // global
           HpAlloc = 16;
           I64[Sp] = block_c1Drh_info;
           R1 = _s1CSS::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1Drl: // global
           if (%MO_S_Ge_W64(_s1CSS::I64, 0)) goto c1Drt; else goto c1DrE;
       c1Drt: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CSS::I64;
           I64[Sp - 8] = block_c1Drr_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = Hp - 7;
           Sp = Sp - 32;
           call Data.Bits.testBit_entry(R2) args: 32, res: 8, upd: 8;
       c1DrE: // global
           Hp = Hp - 16;
           I64[Sp + 24] = _s1CSS::I64;
           Sp = Sp + 8;
           call _c1Dr3() args: 0, res: 0, upd: 0;
     }
 },
 _c1Drh() //  [R1]
         { info_tbl: [(c1Drh,
                       label: block_c1Drh_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Drh: // global
           I64[Sp] = R1;
           call _c1Dri() args: 0, res: 0, upd: 0;
     }
 },
 _c1Drr() //  [R1]
         { info_tbl: [(c1Drr,
                       label: block_c1Drr_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Drr: // global
           _s1CSS::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c1Drz; else goto c1DrD;
       c1Drz: // global
           I64[Sp + 8] = _s1CSS::I64 - 1;
           Sp = Sp + 8;
           call _c1Dri() args: 0, res: 0, upd: 0;
       c1DrD: // global
           I64[Sp + 32] = _s1CSS::I64;
           Sp = Sp + 16;
           call _c1DqO() args: 0, res: 0, upd: 0;
     }
 },
 _c1DqO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DqO: // global
           Hp = Hp + 16;
           _s1CSK::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c1DqZ; else goto c1DqY;
       c1DqZ: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1DqN_info;
           R1 = _s1CSK::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1DqY: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp] + ((-1) - _s1CSK::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1DqN() //  [R1]
         { info_tbl: [(c1DqN,
                       label: block_c1DqN_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DqN: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c1DqO() args: 0, res: 0, upd: 0;
     }
 },
 _c1Dr3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dr3: // global
           Hp = Hp + 16;
           _s1CSO::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c1Dre; else goto c1Drd;
       c1Dre: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1Dr2_info;
           R1 = _s1CSO::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1Drd: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp] + ((-1) - _s1CSO::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Dr2() //  [R1]
         { info_tbl: [(c1Dr2,
                       label: block_c1Dr2_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dr2: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c1Dr3() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.277715089 UTC

[section ""data" . Data.Bits.$dmrotateR_closure" {
     Data.Bits.$dmrotateR_closure:
         const Data.Bits.$dmrotateR_info;
 },
 sat_s1CT4_entry() //  [R1]
         { info_tbl: [(c1Ds6,
                       label: sat_s1CT4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ds6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dsd; else goto c1Dse;
       c1Dsd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Dse: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1Ds3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1Dsi; else goto c1Ds4;
       u1Dsi: // global
           call _c1Ds3(R1) args: 0, res: 0, upd: 0;
       c1Ds4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1Ds3() //  [R1]
         { info_tbl: [(c1Ds3,
                       label: block_c1Ds3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ds3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dsh; else goto c1Dsg;
       c1Dsh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1Dsg: // global
           _s1CT3::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CT3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmrotateR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Dsj,
                       label: Data.Bits.$dmrotateR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dsj: // global
           _s1CT0::P64 = R4;
           _s1CSZ::P64 = R3;
           _s1CSY::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dsk; else goto c1Dsl;
       c1Dsl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Dsn; else goto c1Dsm;
       c1Dsn: // global
           HpAlloc = 24;
           goto c1Dsk;
       c1Dsk: // global
           R4 = _s1CT0::P64;
           R3 = _s1CSZ::P64;
           R2 = _s1CSY::P64;
           R1 = Data.Bits.$dmrotateR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dsm: // global
           I64[Hp - 16] = sat_s1CT4_info;
           P64[Hp] = _s1CT0::P64;
           R2 = _s1CSY::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CSZ::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Data.Bits.rotate_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.27938542 UTC

[section ""data" . Data.Bits.$dmrotateL_closure" {
     Data.Bits.$dmrotateL_closure:
         const Data.Bits.$dmrotateL_info;
 },
 Data.Bits.$dmrotateL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Dss,
                       label: Data.Bits.$dmrotateL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dss: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dst; else goto c1Dsu;
       c1Dst: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmrotateL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dsu: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.rotate_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.281035999 UTC

[section ""data" . Data.Bits.$dmunsafeShiftR_closure" {
     Data.Bits.$dmunsafeShiftR_closure:
         const Data.Bits.$dmunsafeShiftR_info;
 },
 Data.Bits.$dmunsafeShiftR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Dsz,
                       label: Data.Bits.$dmunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dsz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1DsA; else goto c1DsB;
       c1DsA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmunsafeShiftR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DsB: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shiftR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.282414634 UTC

[section ""data" . Data.Bits.$dmshiftR_closure" {
     Data.Bits.$dmshiftR_closure:
         const Data.Bits.$dmshiftR_info;
 },
 sat_s1CTh_entry() //  [R1]
         { info_tbl: [(c1DsN,
                       label: sat_s1CTh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DsN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1DsU; else goto c1DsV;
       c1DsU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DsV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1DsK_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1DsZ; else goto c1DsL;
       u1DsZ: // global
           call _c1DsK(R1) args: 0, res: 0, upd: 0;
       c1DsL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1DsK() //  [R1]
         { info_tbl: [(c1DsK,
                       label: block_c1DsK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DsK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DsY; else goto c1DsX;
       c1DsY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1DsX: // global
           _s1CTg::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CTg::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmshiftR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Dt0,
                       label: Data.Bits.$dmshiftR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dt0: // global
           _s1CTd::P64 = R4;
           _s1CTc::P64 = R3;
           _s1CTb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dt1; else goto c1Dt2;
       c1Dt2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Dt4; else goto c1Dt3;
       c1Dt4: // global
           HpAlloc = 24;
           goto c1Dt1;
       c1Dt1: // global
           R4 = _s1CTd::P64;
           R3 = _s1CTc::P64;
           R2 = _s1CTb::P64;
           R1 = Data.Bits.$dmshiftR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dt3: // global
           I64[Hp - 16] = sat_s1CTh_info;
           P64[Hp] = _s1CTd::P64;
           R2 = _s1CTb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTc::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Data.Bits.shift_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.284058886 UTC

[section ""data" . Data.Bits.$dmunsafeShiftL_closure" {
     Data.Bits.$dmunsafeShiftL_closure:
         const Data.Bits.$dmunsafeShiftL_info;
 },
 Data.Bits.$dmunsafeShiftL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Dt9,
                       label: Data.Bits.$dmunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dt9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dta; else goto c1Dtb;
       c1Dta: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmunsafeShiftL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dtb: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.285058837 UTC

[section ""data" . Data.Bits.$dmshiftL_closure" {
     Data.Bits.$dmshiftL_closure:
         const Data.Bits.$dmshiftL_info;
 },
 Data.Bits.$dmshiftL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Dtg,
                       label: Data.Bits.$dmshiftL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dtg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dth; else goto c1Dti;
       c1Dth: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmshiftL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dti: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shift_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.286457241 UTC

[section ""data" . Data.Bits.$dmcomplementBit_closure" {
     Data.Bits.$dmcomplementBit_closure:
         const Data.Bits.$dmcomplementBit_info;
 },
 sat_s1CTr_entry() //  [R1]
         { info_tbl: [(c1Dtr,
                       label: sat_s1CTr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dtr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Dts; else goto c1Dtt;
       c1Dts: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Dtt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcomplementBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Dtu,
                       label: Data.Bits.$dmcomplementBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dtu: // global
           _s1CTq::P64 = R4;
           _s1CTp::P64 = R3;
           _s1CTo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dtv; else goto c1Dtw;
       c1Dtw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1Dty; else goto c1Dtx;
       c1Dty: // global
           HpAlloc = 32;
           goto c1Dtv;
       c1Dtv: // global
           R4 = _s1CTq::P64;
           R3 = _s1CTp::P64;
           R2 = _s1CTo::P64;
           R1 = Data.Bits.$dmcomplementBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dtx: // global
           I64[Hp - 24] = sat_s1CTr_info;
           P64[Hp - 8] = _s1CTo::P64;
           P64[Hp] = _s1CTq::P64;
           R2 = _s1CTo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTp::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits.xor_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.288126117 UTC

[section ""data" . Data.Bits.$dmclearBit_closure" {
     Data.Bits.$dmclearBit_closure:
         const Data.Bits.$dmclearBit_info;
 },
 sat_s1CTv_entry() //  [R1]
         { info_tbl: [(c1DtL,
                       label: sat_s1CTv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DtL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1DtM; else goto c1DtN;
       c1DtM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DtN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CTw_entry() //  [R1]
         { info_tbl: [(c1DtO,
                       label: sat_s1CTw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DtO: // global
           _s1CTw::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1DtP; else goto c1DtQ;
       c1DtQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1DtS; else goto c1DtR;
       c1DtS: // global
           HpAlloc = 32;
           goto c1DtP;
       c1DtP: // global
           R1 = _s1CTw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DtR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CTw::P64;
           _s1CTs::P64 = P64[_s1CTw::P64 + 16];
           _s1CTu::P64 = P64[_s1CTw::P64 + 24];
           I64[Hp - 24] = sat_s1CTv_info;
           P64[Hp - 8] = _s1CTs::P64;
           P64[Hp] = _s1CTu::P64;
           R2 = _s1CTs::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call Data.Bits.complement_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmclearBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1DtT,
                       label: Data.Bits.$dmclearBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DtT: // global
           _s1CTu::P64 = R4;
           _s1CTt::P64 = R3;
           _s1CTs::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1DtU; else goto c1DtV;
       c1DtV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1DtX; else goto c1DtW;
       c1DtX: // global
           HpAlloc = 32;
           goto c1DtU;
       c1DtU: // global
           R4 = _s1CTu::P64;
           R3 = _s1CTt::P64;
           R2 = _s1CTs::P64;
           R1 = Data.Bits.$dmclearBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DtW: // global
           I64[Hp - 24] = sat_s1CTw_info;
           P64[Hp - 8] = _s1CTs::P64;
           P64[Hp] = _s1CTu::P64;
           R2 = _s1CTs::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTt::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits..&._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.289999341 UTC

[section ""data" . Data.Bits.$dmsetBit_closure" {
     Data.Bits.$dmsetBit_closure:
         const Data.Bits.$dmsetBit_info;
 },
 sat_s1CTA_entry() //  [R1]
         { info_tbl: [(c1Du6,
                       label: sat_s1CTA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Du6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Du7; else goto c1Du8;
       c1Du7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Du8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmsetBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Du9,
                       label: Data.Bits.$dmsetBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Du9: // global
           _s1CTz::P64 = R4;
           _s1CTy::P64 = R3;
           _s1CTx::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dua; else goto c1Dub;
       c1Dub: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1Dud; else goto c1Duc;
       c1Dud: // global
           HpAlloc = 32;
           goto c1Dua;
       c1Dua: // global
           R4 = _s1CTz::P64;
           R3 = _s1CTy::P64;
           R2 = _s1CTx::P64;
           R1 = Data.Bits.$dmsetBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Duc: // global
           I64[Hp - 24] = sat_s1CTA_info;
           P64[Hp - 8] = _s1CTx::P64;
           P64[Hp] = _s1CTz::P64;
           R2 = _s1CTx::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTy::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits..|._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.291520463 UTC

[section ""data" . Data.Bits.$dmzeroBits_closure" {
     Data.Bits.$dmzeroBits_closure:
         const Data.Bits.$dmzeroBits_info;
 },
 sat_s1CTC_entry() //  [R1]
         { info_tbl: [(c1Dum,
                       label: sat_s1CTC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dum: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Dun; else goto c1Duo;
       c1Dun: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Duo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmzeroBits_entry() //  [R2]
         { info_tbl: [(c1Dup,
                       label: Data.Bits.$dmzeroBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dup: // global
           _s1CTB::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1Duq; else goto c1Dur;
       c1Dur: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Dut; else goto c1Dus;
       c1Dut: // global
           HpAlloc = 24;
           goto c1Duq;
       c1Duq: // global
           R2 = _s1CTB::P64;
           R1 = Data.Bits.$dmzeroBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Dus: // global
           I64[Hp - 16] = sat_s1CTC_info;
           P64[Hp] = _s1CTB::P64;
           R2 = _s1CTB::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp - 24;
           call Data.Bits.clearBit_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.29354342 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotateL_closure" {
     Data.Bits.$fBitsBool_$crotateL_closure:
         const Data.Bits.$fBitsBool_$crotateL_info;
 },
 Data.Bits.$fBitsBool_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1Duy,
                       label: Data.Bits.$fBitsBool_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Duy: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.294382189 UTC

[section ""data" . Data.Bits.$fBitsBool_$cshiftR_closure" {
     Data.Bits.$fBitsBool_$cshiftR_closure:
         const Data.Bits.$fBitsBool_$cshiftR_info;
 },
 Data.Bits.$fBitsBool_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1DuF,
                       label: Data.Bits.$fBitsBool_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DuF: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$ctestBit_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.295213078 UTC

[section ""data" . Data.Bits.$fBitsBool_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsBool_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsBool_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsBool_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1DuM,
                       label: Data.Bits.$fBitsBool_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DuM: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$cshiftR_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.296071854 UTC

[section ""data" . Data.Bits.$fBitsBool_$cshiftL_closure" {
     Data.Bits.$fBitsBool_$cshiftL_closure:
         const Data.Bits.$fBitsBool_$cshiftL_info;
 },
 Data.Bits.$fBitsBool_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1DuT,
                       label: Data.Bits.$fBitsBool_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DuT: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$ctestBit_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.296895309 UTC

[section ""data" . Data.Bits.$fBitsBool_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsBool_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsBool_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsBool_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Dv0,
                       label: Data.Bits.$fBitsBool_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dv0: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$cshiftL_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.298285315 UTC

[section ""data" . Data.Bits.$fBitsBool_$ccomplementBit_closure" {
     Data.Bits.$fBitsBool_$ccomplementBit_closure:
         const Data.Bits.$fBitsBool_$ccomplementBit_info;
 },
 Data.Bits.$fBitsBool_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1Dve,
                       label: Data.Bits.$fBitsBool_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dve: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dvf; else goto c1Dvg;
       c1Dvf: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dvg: // global
           I64[Sp - 16] = block_c1Dv7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DvN; else goto c1Dv8;
       u1DvN: // global
           call _c1Dv7(R1) args: 0, res: 0, upd: 0;
       c1Dv8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dv7() //  [R1]
         { info_tbl: [(c1Dv7,
                       label: block_c1Dv7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dv7: // global
           _s1CTE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1Dvb; else goto c1Dvc;
       c1Dvb: // global
           I64[Sp + 8] = block_c1Dvj_info;
           R1 = _s1CTE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1DvL; else goto c1Dvl;
       u1DvL: // global
           call _c1Dvj(R1) args: 0, res: 0, upd: 0;
       c1Dvl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1Dvc: // global
           I64[Sp + 8] = block_c1Dvw_info;
           R1 = _s1CTE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1DvM; else goto c1Dvy;
       u1DvM: // global
           call _c1Dvw(R1) args: 0, res: 0, upd: 0;
       c1Dvy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dvj() //  [R1]
         { info_tbl: [(c1Dvj,
                       label: block_c1Dvj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dvj: // global
           if (I64[R1 + 7] == 0) goto u1DvJ; else goto u1DvK;
       u1DvJ: // global
           Sp = Sp + 8;
           call _c1DvF() args: 0, res: 0, upd: 0;
       u1DvK: // global
           Sp = Sp + 8;
           call _c1DvG() args: 0, res: 0, upd: 0;
     }
 },
 _c1Dvw() //  [R1]
         { info_tbl: [(c1Dvw,
                       label: block_c1Dvw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dvw: // global
           if (I64[R1 + 7] == 0) goto u1DvH; else goto u1DvI;
       u1DvH: // global
           Sp = Sp + 8;
           call _c1DvG() args: 0, res: 0, upd: 0;
       u1DvI: // global
           Sp = Sp + 8;
           call _c1DvF() args: 0, res: 0, upd: 0;
     }
 },
 _c1DvG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DvG: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1DvF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DvF: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.300397477 UTC

[section ""data" . Data.Bits.$fBitsBool_$cclearBit_closure" {
     Data.Bits.$fBitsBool_$cclearBit_closure:
         const Data.Bits.$fBitsBool_$cclearBit_info;
 },
 Data.Bits.$fBitsBool_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1Dw3,
                       label: Data.Bits.$fBitsBool_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dw3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dw4; else goto c1Dw5;
       c1Dw4: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dw5: // global
           I64[Sp - 16] = block_c1DvW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Dwq; else goto c1DvX;
       u1Dwq: // global
           call _c1DvW(R1) args: 0, res: 0, upd: 0;
       c1DvX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DvW() //  [R1]
         { info_tbl: [(c1DvW,
                       label: block_c1DvW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DvW: // global
           if (R1 & 7 == 1) goto u1Dwm; else goto c1Dw1;
       u1Dwm: // global
           Sp = Sp + 16;
           call _c1Dwl() args: 0, res: 0, upd: 0;
       c1Dw1: // global
           _s1CTN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1Dwb_info;
           R1 = _s1CTN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1Dwo; else goto c1Dwd;
       u1Dwo: // global
           call _c1Dwb(R1) args: 0, res: 0, upd: 0;
       c1Dwd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dwb() //  [R1]
         { info_tbl: [(c1Dwb,
                       label: block_c1Dwb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dwb: // global
           if (I64[R1 + 7] == 0) goto u1Dwn; else goto c1Dwk;
       u1Dwn: // global
           Sp = Sp + 8;
           call _c1Dwl() args: 0, res: 0, upd: 0;
       c1Dwk: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Dwl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dwl: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.302145629 UTC

[section ""data" . Data.Bits.$fBitsBool_$csetBit_closure" {
     Data.Bits.$fBitsBool_$csetBit_closure:
         const Data.Bits.$fBitsBool_$csetBit_info;
 },
 Data.Bits.$fBitsBool_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1DwD,
                       label: Data.Bits.$fBitsBool_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DwD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DwE; else goto c1DwF;
       c1DwE: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DwF: // global
           I64[Sp - 16] = block_c1Dww_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DwM; else goto c1Dwx;
       u1DwM: // global
           call _c1Dww(R1) args: 0, res: 0, upd: 0;
       c1Dwx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dww() //  [R1]
         { info_tbl: [(c1Dww,
                       label: block_c1Dww_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dww: // global
           if (R1 & 7 == 1) goto c1DwA; else goto c1DwB;
       c1DwA: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Bits.$fBitsBool_$cbit_entry(R2) args: 8, res: 0, upd: 8;
       c1DwB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.30336344 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotateR_closure" {
     Data.Bits.$fBitsBool_$crotateR_closure:
         const Data.Bits.$fBitsBool_$crotateR_info;
 },
 Data.Bits.$fBitsBool_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1DwR,
                       label: Data.Bits.$fBitsBool_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DwR: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.304122865 UTC

[section ""data" . Data.Bits.$fBitsBool_closure" {
     Data.Bits.$fBitsBool_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqBool_closure;
         const GHC.Classes.&&_closure+2;
         const GHC.Classes.||_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const GHC.Classes.not_closure+1;
         const Data.Bits.$fBitsBool_$ctestBit_closure+2;
         const Data.Bits.$fBitsBool_$crotate_closure+2;
         const GHC.Types.False_closure+1;
         const Data.Bits.$fBitsBool_$cbit_closure+1;
         const Data.Bits.$fBitsBool_$csetBit_closure+2;
         const Data.Bits.$fBitsBool_$cclearBit_closure+2;
         const Data.Bits.$fBitsBool_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsBool_$ctestBit_closure+2;
         const Data.Bits.$fBitsBool_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsBool_$cbitSize_closure+1;
         const Data.Bits.$fBitsBool_$cisSigned_closure+1;
         const Data.Bits.$fBitsBool_$cshiftL_closure+2;
         const Data.Bits.$fBitsBool_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsBool_$cshiftR_closure+2;
         const Data.Bits.$fBitsBool_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsBool_$crotateL_closure+2;
         const Data.Bits.$fBitsBool_$crotateR_closure+2;
         const Data.Bits.$fBitsBool_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.304880722 UTC

[section ""data" . Data.Bits.$fFiniteBitsBool_closure" {
     Data.Bits.$fFiniteBitsBool_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsBool_closure+1;
         const Data.Bits.$fBitsBool_$cbitSize_closure+1;
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure+1;
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.306797104 UTC

[section ""data" . Data.Bits.$dmrotate_closure" {
     Data.Bits.$dmrotate_closure:
         const Data.Bits.$dmrotate_info;
 },
 Data.Bits.$dmrotate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Dx1,
                       label: Data.Bits.$dmrotate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dx1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dx2; else goto c1Dx3;
       c1Dx2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmrotate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dx3: // global
           I64[Sp - 24] = block_c1DwY_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1Dxp; else goto c1DwZ;
       u1Dxp: // global
           call _c1DwY(R1) args: 0, res: 0, upd: 0;
       c1DwZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DwY() //  [R1]
         { info_tbl: [(c1DwY,
                       label: block_c1DwY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DwY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dx8; else goto c1Dx7;
       c1Dx8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dx7: // global
           _s1CTV::P64 = P64[Sp + 8];
           _s1CTW::P64 = P64[Sp + 16];
           _s1CTZ::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CTZ::I64, 0)) goto c1Dxi; else goto c1Dxj;
       c1Dxi: // global
           if (%MO_S_Le_W64(_s1CTZ::I64, 0)) goto c1Dxf; else goto c1Dxg;
       c1Dxf: // global
           Hp = Hp - 16;
           R1 = _s1CTW::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1Dxg: // global
           Hp = Hp - 16;
           R2 = _s1CTV::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CTW::P64;
           P64[Sp + 16] = R1;
           call Data.Bits.rotateL_entry(R2) args: 32, res: 0, upd: 8;
       c1Dxj: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1CTZ::I64;
           R2 = _s1CTV::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CTW::P64;
           P64[Sp + 16] = Hp - 7;
           call Data.Bits.rotateR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.308793525 UTC

[section ""data" . Data.Bits.$dmshift_closure" {
     Data.Bits.$dmshift_closure:
         const Data.Bits.$dmshift_info;
 },
 Data.Bits.$dmshift_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Dxx,
                       label: Data.Bits.$dmshift_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dxx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dxy; else goto c1Dxz;
       c1Dxy: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmshift_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dxz: // global
           I64[Sp - 24] = block_c1Dxu_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1DxV; else goto c1Dxv;
       u1DxV: // global
           call _c1Dxu(R1) args: 0, res: 0, upd: 0;
       c1Dxv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dxu() //  [R1]
         { info_tbl: [(c1Dxu,
                       label: block_c1Dxu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dxu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DxE; else goto c1DxD;
       c1DxE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DxD: // global
           _s1CU4::P64 = P64[Sp + 8];
           _s1CU5::P64 = P64[Sp + 16];
           _s1CU8::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CU8::I64, 0)) goto c1DxO; else goto c1DxP;
       c1DxO: // global
           if (%MO_S_Le_W64(_s1CU8::I64, 0)) goto c1DxL; else goto c1DxM;
       c1DxL: // global
           Hp = Hp - 16;
           R1 = _s1CU5::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1DxM: // global
           Hp = Hp - 16;
           R2 = _s1CU4::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CU5::P64;
           P64[Sp + 16] = R1;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
       c1DxP: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1CU8::I64;
           R2 = _s1CU4::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CU5::P64;
           P64[Sp + 16] = Hp - 7;
           call Data.Bits.shiftR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.310596637 UTC

[section ""data" . Data.Bits.bitDefault_closure" {
     Data.Bits.bitDefault_closure:
         const Data.Bits.bitDefault_info;
         const 0;
 },
 sat_s1CUg_entry() //  [R1]
         { info_tbl: [(c1Dy4,
                       label: sat_s1CUg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dy4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Dy5; else goto c1Dy6;
       c1Dy5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Dy6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.bitDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Dy7,
                       label: Data.Bits.bitDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dy7: // global
           _s1CUf::P64 = R4;
           _s1CUe::P64 = R3;
           _s1CUd::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1Dy8; else goto c1Dy9;
       c1Dy9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Dyb; else goto c1Dya;
       c1Dyb: // global
           HpAlloc = 24;
           goto c1Dy8;
       c1Dy8: // global
           R4 = _s1CUf::P64;
           R3 = _s1CUe::P64;
           R2 = _s1CUd::P64;
           R1 = Data.Bits.bitDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dya: // global
           I64[Hp - 16] = sat_s1CUg_info;
           P64[Hp] = _s1CUe::P64;
           R2 = _s1CUd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1CUf::P64;
           Sp = Sp - 24;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.312585055 UTC

[section ""data" . Data.Bits.testBitDefault_closure" {
     Data.Bits.testBitDefault_closure:
         const Data.Bits.testBitDefault_info;
         const 0;
 },
 sat_s1CUo_entry() //  [R1]
         { info_tbl: [(c1Dyk,
                       label: sat_s1CUo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dyk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Dyl; else goto c1Dym;
       c1Dyl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Dym: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CUm_entry() //  [R1]
         { info_tbl: [(c1Dyv,
                       label: sat_s1CUm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dyv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Dyw; else goto c1Dyx;
       c1Dyw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Dyx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CUn_entry() //  [R1]
         { info_tbl: [(c1Dyy,
                       label: sat_s1CUn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dyy: // global
           _s1CUn::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1Dyz; else goto c1DyA;
       c1DyA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1DyC; else goto c1DyB;
       c1DyC: // global
           HpAlloc = 32;
           goto c1Dyz;
       c1Dyz: // global
           R1 = _s1CUn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DyB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CUn::P64;
           _s1CUh::P64 = P64[_s1CUn::P64 + 16];
           _s1CUj::P64 = P64[_s1CUn::P64 + 24];
           _s1CUk::P64 = P64[_s1CUn::P64 + 32];
           I64[Hp - 24] = sat_s1CUm_info;
           P64[Hp - 8] = _s1CUh::P64;
           P64[Hp] = _s1CUk::P64;
           R2 = _s1CUh::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1CUj::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Data.Bits..&._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Bits.testBitDefault_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1DyF,
                       label: Data.Bits.testBitDefault_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DyF: // global
           _s1CUk::P64 = R5;
           _s1CUj::P64 = R4;
           _s1CUi::P64 = R3;
           _s1CUh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1DyG; else goto c1DyH;
       c1DyH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1DyJ; else goto c1DyI;
       c1DyJ: // global
           HpAlloc = 64;
           goto c1DyG;
       c1DyG: // global
           R5 = _s1CUk::P64;
           R4 = _s1CUj::P64;
           R3 = _s1CUi::P64;
           R2 = _s1CUh::P64;
           R1 = Data.Bits.testBitDefault_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DyI: // global
           I64[Hp - 56] = sat_s1CUo_info;
           P64[Hp - 40] = _s1CUi::P64;
           I64[Hp - 32] = sat_s1CUn_info;
           P64[Hp - 16] = _s1CUh::P64;
           P64[Hp - 8] = _s1CUj::P64;
           P64[Hp] = _s1CUk::P64;
           I64[Sp - 24] = block_c1DyD_info;
           R2 = _s1CUh::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 24;
           call Data.Bits.$p1Bits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1DyD() //  [R1]
         { info_tbl: [(c1DyD,
                       label: block_c1DyD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DyD: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _c1Dyg::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _c1Dyg::P64;
           call GHC.Classes./=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.314807693 UTC

[section ""data" . Data.Bits.$fBitsInt2_closure" {
     Data.Bits.$fBitsInt2_closure:
         const GHC.Base.Just_con_info;
         const Data.Bits.$fBitsInt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.315615024 UTC

[section ""data" . Data.Bits.$fBitsWord_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsWord_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsWord_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsWord_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1DyR,
                       label: Data.Bits.$fBitsWord_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DyR: // global
           R1 = Data.Bits.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.316649169 UTC

[section ""data" . Data.Bits.$fBitsWord_$cbit_closure" {
     Data.Bits.$fBitsWord_$cbit_closure:
         const Data.Bits.$fBitsWord_$cbit_info;
 },
 Data.Bits.$fBitsWord_$cbit_entry() //  [R2]
         { info_tbl: [(c1Dz1,
                       label: Data.Bits.$fBitsWord_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dz1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Dz2; else goto c1Dz3;
       c1Dz2: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Dz3: // global
           I64[Sp - 8] = block_c1DyY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Dzj; else goto c1DyZ;
       u1Dzj: // global
           call _c1DyY(R1) args: 0, res: 0, upd: 0;
       c1DyZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DyY() //  [R1]
         { info_tbl: [(c1DyY,
                       label: block_c1DyY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DyY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Dz8; else goto c1Dz7;
       c1Dz8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Dz7: // global
           _s1CUs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CUs::I64, 64)) goto c1Dzh; else goto c1Dzi;
       c1Dzh: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = 1 << _s1CUs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Dzi: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.31851773 UTC

[section ""data" . Data.Bits.$fBitsWord_$ctestBit_closure" {
     Data.Bits.$fBitsWord_$ctestBit_closure:
         const Data.Bits.$fBitsWord_$ctestBit_info;
 },
 Data.Bits.$fBitsWord_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1Dzr,
                       label: Data.Bits.$fBitsWord_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dzr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Dzv; else goto c1Dzw;
       c1Dzv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Dzw: // global
           I64[Sp - 16] = block_c1Dzo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DA2; else goto c1Dzp;
       u1DA2: // global
           call _c1Dzo(R1) args: 0, res: 0, upd: 0;
       c1Dzp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dzo() //  [R1]
         { info_tbl: [(c1Dzo,
                       label: block_c1Dzo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dzo: // global
           I64[Sp] = block_c1Dzu_info;
           _s1CUy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CUy::I64;
           if (R1 & 7 != 0) goto u1DA1; else goto c1Dzy;
       u1DA1: // global
           call _c1Dzu(R1) args: 0, res: 0, upd: 0;
       c1Dzy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Dzu() //  [R1]
         { info_tbl: [(c1Dzu,
                       label: block_c1Dzu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Dzu: // global
           _s1CUA::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CUA::I64, 64)) goto c1DA0; else goto c1DzZ;
       c1DzZ: // global
           if (I64[Sp + 8] & (1 << _s1CUA::I64) == 0) goto c1DA0; else goto c1DzO;
       c1DA0: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DzO: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.321459255 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotateR_closure" {
     Data.Bits.$fBitsWord_$crotateR_closure:
         const Data.Bits.$fBitsWord_$crotateR_info;
 },
 Data.Bits.$fBitsWord_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1DAa,
                       label: Data.Bits.$fBitsWord_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DAa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1DAe; else goto c1DAf;
       c1DAe: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DAf: // global
           I64[Sp - 16] = block_c1DA7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DAW; else goto c1DA8;
       u1DAW: // global
           call _c1DA7(R1) args: 0, res: 0, upd: 0;
       c1DA8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DA7() //  [R1]
         { info_tbl: [(c1DA7,
                       label: block_c1DA7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DA7: // global
           I64[Sp - 8] = block_c1DAd_info;
           _s1CUG::P64 = R1;
           _s1CUH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CUH::I64;
           P64[Sp + 8] = _s1CUG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1DAV; else goto c1DAh;
       u1DAV: // global
           call _c1DAd(R1) args: 0, res: 0, upd: 0;
       c1DAh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DAd() //  [R1]
         { info_tbl: [(c1DAd,
                       label: block_c1DAd_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DAd: // global
           _s1CUL::I64 = -I64[R1 + 7] & 63;
           if (_s1CUL::I64 != 0) goto u1DAT; else goto c1DAP;
       u1DAT: // global
           I64[Sp + 16] = _s1CUL::I64;
           Sp = Sp + 8;
           call _c1DAt() args: 0, res: 0, upd: 0;
       c1DAP: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1DAt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DAt: // global
           Hp = Hp + 16;
           _s1CUL::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1DAM; else goto c1DAL;
       c1DAM: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1DAs_info;
           R1 = _s1CUL::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1DAL: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           _s1CUH::I64 = I64[Sp];
           I64[Hp] = (_s1CUH::I64 << _s1CUL::I64) | (_s1CUH::I64 >> 64 - _s1CUL::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1DAs() //  [R1]
         { info_tbl: [(c1DAs,
                       label: block_c1DAs_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DAs: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1DAt() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.323676227 UTC

[section ""data" . Data.Bits.$fBitsWord_$ccomplementBit_closure" {
     Data.Bits.$fBitsWord_$ccomplementBit_closure:
         const Data.Bits.$fBitsWord_$ccomplementBit_info;
 },
 Data.Bits.$fBitsWord_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1DB6,
                       label: Data.Bits.$fBitsWord_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DB6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1DBa; else goto c1DBb;
       c1DBa: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DBb: // global
           I64[Sp - 16] = block_c1DB3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DBy; else goto c1DB4;
       u1DBy: // global
           call _c1DB3(R1) args: 0, res: 0, upd: 0;
       c1DB4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DB3() //  [R1]
         { info_tbl: [(c1DB3,
                       label: block_c1DB3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DB3: // global
           I64[Sp - 8] = block_c1DB9_info;
           _s1CUS::P64 = R1;
           _s1CUT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CUT::I64;
           P64[Sp + 8] = _s1CUS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1DBx; else goto c1DBd;
       u1DBx: // global
           call _c1DB9(R1) args: 0, res: 0, upd: 0;
       c1DBd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DB9() //  [R1]
         { info_tbl: [(c1DB9,
                       label: block_c1DB9_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DB9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DBj; else goto c1DBi;
       c1DBj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DBi: // global
           _s1CUV::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CUV::I64, 64)) goto c1DBv; else goto c1DBw;
       c1DBv: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s1CUV::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DBw: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.325591314 UTC

[section ""data" . Data.Bits.$fBitsWord_$cclearBit_closure" {
     Data.Bits.$fBitsWord_$cclearBit_closure:
         const Data.Bits.$fBitsWord_$cclearBit_info;
 },
 Data.Bits.$fBitsWord_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1DBG,
                       label: Data.Bits.$fBitsWord_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DBG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DBK; else goto c1DBL;
       c1DBK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DBL: // global
           I64[Sp - 16] = block_c1DBD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DCg; else goto c1DBE;
       u1DCg: // global
           call _c1DBD(R1) args: 0, res: 0, upd: 0;
       c1DBE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DBD() //  [R1]
         { info_tbl: [(c1DBD,
                       label: block_c1DBD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DBD: // global
           I64[Sp] = block_c1DBJ_info;
           _s1CV2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CV2::I64;
           if (R1 & 7 != 0) goto u1DCf; else goto c1DBN;
       u1DCf: // global
           call _c1DBJ(R1) args: 0, res: 0, upd: 0;
       c1DBN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DBJ() //  [R1]
         { info_tbl: [(c1DBJ,
                       label: block_c1DBJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DBJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DBT; else goto c1DBS;
       c1DBT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DBS: // global
           _s1CV2::I64 = I64[Sp + 8];
           _s1CV4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CV4::I64, 64)) goto c1DC8; else goto c1DCe;
       c1DC8: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CV2::I64 & (1 << _s1CV4::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DCe: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CV2::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.327434924 UTC

[section ""data" . Data.Bits.$fBitsWord_$csetBit_closure" {
     Data.Bits.$fBitsWord_$csetBit_closure:
         const Data.Bits.$fBitsWord_$csetBit_info;
 },
 Data.Bits.$fBitsWord_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1DCo,
                       label: Data.Bits.$fBitsWord_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DCo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1DCs; else goto c1DCt;
       c1DCs: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DCt: // global
           I64[Sp - 16] = block_c1DCl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DCQ; else goto c1DCm;
       u1DCQ: // global
           call _c1DCl(R1) args: 0, res: 0, upd: 0;
       c1DCm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DCl() //  [R1]
         { info_tbl: [(c1DCl,
                       label: block_c1DCl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DCl: // global
           I64[Sp - 8] = block_c1DCr_info;
           _s1CVc::P64 = R1;
           _s1CVd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CVd::I64;
           P64[Sp + 8] = _s1CVc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1DCP; else goto c1DCv;
       u1DCP: // global
           call _c1DCr(R1) args: 0, res: 0, upd: 0;
       c1DCv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DCr() //  [R1]
         { info_tbl: [(c1DCr,
                       label: block_c1DCr_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DCr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DCB; else goto c1DCA;
       c1DCB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DCA: // global
           _s1CVf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVf::I64, 64)) goto c1DCN; else goto c1DCO;
       c1DCN: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s1CVf::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DCO: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.328978372 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotateL_closure" {
     Data.Bits.$fBitsWord_$crotateL_closure:
         const Data.Bits.$fBitsWord_$crotateL_info;
 },
 Data.Bits.$fBitsWord_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1DCV,
                       label: Data.Bits.$fBitsWord_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DCV: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsWord_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.329753293 UTC

[section ""data" . Data.Bits.$fBitsWord_closure" {
     Data.Bits.$fBitsWord_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqWord_closure;
         const Data.Bits.$fBitsWord_$c.&._closure+2;
         const Data.Bits.$fBitsWord_$c.|._closure+2;
         const Data.Bits.$fBitsWord_$cxor_closure+2;
         const Data.Bits.$fBitsWord_$ccomplement_closure+1;
         const Data.Bits.$fBitsWord_$cshift_closure+2;
         const Data.Bits.$fBitsWord_$crotate_closure+2;
         const Data.Bits.$fBitsWord1_closure+1;
         const Data.Bits.$fBitsWord_$cbit_closure+1;
         const Data.Bits.$fBitsWord_$csetBit_closure+2;
         const Data.Bits.$fBitsWord_$cclearBit_closure+2;
         const Data.Bits.$fBitsWord_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsWord_$ctestBit_closure+2;
         const Data.Bits.$fBitsWord_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsWord_$cfiniteBitSize_closure+1;
         const Data.Bits.$fBitsWord_$cisSigned_closure+1;
         const Data.Bits.$fBitsWord_$cshiftL_closure+2;
         const Data.Bits.$fBitsWord_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsWord_$cshiftR_closure+2;
         const Data.Bits.$fBitsWord_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsWord_$crotateL_closure+2;
         const Data.Bits.$fBitsWord_$crotateR_closure+2;
         const Data.Bits.$fBitsWord_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.330556682 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_closure" {
     Data.Bits.$fFiniteBitsWord_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsWord_closure+1;
         const Data.Bits.$fBitsWord_$cfiniteBitSize_closure+1;
         const Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure+1;
         const Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.331396821 UTC

[section ""data" . Data.Bits.$fBitsInt_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsInt_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsInt_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsInt_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1DD2,
                       label: Data.Bits.$fBitsInt_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DD2: // global
           R1 = Data.Bits.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.332280616 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotateL_closure" {
     Data.Bits.$fBitsInt_$crotateL_closure:
         const Data.Bits.$fBitsInt_$crotateL_info;
 },
 Data.Bits.$fBitsInt_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1DD9,
                       label: Data.Bits.$fBitsInt_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DD9: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInt_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.334279862 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotateR_closure" {
     Data.Bits.$fBitsInt_$crotateR_closure:
         const Data.Bits.$fBitsInt_$crotateR_info;
 },
 Data.Bits.$fBitsInt_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1DDj,
                       label: Data.Bits.$fBitsInt_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DDj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DDK; else goto c1DDL;
       c1DDK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DDL: // global
           I64[Sp - 16] = block_c1DDg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DDR; else goto c1DDh;
       u1DDR: // global
           call _c1DDg(R1) args: 0, res: 0, upd: 0;
       c1DDh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DDg() //  [R1]
         { info_tbl: [(c1DDg,
                       label: block_c1DDg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DDg: // global
           I64[Sp] = block_c1DDm_info;
           _s1CVn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CVn::I64;
           if (R1 & 7 != 0) goto u1DDQ; else goto c1DDn;
       u1DDQ: // global
           call _c1DDm(R1) args: 0, res: 0, upd: 0;
       c1DDn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DDm() //  [R1]
         { info_tbl: [(c1DDm,
                       label: block_c1DDm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DDm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DDP; else goto c1DDO;
       c1DDP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DDO: // global
           _s1CVq::I64 = -I64[R1 + 7] & 63;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _s1CVn::I64 = I64[Sp + 8];
           I64[Hp] = (_s1CVn::I64 << _s1CVq::I64) | (_s1CVn::I64 >> 64 - _s1CVq::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.335934198 UTC

[section ""data" . Data.Bits.$fBitsInt_$cbit_closure" {
     Data.Bits.$fBitsInt_$cbit_closure:
         const Data.Bits.$fBitsInt_$cbit_info;
 },
 Data.Bits.$fBitsInt_$cbit_entry() //  [R2]
         { info_tbl: [(c1DDZ,
                       label: Data.Bits.$fBitsInt_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DDZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1DE0; else goto c1DE1;
       c1DE0: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1DE1: // global
           I64[Sp - 8] = block_c1DDW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1DEh; else goto c1DDX;
       u1DEh: // global
           call _c1DDW(R1) args: 0, res: 0, upd: 0;
       c1DDX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DDW() //  [R1]
         { info_tbl: [(c1DDW,
                       label: block_c1DDW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DDW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DE6; else goto c1DE5;
       c1DE6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DE5: // global
           _s1CVy::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVy::I64, 64)) goto c1DEf; else goto c1DEg;
       c1DEf: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = 1 << _s1CVy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DEg: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.337702752 UTC

[section ""data" . Data.Bits.$fBitsInt_$ctestBit_closure" {
     Data.Bits.$fBitsInt_$ctestBit_closure:
         const Data.Bits.$fBitsInt_$ctestBit_info;
 },
 Data.Bits.$fBitsInt_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1DEp,
                       label: Data.Bits.$fBitsInt_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DEp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DEt; else goto c1DEu;
       c1DEt: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DEu: // global
           I64[Sp - 16] = block_c1DEm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DF0; else goto c1DEn;
       u1DF0: // global
           call _c1DEm(R1) args: 0, res: 0, upd: 0;
       c1DEn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DEm() //  [R1]
         { info_tbl: [(c1DEm,
                       label: block_c1DEm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DEm: // global
           I64[Sp] = block_c1DEs_info;
           _s1CVE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CVE::I64;
           if (R1 & 7 != 0) goto u1DEZ; else goto c1DEw;
       u1DEZ: // global
           call _c1DEs(R1) args: 0, res: 0, upd: 0;
       c1DEw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DEs() //  [R1]
         { info_tbl: [(c1DEs,
                       label: block_c1DEs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DEs: // global
           _s1CVG::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CVG::I64, 64)) goto c1DEY; else goto c1DEX;
       c1DEX: // global
           if (I64[Sp + 8] & (1 << _s1CVG::I64) == 0) goto c1DEY; else goto c1DEM;
       c1DEY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DEM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.33946175 UTC

[section ""data" . Data.Bits.$fBitsInt_$csetBit_closure" {
     Data.Bits.$fBitsInt_$csetBit_closure:
         const Data.Bits.$fBitsInt_$csetBit_info;
 },
 Data.Bits.$fBitsInt_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1DF8,
                       label: Data.Bits.$fBitsInt_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DF8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1DFc; else goto c1DFd;
       c1DFc: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DFd: // global
           I64[Sp - 16] = block_c1DF5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DFA; else goto c1DF6;
       u1DFA: // global
           call _c1DF5(R1) args: 0, res: 0, upd: 0;
       c1DF6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DF5() //  [R1]
         { info_tbl: [(c1DF5,
                       label: block_c1DF5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DF5: // global
           I64[Sp - 8] = block_c1DFb_info;
           _s1CVM::P64 = R1;
           _s1CVN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CVN::I64;
           P64[Sp + 8] = _s1CVM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1DFz; else goto c1DFf;
       u1DFz: // global
           call _c1DFb(R1) args: 0, res: 0, upd: 0;
       c1DFf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DFb() //  [R1]
         { info_tbl: [(c1DFb,
                       label: block_c1DFb_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DFb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DFl; else goto c1DFk;
       c1DFl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DFk: // global
           _s1CVP::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVP::I64, 64)) goto c1DFx; else goto c1DFy;
       c1DFx: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s1CVP::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DFy: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.341394478 UTC

[section ""data" . Data.Bits.$fBitsInt_$cclearBit_closure" {
     Data.Bits.$fBitsInt_$cclearBit_closure:
         const Data.Bits.$fBitsInt_$cclearBit_info;
 },
 Data.Bits.$fBitsInt_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1DFI,
                       label: Data.Bits.$fBitsInt_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DFI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DFM; else goto c1DFN;
       c1DFM: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DFN: // global
           I64[Sp - 16] = block_c1DFF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DGi; else goto c1DFG;
       u1DGi: // global
           call _c1DFF(R1) args: 0, res: 0, upd: 0;
       c1DFG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DFF() //  [R1]
         { info_tbl: [(c1DFF,
                       label: block_c1DFF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DFF: // global
           I64[Sp] = block_c1DFL_info;
           _s1CVW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CVW::I64;
           if (R1 & 7 != 0) goto u1DGh; else goto c1DFP;
       u1DGh: // global
           call _c1DFL(R1) args: 0, res: 0, upd: 0;
       c1DFP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DFL() //  [R1]
         { info_tbl: [(c1DFL,
                       label: block_c1DFL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DFL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DFV; else goto c1DFU;
       c1DFV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DFU: // global
           _s1CVW::I64 = I64[Sp + 8];
           _s1CVY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVY::I64, 64)) goto c1DGa; else goto c1DGg;
       c1DGa: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CVW::I64 & ~(1 << _s1CVY::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DGg: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CVW::I64 & (-1);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.343282633 UTC

[section ""data" . Data.Bits.$fBitsInt_$ccomplementBit_closure" {
     Data.Bits.$fBitsInt_$ccomplementBit_closure:
         const Data.Bits.$fBitsInt_$ccomplementBit_info;
 },
 Data.Bits.$fBitsInt_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1DGq,
                       label: Data.Bits.$fBitsInt_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DGq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1DGu; else goto c1DGv;
       c1DGu: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DGv: // global
           I64[Sp - 16] = block_c1DGn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1DGS; else goto c1DGo;
       u1DGS: // global
           call _c1DGn(R1) args: 0, res: 0, upd: 0;
       c1DGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DGn() //  [R1]
         { info_tbl: [(c1DGn,
                       label: block_c1DGn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DGn: // global
           I64[Sp - 8] = block_c1DGt_info;
           _s1CW6::P64 = R1;
           _s1CW7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CW7::I64;
           P64[Sp + 8] = _s1CW6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1DGR; else goto c1DGx;
       u1DGR: // global
           call _c1DGt(R1) args: 0, res: 0, upd: 0;
       c1DGx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DGt() //  [R1]
         { info_tbl: [(c1DGt,
                       label: block_c1DGt_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DGt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DGD; else goto c1DGC;
       c1DGD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DGC: // global
           _s1CW9::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CW9::I64, 64)) goto c1DGP; else goto c1DGQ;
       c1DGP: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s1CW9::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DGQ: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.344763645 UTC

[section ""data" . Data.Bits.$fBitsInt_closure" {
     Data.Bits.$fBitsInt_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqInt_closure;
         const Data.Bits.$fBitsInt_$c.&._closure+2;
         const Data.Bits.$fBitsInt_$c.|._closure+2;
         const Data.Bits.$fBitsInt_$cxor_closure+2;
         const Data.Bits.$fBitsInt_$ccomplement_closure+1;
         const Data.Bits.$fBitsInt_$cshift_closure+2;
         const Data.Bits.$fBitsInt_$crotate_closure+2;
         const Data.Bits.$fBitsBool2_closure+1;
         const Data.Bits.$fBitsInt_$cbit_closure+1;
         const Data.Bits.$fBitsInt_$csetBit_closure+2;
         const Data.Bits.$fBitsInt_$cclearBit_closure+2;
         const Data.Bits.$fBitsInt_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsInt_$ctestBit_closure+2;
         const Data.Bits.$fBitsInt_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsInt_$cfiniteBitSize_closure+1;
         const Data.Bits.$fBitsInt_$cisSigned_closure+1;
         const Data.Bits.$fBitsInt_$cshiftL_closure+2;
         const Data.Bits.$fBitsInt_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsInt_$cshiftR_closure+2;
         const Data.Bits.$fBitsInt_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsInt_$crotateL_closure+2;
         const Data.Bits.$fBitsInt_$crotateR_closure+2;
         const Data.Bits.$fBitsInt_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.345595128 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_closure" {
     Data.Bits.$fFiniteBitsInt_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsInt_closure+1;
         const Data.Bits.$fBitsInt_$cfiniteBitSize_closure+1;
         const Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure+1;
         const Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.347976932 UTC

[section ""data" . Data.Bits.$wpopCountDefault_closure" {
     Data.Bits.$wpopCountDefault_closure:
         const Data.Bits.$wpopCountDefault_info;
         const 0;
 },
 lvl1_s1CWg_entry() //  [R1]
         { info_tbl: [(c1DHh,
                       label: lvl1_s1CWg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DHh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1DHi; else goto c1DHj;
       c1DHi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DHj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl2_s1CWh_entry() //  [R1]
         { info_tbl: [(c1DHm,
                       label: lvl2_s1CWh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DHm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1DHn; else goto c1DHo;
       c1DHn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DHo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CWo_entry() //  [R1]
         { info_tbl: [(c1DHw,
                       label: sat_s1CWo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DHw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1DHx; else goto c1DHy;
       c1DHx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DHy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1CWp_entry() //  [R1]
         { info_tbl: [(c1DHz,
                       label: sat_s1CWp_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DHz: // global
           _s1CWp::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1DHA; else goto c1DHB;
       c1DHB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1DHD; else goto c1DHC;
       c1DHD: // global
           HpAlloc = 40;
           goto c1DHA;
       c1DHA: // global
           R1 = _s1CWp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DHC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CWp::P64;
           _s1CWd::P64 = P64[_s1CWp::P64 + 16];
           _s1CWe::P64 = P64[_s1CWp::P64 + 24];
           _s1CWg::P64 = P64[_s1CWp::P64 + 32];
           _s1CWl::P64 = P64[_s1CWp::P64 + 40];
           I64[Hp - 32] = sat_s1CWo_info;
           P64[Hp - 16] = _s1CWe::P64;
           P64[Hp - 8] = _s1CWg::P64;
           P64[Hp] = _s1CWl::P64;
           R2 = _s1CWd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1CWl::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call Data.Bits..&._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Bits.$wpopCountDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1DHE,
                       label: Data.Bits.$wpopCountDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DHE: // global
           _s1CWf::P64 = R4;
           _s1CWe::P64 = R3;
           _s1CWd::P64 = R2;
           if ((Sp + -88) < SpLim) (likely: False) goto c1DHF; else goto c1DHG;
       c1DHG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1DHI; else goto c1DHH;
       c1DHI: // global
           HpAlloc = 48;
           goto c1DHF;
       c1DHF: // global
           R4 = _s1CWf::P64;
           R3 = _s1CWe::P64;
           R2 = _s1CWd::P64;
           R1 = Data.Bits.$wpopCountDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DHH: // global
           I64[Hp - 40] = lvl1_s1CWg_info;
           P64[Hp - 24] = _s1CWe::P64;
           I64[Hp - 16] = lvl2_s1CWh_info;
           P64[Hp] = _s1CWe::P64;
           I64[Sp - 48] = block_c1DH1_info;
           R2 = _s1CWd::P64;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _s1CWd::P64;
           P64[Sp - 16] = _s1CWe::P64;
           P64[Sp - 8] = _s1CWf::P64;
           Sp = Sp - 48;
           call Data.Bits.$p1Bits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1DH1() //  [R1]
         { info_tbl: [(c1DH1,
                       label: block_c1DH1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DH1: // global
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp] = 0;
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call _c1DH7() args: 0, res: 0, upd: 0;
     }
 },
 _c1DH7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DH7: // global
           I64[Sp - 8] = block_c1DHa_info;
           R2 = P64[Sp + 48];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp];
           P64[Sp - 16] = P64[Sp + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1DHa() //  [R1]
         { info_tbl: [(c1DHa,
                       label: block_c1DHa_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DHa: // global
           _s1CWk::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c1DHM; else goto c1DHT;
       c1DHM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1DHP; else goto c1DHO;
       c1DHP: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DHO: // global
           I64[Hp - 40] = sat_s1CWp_info;
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 16] = _s1CWk::I64 + 1;
           P64[Sp + 8] = Hp - 40;
           Sp = Sp + 8;
           call _c1DH7() args: 0, res: 0, upd: 0;
       c1DHT: // global
           R1 = _s1CWk::I64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.3510713 UTC

[section ""data" . Data.Bits.popCountDefault_closure" {
     Data.Bits.popCountDefault_closure:
         const Data.Bits.popCountDefault_info;
         const 0;
 },
 Data.Bits.popCountDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1DI6,
                       label: Data.Bits.popCountDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DI6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1DIa; else goto c1DIb;
       c1DIa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.popCountDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DIb: // global
           I64[Sp - 8] = block_c1DI4_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Bits.$wpopCountDefault_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1DI4() //  [R1]
         { info_tbl: [(c1DI4,
                       label: block_c1DI4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DI4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DIe; else goto c1DId;
       c1DIe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1DId: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.352417416 UTC

[section ""data" . Data.Bits.$fBitsInteger_closure" {
     Data.Bits.$fBitsInteger_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Integer.Type.$fEqInteger_closure;
         const GHC.Integer.Type.andInteger_closure+2;
         const GHC.Integer.Type.orInteger_closure+2;
         const GHC.Integer.Type.xorInteger_closure+2;
         const GHC.Integer.Type.complementInteger_closure+1;
         const Data.Bits.$fBitsInteger_$cshift_closure+2;
         const Data.Bits.$fBitsInteger_$cshift_closure+2;
         const Data.Bits.$fBitsInteger_$czeroBits_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure+1;
         const Data.Bits.$fBitsInteger_$csetBit_closure+2;
         const Data.Bits.$fBitsInteger_$cclearBit_closure+2;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsInteger_$ctestBit_closure+2;
         const Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsInteger_$cbitSize_closure+1;
         const Data.Bits.$fBitsInteger_$cisSigned_closure+1;
         const Data.Bits.$fBitsInteger_$cshiftL_closure+2;
         const Data.Bits.$fBitsInteger_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsInteger_$cshiftR_closure+2;
         const Data.Bits.$fBitsInteger_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsInteger_$crotateL_closure+2;
         const Data.Bits.$fBitsInteger_$crotateR_closure+2;
         const Data.Bits.$fBitsInteger_$cpopCount_closure+1;
         const 0;
 },
 section ""data" . Data.Bits.$fBitsInteger_$cpopCount_closure" {
     Data.Bits.$fBitsInteger_$cpopCount_closure:
         const Data.Bits.$fBitsInteger_$cpopCount_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1DIl,
                       label: Data.Bits.$fBitsInteger_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DIl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1DIp; else goto c1DIq;
       c1DIp: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1DIq: // global
           I64[Sp - 8] = block_c1DIj_info;
           R4 = R2;
           R3 = GHC.Num.$fNumInteger_closure;
           R2 = Data.Bits.$fBitsInteger_closure+1;
           Sp = Sp - 8;
           call Data.Bits.$wpopCountDefault_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1DIj() //  [R1]
         { info_tbl: [(c1DIj,
                       label: block_c1DIj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DIj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DIt; else goto c1DIs;
       c1DIt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1DIs: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.377320171 UTC

[section ""data" . Data.Bits.toIntegralSized_closure" {
     Data.Bits.toIntegralSized_closure:
         const Data.Bits.toIntegralSized_info;
         const 0;
 },
 sat_s1CWF_entry() //  [R1]
         { info_tbl: [(c1DIK,
                       label: sat_s1CWF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DIK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1DIL; else goto c1DIM;
       c1DIL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DIM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 y_s1CWC_entry() //  [R1]
         { info_tbl: [(c1DIP,
                       label: y_s1CWC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DIP: // global
           _s1CWC::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1DIT; else goto c1DIU;
       c1DIU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1DIW; else goto c1DIV;
       c1DIW: // global
           HpAlloc = 32;
           goto c1DIT;
       c1DIT: // global
           R1 = _s1CWC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DIV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CWC::P64;
           _s1CWw::P64 = P64[_s1CWC::P64 + 16];
           _s1CWx::P64 = P64[_s1CWC::P64 + 24];
           _s1CWA::P64 = P64[_s1CWC::P64 + 32];
           I64[Hp - 24] = sat_s1CWF_info;
           P64[Hp - 8] = _s1CWw::P64;
           P64[Hp] = _s1CWA::P64;
           I64[Sp - 32] = block_c1DIN_info;
           R2 = _s1CWx::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1DIN() //  [R1]
         { info_tbl: [(c1DIN,
                       label: block_c1DIN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DIN: // global
           I64[Sp] = block_c1DIS_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1DIS() //  [R1]
         { info_tbl: [(c1DIS,
                       label: block_c1DIS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DIS: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 xSigned_s1CWI_entry() //  [R1]
         { info_tbl: [(c1DJe,
                       label: xSigned_s1CWI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DJe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1DJf; else goto c1DJg;
       c1DJf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DJg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.isSigned_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dReal_s1CWJ_entry() //  [R1]
         { info_tbl: [(c1DJl,
                       label: $dReal_s1CWJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DJl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DJm; else goto c1DJn;
       c1DJm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DJn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dNum_s1CWK_entry() //  [R1]
         { info_tbl: [(c1DJs,
                       label: $dNum_s1CWK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DJs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DJt; else goto c1DJu;
       c1DJt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DJu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dOrd_s1CWL_entry() //  [R1]
         { info_tbl: [(c1DJz,
                       label: $dOrd_s1CWL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DJz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1DJA; else goto c1DJB;
       c1DJA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DJB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1CX0_entry() //  [R1]
         { info_tbl: [(c1DKp,
                       label: sat_s1CX0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DKp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1DKq; else goto c1DKr;
       c1DKq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DKr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CWZ_entry() //  [R1]
         { info_tbl: [(c1DKw,
                       label: sat_s1CWZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DKw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1DKx; else goto c1DKy;
       c1DKx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DKy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CX1_entry() //  [R1]
         { info_tbl: [(c1DKz,
                       label: sat_s1CX1_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DKz: // global
           _s1CX1::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1DKA; else goto c1DKB;
       c1DKB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1DKD; else goto c1DKC;
       c1DKD: // global
           HpAlloc = 56;
           goto c1DKA;
       c1DKA: // global
           R1 = _s1CX1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DKC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CX1::P64;
           _s1CWy::P64 = P64[_s1CX1::P64 + 16];
           _s1CWK::P64 = P64[_s1CX1::P64 + 24];
           _s1CWX::P64 = P64[_s1CX1::P64 + 32];
           I64[Hp - 48] = sat_s1CX0_info;
           P64[Hp - 32] = _s1CWK::P64;
           I64[Hp - 24] = sat_s1CWZ_info;
           P64[Hp - 8] = _s1CWy::P64;
           P64[Hp] = _s1CWX::P64;
           R2 = _s1CWK::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1CX8_entry() //  [R1]
         { info_tbl: [(c1DKO,
                       label: sat_s1CX8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DKO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1DKP; else goto c1DKQ;
       c1DKP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DKQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CX6_entry() //  [R1]
         { info_tbl: [(c1DL2,
                       label: sat_s1CX6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DL2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1DL9; else goto c1DLa;
       c1DL9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DLa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1DKZ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1DLe; else goto c1DL0;
       u1DLe: // global
           call _c1DKZ(R1) args: 0, res: 0, upd: 0;
       c1DL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1DKZ() //  [R1]
         { info_tbl: [(c1DKZ,
                       label: block_c1DKZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DKZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DLd; else goto c1DLc;
       c1DLd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1DLc: // global
           _s1CX5::I64 = I64[R1 + 7] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CX5::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1CX7_entry() //  [R1]
         { info_tbl: [(c1DLf,
                       label: sat_s1CX7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DLf: // global
           _s1CX7::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1DLg; else goto c1DLh;
       c1DLh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1DLj; else goto c1DLi;
       c1DLj: // global
           HpAlloc = 24;
           goto c1DLg;
       c1DLg: // global
           R1 = _s1CX7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DLi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CX7::P64;
           _s1CWy::P64 = P64[_s1CX7::P64 + 16];
           _s1CWX::P64 = P64[_s1CX7::P64 + 24];
           I64[Hp - 16] = sat_s1CX6_info;
           P64[Hp] = _s1CWX::P64;
           R2 = _s1CWy::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CX9_entry() //  [R1]
         { info_tbl: [(c1DLk,
                       label: sat_s1CX9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DLk: // global
           _s1CX9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1DLl; else goto c1DLm;
       c1DLm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1DLo; else goto c1DLn;
       c1DLo: // global
           HpAlloc = 56;
           goto c1DLl;
       c1DLl: // global
           R1 = _s1CX9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DLn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CX9::P64;
           _s1CWy::P64 = P64[_s1CX9::P64 + 16];
           _s1CWK::P64 = P64[_s1CX9::P64 + 24];
           _s1CWX::P64 = P64[_s1CX9::P64 + 32];
           I64[Hp - 48] = sat_s1CX8_info;
           P64[Hp - 32] = _s1CWK::P64;
           I64[Hp - 24] = sat_s1CX7_info;
           P64[Hp - 8] = _s1CWy::P64;
           P64[Hp] = _s1CWX::P64;
           R2 = _s1CWK::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1CYp_entry() //  [R1]
         { info_tbl: [(c1DMl,
                       label: sat_s1CYp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DMl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1DMs; else goto c1DMt;
       c1DMs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DMt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1DMi_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1DMx; else goto c1DMj;
       u1DMx: // global
           call _c1DMi(R1) args: 0, res: 0, upd: 0;
       c1DMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1DMi() //  [R1]
         { info_tbl: [(c1DMi,
                       label: block_c1DMi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DMi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DMw; else goto c1DMv;
       c1DMw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1DMv: // global
           _s1CYo::I64 = I64[R1 + 7] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CYo::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1CYq_entry() //  [R1]
         { info_tbl: [(c1DMy,
                       label: sat_s1CYq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DMy: // global
           _s1CYq::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1DMz; else goto c1DMA;
       c1DMA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1DMC; else goto c1DMB;
       c1DMC: // global
           HpAlloc = 24;
           goto c1DMz;
       c1DMz: // global
           R1 = _s1CYq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DMB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CYq::P64;
           _s1CWy::P64 = P64[_s1CYq::P64 + 16];
           _s1CYl::P64 = P64[_s1CYq::P64 + 24];
           I64[Hp - 16] = sat_s1CYp_info;
           P64[Hp] = _s1CYl::P64;
           R2 = _s1CWy::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CYr_entry() //  [R1]
         { info_tbl: [(c1DMD,
                       label: sat_s1CYr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DMD: // global
           _s1CYr::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1DME; else goto c1DMF;
       c1DMF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1DMH; else goto c1DMG;
       c1DMH: // global
           HpAlloc = 32;
           goto c1DME;
       c1DME: // global
           R1 = _s1CYr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DMG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CYr::P64;
           _s1CWy::P64 = P64[_s1CYr::P64 + 16];
           _s1CWK::P64 = P64[_s1CYr::P64 + 24];
           _s1CYl::P64 = P64[_s1CYr::P64 + 32];
           I64[Hp - 24] = sat_s1CYq_info;
           P64[Hp - 8] = _s1CWy::P64;
           P64[Hp] = _s1CYl::P64;
           R2 = _s1CWK::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CYv_entry() //  [R1]
         { info_tbl: [(c1DMX,
                       label: sat_s1CYv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DMX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1DMY; else goto c1DMZ;
       c1DMY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1DMZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.toIntegralSized_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1DN0,
                       label: Data.Bits.toIntegralSized_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DN0: // global
           if ((Sp + -104) < SpLim) (likely: False) goto c1DN1; else goto c1DN2;
       c1DN1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.toIntegralSized_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1DN2: // global
           I64[Sp - 48] = block_c1DIy_info;
           _s1CWw::P64 = R2;
           R2 = R4;
           I64[Sp - 64] = stg_ap_p_info;
           P64[Sp - 56] = R6;
           P64[Sp - 40] = _s1CWw::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 64;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1DIy() //  [R1]
         { info_tbl: [(c1DIy,
                       label: block_c1DIy_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DIy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1DN5; else goto c1DN4;
       c1DN5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DN4: // global
           I64[Hp - 32] = y_s1CWC_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 40];
           I64[Sp - 8] = block_c1DJ2_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_p_info;
           _c1DIC::P64 = Hp - 32;
           P64[Sp - 16] = _c1DIC::P64;
           P64[Sp] = R1;
           P64[Sp + 16] = _c1DIC::P64;
           Sp = Sp - 24;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1DJ2() //  [R1]
         { info_tbl: [(c1DJ2,
                       label: block_c1DJ2_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DJ2: // global
           I64[Sp] = block_c1DJ6_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 40] = R1;
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1DJ6() //  [R1]
         { info_tbl: [(c1DJ6,
                       label: block_c1DJ6_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DJ6: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1DNc; else goto c1DNb;
       c1DNc: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DNb: // global
           I64[Hp - 96] = xSigned_s1CWI_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 48];
           I64[Hp - 64] = $dReal_s1CWJ_info;
           P64[Hp - 48] = P64[Sp + 16];
           I64[Hp - 40] = $dNum_s1CWK_info;
           _c1DJh::P64 = Hp - 64;
           P64[Hp - 24] = _c1DJh::P64;
           I64[Hp - 16] = $dOrd_s1CWL_info;
           P64[Hp] = _c1DJh::P64;
           I64[Sp - 24] = block_c1DN9_info;
           _s1CWH::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1CWH::P64;
           P64[Sp] = Hp - 40;
           P64[Sp + 16] = Hp - 96;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1E2w; else goto c1DZF;
       u1E2w: // global
           call _c1DN9(R1) args: 0, res: 0, upd: 0;
       c1DZF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DN9() //  [R1]
         { info_tbl: [(c1DN9,
                       label: block_c1DN9_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DN9: // global
           _s1CWH::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1DZM; else goto c1E02;
       c1DZM: // global
           I64[Sp] = block_c1DZJ_info;
           R1 = _s1CWH::P64;
           if (R1 & 7 != 0) goto u1E2G; else goto c1DZN;
       u1E2G: // global
           call _c1DZJ(R1) args: 0, res: 0, upd: 0;
       c1DZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1E02: // global
           I64[Sp - 8] = block_c1E00_info;
           _s1CZb::P64 = P64[R1 + 6];
           R1 = _s1CWH::P64;
           P64[Sp] = _s1CZb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E2H; else goto c1E03;
       u1E2H: // global
           call _c1E00(R1) args: 0, res: 0, upd: 0;
       c1E03: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DZJ() //  [R1]
         { info_tbl: [(c1DZJ,
                       label: block_c1DZJ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DZJ: // global
           if (R1 & 7 == 1) goto u1E1r; else goto u1E1s;
       u1E1r: // global
           Sp = Sp + 8;
           call _s1CZ4() args: 0, res: 0, upd: 0;
       u1E1s: // global
           Sp = Sp + 8;
           call _s1CY9() args: 0, res: 0, upd: 0;
     }
 },
 _c1E00() //  [R1]
         { info_tbl: [(c1E00,
                       label: block_c1E00_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E00: // global
           if (R1 & 7 == 1) goto u1E1o; else goto c1E0j;
       u1E1o: // global
           Sp = Sp + 16;
           call _s1CY9() args: 0, res: 0, upd: 0;
       c1E0j: // global
           I64[Sp] = block_c1E0c_info;
           _s1CZd::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CZd::P64;
           if (R1 & 7 != 0) goto u1E4m; else goto c1E0d;
       u1E4m: // global
           call _c1E0c(R1) args: 0, res: 0, upd: 0;
       c1E0d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E0c() //  [R1]
         { info_tbl: [(c1E0c,
                       label: block_c1E0c_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E0c: // global
           I64[Sp] = block_c1E0h_info;
           _s1CZf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CZf::I64;
           if (R1 & 7 != 0) goto u1E4o; else goto c1E0l;
       u1E4o: // global
           call _c1E0h(R1) args: 0, res: 0, upd: 0;
       c1E0l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E0h() //  [R1]
         { info_tbl: [(c1E0h,
                       label: block_c1E0h_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E0h: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u1E1p; else goto u1E1q;
       u1E1p: // global
           Sp = Sp + 16;
           call _s1CZ4() args: 0, res: 0, upd: 0;
       u1E1q: // global
           Sp = Sp + 16;
           call _s1CY9() args: 0, res: 0, upd: 0;
     }
 },
 _s1CZ4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CZ4: // global
           I64[Sp - 8] = block_c1DZ4_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4H; else goto c1DZ6;
       u1E4H: // global
           call _c1DZ4(R1) args: 0, res: 0, upd: 0;
       c1DZ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DZ4() //  [R1]
         { info_tbl: [(c1DZ4,
                       label: block_c1DZ4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DZ4: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1DZd; else goto c1DZt;
       c1DZd: // global
           I64[Sp] = block_c1DZa_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1E4e; else goto c1DZe;
       u1E4e: // global
           call _c1DZa(R1) args: 0, res: 0, upd: 0;
       c1DZe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1DZt: // global
           I64[Sp] = block_c1DZr_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1E4f; else goto c1DZu;
       u1E4f: // global
           call _c1DZr(R1) args: 0, res: 0, upd: 0;
       c1DZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DZa() //  [R1]
         { info_tbl: [(c1DZa,
                       label: block_c1DZa_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DZa: // global
           if (R1 & 7 == 1) goto u1E1v; else goto u1E1w;
       u1E1v: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       u1E1w: // global
           Sp = Sp + 8;
           call _s1CY9() args: 0, res: 0, upd: 0;
     }
 },
 _c1DZr() //  [R1]
         { info_tbl: [(c1DZr,
                       label: block_c1DZr_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DZr: // global
           if (R1 & 7 == 1) goto u1E1t; else goto u1E1u;
       u1E1t: // global
           Sp = Sp + 8;
           call _s1CY9() args: 0, res: 0, upd: 0;
       u1E1u: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CY9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CY9: // global
           I64[Sp - 8] = block_c1DUz_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4A; else goto c1DYE;
       u1E4A: // global
           call _c1DUz(R1) args: 0, res: 0, upd: 0;
       c1DYE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DUz() //  [R1]
         { info_tbl: [(c1DUz,
                       label: block_c1DUz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DUz: // global
           if (R1 & 7 == 1) goto u1E1x; else goto c1DYP;
       u1E1x: // global
           Sp = Sp + 8;
           call _s1CYb() args: 0, res: 0, upd: 0;
       c1DYP: // global
           I64[Sp] = block_c1DYN_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1E3C; else goto c1DYQ;
       u1E3C: // global
           call _c1DYN(R1) args: 0, res: 0, upd: 0;
       c1DYQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DYN() //  [R1]
         { info_tbl: [(c1DYN,
                       label: block_c1DYN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DYN: // global
           if (R1 & 7 == 1) goto u1E1y; else goto u1E1z;
       u1E1y: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       u1E1z: // global
           Sp = Sp + 8;
           call _s1CYb() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYb: // global
           I64[Sp - 8] = block_c1DUB_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4B; else goto c1DY5;
       u1E4B: // global
           call _c1DUB(R1) args: 0, res: 0, upd: 0;
       c1DY5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DUB() //  [R1]
         { info_tbl: [(c1DUB,
                       label: block_c1DUB_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DUB: // global
           if (R1 & 7 == 1) goto c1DYc; else goto u1E1A;
       c1DYc: // global
           I64[Sp] = block_c1DY9_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1E3E; else goto c1DYd;
       u1E3E: // global
           call _c1DY9(R1) args: 0, res: 0, upd: 0;
       c1DYd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1E1A: // global
           Sp = Sp + 8;
           call _s1CYd() args: 0, res: 0, upd: 0;
     }
 },
 _c1DY9() //  [R1]
         { info_tbl: [(c1DY9,
                       label: block_c1DY9_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DY9: // global
           if (R1 & 7 == 1) goto c1DYk; else goto u1E1B;
       c1DYk: // global
           I64[Sp] = block_c1DYh_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1E48; else goto c1DYl;
       u1E48: // global
           call _c1DYh(R1) args: 0, res: 0, upd: 0;
       c1DYl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1E1B: // global
           Sp = Sp + 8;
           call _s1CYd() args: 0, res: 0, upd: 0;
     }
 },
 _c1DYh() //  [R1]
         { info_tbl: [(c1DYh,
                       label: block_c1DYh_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DYh: // global
           if (R1 & 7 == 1) goto u1E1C; else goto u1E1D;
       u1E1C: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       u1E1D: // global
           Sp = Sp + 8;
           call _s1CYd() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYd: // global
           I64[Sp - 8] = block_c1DUH_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4C; else goto c1DXw;
       u1E4C: // global
           call _c1DUH(R1) args: 0, res: 0, upd: 0;
       c1DXw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DUH() //  [R1]
         { info_tbl: [(c1DUH,
                       label: block_c1DUH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DUH: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1DXD; else goto c1DXT;
       c1DXD: // global
           I64[Sp] = block_c1DXA_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1E3G; else goto c1DXE;
       u1E3G: // global
           call _c1DXA(R1) args: 0, res: 0, upd: 0;
       c1DXE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1DXT: // global
           I64[Sp] = block_c1DXR_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1E3H; else goto c1DXU;
       u1E3H: // global
           call _c1DXR(R1) args: 0, res: 0, upd: 0;
       c1DXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DXA() //  [R1]
         { info_tbl: [(c1DXA,
                       label: block_c1DXA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DXA: // global
           if (R1 & 7 == 1) goto u1E1G; else goto u1E1H;
       u1E1G: // global
           Sp = Sp + 8;
           call _s1CYK() args: 0, res: 0, upd: 0;
       u1E1H: // global
           Sp = Sp + 8;
           call _s1CYx() args: 0, res: 0, upd: 0;
     }
 },
 _c1DXR() //  [R1]
         { info_tbl: [(c1DXR,
                       label: block_c1DXR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DXR: // global
           if (R1 & 7 == 1) goto u1E1E; else goto u1E1F;
       u1E1E: // global
           Sp = Sp + 8;
           call _s1CYx() args: 0, res: 0, upd: 0;
       u1E1F: // global
           Sp = Sp + 8;
           call _s1CYK() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYK: // global
           I64[Sp - 8] = block_c1DWQ_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4G; else goto c1DWS;
       u1E4G: // global
           call _c1DWQ(R1) args: 0, res: 0, upd: 0;
       c1DWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DWQ() //  [R1]
         { info_tbl: [(c1DWQ,
                       label: block_c1DWQ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DWQ: // global
           if (R1 & 7 == 1) goto u1E1I; else goto c1DX3;
       u1E1I: // global
           Sp = Sp + 8;
           call _s1CYx() args: 0, res: 0, upd: 0;
       c1DX3: // global
           I64[Sp - 8] = block_c1DX1_info;
           _s1CYM::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CYM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E3X; else goto c1DX4;
       u1E3X: // global
           call _c1DX1(R1) args: 0, res: 0, upd: 0;
       c1DX4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DX1() //  [R1]
         { info_tbl: [(c1DX1,
                       label: block_c1DX1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DX1: // global
           if (R1 & 7 == 1) goto u1E1J; else goto c1DXk;
       u1E1J: // global
           Sp = Sp + 16;
           call _s1CYx() args: 0, res: 0, upd: 0;
       c1DXk: // global
           I64[Sp] = block_c1DXd_info;
           _s1CYO::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CYO::P64;
           if (R1 & 7 != 0) goto u1E3Z; else goto c1DXe;
       u1E3Z: // global
           call _c1DXd(R1) args: 0, res: 0, upd: 0;
       c1DXe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _s1CYx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYx: // global
           I64[Sp - 8] = block_c1DVJ_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4F; else goto c1DVL;
       u1E4F: // global
           call _c1DVJ(R1) args: 0, res: 0, upd: 0;
       c1DVL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DVJ() //  [R1]
         { info_tbl: [(c1DVJ,
                       label: block_c1DVJ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DVJ: // global
           if (R1 & 7 == 1) goto c1DVS; else goto u1E1M;
       c1DVS: // global
           I64[Sp] = block_c1DVP_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1E3M; else goto c1DVT;
       u1E3M: // global
           call _c1DVP(R1) args: 0, res: 0, upd: 0;
       c1DVT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1E1M: // global
           Sp = Sp + 8;
           call _s1CYf() args: 0, res: 0, upd: 0;
     }
 },
 _c1DVP() //  [R1]
         { info_tbl: [(c1DVP,
                       label: block_c1DVP_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DVP: // global
           if (R1 & 7 == 1) goto u1E1N; else goto c1DW4;
       u1E1N: // global
           Sp = Sp + 8;
           call _s1CYf() args: 0, res: 0, upd: 0;
       c1DW4: // global
           I64[Sp] = block_c1DW2_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1E3O; else goto c1DW5;
       u1E3O: // global
           call _c1DW2(R1) args: 0, res: 0, upd: 0;
       c1DW5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DW2() //  [R1]
         { info_tbl: [(c1DW2,
                       label: block_c1DW2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DW2: // global
           if (R1 & 7 == 1) goto u1E1O; else goto c1DWg;
       u1E1O: // global
           Sp = Sp + 8;
           call _s1CYf() args: 0, res: 0, upd: 0;
       c1DWg: // global
           I64[Sp - 8] = block_c1DWe_info;
           _s1CYC::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CYC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E3Q; else goto c1DWh;
       u1E3Q: // global
           call _c1DWe(R1) args: 0, res: 0, upd: 0;
       c1DWh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DWe() //  [R1]
         { info_tbl: [(c1DWe,
                       label: block_c1DWe_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DWe: // global
           if (R1 & 7 == 1) goto u1E1P; else goto c1DWx;
       u1E1P: // global
           Sp = Sp + 16;
           call _s1CYf() args: 0, res: 0, upd: 0;
       c1DWx: // global
           I64[Sp] = block_c1DWq_info;
           _s1CYE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CYE::P64;
           if (R1 & 7 != 0) goto u1E3S; else goto c1DWr;
       u1E3S: // global
           call _c1DWq(R1) args: 0, res: 0, upd: 0;
       c1DWr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DWq() //  [R1]
         { info_tbl: [(c1DWq,
                       label: block_c1DWq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DWq: // global
           I64[Sp] = block_c1DWv_info;
           _s1CYG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CYG::I64;
           if (R1 & 7 != 0) goto u1E3U; else goto c1DWz;
       u1E3U: // global
           call _c1DWv(R1) args: 0, res: 0, upd: 0;
       c1DWz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DWv() //  [R1]
         { info_tbl: [(c1DWv,
                       label: block_c1DWv_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DWv: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1E1R; else goto u1E1Q;
       u1E1R: // global
           Sp = Sp + 16;
           call _s1CYf() args: 0, res: 0, upd: 0;
       u1E1Q: // global
           Sp = Sp + 16;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _c1DXd() //  [R1]
         { info_tbl: [(c1DXd,
                       label: block_c1DXd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DXd: // global
           I64[Sp] = block_c1DXi_info;
           _s1CYQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CYQ::I64;
           if (R1 & 7 != 0) goto u1E41; else goto c1DXm;
       u1E41: // global
           call _c1DXi(R1) args: 0, res: 0, upd: 0;
       c1DXm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DXi() //  [R1]
         { info_tbl: [(c1DXi,
                       label: block_c1DXi_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DXi: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1E1L; else goto u1E1K;
       u1E1L: // global
           Sp = Sp + 16;
           call _s1CYf() args: 0, res: 0, upd: 0;
       u1E1K: // global
           Sp = Sp + 16;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYf: // global
           I64[Sp - 8] = block_c1DMI_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4D; else goto c1DMJ;
       u1E4D: // global
           call _c1DMI(R1) args: 0, res: 0, upd: 0;
       c1DMJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DMI() //  [R1]
         { info_tbl: [(c1DMI,
                       label: block_c1DMI_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DMI: // global
           if (R1 & 7 == 1) goto u1E1S; else goto c1DVl;
       u1E1S: // global
           Sp = Sp + 8;
           call _s1CYg() args: 0, res: 0, upd: 0;
       c1DVl: // global
           I64[Sp] = block_c1DMO_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1E2D; else goto c1DMP;
       u1E2D: // global
           call _c1DMO(R1) args: 0, res: 0, upd: 0;
       c1DMP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DMO() //  [R1]
         { info_tbl: [(c1DMO,
                       label: block_c1DMO_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DMO: // global
           if (R1 & 7 == 1) goto c1DVo; else goto u1E1T;
       c1DVo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1DVr; else goto c1DVq;
       c1DVr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DVq: // global
           I64[Hp - 16] = sat_s1CYv_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1DVm_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
       u1E1T: // global
           Sp = Sp + 8;
           call _s1CYg() args: 0, res: 0, upd: 0;
     }
 },
 _c1DVm() //  [R1]
         { info_tbl: [(c1DVm,
                       label: block_c1DVm_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DVm: // global
           if (R1 & 7 == 1) goto u1E1U; else goto u1E1V;
       u1E1U: // global
           Sp = Sp + 80;
           call _c1DVx() args: 0, res: 0, upd: 0;
       u1E1V: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYg: // global
           I64[Sp - 8] = block_c1DLO_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4E; else goto c1DLP;
       u1E4E: // global
           call _c1DLO(R1) args: 0, res: 0, upd: 0;
       c1DLP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DLO() //  [R1]
         { info_tbl: [(c1DLO,
                       label: block_c1DLO_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DLO: // global
           if (R1 & 7 == 1) goto u1E1W; else goto c1DUQ;
       u1E1W: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       c1DUQ: // global
           I64[Sp] = block_c1DLU_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1E2y; else goto c1DLV;
       u1E2y: // global
           call _c1DLU(R1) args: 0, res: 0, upd: 0;
       c1DLV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DLU() //  [R1]
         { info_tbl: [(c1DLU,
                       label: block_c1DLU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DLU: // global
           if (R1 & 7 == 1) goto u1E1X; else goto c1DUW;
       u1E1X: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       c1DUW: // global
           I64[Sp] = block_c1DM0_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1E2A; else goto c1DM1;
       u1E2A: // global
           call _c1DM0(R1) args: 0, res: 0, upd: 0;
       c1DM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DM0() //  [R1]
         { info_tbl: [(c1DM0,
                       label: block_c1DM0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DM0: // global
           if (R1 & 7 == 1) goto u1E1Y; else goto c1DV2;
       u1E1Y: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       c1DV2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1DV5; else goto c1DV4;
       c1DV5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DV4: // global
           _s1CYl::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_s1CYr_info;
           P64[Hp - 16] = P64[Sp + 56];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s1CYl::P64;
           I64[Sp] = block_c1DV1_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1DV1() //  [R1]
         { info_tbl: [(c1DV1,
                       label: block_c1DV1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DV1: // global
           if (R1 & 7 == 1) goto u1E1Z; else goto u1E20;
       u1E1Z: // global
           Sp = Sp + 80;
           call _c1DVx() args: 0, res: 0, upd: 0;
       u1E20: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWM: // global
           I64[Sp - 8] = block_c1DNf_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4r; else goto c1DTJ;
       u1E4r: // global
           call _c1DNf(R1) args: 0, res: 0, upd: 0;
       c1DTJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DNf() //  [R1]
         { info_tbl: [(c1DNf,
                       label: block_c1DNf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DNf: // global
           _s1CWH::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1DTQ; else goto c1DU6;
       c1DTQ: // global
           I64[Sp] = block_c1DTN_info;
           R1 = _s1CWH::P64;
           if (R1 & 7 != 0) goto u1E2I; else goto c1DTR;
       u1E2I: // global
           call _c1DTN(R1) args: 0, res: 0, upd: 0;
       c1DTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1DU6: // global
           I64[Sp - 8] = block_c1DU4_info;
           _s1CY1::P64 = P64[R1 + 6];
           R1 = _s1CWH::P64;
           P64[Sp] = _s1CY1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E2J; else goto c1DU7;
       u1E2J: // global
           call _c1DU4(R1) args: 0, res: 0, upd: 0;
       c1DU7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DTN() //  [R1]
         { info_tbl: [(c1DTN,
                       label: block_c1DTN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DTN: // global
           if (R1 & 7 == 1) goto u1E24; else goto u1E25;
       u1E24: // global
           Sp = Sp + 8;
           call _s1CXU() args: 0, res: 0, upd: 0;
       u1E25: // global
           Sp = Sp + 8;
           call _s1CWN() args: 0, res: 0, upd: 0;
     }
 },
 _c1DU4() //  [R1]
         { info_tbl: [(c1DU4,
                       label: block_c1DU4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DU4: // global
           if (R1 & 7 == 1) goto u1E21; else goto c1DUn;
       u1E21: // global
           Sp = Sp + 16;
           call _s1CWN() args: 0, res: 0, upd: 0;
       c1DUn: // global
           I64[Sp] = block_c1DUg_info;
           _s1CY3::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CY3::P64;
           if (R1 & 7 != 0) goto u1E3x; else goto c1DUh;
       u1E3x: // global
           call _c1DUg(R1) args: 0, res: 0, upd: 0;
       c1DUh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DUg() //  [R1]
         { info_tbl: [(c1DUg,
                       label: block_c1DUg_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DUg: // global
           I64[Sp] = block_c1DUl_info;
           _s1CY5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CY5::I64;
           if (R1 & 7 != 0) goto u1E3z; else goto c1DUp;
       u1E3z: // global
           call _c1DUl(R1) args: 0, res: 0, upd: 0;
       c1DUp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DUl() //  [R1]
         { info_tbl: [(c1DUl,
                       label: block_c1DUl_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DUl: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u1E22; else goto u1E23;
       u1E22: // global
           Sp = Sp + 16;
           call _s1CXU() args: 0, res: 0, upd: 0;
       u1E23: // global
           Sp = Sp + 16;
           call _s1CWN() args: 0, res: 0, upd: 0;
     }
 },
 _s1CXU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CXU: // global
           I64[Sp - 8] = block_c1DT2_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4z; else goto c1DT4;
       u1E4z: // global
           call _c1DT2(R1) args: 0, res: 0, upd: 0;
       c1DT4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DT2() //  [R1]
         { info_tbl: [(c1DT2,
                       label: block_c1DT2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DT2: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1DTb; else goto c1DTu;
       c1DTb: // global
           I64[Sp] = block_c1DT8_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1E3r; else goto c1DTc;
       u1E3r: // global
           call _c1DT8(R1) args: 0, res: 0, upd: 0;
       c1DTc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1DTu: // global
           I64[Sp] = block_c1DTs_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1E3s; else goto c1DTv;
       u1E3s: // global
           call _c1DTs(R1) args: 0, res: 0, upd: 0;
       c1DTv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DT8() //  [R1]
         { info_tbl: [(c1DT8,
                       label: block_c1DT8_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DT8: // global
           if (R1 & 7 == 1) goto c1DTi; else goto u1E27;
       c1DTi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DTl; else goto c1DTk;
       c1DTl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DTk: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1E27: // global
           Sp = Sp + 8;
           call _s1CWN() args: 0, res: 0, upd: 0;
     }
 },
 _c1DTs() //  [R1]
         { info_tbl: [(c1DTs,
                       label: block_c1DTs_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DTs: // global
           if (R1 & 7 == 1) goto u1E26; else goto c1DTF;
       u1E26: // global
           Sp = Sp + 8;
           call _s1CWN() args: 0, res: 0, upd: 0;
       c1DTF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DTI; else goto c1DTH;
       c1DTI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DTH: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1CWN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWN: // global
           I64[Sp - 8] = block_c1DNh_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4s; else goto c1DSz;
       u1E4s: // global
           call _c1DNh(R1) args: 0, res: 0, upd: 0;
       c1DSz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DNh() //  [R1]
         { info_tbl: [(c1DNh,
                       label: block_c1DNh_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DNh: // global
           if (R1 & 7 == 1) goto u1E28; else goto c1DSK;
       u1E28: // global
           Sp = Sp + 8;
           call _s1CWP() args: 0, res: 0, upd: 0;
       c1DSK: // global
           I64[Sp] = block_c1DSI_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1E2K; else goto c1DSL;
       u1E2K: // global
           call _c1DSI(R1) args: 0, res: 0, upd: 0;
       c1DSL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DSI() //  [R1]
         { info_tbl: [(c1DSI,
                       label: block_c1DSI_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DSI: // global
           if (R1 & 7 == 1) goto c1DSR; else goto u1E29;
       c1DSR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DSU; else goto c1DST;
       c1DSU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DST: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1E29: // global
           Sp = Sp + 8;
           call _s1CWP() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWP: // global
           I64[Sp - 8] = block_c1DNj_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4t; else goto c1DRX;
       u1E4t: // global
           call _c1DNj(R1) args: 0, res: 0, upd: 0;
       c1DRX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DNj() //  [R1]
         { info_tbl: [(c1DNj,
                       label: block_c1DNj_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DNj: // global
           if (R1 & 7 == 1) goto c1DS4; else goto u1E2a;
       c1DS4: // global
           I64[Sp] = block_c1DS1_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1E2M; else goto c1DS5;
       u1E2M: // global
           call _c1DS1(R1) args: 0, res: 0, upd: 0;
       c1DS5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1E2a: // global
           Sp = Sp + 8;
           call _s1CWR() args: 0, res: 0, upd: 0;
     }
 },
 _c1DS1() //  [R1]
         { info_tbl: [(c1DS1,
                       label: block_c1DS1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DS1: // global
           if (R1 & 7 == 1) goto c1DSc; else goto u1E2b;
       c1DSc: // global
           I64[Sp] = block_c1DS9_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1E3n; else goto c1DSd;
       u1E3n: // global
           call _c1DS9(R1) args: 0, res: 0, upd: 0;
       c1DSd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1E2b: // global
           Sp = Sp + 8;
           call _s1CWR() args: 0, res: 0, upd: 0;
     }
 },
 _c1DS9() //  [R1]
         { info_tbl: [(c1DS9,
                       label: block_c1DS9_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DS9: // global
           if (R1 & 7 == 1) goto c1DSj; else goto u1E2c;
       c1DSj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DSm; else goto c1DSl;
       c1DSm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DSl: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1E2c: // global
           Sp = Sp + 8;
           call _s1CWR() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWR: // global
           I64[Sp - 8] = block_c1DNp_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4u; else goto c1DRo;
       u1E4u: // global
           call _c1DNp(R1) args: 0, res: 0, upd: 0;
       c1DRo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DNp() //  [R1]
         { info_tbl: [(c1DNp,
                       label: block_c1DNp_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DNp: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1DRv; else goto c1DRL;
       c1DRv: // global
           I64[Sp] = block_c1DRs_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1E2O; else goto c1DRw;
       u1E2O: // global
           call _c1DRs(R1) args: 0, res: 0, upd: 0;
       c1DRw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1DRL: // global
           I64[Sp] = block_c1DRJ_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1E2P; else goto c1DRM;
       u1E2P: // global
           call _c1DRJ(R1) args: 0, res: 0, upd: 0;
       c1DRM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DRs() //  [R1]
         { info_tbl: [(c1DRs,
                       label: block_c1DRs_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DRs: // global
           if (R1 & 7 == 1) goto u1E2f; else goto u1E2g;
       u1E2f: // global
           Sp = Sp + 8;
           call _s1CXA() args: 0, res: 0, upd: 0;
       u1E2g: // global
           Sp = Sp + 8;
           call _s1CXn() args: 0, res: 0, upd: 0;
     }
 },
 _c1DRJ() //  [R1]
         { info_tbl: [(c1DRJ,
                       label: block_c1DRJ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DRJ: // global
           if (R1 & 7 == 1) goto u1E2d; else goto u1E2e;
       u1E2d: // global
           Sp = Sp + 8;
           call _s1CXn() args: 0, res: 0, upd: 0;
       u1E2e: // global
           Sp = Sp + 8;
           call _s1CXA() args: 0, res: 0, upd: 0;
     }
 },
 _s1CXA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CXA: // global
           I64[Sp - 8] = block_c1DQD_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4y; else goto c1DQF;
       u1E4y: // global
           call _c1DQD(R1) args: 0, res: 0, upd: 0;
       c1DQF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DQD() //  [R1]
         { info_tbl: [(c1DQD,
                       label: block_c1DQD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DQD: // global
           if (R1 & 7 == 1) goto u1E2h; else goto c1DQQ;
       u1E2h: // global
           Sp = Sp + 8;
           call _s1CXn() args: 0, res: 0, upd: 0;
       c1DQQ: // global
           I64[Sp - 8] = block_c1DQO_info;
           _s1CXC::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CXC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E3c; else goto c1DQR;
       u1E3c: // global
           call _c1DQO(R1) args: 0, res: 0, upd: 0;
       c1DQR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DQO() //  [R1]
         { info_tbl: [(c1DQO,
                       label: block_c1DQO_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DQO: // global
           if (R1 & 7 == 1) goto u1E2i; else goto c1DR7;
       u1E2i: // global
           Sp = Sp + 16;
           call _s1CXn() args: 0, res: 0, upd: 0;
       c1DR7: // global
           I64[Sp] = block_c1DR0_info;
           _s1CXE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CXE::P64;
           if (R1 & 7 != 0) goto u1E3e; else goto c1DR1;
       u1E3e: // global
           call _c1DR0(R1) args: 0, res: 0, upd: 0;
       c1DR1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _s1CXn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CXn: // global
           I64[Sp - 8] = block_c1DPr_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4x; else goto c1DPt;
       u1E4x: // global
           call _c1DPr(R1) args: 0, res: 0, upd: 0;
       c1DPt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DPr() //  [R1]
         { info_tbl: [(c1DPr,
                       label: block_c1DPr_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DPr: // global
           if (R1 & 7 == 1) goto c1DPA; else goto u1E2k;
       c1DPA: // global
           I64[Sp] = block_c1DPx_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1E32; else goto c1DPB;
       u1E32: // global
           call _c1DPx(R1) args: 0, res: 0, upd: 0;
       c1DPB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1E2k: // global
           Sp = Sp + 8;
           call _s1CWT() args: 0, res: 0, upd: 0;
     }
 },
 _c1DPx() //  [R1]
         { info_tbl: [(c1DPx,
                       label: block_c1DPx_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DPx: // global
           if (R1 & 7 == 1) goto u1E2l; else goto c1DPM;
       u1E2l: // global
           Sp = Sp + 8;
           call _s1CWT() args: 0, res: 0, upd: 0;
       c1DPM: // global
           I64[Sp] = block_c1DPK_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1E34; else goto c1DPN;
       u1E34: // global
           call _c1DPK(R1) args: 0, res: 0, upd: 0;
       c1DPN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DPK() //  [R1]
         { info_tbl: [(c1DPK,
                       label: block_c1DPK_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DPK: // global
           if (R1 & 7 == 1) goto u1E2m; else goto c1DPY;
       u1E2m: // global
           Sp = Sp + 8;
           call _s1CWT() args: 0, res: 0, upd: 0;
       c1DPY: // global
           I64[Sp - 8] = block_c1DPW_info;
           _s1CXs::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CXs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E36; else goto c1DPZ;
       u1E36: // global
           call _c1DPW(R1) args: 0, res: 0, upd: 0;
       c1DPZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DPW() //  [R1]
         { info_tbl: [(c1DPW,
                       label: block_c1DPW_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DPW: // global
           if (R1 & 7 == 1) goto u1E2n; else goto c1DQf;
       u1E2n: // global
           Sp = Sp + 16;
           call _s1CWT() args: 0, res: 0, upd: 0;
       c1DQf: // global
           I64[Sp] = block_c1DQ8_info;
           _s1CXu::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CXu::P64;
           if (R1 & 7 != 0) goto u1E38; else goto c1DQ9;
       u1E38: // global
           call _c1DQ8(R1) args: 0, res: 0, upd: 0;
       c1DQ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DQ8() //  [R1]
         { info_tbl: [(c1DQ8,
                       label: block_c1DQ8_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DQ8: // global
           I64[Sp] = block_c1DQd_info;
           _s1CXw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CXw::I64;
           if (R1 & 7 != 0) goto u1E3a; else goto c1DQh;
       u1E3a: // global
           call _c1DQd(R1) args: 0, res: 0, upd: 0;
       c1DQh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DQd() //  [R1]
         { info_tbl: [(c1DQd,
                       label: block_c1DQd_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DQd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DQn; else goto c1DQm;
       c1DQn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DQm: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1E2o; else goto c1DQv;
       u1E2o: // global
           Sp = Sp + 16;
           call _c1DRj() args: 0, res: 0, upd: 0;
       c1DQv: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 6;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1DR0() //  [R1]
         { info_tbl: [(c1DR0,
                       label: block_c1DR0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DR0: // global
           I64[Sp] = block_c1DR5_info;
           _s1CXG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CXG::I64;
           if (R1 & 7 != 0) goto u1E3g; else goto c1DR9;
       u1E3g: // global
           call _c1DR5(R1) args: 0, res: 0, upd: 0;
       c1DR9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DR5() //  [R1]
         { info_tbl: [(c1DR5,
                       label: block_c1DR5_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DR5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DRf; else goto c1DRe;
       c1DRf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DRe: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1E2j; else goto c1DRn;
       u1E2j: // global
           Sp = Sp + 16;
           call _c1DRj() args: 0, res: 0, upd: 0;
       c1DRn: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 6;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1DRj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DRj: // global
           Hp = Hp - 16;
           call _s1CWT() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWT: // global
           I64[Sp - 8] = block_c1DNr_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4v; else goto c1DOe;
       u1E4v: // global
           call _c1DNr(R1) args: 0, res: 0, upd: 0;
       c1DOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DNr() //  [R1]
         { info_tbl: [(c1DNr,
                       label: block_c1DNr_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DNr: // global
           if (R1 & 7 == 1) goto u1E2p; else goto c1DOp;
       u1E2p: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1DOp: // global
           I64[Sp] = block_c1DOn_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1E2Q; else goto c1DOq;
       u1E2Q: // global
           call _c1DOn(R1) args: 0, res: 0, upd: 0;
       c1DOq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DOn() //  [R1]
         { info_tbl: [(c1DOn,
                       label: block_c1DOn_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DOn: // global
           if (R1 & 7 == 1) goto c1DOx; else goto u1E2q;
       c1DOx: // global
           I64[Sp] = block_c1DOu_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1E2U; else goto c1DOy;
       u1E2U: // global
           call _c1DOu(R1) args: 0, res: 0, upd: 0;
       c1DOy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1E2q: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
     }
 },
 _c1DOu() //  [R1]
         { info_tbl: [(c1DOu,
                       label: block_c1DOu_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DOu: // global
           if (R1 & 7 == 1) goto u1E2r; else goto c1DOJ;
       u1E2r: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1DOJ: // global
           I64[Sp] = block_c1DOH_info;
           _s1CXe::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 40] = _s1CXe::P64;
           if (R1 & 7 != 0) goto u1E2W; else goto c1DOK;
       u1E2W: // global
           call _c1DOH(R1) args: 0, res: 0, upd: 0;
       c1DOK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DOH() //  [R1]
         { info_tbl: [(c1DOH,
                       label: block_c1DOH_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DOH: // global
           if (R1 & 7 == 1) goto u1E2s; else goto c1DP0;
       u1E2s: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1DP0: // global
           I64[Sp] = block_c1DOT_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u1E2Y; else goto c1DOU;
       u1E2Y: // global
           call _c1DOT(R1) args: 0, res: 0, upd: 0;
       c1DOU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DOT() //  [R1]
         { info_tbl: [(c1DOT,
                       label: block_c1DOT_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DOT: // global
           I64[Sp] = block_c1DOY_info;
           _s1CXi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _s1CXi::I64;
           if (R1 & 7 != 0) goto u1E30; else goto c1DP2;
       u1E30: // global
           call _c1DOY(R1) args: 0, res: 0, upd: 0;
       c1DP2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DOY() //  [R1]
         { info_tbl: [(c1DOY,
                       label: block_c1DOY_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DOY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DP8; else goto c1DP7;
       c1DP8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DP7: // global
           if (%MO_S_Gt_W64(I64[R1 + 7],
                            I64[Sp + 40] + 1)) goto c1DPf; else goto c1DPj;
       c1DPf: // global
           Hp = Hp - 16;
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1DPj: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1CWU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWU: // global
           I64[Sp - 8] = block_c1DK6_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E4w; else goto c1DK7;
       u1E4w: // global
           call _c1DK6(R1) args: 0, res: 0, upd: 0;
       c1DK7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DK6() //  [R1]
         { info_tbl: [(c1DK6,
                       label: block_c1DK6_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DK6: // global
           if (R1 & 7 == 1) goto c1DNx; else goto c1DNC;
       c1DNx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DNA; else goto c1DNz;
       c1DNA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DNz: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1DNC: // global
           I64[Sp] = block_c1DKc_info;
           _s1CWX::P64 = P64[R1 + 6];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s1CWX::P64;
           if (R1 & 7 != 0) goto u1E2x; else goto c1DKd;
       u1E2x: // global
           call _c1DKc(R1) args: 0, res: 0, upd: 0;
       c1DKd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1DKc() //  [R1]
         { info_tbl: [(c1DKc,
                       label: block_c1DKc_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DKc: // global
           _c1DJo::P64 = P64[Sp + 24];
           _c1DJv::P64 = P64[Sp + 8];
           _s1CWy::P64 = P64[Sp + 56];
           _s1CWA::P64 = P64[Sp + 72];
           _s1CWX::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1DNF; else goto c1DNX;
       c1DNF: // global
           Hp = Hp + 40;
           _s1CWY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1DO0; else goto c1DNH;
       c1DNH: // global
           I64[Hp - 32] = sat_s1CX1_info;
           P64[Hp - 16] = _s1CWy::P64;
           P64[Hp - 8] = _c1DJo::P64;
           P64[Hp] = _s1CWX::P64;
           I64[Sp + 40] = block_c1DND_info;
           R2 = _c1DJv::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _s1CWA::P64;
           P64[Sp + 32] = Hp - 32;
           Sp = Sp + 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
       c1DNX: // global
           Hp = Hp + 40;
           _s1CWY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1DO0; else goto c1DNZ;
       c1DO0: // global
           HpAlloc = 40;
           R1 = _s1CWY::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DNZ: // global
           I64[Hp - 32] = sat_s1CX9_info;
           P64[Hp - 16] = _s1CWy::P64;
           P64[Hp - 8] = _c1DJo::P64;
           P64[Hp] = _s1CWX::P64;
           I64[Sp + 40] = block_c1DNW_info;
           R2 = _c1DJv::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _s1CWA::P64;
           P64[Sp + 32] = Hp - 32;
           Sp = Sp + 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1DND() //  [R1]
         { info_tbl: [(c1DND,
                       label: block_c1DND_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DND: // global
           if (R1 & 7 == 1) goto u1E2v; else goto c1DNS;
       u1E2v: // global
           Sp = Sp + 40;
           call _c1DVx() args: 0, res: 0, upd: 0;
       c1DNS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DNV; else goto c1DNU;
       c1DNV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DNU: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1DNW() //  [R1]
         { info_tbl: [(c1DNW,
                       label: block_c1DNW_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DNW: // global
           if (R1 & 7 == 1) goto u1E2u; else goto c1DOa;
       u1E2u: // global
           Sp = Sp + 40;
           call _c1DVx() args: 0, res: 0, upd: 0;
       c1DOa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1DOd; else goto c1DOc;
       c1DOd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1DOc: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1DVx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1DVx: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.410056677 UTC

[section ""cstring" . Data.Bits.$trModule4_bytes" {
     Data.Bits.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.410724563 UTC

[section ""data" . Data.Bits.$trModule3_closure" {
     Data.Bits.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.411657055 UTC

[section ""cstring" . Data.Bits.$trModule2_bytes" {
     Data.Bits.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.412179514 UTC

[section ""data" . Data.Bits.$trModule1_closure" {
     Data.Bits.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.412735826 UTC

[section ""data" . Data.Bits.$trModule_closure" {
     Data.Bits.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bits.$trModule3_closure+1;
         const Data.Bits.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.413374418 UTC

[section ""data" . $krep_r1CDE_closure" {
     $krep_r1CDE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.414000446 UTC

[section ""data" . $krep1_r1CDF_closure" {
     $krep1_r1CDF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.414613557 UTC

[section ""data" . $krep2_r1CDG_closure" {
     $krep2_r1CDG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.415191555 UTC

[section ""data" . $krep3_r1CDH_closure" {
     $krep3_r1CDH_closure:
         const :_con_info;
         const $krep1_r1CDF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.415813127 UTC

[section ""data" . $krep4_r1CDI_closure" {
     $krep4_r1CDI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep3_r1CDH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.416394842 UTC

[section ""data" . $krep5_r1CDJ_closure" {
     $krep5_r1CDJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1CDF_closure+1;
         const $krep_r1CDE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.416989189 UTC

[section ""data" . Data.Bits.$tcBits1_closure" {
     Data.Bits.$tcBits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep2_r1CDG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.417618562 UTC

[section ""data" . $krep6_r1CDK_closure" {
     $krep6_r1CDK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.41820991 UTC

[section ""data" . $krep7_r1CDL_closure" {
     $krep7_r1CDL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep6_r1CDK_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.418780092 UTC

[section ""data" . $krep8_r1CDM_closure" {
     $krep8_r1CDM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep7_r1CDL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.419399972 UTC

[section ""data" . $krep9_r1CDN_closure" {
     $krep9_r1CDN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep5_r1CDJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.419989372 UTC

[section ""data" . $krep10_r1CDO_closure" {
     $krep10_r1CDO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep4_r1CDI_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.420598372 UTC

[section ""data" . $krep11_r1CDP_closure" {
     $krep11_r1CDP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep1_r1CDF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.421679122 UTC

[section ""data" . $krep12_r1CDQ_closure" {
     $krep12_r1CDQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep_r1CDE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.422232111 UTC

[section ""data" . $krep13_r1CDR_closure" {
     $krep13_r1CDR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1CDF_closure+1;
         const $krep6_r1CDK_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.422800997 UTC

[section ""data" . $krep14_r1CDS_closure" {
     $krep14_r1CDS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep13_r1CDR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.42341611 UTC

[section ""data" . $krep15_r1CDT_closure" {
     $krep15_r1CDT_closure:
         const :_con_info;
         const $krep6_r1CDK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.423987895 UTC

[section ""data" . $krep16_r1CDU_closure" {
     $krep16_r1CDU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Classes.$tcEq_closure;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.424596149 UTC

[section ""cstring" . Data.Bits.$tcBits3_bytes" {
     Data.Bits.$tcBits3_bytes:
         I8[] [66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.425201729 UTC

[section ""data" . Data.Bits.$tcBits2_closure" {
     Data.Bits.$tcBits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tcBits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.425869168 UTC

[section ""data" . Data.Bits.$tcBits_closure" {
     Data.Bits.$tcBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tcBits2_closure+1;
         const Data.Bits.$tcBits1_closure+4;
         const 7088815172979416363;
         const 4990916430057605838;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.426491696 UTC

[section ""data" . $krep17_r1CDV_closure" {
     $krep17_r1CDV_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Bits.$tcBits_closure+1;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.427047159 UTC

[section ""data" . $krep18_r1CDW_closure" {
     $krep18_r1CDW_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep17_r1CDV_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.427666746 UTC

[section ""data" . $krep19_r1CDX_closure" {
     $krep19_r1CDX_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep18_r1CDW_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.428284967 UTC

[section ""data" . $krep20_r1CDY_closure" {
     $krep20_r1CDY_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep19_r1CDX_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.428885438 UTC

[section ""data" . $krep21_r1CDZ_closure" {
     $krep21_r1CDZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep20_r1CDY_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.429554489 UTC

[section ""data" . $krep22_r1CE0_closure" {
     $krep22_r1CE0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep21_r1CDZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.430197308 UTC

[section ""data" . $krep23_r1CE1_closure" {
     $krep23_r1CE1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep22_r1CE0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.431204618 UTC

[section ""data" . $krep24_r1CE2_closure" {
     $krep24_r1CE2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep23_r1CE1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.431786544 UTC

[section ""data" . $krep25_r1CE3_closure" {
     $krep25_r1CE3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r1CDQ_closure+4;
         const $krep24_r1CE2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.432321952 UTC

[section ""data" . $krep26_r1CE4_closure" {
     $krep26_r1CE4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep25_r1CE3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.432906983 UTC

[section ""data" . $krep27_r1CE5_closure" {
     $krep27_r1CE5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1CDO_closure+4;
         const $krep26_r1CE4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.433568957 UTC

[section ""data" . $krep28_r1CE6_closure" {
     $krep28_r1CE6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r1CDN_closure+4;
         const $krep27_r1CE5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.4341537 UTC

[section ""data" . $krep29_r1CE7_closure" {
     $krep29_r1CE7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep28_r1CE6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.434741481 UTC

[section ""data" . $krep30_r1CE8_closure" {
     $krep30_r1CE8_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep29_r1CE7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.435338328 UTC

[section ""data" . $krep31_r1CE9_closure" {
     $krep31_r1CE9_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep30_r1CE8_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.43595271 UTC

[section ""data" . $krep32_r1CEa_closure" {
     $krep32_r1CEa_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_r1CDR_closure+4;
         const $krep31_r1CE9_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.436505411 UTC

[section ""data" . $krep33_r1CEb_closure" {
     $krep33_r1CEb_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep32_r1CEa_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.437095393 UTC

[section ""data" . $krep34_r1CEc_closure" {
     $krep34_r1CEc_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep33_r1CEb_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.43774444 UTC

[section ""data" . $krep35_r1CEd_closure" {
     $krep35_r1CEd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep34_r1CEc_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.438300484 UTC

[section ""data" . $krep36_r1CEe_closure" {
     $krep36_r1CEe_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1CDL_closure+4;
         const $krep35_r1CEd_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.438912195 UTC

[section ""data" . $krep37_r1CEf_closure" {
     $krep37_r1CEf_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep36_r1CEe_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.439505462 UTC

[section ""data" . $krep38_r1CEg_closure" {
     $krep38_r1CEg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep37_r1CEf_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.440133685 UTC

[section ""data" . $krep39_r1CEh_closure" {
     $krep39_r1CEh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep38_r1CEg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.441126648 UTC

[section ""data" . Data.Bits.$tc'C:Bits1_closure" {
     Data.Bits.$tc'C:Bits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r1CDU_closure+1;
         const $krep39_r1CEh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.441829542 UTC

[section ""cstring" . Data.Bits.$tc'C:Bits3_bytes" {
     Data.Bits.$tc'C:Bits3_bytes:
         I8[] [39,67,58,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.442370973 UTC

[section ""data" . Data.Bits.$tc'C:Bits2_closure" {
     Data.Bits.$tc'C:Bits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tc'C:Bits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.4429789 UTC

[section ""data" . Data.Bits.$tc'C:Bits_closure" {
     Data.Bits.$tc'C:Bits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tc'C:Bits2_closure+1;
         const Data.Bits.$tc'C:Bits1_closure+4;
         const 744071653035646959;
         const 2574978498160477882;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.443566408 UTC

[section ""cstring" . Data.Bits.$tcFiniteBits2_bytes" {
     Data.Bits.$tcFiniteBits2_bytes:
         I8[] [70,105,110,105,116,101,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.444108701 UTC

[section ""data" . Data.Bits.$tcFiniteBits1_closure" {
     Data.Bits.$tcFiniteBits1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tcFiniteBits2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.444650925 UTC

[section ""data" . Data.Bits.$tcFiniteBits_closure" {
     Data.Bits.$tcFiniteBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tcFiniteBits1_closure+1;
         const Data.Bits.$tcBits1_closure+4;
         const 2363162769622202131;
         const 10110405838341883172;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.445333051 UTC

[section ""data" . $krep40_r1CEi_closure" {
     $krep40_r1CEi_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Bits.$tcFiniteBits_closure+1;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.44595113 UTC

[section ""data" . $krep41_r1CEj_closure" {
     $krep41_r1CEj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep40_r1CEi_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.446505035 UTC

[section ""data" . $krep42_r1CEk_closure" {
     $krep42_r1CEk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep41_r1CEj_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.447076386 UTC

[section ""data" . $krep43_r1CEl_closure" {
     $krep43_r1CEl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep42_r1CEk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.447686561 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits1_closure" {
     Data.Bits.$tc'C:FiniteBits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_r1CDV_closure+1;
         const $krep43_r1CEl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.448305546 UTC

[section ""cstring" . Data.Bits.$tc'C:FiniteBits3_bytes" {
     Data.Bits.$tc'C:FiniteBits3_bytes:
         I8[] [39,67,58,70,105,110,105,116,101,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.44888676 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits2_closure" {
     Data.Bits.$tc'C:FiniteBits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tc'C:FiniteBits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.449537206 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits_closure" {
     Data.Bits.$tc'C:FiniteBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tc'C:FiniteBits2_closure+1;
         const Data.Bits.$tc'C:FiniteBits1_closure+4;
         const 7500562306525175158;
         const 16051895206261500648;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.450921499 UTC

[section ""data" . Data.Bits.C:FiniteBits_closure" {
     Data.Bits.C:FiniteBits_closure:
         const Data.Bits.C:FiniteBits_info;
 },
 Data.Bits.C:FiniteBits_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1E4N,
                       label: Data.Bits.C:FiniteBits_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E4N: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1E4R; else goto c1E4Q;
       c1E4R: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.C:FiniteBits_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1E4Q: // global
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.452471048 UTC

[section ""data" . Data.Bits.C:Bits_closure" {
     Data.Bits.C:Bits_closure:
         const Data.Bits.C:Bits_info;
 },
 Data.Bits.C:Bits_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E4T: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Bits.C:Bits_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2,
                                       R1) args: 152, res: 0, upd: 8;
     }
 },
 Data.Bits.C:Bits_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1E4Y,
                       label: Data.Bits.C:Bits_info
                       rep:HeapRep static {
                             Fun {arity: 23
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E4Y: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c1E52; else goto c1E51;
       c1E52: // global
           HpAlloc = 192;
           R1 = Data.Bits.C:Bits_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 192, res: 0, upd: 8;
       c1E51: // global
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           P64[Hp - 152] = R5;
           P64[Hp - 144] = R6;
           P64[Hp - 136] = P64[Sp];
           P64[Hp - 128] = P64[Sp + 8];
           P64[Hp - 120] = P64[Sp + 16];
           P64[Hp - 112] = P64[Sp + 24];
           P64[Hp - 104] = P64[Sp + 32];
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 48];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 72];
           P64[Hp - 56] = P64[Sp + 80];
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = P64[Sp + 96];
           P64[Hp - 32] = P64[Sp + 104];
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = P64[Sp + 136];
           R1 = Hp - 183;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.453946023 UTC

[Data.Bits.C:FiniteBits_con_entry() //  [R1]
         { info_tbl: [(c1E53,
                       label: Data.Bits.C:FiniteBits_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,115,46,67,58,70,105,110,105,116,101,66,105,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E53: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.454692742 UTC

[Data.Bits.C:Bits_con_entry() //  [R1]
         { info_tbl: [(c1E54,
                       label: Data.Bits.C:Bits_con_info
                       rep:HeapRep 23 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,115,46,67,58,66,105,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E54: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.455321782 UTC

[section ""relreadonly" . S1D79_srt" {
     S1D79_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Bits.$fBitsInteger1_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const Data.Bits.$fBitsInteger_$cshift_closure;
         const Data.Bits.$w$cshift_closure;
         const sat_s1COy_closure;
         const Data.Bits.$fBitsInteger3_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure;
         const GHC.Integer.Type.complementInteger_closure;
         const Data.Bits.$fBitsInteger_$cclearBit_closure;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure;
         const Data.Bits.$fBitsInteger_$csetBit_closure;
         const Data.Bits.$fBitsInteger_$cshiftR_closure;
         const Data.Bits.$fBitsInteger_$crotateR_closure;
         const Data.Bits.bitDefault_closure;
         const Data.Bits.$fBitsInteger_$czeroBits_closure;
         const Data.Bits.testBitDefault_closure;
         const Data.Bits.$wpopCountDefault_closure;
         const Data.Bits.popCountDefault_closure;
         const GHC.Num.$fNumInteger_closure;
         const Data.Bits.$fBitsInteger_closure;
         const Data.Bits.$fBitsInteger_$cpopCount_closure;
         const Data.Bits.toIntegralSized_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.456040514 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:23.456819912 UTC

[section ""data" . Data.Bits.$p1FiniteBits_closure" {
     Data.Bits.$p1FiniteBits_closure:
         const Data.Bits.$p1FiniteBits_info;
 },
 Data.Bits.$p1FiniteBits_entry() //  [R2]
         { info_tbl: [(c1E5c,
                       label: Data.Bits.$p1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E5c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E5d; else goto c1E5e;
       c1E5d: // global
           R2 = R2;
           R1 = Data.Bits.$p1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E5e: // global
           I64[Sp - 8] = block_c1E59_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E5i; else goto c1E5a;
       u1E5i: // global
           call _c1E59(R1) args: 0, res: 0, upd: 0;
       c1E5a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E59() //  [R1]
         { info_tbl: [(c1E59,
                       label: block_c1E59_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E59: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.45808628 UTC

[section ""data" . Data.Bits.finiteBitSize_closure" {
     Data.Bits.finiteBitSize_closure:
         const Data.Bits.finiteBitSize_info;
 },
 Data.Bits.finiteBitSize_entry() //  [R2]
         { info_tbl: [(c1E5q,
                       label: Data.Bits.finiteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E5q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E5r; else goto c1E5s;
       c1E5r: // global
           R2 = R2;
           R1 = Data.Bits.finiteBitSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E5s: // global
           I64[Sp - 8] = block_c1E5n_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E5w; else goto c1E5o;
       u1E5w: // global
           call _c1E5n(R1) args: 0, res: 0, upd: 0;
       c1E5o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E5n() //  [R1]
         { info_tbl: [(c1E5n,
                       label: block_c1E5n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E5n: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.459248697 UTC

[section ""data" . Data.Bits.countLeadingZeros_closure" {
     Data.Bits.countLeadingZeros_closure:
         const Data.Bits.countLeadingZeros_info;
 },
 Data.Bits.countLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1E5E,
                       label: Data.Bits.countLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E5E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E5F; else goto c1E5G;
       c1E5F: // global
           R2 = R2;
           R1 = Data.Bits.countLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E5G: // global
           I64[Sp - 8] = block_c1E5B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E5K; else goto c1E5C;
       u1E5K: // global
           call _c1E5B(R1) args: 0, res: 0, upd: 0;
       c1E5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E5B() //  [R1]
         { info_tbl: [(c1E5B,
                       label: block_c1E5B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E5B: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.460458011 UTC

[section ""data" . Data.Bits.countTrailingZeros_closure" {
     Data.Bits.countTrailingZeros_closure:
         const Data.Bits.countTrailingZeros_info;
 },
 Data.Bits.countTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1E5S,
                       label: Data.Bits.countTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E5S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E5T; else goto c1E5U;
       c1E5T: // global
           R2 = R2;
           R1 = Data.Bits.countTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E5U: // global
           I64[Sp - 8] = block_c1E5P_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E5Y; else goto c1E5Q;
       u1E5Y: // global
           call _c1E5P(R1) args: 0, res: 0, upd: 0;
       c1E5Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E5P() //  [R1]
         { info_tbl: [(c1E5P,
                       label: block_c1E5P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E5P: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.462793483 UTC

[section ""data" . Data.Bits.$p1Bits_closure" {
     Data.Bits.$p1Bits_closure:
         const Data.Bits.$p1Bits_info;
 },
 Data.Bits.$p1Bits_entry() //  [R2]
         { info_tbl: [(c1E66,
                       label: Data.Bits.$p1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E66: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E67; else goto c1E68;
       c1E67: // global
           R2 = R2;
           R1 = Data.Bits.$p1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E68: // global
           I64[Sp - 8] = block_c1E63_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E6c; else goto c1E64;
       u1E6c: // global
           call _c1E63(R1) args: 0, res: 0, upd: 0;
       c1E64: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E63() //  [R1]
         { info_tbl: [(c1E63,
                       label: block_c1E63_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E63: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.46398275 UTC

[section ""data" . Data.Bits..&._closure" {
     Data.Bits..&._closure:
         const Data.Bits..&._info;
 },
 Data.Bits..&._entry() //  [R2]
         { info_tbl: [(c1E6k,
                       label: Data.Bits..&._info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E6k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E6l; else goto c1E6m;
       c1E6l: // global
           R2 = R2;
           R1 = Data.Bits..&._closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E6m: // global
           I64[Sp - 8] = block_c1E6h_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E6q; else goto c1E6i;
       u1E6q: // global
           call _c1E6h(R1) args: 0, res: 0, upd: 0;
       c1E6i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E6h() //  [R1]
         { info_tbl: [(c1E6h,
                       label: block_c1E6h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E6h: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.465103228 UTC

[section ""data" . Data.Bits..|._closure" {
     Data.Bits..|._closure:
         const Data.Bits..|._info;
 },
 Data.Bits..|._entry() //  [R2]
         { info_tbl: [(c1E6y,
                       label: Data.Bits..|._info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E6y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E6z; else goto c1E6A;
       c1E6z: // global
           R2 = R2;
           R1 = Data.Bits..|._closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E6A: // global
           I64[Sp - 8] = block_c1E6v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E6E; else goto c1E6w;
       u1E6E: // global
           call _c1E6v(R1) args: 0, res: 0, upd: 0;
       c1E6w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E6v() //  [R1]
         { info_tbl: [(c1E6v,
                       label: block_c1E6v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E6v: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.46640726 UTC

[section ""data" . Data.Bits.xor_closure" {
     Data.Bits.xor_closure:
         const Data.Bits.xor_info;
 },
 Data.Bits.xor_entry() //  [R2]
         { info_tbl: [(c1E6M,
                       label: Data.Bits.xor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E6M: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E6N; else goto c1E6O;
       c1E6N: // global
           R2 = R2;
           R1 = Data.Bits.xor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E6O: // global
           I64[Sp - 8] = block_c1E6J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E6S; else goto c1E6K;
       u1E6S: // global
           call _c1E6J(R1) args: 0, res: 0, upd: 0;
       c1E6K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E6J() //  [R1]
         { info_tbl: [(c1E6J,
                       label: block_c1E6J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E6J: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.467528703 UTC

[section ""data" . Data.Bits.complement_closure" {
     Data.Bits.complement_closure:
         const Data.Bits.complement_info;
 },
 Data.Bits.complement_entry() //  [R2]
         { info_tbl: [(c1E70,
                       label: Data.Bits.complement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E70: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E71; else goto c1E72;
       c1E71: // global
           R2 = R2;
           R1 = Data.Bits.complement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E72: // global
           I64[Sp - 8] = block_c1E6X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E76; else goto c1E6Y;
       u1E76: // global
           call _c1E6X(R1) args: 0, res: 0, upd: 0;
       c1E6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E6X() //  [R1]
         { info_tbl: [(c1E6X,
                       label: block_c1E6X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E6X: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.468728808 UTC

[section ""data" . Data.Bits.shift_closure" {
     Data.Bits.shift_closure:
         const Data.Bits.shift_info;
 },
 Data.Bits.shift_entry() //  [R2]
         { info_tbl: [(c1E7e,
                       label: Data.Bits.shift_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E7e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E7f; else goto c1E7g;
       c1E7f: // global
           R2 = R2;
           R1 = Data.Bits.shift_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E7g: // global
           I64[Sp - 8] = block_c1E7b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E7k; else goto c1E7c;
       u1E7k: // global
           call _c1E7b(R1) args: 0, res: 0, upd: 0;
       c1E7c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E7b() //  [R1]
         { info_tbl: [(c1E7b,
                       label: block_c1E7b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E7b: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.469926363 UTC

[section ""data" . Data.Bits.rotate_closure" {
     Data.Bits.rotate_closure:
         const Data.Bits.rotate_info;
 },
 Data.Bits.rotate_entry() //  [R2]
         { info_tbl: [(c1E7s,
                       label: Data.Bits.rotate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E7s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E7t; else goto c1E7u;
       c1E7t: // global
           R2 = R2;
           R1 = Data.Bits.rotate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E7u: // global
           I64[Sp - 8] = block_c1E7p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E7y; else goto c1E7q;
       u1E7y: // global
           call _c1E7p(R1) args: 0, res: 0, upd: 0;
       c1E7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E7p() //  [R1]
         { info_tbl: [(c1E7p,
                       label: block_c1E7p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E7p: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.471136713 UTC

[section ""data" . Data.Bits.zeroBits_closure" {
     Data.Bits.zeroBits_closure:
         const Data.Bits.zeroBits_info;
 },
 Data.Bits.zeroBits_entry() //  [R2]
         { info_tbl: [(c1E7G,
                       label: Data.Bits.zeroBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E7G: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E7H; else goto c1E7I;
       c1E7H: // global
           R2 = R2;
           R1 = Data.Bits.zeroBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E7I: // global
           I64[Sp - 8] = block_c1E7D_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E7M; else goto c1E7E;
       u1E7M: // global
           call _c1E7D(R1) args: 0, res: 0, upd: 0;
       c1E7E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E7D() //  [R1]
         { info_tbl: [(c1E7D,
                       label: block_c1E7D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E7D: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.472315519 UTC

[section ""data" . Data.Bits.bit_closure" {
     Data.Bits.bit_closure:
         const Data.Bits.bit_info;
 },
 Data.Bits.bit_entry() //  [R2]
         { info_tbl: [(c1E7U,
                       label: Data.Bits.bit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E7U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E7V; else goto c1E7W;
       c1E7V: // global
           R2 = R2;
           R1 = Data.Bits.bit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E7W: // global
           I64[Sp - 8] = block_c1E7R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E80; else goto c1E7S;
       u1E80: // global
           call _c1E7R(R1) args: 0, res: 0, upd: 0;
       c1E7S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E7R() //  [R1]
         { info_tbl: [(c1E7R,
                       label: block_c1E7R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E7R: // global
           R1 = P64[R1 + 71];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.473701258 UTC

[section ""data" . Data.Bits.setBit_closure" {
     Data.Bits.setBit_closure:
         const Data.Bits.setBit_info;
 },
 Data.Bits.setBit_entry() //  [R2]
         { info_tbl: [(c1E88,
                       label: Data.Bits.setBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E88: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E89; else goto c1E8a;
       c1E89: // global
           R2 = R2;
           R1 = Data.Bits.setBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E8a: // global
           I64[Sp - 8] = block_c1E85_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E8e; else goto c1E86;
       u1E8e: // global
           call _c1E85(R1) args: 0, res: 0, upd: 0;
       c1E86: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E85() //  [R1]
         { info_tbl: [(c1E85,
                       label: block_c1E85_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E85: // global
           R1 = P64[R1 + 79];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.475436241 UTC

[section ""data" . Data.Bits.clearBit_closure" {
     Data.Bits.clearBit_closure:
         const Data.Bits.clearBit_info;
 },
 Data.Bits.clearBit_entry() //  [R2]
         { info_tbl: [(c1E8m,
                       label: Data.Bits.clearBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E8m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E8n; else goto c1E8o;
       c1E8n: // global
           R2 = R2;
           R1 = Data.Bits.clearBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E8o: // global
           I64[Sp - 8] = block_c1E8j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E8s; else goto c1E8k;
       u1E8s: // global
           call _c1E8j(R1) args: 0, res: 0, upd: 0;
       c1E8k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E8j() //  [R1]
         { info_tbl: [(c1E8j,
                       label: block_c1E8j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E8j: // global
           R1 = P64[R1 + 87];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.476575475 UTC

[section ""data" . Data.Bits.complementBit_closure" {
     Data.Bits.complementBit_closure:
         const Data.Bits.complementBit_info;
 },
 Data.Bits.complementBit_entry() //  [R2]
         { info_tbl: [(c1E8A,
                       label: Data.Bits.complementBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E8A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E8B; else goto c1E8C;
       c1E8B: // global
           R2 = R2;
           R1 = Data.Bits.complementBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E8C: // global
           I64[Sp - 8] = block_c1E8x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E8G; else goto c1E8y;
       u1E8G: // global
           call _c1E8x(R1) args: 0, res: 0, upd: 0;
       c1E8y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E8x() //  [R1]
         { info_tbl: [(c1E8x,
                       label: block_c1E8x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E8x: // global
           R1 = P64[R1 + 95];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.477767015 UTC

[section ""data" . Data.Bits.testBit_closure" {
     Data.Bits.testBit_closure:
         const Data.Bits.testBit_info;
 },
 Data.Bits.testBit_entry() //  [R2]
         { info_tbl: [(c1E8O,
                       label: Data.Bits.testBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E8O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E8P; else goto c1E8Q;
       c1E8P: // global
           R2 = R2;
           R1 = Data.Bits.testBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E8Q: // global
           I64[Sp - 8] = block_c1E8L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E8U; else goto c1E8M;
       u1E8U: // global
           call _c1E8L(R1) args: 0, res: 0, upd: 0;
       c1E8M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E8L() //  [R1]
         { info_tbl: [(c1E8L,
                       label: block_c1E8L_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E8L: // global
           R1 = P64[R1 + 103];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.478929826 UTC

[section ""data" . Data.Bits.bitSizeMaybe_closure" {
     Data.Bits.bitSizeMaybe_closure:
         const Data.Bits.bitSizeMaybe_info;
 },
 Data.Bits.bitSizeMaybe_entry() //  [R2]
         { info_tbl: [(c1E92,
                       label: Data.Bits.bitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E92: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E93; else goto c1E94;
       c1E93: // global
           R2 = R2;
           R1 = Data.Bits.bitSizeMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E94: // global
           I64[Sp - 8] = block_c1E8Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E98; else goto c1E90;
       u1E98: // global
           call _c1E8Z(R1) args: 0, res: 0, upd: 0;
       c1E90: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E8Z() //  [R1]
         { info_tbl: [(c1E8Z,
                       label: block_c1E8Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E8Z: // global
           R1 = P64[R1 + 111];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.480105333 UTC

[section ""data" . Data.Bits.bitSize_closure" {
     Data.Bits.bitSize_closure:
         const Data.Bits.bitSize_info;
 },
 Data.Bits.bitSize_entry() //  [R2]
         { info_tbl: [(c1E9g,
                       label: Data.Bits.bitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E9g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E9h; else goto c1E9i;
       c1E9h: // global
           R2 = R2;
           R1 = Data.Bits.bitSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E9i: // global
           I64[Sp - 8] = block_c1E9d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E9m; else goto c1E9e;
       u1E9m: // global
           call _c1E9d(R1) args: 0, res: 0, upd: 0;
       c1E9e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E9d() //  [R1]
         { info_tbl: [(c1E9d,
                       label: block_c1E9d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E9d: // global
           R1 = P64[R1 + 119];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.481210763 UTC

[section ""data" . Data.Bits.isSigned_closure" {
     Data.Bits.isSigned_closure:
         const Data.Bits.isSigned_info;
 },
 Data.Bits.isSigned_entry() //  [R2]
         { info_tbl: [(c1E9u,
                       label: Data.Bits.isSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E9u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E9v; else goto c1E9w;
       c1E9v: // global
           R2 = R2;
           R1 = Data.Bits.isSigned_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E9w: // global
           I64[Sp - 8] = block_c1E9r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E9A; else goto c1E9s;
       u1E9A: // global
           call _c1E9r(R1) args: 0, res: 0, upd: 0;
       c1E9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E9r() //  [R1]
         { info_tbl: [(c1E9r,
                       label: block_c1E9r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E9r: // global
           R1 = P64[R1 + 127];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.482467576 UTC

[section ""data" . Data.Bits.shiftL_closure" {
     Data.Bits.shiftL_closure:
         const Data.Bits.shiftL_info;
 },
 Data.Bits.shiftL_entry() //  [R2]
         { info_tbl: [(c1E9I,
                       label: Data.Bits.shiftL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E9I: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E9J; else goto c1E9K;
       c1E9J: // global
           R2 = R2;
           R1 = Data.Bits.shiftL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E9K: // global
           I64[Sp - 8] = block_c1E9F_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1E9O; else goto c1E9G;
       u1E9O: // global
           call _c1E9F(R1) args: 0, res: 0, upd: 0;
       c1E9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E9F() //  [R1]
         { info_tbl: [(c1E9F,
                       label: block_c1E9F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E9F: // global
           R1 = P64[R1 + 135];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.483615739 UTC

[section ""data" . Data.Bits.unsafeShiftL_closure" {
     Data.Bits.unsafeShiftL_closure:
         const Data.Bits.unsafeShiftL_info;
 },
 Data.Bits.unsafeShiftL_entry() //  [R2]
         { info_tbl: [(c1E9W,
                       label: Data.Bits.unsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E9W: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1E9X; else goto c1E9Y;
       c1E9X: // global
           R2 = R2;
           R1 = Data.Bits.unsafeShiftL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1E9Y: // global
           I64[Sp - 8] = block_c1E9T_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Ea2; else goto c1E9U;
       u1Ea2: // global
           call _c1E9T(R1) args: 0, res: 0, upd: 0;
       c1E9U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1E9T() //  [R1]
         { info_tbl: [(c1E9T,
                       label: block_c1E9T_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1E9T: // global
           R1 = P64[R1 + 143];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.484783128 UTC

[section ""data" . Data.Bits.shiftR_closure" {
     Data.Bits.shiftR_closure:
         const Data.Bits.shiftR_info;
 },
 Data.Bits.shiftR_entry() //  [R2]
         { info_tbl: [(c1Eaa,
                       label: Data.Bits.shiftR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eaa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Eab; else goto c1Eac;
       c1Eab: // global
           R2 = R2;
           R1 = Data.Bits.shiftR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Eac: // global
           I64[Sp - 8] = block_c1Ea7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Eag; else goto c1Ea8;
       u1Eag: // global
           call _c1Ea7(R1) args: 0, res: 0, upd: 0;
       c1Ea8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ea7() //  [R1]
         { info_tbl: [(c1Ea7,
                       label: block_c1Ea7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ea7: // global
           R1 = P64[R1 + 151];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.486649191 UTC

[section ""data" . Data.Bits.unsafeShiftR_closure" {
     Data.Bits.unsafeShiftR_closure:
         const Data.Bits.unsafeShiftR_info;
 },
 Data.Bits.unsafeShiftR_entry() //  [R2]
         { info_tbl: [(c1Eao,
                       label: Data.Bits.unsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eao: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Eap; else goto c1Eaq;
       c1Eap: // global
           R2 = R2;
           R1 = Data.Bits.unsafeShiftR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Eaq: // global
           I64[Sp - 8] = block_c1Eal_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Eau; else goto c1Eam;
       u1Eau: // global
           call _c1Eal(R1) args: 0, res: 0, upd: 0;
       c1Eam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eal() //  [R1]
         { info_tbl: [(c1Eal,
                       label: block_c1Eal_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eal: // global
           R1 = P64[R1 + 159];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.487781893 UTC

[section ""data" . Data.Bits.rotateL_closure" {
     Data.Bits.rotateL_closure:
         const Data.Bits.rotateL_info;
 },
 Data.Bits.rotateL_entry() //  [R2]
         { info_tbl: [(c1EaC,
                       label: Data.Bits.rotateL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EaC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1EaD; else goto c1EaE;
       c1EaD: // global
           R2 = R2;
           R1 = Data.Bits.rotateL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EaE: // global
           I64[Sp - 8] = block_c1Eaz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EaI; else goto c1EaA;
       u1EaI: // global
           call _c1Eaz(R1) args: 0, res: 0, upd: 0;
       c1EaA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eaz() //  [R1]
         { info_tbl: [(c1Eaz,
                       label: block_c1Eaz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eaz: // global
           R1 = P64[R1 + 167];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.48890086 UTC

[section ""data" . Data.Bits.rotateR_closure" {
     Data.Bits.rotateR_closure:
         const Data.Bits.rotateR_info;
 },
 Data.Bits.rotateR_entry() //  [R2]
         { info_tbl: [(c1EaQ,
                       label: Data.Bits.rotateR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EaQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1EaR; else goto c1EaS;
       c1EaR: // global
           R2 = R2;
           R1 = Data.Bits.rotateR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EaS: // global
           I64[Sp - 8] = block_c1EaN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EaW; else goto c1EaO;
       u1EaW: // global
           call _c1EaN(R1) args: 0, res: 0, upd: 0;
       c1EaO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EaN() //  [R1]
         { info_tbl: [(c1EaN,
                       label: block_c1EaN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EaN: // global
           R1 = P64[R1 + 175];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.490087398 UTC

[section ""data" . Data.Bits.popCount_closure" {
     Data.Bits.popCount_closure:
         const Data.Bits.popCount_info;
 },
 Data.Bits.popCount_entry() //  [R2]
         { info_tbl: [(c1Eb4,
                       label: Data.Bits.popCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eb4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Eb5; else goto c1Eb6;
       c1Eb5: // global
           R2 = R2;
           R1 = Data.Bits.popCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Eb6: // global
           I64[Sp - 8] = block_c1Eb1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Eba; else goto c1Eb2;
       u1Eba: // global
           call _c1Eb1(R1) args: 0, res: 0, upd: 0;
       c1Eb2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eb1() //  [R1]
         { info_tbl: [(c1Eb1,
                       label: block_c1Eb1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eb1: // global
           R1 = P64[R1 + 183];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.49107409 UTC

[section ""data" . Data.Bits.$fBitsBool2_closure" {
     Data.Bits.$fBitsBool2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.49161953 UTC

[section ""data" . Data.Bits.$fBitsBool1_closure" {
     Data.Bits.$fBitsBool1_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.492442989 UTC

[section ""data" . Data.Bits.$fBitsBool_$cpopCount_closure" {
     Data.Bits.$fBitsBool_$cpopCount_closure:
         const Data.Bits.$fBitsBool_$cpopCount_info;
 },
 Data.Bits.$fBitsBool_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1Ebm,
                       label: Data.Bits.$fBitsBool_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ebm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Ebn; else goto c1Ebo;
       c1Ebn: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Ebo: // global
           I64[Sp - 8] = block_c1Ebf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Ebv; else goto c1Ebg;
       u1Ebv: // global
           call _c1Ebf(R1) args: 0, res: 0, upd: 0;
       c1Ebg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ebf() //  [R1]
         { info_tbl: [(c1Ebf,
                       label: block_c1Ebf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ebf: // global
           if (R1 & 7 == 1) goto c1Ebj; else goto c1Ebk;
       c1Ebj: // global
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Ebk: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.494390798 UTC

[section ""data" . Data.Bits.$fBitsBool_$cisSigned_closure" {
     Data.Bits.$fBitsBool_$cisSigned_closure:
         const Data.Bits.$fBitsBool_$cisSigned_info;
 },
 Data.Bits.$fBitsBool_$cisSigned_entry() //  []
         { info_tbl: [(c1EbA,
                       label: Data.Bits.$fBitsBool_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EbA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.495221454 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbitSize_closure" {
     Data.Bits.$fBitsBool_$cbitSize_closure:
         const Data.Bits.$fBitsBool_$cbitSize_info;
 },
 Data.Bits.$fBitsBool_$cbitSize_entry() //  []
         { info_tbl: [(c1EbH,
                       label: Data.Bits.$fBitsBool_$cbitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EbH: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.495978023 UTC

[section ""data" . Data.Bits.$fBitsBool3_closure" {
     Data.Bits.$fBitsBool3_closure:
         const GHC.Base.Just_con_info;
         const Data.Bits.$fBitsBool1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.496688355 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsBool_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsBool_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsBool_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1EbO,
                       label: Data.Bits.$fBitsBool_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EbO: // global
           R1 = Data.Bits.$fBitsBool3_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.497799737 UTC

[section ""data" . Data.Bits.$fBitsBool_$ctestBit_closure" {
     Data.Bits.$fBitsBool_$ctestBit_closure:
         const Data.Bits.$fBitsBool_$ctestBit_info;
 },
 Data.Bits.$fBitsBool_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1EbY,
                       label: Data.Bits.$fBitsBool_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EbY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EbZ; else goto c1Ec0;
       c1EbZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ec0: // global
           I64[Sp - 16] = block_c1EbV_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Ec8; else goto c1EbW;
       u1Ec8: // global
           call _c1EbV(R1) args: 0, res: 0, upd: 0;
       c1EbW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EbV() //  [R1]
         { info_tbl: [(c1EbV,
                       label: block_c1EbV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EbV: // global
           if (I64[R1 + 7] == 0) goto c1Ec7; else goto c1Ec6;
       c1Ec7: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1Ec6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.499695753 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbit_closure" {
     Data.Bits.$fBitsBool_$cbit_closure:
         const Data.Bits.$fBitsBool_$cbit_info;
 },
 Data.Bits.$fBitsBool_$cbit_entry() //  [R2]
         { info_tbl: [(c1Ecg,
                       label: Data.Bits.$fBitsBool_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ecg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Ech; else goto c1Eci;
       c1Ech: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Eci: // global
           I64[Sp - 8] = block_c1Ecd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Ecq; else goto c1Ece;
       u1Ecq: // global
           call _c1Ecd(R1) args: 0, res: 0, upd: 0;
       c1Ece: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ecd() //  [R1]
         { info_tbl: [(c1Ecd,
                       label: block_c1Ecd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ecd: // global
           if (I64[R1 + 7] == 0) goto c1Ecp; else goto c1Eco;
       c1Ecp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Eco: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.500822595 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotate_closure" {
     Data.Bits.$fBitsBool_$crotate_closure:
         const Data.Bits.$fBitsBool_$crotate_info;
 },
 Data.Bits.$fBitsBool_$crotate_entry() //  [R2]
         { info_tbl: [(c1Ecv,
                       label: Data.Bits.$fBitsBool_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ecv: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.501811911 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cisSigned_closure" {
     Data.Bits.$fBitsInteger_$cisSigned_closure:
         const Data.Bits.$fBitsInteger_$cisSigned_info;
 },
 Data.Bits.$fBitsInteger_$cisSigned_entry() //  []
         { info_tbl: [(c1EcC,
                       label: Data.Bits.$fBitsInteger_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EcC: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.502497929 UTC

[section ""cstring" . Data.Bits.$fBitsInteger2_bytes" {
     Data.Bits.$fBitsInteger2_bytes:
         I8[] [68,97,116,97,46,66,105,116,115,46,98,105,116,83,105,122,101,40,73,110,116,101,103,101,114,41]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.503279364 UTC

[section ""data" . Data.Bits.$fBitsInteger1_closure" {
     Data.Bits.$fBitsInteger1_closure:
         const Data.Bits.$fBitsInteger1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger1_entry() //  [R1]
         { info_tbl: [(c1EcL,
                       label: Data.Bits.$fBitsInteger1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EcL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EcM; else goto c1EcN;
       c1EcM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EcN: // global
           (_c1EcI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1EcI::I64 == 0) goto c1EcK; else goto c1EcJ;
       c1EcK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1EcJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1EcI::I64;
           R2 = Data.Bits.$fBitsInteger2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.504283391 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbitSize_closure" {
     Data.Bits.$fBitsInteger_$cbitSize_closure:
         const Data.Bits.$fBitsInteger_$cbitSize_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cbitSize_entry() //  []
         { info_tbl: [(c1EcS,
                       label: Data.Bits.$fBitsInteger_$cbitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EcS: // global
           R2 = Data.Bits.$fBitsInteger1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.505099251 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsInteger_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsInteger_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1EcZ,
                       label: Data.Bits.$fBitsInteger_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EcZ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.506100226 UTC

[section ""data" . Data.Bits.$fBitsInteger_$ctestBit_closure" {
     Data.Bits.$fBitsInteger_$ctestBit_closure:
         const Data.Bits.$fBitsInteger_$ctestBit_info;
 },
 Data.Bits.$fBitsInteger_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1Ed9,
                       label: Data.Bits.$fBitsInteger_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ed9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Eda; else goto c1Edb;
       c1Eda: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Edb: // global
           I64[Sp - 16] = block_c1Ed6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Edf; else goto c1Ed7;
       u1Edf: // global
           call _c1Ed6(R1) args: 0, res: 0, upd: 0;
       c1Ed7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ed6() //  [R1]
         { info_tbl: [(c1Ed6,
                       label: block_c1Ed6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ed6: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.testBitInteger_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.507346054 UTC

[section ""data" . Data.Bits.$fBitsInteger_$czeroBits_closure" {
     Data.Bits.$fBitsInteger_$czeroBits_closure:
         const Data.Bits.$fBitsInteger_$czeroBits_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger_$czeroBits_entry() //  [R1]
         { info_tbl: [(c1Edm,
                       label: Data.Bits.$fBitsInteger_$czeroBits_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Edm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Edn; else goto c1Edo;
       c1Edn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Edo: // global
           (_c1Edj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1Edj::I64 == 0) goto c1Edl; else goto c1Edk;
       c1Edl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1Edk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1Edj::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.508477987 UTC

[section ""data" . Data.Bits.$w$cshift_closure" {
     Data.Bits.$w$cshift_closure:
         const Data.Bits.$w$cshift_info;
         const 0;
 },
 Data.Bits.$w$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1Edy,
                       label: Data.Bits.$w$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Edy: // global
           if (%MO_S_Lt_W64(R3, 0)) goto c1Edw; else goto c1Edx;
       c1Edw: // global
           R3 = -R3;
           R2 = R2;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1Edx: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.509925092 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshift_closure" {
     Data.Bits.$fBitsInteger_$cshift_closure:
         const Data.Bits.$fBitsInteger_$cshift_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1EdK,
                       label: Data.Bits.$fBitsInteger_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EdK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EdL; else goto c1EdM;
       c1EdL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EdM: // global
           I64[Sp - 16] = block_c1EdH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EdQ; else goto c1EdI;
       u1EdQ: // global
           call _c1EdH(R1) args: 0, res: 0, upd: 0;
       c1EdI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EdH() //  [R1]
         { info_tbl: [(c1EdH,
                       label: block_c1EdH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EdH: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Bits.$w$cshift_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.511549869 UTC

[section ""data" . sat_s1COx_closure" {
     sat_s1COx_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.512168532 UTC

[section ""data" . sat_s1COy_closure" {
     sat_s1COy_closure:
         const :_con_info;
         const sat_s1COx_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.512937944 UTC

[section ""data" . Data.Bits.$fBitsInteger3_closure" {
     Data.Bits.$fBitsInteger3_closure:
         const Data.Bits.$fBitsInteger3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger3_entry() //  [R1]
         { info_tbl: [(c1EdX,
                       label: Data.Bits.$fBitsInteger3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EdX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EdY; else goto c1EdZ;
       c1EdY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EdZ: // global
           (_c1EdU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1EdU::I64 == 0) goto c1EdW; else goto c1EdV;
       c1EdW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1EdV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1EdU::I64;
           R3 = sat_s1COy_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.514209577 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbit_closure" {
     Data.Bits.$fBitsInteger_$cbit_closure:
         const Data.Bits.$fBitsInteger_$cbit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cbit_entry() //  [R2]
         { info_tbl: [(c1Ee7,
                       label: Data.Bits.$fBitsInteger_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ee7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Ee8; else goto c1Ee9;
       c1Ee8: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Ee9: // global
           I64[Sp - 8] = block_c1Ee4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Eek; else goto c1Ee5;
       u1Eek: // global
           call _c1Ee4(R1) args: 0, res: 0, upd: 0;
       c1Ee5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ee4() //  [R1]
         { info_tbl: [(c1Ee4,
                       label: block_c1Ee4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ee4: // global
           _s1COB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COB::I64, 0)) goto c1Eeg; else goto c1Eeh;
       c1Eeg: // global
           R3 = -_s1COB::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1Eeh: // global
           R3 = _s1COB::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.515748358 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cclearBit_closure" {
     Data.Bits.$fBitsInteger_$cclearBit_closure:
         const Data.Bits.$fBitsInteger_$cclearBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1Ees,
                       label: Data.Bits.$fBitsInteger_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ees: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Eet; else goto c1Eeu;
       c1Eet: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Eeu: // global
           I64[Sp - 16] = block_c1Eep_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Ef2; else goto c1Eeq;
       u1Ef2: // global
           call _c1Eep(R1) args: 0, res: 0, upd: 0;
       c1Eeq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eep() //  [R1]
         { info_tbl: [(c1Eep,
                       label: block_c1Eep_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eep: // global
           _s1COH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COH::I64, 0)) goto c1EeK; else goto c1EeW;
       c1EeK: // global
           I64[Sp] = block_c1EeE_info;
           R3 = -_s1COH::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1EeW: // global
           I64[Sp] = block_c1EeR_info;
           R3 = _s1COH::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1EeE() //  [R1]
         { info_tbl: [(c1EeE,
                       label: block_c1EeE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EeE: // global
           I64[Sp] = block_c1EeI_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1EeI() //  [R1]
         { info_tbl: [(c1EeI,
                       label: block_c1EeI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EeI: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1EeR() //  [R1]
         { info_tbl: [(c1EeR,
                       label: block_c1EeR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EeR: // global
           I64[Sp] = block_c1EeV_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1EeV() //  [R1]
         { info_tbl: [(c1EeV,
                       label: block_c1EeV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EeV: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.517780305 UTC

[section ""data" . Data.Bits.$fBitsInteger_$ccomplementBit_closure" {
     Data.Bits.$fBitsInteger_$ccomplementBit_closure:
         const Data.Bits.$fBitsInteger_$ccomplementBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1Efa,
                       label: Data.Bits.$fBitsInteger_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Efa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Efb; else goto c1Efc;
       c1Efb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Efc: // global
           I64[Sp - 16] = block_c1Ef7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EfA; else goto c1Ef8;
       u1EfA: // global
           call _c1Ef7(R1) args: 0, res: 0, upd: 0;
       c1Ef8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ef7() //  [R1]
         { info_tbl: [(c1Ef7,
                       label: block_c1Ef7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ef7: // global
           _s1COR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COR::I64, 0)) goto c1Efo; else goto c1Efv;
       c1Efo: // global
           I64[Sp] = block_c1Efm_info;
           R3 = -_s1COR::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1Efv: // global
           I64[Sp] = block_c1Efu_info;
           R3 = _s1COR::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Efm() //  [R1]
         { info_tbl: [(c1Efm,
                       label: block_c1Efm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Efm: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1Efu() //  [R1]
         { info_tbl: [(c1Efu,
                       label: block_c1Efu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Efu: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.519577964 UTC

[section ""data" . Data.Bits.$fBitsInteger_$csetBit_closure" {
     Data.Bits.$fBitsInteger_$csetBit_closure:
         const Data.Bits.$fBitsInteger_$csetBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1EfI,
                       label: Data.Bits.$fBitsInteger_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EfI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EfJ; else goto c1EfK;
       c1EfJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EfK: // global
           I64[Sp - 16] = block_c1EfF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Eg8; else goto c1EfG;
       u1Eg8: // global
           call _c1EfF(R1) args: 0, res: 0, upd: 0;
       c1EfG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EfF() //  [R1]
         { info_tbl: [(c1EfF,
                       label: block_c1EfF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EfF: // global
           _s1COZ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COZ::I64, 0)) goto c1EfW; else goto c1Eg3;
       c1EfW: // global
           I64[Sp] = block_c1EfU_info;
           R3 = -_s1COZ::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1Eg3: // global
           I64[Sp] = block_c1Eg2_info;
           R3 = _s1COZ::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1EfU() //  [R1]
         { info_tbl: [(c1EfU,
                       label: block_c1EfU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EfU: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1Eg2() //  [R1]
         { info_tbl: [(c1Eg2,
                       label: block_c1Eg2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eg2: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.521097117 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsInteger_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsInteger_$cunsafeShiftL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Egd,
                       label: Data.Bits.$fBitsInteger_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Egd: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.52203719 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshiftL_closure" {
     Data.Bits.$fBitsInteger_$cshiftL_closure:
         const Data.Bits.$fBitsInteger_$cshiftL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Egk,
                       label: Data.Bits.$fBitsInteger_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Egk: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.523668729 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshiftR_closure" {
     Data.Bits.$fBitsInteger_$cshiftR_closure:
         const Data.Bits.$fBitsInteger_$cshiftR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1Egu,
                       label: Data.Bits.$fBitsInteger_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Egu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Egv; else goto c1Egw;
       c1Egv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Egw: // global
           I64[Sp - 16] = block_c1Egr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EgK; else goto c1Egs;
       u1EgK: // global
           call _c1Egr(R1) args: 0, res: 0, upd: 0;
       c1Egs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Egr() //  [R1]
         { info_tbl: [(c1Egr,
                       label: block_c1Egr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Egr: // global
           _s1CP4::P64 = P64[Sp + 8];
           _s1CP8::I64 = -I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CP8::I64, 0)) goto c1EgG; else goto c1EgH;
       c1EgG: // global
           R3 = -_s1CP8::I64;
           R2 = _s1CP4::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1EgH: // global
           R3 = _s1CP8::I64;
           R2 = _s1CP4::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.524905679 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsInteger_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsInteger_$cunsafeShiftR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1EgP,
                       label: Data.Bits.$fBitsInteger_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EgP: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.526135547 UTC

[section ""data" . Data.Bits.$fBitsInteger_$crotateR_closure" {
     Data.Bits.$fBitsInteger_$crotateR_closure:
         const Data.Bits.$fBitsInteger_$crotateR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1EgZ,
                       label: Data.Bits.$fBitsInteger_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EgZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Eh0; else goto c1Eh1;
       c1Eh0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Eh1: // global
           I64[Sp - 16] = block_c1EgW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Ehf; else goto c1EgX;
       u1Ehf: // global
           call _c1EgW(R1) args: 0, res: 0, upd: 0;
       c1EgX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EgW() //  [R1]
         { info_tbl: [(c1EgW,
                       label: block_c1EgW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EgW: // global
           _s1CPb::P64 = P64[Sp + 8];
           _s1CPf::I64 = -I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CPf::I64, 0)) goto c1Ehb; else goto c1Ehc;
       c1Ehb: // global
           R3 = -_s1CPf::I64;
           R2 = _s1CPb::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1Ehc: // global
           R3 = _s1CPf::I64;
           R2 = _s1CPb::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.527504138 UTC

[section ""data" . Data.Bits.$fBitsInteger_$crotateL_closure" {
     Data.Bits.$fBitsInteger_$crotateL_closure:
         const Data.Bits.$fBitsInteger_$crotateL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1Ehk,
                       label: Data.Bits.$fBitsInteger_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ehk: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.528502242 UTC

[section ""data" . Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1Ehy,
                       label: Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ehy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Ehz; else goto c1EhA;
       c1Ehz: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EhA: // global
           I64[Sp - 8] = block_c1Ehr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EhH; else goto c1Ehs;
       u1EhH: // global
           call _c1Ehr(R1) args: 0, res: 0, upd: 0;
       c1Ehs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ehr() //  [R1]
         { info_tbl: [(c1Ehr,
                       label: block_c1Ehr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ehr: // global
           if (R1 & 7 == 1) goto c1Ehv; else goto c1Ehw;
       c1Ehv: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Ehw: // global
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.529891116 UTC

[section ""data" . Data.Bits.$fBitsInt_$cpopCount_closure" {
     Data.Bits.$fBitsInt_$cpopCount_closure:
         const Data.Bits.$fBitsInt_$cpopCount_info;
 },
 Data.Bits.$fBitsInt_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1EhP,
                       label: Data.Bits.$fBitsInt_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EhP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Ei3; else goto c1Ei4;
       c1Ei3: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Ei4: // global
           I64[Sp - 8] = block_c1EhM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Ei8; else goto c1EhN;
       u1Ei8: // global
           call _c1EhM(R1) args: 0, res: 0, upd: 0;
       c1EhN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EhM() //  [R1]
         { info_tbl: [(c1EhM,
                       label: block_c1EhM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EhM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ei7; else goto c1Ei6;
       c1Ei7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Ei6: // global
           (_c1EhV::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1EhV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.531371249 UTC

[section ""data" . Data.Bits.$fBitsInt_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsInt_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsInt_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsInt_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1Eig,
                       label: Data.Bits.$fBitsInt_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eig: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Eis; else goto c1Eit;
       c1Eis: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Eit: // global
           I64[Sp - 16] = block_c1Eid_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Eiz; else goto c1Eie;
       u1Eiz: // global
           call _c1Eid(R1) args: 0, res: 0, upd: 0;
       c1Eie: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eid() //  [R1]
         { info_tbl: [(c1Eid,
                       label: block_c1Eid_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eid: // global
           I64[Sp] = block_c1Eij_info;
           _s1CPt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPt::I64;
           if (R1 & 7 != 0) goto u1Eiy; else goto c1Eik;
       u1Eiy: // global
           call _c1Eij(R1) args: 0, res: 0, upd: 0;
       c1Eik: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eij() //  [R1]
         { info_tbl: [(c1Eij,
                       label: block_c1Eij_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eij: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Eix; else goto c1Eiw;
       c1Eix: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Eiw: // global
           _s1CPw::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CPw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.532755842 UTC

[section ""data" . lvl_r1CDD_closure" {
     lvl_r1CDD_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.533877431 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshiftR_closure" {
     Data.Bits.$fBitsInt_$cshiftR_closure:
         const Data.Bits.$fBitsInt_$cshiftR_info;
 },
 Data.Bits.$fBitsInt_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1EiH,
                       label: Data.Bits.$fBitsInt_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EiH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EiL; else goto c1EiM;
       c1EiL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EiM: // global
           I64[Sp - 16] = block_c1EiE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Ejc; else goto c1EiF;
       u1Ejc: // global
           call _c1EiE(R1) args: 0, res: 0, upd: 0;
       c1EiF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EiE() //  [R1]
         { info_tbl: [(c1EiE,
                       label: block_c1EiE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EiE: // global
           I64[Sp] = block_c1EiK_info;
           _s1CPA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPA::I64;
           if (R1 & 7 != 0) goto u1Ejb; else goto c1EiO;
       u1Ejb: // global
           call _c1EiK(R1) args: 0, res: 0, upd: 0;
       c1EiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EiK() //  [R1]
         { info_tbl: [(c1EiK,
                       label: block_c1EiK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EiK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EiU; else goto c1EiT;
       c1EiU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EiT: // global
           _s1CPA::I64 = I64[Sp + 8];
           _s1CPC::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CPC::I64, 64)) goto c1Ej3; else goto c1Eja;
       c1Ej3: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s1CPA::I64, _s1CPC::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Eja: // global
           if (%MO_S_Ge_W64(_s1CPA::I64, 0)) goto c1Ej8; else goto c1Ej9;
       c1Ej8: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Ej9: // global
           Hp = Hp - 16;
           R1 = lvl_r1CDD_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.536329672 UTC

[section ""data" . Data.Bits.$fBitsInt_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsInt_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsInt_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsInt_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Ejk,
                       label: Data.Bits.$fBitsInt_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ejk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Ejw; else goto c1Ejx;
       c1Ejw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ejx: // global
           I64[Sp - 16] = block_c1Ejh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EjD; else goto c1Eji;
       u1EjD: // global
           call _c1Ejh(R1) args: 0, res: 0, upd: 0;
       c1Eji: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ejh() //  [R1]
         { info_tbl: [(c1Ejh,
                       label: block_c1Ejh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ejh: // global
           I64[Sp] = block_c1Ejn_info;
           _s1CPJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPJ::I64;
           if (R1 & 7 != 0) goto u1EjC; else goto c1Ejo;
       u1EjC: // global
           call _c1Ejn(R1) args: 0, res: 0, upd: 0;
       c1Ejo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ejn() //  [R1]
         { info_tbl: [(c1Ejn,
                       label: block_c1Ejn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ejn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EjB; else goto c1EjA;
       c1EjB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EjA: // global
           _s1CPM::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CPM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.538307402 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshiftL_closure" {
     Data.Bits.$fBitsInt_$cshiftL_closure:
         const Data.Bits.$fBitsInt_$cshiftL_info;
 },
 Data.Bits.$fBitsInt_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1EjL,
                       label: Data.Bits.$fBitsInt_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EjL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EjP; else goto c1EjQ;
       c1EjP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EjQ: // global
           I64[Sp - 16] = block_c1EjI_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Eka; else goto c1EjJ;
       u1Eka: // global
           call _c1EjI(R1) args: 0, res: 0, upd: 0;
       c1EjJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EjI() //  [R1]
         { info_tbl: [(c1EjI,
                       label: block_c1EjI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EjI: // global
           I64[Sp] = block_c1EjO_info;
           _s1CPQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPQ::I64;
           if (R1 & 7 != 0) goto u1Ek9; else goto c1EjS;
       u1Ek9: // global
           call _c1EjO(R1) args: 0, res: 0, upd: 0;
       c1EjS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EjO() //  [R1]
         { info_tbl: [(c1EjO,
                       label: block_c1EjO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EjO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EjY; else goto c1EjX;
       c1EjY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EjX: // global
           _s1CPS::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CPS::I64, 64)) goto c1Ek7; else goto c1Ek8;
       c1Ek7: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] << _s1CPS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Ek8: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.539789236 UTC

[section ""data" . Data.Bits.$fBitsInt_$cisSigned_closure" {
     Data.Bits.$fBitsInt_$cisSigned_closure:
         const Data.Bits.$fBitsInt_$cisSigned_info;
 },
 Data.Bits.$fBitsInt_$cisSigned_entry() //  []
         { info_tbl: [(c1Ekf,
                       label: Data.Bits.$fBitsInt_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ekf: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.540947415 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotate_closure" {
     Data.Bits.$fBitsInt_$crotate_closure:
         const Data.Bits.$fBitsInt_$crotate_info;
 },
 Data.Bits.$fBitsInt_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c1Ekp,
                       label: Data.Bits.$fBitsInt_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ekp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EkN; else goto c1EkO;
       c1EkN: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EkO: // global
           I64[Sp - 16] = block_c1Ekm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EkU; else goto c1Ekn;
       u1EkU: // global
           call _c1Ekm(R1) args: 0, res: 0, upd: 0;
       c1Ekn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ekm() //  [R1]
         { info_tbl: [(c1Ekm,
                       label: block_c1Ekm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ekm: // global
           I64[Sp] = block_c1Eks_info;
           _s1CPZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPZ::I64;
           if (R1 & 7 != 0) goto u1EkT; else goto c1Ekt;
       u1EkT: // global
           call _c1Eks(R1) args: 0, res: 0, upd: 0;
       c1Ekt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eks() //  [R1]
         { info_tbl: [(c1Eks,
                       label: block_c1Eks_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eks: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EkS; else goto c1EkR;
       c1EkS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EkR: // global
           _s1CQ2::I64 = I64[R1 + 7] & 63;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _s1CPZ::I64 = I64[Sp + 8];
           I64[Hp] = (_s1CPZ::I64 << _s1CQ2::I64) | (_s1CPZ::I64 >> 64 - _s1CQ2::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.543006174 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshift_closure" {
     Data.Bits.$fBitsInt_$cshift_closure:
         const Data.Bits.$fBitsInt_$cshift_info;
 },
 Data.Bits.$fBitsInt_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1El2,
                       label: Data.Bits.$fBitsInt_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1El2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1El6; else goto c1El7;
       c1El6: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1El7: // global
           I64[Sp - 16] = block_c1EkZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1ElR; else goto c1El0;
       u1ElR: // global
           call _c1EkZ(R1) args: 0, res: 0, upd: 0;
       c1El0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EkZ() //  [R1]
         { info_tbl: [(c1EkZ,
                       label: block_c1EkZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EkZ: // global
           I64[Sp] = block_c1El5_info;
           _s1CQa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQa::I64;
           if (R1 & 7 != 0) goto u1ElQ; else goto c1El9;
       u1ElQ: // global
           call _c1El5(R1) args: 0, res: 0, upd: 0;
       c1El9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1El5() //  [R1]
         { info_tbl: [(c1El5,
                       label: block_c1El5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1El5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Elf; else goto c1Ele;
       c1Elf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Ele: // global
           _s1CQa::I64 = I64[Sp + 8];
           _s1CQc::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CQc::I64, 0)) goto c1ElD; else goto c1ElP;
       c1ElD: // global
           _s1CQe::I64 = -_s1CQc::I64;
           if (%MO_S_Lt_W64(_s1CQe::I64, 64)) goto c1Elu; else goto c1ElB;
       c1Elu: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s1CQa::I64, _s1CQe::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ElB: // global
           if (%MO_S_Ge_W64(_s1CQa::I64, 0)) goto c1ElO; else goto c1ElA;
       c1ElA: // global
           Hp = Hp - 16;
           R1 = lvl_r1CDD_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ElP: // global
           if (%MO_S_Ge_W64(_s1CQc::I64, 64)) goto c1ElO; else goto c1ElN;
       c1ElO: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ElN: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQa::I64 << _s1CQc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.544968827 UTC

[section ""data" . Data.Bits.$fBitsInt_$ccomplement_closure" {
     Data.Bits.$fBitsInt_$ccomplement_closure:
         const Data.Bits.$fBitsInt_$ccomplement_info;
 },
 Data.Bits.$fBitsInt_$ccomplement_entry() //  [R2]
         { info_tbl: [(c1ElZ,
                       label: Data.Bits.$fBitsInt_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ElZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Em6; else goto c1Em7;
       c1Em6: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Em7: // global
           I64[Sp - 8] = block_c1ElW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Emb; else goto c1ElX;
       u1Emb: // global
           call _c1ElW(R1) args: 0, res: 0, upd: 0;
       c1ElX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ElW() //  [R1]
         { info_tbl: [(c1ElW,
                       label: block_c1ElW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ElW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ema; else goto c1Em9;
       c1Ema: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Em9: // global
           _s1CQn::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQn::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.54653503 UTC

[section ""data" . Data.Bits.$fBitsInt_$cxor_closure" {
     Data.Bits.$fBitsInt_$cxor_closure:
         const Data.Bits.$fBitsInt_$cxor_info;
 },
 Data.Bits.$fBitsInt_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c1Emj,
                       label: Data.Bits.$fBitsInt_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Emj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Emv; else goto c1Emw;
       c1Emv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Emw: // global
           I64[Sp - 16] = block_c1Emg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EmC; else goto c1Emh;
       u1EmC: // global
           call _c1Emg(R1) args: 0, res: 0, upd: 0;
       c1Emh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Emg() //  [R1]
         { info_tbl: [(c1Emg,
                       label: block_c1Emg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Emg: // global
           I64[Sp] = block_c1Emm_info;
           _s1CQr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQr::I64;
           if (R1 & 7 != 0) goto u1EmB; else goto c1Emn;
       u1EmB: // global
           call _c1Emm(R1) args: 0, res: 0, upd: 0;
       c1Emn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Emm() //  [R1]
         { info_tbl: [(c1Emm,
                       label: block_c1Emm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Emm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EmA; else goto c1Emz;
       c1EmA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Emz: // global
           _s1CQu::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.548877983 UTC

[section ""data" . Data.Bits.$fBitsInt_$c.|._closure" {
     Data.Bits.$fBitsInt_$c.|._closure:
         const Data.Bits.$fBitsInt_$c.|._info;
 },
 Data.Bits.$fBitsInt_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c1EmK,
                       label: Data.Bits.$fBitsInt_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EmK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EmW; else goto c1EmX;
       c1EmW: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EmX: // global
           I64[Sp - 16] = block_c1EmH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1En3; else goto c1EmI;
       u1En3: // global
           call _c1EmH(R1) args: 0, res: 0, upd: 0;
       c1EmI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EmH() //  [R1]
         { info_tbl: [(c1EmH,
                       label: block_c1EmH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EmH: // global
           I64[Sp] = block_c1EmN_info;
           _s1CQy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQy::I64;
           if (R1 & 7 != 0) goto u1En2; else goto c1EmO;
       u1En2: // global
           call _c1EmN(R1) args: 0, res: 0, upd: 0;
       c1EmO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EmN() //  [R1]
         { info_tbl: [(c1EmN,
                       label: block_c1EmN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EmN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1En1; else goto c1En0;
       c1En1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1En0: // global
           _s1CQB::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.550799566 UTC

[section ""data" . Data.Bits.$fBitsInt_$c.&._closure" {
     Data.Bits.$fBitsInt_$c.&._closure:
         const Data.Bits.$fBitsInt_$c.&._info;
 },
 Data.Bits.$fBitsInt_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c1Enb,
                       label: Data.Bits.$fBitsInt_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Enb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Enn; else goto c1Eno;
       c1Enn: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Eno: // global
           I64[Sp - 16] = block_c1En8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Enu; else goto c1En9;
       u1Enu: // global
           call _c1En8(R1) args: 0, res: 0, upd: 0;
       c1En9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1En8() //  [R1]
         { info_tbl: [(c1En8,
                       label: block_c1En8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1En8: // global
           I64[Sp] = block_c1Ene_info;
           _s1CQF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQF::I64;
           if (R1 & 7 != 0) goto u1Ent; else goto c1Enf;
       u1Ent: // global
           call _c1Ene(R1) args: 0, res: 0, upd: 0;
       c1Enf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ene() //  [R1]
         { info_tbl: [(c1Ene,
                       label: block_c1Ene_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ene: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ens; else goto c1Enr;
       c1Ens: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Enr: // global
           _s1CQI::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.552438504 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1EnC,
                       label: Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EnC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1EnQ; else goto c1EnR;
       c1EnQ: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EnR: // global
           I64[Sp - 8] = block_c1Enz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EnV; else goto c1EnA;
       u1EnV: // global
           call _c1Enz(R1) args: 0, res: 0, upd: 0;
       c1EnA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Enz() //  [R1]
         { info_tbl: [(c1Enz,
                       label: block_c1Enz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Enz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EnU; else goto c1EnT;
       c1EnU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EnT: // global
           (_c1EnI::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1EnI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.55385774 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure" {
     Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure:
         const Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_info;
 },
 Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1Eo3,
                       label: Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eo3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Eoh; else goto c1Eoi;
       c1Eoh: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Eoi: // global
           I64[Sp - 8] = block_c1Eo0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Eom; else goto c1Eo1;
       u1Eom: // global
           call _c1Eo0(R1) args: 0, res: 0, upd: 0;
       c1Eo1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eo0() //  [R1]
         { info_tbl: [(c1Eo0,
                       label: block_c1Eo0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eo0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Eol; else goto c1Eok;
       c1Eol: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Eok: // global
           (_c1Eo9::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1Eo9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.554979625 UTC

[section ""data" . Data.Bits.$fBitsInt1_closure" {
     Data.Bits.$fBitsInt1_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.555632402 UTC

[section ""data" . Data.Bits.$fBitsInt_$cfiniteBitSize_closure" {
     Data.Bits.$fBitsInt_$cfiniteBitSize_closure:
         const Data.Bits.$fBitsInt_$cfiniteBitSize_info;
 },
 Data.Bits.$fBitsInt_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c1Eor,
                       label: Data.Bits.$fBitsInt_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eor: // global
           R1 = Data.Bits.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.556723983 UTC

[section ""data" . Data.Bits.$fBitsWord_$cpopCount_closure" {
     Data.Bits.$fBitsWord_$cpopCount_closure:
         const Data.Bits.$fBitsWord_$cpopCount_info;
 },
 Data.Bits.$fBitsWord_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1EoB,
                       label: Data.Bits.$fBitsWord_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EoB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1EoM; else goto c1EoN;
       c1EoM: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EoN: // global
           I64[Sp - 8] = block_c1Eoy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EoR; else goto c1Eoz;
       u1EoR: // global
           call _c1Eoy(R1) args: 0, res: 0, upd: 0;
       c1Eoz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eoy() //  [R1]
         { info_tbl: [(c1Eoy,
                       label: block_c1Eoy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eoy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EoQ; else goto c1EoP;
       c1EoQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EoP: // global
           (_c1EoE::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1EoE::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.558416123 UTC

[section ""data" . Data.Bits.$fBitsWord_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsWord_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsWord_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsWord_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1EoZ,
                       label: Data.Bits.$fBitsWord_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EoZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Epb; else goto c1Epc;
       c1Epb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Epc: // global
           I64[Sp - 16] = block_c1EoW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Epi; else goto c1EoX;
       u1Epi: // global
           call _c1EoW(R1) args: 0, res: 0, upd: 0;
       c1EoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EoW() //  [R1]
         { info_tbl: [(c1EoW,
                       label: block_c1EoW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EoW: // global
           I64[Sp] = block_c1Ep2_info;
           _s1CR4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CR4::I64;
           if (R1 & 7 != 0) goto u1Eph; else goto c1Ep3;
       u1Eph: // global
           call _c1Ep2(R1) args: 0, res: 0, upd: 0;
       c1Ep3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ep2() //  [R1]
         { info_tbl: [(c1Ep2,
                       label: block_c1Ep2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ep2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Epg; else goto c1Epf;
       c1Epg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Epf: // global
           _s1CR7::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CR7::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.560374474 UTC

[section ""data" . Data.Bits.$fBitsWord1_closure" {
     Data.Bits.$fBitsWord1_closure:
         const GHC.Types.W#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.561518164 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshiftR_closure" {
     Data.Bits.$fBitsWord_$cshiftR_closure:
         const Data.Bits.$fBitsWord_$cshiftR_info;
 },
 Data.Bits.$fBitsWord_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1Epq,
                       label: Data.Bits.$fBitsWord_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Epq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Epu; else goto c1Epv;
       c1Epu: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Epv: // global
           I64[Sp - 16] = block_c1Epn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EpP; else goto c1Epo;
       u1EpP: // global
           call _c1Epn(R1) args: 0, res: 0, upd: 0;
       c1Epo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Epn() //  [R1]
         { info_tbl: [(c1Epn,
                       label: block_c1Epn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Epn: // global
           I64[Sp] = block_c1Ept_info;
           _s1CRb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRb::I64;
           if (R1 & 7 != 0) goto u1EpO; else goto c1Epx;
       u1EpO: // global
           call _c1Ept(R1) args: 0, res: 0, upd: 0;
       c1Epx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ept() //  [R1]
         { info_tbl: [(c1Ept,
                       label: block_c1Ept_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ept: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EpD; else goto c1EpC;
       c1EpD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EpC: // global
           _s1CRd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CRd::I64, 64)) goto c1EpM; else goto c1EpN;
       c1EpM: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s1CRd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EpN: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.56328506 UTC

[section ""data" . Data.Bits.$fBitsWord_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsWord_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsWord_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsWord_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1EpX,
                       label: Data.Bits.$fBitsWord_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EpX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Eq9; else goto c1Eqa;
       c1Eq9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Eqa: // global
           I64[Sp - 16] = block_c1EpU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Eqg; else goto c1EpV;
       u1Eqg: // global
           call _c1EpU(R1) args: 0, res: 0, upd: 0;
       c1EpV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EpU() //  [R1]
         { info_tbl: [(c1EpU,
                       label: block_c1EpU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EpU: // global
           I64[Sp] = block_c1Eq0_info;
           _s1CRj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRj::I64;
           if (R1 & 7 != 0) goto u1Eqf; else goto c1Eq1;
       u1Eqf: // global
           call _c1Eq0(R1) args: 0, res: 0, upd: 0;
       c1Eq1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eq0() //  [R1]
         { info_tbl: [(c1Eq0,
                       label: block_c1Eq0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eq0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Eqe; else goto c1Eqd;
       c1Eqe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Eqd: // global
           _s1CRm::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.565066514 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshiftL_closure" {
     Data.Bits.$fBitsWord_$cshiftL_closure:
         const Data.Bits.$fBitsWord_$cshiftL_info;
 },
 Data.Bits.$fBitsWord_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Eqo,
                       label: Data.Bits.$fBitsWord_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eqo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Eqs; else goto c1Eqt;
       c1Eqs: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Eqt: // global
           I64[Sp - 16] = block_c1Eql_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EqN; else goto c1Eqm;
       u1EqN: // global
           call _c1Eql(R1) args: 0, res: 0, upd: 0;
       c1Eqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eql() //  [R1]
         { info_tbl: [(c1Eql,
                       label: block_c1Eql_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eql: // global
           I64[Sp] = block_c1Eqr_info;
           _s1CRq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRq::I64;
           if (R1 & 7 != 0) goto u1EqM; else goto c1Eqv;
       u1EqM: // global
           call _c1Eqr(R1) args: 0, res: 0, upd: 0;
       c1Eqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eqr() //  [R1]
         { info_tbl: [(c1Eqr,
                       label: block_c1Eqr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eqr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EqB; else goto c1EqA;
       c1EqB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EqA: // global
           _s1CRs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CRs::I64, 64)) goto c1EqK; else goto c1EqL;
       c1EqK: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] << _s1CRs::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EqL: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.56678355 UTC

[section ""data" . Data.Bits.$fBitsWord_$cisSigned_closure" {
     Data.Bits.$fBitsWord_$cisSigned_closure:
         const Data.Bits.$fBitsWord_$cisSigned_info;
 },
 Data.Bits.$fBitsWord_$cisSigned_entry() //  []
         { info_tbl: [(c1EqS,
                       label: Data.Bits.$fBitsWord_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EqS: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.568127392 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotate_closure" {
     Data.Bits.$fBitsWord_$crotate_closure:
         const Data.Bits.$fBitsWord_$crotate_info;
 },
 Data.Bits.$fBitsWord_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c1Er2,
                       label: Data.Bits.$fBitsWord_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Er2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Er6; else goto c1Er7;
       c1Er6: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Er7: // global
           I64[Sp - 16] = block_c1EqZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1ErL; else goto c1Er0;
       u1ErL: // global
           call _c1EqZ(R1) args: 0, res: 0, upd: 0;
       c1Er0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EqZ() //  [R1]
         { info_tbl: [(c1EqZ,
                       label: block_c1EqZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EqZ: // global
           I64[Sp - 8] = block_c1Er5_info;
           _s1CRy::P64 = R1;
           _s1CRz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CRz::I64;
           P64[Sp + 8] = _s1CRy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ErK; else goto c1Er9;
       u1ErK: // global
           call _c1Er5(R1) args: 0, res: 0, upd: 0;
       c1Er9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Er5() //  [R1]
         { info_tbl: [(c1Er5,
                       label: block_c1Er5_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Er5: // global
           _s1CRC::I64 = I64[R1 + 7] & 63;
           if (_s1CRC::I64 != 0) goto u1ErI; else goto c1ErE;
       u1ErI: // global
           I64[Sp + 16] = _s1CRC::I64;
           Sp = Sp + 8;
           call _c1Eri() args: 0, res: 0, upd: 0;
       c1ErE: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Eri() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eri: // global
           Hp = Hp + 16;
           _s1CRC::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1ErB; else goto c1ErA;
       c1ErB: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1Erh_info;
           R1 = _s1CRC::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1ErA: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           _s1CRz::I64 = I64[Sp];
           I64[Hp] = (_s1CRz::I64 << _s1CRC::I64) | (_s1CRz::I64 >> 64 - _s1CRC::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Erh() //  [R1]
         { info_tbl: [(c1Erh,
                       label: block_c1Erh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Erh: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1Eri() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.570587489 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshift_closure" {
     Data.Bits.$fBitsWord_$cshift_closure:
         const Data.Bits.$fBitsWord_$cshift_info;
 },
 Data.Bits.$fBitsWord_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1ErV,
                       label: Data.Bits.$fBitsWord_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ErV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ErZ; else goto c1Es0;
       c1ErZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Es0: // global
           I64[Sp - 16] = block_c1ErS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EsE; else goto c1ErT;
       u1EsE: // global
           call _c1ErS(R1) args: 0, res: 0, upd: 0;
       c1ErT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ErS() //  [R1]
         { info_tbl: [(c1ErS,
                       label: block_c1ErS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ErS: // global
           I64[Sp] = block_c1ErY_info;
           _s1CRK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRK::I64;
           if (R1 & 7 != 0) goto u1EsD; else goto c1Es2;
       u1EsD: // global
           call _c1ErY(R1) args: 0, res: 0, upd: 0;
       c1Es2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ErY() //  [R1]
         { info_tbl: [(c1ErY,
                       label: block_c1ErY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ErY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Es8; else goto c1Es7;
       c1Es8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Es7: // global
           _s1CRK::I64 = I64[Sp + 8];
           _s1CRM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CRM::I64, 0)) goto c1Esq; else goto c1EsC;
       c1Esq: // global
           _s1CRO::I64 = -_s1CRM::I64;
           if (%MO_S_Ge_W64(_s1CRO::I64, 64)) goto c1EsB; else goto c1Esn;
       c1Esn: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRK::I64 >> _s1CRO::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EsC: // global
           if (%MO_S_Ge_W64(_s1CRM::I64, 64)) goto c1EsB; else goto c1EsA;
       c1EsB: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EsA: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRK::I64 << _s1CRM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.57317362 UTC

[section ""data" . Data.Bits.$fBitsWord_$ccomplement_closure" {
     Data.Bits.$fBitsWord_$ccomplement_closure:
         const Data.Bits.$fBitsWord_$ccomplement_info;
 },
 Data.Bits.$fBitsWord_$ccomplement_entry() //  [R2]
         { info_tbl: [(c1EsM,
                       label: Data.Bits.$fBitsWord_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EsM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1EsT; else goto c1EsU;
       c1EsT: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EsU: // global
           I64[Sp - 8] = block_c1EsJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EsY; else goto c1EsK;
       u1EsY: // global
           call _c1EsJ(R1) args: 0, res: 0, upd: 0;
       c1EsK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EsJ() //  [R1]
         { info_tbl: [(c1EsJ,
                       label: block_c1EsJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EsJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EsX; else goto c1EsW;
       c1EsX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EsW: // global
           _s1CRW::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.574677832 UTC

[section ""data" . Data.Bits.$fBitsWord_$cxor_closure" {
     Data.Bits.$fBitsWord_$cxor_closure:
         const Data.Bits.$fBitsWord_$cxor_info;
 },
 Data.Bits.$fBitsWord_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c1Et6,
                       label: Data.Bits.$fBitsWord_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Et6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Eti; else goto c1Etj;
       c1Eti: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Etj: // global
           I64[Sp - 16] = block_c1Et3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Etp; else goto c1Et4;
       u1Etp: // global
           call _c1Et3(R1) args: 0, res: 0, upd: 0;
       c1Et4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Et3() //  [R1]
         { info_tbl: [(c1Et3,
                       label: block_c1Et3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Et3: // global
           I64[Sp] = block_c1Et9_info;
           _s1CS0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CS0::I64;
           if (R1 & 7 != 0) goto u1Eto; else goto c1Eta;
       u1Eto: // global
           call _c1Et9(R1) args: 0, res: 0, upd: 0;
       c1Eta: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Et9() //  [R1]
         { info_tbl: [(c1Et9,
                       label: block_c1Et9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Et9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Etn; else goto c1Etm;
       c1Etn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Etm: // global
           _s1CS3::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CS3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.576352049 UTC

[section ""data" . Data.Bits.$fBitsWord_$c.|._closure" {
     Data.Bits.$fBitsWord_$c.|._closure:
         const Data.Bits.$fBitsWord_$c.|._info;
 },
 Data.Bits.$fBitsWord_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c1Etx,
                       label: Data.Bits.$fBitsWord_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Etx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EtJ; else goto c1EtK;
       c1EtJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EtK: // global
           I64[Sp - 16] = block_c1Etu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EtQ; else goto c1Etv;
       u1EtQ: // global
           call _c1Etu(R1) args: 0, res: 0, upd: 0;
       c1Etv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Etu() //  [R1]
         { info_tbl: [(c1Etu,
                       label: block_c1Etu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Etu: // global
           I64[Sp] = block_c1EtA_info;
           _s1CS7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CS7::I64;
           if (R1 & 7 != 0) goto u1EtP; else goto c1EtB;
       u1EtP: // global
           call _c1EtA(R1) args: 0, res: 0, upd: 0;
       c1EtB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EtA() //  [R1]
         { info_tbl: [(c1EtA,
                       label: block_c1EtA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EtA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EtO; else goto c1EtN;
       c1EtO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EtN: // global
           _s1CSa::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CSa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.57809828 UTC

[section ""data" . Data.Bits.$fBitsWord_$c.&._closure" {
     Data.Bits.$fBitsWord_$c.&._closure:
         const Data.Bits.$fBitsWord_$c.&._info;
 },
 Data.Bits.$fBitsWord_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c1EtY,
                       label: Data.Bits.$fBitsWord_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EtY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Eua; else goto c1Eub;
       c1Eua: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Eub: // global
           I64[Sp - 16] = block_c1EtV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Euh; else goto c1EtW;
       u1Euh: // global
           call _c1EtV(R1) args: 0, res: 0, upd: 0;
       c1EtW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EtV() //  [R1]
         { info_tbl: [(c1EtV,
                       label: block_c1EtV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EtV: // global
           I64[Sp] = block_c1Eu1_info;
           _s1CSe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CSe::I64;
           if (R1 & 7 != 0) goto u1Eug; else goto c1Eu2;
       u1Eug: // global
           call _c1Eu1(R1) args: 0, res: 0, upd: 0;
       c1Eu2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eu1() //  [R1]
         { info_tbl: [(c1Eu1,
                       label: block_c1Eu1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eu1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Euf; else goto c1Eue;
       c1Euf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Eue: // global
           _s1CSh::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CSh::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.579708426 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1Eup,
                       label: Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eup: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1EuA; else goto c1EuB;
       c1EuA: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EuB: // global
           I64[Sp - 8] = block_c1Eum_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EuF; else goto c1Eun;
       u1EuF: // global
           call _c1Eum(R1) args: 0, res: 0, upd: 0;
       c1Eun: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Eum() //  [R1]
         { info_tbl: [(c1Eum,
                       label: block_c1Eum_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eum: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EuE; else goto c1EuD;
       c1EuE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EuD: // global
           (_c1Eus::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1Eus::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.581101373 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure" {
     Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure:
         const Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_info;
 },
 Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1EuN,
                       label: Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EuN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1EuY; else goto c1EuZ;
       c1EuY: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EuZ: // global
           I64[Sp - 8] = block_c1EuK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Ev3; else goto c1EuL;
       u1Ev3: // global
           call _c1EuK(R1) args: 0, res: 0, upd: 0;
       c1EuL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EuK() //  [R1]
         { info_tbl: [(c1EuK,
                       label: block_c1EuK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EuK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ev2; else goto c1Ev1;
       c1Ev2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Ev1: // global
           (_c1EuQ::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1EuQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.582575105 UTC

[section ""data" . Data.Bits.$fBitsWord_$cfiniteBitSize_closure" {
     Data.Bits.$fBitsWord_$cfiniteBitSize_closure:
         const Data.Bits.$fBitsWord_$cfiniteBitSize_info;
 },
 Data.Bits.$fBitsWord_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c1Ev8,
                       label: Data.Bits.$fBitsWord_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ev8: // global
           R1 = Data.Bits.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.584890298 UTC

[section ""data" . Data.Bits.$dmcountTrailingZeros_closure" {
     Data.Bits.$dmcountTrailingZeros_closure:
         const Data.Bits.$dmcountTrailingZeros_info;
 },
 $dBits_s1CSx_entry() //  [R1]
         { info_tbl: [(c1Evn,
                       label: $dBits_s1CSx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Evn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Evo; else goto c1Evp;
       c1Evo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Evp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcountTrailingZeros_entry() //  [R2, R3]
         { info_tbl: [(c1Evq,
                       label: Data.Bits.$dmcountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Evq: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1Evr; else goto c1Evs;
       c1Evr: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmcountTrailingZeros_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Evs: // global
           I64[Sp - 24] = block_c1Evf_info;
           _s1CSt::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R3;
           P64[Sp - 16] = _s1CSt::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1Evf() //  [R1]
         { info_tbl: [(c1Evf,
                       label: block_c1Evf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Evf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Evv; else goto c1Evu;
       c1Evv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Evu: // global
           _s1CSw::I64 = I64[R1 + 7];
           I64[Hp - 16] = $dBits_s1CSx_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           I64[Sp] = _s1CSw::I64;
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call _c1Evz() args: 0, res: 0, upd: 0;
     }
 },
 _c1Evz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Evz: // global
           Hp = Hp + 16;
           _s1CSz::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c1EvD; else goto c1EvC;
       c1EvD: // global
           HpAlloc = 16;
           I64[Sp] = block_c1Evy_info;
           R1 = _s1CSz::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1EvC: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CSz::I64;
           _c1EvE::P64 = Hp - 7;
           if (%MO_S_Lt_W64(_s1CSz::I64,
                            I64[Sp + 8])) goto c1EvK; else goto u1Ew0;
       c1EvK: // global
           I64[Sp - 16] = block_c1EvI_info;
           R2 = P64[Sp + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[Sp + 24];
           P64[Sp - 24] = _c1EvE::P64;
           P64[Sp - 8] = _c1EvE::P64;
           Sp = Sp - 40;
           call Data.Bits.testBit_entry(R2) args: 32, res: 8, upd: 8;
       u1Ew0: // global
           P64[Sp + 24] = _c1EvE::P64;
           Sp = Sp + 24;
           call _c1EvV() args: 0, res: 0, upd: 0;
     }
 },
 _c1Evy() //  [R1]
         { info_tbl: [(c1Evy,
                       label: block_c1Evy_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Evy: // global
           I64[Sp] = R1;
           call _c1Evz() args: 0, res: 0, upd: 0;
     }
 },
 _c1EvI() //  [R1]
         { info_tbl: [(c1EvI,
                       label: block_c1EvI_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EvI: // global
           if (R1 & 7 == 1) goto c1EvQ; else goto u1Ew1;
       c1EvQ: // global
           I64[Sp + 16] = I64[Sp + 16] + 1;
           Sp = Sp + 16;
           call _c1Evz() args: 0, res: 0, upd: 0;
       u1Ew1: // global
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call _c1EvV() args: 0, res: 0, upd: 0;
     }
 },
 _c1EvV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EvV: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.588476893 UTC

[section ""data" . Data.Bits.$dmcountLeadingZeros_closure" {
     Data.Bits.$dmcountLeadingZeros_closure:
         const Data.Bits.$dmcountLeadingZeros_info;
 },
 $dBits_s1CSI_entry() //  [R1]
         { info_tbl: [(c1Ewk,
                       label: $dBits_s1CSI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ewk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Ewl; else goto c1Ewm;
       c1Ewl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Ewm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcountLeadingZeros_entry() //  [R2, R3]
         { info_tbl: [(c1Ewn,
                       label: Data.Bits.$dmcountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ewn: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1Ewo; else goto c1Ewp;
       c1Ewo: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmcountLeadingZeros_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ewp: // global
           I64[Sp - 24] = block_c1Ewc_info;
           _s1CSE::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R3;
           P64[Sp - 16] = _s1CSE::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1Ewc() //  [R1]
         { info_tbl: [(c1Ewc,
                       label: block_c1Ewc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ewc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Ews; else goto c1Ewr;
       c1Ews: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Ewr: // global
           _s1CSH::I64 = I64[R1 + 7];
           I64[Hp - 16] = $dBits_s1CSI_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = _s1CSH::I64 - 1;
           I64[Sp] = _s1CSH::I64;
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call _c1Ex3() args: 0, res: 0, upd: 0;
     }
 },
 _c1Ex3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ex3: // global
           Hp = Hp + 16;
           _s1CSS::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c1Ex7; else goto c1Ex6;
       c1Ex7: // global
           HpAlloc = 16;
           I64[Sp] = block_c1Ex2_info;
           R1 = _s1CSS::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1Ex6: // global
           if (%MO_S_Ge_W64(_s1CSS::I64, 0)) goto c1Exe; else goto c1Exp;
       c1Exe: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CSS::I64;
           I64[Sp - 8] = block_c1Exc_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = Hp - 7;
           Sp = Sp - 32;
           call Data.Bits.testBit_entry(R2) args: 32, res: 8, upd: 8;
       c1Exp: // global
           Hp = Hp - 16;
           I64[Sp + 24] = _s1CSS::I64;
           Sp = Sp + 8;
           call _c1EwO() args: 0, res: 0, upd: 0;
     }
 },
 _c1Ex2() //  [R1]
         { info_tbl: [(c1Ex2,
                       label: block_c1Ex2_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ex2: // global
           I64[Sp] = R1;
           call _c1Ex3() args: 0, res: 0, upd: 0;
     }
 },
 _c1Exc() //  [R1]
         { info_tbl: [(c1Exc,
                       label: block_c1Exc_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Exc: // global
           _s1CSS::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c1Exk; else goto c1Exo;
       c1Exk: // global
           I64[Sp + 8] = _s1CSS::I64 - 1;
           Sp = Sp + 8;
           call _c1Ex3() args: 0, res: 0, upd: 0;
       c1Exo: // global
           I64[Sp + 32] = _s1CSS::I64;
           Sp = Sp + 16;
           call _c1Ewz() args: 0, res: 0, upd: 0;
     }
 },
 _c1Ewz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ewz: // global
           Hp = Hp + 16;
           _s1CSK::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c1EwK; else goto c1EwJ;
       c1EwK: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1Ewy_info;
           R1 = _s1CSK::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1EwJ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp] + ((-1) - _s1CSK::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Ewy() //  [R1]
         { info_tbl: [(c1Ewy,
                       label: block_c1Ewy_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ewy: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c1Ewz() args: 0, res: 0, upd: 0;
     }
 },
 _c1EwO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EwO: // global
           Hp = Hp + 16;
           _s1CSO::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c1EwZ; else goto c1EwY;
       c1EwZ: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1EwN_info;
           R1 = _s1CSO::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1EwY: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp] + ((-1) - _s1CSO::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1EwN() //  [R1]
         { info_tbl: [(c1EwN,
                       label: block_c1EwN_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EwN: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c1EwO() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.592060668 UTC

[section ""data" . Data.Bits.$dmrotateR_closure" {
     Data.Bits.$dmrotateR_closure:
         const Data.Bits.$dmrotateR_info;
 },
 sat_s1CT4_entry() //  [R1]
         { info_tbl: [(c1ExR,
                       label: sat_s1CT4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ExR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ExY; else goto c1ExZ;
       c1ExY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ExZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1ExO_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1Ey3; else goto c1ExP;
       u1Ey3: // global
           call _c1ExO(R1) args: 0, res: 0, upd: 0;
       c1ExP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1ExO() //  [R1]
         { info_tbl: [(c1ExO,
                       label: block_c1ExO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ExO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ey2; else goto c1Ey1;
       c1Ey2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1Ey1: // global
           _s1CT3::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CT3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmrotateR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Ey4,
                       label: Data.Bits.$dmrotateR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ey4: // global
           _s1CT0::P64 = R4;
           _s1CSZ::P64 = R3;
           _s1CSY::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1Ey5; else goto c1Ey6;
       c1Ey6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Ey8; else goto c1Ey7;
       c1Ey8: // global
           HpAlloc = 24;
           goto c1Ey5;
       c1Ey5: // global
           R4 = _s1CT0::P64;
           R3 = _s1CSZ::P64;
           R2 = _s1CSY::P64;
           R1 = Data.Bits.$dmrotateR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ey7: // global
           I64[Hp - 16] = sat_s1CT4_info;
           P64[Hp] = _s1CT0::P64;
           R2 = _s1CSY::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CSZ::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Data.Bits.rotate_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.593783798 UTC

[section ""data" . Data.Bits.$dmrotateL_closure" {
     Data.Bits.$dmrotateL_closure:
         const Data.Bits.$dmrotateL_info;
 },
 Data.Bits.$dmrotateL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Eyd,
                       label: Data.Bits.$dmrotateL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eyd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Eye; else goto c1Eyf;
       c1Eye: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmrotateL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Eyf: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.rotate_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.594808564 UTC

[section ""data" . Data.Bits.$dmunsafeShiftR_closure" {
     Data.Bits.$dmunsafeShiftR_closure:
         const Data.Bits.$dmunsafeShiftR_info;
 },
 Data.Bits.$dmunsafeShiftR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Eyk,
                       label: Data.Bits.$dmunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eyk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Eyl; else goto c1Eym;
       c1Eyl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmunsafeShiftR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Eym: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shiftR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.596236341 UTC

[section ""data" . Data.Bits.$dmshiftR_closure" {
     Data.Bits.$dmshiftR_closure:
         const Data.Bits.$dmshiftR_info;
 },
 sat_s1CTh_entry() //  [R1]
         { info_tbl: [(c1Eyy,
                       label: sat_s1CTh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eyy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1EyF; else goto c1EyG;
       c1EyF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EyG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1Eyv_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1EyK; else goto c1Eyw;
       u1EyK: // global
           call _c1Eyv(R1) args: 0, res: 0, upd: 0;
       c1Eyw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1Eyv() //  [R1]
         { info_tbl: [(c1Eyv,
                       label: block_c1Eyv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Eyv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EyJ; else goto c1EyI;
       c1EyJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1EyI: // global
           _s1CTg::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CTg::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmshiftR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1EyL,
                       label: Data.Bits.$dmshiftR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EyL: // global
           _s1CTd::P64 = R4;
           _s1CTc::P64 = R3;
           _s1CTb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1EyM; else goto c1EyN;
       c1EyN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1EyP; else goto c1EyO;
       c1EyP: // global
           HpAlloc = 24;
           goto c1EyM;
       c1EyM: // global
           R4 = _s1CTd::P64;
           R3 = _s1CTc::P64;
           R2 = _s1CTb::P64;
           R1 = Data.Bits.$dmshiftR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EyO: // global
           I64[Hp - 16] = sat_s1CTh_info;
           P64[Hp] = _s1CTd::P64;
           R2 = _s1CTb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTc::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Data.Bits.shift_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.598634517 UTC

[section ""data" . Data.Bits.$dmunsafeShiftL_closure" {
     Data.Bits.$dmunsafeShiftL_closure:
         const Data.Bits.$dmunsafeShiftL_info;
 },
 Data.Bits.$dmunsafeShiftL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1EyU,
                       label: Data.Bits.$dmunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EyU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1EyV; else goto c1EyW;
       c1EyV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmunsafeShiftL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EyW: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.599647794 UTC

[section ""data" . Data.Bits.$dmshiftL_closure" {
     Data.Bits.$dmshiftL_closure:
         const Data.Bits.$dmshiftL_info;
 },
 Data.Bits.$dmshiftL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Ez1,
                       label: Data.Bits.$dmshiftL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ez1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Ez2; else goto c1Ez3;
       c1Ez2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmshiftL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ez3: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shift_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.6008518 UTC

[section ""data" . Data.Bits.$dmcomplementBit_closure" {
     Data.Bits.$dmcomplementBit_closure:
         const Data.Bits.$dmcomplementBit_info;
 },
 sat_s1CTr_entry() //  [R1]
         { info_tbl: [(c1Ezc,
                       label: sat_s1CTr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ezc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Ezd; else goto c1Eze;
       c1Ezd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Eze: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcomplementBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Ezf,
                       label: Data.Bits.$dmcomplementBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ezf: // global
           _s1CTq::P64 = R4;
           _s1CTp::P64 = R3;
           _s1CTo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1Ezg; else goto c1Ezh;
       c1Ezh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1Ezj; else goto c1Ezi;
       c1Ezj: // global
           HpAlloc = 32;
           goto c1Ezg;
       c1Ezg: // global
           R4 = _s1CTq::P64;
           R3 = _s1CTp::P64;
           R2 = _s1CTo::P64;
           R1 = Data.Bits.$dmcomplementBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ezi: // global
           I64[Hp - 24] = sat_s1CTr_info;
           P64[Hp - 8] = _s1CTo::P64;
           P64[Hp] = _s1CTq::P64;
           R2 = _s1CTo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTp::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits.xor_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.602555287 UTC

[section ""data" . Data.Bits.$dmclearBit_closure" {
     Data.Bits.$dmclearBit_closure:
         const Data.Bits.$dmclearBit_info;
 },
 sat_s1CTv_entry() //  [R1]
         { info_tbl: [(c1Ezw,
                       label: sat_s1CTv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ezw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Ezx; else goto c1Ezy;
       c1Ezx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Ezy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CTw_entry() //  [R1]
         { info_tbl: [(c1Ezz,
                       label: sat_s1CTw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ezz: // global
           _s1CTw::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1EzA; else goto c1EzB;
       c1EzB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1EzD; else goto c1EzC;
       c1EzD: // global
           HpAlloc = 32;
           goto c1EzA;
       c1EzA: // global
           R1 = _s1CTw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EzC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CTw::P64;
           _s1CTs::P64 = P64[_s1CTw::P64 + 16];
           _s1CTu::P64 = P64[_s1CTw::P64 + 24];
           I64[Hp - 24] = sat_s1CTv_info;
           P64[Hp - 8] = _s1CTs::P64;
           P64[Hp] = _s1CTu::P64;
           R2 = _s1CTs::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call Data.Bits.complement_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmclearBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1EzE,
                       label: Data.Bits.$dmclearBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EzE: // global
           _s1CTu::P64 = R4;
           _s1CTt::P64 = R3;
           _s1CTs::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1EzF; else goto c1EzG;
       c1EzG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1EzI; else goto c1EzH;
       c1EzI: // global
           HpAlloc = 32;
           goto c1EzF;
       c1EzF: // global
           R4 = _s1CTu::P64;
           R3 = _s1CTt::P64;
           R2 = _s1CTs::P64;
           R1 = Data.Bits.$dmclearBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EzH: // global
           I64[Hp - 24] = sat_s1CTw_info;
           P64[Hp - 8] = _s1CTs::P64;
           P64[Hp] = _s1CTu::P64;
           R2 = _s1CTs::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTt::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits..&._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.604469096 UTC

[section ""data" . Data.Bits.$dmsetBit_closure" {
     Data.Bits.$dmsetBit_closure:
         const Data.Bits.$dmsetBit_info;
 },
 sat_s1CTA_entry() //  [R1]
         { info_tbl: [(c1EzR,
                       label: sat_s1CTA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EzR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EzS; else goto c1EzT;
       c1EzS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EzT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmsetBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1EzU,
                       label: Data.Bits.$dmsetBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EzU: // global
           _s1CTz::P64 = R4;
           _s1CTy::P64 = R3;
           _s1CTx::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1EzV; else goto c1EzW;
       c1EzW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1EzY; else goto c1EzX;
       c1EzY: // global
           HpAlloc = 32;
           goto c1EzV;
       c1EzV: // global
           R4 = _s1CTz::P64;
           R3 = _s1CTy::P64;
           R2 = _s1CTx::P64;
           R1 = Data.Bits.$dmsetBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EzX: // global
           I64[Hp - 24] = sat_s1CTA_info;
           P64[Hp - 8] = _s1CTx::P64;
           P64[Hp] = _s1CTz::P64;
           R2 = _s1CTx::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTy::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits..|._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.605987775 UTC

[section ""data" . Data.Bits.$dmzeroBits_closure" {
     Data.Bits.$dmzeroBits_closure:
         const Data.Bits.$dmzeroBits_info;
 },
 sat_s1CTC_entry() //  [R1]
         { info_tbl: [(c1EA7,
                       label: sat_s1CTC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EA7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EA8; else goto c1EA9;
       c1EA8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EA9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmzeroBits_entry() //  [R2]
         { info_tbl: [(c1EAa,
                       label: Data.Bits.$dmzeroBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EAa: // global
           _s1CTB::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1EAb; else goto c1EAc;
       c1EAc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1EAe; else goto c1EAd;
       c1EAe: // global
           HpAlloc = 24;
           goto c1EAb;
       c1EAb: // global
           R2 = _s1CTB::P64;
           R1 = Data.Bits.$dmzeroBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EAd: // global
           I64[Hp - 16] = sat_s1CTC_info;
           P64[Hp] = _s1CTB::P64;
           R2 = _s1CTB::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp - 24;
           call Data.Bits.clearBit_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.607304935 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotateL_closure" {
     Data.Bits.$fBitsBool_$crotateL_closure:
         const Data.Bits.$fBitsBool_$crotateL_info;
 },
 Data.Bits.$fBitsBool_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1EAj,
                       label: Data.Bits.$fBitsBool_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EAj: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.608185516 UTC

[section ""data" . Data.Bits.$fBitsBool_$cshiftR_closure" {
     Data.Bits.$fBitsBool_$cshiftR_closure:
         const Data.Bits.$fBitsBool_$cshiftR_info;
 },
 Data.Bits.$fBitsBool_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1EAq,
                       label: Data.Bits.$fBitsBool_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EAq: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$ctestBit_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.609812419 UTC

[section ""data" . Data.Bits.$fBitsBool_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsBool_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsBool_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsBool_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1EAx,
                       label: Data.Bits.$fBitsBool_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EAx: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$cshiftR_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.610643192 UTC

[section ""data" . Data.Bits.$fBitsBool_$cshiftL_closure" {
     Data.Bits.$fBitsBool_$cshiftL_closure:
         const Data.Bits.$fBitsBool_$cshiftL_info;
 },
 Data.Bits.$fBitsBool_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1EAE,
                       label: Data.Bits.$fBitsBool_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EAE: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$ctestBit_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.61146678 UTC

[section ""data" . Data.Bits.$fBitsBool_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsBool_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsBool_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsBool_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1EAL,
                       label: Data.Bits.$fBitsBool_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EAL: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$cshiftL_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.612798398 UTC

[section ""data" . Data.Bits.$fBitsBool_$ccomplementBit_closure" {
     Data.Bits.$fBitsBool_$ccomplementBit_closure:
         const Data.Bits.$fBitsBool_$ccomplementBit_info;
 },
 Data.Bits.$fBitsBool_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1EAZ,
                       label: Data.Bits.$fBitsBool_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EAZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EB0; else goto c1EB1;
       c1EB0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EB1: // global
           I64[Sp - 16] = block_c1EAS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EBy; else goto c1EAT;
       u1EBy: // global
           call _c1EAS(R1) args: 0, res: 0, upd: 0;
       c1EAT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EAS() //  [R1]
         { info_tbl: [(c1EAS,
                       label: block_c1EAS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EAS: // global
           _s1CTE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1EAW; else goto c1EAX;
       c1EAW: // global
           I64[Sp + 8] = block_c1EB4_info;
           R1 = _s1CTE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1EBw; else goto c1EB6;
       u1EBw: // global
           call _c1EB4(R1) args: 0, res: 0, upd: 0;
       c1EB6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1EAX: // global
           I64[Sp + 8] = block_c1EBh_info;
           R1 = _s1CTE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1EBx; else goto c1EBj;
       u1EBx: // global
           call _c1EBh(R1) args: 0, res: 0, upd: 0;
       c1EBj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EB4() //  [R1]
         { info_tbl: [(c1EB4,
                       label: block_c1EB4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EB4: // global
           if (I64[R1 + 7] == 0) goto u1EBu; else goto u1EBv;
       u1EBu: // global
           Sp = Sp + 8;
           call _c1EBq() args: 0, res: 0, upd: 0;
       u1EBv: // global
           Sp = Sp + 8;
           call _c1EBr() args: 0, res: 0, upd: 0;
     }
 },
 _c1EBh() //  [R1]
         { info_tbl: [(c1EBh,
                       label: block_c1EBh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EBh: // global
           if (I64[R1 + 7] == 0) goto u1EBs; else goto u1EBt;
       u1EBs: // global
           Sp = Sp + 8;
           call _c1EBr() args: 0, res: 0, upd: 0;
       u1EBt: // global
           Sp = Sp + 8;
           call _c1EBq() args: 0, res: 0, upd: 0;
     }
 },
 _c1EBr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EBr: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1EBq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EBq: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.614950866 UTC

[section ""data" . Data.Bits.$fBitsBool_$cclearBit_closure" {
     Data.Bits.$fBitsBool_$cclearBit_closure:
         const Data.Bits.$fBitsBool_$cclearBit_info;
 },
 Data.Bits.$fBitsBool_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1EBO,
                       label: Data.Bits.$fBitsBool_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EBO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EBP; else goto c1EBQ;
       c1EBP: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EBQ: // global
           I64[Sp - 16] = block_c1EBH_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1ECb; else goto c1EBI;
       u1ECb: // global
           call _c1EBH(R1) args: 0, res: 0, upd: 0;
       c1EBI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EBH() //  [R1]
         { info_tbl: [(c1EBH,
                       label: block_c1EBH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EBH: // global
           if (R1 & 7 == 1) goto u1EC7; else goto c1EBM;
       u1EC7: // global
           Sp = Sp + 16;
           call _c1EC6() args: 0, res: 0, upd: 0;
       c1EBM: // global
           _s1CTN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1EBW_info;
           R1 = _s1CTN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1EC9; else goto c1EBY;
       u1EC9: // global
           call _c1EBW(R1) args: 0, res: 0, upd: 0;
       c1EBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EBW() //  [R1]
         { info_tbl: [(c1EBW,
                       label: block_c1EBW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EBW: // global
           if (I64[R1 + 7] == 0) goto u1EC8; else goto c1EC5;
       u1EC8: // global
           Sp = Sp + 8;
           call _c1EC6() args: 0, res: 0, upd: 0;
       c1EC5: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1EC6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EC6: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.616619364 UTC

[section ""data" . Data.Bits.$fBitsBool_$csetBit_closure" {
     Data.Bits.$fBitsBool_$csetBit_closure:
         const Data.Bits.$fBitsBool_$csetBit_info;
 },
 Data.Bits.$fBitsBool_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1ECo,
                       label: Data.Bits.$fBitsBool_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ECo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ECp; else goto c1ECq;
       c1ECp: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ECq: // global
           I64[Sp - 16] = block_c1ECh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1ECx; else goto c1ECi;
       u1ECx: // global
           call _c1ECh(R1) args: 0, res: 0, upd: 0;
       c1ECi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ECh() //  [R1]
         { info_tbl: [(c1ECh,
                       label: block_c1ECh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ECh: // global
           if (R1 & 7 == 1) goto c1ECl; else goto c1ECm;
       c1ECl: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Bits.$fBitsBool_$cbit_entry(R2) args: 8, res: 0, upd: 8;
       c1ECm: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.617902638 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotateR_closure" {
     Data.Bits.$fBitsBool_$crotateR_closure:
         const Data.Bits.$fBitsBool_$crotateR_info;
 },
 Data.Bits.$fBitsBool_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1ECC,
                       label: Data.Bits.$fBitsBool_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ECC: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.618756772 UTC

[section ""data" . Data.Bits.$fBitsBool_closure" {
     Data.Bits.$fBitsBool_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqBool_closure;
         const GHC.Classes.&&_closure+2;
         const GHC.Classes.||_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const GHC.Classes.not_closure+1;
         const Data.Bits.$fBitsBool_$ctestBit_closure+2;
         const Data.Bits.$fBitsBool_$crotate_closure+2;
         const GHC.Types.False_closure+1;
         const Data.Bits.$fBitsBool_$cbit_closure+1;
         const Data.Bits.$fBitsBool_$csetBit_closure+2;
         const Data.Bits.$fBitsBool_$cclearBit_closure+2;
         const Data.Bits.$fBitsBool_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsBool_$ctestBit_closure+2;
         const Data.Bits.$fBitsBool_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsBool_$cbitSize_closure+1;
         const Data.Bits.$fBitsBool_$cisSigned_closure+1;
         const Data.Bits.$fBitsBool_$cshiftL_closure+2;
         const Data.Bits.$fBitsBool_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsBool_$cshiftR_closure+2;
         const Data.Bits.$fBitsBool_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsBool_$crotateL_closure+2;
         const Data.Bits.$fBitsBool_$crotateR_closure+2;
         const Data.Bits.$fBitsBool_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.619578555 UTC

[section ""data" . Data.Bits.$fFiniteBitsBool_closure" {
     Data.Bits.$fFiniteBitsBool_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsBool_closure+1;
         const Data.Bits.$fBitsBool_$cbitSize_closure+1;
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure+1;
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.621418535 UTC

[section ""data" . Data.Bits.$dmrotate_closure" {
     Data.Bits.$dmrotate_closure:
         const Data.Bits.$dmrotate_info;
 },
 Data.Bits.$dmrotate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ECM,
                       label: Data.Bits.$dmrotate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ECM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ECN; else goto c1ECO;
       c1ECN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmrotate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ECO: // global
           I64[Sp - 24] = block_c1ECJ_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1EDa; else goto c1ECK;
       u1EDa: // global
           call _c1ECJ(R1) args: 0, res: 0, upd: 0;
       c1ECK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ECJ() //  [R1]
         { info_tbl: [(c1ECJ,
                       label: block_c1ECJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ECJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ECT; else goto c1ECS;
       c1ECT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ECS: // global
           _s1CTV::P64 = P64[Sp + 8];
           _s1CTW::P64 = P64[Sp + 16];
           _s1CTZ::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CTZ::I64, 0)) goto c1ED3; else goto c1ED4;
       c1ED3: // global
           if (%MO_S_Le_W64(_s1CTZ::I64, 0)) goto c1ED0; else goto c1ED1;
       c1ED0: // global
           Hp = Hp - 16;
           R1 = _s1CTW::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1ED1: // global
           Hp = Hp - 16;
           R2 = _s1CTV::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CTW::P64;
           P64[Sp + 16] = R1;
           call Data.Bits.rotateL_entry(R2) args: 32, res: 0, upd: 8;
       c1ED4: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1CTZ::I64;
           R2 = _s1CTV::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CTW::P64;
           P64[Sp + 16] = Hp - 7;
           call Data.Bits.rotateR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.62337899 UTC

[section ""data" . Data.Bits.$dmshift_closure" {
     Data.Bits.$dmshift_closure:
         const Data.Bits.$dmshift_info;
 },
 Data.Bits.$dmshift_entry() //  [R2, R3, R4]
         { info_tbl: [(c1EDi,
                       label: Data.Bits.$dmshift_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EDi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1EDj; else goto c1EDk;
       c1EDj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmshift_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EDk: // global
           I64[Sp - 24] = block_c1EDf_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1EDG; else goto c1EDg;
       u1EDG: // global
           call _c1EDf(R1) args: 0, res: 0, upd: 0;
       c1EDg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EDf() //  [R1]
         { info_tbl: [(c1EDf,
                       label: block_c1EDf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EDf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EDp; else goto c1EDo;
       c1EDp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EDo: // global
           _s1CU4::P64 = P64[Sp + 8];
           _s1CU5::P64 = P64[Sp + 16];
           _s1CU8::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CU8::I64, 0)) goto c1EDz; else goto c1EDA;
       c1EDz: // global
           if (%MO_S_Le_W64(_s1CU8::I64, 0)) goto c1EDw; else goto c1EDx;
       c1EDw: // global
           Hp = Hp - 16;
           R1 = _s1CU5::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1EDx: // global
           Hp = Hp - 16;
           R2 = _s1CU4::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CU5::P64;
           P64[Sp + 16] = R1;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
       c1EDA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1CU8::I64;
           R2 = _s1CU4::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CU5::P64;
           P64[Sp + 16] = Hp - 7;
           call Data.Bits.shiftR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.62507873 UTC

[section ""data" . Data.Bits.bitDefault_closure" {
     Data.Bits.bitDefault_closure:
         const Data.Bits.bitDefault_info;
         const 0;
 },
 sat_s1CUg_entry() //  [R1]
         { info_tbl: [(c1EDP,
                       label: sat_s1CUg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EDP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EDQ; else goto c1EDR;
       c1EDQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EDR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.bitDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1EDS,
                       label: Data.Bits.bitDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EDS: // global
           _s1CUf::P64 = R4;
           _s1CUe::P64 = R3;
           _s1CUd::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1EDT; else goto c1EDU;
       c1EDU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1EDW; else goto c1EDV;
       c1EDW: // global
           HpAlloc = 24;
           goto c1EDT;
       c1EDT: // global
           R4 = _s1CUf::P64;
           R3 = _s1CUe::P64;
           R2 = _s1CUd::P64;
           R1 = Data.Bits.bitDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EDV: // global
           I64[Hp - 16] = sat_s1CUg_info;
           P64[Hp] = _s1CUe::P64;
           R2 = _s1CUd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1CUf::P64;
           Sp = Sp - 24;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.6270347 UTC

[section ""data" . Data.Bits.testBitDefault_closure" {
     Data.Bits.testBitDefault_closure:
         const Data.Bits.testBitDefault_info;
         const 0;
 },
 sat_s1CUo_entry() //  [R1]
         { info_tbl: [(c1EE5,
                       label: sat_s1CUo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EE5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EE6; else goto c1EE7;
       c1EE6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EE7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CUm_entry() //  [R1]
         { info_tbl: [(c1EEg,
                       label: sat_s1CUm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EEg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EEh; else goto c1EEi;
       c1EEh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EEi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CUn_entry() //  [R1]
         { info_tbl: [(c1EEj,
                       label: sat_s1CUn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EEj: // global
           _s1CUn::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1EEk; else goto c1EEl;
       c1EEl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1EEn; else goto c1EEm;
       c1EEn: // global
           HpAlloc = 32;
           goto c1EEk;
       c1EEk: // global
           R1 = _s1CUn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EEm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CUn::P64;
           _s1CUh::P64 = P64[_s1CUn::P64 + 16];
           _s1CUj::P64 = P64[_s1CUn::P64 + 24];
           _s1CUk::P64 = P64[_s1CUn::P64 + 32];
           I64[Hp - 24] = sat_s1CUm_info;
           P64[Hp - 8] = _s1CUh::P64;
           P64[Hp] = _s1CUk::P64;
           R2 = _s1CUh::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1CUj::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Data.Bits..&._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Bits.testBitDefault_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1EEq,
                       label: Data.Bits.testBitDefault_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EEq: // global
           _s1CUk::P64 = R5;
           _s1CUj::P64 = R4;
           _s1CUi::P64 = R3;
           _s1CUh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1EEr; else goto c1EEs;
       c1EEs: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1EEu; else goto c1EEt;
       c1EEu: // global
           HpAlloc = 64;
           goto c1EEr;
       c1EEr: // global
           R5 = _s1CUk::P64;
           R4 = _s1CUj::P64;
           R3 = _s1CUi::P64;
           R2 = _s1CUh::P64;
           R1 = Data.Bits.testBitDefault_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EEt: // global
           I64[Hp - 56] = sat_s1CUo_info;
           P64[Hp - 40] = _s1CUi::P64;
           I64[Hp - 32] = sat_s1CUn_info;
           P64[Hp - 16] = _s1CUh::P64;
           P64[Hp - 8] = _s1CUj::P64;
           P64[Hp] = _s1CUk::P64;
           I64[Sp - 24] = block_c1EEo_info;
           R2 = _s1CUh::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 24;
           call Data.Bits.$p1Bits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1EEo() //  [R1]
         { info_tbl: [(c1EEo,
                       label: block_c1EEo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EEo: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _c1EE1::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _c1EE1::P64;
           call GHC.Classes./=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.629181482 UTC

[section ""data" . Data.Bits.$fBitsInt2_closure" {
     Data.Bits.$fBitsInt2_closure:
         const GHC.Base.Just_con_info;
         const Data.Bits.$fBitsInt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.62997283 UTC

[section ""data" . Data.Bits.$fBitsWord_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsWord_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsWord_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsWord_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1EEC,
                       label: Data.Bits.$fBitsWord_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EEC: // global
           R1 = Data.Bits.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.631089002 UTC

[section ""data" . Data.Bits.$fBitsWord_$cbit_closure" {
     Data.Bits.$fBitsWord_$cbit_closure:
         const Data.Bits.$fBitsWord_$cbit_info;
 },
 Data.Bits.$fBitsWord_$cbit_entry() //  [R2]
         { info_tbl: [(c1EEM,
                       label: Data.Bits.$fBitsWord_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EEM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1EEN; else goto c1EEO;
       c1EEN: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EEO: // global
           I64[Sp - 8] = block_c1EEJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EF4; else goto c1EEK;
       u1EF4: // global
           call _c1EEJ(R1) args: 0, res: 0, upd: 0;
       c1EEK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EEJ() //  [R1]
         { info_tbl: [(c1EEJ,
                       label: block_c1EEJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EEJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EET; else goto c1EES;
       c1EET: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EES: // global
           _s1CUs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CUs::I64, 64)) goto c1EF2; else goto c1EF3;
       c1EF2: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = 1 << _s1CUs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EF3: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.633794913 UTC

[section ""data" . Data.Bits.$fBitsWord_$ctestBit_closure" {
     Data.Bits.$fBitsWord_$ctestBit_closure:
         const Data.Bits.$fBitsWord_$ctestBit_info;
 },
 Data.Bits.$fBitsWord_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1EFc,
                       label: Data.Bits.$fBitsWord_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EFc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EFg; else goto c1EFh;
       c1EFg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EFh: // global
           I64[Sp - 16] = block_c1EF9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EFN; else goto c1EFa;
       u1EFN: // global
           call _c1EF9(R1) args: 0, res: 0, upd: 0;
       c1EFa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EF9() //  [R1]
         { info_tbl: [(c1EF9,
                       label: block_c1EF9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EF9: // global
           I64[Sp] = block_c1EFf_info;
           _s1CUy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CUy::I64;
           if (R1 & 7 != 0) goto u1EFM; else goto c1EFj;
       u1EFM: // global
           call _c1EFf(R1) args: 0, res: 0, upd: 0;
       c1EFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EFf() //  [R1]
         { info_tbl: [(c1EFf,
                       label: block_c1EFf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EFf: // global
           _s1CUA::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CUA::I64, 64)) goto c1EFL; else goto c1EFK;
       c1EFK: // global
           if (I64[Sp + 8] & (1 << _s1CUA::I64) == 0) goto c1EFL; else goto c1EFz;
       c1EFL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EFz: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.635703724 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotateR_closure" {
     Data.Bits.$fBitsWord_$crotateR_closure:
         const Data.Bits.$fBitsWord_$crotateR_info;
 },
 Data.Bits.$fBitsWord_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1EFV,
                       label: Data.Bits.$fBitsWord_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EFV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1EFZ; else goto c1EG0;
       c1EFZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EG0: // global
           I64[Sp - 16] = block_c1EFS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EGH; else goto c1EFT;
       u1EGH: // global
           call _c1EFS(R1) args: 0, res: 0, upd: 0;
       c1EFT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EFS() //  [R1]
         { info_tbl: [(c1EFS,
                       label: block_c1EFS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EFS: // global
           I64[Sp - 8] = block_c1EFY_info;
           _s1CUG::P64 = R1;
           _s1CUH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CUH::I64;
           P64[Sp + 8] = _s1CUG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EGG; else goto c1EG2;
       u1EGG: // global
           call _c1EFY(R1) args: 0, res: 0, upd: 0;
       c1EG2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EFY() //  [R1]
         { info_tbl: [(c1EFY,
                       label: block_c1EFY_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EFY: // global
           _s1CUL::I64 = -I64[R1 + 7] & 63;
           if (_s1CUL::I64 != 0) goto u1EGE; else goto c1EGA;
       u1EGE: // global
           I64[Sp + 16] = _s1CUL::I64;
           Sp = Sp + 8;
           call _c1EGe() args: 0, res: 0, upd: 0;
       c1EGA: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1EGe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EGe: // global
           Hp = Hp + 16;
           _s1CUL::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1EGx; else goto c1EGw;
       c1EGx: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1EGd_info;
           R1 = _s1CUL::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1EGw: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           _s1CUH::I64 = I64[Sp];
           I64[Hp] = (_s1CUH::I64 << _s1CUL::I64) | (_s1CUH::I64 >> 64 - _s1CUL::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1EGd() //  [R1]
         { info_tbl: [(c1EGd,
                       label: block_c1EGd_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EGd: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1EGe() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.638019404 UTC

[section ""data" . Data.Bits.$fBitsWord_$ccomplementBit_closure" {
     Data.Bits.$fBitsWord_$ccomplementBit_closure:
         const Data.Bits.$fBitsWord_$ccomplementBit_info;
 },
 Data.Bits.$fBitsWord_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1EGR,
                       label: Data.Bits.$fBitsWord_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EGR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1EGV; else goto c1EGW;
       c1EGV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EGW: // global
           I64[Sp - 16] = block_c1EGO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EHj; else goto c1EGP;
       u1EHj: // global
           call _c1EGO(R1) args: 0, res: 0, upd: 0;
       c1EGP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EGO() //  [R1]
         { info_tbl: [(c1EGO,
                       label: block_c1EGO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EGO: // global
           I64[Sp - 8] = block_c1EGU_info;
           _s1CUS::P64 = R1;
           _s1CUT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CUT::I64;
           P64[Sp + 8] = _s1CUS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EHi; else goto c1EGY;
       u1EHi: // global
           call _c1EGU(R1) args: 0, res: 0, upd: 0;
       c1EGY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EGU() //  [R1]
         { info_tbl: [(c1EGU,
                       label: block_c1EGU_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EGU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EH4; else goto c1EH3;
       c1EH4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EH3: // global
           _s1CUV::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CUV::I64, 64)) goto c1EHg; else goto c1EHh;
       c1EHg: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s1CUV::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EHh: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.639909223 UTC

[section ""data" . Data.Bits.$fBitsWord_$cclearBit_closure" {
     Data.Bits.$fBitsWord_$cclearBit_closure:
         const Data.Bits.$fBitsWord_$cclearBit_info;
 },
 Data.Bits.$fBitsWord_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1EHr,
                       label: Data.Bits.$fBitsWord_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EHr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EHv; else goto c1EHw;
       c1EHv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EHw: // global
           I64[Sp - 16] = block_c1EHo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EI1; else goto c1EHp;
       u1EI1: // global
           call _c1EHo(R1) args: 0, res: 0, upd: 0;
       c1EHp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EHo() //  [R1]
         { info_tbl: [(c1EHo,
                       label: block_c1EHo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EHo: // global
           I64[Sp] = block_c1EHu_info;
           _s1CV2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CV2::I64;
           if (R1 & 7 != 0) goto u1EI0; else goto c1EHy;
       u1EI0: // global
           call _c1EHu(R1) args: 0, res: 0, upd: 0;
       c1EHy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EHu() //  [R1]
         { info_tbl: [(c1EHu,
                       label: block_c1EHu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EHu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EHE; else goto c1EHD;
       c1EHE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EHD: // global
           _s1CV2::I64 = I64[Sp + 8];
           _s1CV4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CV4::I64, 64)) goto c1EHT; else goto c1EHZ;
       c1EHT: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CV2::I64 & (1 << _s1CV4::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EHZ: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CV2::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.641859439 UTC

[section ""data" . Data.Bits.$fBitsWord_$csetBit_closure" {
     Data.Bits.$fBitsWord_$csetBit_closure:
         const Data.Bits.$fBitsWord_$csetBit_info;
 },
 Data.Bits.$fBitsWord_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1EI9,
                       label: Data.Bits.$fBitsWord_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EI9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1EId; else goto c1EIe;
       c1EId: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EIe: // global
           I64[Sp - 16] = block_c1EI6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EIB; else goto c1EI7;
       u1EIB: // global
           call _c1EI6(R1) args: 0, res: 0, upd: 0;
       c1EI7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EI6() //  [R1]
         { info_tbl: [(c1EI6,
                       label: block_c1EI6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EI6: // global
           I64[Sp - 8] = block_c1EIc_info;
           _s1CVc::P64 = R1;
           _s1CVd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CVd::I64;
           P64[Sp + 8] = _s1CVc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EIA; else goto c1EIg;
       u1EIA: // global
           call _c1EIc(R1) args: 0, res: 0, upd: 0;
       c1EIg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EIc() //  [R1]
         { info_tbl: [(c1EIc,
                       label: block_c1EIc_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EIc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EIm; else goto c1EIl;
       c1EIm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EIl: // global
           _s1CVf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVf::I64, 64)) goto c1EIy; else goto c1EIz;
       c1EIy: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s1CVf::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EIz: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.643442629 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotateL_closure" {
     Data.Bits.$fBitsWord_$crotateL_closure:
         const Data.Bits.$fBitsWord_$crotateL_info;
 },
 Data.Bits.$fBitsWord_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1EIG,
                       label: Data.Bits.$fBitsWord_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EIG: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsWord_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.644199261 UTC

[section ""data" . Data.Bits.$fBitsWord_closure" {
     Data.Bits.$fBitsWord_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqWord_closure;
         const Data.Bits.$fBitsWord_$c.&._closure+2;
         const Data.Bits.$fBitsWord_$c.|._closure+2;
         const Data.Bits.$fBitsWord_$cxor_closure+2;
         const Data.Bits.$fBitsWord_$ccomplement_closure+1;
         const Data.Bits.$fBitsWord_$cshift_closure+2;
         const Data.Bits.$fBitsWord_$crotate_closure+2;
         const Data.Bits.$fBitsWord1_closure+1;
         const Data.Bits.$fBitsWord_$cbit_closure+1;
         const Data.Bits.$fBitsWord_$csetBit_closure+2;
         const Data.Bits.$fBitsWord_$cclearBit_closure+2;
         const Data.Bits.$fBitsWord_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsWord_$ctestBit_closure+2;
         const Data.Bits.$fBitsWord_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsWord_$cfiniteBitSize_closure+1;
         const Data.Bits.$fBitsWord_$cisSigned_closure+1;
         const Data.Bits.$fBitsWord_$cshiftL_closure+2;
         const Data.Bits.$fBitsWord_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsWord_$cshiftR_closure+2;
         const Data.Bits.$fBitsWord_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsWord_$crotateL_closure+2;
         const Data.Bits.$fBitsWord_$crotateR_closure+2;
         const Data.Bits.$fBitsWord_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.645629582 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_closure" {
     Data.Bits.$fFiniteBitsWord_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsWord_closure+1;
         const Data.Bits.$fBitsWord_$cfiniteBitSize_closure+1;
         const Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure+1;
         const Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.646359059 UTC

[section ""data" . Data.Bits.$fBitsInt_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsInt_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsInt_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsInt_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1EIN,
                       label: Data.Bits.$fBitsInt_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EIN: // global
           R1 = Data.Bits.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.647182647 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotateL_closure" {
     Data.Bits.$fBitsInt_$crotateL_closure:
         const Data.Bits.$fBitsInt_$crotateL_info;
 },
 Data.Bits.$fBitsInt_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1EIU,
                       label: Data.Bits.$fBitsInt_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EIU: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInt_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.648416712 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotateR_closure" {
     Data.Bits.$fBitsInt_$crotateR_closure:
         const Data.Bits.$fBitsInt_$crotateR_info;
 },
 Data.Bits.$fBitsInt_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1EJ4,
                       label: Data.Bits.$fBitsInt_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EJ4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EJv; else goto c1EJw;
       c1EJv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EJw: // global
           I64[Sp - 16] = block_c1EJ1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EJC; else goto c1EJ2;
       u1EJC: // global
           call _c1EJ1(R1) args: 0, res: 0, upd: 0;
       c1EJ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EJ1() //  [R1]
         { info_tbl: [(c1EJ1,
                       label: block_c1EJ1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EJ1: // global
           I64[Sp] = block_c1EJ7_info;
           _s1CVn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CVn::I64;
           if (R1 & 7 != 0) goto u1EJB; else goto c1EJ8;
       u1EJB: // global
           call _c1EJ7(R1) args: 0, res: 0, upd: 0;
       c1EJ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EJ7() //  [R1]
         { info_tbl: [(c1EJ7,
                       label: block_c1EJ7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EJ7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EJA; else goto c1EJz;
       c1EJA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EJz: // global
           _s1CVq::I64 = -I64[R1 + 7] & 63;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _s1CVn::I64 = I64[Sp + 8];
           I64[Hp] = (_s1CVn::I64 << _s1CVq::I64) | (_s1CVn::I64 >> 64 - _s1CVq::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.650322321 UTC

[section ""data" . Data.Bits.$fBitsInt_$cbit_closure" {
     Data.Bits.$fBitsInt_$cbit_closure:
         const Data.Bits.$fBitsInt_$cbit_info;
 },
 Data.Bits.$fBitsInt_$cbit_entry() //  [R2]
         { info_tbl: [(c1EJK,
                       label: Data.Bits.$fBitsInt_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EJK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1EJL; else goto c1EJM;
       c1EJL: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EJM: // global
           I64[Sp - 8] = block_c1EJH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EK2; else goto c1EJI;
       u1EK2: // global
           call _c1EJH(R1) args: 0, res: 0, upd: 0;
       c1EJI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EJH() //  [R1]
         { info_tbl: [(c1EJH,
                       label: block_c1EJH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EJH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EJR; else goto c1EJQ;
       c1EJR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EJQ: // global
           _s1CVy::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVy::I64, 64)) goto c1EK0; else goto c1EK1;
       c1EK0: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = 1 << _s1CVy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EK1: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.651983526 UTC

[section ""data" . Data.Bits.$fBitsInt_$ctestBit_closure" {
     Data.Bits.$fBitsInt_$ctestBit_closure:
         const Data.Bits.$fBitsInt_$ctestBit_info;
 },
 Data.Bits.$fBitsInt_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1EKa,
                       label: Data.Bits.$fBitsInt_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EKa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EKe; else goto c1EKf;
       c1EKe: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EKf: // global
           I64[Sp - 16] = block_c1EK7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EKL; else goto c1EK8;
       u1EKL: // global
           call _c1EK7(R1) args: 0, res: 0, upd: 0;
       c1EK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EK7() //  [R1]
         { info_tbl: [(c1EK7,
                       label: block_c1EK7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EK7: // global
           I64[Sp] = block_c1EKd_info;
           _s1CVE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CVE::I64;
           if (R1 & 7 != 0) goto u1EKK; else goto c1EKh;
       u1EKK: // global
           call _c1EKd(R1) args: 0, res: 0, upd: 0;
       c1EKh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EKd() //  [R1]
         { info_tbl: [(c1EKd,
                       label: block_c1EKd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EKd: // global
           _s1CVG::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CVG::I64, 64)) goto c1EKJ; else goto c1EKI;
       c1EKI: // global
           if (I64[Sp + 8] & (1 << _s1CVG::I64) == 0) goto c1EKJ; else goto c1EKx;
       c1EKJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EKx: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.653875963 UTC

[section ""data" . Data.Bits.$fBitsInt_$csetBit_closure" {
     Data.Bits.$fBitsInt_$csetBit_closure:
         const Data.Bits.$fBitsInt_$csetBit_info;
 },
 Data.Bits.$fBitsInt_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1EKT,
                       label: Data.Bits.$fBitsInt_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EKT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1EKX; else goto c1EKY;
       c1EKX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EKY: // global
           I64[Sp - 16] = block_c1EKQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1ELl; else goto c1EKR;
       u1ELl: // global
           call _c1EKQ(R1) args: 0, res: 0, upd: 0;
       c1EKR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EKQ() //  [R1]
         { info_tbl: [(c1EKQ,
                       label: block_c1EKQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EKQ: // global
           I64[Sp - 8] = block_c1EKW_info;
           _s1CVM::P64 = R1;
           _s1CVN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CVN::I64;
           P64[Sp + 8] = _s1CVM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1ELk; else goto c1EL0;
       u1ELk: // global
           call _c1EKW(R1) args: 0, res: 0, upd: 0;
       c1EL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EKW() //  [R1]
         { info_tbl: [(c1EKW,
                       label: block_c1EKW_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EKW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EL6; else goto c1EL5;
       c1EL6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EL5: // global
           _s1CVP::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVP::I64, 64)) goto c1ELi; else goto c1ELj;
       c1ELi: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s1CVP::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ELj: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.655808692 UTC

[section ""data" . Data.Bits.$fBitsInt_$cclearBit_closure" {
     Data.Bits.$fBitsInt_$cclearBit_closure:
         const Data.Bits.$fBitsInt_$cclearBit_info;
 },
 Data.Bits.$fBitsInt_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1ELt,
                       label: Data.Bits.$fBitsInt_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ELt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1ELx; else goto c1ELy;
       c1ELx: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ELy: // global
           I64[Sp - 16] = block_c1ELq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EM3; else goto c1ELr;
       u1EM3: // global
           call _c1ELq(R1) args: 0, res: 0, upd: 0;
       c1ELr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ELq() //  [R1]
         { info_tbl: [(c1ELq,
                       label: block_c1ELq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ELq: // global
           I64[Sp] = block_c1ELw_info;
           _s1CVW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CVW::I64;
           if (R1 & 7 != 0) goto u1EM2; else goto c1ELA;
       u1EM2: // global
           call _c1ELw(R1) args: 0, res: 0, upd: 0;
       c1ELA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ELw() //  [R1]
         { info_tbl: [(c1ELw,
                       label: block_c1ELw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ELw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ELG; else goto c1ELF;
       c1ELG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ELF: // global
           _s1CVW::I64 = I64[Sp + 8];
           _s1CVY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVY::I64, 64)) goto c1ELV; else goto c1EM1;
       c1ELV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CVW::I64 & ~(1 << _s1CVY::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EM1: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CVW::I64 & (-1);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.658305493 UTC

[section ""data" . Data.Bits.$fBitsInt_$ccomplementBit_closure" {
     Data.Bits.$fBitsInt_$ccomplementBit_closure:
         const Data.Bits.$fBitsInt_$ccomplementBit_info;
 },
 Data.Bits.$fBitsInt_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1EMb,
                       label: Data.Bits.$fBitsInt_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EMb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1EMf; else goto c1EMg;
       c1EMf: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1EMg: // global
           I64[Sp - 16] = block_c1EM8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1EMD; else goto c1EM9;
       u1EMD: // global
           call _c1EM8(R1) args: 0, res: 0, upd: 0;
       c1EM9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EM8() //  [R1]
         { info_tbl: [(c1EM8,
                       label: block_c1EM8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EM8: // global
           I64[Sp - 8] = block_c1EMe_info;
           _s1CW6::P64 = R1;
           _s1CW7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CW7::I64;
           P64[Sp + 8] = _s1CW6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1EMC; else goto c1EMi;
       u1EMC: // global
           call _c1EMe(R1) args: 0, res: 0, upd: 0;
       c1EMi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EMe() //  [R1]
         { info_tbl: [(c1EMe,
                       label: block_c1EMe_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EMe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EMo; else goto c1EMn;
       c1EMo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EMn: // global
           _s1CW9::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CW9::I64, 64)) goto c1EMA; else goto c1EMB;
       c1EMA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s1CW9::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1EMB: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.659815486 UTC

[section ""data" . Data.Bits.$fBitsInt_closure" {
     Data.Bits.$fBitsInt_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqInt_closure;
         const Data.Bits.$fBitsInt_$c.&._closure+2;
         const Data.Bits.$fBitsInt_$c.|._closure+2;
         const Data.Bits.$fBitsInt_$cxor_closure+2;
         const Data.Bits.$fBitsInt_$ccomplement_closure+1;
         const Data.Bits.$fBitsInt_$cshift_closure+2;
         const Data.Bits.$fBitsInt_$crotate_closure+2;
         const Data.Bits.$fBitsBool2_closure+1;
         const Data.Bits.$fBitsInt_$cbit_closure+1;
         const Data.Bits.$fBitsInt_$csetBit_closure+2;
         const Data.Bits.$fBitsInt_$cclearBit_closure+2;
         const Data.Bits.$fBitsInt_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsInt_$ctestBit_closure+2;
         const Data.Bits.$fBitsInt_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsInt_$cfiniteBitSize_closure+1;
         const Data.Bits.$fBitsInt_$cisSigned_closure+1;
         const Data.Bits.$fBitsInt_$cshiftL_closure+2;
         const Data.Bits.$fBitsInt_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsInt_$cshiftR_closure+2;
         const Data.Bits.$fBitsInt_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsInt_$crotateL_closure+2;
         const Data.Bits.$fBitsInt_$crotateR_closure+2;
         const Data.Bits.$fBitsInt_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.660578983 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_closure" {
     Data.Bits.$fFiniteBitsInt_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsInt_closure+1;
         const Data.Bits.$fBitsInt_$cfiniteBitSize_closure+1;
         const Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure+1;
         const Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.662553095 UTC

[section ""data" . Data.Bits.$wpopCountDefault_closure" {
     Data.Bits.$wpopCountDefault_closure:
         const Data.Bits.$wpopCountDefault_info;
         const 0;
 },
 lvl1_s1CWg_entry() //  [R1]
         { info_tbl: [(c1EN2,
                       label: lvl1_s1CWg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EN2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EN3; else goto c1EN4;
       c1EN3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EN4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl2_s1CWh_entry() //  [R1]
         { info_tbl: [(c1EN7,
                       label: lvl2_s1CWh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EN7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EN8; else goto c1EN9;
       c1EN8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EN9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CWo_entry() //  [R1]
         { info_tbl: [(c1ENh,
                       label: sat_s1CWo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ENh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1ENi; else goto c1ENj;
       c1ENi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ENj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1CWp_entry() //  [R1]
         { info_tbl: [(c1ENk,
                       label: sat_s1CWp_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ENk: // global
           _s1CWp::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1ENl; else goto c1ENm;
       c1ENm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1ENo; else goto c1ENn;
       c1ENo: // global
           HpAlloc = 40;
           goto c1ENl;
       c1ENl: // global
           R1 = _s1CWp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ENn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CWp::P64;
           _s1CWd::P64 = P64[_s1CWp::P64 + 16];
           _s1CWe::P64 = P64[_s1CWp::P64 + 24];
           _s1CWg::P64 = P64[_s1CWp::P64 + 32];
           _s1CWl::P64 = P64[_s1CWp::P64 + 40];
           I64[Hp - 32] = sat_s1CWo_info;
           P64[Hp - 16] = _s1CWe::P64;
           P64[Hp - 8] = _s1CWg::P64;
           P64[Hp] = _s1CWl::P64;
           R2 = _s1CWd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1CWl::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call Data.Bits..&._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Bits.$wpopCountDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ENp,
                       label: Data.Bits.$wpopCountDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ENp: // global
           _s1CWf::P64 = R4;
           _s1CWe::P64 = R3;
           _s1CWd::P64 = R2;
           if ((Sp + -88) < SpLim) (likely: False) goto c1ENq; else goto c1ENr;
       c1ENr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1ENt; else goto c1ENs;
       c1ENt: // global
           HpAlloc = 48;
           goto c1ENq;
       c1ENq: // global
           R4 = _s1CWf::P64;
           R3 = _s1CWe::P64;
           R2 = _s1CWd::P64;
           R1 = Data.Bits.$wpopCountDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ENs: // global
           I64[Hp - 40] = lvl1_s1CWg_info;
           P64[Hp - 24] = _s1CWe::P64;
           I64[Hp - 16] = lvl2_s1CWh_info;
           P64[Hp] = _s1CWe::P64;
           I64[Sp - 48] = block_c1EMM_info;
           R2 = _s1CWd::P64;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _s1CWd::P64;
           P64[Sp - 16] = _s1CWe::P64;
           P64[Sp - 8] = _s1CWf::P64;
           Sp = Sp - 48;
           call Data.Bits.$p1Bits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1EMM() //  [R1]
         { info_tbl: [(c1EMM,
                       label: block_c1EMM_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EMM: // global
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp] = 0;
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call _c1EMS() args: 0, res: 0, upd: 0;
     }
 },
 _c1EMS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EMS: // global
           I64[Sp - 8] = block_c1EMV_info;
           R2 = P64[Sp + 48];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp];
           P64[Sp - 16] = P64[Sp + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1EMV() //  [R1]
         { info_tbl: [(c1EMV,
                       label: block_c1EMV_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EMV: // global
           _s1CWk::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c1ENx; else goto c1ENE;
       c1ENx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1ENA; else goto c1ENz;
       c1ENA: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ENz: // global
           I64[Hp - 40] = sat_s1CWp_info;
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 16] = _s1CWk::I64 + 1;
           P64[Sp + 8] = Hp - 40;
           Sp = Sp + 8;
           call _c1EMS() args: 0, res: 0, upd: 0;
       c1ENE: // global
           R1 = _s1CWk::I64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.665718937 UTC

[section ""data" . Data.Bits.popCountDefault_closure" {
     Data.Bits.popCountDefault_closure:
         const Data.Bits.popCountDefault_info;
         const 0;
 },
 Data.Bits.popCountDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ENR,
                       label: Data.Bits.popCountDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ENR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1ENV; else goto c1ENW;
       c1ENV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.popCountDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ENW: // global
           I64[Sp - 8] = block_c1ENP_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Bits.$wpopCountDefault_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ENP() //  [R1]
         { info_tbl: [(c1ENP,
                       label: block_c1ENP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ENP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ENZ; else goto c1ENY;
       c1ENZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1ENY: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.667100064 UTC

[section ""data" . Data.Bits.$fBitsInteger_closure" {
     Data.Bits.$fBitsInteger_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Integer.Type.$fEqInteger_closure;
         const GHC.Integer.Type.andInteger_closure+2;
         const GHC.Integer.Type.orInteger_closure+2;
         const GHC.Integer.Type.xorInteger_closure+2;
         const GHC.Integer.Type.complementInteger_closure+1;
         const Data.Bits.$fBitsInteger_$cshift_closure+2;
         const Data.Bits.$fBitsInteger_$cshift_closure+2;
         const Data.Bits.$fBitsInteger_$czeroBits_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure+1;
         const Data.Bits.$fBitsInteger_$csetBit_closure+2;
         const Data.Bits.$fBitsInteger_$cclearBit_closure+2;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsInteger_$ctestBit_closure+2;
         const Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsInteger_$cbitSize_closure+1;
         const Data.Bits.$fBitsInteger_$cisSigned_closure+1;
         const Data.Bits.$fBitsInteger_$cshiftL_closure+2;
         const Data.Bits.$fBitsInteger_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsInteger_$cshiftR_closure+2;
         const Data.Bits.$fBitsInteger_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsInteger_$crotateL_closure+2;
         const Data.Bits.$fBitsInteger_$crotateR_closure+2;
         const Data.Bits.$fBitsInteger_$cpopCount_closure+1;
         const 0;
 },
 section ""data" . Data.Bits.$fBitsInteger_$cpopCount_closure" {
     Data.Bits.$fBitsInteger_$cpopCount_closure:
         const Data.Bits.$fBitsInteger_$cpopCount_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1EO6,
                       label: Data.Bits.$fBitsInteger_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EO6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1EOa; else goto c1EOb;
       c1EOa: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1EOb: // global
           I64[Sp - 8] = block_c1EO4_info;
           R4 = R2;
           R3 = GHC.Num.$fNumInteger_closure;
           R2 = Data.Bits.$fBitsInteger_closure+1;
           Sp = Sp - 8;
           call Data.Bits.$wpopCountDefault_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1EO4() //  [R1]
         { info_tbl: [(c1EO4,
                       label: block_c1EO4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EO4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EOe; else goto c1EOd;
       c1EOe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1EOd: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.693500722 UTC

[section ""data" . Data.Bits.toIntegralSized_closure" {
     Data.Bits.toIntegralSized_closure:
         const Data.Bits.toIntegralSized_info;
         const 0;
 },
 sat_s1CWF_entry() //  [R1]
         { info_tbl: [(c1EOv,
                       label: sat_s1CWF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EOv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EOw; else goto c1EOx;
       c1EOw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EOx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 y_s1CWC_entry() //  [R1]
         { info_tbl: [(c1EOA,
                       label: y_s1CWC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EOA: // global
           _s1CWC::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1EOE; else goto c1EOF;
       c1EOF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1EOH; else goto c1EOG;
       c1EOH: // global
           HpAlloc = 32;
           goto c1EOE;
       c1EOE: // global
           R1 = _s1CWC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EOG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CWC::P64;
           _s1CWw::P64 = P64[_s1CWC::P64 + 16];
           _s1CWx::P64 = P64[_s1CWC::P64 + 24];
           _s1CWA::P64 = P64[_s1CWC::P64 + 32];
           I64[Hp - 24] = sat_s1CWF_info;
           P64[Hp - 8] = _s1CWw::P64;
           P64[Hp] = _s1CWA::P64;
           I64[Sp - 32] = block_c1EOy_info;
           R2 = _s1CWx::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1EOy() //  [R1]
         { info_tbl: [(c1EOy,
                       label: block_c1EOy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EOy: // global
           I64[Sp] = block_c1EOD_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1EOD() //  [R1]
         { info_tbl: [(c1EOD,
                       label: block_c1EOD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EOD: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 xSigned_s1CWI_entry() //  [R1]
         { info_tbl: [(c1EOZ,
                       label: xSigned_s1CWI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EOZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EP0; else goto c1EP1;
       c1EP0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EP1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.isSigned_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dReal_s1CWJ_entry() //  [R1]
         { info_tbl: [(c1EP6,
                       label: $dReal_s1CWJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EP6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EP7; else goto c1EP8;
       c1EP7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EP8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dNum_s1CWK_entry() //  [R1]
         { info_tbl: [(c1EPd,
                       label: $dNum_s1CWK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EPd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EPe; else goto c1EPf;
       c1EPe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EPf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dOrd_s1CWL_entry() //  [R1]
         { info_tbl: [(c1EPk,
                       label: $dOrd_s1CWL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EPk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1EPl; else goto c1EPm;
       c1EPl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EPm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1CX0_entry() //  [R1]
         { info_tbl: [(c1EQa,
                       label: sat_s1CX0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EQa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EQb; else goto c1EQc;
       c1EQb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EQc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CWZ_entry() //  [R1]
         { info_tbl: [(c1EQh,
                       label: sat_s1CWZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EQh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EQi; else goto c1EQj;
       c1EQi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EQj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CX1_entry() //  [R1]
         { info_tbl: [(c1EQk,
                       label: sat_s1CX1_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EQk: // global
           _s1CX1::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1EQl; else goto c1EQm;
       c1EQm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1EQo; else goto c1EQn;
       c1EQo: // global
           HpAlloc = 56;
           goto c1EQl;
       c1EQl: // global
           R1 = _s1CX1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EQn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CX1::P64;
           _s1CWy::P64 = P64[_s1CX1::P64 + 16];
           _s1CWK::P64 = P64[_s1CX1::P64 + 24];
           _s1CWX::P64 = P64[_s1CX1::P64 + 32];
           I64[Hp - 48] = sat_s1CX0_info;
           P64[Hp - 32] = _s1CWK::P64;
           I64[Hp - 24] = sat_s1CWZ_info;
           P64[Hp - 8] = _s1CWy::P64;
           P64[Hp] = _s1CWX::P64;
           R2 = _s1CWK::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1CX8_entry() //  [R1]
         { info_tbl: [(c1EQz,
                       label: sat_s1CX8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EQz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1EQA; else goto c1EQB;
       c1EQA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EQB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CX6_entry() //  [R1]
         { info_tbl: [(c1EQN,
                       label: sat_s1CX6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EQN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1EQU; else goto c1EQV;
       c1EQU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1EQV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1EQK_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1EQZ; else goto c1EQL;
       u1EQZ: // global
           call _c1EQK(R1) args: 0, res: 0, upd: 0;
       c1EQL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1EQK() //  [R1]
         { info_tbl: [(c1EQK,
                       label: block_c1EQK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EQK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EQY; else goto c1EQX;
       c1EQY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1EQX: // global
           _s1CX5::I64 = I64[R1 + 7] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CX5::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1CX7_entry() //  [R1]
         { info_tbl: [(c1ER0,
                       label: sat_s1CX7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ER0: // global
           _s1CX7::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1ER1; else goto c1ER2;
       c1ER2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ER4; else goto c1ER3;
       c1ER4: // global
           HpAlloc = 24;
           goto c1ER1;
       c1ER1: // global
           R1 = _s1CX7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ER3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CX7::P64;
           _s1CWy::P64 = P64[_s1CX7::P64 + 16];
           _s1CWX::P64 = P64[_s1CX7::P64 + 24];
           I64[Hp - 16] = sat_s1CX6_info;
           P64[Hp] = _s1CWX::P64;
           R2 = _s1CWy::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CX9_entry() //  [R1]
         { info_tbl: [(c1ER5,
                       label: sat_s1CX9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ER5: // global
           _s1CX9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1ER6; else goto c1ER7;
       c1ER7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1ER9; else goto c1ER8;
       c1ER9: // global
           HpAlloc = 56;
           goto c1ER6;
       c1ER6: // global
           R1 = _s1CX9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ER8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CX9::P64;
           _s1CWy::P64 = P64[_s1CX9::P64 + 16];
           _s1CWK::P64 = P64[_s1CX9::P64 + 24];
           _s1CWX::P64 = P64[_s1CX9::P64 + 32];
           I64[Hp - 48] = sat_s1CX8_info;
           P64[Hp - 32] = _s1CWK::P64;
           I64[Hp - 24] = sat_s1CX7_info;
           P64[Hp - 8] = _s1CWy::P64;
           P64[Hp] = _s1CWX::P64;
           R2 = _s1CWK::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1CYp_entry() //  [R1]
         { info_tbl: [(c1ES6,
                       label: sat_s1CYp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ES6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1ESd; else goto c1ESe;
       c1ESd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ESe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1ES3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1ESi; else goto c1ES4;
       u1ESi: // global
           call _c1ES3(R1) args: 0, res: 0, upd: 0;
       c1ES4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1ES3() //  [R1]
         { info_tbl: [(c1ES3,
                       label: block_c1ES3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ES3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ESh; else goto c1ESg;
       c1ESh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1ESg: // global
           _s1CYo::I64 = I64[R1 + 7] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CYo::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1CYq_entry() //  [R1]
         { info_tbl: [(c1ESj,
                       label: sat_s1CYq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ESj: // global
           _s1CYq::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1ESk; else goto c1ESl;
       c1ESl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1ESn; else goto c1ESm;
       c1ESn: // global
           HpAlloc = 24;
           goto c1ESk;
       c1ESk: // global
           R1 = _s1CYq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ESm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CYq::P64;
           _s1CWy::P64 = P64[_s1CYq::P64 + 16];
           _s1CYl::P64 = P64[_s1CYq::P64 + 24];
           I64[Hp - 16] = sat_s1CYp_info;
           P64[Hp] = _s1CYl::P64;
           R2 = _s1CWy::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CYr_entry() //  [R1]
         { info_tbl: [(c1ESo,
                       label: sat_s1CYr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ESo: // global
           _s1CYr::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1ESp; else goto c1ESq;
       c1ESq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1ESs; else goto c1ESr;
       c1ESs: // global
           HpAlloc = 32;
           goto c1ESp;
       c1ESp: // global
           R1 = _s1CYr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ESr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CYr::P64;
           _s1CWy::P64 = P64[_s1CYr::P64 + 16];
           _s1CWK::P64 = P64[_s1CYr::P64 + 24];
           _s1CYl::P64 = P64[_s1CYr::P64 + 32];
           I64[Hp - 24] = sat_s1CYq_info;
           P64[Hp - 8] = _s1CWy::P64;
           P64[Hp] = _s1CYl::P64;
           R2 = _s1CWK::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CYv_entry() //  [R1]
         { info_tbl: [(c1ESI,
                       label: sat_s1CYv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ESI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1ESJ; else goto c1ESK;
       c1ESJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1ESK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.toIntegralSized_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1ESL,
                       label: Data.Bits.toIntegralSized_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ESL: // global
           if ((Sp + -104) < SpLim) (likely: False) goto c1ESM; else goto c1ESN;
       c1ESM: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.toIntegralSized_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ESN: // global
           I64[Sp - 48] = block_c1EOj_info;
           _s1CWw::P64 = R2;
           R2 = R4;
           I64[Sp - 64] = stg_ap_p_info;
           P64[Sp - 56] = R6;
           P64[Sp - 40] = _s1CWw::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 64;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1EOj() //  [R1]
         { info_tbl: [(c1EOj,
                       label: block_c1EOj_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EOj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1ESQ; else goto c1ESP;
       c1ESQ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ESP: // global
           I64[Hp - 32] = y_s1CWC_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 40];
           I64[Sp - 8] = block_c1EON_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_p_info;
           _c1EOn::P64 = Hp - 32;
           P64[Sp - 16] = _c1EOn::P64;
           P64[Sp] = R1;
           P64[Sp + 16] = _c1EOn::P64;
           Sp = Sp - 24;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1EON() //  [R1]
         { info_tbl: [(c1EON,
                       label: block_c1EON_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EON: // global
           I64[Sp] = block_c1EOR_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 40] = R1;
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1EOR() //  [R1]
         { info_tbl: [(c1EOR,
                       label: block_c1EOR_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EOR: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1ESX; else goto c1ESW;
       c1ESX: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ESW: // global
           I64[Hp - 96] = xSigned_s1CWI_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 48];
           I64[Hp - 64] = $dReal_s1CWJ_info;
           P64[Hp - 48] = P64[Sp + 16];
           I64[Hp - 40] = $dNum_s1CWK_info;
           _c1EP2::P64 = Hp - 64;
           P64[Hp - 24] = _c1EP2::P64;
           I64[Hp - 16] = $dOrd_s1CWL_info;
           P64[Hp] = _c1EP2::P64;
           I64[Sp - 24] = block_c1ESU_info;
           _s1CWH::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1CWH::P64;
           P64[Sp] = Hp - 40;
           P64[Sp + 16] = Hp - 96;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1F8h; else goto c1F5q;
       u1F8h: // global
           call _c1ESU(R1) args: 0, res: 0, upd: 0;
       c1F5q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ESU() //  [R1]
         { info_tbl: [(c1ESU,
                       label: block_c1ESU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ESU: // global
           _s1CWH::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1F5x; else goto c1F5N;
       c1F5x: // global
           I64[Sp] = block_c1F5u_info;
           R1 = _s1CWH::P64;
           if (R1 & 7 != 0) goto u1F8r; else goto c1F5y;
       u1F8r: // global
           call _c1F5u(R1) args: 0, res: 0, upd: 0;
       c1F5y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1F5N: // global
           I64[Sp - 8] = block_c1F5L_info;
           _s1CZb::P64 = P64[R1 + 6];
           R1 = _s1CWH::P64;
           P64[Sp] = _s1CZb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1F8s; else goto c1F5O;
       u1F8s: // global
           call _c1F5L(R1) args: 0, res: 0, upd: 0;
       c1F5O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F5u() //  [R1]
         { info_tbl: [(c1F5u,
                       label: block_c1F5u_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F5u: // global
           if (R1 & 7 == 1) goto u1F7c; else goto u1F7d;
       u1F7c: // global
           Sp = Sp + 8;
           call _s1CZ4() args: 0, res: 0, upd: 0;
       u1F7d: // global
           Sp = Sp + 8;
           call _s1CY9() args: 0, res: 0, upd: 0;
     }
 },
 _c1F5L() //  [R1]
         { info_tbl: [(c1F5L,
                       label: block_c1F5L_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F5L: // global
           if (R1 & 7 == 1) goto u1F79; else goto c1F64;
       u1F79: // global
           Sp = Sp + 16;
           call _s1CY9() args: 0, res: 0, upd: 0;
       c1F64: // global
           I64[Sp] = block_c1F5X_info;
           _s1CZd::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CZd::P64;
           if (R1 & 7 != 0) goto u1Fa7; else goto c1F5Y;
       u1Fa7: // global
           call _c1F5X(R1) args: 0, res: 0, upd: 0;
       c1F5Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F5X() //  [R1]
         { info_tbl: [(c1F5X,
                       label: block_c1F5X_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F5X: // global
           I64[Sp] = block_c1F62_info;
           _s1CZf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CZf::I64;
           if (R1 & 7 != 0) goto u1Fa9; else goto c1F66;
       u1Fa9: // global
           call _c1F62(R1) args: 0, res: 0, upd: 0;
       c1F66: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F62() //  [R1]
         { info_tbl: [(c1F62,
                       label: block_c1F62_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F62: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u1F7a; else goto u1F7b;
       u1F7a: // global
           Sp = Sp + 16;
           call _s1CZ4() args: 0, res: 0, upd: 0;
       u1F7b: // global
           Sp = Sp + 16;
           call _s1CY9() args: 0, res: 0, upd: 0;
     }
 },
 _s1CZ4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CZ4: // global
           I64[Sp - 8] = block_c1F4P_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fas; else goto c1F4R;
       u1Fas: // global
           call _c1F4P(R1) args: 0, res: 0, upd: 0;
       c1F4R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F4P() //  [R1]
         { info_tbl: [(c1F4P,
                       label: block_c1F4P_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F4P: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1F4Y; else goto c1F5e;
       c1F4Y: // global
           I64[Sp] = block_c1F4V_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1F9Z; else goto c1F4Z;
       u1F9Z: // global
           call _c1F4V(R1) args: 0, res: 0, upd: 0;
       c1F4Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1F5e: // global
           I64[Sp] = block_c1F5c_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1Fa0; else goto c1F5f;
       u1Fa0: // global
           call _c1F5c(R1) args: 0, res: 0, upd: 0;
       c1F5f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F4V() //  [R1]
         { info_tbl: [(c1F4V,
                       label: block_c1F4V_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F4V: // global
           if (R1 & 7 == 1) goto u1F7g; else goto u1F7h;
       u1F7g: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       u1F7h: // global
           Sp = Sp + 8;
           call _s1CY9() args: 0, res: 0, upd: 0;
     }
 },
 _c1F5c() //  [R1]
         { info_tbl: [(c1F5c,
                       label: block_c1F5c_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F5c: // global
           if (R1 & 7 == 1) goto u1F7e; else goto u1F7f;
       u1F7e: // global
           Sp = Sp + 8;
           call _s1CY9() args: 0, res: 0, upd: 0;
       u1F7f: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CY9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CY9: // global
           I64[Sp - 8] = block_c1F0k_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fal; else goto c1F4p;
       u1Fal: // global
           call _c1F0k(R1) args: 0, res: 0, upd: 0;
       c1F4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F0k() //  [R1]
         { info_tbl: [(c1F0k,
                       label: block_c1F0k_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F0k: // global
           if (R1 & 7 == 1) goto u1F7i; else goto c1F4A;
       u1F7i: // global
           Sp = Sp + 8;
           call _s1CYb() args: 0, res: 0, upd: 0;
       c1F4A: // global
           I64[Sp] = block_c1F4y_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1F9n; else goto c1F4B;
       u1F9n: // global
           call _c1F4y(R1) args: 0, res: 0, upd: 0;
       c1F4B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F4y() //  [R1]
         { info_tbl: [(c1F4y,
                       label: block_c1F4y_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F4y: // global
           if (R1 & 7 == 1) goto u1F7j; else goto u1F7k;
       u1F7j: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       u1F7k: // global
           Sp = Sp + 8;
           call _s1CYb() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYb: // global
           I64[Sp - 8] = block_c1F0m_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fam; else goto c1F3Q;
       u1Fam: // global
           call _c1F0m(R1) args: 0, res: 0, upd: 0;
       c1F3Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F0m() //  [R1]
         { info_tbl: [(c1F0m,
                       label: block_c1F0m_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F0m: // global
           if (R1 & 7 == 1) goto c1F3X; else goto u1F7l;
       c1F3X: // global
           I64[Sp] = block_c1F3U_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1F9p; else goto c1F3Y;
       u1F9p: // global
           call _c1F3U(R1) args: 0, res: 0, upd: 0;
       c1F3Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1F7l: // global
           Sp = Sp + 8;
           call _s1CYd() args: 0, res: 0, upd: 0;
     }
 },
 _c1F3U() //  [R1]
         { info_tbl: [(c1F3U,
                       label: block_c1F3U_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F3U: // global
           if (R1 & 7 == 1) goto c1F45; else goto u1F7m;
       c1F45: // global
           I64[Sp] = block_c1F42_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1F9T; else goto c1F46;
       u1F9T: // global
           call _c1F42(R1) args: 0, res: 0, upd: 0;
       c1F46: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1F7m: // global
           Sp = Sp + 8;
           call _s1CYd() args: 0, res: 0, upd: 0;
     }
 },
 _c1F42() //  [R1]
         { info_tbl: [(c1F42,
                       label: block_c1F42_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F42: // global
           if (R1 & 7 == 1) goto u1F7n; else goto u1F7o;
       u1F7n: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       u1F7o: // global
           Sp = Sp + 8;
           call _s1CYd() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYd: // global
           I64[Sp - 8] = block_c1F0s_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fan; else goto c1F3h;
       u1Fan: // global
           call _c1F0s(R1) args: 0, res: 0, upd: 0;
       c1F3h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F0s() //  [R1]
         { info_tbl: [(c1F0s,
                       label: block_c1F0s_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F0s: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1F3o; else goto c1F3E;
       c1F3o: // global
           I64[Sp] = block_c1F3l_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1F9r; else goto c1F3p;
       u1F9r: // global
           call _c1F3l(R1) args: 0, res: 0, upd: 0;
       c1F3p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1F3E: // global
           I64[Sp] = block_c1F3C_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1F9s; else goto c1F3F;
       u1F9s: // global
           call _c1F3C(R1) args: 0, res: 0, upd: 0;
       c1F3F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F3l() //  [R1]
         { info_tbl: [(c1F3l,
                       label: block_c1F3l_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F3l: // global
           if (R1 & 7 == 1) goto u1F7r; else goto u1F7s;
       u1F7r: // global
           Sp = Sp + 8;
           call _s1CYK() args: 0, res: 0, upd: 0;
       u1F7s: // global
           Sp = Sp + 8;
           call _s1CYx() args: 0, res: 0, upd: 0;
     }
 },
 _c1F3C() //  [R1]
         { info_tbl: [(c1F3C,
                       label: block_c1F3C_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F3C: // global
           if (R1 & 7 == 1) goto u1F7p; else goto u1F7q;
       u1F7p: // global
           Sp = Sp + 8;
           call _s1CYx() args: 0, res: 0, upd: 0;
       u1F7q: // global
           Sp = Sp + 8;
           call _s1CYK() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYK: // global
           I64[Sp - 8] = block_c1F2B_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Far; else goto c1F2D;
       u1Far: // global
           call _c1F2B(R1) args: 0, res: 0, upd: 0;
       c1F2D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F2B() //  [R1]
         { info_tbl: [(c1F2B,
                       label: block_c1F2B_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F2B: // global
           if (R1 & 7 == 1) goto u1F7t; else goto c1F2O;
       u1F7t: // global
           Sp = Sp + 8;
           call _s1CYx() args: 0, res: 0, upd: 0;
       c1F2O: // global
           I64[Sp - 8] = block_c1F2M_info;
           _s1CYM::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CYM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1F9I; else goto c1F2P;
       u1F9I: // global
           call _c1F2M(R1) args: 0, res: 0, upd: 0;
       c1F2P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F2M() //  [R1]
         { info_tbl: [(c1F2M,
                       label: block_c1F2M_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F2M: // global
           if (R1 & 7 == 1) goto u1F7u; else goto c1F35;
       u1F7u: // global
           Sp = Sp + 16;
           call _s1CYx() args: 0, res: 0, upd: 0;
       c1F35: // global
           I64[Sp] = block_c1F2Y_info;
           _s1CYO::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CYO::P64;
           if (R1 & 7 != 0) goto u1F9K; else goto c1F2Z;
       u1F9K: // global
           call _c1F2Y(R1) args: 0, res: 0, upd: 0;
       c1F2Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _s1CYx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYx: // global
           I64[Sp - 8] = block_c1F1u_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Faq; else goto c1F1w;
       u1Faq: // global
           call _c1F1u(R1) args: 0, res: 0, upd: 0;
       c1F1w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F1u() //  [R1]
         { info_tbl: [(c1F1u,
                       label: block_c1F1u_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F1u: // global
           if (R1 & 7 == 1) goto c1F1D; else goto u1F7x;
       c1F1D: // global
           I64[Sp] = block_c1F1A_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1F9x; else goto c1F1E;
       u1F9x: // global
           call _c1F1A(R1) args: 0, res: 0, upd: 0;
       c1F1E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1F7x: // global
           Sp = Sp + 8;
           call _s1CYf() args: 0, res: 0, upd: 0;
     }
 },
 _c1F1A() //  [R1]
         { info_tbl: [(c1F1A,
                       label: block_c1F1A_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F1A: // global
           if (R1 & 7 == 1) goto u1F7y; else goto c1F1P;
       u1F7y: // global
           Sp = Sp + 8;
           call _s1CYf() args: 0, res: 0, upd: 0;
       c1F1P: // global
           I64[Sp] = block_c1F1N_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1F9z; else goto c1F1Q;
       u1F9z: // global
           call _c1F1N(R1) args: 0, res: 0, upd: 0;
       c1F1Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F1N() //  [R1]
         { info_tbl: [(c1F1N,
                       label: block_c1F1N_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F1N: // global
           if (R1 & 7 == 1) goto u1F7z; else goto c1F21;
       u1F7z: // global
           Sp = Sp + 8;
           call _s1CYf() args: 0, res: 0, upd: 0;
       c1F21: // global
           I64[Sp - 8] = block_c1F1Z_info;
           _s1CYC::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CYC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1F9B; else goto c1F22;
       u1F9B: // global
           call _c1F1Z(R1) args: 0, res: 0, upd: 0;
       c1F22: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F1Z() //  [R1]
         { info_tbl: [(c1F1Z,
                       label: block_c1F1Z_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F1Z: // global
           if (R1 & 7 == 1) goto u1F7A; else goto c1F2i;
       u1F7A: // global
           Sp = Sp + 16;
           call _s1CYf() args: 0, res: 0, upd: 0;
       c1F2i: // global
           I64[Sp] = block_c1F2b_info;
           _s1CYE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CYE::P64;
           if (R1 & 7 != 0) goto u1F9D; else goto c1F2c;
       u1F9D: // global
           call _c1F2b(R1) args: 0, res: 0, upd: 0;
       c1F2c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F2b() //  [R1]
         { info_tbl: [(c1F2b,
                       label: block_c1F2b_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F2b: // global
           I64[Sp] = block_c1F2g_info;
           _s1CYG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CYG::I64;
           if (R1 & 7 != 0) goto u1F9F; else goto c1F2k;
       u1F9F: // global
           call _c1F2g(R1) args: 0, res: 0, upd: 0;
       c1F2k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F2g() //  [R1]
         { info_tbl: [(c1F2g,
                       label: block_c1F2g_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F2g: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1F7C; else goto u1F7B;
       u1F7C: // global
           Sp = Sp + 16;
           call _s1CYf() args: 0, res: 0, upd: 0;
       u1F7B: // global
           Sp = Sp + 16;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _c1F2Y() //  [R1]
         { info_tbl: [(c1F2Y,
                       label: block_c1F2Y_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F2Y: // global
           I64[Sp] = block_c1F33_info;
           _s1CYQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CYQ::I64;
           if (R1 & 7 != 0) goto u1F9M; else goto c1F37;
       u1F9M: // global
           call _c1F33(R1) args: 0, res: 0, upd: 0;
       c1F37: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F33() //  [R1]
         { info_tbl: [(c1F33,
                       label: block_c1F33_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F33: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1F7w; else goto u1F7v;
       u1F7w: // global
           Sp = Sp + 16;
           call _s1CYf() args: 0, res: 0, upd: 0;
       u1F7v: // global
           Sp = Sp + 16;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYf: // global
           I64[Sp - 8] = block_c1ESt_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fao; else goto c1ESu;
       u1Fao: // global
           call _c1ESt(R1) args: 0, res: 0, upd: 0;
       c1ESu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ESt() //  [R1]
         { info_tbl: [(c1ESt,
                       label: block_c1ESt_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ESt: // global
           if (R1 & 7 == 1) goto u1F7D; else goto c1F16;
       u1F7D: // global
           Sp = Sp + 8;
           call _s1CYg() args: 0, res: 0, upd: 0;
       c1F16: // global
           I64[Sp] = block_c1ESz_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1F8o; else goto c1ESA;
       u1F8o: // global
           call _c1ESz(R1) args: 0, res: 0, upd: 0;
       c1ESA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ESz() //  [R1]
         { info_tbl: [(c1ESz,
                       label: block_c1ESz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ESz: // global
           if (R1 & 7 == 1) goto c1F19; else goto u1F7E;
       c1F19: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1F1c; else goto c1F1b;
       c1F1c: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1F1b: // global
           I64[Hp - 16] = sat_s1CYv_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1F17_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
       u1F7E: // global
           Sp = Sp + 8;
           call _s1CYg() args: 0, res: 0, upd: 0;
     }
 },
 _c1F17() //  [R1]
         { info_tbl: [(c1F17,
                       label: block_c1F17_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F17: // global
           if (R1 & 7 == 1) goto u1F7F; else goto u1F7G;
       u1F7F: // global
           Sp = Sp + 80;
           call _c1F1i() args: 0, res: 0, upd: 0;
       u1F7G: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYg: // global
           I64[Sp - 8] = block_c1ERz_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fap; else goto c1ERA;
       u1Fap: // global
           call _c1ERz(R1) args: 0, res: 0, upd: 0;
       c1ERA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ERz() //  [R1]
         { info_tbl: [(c1ERz,
                       label: block_c1ERz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ERz: // global
           if (R1 & 7 == 1) goto u1F7H; else goto c1F0B;
       u1F7H: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       c1F0B: // global
           I64[Sp] = block_c1ERF_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1F8j; else goto c1ERG;
       u1F8j: // global
           call _c1ERF(R1) args: 0, res: 0, upd: 0;
       c1ERG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ERF() //  [R1]
         { info_tbl: [(c1ERF,
                       label: block_c1ERF_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ERF: // global
           if (R1 & 7 == 1) goto u1F7I; else goto c1F0H;
       u1F7I: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       c1F0H: // global
           I64[Sp] = block_c1ERL_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1F8l; else goto c1ERM;
       u1F8l: // global
           call _c1ERL(R1) args: 0, res: 0, upd: 0;
       c1ERM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ERL() //  [R1]
         { info_tbl: [(c1ERL,
                       label: block_c1ERL_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ERL: // global
           if (R1 & 7 == 1) goto u1F7J; else goto c1F0N;
       u1F7J: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       c1F0N: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1F0Q; else goto c1F0P;
       c1F0Q: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1F0P: // global
           _s1CYl::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_s1CYr_info;
           P64[Hp - 16] = P64[Sp + 56];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s1CYl::P64;
           I64[Sp] = block_c1F0M_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1F0M() //  [R1]
         { info_tbl: [(c1F0M,
                       label: block_c1F0M_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F0M: // global
           if (R1 & 7 == 1) goto u1F7K; else goto u1F7L;
       u1F7K: // global
           Sp = Sp + 80;
           call _c1F1i() args: 0, res: 0, upd: 0;
       u1F7L: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWM: // global
           I64[Sp - 8] = block_c1ET0_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fac; else goto c1EZu;
       u1Fac: // global
           call _c1ET0(R1) args: 0, res: 0, upd: 0;
       c1EZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ET0() //  [R1]
         { info_tbl: [(c1ET0,
                       label: block_c1ET0_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ET0: // global
           _s1CWH::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1EZB; else goto c1EZR;
       c1EZB: // global
           I64[Sp] = block_c1EZy_info;
           R1 = _s1CWH::P64;
           if (R1 & 7 != 0) goto u1F8t; else goto c1EZC;
       u1F8t: // global
           call _c1EZy(R1) args: 0, res: 0, upd: 0;
       c1EZC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1EZR: // global
           I64[Sp - 8] = block_c1EZP_info;
           _s1CY1::P64 = P64[R1 + 6];
           R1 = _s1CWH::P64;
           P64[Sp] = _s1CY1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1F8u; else goto c1EZS;
       u1F8u: // global
           call _c1EZP(R1) args: 0, res: 0, upd: 0;
       c1EZS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EZy() //  [R1]
         { info_tbl: [(c1EZy,
                       label: block_c1EZy_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EZy: // global
           if (R1 & 7 == 1) goto u1F7P; else goto u1F7Q;
       u1F7P: // global
           Sp = Sp + 8;
           call _s1CXU() args: 0, res: 0, upd: 0;
       u1F7Q: // global
           Sp = Sp + 8;
           call _s1CWN() args: 0, res: 0, upd: 0;
     }
 },
 _c1EZP() //  [R1]
         { info_tbl: [(c1EZP,
                       label: block_c1EZP_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EZP: // global
           if (R1 & 7 == 1) goto u1F7M; else goto c1F08;
       u1F7M: // global
           Sp = Sp + 16;
           call _s1CWN() args: 0, res: 0, upd: 0;
       c1F08: // global
           I64[Sp] = block_c1F01_info;
           _s1CY3::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CY3::P64;
           if (R1 & 7 != 0) goto u1F9i; else goto c1F02;
       u1F9i: // global
           call _c1F01(R1) args: 0, res: 0, upd: 0;
       c1F02: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F01() //  [R1]
         { info_tbl: [(c1F01,
                       label: block_c1F01_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F01: // global
           I64[Sp] = block_c1F06_info;
           _s1CY5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CY5::I64;
           if (R1 & 7 != 0) goto u1F9k; else goto c1F0a;
       u1F9k: // global
           call _c1F06(R1) args: 0, res: 0, upd: 0;
       c1F0a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1F06() //  [R1]
         { info_tbl: [(c1F06,
                       label: block_c1F06_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F06: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u1F7N; else goto u1F7O;
       u1F7N: // global
           Sp = Sp + 16;
           call _s1CXU() args: 0, res: 0, upd: 0;
       u1F7O: // global
           Sp = Sp + 16;
           call _s1CWN() args: 0, res: 0, upd: 0;
     }
 },
 _s1CXU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CXU: // global
           I64[Sp - 8] = block_c1EYN_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fak; else goto c1EYP;
       u1Fak: // global
           call _c1EYN(R1) args: 0, res: 0, upd: 0;
       c1EYP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EYN() //  [R1]
         { info_tbl: [(c1EYN,
                       label: block_c1EYN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EYN: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1EYW; else goto c1EZf;
       c1EYW: // global
           I64[Sp] = block_c1EYT_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1F9c; else goto c1EYX;
       u1F9c: // global
           call _c1EYT(R1) args: 0, res: 0, upd: 0;
       c1EYX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1EZf: // global
           I64[Sp] = block_c1EZd_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1F9d; else goto c1EZg;
       u1F9d: // global
           call _c1EZd(R1) args: 0, res: 0, upd: 0;
       c1EZg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EYT() //  [R1]
         { info_tbl: [(c1EYT,
                       label: block_c1EYT_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EYT: // global
           if (R1 & 7 == 1) goto c1EZ3; else goto u1F7S;
       c1EZ3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EZ6; else goto c1EZ5;
       c1EZ6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EZ5: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1F7S: // global
           Sp = Sp + 8;
           call _s1CWN() args: 0, res: 0, upd: 0;
     }
 },
 _c1EZd() //  [R1]
         { info_tbl: [(c1EZd,
                       label: block_c1EZd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EZd: // global
           if (R1 & 7 == 1) goto u1F7R; else goto c1EZq;
       u1F7R: // global
           Sp = Sp + 8;
           call _s1CWN() args: 0, res: 0, upd: 0;
       c1EZq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EZt; else goto c1EZs;
       c1EZt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EZs: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1CWN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWN: // global
           I64[Sp - 8] = block_c1ET2_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fad; else goto c1EYk;
       u1Fad: // global
           call _c1ET2(R1) args: 0, res: 0, upd: 0;
       c1EYk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ET2() //  [R1]
         { info_tbl: [(c1ET2,
                       label: block_c1ET2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ET2: // global
           if (R1 & 7 == 1) goto u1F7T; else goto c1EYv;
       u1F7T: // global
           Sp = Sp + 8;
           call _s1CWP() args: 0, res: 0, upd: 0;
       c1EYv: // global
           I64[Sp] = block_c1EYt_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1F8v; else goto c1EYw;
       u1F8v: // global
           call _c1EYt(R1) args: 0, res: 0, upd: 0;
       c1EYw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EYt() //  [R1]
         { info_tbl: [(c1EYt,
                       label: block_c1EYt_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EYt: // global
           if (R1 & 7 == 1) goto c1EYC; else goto u1F7U;
       c1EYC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EYF; else goto c1EYE;
       c1EYF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EYE: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1F7U: // global
           Sp = Sp + 8;
           call _s1CWP() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWP: // global
           I64[Sp - 8] = block_c1ET4_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fae; else goto c1EXI;
       u1Fae: // global
           call _c1ET4(R1) args: 0, res: 0, upd: 0;
       c1EXI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ET4() //  [R1]
         { info_tbl: [(c1ET4,
                       label: block_c1ET4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ET4: // global
           if (R1 & 7 == 1) goto c1EXP; else goto u1F7V;
       c1EXP: // global
           I64[Sp] = block_c1EXM_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1F8x; else goto c1EXQ;
       u1F8x: // global
           call _c1EXM(R1) args: 0, res: 0, upd: 0;
       c1EXQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1F7V: // global
           Sp = Sp + 8;
           call _s1CWR() args: 0, res: 0, upd: 0;
     }
 },
 _c1EXM() //  [R1]
         { info_tbl: [(c1EXM,
                       label: block_c1EXM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EXM: // global
           if (R1 & 7 == 1) goto c1EXX; else goto u1F7W;
       c1EXX: // global
           I64[Sp] = block_c1EXU_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1F98; else goto c1EXY;
       u1F98: // global
           call _c1EXU(R1) args: 0, res: 0, upd: 0;
       c1EXY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1F7W: // global
           Sp = Sp + 8;
           call _s1CWR() args: 0, res: 0, upd: 0;
     }
 },
 _c1EXU() //  [R1]
         { info_tbl: [(c1EXU,
                       label: block_c1EXU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EXU: // global
           if (R1 & 7 == 1) goto c1EY4; else goto u1F7X;
       c1EY4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EY7; else goto c1EY6;
       c1EY7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EY6: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1F7X: // global
           Sp = Sp + 8;
           call _s1CWR() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWR: // global
           I64[Sp - 8] = block_c1ETa_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Faf; else goto c1EX9;
       u1Faf: // global
           call _c1ETa(R1) args: 0, res: 0, upd: 0;
       c1EX9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ETa() //  [R1]
         { info_tbl: [(c1ETa,
                       label: block_c1ETa_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ETa: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1EXg; else goto c1EXw;
       c1EXg: // global
           I64[Sp] = block_c1EXd_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1F8z; else goto c1EXh;
       u1F8z: // global
           call _c1EXd(R1) args: 0, res: 0, upd: 0;
       c1EXh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1EXw: // global
           I64[Sp] = block_c1EXu_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1F8A; else goto c1EXx;
       u1F8A: // global
           call _c1EXu(R1) args: 0, res: 0, upd: 0;
       c1EXx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EXd() //  [R1]
         { info_tbl: [(c1EXd,
                       label: block_c1EXd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EXd: // global
           if (R1 & 7 == 1) goto u1F80; else goto u1F81;
       u1F80: // global
           Sp = Sp + 8;
           call _s1CXA() args: 0, res: 0, upd: 0;
       u1F81: // global
           Sp = Sp + 8;
           call _s1CXn() args: 0, res: 0, upd: 0;
     }
 },
 _c1EXu() //  [R1]
         { info_tbl: [(c1EXu,
                       label: block_c1EXu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EXu: // global
           if (R1 & 7 == 1) goto u1F7Y; else goto u1F7Z;
       u1F7Y: // global
           Sp = Sp + 8;
           call _s1CXn() args: 0, res: 0, upd: 0;
       u1F7Z: // global
           Sp = Sp + 8;
           call _s1CXA() args: 0, res: 0, upd: 0;
     }
 },
 _s1CXA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CXA: // global
           I64[Sp - 8] = block_c1EWo_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Faj; else goto c1EWq;
       u1Faj: // global
           call _c1EWo(R1) args: 0, res: 0, upd: 0;
       c1EWq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EWo() //  [R1]
         { info_tbl: [(c1EWo,
                       label: block_c1EWo_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EWo: // global
           if (R1 & 7 == 1) goto u1F82; else goto c1EWB;
       u1F82: // global
           Sp = Sp + 8;
           call _s1CXn() args: 0, res: 0, upd: 0;
       c1EWB: // global
           I64[Sp - 8] = block_c1EWz_info;
           _s1CXC::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CXC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1F8X; else goto c1EWC;
       u1F8X: // global
           call _c1EWz(R1) args: 0, res: 0, upd: 0;
       c1EWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EWz() //  [R1]
         { info_tbl: [(c1EWz,
                       label: block_c1EWz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EWz: // global
           if (R1 & 7 == 1) goto u1F83; else goto c1EWS;
       u1F83: // global
           Sp = Sp + 16;
           call _s1CXn() args: 0, res: 0, upd: 0;
       c1EWS: // global
           I64[Sp] = block_c1EWL_info;
           _s1CXE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CXE::P64;
           if (R1 & 7 != 0) goto u1F8Z; else goto c1EWM;
       u1F8Z: // global
           call _c1EWL(R1) args: 0, res: 0, upd: 0;
       c1EWM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _s1CXn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CXn: // global
           I64[Sp - 8] = block_c1EVc_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fai; else goto c1EVe;
       u1Fai: // global
           call _c1EVc(R1) args: 0, res: 0, upd: 0;
       c1EVe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EVc() //  [R1]
         { info_tbl: [(c1EVc,
                       label: block_c1EVc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EVc: // global
           if (R1 & 7 == 1) goto c1EVl; else goto u1F85;
       c1EVl: // global
           I64[Sp] = block_c1EVi_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1F8N; else goto c1EVm;
       u1F8N: // global
           call _c1EVi(R1) args: 0, res: 0, upd: 0;
       c1EVm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1F85: // global
           Sp = Sp + 8;
           call _s1CWT() args: 0, res: 0, upd: 0;
     }
 },
 _c1EVi() //  [R1]
         { info_tbl: [(c1EVi,
                       label: block_c1EVi_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EVi: // global
           if (R1 & 7 == 1) goto u1F86; else goto c1EVx;
       u1F86: // global
           Sp = Sp + 8;
           call _s1CWT() args: 0, res: 0, upd: 0;
       c1EVx: // global
           I64[Sp] = block_c1EVv_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1F8P; else goto c1EVy;
       u1F8P: // global
           call _c1EVv(R1) args: 0, res: 0, upd: 0;
       c1EVy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EVv() //  [R1]
         { info_tbl: [(c1EVv,
                       label: block_c1EVv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EVv: // global
           if (R1 & 7 == 1) goto u1F87; else goto c1EVJ;
       u1F87: // global
           Sp = Sp + 8;
           call _s1CWT() args: 0, res: 0, upd: 0;
       c1EVJ: // global
           I64[Sp - 8] = block_c1EVH_info;
           _s1CXs::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CXs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1F8R; else goto c1EVK;
       u1F8R: // global
           call _c1EVH(R1) args: 0, res: 0, upd: 0;
       c1EVK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EVH() //  [R1]
         { info_tbl: [(c1EVH,
                       label: block_c1EVH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EVH: // global
           if (R1 & 7 == 1) goto u1F88; else goto c1EW0;
       u1F88: // global
           Sp = Sp + 16;
           call _s1CWT() args: 0, res: 0, upd: 0;
       c1EW0: // global
           I64[Sp] = block_c1EVT_info;
           _s1CXu::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CXu::P64;
           if (R1 & 7 != 0) goto u1F8T; else goto c1EVU;
       u1F8T: // global
           call _c1EVT(R1) args: 0, res: 0, upd: 0;
       c1EVU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EVT() //  [R1]
         { info_tbl: [(c1EVT,
                       label: block_c1EVT_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EVT: // global
           I64[Sp] = block_c1EVY_info;
           _s1CXw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CXw::I64;
           if (R1 & 7 != 0) goto u1F8V; else goto c1EW2;
       u1F8V: // global
           call _c1EVY(R1) args: 0, res: 0, upd: 0;
       c1EW2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EVY() //  [R1]
         { info_tbl: [(c1EVY,
                       label: block_c1EVY_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EVY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EW8; else goto c1EW7;
       c1EW8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EW7: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1F89; else goto c1EWg;
       u1F89: // global
           Sp = Sp + 16;
           call _c1EX4() args: 0, res: 0, upd: 0;
       c1EWg: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 6;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1EWL() //  [R1]
         { info_tbl: [(c1EWL,
                       label: block_c1EWL_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EWL: // global
           I64[Sp] = block_c1EWQ_info;
           _s1CXG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CXG::I64;
           if (R1 & 7 != 0) goto u1F91; else goto c1EWU;
       u1F91: // global
           call _c1EWQ(R1) args: 0, res: 0, upd: 0;
       c1EWU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EWQ() //  [R1]
         { info_tbl: [(c1EWQ,
                       label: block_c1EWQ_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EWQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EX0; else goto c1EWZ;
       c1EX0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EWZ: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1F84; else goto c1EX8;
       u1F84: // global
           Sp = Sp + 16;
           call _c1EX4() args: 0, res: 0, upd: 0;
       c1EX8: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 6;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1EX4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EX4: // global
           Hp = Hp - 16;
           call _s1CWT() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWT: // global
           I64[Sp - 8] = block_c1ETc_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fag; else goto c1ETZ;
       u1Fag: // global
           call _c1ETc(R1) args: 0, res: 0, upd: 0;
       c1ETZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ETc() //  [R1]
         { info_tbl: [(c1ETc,
                       label: block_c1ETc_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ETc: // global
           if (R1 & 7 == 1) goto u1F8a; else goto c1EUa;
       u1F8a: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1EUa: // global
           I64[Sp] = block_c1EU8_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1F8B; else goto c1EUb;
       u1F8B: // global
           call _c1EU8(R1) args: 0, res: 0, upd: 0;
       c1EUb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EU8() //  [R1]
         { info_tbl: [(c1EU8,
                       label: block_c1EU8_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EU8: // global
           if (R1 & 7 == 1) goto c1EUi; else goto u1F8b;
       c1EUi: // global
           I64[Sp] = block_c1EUf_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1F8F; else goto c1EUj;
       u1F8F: // global
           call _c1EUf(R1) args: 0, res: 0, upd: 0;
       c1EUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1F8b: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
     }
 },
 _c1EUf() //  [R1]
         { info_tbl: [(c1EUf,
                       label: block_c1EUf_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EUf: // global
           if (R1 & 7 == 1) goto u1F8c; else goto c1EUu;
       u1F8c: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1EUu: // global
           I64[Sp] = block_c1EUs_info;
           _s1CXe::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 40] = _s1CXe::P64;
           if (R1 & 7 != 0) goto u1F8H; else goto c1EUv;
       u1F8H: // global
           call _c1EUs(R1) args: 0, res: 0, upd: 0;
       c1EUv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EUs() //  [R1]
         { info_tbl: [(c1EUs,
                       label: block_c1EUs_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EUs: // global
           if (R1 & 7 == 1) goto u1F8d; else goto c1EUL;
       u1F8d: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1EUL: // global
           I64[Sp] = block_c1EUE_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u1F8J; else goto c1EUF;
       u1F8J: // global
           call _c1EUE(R1) args: 0, res: 0, upd: 0;
       c1EUF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EUE() //  [R1]
         { info_tbl: [(c1EUE,
                       label: block_c1EUE_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EUE: // global
           I64[Sp] = block_c1EUJ_info;
           _s1CXi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _s1CXi::I64;
           if (R1 & 7 != 0) goto u1F8L; else goto c1EUN;
       u1F8L: // global
           call _c1EUJ(R1) args: 0, res: 0, upd: 0;
       c1EUN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EUJ() //  [R1]
         { info_tbl: [(c1EUJ,
                       label: block_c1EUJ_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EUJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1EUT; else goto c1EUS;
       c1EUT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1EUS: // global
           if (%MO_S_Gt_W64(I64[R1 + 7],
                            I64[Sp + 40] + 1)) goto c1EV0; else goto c1EV4;
       c1EV0: // global
           Hp = Hp - 16;
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1EV4: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1CWU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWU: // global
           I64[Sp - 8] = block_c1EPR_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fah; else goto c1EPS;
       u1Fah: // global
           call _c1EPR(R1) args: 0, res: 0, upd: 0;
       c1EPS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EPR() //  [R1]
         { info_tbl: [(c1EPR,
                       label: block_c1EPR_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EPR: // global
           if (R1 & 7 == 1) goto c1ETi; else goto c1ETn;
       c1ETi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ETl; else goto c1ETk;
       c1ETl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ETk: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1ETn: // global
           I64[Sp] = block_c1EPX_info;
           _s1CWX::P64 = P64[R1 + 6];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s1CWX::P64;
           if (R1 & 7 != 0) goto u1F8i; else goto c1EPY;
       u1F8i: // global
           call _c1EPX(R1) args: 0, res: 0, upd: 0;
       c1EPY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1EPX() //  [R1]
         { info_tbl: [(c1EPX,
                       label: block_c1EPX_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1EPX: // global
           _c1EP9::P64 = P64[Sp + 24];
           _c1EPg::P64 = P64[Sp + 8];
           _s1CWy::P64 = P64[Sp + 56];
           _s1CWA::P64 = P64[Sp + 72];
           _s1CWX::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1ETq; else goto c1ETI;
       c1ETq: // global
           Hp = Hp + 40;
           _s1CWY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1ETL; else goto c1ETs;
       c1ETs: // global
           I64[Hp - 32] = sat_s1CX1_info;
           P64[Hp - 16] = _s1CWy::P64;
           P64[Hp - 8] = _c1EP9::P64;
           P64[Hp] = _s1CWX::P64;
           I64[Sp + 40] = block_c1ETo_info;
           R2 = _c1EPg::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _s1CWA::P64;
           P64[Sp + 32] = Hp - 32;
           Sp = Sp + 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
       c1ETI: // global
           Hp = Hp + 40;
           _s1CWY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1ETL; else goto c1ETK;
       c1ETL: // global
           HpAlloc = 40;
           R1 = _s1CWY::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ETK: // global
           I64[Hp - 32] = sat_s1CX9_info;
           P64[Hp - 16] = _s1CWy::P64;
           P64[Hp - 8] = _c1EP9::P64;
           P64[Hp] = _s1CWX::P64;
           I64[Sp + 40] = block_c1ETH_info;
           R2 = _c1EPg::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _s1CWA::P64;
           P64[Sp + 32] = Hp - 32;
           Sp = Sp + 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1ETo() //  [R1]
         { info_tbl: [(c1ETo,
                       label: block_c1ETo_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ETo: // global
           if (R1 & 7 == 1) goto u1F8g; else goto c1ETD;
       u1F8g: // global
           Sp = Sp + 40;
           call _c1F1i() args: 0, res: 0, upd: 0;
       c1ETD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ETG; else goto c1ETF;
       c1ETG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ETF: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1ETH() //  [R1]
         { info_tbl: [(c1ETH,
                       label: block_c1ETH_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ETH: // global
           if (R1 & 7 == 1) goto u1F8f; else goto c1ETV;
       u1F8f: // global
           Sp = Sp + 40;
           call _c1F1i() args: 0, res: 0, upd: 0;
       c1ETV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ETY; else goto c1ETX;
       c1ETY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1ETX: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1F1i() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1F1i: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.724886814 UTC

[section ""cstring" . Data.Bits.$trModule4_bytes" {
     Data.Bits.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.725579397 UTC

[section ""data" . Data.Bits.$trModule3_closure" {
     Data.Bits.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.726167444 UTC

[section ""cstring" . Data.Bits.$trModule2_bytes" {
     Data.Bits.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.726747864 UTC

[section ""data" . Data.Bits.$trModule1_closure" {
     Data.Bits.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.727298511 UTC

[section ""data" . Data.Bits.$trModule_closure" {
     Data.Bits.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bits.$trModule3_closure+1;
         const Data.Bits.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.72830453 UTC

[section ""data" . $krep_r1CDE_closure" {
     $krep_r1CDE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.728908236 UTC

[section ""data" . $krep1_r1CDF_closure" {
     $krep1_r1CDF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.72956007 UTC

[section ""data" . $krep2_r1CDG_closure" {
     $krep2_r1CDG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.730133368 UTC

[section ""data" . $krep3_r1CDH_closure" {
     $krep3_r1CDH_closure:
         const :_con_info;
         const $krep1_r1CDF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.730720776 UTC

[section ""data" . $krep4_r1CDI_closure" {
     $krep4_r1CDI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep3_r1CDH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.731274215 UTC

[section ""data" . $krep5_r1CDJ_closure" {
     $krep5_r1CDJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1CDF_closure+1;
         const $krep_r1CDE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.731829592 UTC

[section ""data" . Data.Bits.$tcBits1_closure" {
     Data.Bits.$tcBits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep2_r1CDG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.732393723 UTC

[section ""data" . $krep6_r1CDK_closure" {
     $krep6_r1CDK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.732984353 UTC

[section ""data" . $krep7_r1CDL_closure" {
     $krep7_r1CDL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep6_r1CDK_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.733606082 UTC

[section ""data" . $krep8_r1CDM_closure" {
     $krep8_r1CDM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep7_r1CDL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.734200167 UTC

[section ""data" . $krep9_r1CDN_closure" {
     $krep9_r1CDN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep5_r1CDJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.734793926 UTC

[section ""data" . $krep10_r1CDO_closure" {
     $krep10_r1CDO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep4_r1CDI_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.735402005 UTC

[section ""data" . $krep11_r1CDP_closure" {
     $krep11_r1CDP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep1_r1CDF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.73600598 UTC

[section ""data" . $krep12_r1CDQ_closure" {
     $krep12_r1CDQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep_r1CDE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.736608405 UTC

[section ""data" . $krep13_r1CDR_closure" {
     $krep13_r1CDR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1CDF_closure+1;
         const $krep6_r1CDK_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.737738568 UTC

[section ""data" . $krep14_r1CDS_closure" {
     $krep14_r1CDS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep13_r1CDR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.738340086 UTC

[section ""data" . $krep15_r1CDT_closure" {
     $krep15_r1CDT_closure:
         const :_con_info;
         const $krep6_r1CDK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.73896195 UTC

[section ""data" . $krep16_r1CDU_closure" {
     $krep16_r1CDU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Classes.$tcEq_closure;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.739514391 UTC

[section ""cstring" . Data.Bits.$tcBits3_bytes" {
     Data.Bits.$tcBits3_bytes:
         I8[] [66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.740068902 UTC

[section ""data" . Data.Bits.$tcBits2_closure" {
     Data.Bits.$tcBits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tcBits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.740689988 UTC

[section ""data" . Data.Bits.$tcBits_closure" {
     Data.Bits.$tcBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tcBits2_closure+1;
         const Data.Bits.$tcBits1_closure+4;
         const 7088815172979416363;
         const 4990916430057605838;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.741442357 UTC

[section ""data" . $krep17_r1CDV_closure" {
     $krep17_r1CDV_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Bits.$tcBits_closure+1;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.742120277 UTC

[section ""data" . $krep18_r1CDW_closure" {
     $krep18_r1CDW_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep17_r1CDV_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.742716242 UTC

[section ""data" . $krep19_r1CDX_closure" {
     $krep19_r1CDX_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep18_r1CDW_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.743306493 UTC

[section ""data" . $krep20_r1CDY_closure" {
     $krep20_r1CDY_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep19_r1CDX_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.743902982 UTC

[section ""data" . $krep21_r1CDZ_closure" {
     $krep21_r1CDZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep20_r1CDY_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.744495677 UTC

[section ""data" . $krep22_r1CE0_closure" {
     $krep22_r1CE0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep21_r1CDZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.745114714 UTC

[section ""data" . $krep23_r1CE1_closure" {
     $krep23_r1CE1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep22_r1CE0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.745759514 UTC

[section ""data" . $krep24_r1CE2_closure" {
     $krep24_r1CE2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep23_r1CE1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.746705267 UTC

[section ""data" . $krep25_r1CE3_closure" {
     $krep25_r1CE3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r1CDQ_closure+4;
         const $krep24_r1CE2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.747270629 UTC

[section ""data" . $krep26_r1CE4_closure" {
     $krep26_r1CE4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep25_r1CE3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.747886496 UTC

[section ""data" . $krep27_r1CE5_closure" {
     $krep27_r1CE5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1CDO_closure+4;
         const $krep26_r1CE4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.748467009 UTC

[section ""data" . $krep28_r1CE6_closure" {
     $krep28_r1CE6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r1CDN_closure+4;
         const $krep27_r1CE5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.749045929 UTC

[section ""data" . $krep29_r1CE7_closure" {
     $krep29_r1CE7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep28_r1CE6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.749655831 UTC

[section ""data" . $krep30_r1CE8_closure" {
     $krep30_r1CE8_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep29_r1CE7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.75022987 UTC

[section ""data" . $krep31_r1CE9_closure" {
     $krep31_r1CE9_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep30_r1CE8_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.750792829 UTC

[section ""data" . $krep32_r1CEa_closure" {
     $krep32_r1CEa_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_r1CDR_closure+4;
         const $krep31_r1CE9_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.751383108 UTC

[section ""data" . $krep33_r1CEb_closure" {
     $krep33_r1CEb_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep32_r1CEa_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.751981091 UTC

[section ""data" . $krep34_r1CEc_closure" {
     $krep34_r1CEc_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep33_r1CEb_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.752555991 UTC

[section ""data" . $krep35_r1CEd_closure" {
     $krep35_r1CEd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep34_r1CEc_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.75315971 UTC

[section ""data" . $krep36_r1CEe_closure" {
     $krep36_r1CEe_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1CDL_closure+4;
         const $krep35_r1CEd_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.75376617 UTC

[section ""data" . $krep37_r1CEf_closure" {
     $krep37_r1CEf_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep36_r1CEe_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.754361943 UTC

[section ""data" . $krep38_r1CEg_closure" {
     $krep38_r1CEg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep37_r1CEf_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.755362121 UTC

[section ""data" . $krep39_r1CEh_closure" {
     $krep39_r1CEh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep38_r1CEg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.755931264 UTC

[section ""data" . Data.Bits.$tc'C:Bits1_closure" {
     Data.Bits.$tc'C:Bits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r1CDU_closure+1;
         const $krep39_r1CEh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.756446934 UTC

[section ""cstring" . Data.Bits.$tc'C:Bits3_bytes" {
     Data.Bits.$tc'C:Bits3_bytes:
         I8[] [39,67,58,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.757002199 UTC

[section ""data" . Data.Bits.$tc'C:Bits2_closure" {
     Data.Bits.$tc'C:Bits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tc'C:Bits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.758071543 UTC

[section ""data" . Data.Bits.$tc'C:Bits_closure" {
     Data.Bits.$tc'C:Bits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tc'C:Bits2_closure+1;
         const Data.Bits.$tc'C:Bits1_closure+4;
         const 744071653035646959;
         const 2574978498160477882;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.758641713 UTC

[section ""cstring" . Data.Bits.$tcFiniteBits2_bytes" {
     Data.Bits.$tcFiniteBits2_bytes:
         I8[] [70,105,110,105,116,101,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.759173845 UTC

[section ""data" . Data.Bits.$tcFiniteBits1_closure" {
     Data.Bits.$tcFiniteBits1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tcFiniteBits2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.759743791 UTC

[section ""data" . Data.Bits.$tcFiniteBits_closure" {
     Data.Bits.$tcFiniteBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tcFiniteBits1_closure+1;
         const Data.Bits.$tcBits1_closure+4;
         const 2363162769622202131;
         const 10110405838341883172;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.760345557 UTC

[section ""data" . $krep40_r1CEi_closure" {
     $krep40_r1CEi_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Bits.$tcFiniteBits_closure+1;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.760953579 UTC

[section ""data" . $krep41_r1CEj_closure" {
     $krep41_r1CEj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep40_r1CEi_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.761593425 UTC

[section ""data" . $krep42_r1CEk_closure" {
     $krep42_r1CEk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep41_r1CEj_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.762144272 UTC

[section ""data" . $krep43_r1CEl_closure" {
     $krep43_r1CEl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep42_r1CEk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.762728581 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits1_closure" {
     Data.Bits.$tc'C:FiniteBits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_r1CDV_closure+1;
         const $krep43_r1CEl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.76334376 UTC

[section ""cstring" . Data.Bits.$tc'C:FiniteBits3_bytes" {
     Data.Bits.$tc'C:FiniteBits3_bytes:
         I8[] [39,67,58,70,105,110,105,116,101,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.763914214 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits2_closure" {
     Data.Bits.$tc'C:FiniteBits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tc'C:FiniteBits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.76488913 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits_closure" {
     Data.Bits.$tc'C:FiniteBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tc'C:FiniteBits2_closure+1;
         const Data.Bits.$tc'C:FiniteBits1_closure+4;
         const 7500562306525175158;
         const 16051895206261500648;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.765927295 UTC

[section ""data" . Data.Bits.C:FiniteBits_closure" {
     Data.Bits.C:FiniteBits_closure:
         const Data.Bits.C:FiniteBits_info;
 },
 Data.Bits.C:FiniteBits_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1Fay,
                       label: Data.Bits.C:FiniteBits_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fay: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1FaC; else goto c1FaB;
       c1FaC: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.C:FiniteBits_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FaB: // global
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.767465591 UTC

[section ""data" . Data.Bits.C:Bits_closure" {
     Data.Bits.C:Bits_closure:
         const Data.Bits.C:Bits_info;
 },
 Data.Bits.C:Bits_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FaE: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Bits.C:Bits_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2,
                                       R1) args: 152, res: 0, upd: 8;
     }
 },
 Data.Bits.C:Bits_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1FaJ,
                       label: Data.Bits.C:Bits_info
                       rep:HeapRep static {
                             Fun {arity: 23
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FaJ: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c1FaN; else goto c1FaM;
       c1FaN: // global
           HpAlloc = 192;
           R1 = Data.Bits.C:Bits_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 192, res: 0, upd: 8;
       c1FaM: // global
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           P64[Hp - 152] = R5;
           P64[Hp - 144] = R6;
           P64[Hp - 136] = P64[Sp];
           P64[Hp - 128] = P64[Sp + 8];
           P64[Hp - 120] = P64[Sp + 16];
           P64[Hp - 112] = P64[Sp + 24];
           P64[Hp - 104] = P64[Sp + 32];
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 48];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 72];
           P64[Hp - 56] = P64[Sp + 80];
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = P64[Sp + 96];
           P64[Hp - 32] = P64[Sp + 104];
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = P64[Sp + 136];
           R1 = Hp - 183;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.768893858 UTC

[Data.Bits.C:FiniteBits_con_entry() //  [R1]
         { info_tbl: [(c1FaO,
                       label: Data.Bits.C:FiniteBits_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,115,46,67,58,70,105,110,105,116,101,66,105,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FaO: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.770006907 UTC

[Data.Bits.C:Bits_con_entry() //  [R1]
         { info_tbl: [(c1FaQ,
                       label: Data.Bits.C:Bits_con_info
                       rep:HeapRep 23 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,115,46,67,58,66,105,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FaQ: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.770940962 UTC

[section ""relreadonly" . S1D79_srt" {
     S1D79_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Bits.$fBitsInteger1_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const Data.Bits.$fBitsInteger_$cshift_closure;
         const Data.Bits.$w$cshift_closure;
         const sat_s1COy_closure;
         const Data.Bits.$fBitsInteger3_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure;
         const GHC.Integer.Type.complementInteger_closure;
         const Data.Bits.$fBitsInteger_$cclearBit_closure;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure;
         const Data.Bits.$fBitsInteger_$csetBit_closure;
         const Data.Bits.$fBitsInteger_$cshiftR_closure;
         const Data.Bits.$fBitsInteger_$crotateR_closure;
         const Data.Bits.bitDefault_closure;
         const Data.Bits.$fBitsInteger_$czeroBits_closure;
         const Data.Bits.testBitDefault_closure;
         const Data.Bits.$wpopCountDefault_closure;
         const Data.Bits.popCountDefault_closure;
         const GHC.Num.$fNumInteger_closure;
         const Data.Bits.$fBitsInteger_closure;
         const Data.Bits.$fBitsInteger_$cpopCount_closure;
         const Data.Bits.toIntegralSized_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.77185347 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:23.773447798 UTC

[section ""data" . Data.Bits.$p1FiniteBits_closure" {
     Data.Bits.$p1FiniteBits_closure:
         const Data.Bits.$p1FiniteBits_info;
 },
 Data.Bits.$p1FiniteBits_entry() //  [R2]
         { info_tbl: [(c1FaZ,
                       label: Data.Bits.$p1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FaZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fb0; else goto c1Fb1;
       c1Fb0: // global
           R2 = R2;
           R1 = Data.Bits.$p1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fb1: // global
           I64[Sp - 8] = block_c1FaW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fb5; else goto c1FaX;
       u1Fb5: // global
           call _c1FaW(R1) args: 0, res: 0, upd: 0;
       c1FaX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FaW() //  [R1]
         { info_tbl: [(c1FaW,
                       label: block_c1FaW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FaW: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.779989685 UTC

[section ""data" . Data.Bits.finiteBitSize_closure" {
     Data.Bits.finiteBitSize_closure:
         const Data.Bits.finiteBitSize_info;
 },
 Data.Bits.finiteBitSize_entry() //  [R2]
         { info_tbl: [(c1Fbo,
                       label: Data.Bits.finiteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fbo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fbp; else goto c1Fbq;
       c1Fbp: // global
           R2 = R2;
           R1 = Data.Bits.finiteBitSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fbq: // global
           I64[Sp - 8] = block_c1Fbl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fbu; else goto c1Fbm;
       u1Fbu: // global
           call _c1Fbl(R1) args: 0, res: 0, upd: 0;
       c1Fbm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fbl() //  [R1]
         { info_tbl: [(c1Fbl,
                       label: block_c1Fbl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fbl: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.786360968 UTC

[section ""data" . Data.Bits.countLeadingZeros_closure" {
     Data.Bits.countLeadingZeros_closure:
         const Data.Bits.countLeadingZeros_info;
 },
 Data.Bits.countLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1FbL,
                       label: Data.Bits.countLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FbL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FbM; else goto c1FbN;
       c1FbM: // global
           R2 = R2;
           R1 = Data.Bits.countLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FbN: // global
           I64[Sp - 8] = block_c1FbI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FbR; else goto c1FbJ;
       u1FbR: // global
           call _c1FbI(R1) args: 0, res: 0, upd: 0;
       c1FbJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FbI() //  [R1]
         { info_tbl: [(c1FbI,
                       label: block_c1FbI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FbI: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.791977669 UTC

[section ""data" . Data.Bits.countTrailingZeros_closure" {
     Data.Bits.countTrailingZeros_closure:
         const Data.Bits.countTrailingZeros_info;
 },
 Data.Bits.countTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1Fc8,
                       label: Data.Bits.countTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fc8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fc9; else goto c1Fca;
       c1Fc9: // global
           R2 = R2;
           R1 = Data.Bits.countTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fca: // global
           I64[Sp - 8] = block_c1Fc5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fce; else goto c1Fc6;
       u1Fce: // global
           call _c1Fc5(R1) args: 0, res: 0, upd: 0;
       c1Fc6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fc5() //  [R1]
         { info_tbl: [(c1Fc5,
                       label: block_c1Fc5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fc5: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.798048676 UTC

[section ""data" . Data.Bits.$p1Bits_closure" {
     Data.Bits.$p1Bits_closure:
         const Data.Bits.$p1Bits_info;
 },
 Data.Bits.$p1Bits_entry() //  [R2]
         { info_tbl: [(c1Fcv,
                       label: Data.Bits.$p1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fcv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fcw; else goto c1Fcx;
       c1Fcw: // global
           R2 = R2;
           R1 = Data.Bits.$p1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fcx: // global
           I64[Sp - 8] = block_c1Fcs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FcB; else goto c1Fct;
       u1FcB: // global
           call _c1Fcs(R1) args: 0, res: 0, upd: 0;
       c1Fct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fcs() //  [R1]
         { info_tbl: [(c1Fcs,
                       label: block_c1Fcs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fcs: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.803624619 UTC

[section ""data" . Data.Bits..&._closure" {
     Data.Bits..&._closure:
         const Data.Bits..&._info;
 },
 Data.Bits..&._entry() //  [R2]
         { info_tbl: [(c1FcU,
                       label: Data.Bits..&._info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FcU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FcV; else goto c1FcW;
       c1FcV: // global
           R2 = R2;
           R1 = Data.Bits..&._closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FcW: // global
           I64[Sp - 8] = block_c1FcR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fd0; else goto c1FcS;
       u1Fd0: // global
           call _c1FcR(R1) args: 0, res: 0, upd: 0;
       c1FcS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FcR() //  [R1]
         { info_tbl: [(c1FcR,
                       label: block_c1FcR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FcR: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.809470518 UTC

[section ""data" . Data.Bits..|._closure" {
     Data.Bits..|._closure:
         const Data.Bits..|._info;
 },
 Data.Bits..|._entry() //  [R2]
         { info_tbl: [(c1Fdh,
                       label: Data.Bits..|._info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fdh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fdi; else goto c1Fdj;
       c1Fdi: // global
           R2 = R2;
           R1 = Data.Bits..|._closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fdj: // global
           I64[Sp - 8] = block_c1Fde_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fdn; else goto c1Fdf;
       u1Fdn: // global
           call _c1Fde(R1) args: 0, res: 0, upd: 0;
       c1Fdf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fde() //  [R1]
         { info_tbl: [(c1Fde,
                       label: block_c1Fde_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fde: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.815184201 UTC

[section ""data" . Data.Bits.xor_closure" {
     Data.Bits.xor_closure:
         const Data.Bits.xor_info;
 },
 Data.Bits.xor_entry() //  [R2]
         { info_tbl: [(c1FdE,
                       label: Data.Bits.xor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FdE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FdF; else goto c1FdG;
       c1FdF: // global
           R2 = R2;
           R1 = Data.Bits.xor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FdG: // global
           I64[Sp - 8] = block_c1FdB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FdK; else goto c1FdC;
       u1FdK: // global
           call _c1FdB(R1) args: 0, res: 0, upd: 0;
       c1FdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FdB() //  [R1]
         { info_tbl: [(c1FdB,
                       label: block_c1FdB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FdB: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.821091862 UTC

[section ""data" . Data.Bits.complement_closure" {
     Data.Bits.complement_closure:
         const Data.Bits.complement_info;
 },
 Data.Bits.complement_entry() //  [R2]
         { info_tbl: [(c1Fe1,
                       label: Data.Bits.complement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fe1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fe2; else goto c1Fe3;
       c1Fe2: // global
           R2 = R2;
           R1 = Data.Bits.complement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fe3: // global
           I64[Sp - 8] = block_c1FdY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fe7; else goto c1FdZ;
       u1Fe7: // global
           call _c1FdY(R1) args: 0, res: 0, upd: 0;
       c1FdZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FdY() //  [R1]
         { info_tbl: [(c1FdY,
                       label: block_c1FdY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FdY: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.827124697 UTC

[section ""data" . Data.Bits.shift_closure" {
     Data.Bits.shift_closure:
         const Data.Bits.shift_info;
 },
 Data.Bits.shift_entry() //  [R2]
         { info_tbl: [(c1Feo,
                       label: Data.Bits.shift_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Feo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fep; else goto c1Feq;
       c1Fep: // global
           R2 = R2;
           R1 = Data.Bits.shift_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Feq: // global
           I64[Sp - 8] = block_c1Fel_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Feu; else goto c1Fem;
       u1Feu: // global
           call _c1Fel(R1) args: 0, res: 0, upd: 0;
       c1Fem: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fel() //  [R1]
         { info_tbl: [(c1Fel,
                       label: block_c1Fel_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fel: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.832749303 UTC

[section ""data" . Data.Bits.rotate_closure" {
     Data.Bits.rotate_closure:
         const Data.Bits.rotate_info;
 },
 Data.Bits.rotate_entry() //  [R2]
         { info_tbl: [(c1FeL,
                       label: Data.Bits.rotate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FeL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FeM; else goto c1FeN;
       c1FeM: // global
           R2 = R2;
           R1 = Data.Bits.rotate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FeN: // global
           I64[Sp - 8] = block_c1FeI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FeR; else goto c1FeJ;
       u1FeR: // global
           call _c1FeI(R1) args: 0, res: 0, upd: 0;
       c1FeJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FeI() //  [R1]
         { info_tbl: [(c1FeI,
                       label: block_c1FeI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FeI: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.83860827 UTC

[section ""data" . Data.Bits.zeroBits_closure" {
     Data.Bits.zeroBits_closure:
         const Data.Bits.zeroBits_info;
 },
 Data.Bits.zeroBits_entry() //  [R2]
         { info_tbl: [(c1Ff8,
                       label: Data.Bits.zeroBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ff8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Ff9; else goto c1Ffa;
       c1Ff9: // global
           R2 = R2;
           R1 = Data.Bits.zeroBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Ffa: // global
           I64[Sp - 8] = block_c1Ff5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Ffe; else goto c1Ff6;
       u1Ffe: // global
           call _c1Ff5(R1) args: 0, res: 0, upd: 0;
       c1Ff6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ff5() //  [R1]
         { info_tbl: [(c1Ff5,
                       label: block_c1Ff5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ff5: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.844187195 UTC

[section ""data" . Data.Bits.bit_closure" {
     Data.Bits.bit_closure:
         const Data.Bits.bit_info;
 },
 Data.Bits.bit_entry() //  [R2]
         { info_tbl: [(c1Ffv,
                       label: Data.Bits.bit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ffv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Ffw; else goto c1Ffx;
       c1Ffw: // global
           R2 = R2;
           R1 = Data.Bits.bit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Ffx: // global
           I64[Sp - 8] = block_c1Ffs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FfB; else goto c1Fft;
       u1FfB: // global
           call _c1Ffs(R1) args: 0, res: 0, upd: 0;
       c1Fft: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ffs() //  [R1]
         { info_tbl: [(c1Ffs,
                       label: block_c1Ffs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ffs: // global
           R1 = P64[R1 + 71];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.850044683 UTC

[section ""data" . Data.Bits.setBit_closure" {
     Data.Bits.setBit_closure:
         const Data.Bits.setBit_info;
 },
 Data.Bits.setBit_entry() //  [R2]
         { info_tbl: [(c1FfS,
                       label: Data.Bits.setBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FfS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FfT; else goto c1FfU;
       c1FfT: // global
           R2 = R2;
           R1 = Data.Bits.setBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FfU: // global
           I64[Sp - 8] = block_c1FfP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FfY; else goto c1FfQ;
       u1FfY: // global
           call _c1FfP(R1) args: 0, res: 0, upd: 0;
       c1FfQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FfP() //  [R1]
         { info_tbl: [(c1FfP,
                       label: block_c1FfP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FfP: // global
           R1 = P64[R1 + 79];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.856016763 UTC

[section ""data" . Data.Bits.clearBit_closure" {
     Data.Bits.clearBit_closure:
         const Data.Bits.clearBit_info;
 },
 Data.Bits.clearBit_entry() //  [R2]
         { info_tbl: [(c1Fgf,
                       label: Data.Bits.clearBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fgf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fgg; else goto c1Fgh;
       c1Fgg: // global
           R2 = R2;
           R1 = Data.Bits.clearBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fgh: // global
           I64[Sp - 8] = block_c1Fgc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fgl; else goto c1Fgd;
       u1Fgl: // global
           call _c1Fgc(R1) args: 0, res: 0, upd: 0;
       c1Fgd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fgc() //  [R1]
         { info_tbl: [(c1Fgc,
                       label: block_c1Fgc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fgc: // global
           R1 = P64[R1 + 87];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.862373829 UTC

[section ""data" . Data.Bits.complementBit_closure" {
     Data.Bits.complementBit_closure:
         const Data.Bits.complementBit_info;
 },
 Data.Bits.complementBit_entry() //  [R2]
         { info_tbl: [(c1FgC,
                       label: Data.Bits.complementBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FgC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FgD; else goto c1FgE;
       c1FgD: // global
           R2 = R2;
           R1 = Data.Bits.complementBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FgE: // global
           I64[Sp - 8] = block_c1Fgz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FgI; else goto c1FgA;
       u1FgI: // global
           call _c1Fgz(R1) args: 0, res: 0, upd: 0;
       c1FgA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fgz() //  [R1]
         { info_tbl: [(c1Fgz,
                       label: block_c1Fgz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fgz: // global
           R1 = P64[R1 + 95];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.868230004 UTC

[section ""data" . Data.Bits.testBit_closure" {
     Data.Bits.testBit_closure:
         const Data.Bits.testBit_info;
 },
 Data.Bits.testBit_entry() //  [R2]
         { info_tbl: [(c1FgZ,
                       label: Data.Bits.testBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FgZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fh0; else goto c1Fh1;
       c1Fh0: // global
           R2 = R2;
           R1 = Data.Bits.testBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fh1: // global
           I64[Sp - 8] = block_c1FgW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fh5; else goto c1FgX;
       u1Fh5: // global
           call _c1FgW(R1) args: 0, res: 0, upd: 0;
       c1FgX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FgW() //  [R1]
         { info_tbl: [(c1FgW,
                       label: block_c1FgW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FgW: // global
           R1 = P64[R1 + 103];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.874203261 UTC

[section ""data" . Data.Bits.bitSizeMaybe_closure" {
     Data.Bits.bitSizeMaybe_closure:
         const Data.Bits.bitSizeMaybe_info;
 },
 Data.Bits.bitSizeMaybe_entry() //  [R2]
         { info_tbl: [(c1Fhm,
                       label: Data.Bits.bitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fhm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fhn; else goto c1Fho;
       c1Fhn: // global
           R2 = R2;
           R1 = Data.Bits.bitSizeMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fho: // global
           I64[Sp - 8] = block_c1Fhj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fhs; else goto c1Fhk;
       u1Fhs: // global
           call _c1Fhj(R1) args: 0, res: 0, upd: 0;
       c1Fhk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fhj() //  [R1]
         { info_tbl: [(c1Fhj,
                       label: block_c1Fhj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fhj: // global
           R1 = P64[R1 + 111];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.879976743 UTC

[section ""data" . Data.Bits.bitSize_closure" {
     Data.Bits.bitSize_closure:
         const Data.Bits.bitSize_info;
 },
 Data.Bits.bitSize_entry() //  [R2]
         { info_tbl: [(c1FhJ,
                       label: Data.Bits.bitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FhJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FhK; else goto c1FhL;
       c1FhK: // global
           R2 = R2;
           R1 = Data.Bits.bitSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FhL: // global
           I64[Sp - 8] = block_c1FhG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FhP; else goto c1FhH;
       u1FhP: // global
           call _c1FhG(R1) args: 0, res: 0, upd: 0;
       c1FhH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FhG() //  [R1]
         { info_tbl: [(c1FhG,
                       label: block_c1FhG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FhG: // global
           R1 = P64[R1 + 119];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.885464612 UTC

[section ""data" . Data.Bits.isSigned_closure" {
     Data.Bits.isSigned_closure:
         const Data.Bits.isSigned_info;
 },
 Data.Bits.isSigned_entry() //  [R2]
         { info_tbl: [(c1Fi6,
                       label: Data.Bits.isSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fi6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fi7; else goto c1Fi8;
       c1Fi7: // global
           R2 = R2;
           R1 = Data.Bits.isSigned_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fi8: // global
           I64[Sp - 8] = block_c1Fi3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fic; else goto c1Fi4;
       u1Fic: // global
           call _c1Fi3(R1) args: 0, res: 0, upd: 0;
       c1Fi4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fi3() //  [R1]
         { info_tbl: [(c1Fi3,
                       label: block_c1Fi3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fi3: // global
           R1 = P64[R1 + 127];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.891341378 UTC

[section ""data" . Data.Bits.shiftL_closure" {
     Data.Bits.shiftL_closure:
         const Data.Bits.shiftL_info;
 },
 Data.Bits.shiftL_entry() //  [R2]
         { info_tbl: [(c1Fit,
                       label: Data.Bits.shiftL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fit: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fiu; else goto c1Fiv;
       c1Fiu: // global
           R2 = R2;
           R1 = Data.Bits.shiftL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fiv: // global
           I64[Sp - 8] = block_c1Fiq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fiz; else goto c1Fir;
       u1Fiz: // global
           call _c1Fiq(R1) args: 0, res: 0, upd: 0;
       c1Fir: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fiq() //  [R1]
         { info_tbl: [(c1Fiq,
                       label: block_c1Fiq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fiq: // global
           R1 = P64[R1 + 135];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.896708729 UTC

[section ""data" . Data.Bits.unsafeShiftL_closure" {
     Data.Bits.unsafeShiftL_closure:
         const Data.Bits.unsafeShiftL_info;
 },
 Data.Bits.unsafeShiftL_entry() //  [R2]
         { info_tbl: [(c1FiQ,
                       label: Data.Bits.unsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FiQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FiR; else goto c1FiS;
       c1FiR: // global
           R2 = R2;
           R1 = Data.Bits.unsafeShiftL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FiS: // global
           I64[Sp - 8] = block_c1FiN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FiW; else goto c1FiO;
       u1FiW: // global
           call _c1FiN(R1) args: 0, res: 0, upd: 0;
       c1FiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FiN() //  [R1]
         { info_tbl: [(c1FiN,
                       label: block_c1FiN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FiN: // global
           R1 = P64[R1 + 143];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.902864924 UTC

[section ""data" . Data.Bits.shiftR_closure" {
     Data.Bits.shiftR_closure:
         const Data.Bits.shiftR_info;
 },
 Data.Bits.shiftR_entry() //  [R2]
         { info_tbl: [(c1Fjd,
                       label: Data.Bits.shiftR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fjd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fje; else goto c1Fjf;
       c1Fje: // global
           R2 = R2;
           R1 = Data.Bits.shiftR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fjf: // global
           I64[Sp - 8] = block_c1Fja_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fjj; else goto c1Fjb;
       u1Fjj: // global
           call _c1Fja(R1) args: 0, res: 0, upd: 0;
       c1Fjb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fja() //  [R1]
         { info_tbl: [(c1Fja,
                       label: block_c1Fja_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fja: // global
           R1 = P64[R1 + 151];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.90865898 UTC

[section ""data" . Data.Bits.unsafeShiftR_closure" {
     Data.Bits.unsafeShiftR_closure:
         const Data.Bits.unsafeShiftR_info;
 },
 Data.Bits.unsafeShiftR_entry() //  [R2]
         { info_tbl: [(c1FjA,
                       label: Data.Bits.unsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FjA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FjB; else goto c1FjC;
       c1FjB: // global
           R2 = R2;
           R1 = Data.Bits.unsafeShiftR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FjC: // global
           I64[Sp - 8] = block_c1Fjx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FjG; else goto c1Fjy;
       u1FjG: // global
           call _c1Fjx(R1) args: 0, res: 0, upd: 0;
       c1Fjy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fjx() //  [R1]
         { info_tbl: [(c1Fjx,
                       label: block_c1Fjx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fjx: // global
           R1 = P64[R1 + 159];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.914265746 UTC

[section ""data" . Data.Bits.rotateL_closure" {
     Data.Bits.rotateL_closure:
         const Data.Bits.rotateL_info;
 },
 Data.Bits.rotateL_entry() //  [R2]
         { info_tbl: [(c1FjX,
                       label: Data.Bits.rotateL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FjX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FjY; else goto c1FjZ;
       c1FjY: // global
           R2 = R2;
           R1 = Data.Bits.rotateL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FjZ: // global
           I64[Sp - 8] = block_c1FjU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fk3; else goto c1FjV;
       u1Fk3: // global
           call _c1FjU(R1) args: 0, res: 0, upd: 0;
       c1FjV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FjU() //  [R1]
         { info_tbl: [(c1FjU,
                       label: block_c1FjU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FjU: // global
           R1 = P64[R1 + 167];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.920163655 UTC

[section ""data" . Data.Bits.rotateR_closure" {
     Data.Bits.rotateR_closure:
         const Data.Bits.rotateR_info;
 },
 Data.Bits.rotateR_entry() //  [R2]
         { info_tbl: [(c1Fkk,
                       label: Data.Bits.rotateR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fkk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fkl; else goto c1Fkm;
       c1Fkl: // global
           R2 = R2;
           R1 = Data.Bits.rotateR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fkm: // global
           I64[Sp - 8] = block_c1Fkh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fkq; else goto c1Fki;
       u1Fkq: // global
           call _c1Fkh(R1) args: 0, res: 0, upd: 0;
       c1Fki: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fkh() //  [R1]
         { info_tbl: [(c1Fkh,
                       label: block_c1Fkh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fkh: // global
           R1 = P64[R1 + 175];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.925954283 UTC

[section ""data" . Data.Bits.popCount_closure" {
     Data.Bits.popCount_closure:
         const Data.Bits.popCount_info;
 },
 Data.Bits.popCount_entry() //  [R2]
         { info_tbl: [(c1FkH,
                       label: Data.Bits.popCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FkH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FkI; else goto c1FkJ;
       c1FkI: // global
           R2 = R2;
           R1 = Data.Bits.popCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FkJ: // global
           I64[Sp - 8] = block_c1FkE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FkN; else goto c1FkF;
       u1FkN: // global
           call _c1FkE(R1) args: 0, res: 0, upd: 0;
       c1FkF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FkE() //  [R1]
         { info_tbl: [(c1FkE,
                       label: block_c1FkE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FkE: // global
           R1 = P64[R1 + 183];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.931538875 UTC

[section ""data" . Data.Bits.$fBitsBool2_closure" {
     Data.Bits.$fBitsBool2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.93329056 UTC

[section ""data" . Data.Bits.$fBitsBool1_closure" {
     Data.Bits.$fBitsBool1_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.935283199 UTC

[section ""data" . Data.Bits.$fBitsBool_$cpopCount_closure" {
     Data.Bits.$fBitsBool_$cpopCount_closure:
         const Data.Bits.$fBitsBool_$cpopCount_info;
 },
 Data.Bits.$fBitsBool_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1Fla,
                       label: Data.Bits.$fBitsBool_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fla: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Flb; else goto c1Flc;
       c1Flb: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Flc: // global
           I64[Sp - 8] = block_c1Fl3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Flj; else goto c1Fl4;
       u1Flj: // global
           call _c1Fl3(R1) args: 0, res: 0, upd: 0;
       c1Fl4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fl3() //  [R1]
         { info_tbl: [(c1Fl3,
                       label: block_c1Fl3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fl3: // global
           if (R1 & 7 == 1) goto c1Fl7; else goto c1Fl8;
       c1Fl7: // global
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Fl8: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.941482708 UTC

[section ""data" . Data.Bits.$fBitsBool_$cisSigned_closure" {
     Data.Bits.$fBitsBool_$cisSigned_closure:
         const Data.Bits.$fBitsBool_$cisSigned_info;
 },
 Data.Bits.$fBitsBool_$cisSigned_entry() //  []
         { info_tbl: [(c1FlB,
                       label: Data.Bits.$fBitsBool_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FlB: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.944880668 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbitSize_closure" {
     Data.Bits.$fBitsBool_$cbitSize_closure:
         const Data.Bits.$fBitsBool_$cbitSize_info;
 },
 Data.Bits.$fBitsBool_$cbitSize_entry() //  []
         { info_tbl: [(c1FlN,
                       label: Data.Bits.$fBitsBool_$cbitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FlN: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.948511563 UTC

[section ""data" . Data.Bits.$fBitsBool3_closure" {
     Data.Bits.$fBitsBool3_closure:
         const GHC.Base.Just_con_info;
         const Data.Bits.$fBitsBool1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.950363189 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsBool_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsBool_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsBool_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1Fm0,
                       label: Data.Bits.$fBitsBool_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fm0: // global
           R1 = Data.Bits.$fBitsBool3_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.954206722 UTC

[section ""data" . Data.Bits.$fBitsBool_$ctestBit_closure" {
     Data.Bits.$fBitsBool_$ctestBit_closure:
         const Data.Bits.$fBitsBool_$ctestBit_info;
 },
 Data.Bits.$fBitsBool_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1Fmf,
                       label: Data.Bits.$fBitsBool_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fmf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Fmg; else goto c1Fmh;
       c1Fmg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Fmh: // global
           I64[Sp - 16] = block_c1Fmc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Fmp; else goto c1Fmd;
       u1Fmp: // global
           call _c1Fmc(R1) args: 0, res: 0, upd: 0;
       c1Fmd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fmc() //  [R1]
         { info_tbl: [(c1Fmc,
                       label: block_c1Fmc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fmc: // global
           if (I64[R1 + 7] == 0) goto c1Fmo; else goto c1Fmn;
       c1Fmo: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1Fmn: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.960449999 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbit_closure" {
     Data.Bits.$fBitsBool_$cbit_closure:
         const Data.Bits.$fBitsBool_$cbit_info;
 },
 Data.Bits.$fBitsBool_$cbit_entry() //  [R2]
         { info_tbl: [(c1FmJ,
                       label: Data.Bits.$fBitsBool_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FmJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FmK; else goto c1FmL;
       c1FmK: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FmL: // global
           I64[Sp - 8] = block_c1FmG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FmT; else goto c1FmH;
       u1FmT: // global
           call _c1FmG(R1) args: 0, res: 0, upd: 0;
       c1FmH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FmG() //  [R1]
         { info_tbl: [(c1FmG,
                       label: block_c1FmG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FmG: // global
           if (I64[R1 + 7] == 0) goto c1FmS; else goto c1FmR;
       c1FmS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1FmR: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.966288885 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotate_closure" {
     Data.Bits.$fBitsBool_$crotate_closure:
         const Data.Bits.$fBitsBool_$crotate_info;
 },
 Data.Bits.$fBitsBool_$crotate_entry() //  [R2]
         { info_tbl: [(c1Fn9,
                       label: Data.Bits.$fBitsBool_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fn9: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.970337541 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cisSigned_closure" {
     Data.Bits.$fBitsInteger_$cisSigned_closure:
         const Data.Bits.$fBitsInteger_$cisSigned_info;
 },
 Data.Bits.$fBitsInteger_$cisSigned_entry() //  []
         { info_tbl: [(c1Fnm,
                       label: Data.Bits.$fBitsInteger_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fnm: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.973507253 UTC

[section ""cstring" . Data.Bits.$fBitsInteger2_bytes" {
     Data.Bits.$fBitsInteger2_bytes:
         I8[] [68,97,116,97,46,66,105,116,115,46,98,105,116,83,105,122,101,40,73,110,116,101,103,101,114,41]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.975367456 UTC

[section ""data" . Data.Bits.$fBitsInteger1_closure" {
     Data.Bits.$fBitsInteger1_closure:
         const Data.Bits.$fBitsInteger1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger1_entry() //  [R1]
         { info_tbl: [(c1FnB,
                       label: Data.Bits.$fBitsInteger1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FnB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FnC; else goto c1FnD;
       c1FnC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FnD: // global
           (_c1Fny::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1Fny::I64 == 0) goto c1FnA; else goto c1Fnz;
       c1FnA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1Fnz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1Fny::I64;
           R2 = Data.Bits.$fBitsInteger2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.979798989 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbitSize_closure" {
     Data.Bits.$fBitsInteger_$cbitSize_closure:
         const Data.Bits.$fBitsInteger_$cbitSize_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cbitSize_entry() //  []
         { info_tbl: [(c1FnP,
                       label: Data.Bits.$fBitsInteger_$cbitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FnP: // global
           R2 = Data.Bits.$fBitsInteger1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.983264784 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsInteger_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsInteger_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1Fo0,
                       label: Data.Bits.$fBitsInteger_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fo0: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.986722071 UTC

[section ""data" . Data.Bits.$fBitsInteger_$ctestBit_closure" {
     Data.Bits.$fBitsInteger_$ctestBit_closure:
         const Data.Bits.$fBitsInteger_$ctestBit_info;
 },
 Data.Bits.$fBitsInteger_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1Fof,
                       label: Data.Bits.$fBitsInteger_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fof: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Fog; else goto c1Foh;
       c1Fog: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Foh: // global
           I64[Sp - 16] = block_c1Foc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Fol; else goto c1Fod;
       u1Fol: // global
           call _c1Foc(R1) args: 0, res: 0, upd: 0;
       c1Fod: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Foc() //  [R1]
         { info_tbl: [(c1Foc,
                       label: block_c1Foc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Foc: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.testBitInteger_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.992529383 UTC

[section ""data" . Data.Bits.$fBitsInteger_$czeroBits_closure" {
     Data.Bits.$fBitsInteger_$czeroBits_closure:
         const Data.Bits.$fBitsInteger_$czeroBits_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger_$czeroBits_entry() //  [R1]
         { info_tbl: [(c1FoB,
                       label: Data.Bits.$fBitsInteger_$czeroBits_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FoB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FoC; else goto c1FoD;
       c1FoC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FoD: // global
           (_c1Foy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1Foy::I64 == 0) goto c1FoA; else goto c1Foz;
       c1FoA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1Foz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1Foy::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:23.996890044 UTC

[section ""data" . Data.Bits.$w$cshift_closure" {
     Data.Bits.$w$cshift_closure:
         const Data.Bits.$w$cshift_info;
         const 0;
 },
 Data.Bits.$w$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1FoU,
                       label: Data.Bits.$w$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FoU: // global
           if (%MO_S_Lt_W64(R3, 0)) goto c1FoS; else goto c1FoT;
       c1FoS: // global
           R3 = -R3;
           R2 = R2;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1FoT: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.000931148 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshift_closure" {
     Data.Bits.$fBitsInteger_$cshift_closure:
         const Data.Bits.$fBitsInteger_$cshift_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1Fpa,
                       label: Data.Bits.$fBitsInteger_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fpa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Fpb; else goto c1Fpc;
       c1Fpb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Fpc: // global
           I64[Sp - 16] = block_c1Fp7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Fpg; else goto c1Fp8;
       u1Fpg: // global
           call _c1Fp7(R1) args: 0, res: 0, upd: 0;
       c1Fp8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fp7() //  [R1]
         { info_tbl: [(c1Fp7,
                       label: block_c1Fp7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fp7: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Bits.$w$cshift_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.006066424 UTC

[section ""data" . sat_s1COx_closure" {
     sat_s1COx_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.007742496 UTC

[section ""data" . sat_s1COy_closure" {
     sat_s1COy_closure:
         const :_con_info;
         const sat_s1COx_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.010103356 UTC

[section ""data" . Data.Bits.$fBitsInteger3_closure" {
     Data.Bits.$fBitsInteger3_closure:
         const Data.Bits.$fBitsInteger3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger3_entry() //  [R1]
         { info_tbl: [(c1Fpy,
                       label: Data.Bits.$fBitsInteger3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fpy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Fpz; else goto c1FpA;
       c1Fpz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FpA: // global
           (_c1Fpv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1Fpv::I64 == 0) goto c1Fpx; else goto c1Fpw;
       c1Fpx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1Fpw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1Fpv::I64;
           R3 = sat_s1COy_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.014488272 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbit_closure" {
     Data.Bits.$fBitsInteger_$cbit_closure:
         const Data.Bits.$fBitsInteger_$cbit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cbit_entry() //  [R2]
         { info_tbl: [(c1FpP,
                       label: Data.Bits.$fBitsInteger_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FpP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FpQ; else goto c1FpR;
       c1FpQ: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FpR: // global
           I64[Sp - 8] = block_c1FpM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fq2; else goto c1FpN;
       u1Fq2: // global
           call _c1FpM(R1) args: 0, res: 0, upd: 0;
       c1FpN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FpM() //  [R1]
         { info_tbl: [(c1FpM,
                       label: block_c1FpM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FpM: // global
           _s1COB::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COB::I64, 0)) goto c1FpY; else goto c1FpZ;
       c1FpY: // global
           R3 = -_s1COB::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1FpZ: // global
           R3 = _s1COB::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.021537422 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cclearBit_closure" {
     Data.Bits.$fBitsInteger_$cclearBit_closure:
         const Data.Bits.$fBitsInteger_$cclearBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1Fqj,
                       label: Data.Bits.$fBitsInteger_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fqj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Fqk; else goto c1Fql;
       c1Fqk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Fql: // global
           I64[Sp - 16] = block_c1Fqg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FqT; else goto c1Fqh;
       u1FqT: // global
           call _c1Fqg(R1) args: 0, res: 0, upd: 0;
       c1Fqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fqg() //  [R1]
         { info_tbl: [(c1Fqg,
                       label: block_c1Fqg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fqg: // global
           _s1COH::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COH::I64, 0)) goto c1FqB; else goto c1FqN;
       c1FqB: // global
           I64[Sp] = block_c1Fqv_info;
           R3 = -_s1COH::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1FqN: // global
           I64[Sp] = block_c1FqI_info;
           R3 = _s1COH::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fqv() //  [R1]
         { info_tbl: [(c1Fqv,
                       label: block_c1Fqv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fqv: // global
           I64[Sp] = block_c1Fqz_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fqz() //  [R1]
         { info_tbl: [(c1Fqz,
                       label: block_c1Fqz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fqz: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1FqI() //  [R1]
         { info_tbl: [(c1FqI,
                       label: block_c1FqI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FqI: // global
           I64[Sp] = block_c1FqM_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1FqM() //  [R1]
         { info_tbl: [(c1FqM,
                       label: block_c1FqM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FqM: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.033793764 UTC

[section ""data" . Data.Bits.$fBitsInteger_$ccomplementBit_closure" {
     Data.Bits.$fBitsInteger_$ccomplementBit_closure:
         const Data.Bits.$fBitsInteger_$ccomplementBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1Frm,
                       label: Data.Bits.$fBitsInteger_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Frm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Frn; else goto c1Fro;
       c1Frn: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Fro: // global
           I64[Sp - 16] = block_c1Frj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FrM; else goto c1Frk;
       u1FrM: // global
           call _c1Frj(R1) args: 0, res: 0, upd: 0;
       c1Frk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Frj() //  [R1]
         { info_tbl: [(c1Frj,
                       label: block_c1Frj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Frj: // global
           _s1COR::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COR::I64, 0)) goto c1FrA; else goto c1FrH;
       c1FrA: // global
           I64[Sp] = block_c1Fry_info;
           R3 = -_s1COR::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1FrH: // global
           I64[Sp] = block_c1FrG_info;
           R3 = _s1COR::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fry() //  [R1]
         { info_tbl: [(c1Fry,
                       label: block_c1Fry_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fry: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1FrG() //  [R1]
         { info_tbl: [(c1FrG,
                       label: block_c1FrG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FrG: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.043153332 UTC

[section ""data" . Data.Bits.$fBitsInteger_$csetBit_closure" {
     Data.Bits.$fBitsInteger_$csetBit_closure:
         const Data.Bits.$fBitsInteger_$csetBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1Fs9,
                       label: Data.Bits.$fBitsInteger_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fs9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Fsa; else goto c1Fsb;
       c1Fsa: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Fsb: // global
           I64[Sp - 16] = block_c1Fs6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Fsz; else goto c1Fs7;
       u1Fsz: // global
           call _c1Fs6(R1) args: 0, res: 0, upd: 0;
       c1Fs7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fs6() //  [R1]
         { info_tbl: [(c1Fs6,
                       label: block_c1Fs6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fs6: // global
           _s1COZ::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1COZ::I64, 0)) goto c1Fsn; else goto c1Fsu;
       c1Fsn: // global
           I64[Sp] = block_c1Fsl_info;
           R3 = -_s1COZ::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1Fsu: // global
           I64[Sp] = block_c1Fst_info;
           R3 = _s1COZ::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fsl() //  [R1]
         { info_tbl: [(c1Fsl,
                       label: block_c1Fsl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fsl: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1Fst() //  [R1]
         { info_tbl: [(c1Fst,
                       label: block_c1Fst_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fst: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.052355989 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsInteger_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsInteger_$cunsafeShiftL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1FsT,
                       label: Data.Bits.$fBitsInteger_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FsT: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.055674147 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshiftL_closure" {
     Data.Bits.$fBitsInteger_$cshiftL_closure:
         const Data.Bits.$fBitsInteger_$cshiftL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Ft4,
                       label: Data.Bits.$fBitsInteger_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ft4: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.059287657 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshiftR_closure" {
     Data.Bits.$fBitsInteger_$cshiftR_closure:
         const Data.Bits.$fBitsInteger_$cshiftR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1Fti,
                       label: Data.Bits.$fBitsInteger_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fti: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Ftj; else goto c1Ftk;
       c1Ftj: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ftk: // global
           I64[Sp - 16] = block_c1Ftf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Fty; else goto c1Ftg;
       u1Fty: // global
           call _c1Ftf(R1) args: 0, res: 0, upd: 0;
       c1Ftg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ftf() //  [R1]
         { info_tbl: [(c1Ftf,
                       label: block_c1Ftf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ftf: // global
           _s1CP4::P64 = P64[Sp + 8];
           _s1CP8::I64 = -I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CP8::I64, 0)) goto c1Ftu; else goto c1Ftv;
       c1Ftu: // global
           R3 = -_s1CP8::I64;
           R2 = _s1CP4::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1Ftv: // global
           R3 = _s1CP8::I64;
           R2 = _s1CP4::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.066017003 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsInteger_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsInteger_$cunsafeShiftR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1FtM,
                       label: Data.Bits.$fBitsInteger_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FtM: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.069726399 UTC

[section ""data" . Data.Bits.$fBitsInteger_$crotateR_closure" {
     Data.Bits.$fBitsInteger_$crotateR_closure:
         const Data.Bits.$fBitsInteger_$crotateR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1Fu0,
                       label: Data.Bits.$fBitsInteger_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fu0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Fu1; else goto c1Fu2;
       c1Fu1: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Fu2: // global
           I64[Sp - 16] = block_c1FtX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Fug; else goto c1FtY;
       u1Fug: // global
           call _c1FtX(R1) args: 0, res: 0, upd: 0;
       c1FtY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FtX() //  [R1]
         { info_tbl: [(c1FtX,
                       label: block_c1FtX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FtX: // global
           _s1CPb::P64 = P64[Sp + 8];
           _s1CPf::I64 = -I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CPf::I64, 0)) goto c1Fuc; else goto c1Fud;
       c1Fuc: // global
           R3 = -_s1CPf::I64;
           R2 = _s1CPb::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1Fud: // global
           R3 = _s1CPf::I64;
           R2 = _s1CPb::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.076109627 UTC

[section ""data" . Data.Bits.$fBitsInteger_$crotateL_closure" {
     Data.Bits.$fBitsInteger_$crotateL_closure:
         const Data.Bits.$fBitsInteger_$crotateL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1Fuu,
                       label: Data.Bits.$fBitsInteger_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fuu: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.079825314 UTC

[section ""data" . Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1FuM,
                       label: Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FuM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FuN; else goto c1FuO;
       c1FuN: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FuO: // global
           I64[Sp - 8] = block_c1FuF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FuV; else goto c1FuG;
       u1FuV: // global
           call _c1FuF(R1) args: 0, res: 0, upd: 0;
       c1FuG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FuF() //  [R1]
         { info_tbl: [(c1FuF,
                       label: block_c1FuF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FuF: // global
           if (R1 & 7 == 1) goto c1FuJ; else goto c1FuK;
       c1FuJ: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1FuK: // global
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.086801135 UTC

[section ""data" . Data.Bits.$fBitsInt_$cpopCount_closure" {
     Data.Bits.$fBitsInt_$cpopCount_closure:
         const Data.Bits.$fBitsInt_$cpopCount_info;
 },
 Data.Bits.$fBitsInt_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1Fvg,
                       label: Data.Bits.$fBitsInt_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fvg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Fvu; else goto c1Fvv;
       c1Fvu: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Fvv: // global
           I64[Sp - 8] = block_c1Fvd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Fvz; else goto c1Fve;
       u1Fvz: // global
           call _c1Fvd(R1) args: 0, res: 0, upd: 0;
       c1Fve: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fvd() //  [R1]
         { info_tbl: [(c1Fvd,
                       label: block_c1Fvd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fvd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Fvy; else goto c1Fvx;
       c1Fvy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Fvx: // global
           (_c1Fvm::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1Fvm::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.093670874 UTC

[section ""data" . Data.Bits.$fBitsInt_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsInt_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsInt_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsInt_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1FvR,
                       label: Data.Bits.$fBitsInt_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FvR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Fw3; else goto c1Fw4;
       c1Fw3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Fw4: // global
           I64[Sp - 16] = block_c1FvO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Fwa; else goto c1FvP;
       u1Fwa: // global
           call _c1FvO(R1) args: 0, res: 0, upd: 0;
       c1FvP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FvO() //  [R1]
         { info_tbl: [(c1FvO,
                       label: block_c1FvO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FvO: // global
           I64[Sp] = block_c1FvU_info;
           _s1CPt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPt::I64;
           if (R1 & 7 != 0) goto u1Fw9; else goto c1FvV;
       u1Fw9: // global
           call _c1FvU(R1) args: 0, res: 0, upd: 0;
       c1FvV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FvU() //  [R1]
         { info_tbl: [(c1FvU,
                       label: block_c1FvU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FvU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Fw8; else goto c1Fw7;
       c1Fw8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Fw7: // global
           _s1CPw::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CPw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.100941247 UTC

[section ""data" . lvl_r1CDD_closure" {
     lvl_r1CDD_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.103768598 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshiftR_closure" {
     Data.Bits.$fBitsInt_$cshiftR_closure:
         const Data.Bits.$fBitsInt_$cshiftR_info;
 },
 Data.Bits.$fBitsInt_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1Fwy,
                       label: Data.Bits.$fBitsInt_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fwy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FwC; else goto c1FwD;
       c1FwC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FwD: // global
           I64[Sp - 16] = block_c1Fwv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Fx3; else goto c1Fww;
       u1Fx3: // global
           call _c1Fwv(R1) args: 0, res: 0, upd: 0;
       c1Fww: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fwv() //  [R1]
         { info_tbl: [(c1Fwv,
                       label: block_c1Fwv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fwv: // global
           I64[Sp] = block_c1FwB_info;
           _s1CPA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPA::I64;
           if (R1 & 7 != 0) goto u1Fx2; else goto c1FwF;
       u1Fx2: // global
           call _c1FwB(R1) args: 0, res: 0, upd: 0;
       c1FwF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FwB() //  [R1]
         { info_tbl: [(c1FwB,
                       label: block_c1FwB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FwB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FwL; else goto c1FwK;
       c1FwL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FwK: // global
           _s1CPA::I64 = I64[Sp + 8];
           _s1CPC::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CPC::I64, 64)) goto c1FwU; else goto c1Fx1;
       c1FwU: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s1CPA::I64, _s1CPC::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Fx1: // global
           if (%MO_S_Ge_W64(_s1CPA::I64, 0)) goto c1FwZ; else goto c1Fx0;
       c1FwZ: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Fx0: // global
           Hp = Hp - 16;
           R1 = lvl_r1CDD_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.112405485 UTC

[section ""data" . Data.Bits.$fBitsInt_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsInt_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsInt_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsInt_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Fxs,
                       label: Data.Bits.$fBitsInt_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fxs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FxE; else goto c1FxF;
       c1FxE: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FxF: // global
           I64[Sp - 16] = block_c1Fxp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FxL; else goto c1Fxq;
       u1FxL: // global
           call _c1Fxp(R1) args: 0, res: 0, upd: 0;
       c1Fxq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fxp() //  [R1]
         { info_tbl: [(c1Fxp,
                       label: block_c1Fxp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fxp: // global
           I64[Sp] = block_c1Fxv_info;
           _s1CPJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPJ::I64;
           if (R1 & 7 != 0) goto u1FxK; else goto c1Fxw;
       u1FxK: // global
           call _c1Fxv(R1) args: 0, res: 0, upd: 0;
       c1Fxw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fxv() //  [R1]
         { info_tbl: [(c1Fxv,
                       label: block_c1Fxv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fxv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FxJ; else goto c1FxI;
       c1FxJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FxI: // global
           _s1CPM::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CPM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.120921282 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshiftL_closure" {
     Data.Bits.$fBitsInt_$cshiftL_closure:
         const Data.Bits.$fBitsInt_$cshiftL_info;
 },
 Data.Bits.$fBitsInt_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Fy8,
                       label: Data.Bits.$fBitsInt_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fy8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Fyc; else goto c1Fyd;
       c1Fyc: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Fyd: // global
           I64[Sp - 16] = block_c1Fy5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Fyx; else goto c1Fy6;
       u1Fyx: // global
           call _c1Fy5(R1) args: 0, res: 0, upd: 0;
       c1Fy6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fy5() //  [R1]
         { info_tbl: [(c1Fy5,
                       label: block_c1Fy5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fy5: // global
           I64[Sp] = block_c1Fyb_info;
           _s1CPQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPQ::I64;
           if (R1 & 7 != 0) goto u1Fyw; else goto c1Fyf;
       u1Fyw: // global
           call _c1Fyb(R1) args: 0, res: 0, upd: 0;
       c1Fyf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fyb() //  [R1]
         { info_tbl: [(c1Fyb,
                       label: block_c1Fyb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fyb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Fyl; else goto c1Fyk;
       c1Fyl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Fyk: // global
           _s1CPS::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CPS::I64, 64)) goto c1Fyu; else goto c1Fyv;
       c1Fyu: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] << _s1CPS::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Fyv: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.129297105 UTC

[section ""data" . Data.Bits.$fBitsInt_$cisSigned_closure" {
     Data.Bits.$fBitsInt_$cisSigned_closure:
         const Data.Bits.$fBitsInt_$cisSigned_info;
 },
 Data.Bits.$fBitsInt_$cisSigned_entry() //  []
         { info_tbl: [(c1FyS,
                       label: Data.Bits.$fBitsInt_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FyS: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.133215315 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotate_closure" {
     Data.Bits.$fBitsInt_$crotate_closure:
         const Data.Bits.$fBitsInt_$crotate_info;
 },
 Data.Bits.$fBitsInt_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c1Fz7,
                       label: Data.Bits.$fBitsInt_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fz7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Fzv; else goto c1Fzw;
       c1Fzv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Fzw: // global
           I64[Sp - 16] = block_c1Fz4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FzC; else goto c1Fz5;
       u1FzC: // global
           call _c1Fz4(R1) args: 0, res: 0, upd: 0;
       c1Fz5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fz4() //  [R1]
         { info_tbl: [(c1Fz4,
                       label: block_c1Fz4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fz4: // global
           I64[Sp] = block_c1Fza_info;
           _s1CPZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CPZ::I64;
           if (R1 & 7 != 0) goto u1FzB; else goto c1Fzb;
       u1FzB: // global
           call _c1Fza(R1) args: 0, res: 0, upd: 0;
       c1Fzb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Fza() //  [R1]
         { info_tbl: [(c1Fza,
                       label: block_c1Fza_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Fza: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FzA; else goto c1Fzz;
       c1FzA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Fzz: // global
           _s1CQ2::I64 = I64[R1 + 7] & 63;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _s1CPZ::I64 = I64[Sp + 8];
           I64[Hp] = (_s1CPZ::I64 << _s1CQ2::I64) | (_s1CPZ::I64 >> 64 - _s1CQ2::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.142262913 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshift_closure" {
     Data.Bits.$fBitsInt_$cshift_closure:
         const Data.Bits.$fBitsInt_$cshift_info;
 },
 Data.Bits.$fBitsInt_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1FA4,
                       label: Data.Bits.$fBitsInt_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FA4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FA8; else goto c1FA9;
       c1FA8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FA9: // global
           I64[Sp - 16] = block_c1FA1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FAT; else goto c1FA2;
       u1FAT: // global
           call _c1FA1(R1) args: 0, res: 0, upd: 0;
       c1FA2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FA1() //  [R1]
         { info_tbl: [(c1FA1,
                       label: block_c1FA1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FA1: // global
           I64[Sp] = block_c1FA7_info;
           _s1CQa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQa::I64;
           if (R1 & 7 != 0) goto u1FAS; else goto c1FAb;
       u1FAS: // global
           call _c1FA7(R1) args: 0, res: 0, upd: 0;
       c1FAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FA7() //  [R1]
         { info_tbl: [(c1FA7,
                       label: block_c1FA7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FA7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FAh; else goto c1FAg;
       c1FAh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FAg: // global
           _s1CQa::I64 = I64[Sp + 8];
           _s1CQc::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CQc::I64, 0)) goto c1FAF; else goto c1FAR;
       c1FAF: // global
           _s1CQe::I64 = -_s1CQc::I64;
           if (%MO_S_Lt_W64(_s1CQe::I64, 64)) goto c1FAw; else goto c1FAD;
       c1FAw: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s1CQa::I64, _s1CQe::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1FAD: // global
           if (%MO_S_Ge_W64(_s1CQa::I64, 0)) goto c1FAQ; else goto c1FAC;
       c1FAC: // global
           Hp = Hp - 16;
           R1 = lvl_r1CDD_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1FAR: // global
           if (%MO_S_Ge_W64(_s1CQc::I64, 64)) goto c1FAQ; else goto c1FAP;
       c1FAQ: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1FAP: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQa::I64 << _s1CQc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.151973134 UTC

[section ""data" . Data.Bits.$fBitsInt_$ccomplement_closure" {
     Data.Bits.$fBitsInt_$ccomplement_closure:
         const Data.Bits.$fBitsInt_$ccomplement_info;
 },
 Data.Bits.$fBitsInt_$ccomplement_entry() //  [R2]
         { info_tbl: [(c1FBk,
                       label: Data.Bits.$fBitsInt_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FBk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FBr; else goto c1FBs;
       c1FBr: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FBs: // global
           I64[Sp - 8] = block_c1FBh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FBw; else goto c1FBi;
       u1FBw: // global
           call _c1FBh(R1) args: 0, res: 0, upd: 0;
       c1FBi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FBh() //  [R1]
         { info_tbl: [(c1FBh,
                       label: block_c1FBh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FBh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FBv; else goto c1FBu;
       c1FBv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FBu: // global
           _s1CQn::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQn::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.158808569 UTC

[section ""data" . Data.Bits.$fBitsInt_$cxor_closure" {
     Data.Bits.$fBitsInt_$cxor_closure:
         const Data.Bits.$fBitsInt_$cxor_info;
 },
 Data.Bits.$fBitsInt_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c1FBO,
                       label: Data.Bits.$fBitsInt_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FBO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FC0; else goto c1FC1;
       c1FC0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FC1: // global
           I64[Sp - 16] = block_c1FBL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FC7; else goto c1FBM;
       u1FC7: // global
           call _c1FBL(R1) args: 0, res: 0, upd: 0;
       c1FBM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FBL() //  [R1]
         { info_tbl: [(c1FBL,
                       label: block_c1FBL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FBL: // global
           I64[Sp] = block_c1FBR_info;
           _s1CQr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQr::I64;
           if (R1 & 7 != 0) goto u1FC6; else goto c1FBS;
       u1FC6: // global
           call _c1FBR(R1) args: 0, res: 0, upd: 0;
       c1FBS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FBR() //  [R1]
         { info_tbl: [(c1FBR,
                       label: block_c1FBR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FBR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FC5; else goto c1FC4;
       c1FC5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FC4: // global
           _s1CQu::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.16728658 UTC

[section ""data" . Data.Bits.$fBitsInt_$c.|._closure" {
     Data.Bits.$fBitsInt_$c.|._closure:
         const Data.Bits.$fBitsInt_$c.|._info;
 },
 Data.Bits.$fBitsInt_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c1FCv,
                       label: Data.Bits.$fBitsInt_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FCv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FCH; else goto c1FCI;
       c1FCH: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FCI: // global
           I64[Sp - 16] = block_c1FCs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FCO; else goto c1FCt;
       u1FCO: // global
           call _c1FCs(R1) args: 0, res: 0, upd: 0;
       c1FCt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FCs() //  [R1]
         { info_tbl: [(c1FCs,
                       label: block_c1FCs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FCs: // global
           I64[Sp] = block_c1FCy_info;
           _s1CQy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQy::I64;
           if (R1 & 7 != 0) goto u1FCN; else goto c1FCz;
       u1FCN: // global
           call _c1FCy(R1) args: 0, res: 0, upd: 0;
       c1FCz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FCy() //  [R1]
         { info_tbl: [(c1FCy,
                       label: block_c1FCy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FCy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FCM; else goto c1FCL;
       c1FCM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FCL: // global
           _s1CQB::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.175172882 UTC

[section ""data" . Data.Bits.$fBitsInt_$c.&._closure" {
     Data.Bits.$fBitsInt_$c.&._closure:
         const Data.Bits.$fBitsInt_$c.&._info;
 },
 Data.Bits.$fBitsInt_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c1FDc,
                       label: Data.Bits.$fBitsInt_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FDc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FDo; else goto c1FDp;
       c1FDo: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FDp: // global
           I64[Sp - 16] = block_c1FD9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FDv; else goto c1FDa;
       u1FDv: // global
           call _c1FD9(R1) args: 0, res: 0, upd: 0;
       c1FDa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FD9() //  [R1]
         { info_tbl: [(c1FD9,
                       label: block_c1FD9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FD9: // global
           I64[Sp] = block_c1FDf_info;
           _s1CQF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CQF::I64;
           if (R1 & 7 != 0) goto u1FDu; else goto c1FDg;
       u1FDu: // global
           call _c1FDf(R1) args: 0, res: 0, upd: 0;
       c1FDg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FDf() //  [R1]
         { info_tbl: [(c1FDf,
                       label: block_c1FDf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FDf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FDt; else goto c1FDs;
       c1FDt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FDs: // global
           _s1CQI::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CQI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.183593121 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1FDT,
                       label: Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FDT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FE7; else goto c1FE8;
       c1FE7: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FE8: // global
           I64[Sp - 8] = block_c1FDQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FEc; else goto c1FDR;
       u1FEc: // global
           call _c1FDQ(R1) args: 0, res: 0, upd: 0;
       c1FDR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FDQ() //  [R1]
         { info_tbl: [(c1FDQ,
                       label: block_c1FDQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FDQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FEb; else goto c1FEa;
       c1FEb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FEa: // global
           (_c1FDZ::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1FDZ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.190114778 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure" {
     Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure:
         const Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_info;
 },
 Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1FEw,
                       label: Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FEw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FEK; else goto c1FEL;
       c1FEK: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FEL: // global
           I64[Sp - 8] = block_c1FEt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FEP; else goto c1FEu;
       u1FEP: // global
           call _c1FEt(R1) args: 0, res: 0, upd: 0;
       c1FEu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FEt() //  [R1]
         { info_tbl: [(c1FEt,
                       label: block_c1FEt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FEt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FEO; else goto c1FEN;
       c1FEO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FEN: // global
           (_c1FEC::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1FEC::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.195749081 UTC

[section ""data" . Data.Bits.$fBitsInt1_closure" {
     Data.Bits.$fBitsInt1_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.198255315 UTC

[section ""data" . Data.Bits.$fBitsInt_$cfiniteBitSize_closure" {
     Data.Bits.$fBitsInt_$cfiniteBitSize_closure:
         const Data.Bits.$fBitsInt_$cfiniteBitSize_info;
 },
 Data.Bits.$fBitsInt_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c1FF7,
                       label: Data.Bits.$fBitsInt_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FF7: // global
           R1 = Data.Bits.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.202007157 UTC

[section ""data" . Data.Bits.$fBitsWord_$cpopCount_closure" {
     Data.Bits.$fBitsWord_$cpopCount_closure:
         const Data.Bits.$fBitsWord_$cpopCount_info;
 },
 Data.Bits.$fBitsWord_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1FFm,
                       label: Data.Bits.$fBitsWord_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FFm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FFx; else goto c1FFy;
       c1FFx: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FFy: // global
           I64[Sp - 8] = block_c1FFj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FFC; else goto c1FFk;
       u1FFC: // global
           call _c1FFj(R1) args: 0, res: 0, upd: 0;
       c1FFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FFj() //  [R1]
         { info_tbl: [(c1FFj,
                       label: block_c1FFj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FFj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FFB; else goto c1FFA;
       c1FFB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FFA: // global
           (_c1FFp::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1FFp::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.208507249 UTC

[section ""data" . Data.Bits.$fBitsWord_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsWord_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsWord_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsWord_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1FFU,
                       label: Data.Bits.$fBitsWord_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FFU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FG6; else goto c1FG7;
       c1FG6: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FG7: // global
           I64[Sp - 16] = block_c1FFR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FGd; else goto c1FFS;
       u1FGd: // global
           call _c1FFR(R1) args: 0, res: 0, upd: 0;
       c1FFS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FFR() //  [R1]
         { info_tbl: [(c1FFR,
                       label: block_c1FFR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FFR: // global
           I64[Sp] = block_c1FFX_info;
           _s1CR4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CR4::I64;
           if (R1 & 7 != 0) goto u1FGc; else goto c1FFY;
       u1FGc: // global
           call _c1FFX(R1) args: 0, res: 0, upd: 0;
       c1FFY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FFX() //  [R1]
         { info_tbl: [(c1FFX,
                       label: block_c1FFX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FFX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FGb; else goto c1FGa;
       c1FGb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FGa: // global
           _s1CR7::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CR7::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.216449338 UTC

[section ""data" . Data.Bits.$fBitsWord1_closure" {
     Data.Bits.$fBitsWord1_closure:
         const GHC.Types.W#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.219260086 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshiftR_closure" {
     Data.Bits.$fBitsWord_$cshiftR_closure:
         const Data.Bits.$fBitsWord_$cshiftR_info;
 },
 Data.Bits.$fBitsWord_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1FGB,
                       label: Data.Bits.$fBitsWord_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FGB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FGF; else goto c1FGG;
       c1FGF: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FGG: // global
           I64[Sp - 16] = block_c1FGy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FH0; else goto c1FGz;
       u1FH0: // global
           call _c1FGy(R1) args: 0, res: 0, upd: 0;
       c1FGz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FGy() //  [R1]
         { info_tbl: [(c1FGy,
                       label: block_c1FGy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FGy: // global
           I64[Sp] = block_c1FGE_info;
           _s1CRb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRb::I64;
           if (R1 & 7 != 0) goto u1FGZ; else goto c1FGI;
       u1FGZ: // global
           call _c1FGE(R1) args: 0, res: 0, upd: 0;
       c1FGI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FGE() //  [R1]
         { info_tbl: [(c1FGE,
                       label: block_c1FGE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FGE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FGO; else goto c1FGN;
       c1FGO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FGN: // global
           _s1CRd::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CRd::I64, 64)) goto c1FGX; else goto c1FGY;
       c1FGX: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s1CRd::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1FGY: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.228104697 UTC

[section ""data" . Data.Bits.$fBitsWord_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsWord_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsWord_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsWord_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1FHo,
                       label: Data.Bits.$fBitsWord_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FHo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FHA; else goto c1FHB;
       c1FHA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FHB: // global
           I64[Sp - 16] = block_c1FHl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FHH; else goto c1FHm;
       u1FHH: // global
           call _c1FHl(R1) args: 0, res: 0, upd: 0;
       c1FHm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FHl() //  [R1]
         { info_tbl: [(c1FHl,
                       label: block_c1FHl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FHl: // global
           I64[Sp] = block_c1FHr_info;
           _s1CRj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRj::I64;
           if (R1 & 7 != 0) goto u1FHG; else goto c1FHs;
       u1FHG: // global
           call _c1FHr(R1) args: 0, res: 0, upd: 0;
       c1FHs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FHr() //  [R1]
         { info_tbl: [(c1FHr,
                       label: block_c1FHr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FHr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FHF; else goto c1FHE;
       c1FHF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FHE: // global
           _s1CRm::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.236751799 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshiftL_closure" {
     Data.Bits.$fBitsWord_$cshiftL_closure:
         const Data.Bits.$fBitsWord_$cshiftL_info;
 },
 Data.Bits.$fBitsWord_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1FI4,
                       label: Data.Bits.$fBitsWord_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FI8; else goto c1FI9;
       c1FI8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FI9: // global
           I64[Sp - 16] = block_c1FI1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FIt; else goto c1FI2;
       u1FIt: // global
           call _c1FI1(R1) args: 0, res: 0, upd: 0;
       c1FI2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FI1() //  [R1]
         { info_tbl: [(c1FI1,
                       label: block_c1FI1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FI1: // global
           I64[Sp] = block_c1FI7_info;
           _s1CRq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRq::I64;
           if (R1 & 7 != 0) goto u1FIs; else goto c1FIb;
       u1FIs: // global
           call _c1FI7(R1) args: 0, res: 0, upd: 0;
       c1FIb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FI7() //  [R1]
         { info_tbl: [(c1FI7,
                       label: block_c1FI7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FI7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FIh; else goto c1FIg;
       c1FIh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FIg: // global
           _s1CRs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CRs::I64, 64)) goto c1FIq; else goto c1FIr;
       c1FIq: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] << _s1CRs::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1FIr: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.24515182 UTC

[section ""data" . Data.Bits.$fBitsWord_$cisSigned_closure" {
     Data.Bits.$fBitsWord_$cisSigned_closure:
         const Data.Bits.$fBitsWord_$cisSigned_info;
 },
 Data.Bits.$fBitsWord_$cisSigned_entry() //  []
         { info_tbl: [(c1FIO,
                       label: Data.Bits.$fBitsWord_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FIO: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.249600786 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotate_closure" {
     Data.Bits.$fBitsWord_$crotate_closure:
         const Data.Bits.$fBitsWord_$crotate_info;
 },
 Data.Bits.$fBitsWord_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c1FJ3,
                       label: Data.Bits.$fBitsWord_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FJ3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1FJ7; else goto c1FJ8;
       c1FJ7: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FJ8: // global
           I64[Sp - 16] = block_c1FJ0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FJM; else goto c1FJ1;
       u1FJM: // global
           call _c1FJ0(R1) args: 0, res: 0, upd: 0;
       c1FJ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FJ0() //  [R1]
         { info_tbl: [(c1FJ0,
                       label: block_c1FJ0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FJ0: // global
           I64[Sp - 8] = block_c1FJ6_info;
           _s1CRy::P64 = R1;
           _s1CRz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CRz::I64;
           P64[Sp + 8] = _s1CRy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FJL; else goto c1FJa;
       u1FJL: // global
           call _c1FJ6(R1) args: 0, res: 0, upd: 0;
       c1FJa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FJ6() //  [R1]
         { info_tbl: [(c1FJ6,
                       label: block_c1FJ6_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FJ6: // global
           _s1CRC::I64 = I64[R1 + 7] & 63;
           if (_s1CRC::I64 != 0) goto u1FJJ; else goto c1FJF;
       u1FJJ: // global
           I64[Sp + 16] = _s1CRC::I64;
           Sp = Sp + 8;
           call _c1FJj() args: 0, res: 0, upd: 0;
       c1FJF: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1FJj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FJj: // global
           Hp = Hp + 16;
           _s1CRC::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1FJC; else goto c1FJB;
       c1FJC: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1FJi_info;
           R1 = _s1CRC::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1FJB: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           _s1CRz::I64 = I64[Sp];
           I64[Hp] = (_s1CRz::I64 << _s1CRC::I64) | (_s1CRz::I64 >> 64 - _s1CRC::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1FJi() //  [R1]
         { info_tbl: [(c1FJi,
                       label: block_c1FJi_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FJi: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1FJj() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.261089652 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshift_closure" {
     Data.Bits.$fBitsWord_$cshift_closure:
         const Data.Bits.$fBitsWord_$cshift_info;
 },
 Data.Bits.$fBitsWord_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1FKn,
                       label: Data.Bits.$fBitsWord_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FKr; else goto c1FKs;
       c1FKr: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FKs: // global
           I64[Sp - 16] = block_c1FKk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FL6; else goto c1FKl;
       u1FL6: // global
           call _c1FKk(R1) args: 0, res: 0, upd: 0;
       c1FKl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FKk() //  [R1]
         { info_tbl: [(c1FKk,
                       label: block_c1FKk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FKk: // global
           I64[Sp] = block_c1FKq_info;
           _s1CRK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CRK::I64;
           if (R1 & 7 != 0) goto u1FL5; else goto c1FKu;
       u1FL5: // global
           call _c1FKq(R1) args: 0, res: 0, upd: 0;
       c1FKu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FKq() //  [R1]
         { info_tbl: [(c1FKq,
                       label: block_c1FKq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FKq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FKA; else goto c1FKz;
       c1FKA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FKz: // global
           _s1CRK::I64 = I64[Sp + 8];
           _s1CRM::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CRM::I64, 0)) goto c1FKS; else goto c1FL4;
       c1FKS: // global
           _s1CRO::I64 = -_s1CRM::I64;
           if (%MO_S_Ge_W64(_s1CRO::I64, 64)) goto c1FL3; else goto c1FKP;
       c1FKP: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRK::I64 >> _s1CRO::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1FL4: // global
           if (%MO_S_Ge_W64(_s1CRM::I64, 64)) goto c1FL3; else goto c1FL2;
       c1FL3: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1FL2: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRK::I64 << _s1CRM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.270408876 UTC

[section ""data" . Data.Bits.$fBitsWord_$ccomplement_closure" {
     Data.Bits.$fBitsWord_$ccomplement_closure:
         const Data.Bits.$fBitsWord_$ccomplement_info;
 },
 Data.Bits.$fBitsWord_$ccomplement_entry() //  [R2]
         { info_tbl: [(c1FLw,
                       label: Data.Bits.$fBitsWord_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FLw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FLD; else goto c1FLE;
       c1FLD: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FLE: // global
           I64[Sp - 8] = block_c1FLt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FLI; else goto c1FLu;
       u1FLI: // global
           call _c1FLt(R1) args: 0, res: 0, upd: 0;
       c1FLu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FLt() //  [R1]
         { info_tbl: [(c1FLt,
                       label: block_c1FLt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FLt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FLH; else goto c1FLG;
       c1FLH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FLG: // global
           _s1CRW::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CRW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.276549213 UTC

[section ""data" . Data.Bits.$fBitsWord_$cxor_closure" {
     Data.Bits.$fBitsWord_$cxor_closure:
         const Data.Bits.$fBitsWord_$cxor_info;
 },
 Data.Bits.$fBitsWord_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c1FM1,
                       label: Data.Bits.$fBitsWord_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FM1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FMd; else goto c1FMe;
       c1FMd: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FMe: // global
           I64[Sp - 16] = block_c1FLY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FMk; else goto c1FLZ;
       u1FMk: // global
           call _c1FLY(R1) args: 0, res: 0, upd: 0;
       c1FLZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FLY() //  [R1]
         { info_tbl: [(c1FLY,
                       label: block_c1FLY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FLY: // global
           I64[Sp] = block_c1FM4_info;
           _s1CS0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CS0::I64;
           if (R1 & 7 != 0) goto u1FMj; else goto c1FM5;
       u1FMj: // global
           call _c1FM4(R1) args: 0, res: 0, upd: 0;
       c1FM5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FM4() //  [R1]
         { info_tbl: [(c1FM4,
                       label: block_c1FM4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FM4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FMi; else goto c1FMh;
       c1FMi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FMh: // global
           _s1CS3::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CS3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.284805561 UTC

[section ""data" . Data.Bits.$fBitsWord_$c.|._closure" {
     Data.Bits.$fBitsWord_$c.|._closure:
         const Data.Bits.$fBitsWord_$c.|._info;
 },
 Data.Bits.$fBitsWord_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c1FMI,
                       label: Data.Bits.$fBitsWord_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FMI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FMU; else goto c1FMV;
       c1FMU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FMV: // global
           I64[Sp - 16] = block_c1FMF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FN1; else goto c1FMG;
       u1FN1: // global
           call _c1FMF(R1) args: 0, res: 0, upd: 0;
       c1FMG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FMF() //  [R1]
         { info_tbl: [(c1FMF,
                       label: block_c1FMF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FMF: // global
           I64[Sp] = block_c1FML_info;
           _s1CS7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CS7::I64;
           if (R1 & 7 != 0) goto u1FN0; else goto c1FMM;
       u1FN0: // global
           call _c1FML(R1) args: 0, res: 0, upd: 0;
       c1FMM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FML() //  [R1]
         { info_tbl: [(c1FML,
                       label: block_c1FML_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FML: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FMZ; else goto c1FMY;
       c1FMZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FMY: // global
           _s1CSa::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CSa::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.293811183 UTC

[section ""data" . Data.Bits.$fBitsWord_$c.&._closure" {
     Data.Bits.$fBitsWord_$c.&._closure:
         const Data.Bits.$fBitsWord_$c.&._info;
 },
 Data.Bits.$fBitsWord_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c1FNp,
                       label: Data.Bits.$fBitsWord_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FNp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FNB; else goto c1FNC;
       c1FNB: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FNC: // global
           I64[Sp - 16] = block_c1FNm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FNI; else goto c1FNn;
       u1FNI: // global
           call _c1FNm(R1) args: 0, res: 0, upd: 0;
       c1FNn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FNm() //  [R1]
         { info_tbl: [(c1FNm,
                       label: block_c1FNm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FNm: // global
           I64[Sp] = block_c1FNs_info;
           _s1CSe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CSe::I64;
           if (R1 & 7 != 0) goto u1FNH; else goto c1FNt;
       u1FNH: // global
           call _c1FNs(R1) args: 0, res: 0, upd: 0;
       c1FNt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FNs() //  [R1]
         { info_tbl: [(c1FNs,
                       label: block_c1FNs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FNs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FNG; else goto c1FNF;
       c1FNG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FNF: // global
           _s1CSh::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CSh::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.302182985 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1FO6,
                       label: Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FO6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FOh; else goto c1FOi;
       c1FOh: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FOi: // global
           I64[Sp - 8] = block_c1FO3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FOm; else goto c1FO4;
       u1FOm: // global
           call _c1FO3(R1) args: 0, res: 0, upd: 0;
       c1FO4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FO3() //  [R1]
         { info_tbl: [(c1FO3,
                       label: block_c1FO3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FO3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FOl; else goto c1FOk;
       c1FOl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FOk: // global
           (_c1FO9::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1FO9::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.308660747 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure" {
     Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure:
         const Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_info;
 },
 Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1FOG,
                       label: Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FOG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1FOR; else goto c1FOS;
       c1FOR: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FOS: // global
           I64[Sp - 8] = block_c1FOD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1FOW; else goto c1FOE;
       u1FOW: // global
           call _c1FOD(R1) args: 0, res: 0, upd: 0;
       c1FOE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FOD() //  [R1]
         { info_tbl: [(c1FOD,
                       label: block_c1FOD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FOD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FOV; else goto c1FOU;
       c1FOV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FOU: // global
           (_c1FOJ::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1FOJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.315068316 UTC

[section ""data" . Data.Bits.$fBitsWord_$cfiniteBitSize_closure" {
     Data.Bits.$fBitsWord_$cfiniteBitSize_closure:
         const Data.Bits.$fBitsWord_$cfiniteBitSize_info;
 },
 Data.Bits.$fBitsWord_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c1FPd,
                       label: Data.Bits.$fBitsWord_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FPd: // global
           R1 = Data.Bits.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.319244109 UTC

[section ""data" . Data.Bits.$dmcountTrailingZeros_closure" {
     Data.Bits.$dmcountTrailingZeros_closure:
         const Data.Bits.$dmcountTrailingZeros_info;
 },
 $dBits_s1CSx_entry() //  [R1]
         { info_tbl: [(c1FPx,
                       label: $dBits_s1CSx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FPx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FPy; else goto c1FPz;
       c1FPy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FPz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcountTrailingZeros_entry() //  [R2, R3]
         { info_tbl: [(c1FPA,
                       label: Data.Bits.$dmcountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FPA: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1FPB; else goto c1FPC;
       c1FPB: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmcountTrailingZeros_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FPC: // global
           I64[Sp - 24] = block_c1FPp_info;
           _s1CSt::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R3;
           P64[Sp - 16] = _s1CSt::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1FPp() //  [R1]
         { info_tbl: [(c1FPp,
                       label: block_c1FPp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FPp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1FPF; else goto c1FPE;
       c1FPF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FPE: // global
           _s1CSw::I64 = I64[R1 + 7];
           I64[Hp - 16] = $dBits_s1CSx_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           I64[Sp] = _s1CSw::I64;
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call _c1FPJ() args: 0, res: 0, upd: 0;
     }
 },
 _c1FPJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FPJ: // global
           Hp = Hp + 16;
           _s1CSz::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c1FPN; else goto c1FPM;
       c1FPN: // global
           HpAlloc = 16;
           I64[Sp] = block_c1FPI_info;
           R1 = _s1CSz::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1FPM: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CSz::I64;
           _c1FPO::P64 = Hp - 7;
           if (%MO_S_Lt_W64(_s1CSz::I64,
                            I64[Sp + 8])) goto c1FPU; else goto u1FQa;
       c1FPU: // global
           I64[Sp - 16] = block_c1FPS_info;
           R2 = P64[Sp + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[Sp + 24];
           P64[Sp - 24] = _c1FPO::P64;
           P64[Sp - 8] = _c1FPO::P64;
           Sp = Sp - 40;
           call Data.Bits.testBit_entry(R2) args: 32, res: 8, upd: 8;
       u1FQa: // global
           P64[Sp + 24] = _c1FPO::P64;
           Sp = Sp + 24;
           call _c1FQ5() args: 0, res: 0, upd: 0;
     }
 },
 _c1FPI() //  [R1]
         { info_tbl: [(c1FPI,
                       label: block_c1FPI_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FPI: // global
           I64[Sp] = R1;
           call _c1FPJ() args: 0, res: 0, upd: 0;
     }
 },
 _c1FPS() //  [R1]
         { info_tbl: [(c1FPS,
                       label: block_c1FPS_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FPS: // global
           if (R1 & 7 == 1) goto c1FQ0; else goto u1FQb;
       c1FQ0: // global
           I64[Sp + 16] = I64[Sp + 16] + 1;
           Sp = Sp + 16;
           call _c1FPJ() args: 0, res: 0, upd: 0;
       u1FQb: // global
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call _c1FQ5() args: 0, res: 0, upd: 0;
     }
 },
 _c1FQ5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FQ5: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.334835027 UTC

[section ""data" . Data.Bits.$dmcountLeadingZeros_closure" {
     Data.Bits.$dmcountLeadingZeros_closure:
         const Data.Bits.$dmcountLeadingZeros_info;
 },
 $dBits_s1CSI_entry() //  [R1]
         { info_tbl: [(c1FQX,
                       label: $dBits_s1CSI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FQX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FQY; else goto c1FQZ;
       c1FQY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FQZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcountLeadingZeros_entry() //  [R2, R3]
         { info_tbl: [(c1FR0,
                       label: Data.Bits.$dmcountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FR0: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1FR1; else goto c1FR2;
       c1FR1: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmcountLeadingZeros_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FR2: // global
           I64[Sp - 24] = block_c1FQP_info;
           _s1CSE::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R3;
           P64[Sp - 16] = _s1CSE::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1FQP() //  [R1]
         { info_tbl: [(c1FQP,
                       label: block_c1FQP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FQP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1FR5; else goto c1FR4;
       c1FR5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1FR4: // global
           _s1CSH::I64 = I64[R1 + 7];
           I64[Hp - 16] = $dBits_s1CSI_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = _s1CSH::I64 - 1;
           I64[Sp] = _s1CSH::I64;
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call _c1FRG() args: 0, res: 0, upd: 0;
     }
 },
 _c1FRG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FRG: // global
           Hp = Hp + 16;
           _s1CSS::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c1FRK; else goto c1FRJ;
       c1FRK: // global
           HpAlloc = 16;
           I64[Sp] = block_c1FRF_info;
           R1 = _s1CSS::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1FRJ: // global
           if (%MO_S_Ge_W64(_s1CSS::I64, 0)) goto c1FRR; else goto c1FS2;
       c1FRR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CSS::I64;
           I64[Sp - 8] = block_c1FRP_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = Hp - 7;
           Sp = Sp - 32;
           call Data.Bits.testBit_entry(R2) args: 32, res: 8, upd: 8;
       c1FS2: // global
           Hp = Hp - 16;
           I64[Sp + 24] = _s1CSS::I64;
           Sp = Sp + 8;
           call _c1FRr() args: 0, res: 0, upd: 0;
     }
 },
 _c1FRF() //  [R1]
         { info_tbl: [(c1FRF,
                       label: block_c1FRF_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FRF: // global
           I64[Sp] = R1;
           call _c1FRG() args: 0, res: 0, upd: 0;
     }
 },
 _c1FRP() //  [R1]
         { info_tbl: [(c1FRP,
                       label: block_c1FRP_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FRP: // global
           _s1CSS::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c1FRX; else goto c1FS1;
       c1FRX: // global
           I64[Sp + 8] = _s1CSS::I64 - 1;
           Sp = Sp + 8;
           call _c1FRG() args: 0, res: 0, upd: 0;
       c1FS1: // global
           I64[Sp + 32] = _s1CSS::I64;
           Sp = Sp + 16;
           call _c1FRc() args: 0, res: 0, upd: 0;
     }
 },
 _c1FRc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FRc: // global
           Hp = Hp + 16;
           _s1CSK::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c1FRn; else goto c1FRm;
       c1FRn: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1FRb_info;
           R1 = _s1CSK::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1FRm: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp] + ((-1) - _s1CSK::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1FRb() //  [R1]
         { info_tbl: [(c1FRb,
                       label: block_c1FRb_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FRb: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c1FRc() args: 0, res: 0, upd: 0;
     }
 },
 _c1FRr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FRr: // global
           Hp = Hp + 16;
           _s1CSO::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c1FRC; else goto c1FRB;
       c1FRC: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1FRq_info;
           R1 = _s1CSO::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1FRB: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp] + ((-1) - _s1CSO::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1FRq() //  [R1]
         { info_tbl: [(c1FRq,
                       label: block_c1FRq_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FRq: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c1FRr() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.354332425 UTC

[section ""data" . Data.Bits.$dmrotateR_closure" {
     Data.Bits.$dmrotateR_closure:
         const Data.Bits.$dmrotateR_info;
 },
 sat_s1CT4_entry() //  [R1]
         { info_tbl: [(c1FTg,
                       label: sat_s1CT4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FTg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1FTn; else goto c1FTo;
       c1FTn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FTo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1FTd_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1FTs; else goto c1FTe;
       u1FTs: // global
           call _c1FTd(R1) args: 0, res: 0, upd: 0;
       c1FTe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1FTd() //  [R1]
         { info_tbl: [(c1FTd,
                       label: block_c1FTd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FTd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FTr; else goto c1FTq;
       c1FTr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1FTq: // global
           _s1CT3::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CT3::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmrotateR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1FTt,
                       label: Data.Bits.$dmrotateR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FTt: // global
           _s1CT0::P64 = R4;
           _s1CSZ::P64 = R3;
           _s1CSY::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1FTu; else goto c1FTv;
       c1FTv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1FTx; else goto c1FTw;
       c1FTx: // global
           HpAlloc = 24;
           goto c1FTu;
       c1FTu: // global
           R4 = _s1CT0::P64;
           R3 = _s1CSZ::P64;
           R2 = _s1CSY::P64;
           R1 = Data.Bits.$dmrotateR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FTw: // global
           I64[Hp - 16] = sat_s1CT4_info;
           P64[Hp] = _s1CT0::P64;
           R2 = _s1CSY::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CSZ::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Data.Bits.rotate_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.363031848 UTC

[section ""data" . Data.Bits.$dmrotateL_closure" {
     Data.Bits.$dmrotateL_closure:
         const Data.Bits.$dmrotateL_info;
 },
 Data.Bits.$dmrotateL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1FTR,
                       label: Data.Bits.$dmrotateL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FTR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1FTS; else goto c1FTT;
       c1FTS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmrotateL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FTT: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.rotate_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.366993855 UTC

[section ""data" . Data.Bits.$dmunsafeShiftR_closure" {
     Data.Bits.$dmunsafeShiftR_closure:
         const Data.Bits.$dmunsafeShiftR_info;
 },
 Data.Bits.$dmunsafeShiftR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1FU3,
                       label: Data.Bits.$dmunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FU3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1FU4; else goto c1FU5;
       c1FU4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmunsafeShiftR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FU5: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shiftR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.37161842 UTC

[section ""data" . Data.Bits.$dmshiftR_closure" {
     Data.Bits.$dmshiftR_closure:
         const Data.Bits.$dmshiftR_info;
 },
 sat_s1CTh_entry() //  [R1]
         { info_tbl: [(c1FUm,
                       label: sat_s1CTh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FUm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1FUt; else goto c1FUu;
       c1FUt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FUu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1FUj_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1FUy; else goto c1FUk;
       u1FUy: // global
           call _c1FUj(R1) args: 0, res: 0, upd: 0;
       c1FUk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1FUj() //  [R1]
         { info_tbl: [(c1FUj,
                       label: block_c1FUj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FUj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1FUx; else goto c1FUw;
       c1FUx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1FUw: // global
           _s1CTg::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CTg::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmshiftR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1FUz,
                       label: Data.Bits.$dmshiftR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FUz: // global
           _s1CTd::P64 = R4;
           _s1CTc::P64 = R3;
           _s1CTb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1FUA; else goto c1FUB;
       c1FUB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1FUD; else goto c1FUC;
       c1FUD: // global
           HpAlloc = 24;
           goto c1FUA;
       c1FUA: // global
           R4 = _s1CTd::P64;
           R3 = _s1CTc::P64;
           R2 = _s1CTb::P64;
           R1 = Data.Bits.$dmshiftR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FUC: // global
           I64[Hp - 16] = sat_s1CTh_info;
           P64[Hp] = _s1CTd::P64;
           R2 = _s1CTb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTc::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Data.Bits.shift_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.38015101 UTC

[section ""data" . Data.Bits.$dmunsafeShiftL_closure" {
     Data.Bits.$dmunsafeShiftL_closure:
         const Data.Bits.$dmunsafeShiftL_info;
 },
 Data.Bits.$dmunsafeShiftL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1FUX,
                       label: Data.Bits.$dmunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FUX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1FUY; else goto c1FUZ;
       c1FUY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmunsafeShiftL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FUZ: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.384706131 UTC

[section ""data" . Data.Bits.$dmshiftL_closure" {
     Data.Bits.$dmshiftL_closure:
         const Data.Bits.$dmshiftL_info;
 },
 Data.Bits.$dmshiftL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1FV9,
                       label: Data.Bits.$dmshiftL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FV9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1FVa; else goto c1FVb;
       c1FVa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmshiftL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FVb: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shift_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.388797456 UTC

[section ""data" . Data.Bits.$dmcomplementBit_closure" {
     Data.Bits.$dmcomplementBit_closure:
         const Data.Bits.$dmcomplementBit_info;
 },
 sat_s1CTr_entry() //  [R1]
         { info_tbl: [(c1FVp,
                       label: sat_s1CTr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FVp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1FVq; else goto c1FVr;
       c1FVq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FVr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcomplementBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1FVs,
                       label: Data.Bits.$dmcomplementBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FVs: // global
           _s1CTq::P64 = R4;
           _s1CTp::P64 = R3;
           _s1CTo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1FVt; else goto c1FVu;
       c1FVu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1FVw; else goto c1FVv;
       c1FVw: // global
           HpAlloc = 32;
           goto c1FVt;
       c1FVt: // global
           R4 = _s1CTq::P64;
           R3 = _s1CTp::P64;
           R2 = _s1CTo::P64;
           R1 = Data.Bits.$dmcomplementBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FVv: // global
           I64[Hp - 24] = sat_s1CTr_info;
           P64[Hp - 8] = _s1CTo::P64;
           P64[Hp] = _s1CTq::P64;
           R2 = _s1CTo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTp::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits.xor_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.395816422 UTC

[section ""data" . Data.Bits.$dmclearBit_closure" {
     Data.Bits.$dmclearBit_closure:
         const Data.Bits.$dmclearBit_info;
 },
 sat_s1CTv_entry() //  [R1]
         { info_tbl: [(c1FVU,
                       label: sat_s1CTv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FVU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1FVV; else goto c1FVW;
       c1FVV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FVW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CTw_entry() //  [R1]
         { info_tbl: [(c1FVX,
                       label: sat_s1CTw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FVX: // global
           _s1CTw::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1FVY; else goto c1FVZ;
       c1FVZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1FW1; else goto c1FW0;
       c1FW1: // global
           HpAlloc = 32;
           goto c1FVY;
       c1FVY: // global
           R1 = _s1CTw::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FW0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CTw::P64;
           _s1CTs::P64 = P64[_s1CTw::P64 + 16];
           _s1CTu::P64 = P64[_s1CTw::P64 + 24];
           I64[Hp - 24] = sat_s1CTv_info;
           P64[Hp - 8] = _s1CTs::P64;
           P64[Hp] = _s1CTu::P64;
           R2 = _s1CTs::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call Data.Bits.complement_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmclearBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1FW2,
                       label: Data.Bits.$dmclearBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FW2: // global
           _s1CTu::P64 = R4;
           _s1CTt::P64 = R3;
           _s1CTs::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1FW3; else goto c1FW4;
       c1FW4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1FW6; else goto c1FW5;
       c1FW6: // global
           HpAlloc = 32;
           goto c1FW3;
       c1FW3: // global
           R4 = _s1CTu::P64;
           R3 = _s1CTt::P64;
           R2 = _s1CTs::P64;
           R1 = Data.Bits.$dmclearBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FW5: // global
           I64[Hp - 24] = sat_s1CTw_info;
           P64[Hp - 8] = _s1CTs::P64;
           P64[Hp] = _s1CTu::P64;
           R2 = _s1CTs::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTt::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits..&._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.404800337 UTC

[section ""data" . Data.Bits.$dmsetBit_closure" {
     Data.Bits.$dmsetBit_closure:
         const Data.Bits.$dmsetBit_info;
 },
 sat_s1CTA_entry() //  [R1]
         { info_tbl: [(c1FWv,
                       label: sat_s1CTA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FWv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1FWw; else goto c1FWx;
       c1FWw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FWx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmsetBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1FWy,
                       label: Data.Bits.$dmsetBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FWy: // global
           _s1CTz::P64 = R4;
           _s1CTy::P64 = R3;
           _s1CTx::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1FWz; else goto c1FWA;
       c1FWA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1FWC; else goto c1FWB;
       c1FWC: // global
           HpAlloc = 32;
           goto c1FWz;
       c1FWz: // global
           R4 = _s1CTz::P64;
           R3 = _s1CTy::P64;
           R2 = _s1CTx::P64;
           R1 = Data.Bits.$dmsetBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FWB: // global
           I64[Hp - 24] = sat_s1CTA_info;
           P64[Hp - 8] = _s1CTx::P64;
           P64[Hp] = _s1CTz::P64;
           R2 = _s1CTx::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1CTy::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits..|._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.411445505 UTC

[section ""data" . Data.Bits.$dmzeroBits_closure" {
     Data.Bits.$dmzeroBits_closure:
         const Data.Bits.$dmzeroBits_info;
 },
 sat_s1CTC_entry() //  [R1]
         { info_tbl: [(c1FWW,
                       label: sat_s1CTC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FWW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1FWX; else goto c1FWY;
       c1FWX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1FWY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmzeroBits_entry() //  [R2]
         { info_tbl: [(c1FWZ,
                       label: Data.Bits.$dmzeroBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FWZ: // global
           _s1CTB::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1FX0; else goto c1FX1;
       c1FX1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1FX3; else goto c1FX2;
       c1FX3: // global
           HpAlloc = 24;
           goto c1FX0;
       c1FX0: // global
           R2 = _s1CTB::P64;
           R1 = Data.Bits.$dmzeroBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1FX2: // global
           I64[Hp - 16] = sat_s1CTC_info;
           P64[Hp] = _s1CTB::P64;
           R2 = _s1CTB::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp - 24;
           call Data.Bits.clearBit_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.417902529 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotateL_closure" {
     Data.Bits.$fBitsBool_$crotateL_closure:
         const Data.Bits.$fBitsBool_$crotateL_info;
 },
 Data.Bits.$fBitsBool_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1FXi,
                       label: Data.Bits.$fBitsBool_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FXi: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.421428838 UTC

[section ""data" . Data.Bits.$fBitsBool_$cshiftR_closure" {
     Data.Bits.$fBitsBool_$cshiftR_closure:
         const Data.Bits.$fBitsBool_$cshiftR_info;
 },
 Data.Bits.$fBitsBool_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1FXt,
                       label: Data.Bits.$fBitsBool_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FXt: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$ctestBit_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.425086964 UTC

[section ""data" . Data.Bits.$fBitsBool_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsBool_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsBool_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsBool_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1FXE,
                       label: Data.Bits.$fBitsBool_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FXE: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$cshiftR_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.428484542 UTC

[section ""data" . Data.Bits.$fBitsBool_$cshiftL_closure" {
     Data.Bits.$fBitsBool_$cshiftL_closure:
         const Data.Bits.$fBitsBool_$cshiftL_info;
 },
 Data.Bits.$fBitsBool_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1FXP,
                       label: Data.Bits.$fBitsBool_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FXP: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$ctestBit_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.432176984 UTC

[section ""data" . Data.Bits.$fBitsBool_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsBool_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsBool_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsBool_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1FY0,
                       label: Data.Bits.$fBitsBool_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FY0: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$cshiftL_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.436320251 UTC

[section ""data" . Data.Bits.$fBitsBool_$ccomplementBit_closure" {
     Data.Bits.$fBitsBool_$ccomplementBit_closure:
         const Data.Bits.$fBitsBool_$ccomplementBit_info;
 },
 Data.Bits.$fBitsBool_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1FYi,
                       label: Data.Bits.$fBitsBool_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FYi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FYj; else goto c1FYk;
       c1FYj: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FYk: // global
           I64[Sp - 16] = block_c1FYb_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FYR; else goto c1FYc;
       u1FYR: // global
           call _c1FYb(R1) args: 0, res: 0, upd: 0;
       c1FYc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FYb() //  [R1]
         { info_tbl: [(c1FYb,
                       label: block_c1FYb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FYb: // global
           _s1CTE::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1FYf; else goto c1FYg;
       c1FYf: // global
           I64[Sp + 8] = block_c1FYn_info;
           R1 = _s1CTE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1FYP; else goto c1FYp;
       u1FYP: // global
           call _c1FYn(R1) args: 0, res: 0, upd: 0;
       c1FYp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1FYg: // global
           I64[Sp + 8] = block_c1FYA_info;
           R1 = _s1CTE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1FYQ; else goto c1FYC;
       u1FYQ: // global
           call _c1FYA(R1) args: 0, res: 0, upd: 0;
       c1FYC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FYn() //  [R1]
         { info_tbl: [(c1FYn,
                       label: block_c1FYn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FYn: // global
           if (I64[R1 + 7] == 0) goto u1FYN; else goto u1FYO;
       u1FYN: // global
           Sp = Sp + 8;
           call _c1FYJ() args: 0, res: 0, upd: 0;
       u1FYO: // global
           Sp = Sp + 8;
           call _c1FYK() args: 0, res: 0, upd: 0;
     }
 },
 _c1FYA() //  [R1]
         { info_tbl: [(c1FYA,
                       label: block_c1FYA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FYA: // global
           if (I64[R1 + 7] == 0) goto u1FYL; else goto u1FYM;
       u1FYL: // global
           Sp = Sp + 8;
           call _c1FYK() args: 0, res: 0, upd: 0;
       u1FYM: // global
           Sp = Sp + 8;
           call _c1FYJ() args: 0, res: 0, upd: 0;
     }
 },
 _c1FYK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FYK: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1FYJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FYJ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.447871136 UTC

[section ""data" . Data.Bits.$fBitsBool_$cclearBit_closure" {
     Data.Bits.$fBitsBool_$cclearBit_closure:
         const Data.Bits.$fBitsBool_$cclearBit_info;
 },
 Data.Bits.$fBitsBool_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1FZw,
                       label: Data.Bits.$fBitsBool_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FZw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1FZx; else goto c1FZy;
       c1FZx: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1FZy: // global
           I64[Sp - 16] = block_c1FZp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1FZT; else goto c1FZq;
       u1FZT: // global
           call _c1FZp(R1) args: 0, res: 0, upd: 0;
       c1FZq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FZp() //  [R1]
         { info_tbl: [(c1FZp,
                       label: block_c1FZp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FZp: // global
           if (R1 & 7 == 1) goto u1FZP; else goto c1FZu;
       u1FZP: // global
           Sp = Sp + 16;
           call _c1FZO() args: 0, res: 0, upd: 0;
       c1FZu: // global
           _s1CTN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1FZE_info;
           R1 = _s1CTN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1FZR; else goto c1FZG;
       u1FZR: // global
           call _c1FZE(R1) args: 0, res: 0, upd: 0;
       c1FZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1FZE() //  [R1]
         { info_tbl: [(c1FZE,
                       label: block_c1FZE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FZE: // global
           if (I64[R1 + 7] == 0) goto u1FZQ; else goto c1FZN;
       u1FZQ: // global
           Sp = Sp + 8;
           call _c1FZO() args: 0, res: 0, upd: 0;
       c1FZN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1FZO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1FZO: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.456897855 UTC

[section ""data" . Data.Bits.$fBitsBool_$csetBit_closure" {
     Data.Bits.$fBitsBool_$csetBit_closure:
         const Data.Bits.$fBitsBool_$csetBit_info;
 },
 Data.Bits.$fBitsBool_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1G0p,
                       label: Data.Bits.$fBitsBool_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G0p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1G0q; else goto c1G0r;
       c1G0q: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1G0r: // global
           I64[Sp - 16] = block_c1G0i_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1G0y; else goto c1G0j;
       u1G0y: // global
           call _c1G0i(R1) args: 0, res: 0, upd: 0;
       c1G0j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G0i() //  [R1]
         { info_tbl: [(c1G0i,
                       label: block_c1G0i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G0i: // global
           if (R1 & 7 == 1) goto c1G0m; else goto c1G0n;
       c1G0m: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Bits.$fBitsBool_$cbit_entry(R2) args: 8, res: 0, upd: 8;
       c1G0n: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.463455739 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotateR_closure" {
     Data.Bits.$fBitsBool_$crotateR_closure:
         const Data.Bits.$fBitsBool_$crotateR_info;
 },
 Data.Bits.$fBitsBool_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1G0P,
                       label: Data.Bits.$fBitsBool_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G0P: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.466700674 UTC

[section ""data" . Data.Bits.$fBitsBool_closure" {
     Data.Bits.$fBitsBool_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqBool_closure;
         const GHC.Classes.&&_closure+2;
         const GHC.Classes.||_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const GHC.Classes.not_closure+1;
         const Data.Bits.$fBitsBool_$ctestBit_closure+2;
         const Data.Bits.$fBitsBool_$crotate_closure+2;
         const GHC.Types.False_closure+1;
         const Data.Bits.$fBitsBool_$cbit_closure+1;
         const Data.Bits.$fBitsBool_$csetBit_closure+2;
         const Data.Bits.$fBitsBool_$cclearBit_closure+2;
         const Data.Bits.$fBitsBool_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsBool_$ctestBit_closure+2;
         const Data.Bits.$fBitsBool_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsBool_$cbitSize_closure+1;
         const Data.Bits.$fBitsBool_$cisSigned_closure+1;
         const Data.Bits.$fBitsBool_$cshiftL_closure+2;
         const Data.Bits.$fBitsBool_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsBool_$cshiftR_closure+2;
         const Data.Bits.$fBitsBool_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsBool_$crotateL_closure+2;
         const Data.Bits.$fBitsBool_$crotateR_closure+2;
         const Data.Bits.$fBitsBool_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.468968624 UTC

[section ""data" . Data.Bits.$fFiniteBitsBool_closure" {
     Data.Bits.$fFiniteBitsBool_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsBool_closure+1;
         const Data.Bits.$fBitsBool_$cbitSize_closure+1;
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure+1;
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.471895474 UTC

[section ""data" . Data.Bits.$dmrotate_closure" {
     Data.Bits.$dmrotate_closure:
         const Data.Bits.$dmrotate_info;
 },
 Data.Bits.$dmrotate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1G15,
                       label: Data.Bits.$dmrotate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G15: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1G16; else goto c1G17;
       c1G16: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmrotate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1G17: // global
           I64[Sp - 24] = block_c1G12_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1G1t; else goto c1G13;
       u1G1t: // global
           call _c1G12(R1) args: 0, res: 0, upd: 0;
       c1G13: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G12() //  [R1]
         { info_tbl: [(c1G12,
                       label: block_c1G12_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G12: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1G1c; else goto c1G1b;
       c1G1c: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1G1b: // global
           _s1CTV::P64 = P64[Sp + 8];
           _s1CTW::P64 = P64[Sp + 16];
           _s1CTZ::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CTZ::I64, 0)) goto c1G1m; else goto c1G1n;
       c1G1m: // global
           if (%MO_S_Le_W64(_s1CTZ::I64, 0)) goto c1G1j; else goto c1G1k;
       c1G1j: // global
           Hp = Hp - 16;
           R1 = _s1CTW::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1G1k: // global
           Hp = Hp - 16;
           R2 = _s1CTV::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CTW::P64;
           P64[Sp + 16] = R1;
           call Data.Bits.rotateL_entry(R2) args: 32, res: 0, upd: 8;
       c1G1n: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1CTZ::I64;
           R2 = _s1CTV::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CTW::P64;
           P64[Sp + 16] = Hp - 7;
           call Data.Bits.rotateR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.479077199 UTC

[section ""data" . Data.Bits.$dmshift_closure" {
     Data.Bits.$dmshift_closure:
         const Data.Bits.$dmshift_info;
 },
 Data.Bits.$dmshift_entry() //  [R2, R3, R4]
         { info_tbl: [(c1G1M,
                       label: Data.Bits.$dmshift_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G1M: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1G1N; else goto c1G1O;
       c1G1N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmshift_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1G1O: // global
           I64[Sp - 24] = block_c1G1J_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1G2a; else goto c1G1K;
       u1G2a: // global
           call _c1G1J(R1) args: 0, res: 0, upd: 0;
       c1G1K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G1J() //  [R1]
         { info_tbl: [(c1G1J,
                       label: block_c1G1J_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G1J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1G1T; else goto c1G1S;
       c1G1T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1G1S: // global
           _s1CU4::P64 = P64[Sp + 8];
           _s1CU5::P64 = P64[Sp + 16];
           _s1CU8::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CU8::I64, 0)) goto c1G23; else goto c1G24;
       c1G23: // global
           if (%MO_S_Le_W64(_s1CU8::I64, 0)) goto c1G20; else goto c1G21;
       c1G20: // global
           Hp = Hp - 16;
           R1 = _s1CU5::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1G21: // global
           Hp = Hp - 16;
           R2 = _s1CU4::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CU5::P64;
           P64[Sp + 16] = R1;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
       c1G24: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1CU8::I64;
           R2 = _s1CU4::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1CU5::P64;
           P64[Sp + 16] = Hp - 7;
           call Data.Bits.shiftR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.486715763 UTC

[section ""data" . Data.Bits.bitDefault_closure" {
     Data.Bits.bitDefault_closure:
         const Data.Bits.bitDefault_info;
         const 0;
 },
 sat_s1CUg_entry() //  [R1]
         { info_tbl: [(c1G2u,
                       label: sat_s1CUg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G2u: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1G2v; else goto c1G2w;
       c1G2v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1G2w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.bitDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1G2x,
                       label: Data.Bits.bitDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G2x: // global
           _s1CUf::P64 = R4;
           _s1CUe::P64 = R3;
           _s1CUd::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1G2y; else goto c1G2z;
       c1G2z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1G2B; else goto c1G2A;
       c1G2B: // global
           HpAlloc = 24;
           goto c1G2y;
       c1G2y: // global
           R4 = _s1CUf::P64;
           R3 = _s1CUe::P64;
           R2 = _s1CUd::P64;
           R1 = Data.Bits.bitDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1G2A: // global
           I64[Hp - 16] = sat_s1CUg_info;
           P64[Hp] = _s1CUe::P64;
           R2 = _s1CUd::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1CUf::P64;
           Sp = Sp - 24;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.494431146 UTC

[section ""data" . Data.Bits.testBitDefault_closure" {
     Data.Bits.testBitDefault_closure:
         const Data.Bits.testBitDefault_info;
         const 0;
 },
 sat_s1CUo_entry() //  [R1]
         { info_tbl: [(c1G2U,
                       label: sat_s1CUo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G2U: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1G2V; else goto c1G2W;
       c1G2V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1G2W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CUm_entry() //  [R1]
         { info_tbl: [(c1G35,
                       label: sat_s1CUm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G35: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1G36; else goto c1G37;
       c1G36: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1G37: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CUn_entry() //  [R1]
         { info_tbl: [(c1G38,
                       label: sat_s1CUn_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G38: // global
           _s1CUn::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1G39; else goto c1G3a;
       c1G3a: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1G3c; else goto c1G3b;
       c1G3c: // global
           HpAlloc = 32;
           goto c1G39;
       c1G39: // global
           R1 = _s1CUn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1G3b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CUn::P64;
           _s1CUh::P64 = P64[_s1CUn::P64 + 16];
           _s1CUj::P64 = P64[_s1CUn::P64 + 24];
           _s1CUk::P64 = P64[_s1CUn::P64 + 32];
           I64[Hp - 24] = sat_s1CUm_info;
           P64[Hp - 8] = _s1CUh::P64;
           P64[Hp] = _s1CUk::P64;
           R2 = _s1CUh::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1CUj::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Data.Bits..&._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Bits.testBitDefault_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1G3f,
                       label: Data.Bits.testBitDefault_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G3f: // global
           _s1CUk::P64 = R5;
           _s1CUj::P64 = R4;
           _s1CUi::P64 = R3;
           _s1CUh::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1G3g; else goto c1G3h;
       c1G3h: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1G3j; else goto c1G3i;
       c1G3j: // global
           HpAlloc = 64;
           goto c1G3g;
       c1G3g: // global
           R5 = _s1CUk::P64;
           R4 = _s1CUj::P64;
           R3 = _s1CUi::P64;
           R2 = _s1CUh::P64;
           R1 = Data.Bits.testBitDefault_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1G3i: // global
           I64[Hp - 56] = sat_s1CUo_info;
           P64[Hp - 40] = _s1CUi::P64;
           I64[Hp - 32] = sat_s1CUn_info;
           P64[Hp - 16] = _s1CUh::P64;
           P64[Hp - 8] = _s1CUj::P64;
           P64[Hp] = _s1CUk::P64;
           I64[Sp - 24] = block_c1G3d_info;
           R2 = _s1CUh::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 24;
           call Data.Bits.$p1Bits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1G3d() //  [R1]
         { info_tbl: [(c1G3d,
                       label: block_c1G3d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G3d: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _c1G2Q::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _c1G2Q::P64;
           call GHC.Classes./=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.507336554 UTC

[section ""data" . Data.Bits.$fBitsInt2_closure" {
     Data.Bits.$fBitsInt2_closure:
         const GHC.Base.Just_con_info;
         const Data.Bits.$fBitsInt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.509230234 UTC

[section ""data" . Data.Bits.$fBitsWord_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsWord_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsWord_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsWord_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1G3R,
                       label: Data.Bits.$fBitsWord_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G3R: // global
           R1 = Data.Bits.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.513420198 UTC

[section ""data" . Data.Bits.$fBitsWord_$cbit_closure" {
     Data.Bits.$fBitsWord_$cbit_closure:
         const Data.Bits.$fBitsWord_$cbit_info;
 },
 Data.Bits.$fBitsWord_$cbit_entry() //  [R2]
         { info_tbl: [(c1G46,
                       label: Data.Bits.$fBitsWord_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G46: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1G47; else goto c1G48;
       c1G47: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1G48: // global
           I64[Sp - 8] = block_c1G43_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1G4o; else goto c1G44;
       u1G4o: // global
           call _c1G43(R1) args: 0, res: 0, upd: 0;
       c1G44: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G43() //  [R1]
         { info_tbl: [(c1G43,
                       label: block_c1G43_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G43: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1G4d; else goto c1G4c;
       c1G4d: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1G4c: // global
           _s1CUs::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CUs::I64, 64)) goto c1G4m; else goto c1G4n;
       c1G4m: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = 1 << _s1CUs::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1G4n: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.519958498 UTC

[section ""data" . Data.Bits.$fBitsWord_$ctestBit_closure" {
     Data.Bits.$fBitsWord_$ctestBit_closure:
         const Data.Bits.$fBitsWord_$ctestBit_info;
 },
 Data.Bits.$fBitsWord_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1G4I,
                       label: Data.Bits.$fBitsWord_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G4I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1G4M; else goto c1G4N;
       c1G4M: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1G4N: // global
           I64[Sp - 16] = block_c1G4F_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1G5j; else goto c1G4G;
       u1G5j: // global
           call _c1G4F(R1) args: 0, res: 0, upd: 0;
       c1G4G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G4F() //  [R1]
         { info_tbl: [(c1G4F,
                       label: block_c1G4F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G4F: // global
           I64[Sp] = block_c1G4L_info;
           _s1CUy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CUy::I64;
           if (R1 & 7 != 0) goto u1G5i; else goto c1G4P;
       u1G5i: // global
           call _c1G4L(R1) args: 0, res: 0, upd: 0;
       c1G4P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G4L() //  [R1]
         { info_tbl: [(c1G4L,
                       label: block_c1G4L_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G4L: // global
           _s1CUA::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CUA::I64, 64)) goto c1G5h; else goto c1G5g;
       c1G5g: // global
           if (I64[Sp + 8] & (1 << _s1CUA::I64) == 0) goto c1G5h; else goto c1G55;
       c1G5h: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1G55: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.528643231 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotateR_closure" {
     Data.Bits.$fBitsWord_$crotateR_closure:
         const Data.Bits.$fBitsWord_$crotateR_info;
 },
 Data.Bits.$fBitsWord_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1G5J,
                       label: Data.Bits.$fBitsWord_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G5J: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1G5N; else goto c1G5O;
       c1G5N: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1G5O: // global
           I64[Sp - 16] = block_c1G5G_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1G6v; else goto c1G5H;
       u1G6v: // global
           call _c1G5G(R1) args: 0, res: 0, upd: 0;
       c1G5H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G5G() //  [R1]
         { info_tbl: [(c1G5G,
                       label: block_c1G5G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G5G: // global
           I64[Sp - 8] = block_c1G5M_info;
           _s1CUG::P64 = R1;
           _s1CUH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CUH::I64;
           P64[Sp + 8] = _s1CUG::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1G6u; else goto c1G5Q;
       u1G6u: // global
           call _c1G5M(R1) args: 0, res: 0, upd: 0;
       c1G5Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G5M() //  [R1]
         { info_tbl: [(c1G5M,
                       label: block_c1G5M_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G5M: // global
           _s1CUL::I64 = -I64[R1 + 7] & 63;
           if (_s1CUL::I64 != 0) goto u1G6s; else goto c1G6o;
       u1G6s: // global
           I64[Sp + 16] = _s1CUL::I64;
           Sp = Sp + 8;
           call _c1G62() args: 0, res: 0, upd: 0;
       c1G6o: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1G62() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G62: // global
           Hp = Hp + 16;
           _s1CUL::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1G6l; else goto c1G6k;
       c1G6l: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1G61_info;
           R1 = _s1CUL::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1G6k: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           _s1CUH::I64 = I64[Sp];
           I64[Hp] = (_s1CUH::I64 << _s1CUL::I64) | (_s1CUH::I64 >> 64 - _s1CUL::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1G61() //  [R1]
         { info_tbl: [(c1G61,
                       label: block_c1G61_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G61: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1G62() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.539941867 UTC

[section ""data" . Data.Bits.$fBitsWord_$ccomplementBit_closure" {
     Data.Bits.$fBitsWord_$ccomplementBit_closure:
         const Data.Bits.$fBitsWord_$ccomplementBit_info;
 },
 Data.Bits.$fBitsWord_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1G76,
                       label: Data.Bits.$fBitsWord_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G76: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1G7a; else goto c1G7b;
       c1G7a: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1G7b: // global
           I64[Sp - 16] = block_c1G73_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1G7y; else goto c1G74;
       u1G7y: // global
           call _c1G73(R1) args: 0, res: 0, upd: 0;
       c1G74: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G73() //  [R1]
         { info_tbl: [(c1G73,
                       label: block_c1G73_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G73: // global
           I64[Sp - 8] = block_c1G79_info;
           _s1CUS::P64 = R1;
           _s1CUT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CUT::I64;
           P64[Sp + 8] = _s1CUS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1G7x; else goto c1G7d;
       u1G7x: // global
           call _c1G79(R1) args: 0, res: 0, upd: 0;
       c1G7d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G79() //  [R1]
         { info_tbl: [(c1G79,
                       label: block_c1G79_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G79: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1G7j; else goto c1G7i;
       c1G7j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1G7i: // global
           _s1CUV::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CUV::I64, 64)) goto c1G7v; else goto c1G7w;
       c1G7v: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s1CUV::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1G7w: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.549586469 UTC

[section ""data" . Data.Bits.$fBitsWord_$cclearBit_closure" {
     Data.Bits.$fBitsWord_$cclearBit_closure:
         const Data.Bits.$fBitsWord_$cclearBit_info;
 },
 Data.Bits.$fBitsWord_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1G7Z,
                       label: Data.Bits.$fBitsWord_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G7Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1G83; else goto c1G84;
       c1G83: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1G84: // global
           I64[Sp - 16] = block_c1G7W_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1G8z; else goto c1G7X;
       u1G8z: // global
           call _c1G7W(R1) args: 0, res: 0, upd: 0;
       c1G7X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G7W() //  [R1]
         { info_tbl: [(c1G7W,
                       label: block_c1G7W_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G7W: // global
           I64[Sp] = block_c1G82_info;
           _s1CV2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CV2::I64;
           if (R1 & 7 != 0) goto u1G8y; else goto c1G86;
       u1G8y: // global
           call _c1G82(R1) args: 0, res: 0, upd: 0;
       c1G86: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G82() //  [R1]
         { info_tbl: [(c1G82,
                       label: block_c1G82_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G82: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1G8c; else goto c1G8b;
       c1G8c: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1G8b: // global
           _s1CV2::I64 = I64[Sp + 8];
           _s1CV4::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CV4::I64, 64)) goto c1G8r; else goto c1G8x;
       c1G8r: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CV2::I64 & (1 << _s1CV4::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1G8x: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1CV2::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.558768624 UTC

[section ""data" . Data.Bits.$fBitsWord_$csetBit_closure" {
     Data.Bits.$fBitsWord_$csetBit_closure:
         const Data.Bits.$fBitsWord_$csetBit_info;
 },
 Data.Bits.$fBitsWord_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1G93,
                       label: Data.Bits.$fBitsWord_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G93: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1G97; else goto c1G98;
       c1G97: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1G98: // global
           I64[Sp - 16] = block_c1G90_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1G9v; else goto c1G91;
       u1G9v: // global
           call _c1G90(R1) args: 0, res: 0, upd: 0;
       c1G91: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G90() //  [R1]
         { info_tbl: [(c1G90,
                       label: block_c1G90_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G90: // global
           I64[Sp - 8] = block_c1G96_info;
           _s1CVc::P64 = R1;
           _s1CVd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CVd::I64;
           P64[Sp + 8] = _s1CVc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1G9u; else goto c1G9a;
       u1G9u: // global
           call _c1G96(R1) args: 0, res: 0, upd: 0;
       c1G9a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1G96() //  [R1]
         { info_tbl: [(c1G96,
                       label: block_c1G96_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G96: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1G9g; else goto c1G9f;
       c1G9g: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1G9f: // global
           _s1CVf::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVf::I64, 64)) goto c1G9s; else goto c1G9t;
       c1G9s: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s1CVf::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1G9t: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.567425064 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotateL_closure" {
     Data.Bits.$fBitsWord_$crotateL_closure:
         const Data.Bits.$fBitsWord_$crotateL_info;
 },
 Data.Bits.$fBitsWord_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1G9T,
                       label: Data.Bits.$fBitsWord_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1G9T: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsWord_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.570889532 UTC

[section ""data" . Data.Bits.$fBitsWord_closure" {
     Data.Bits.$fBitsWord_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqWord_closure;
         const Data.Bits.$fBitsWord_$c.&._closure+2;
         const Data.Bits.$fBitsWord_$c.|._closure+2;
         const Data.Bits.$fBitsWord_$cxor_closure+2;
         const Data.Bits.$fBitsWord_$ccomplement_closure+1;
         const Data.Bits.$fBitsWord_$cshift_closure+2;
         const Data.Bits.$fBitsWord_$crotate_closure+2;
         const Data.Bits.$fBitsWord1_closure+1;
         const Data.Bits.$fBitsWord_$cbit_closure+1;
         const Data.Bits.$fBitsWord_$csetBit_closure+2;
         const Data.Bits.$fBitsWord_$cclearBit_closure+2;
         const Data.Bits.$fBitsWord_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsWord_$ctestBit_closure+2;
         const Data.Bits.$fBitsWord_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsWord_$cfiniteBitSize_closure+1;
         const Data.Bits.$fBitsWord_$cisSigned_closure+1;
         const Data.Bits.$fBitsWord_$cshiftL_closure+2;
         const Data.Bits.$fBitsWord_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsWord_$cshiftR_closure+2;
         const Data.Bits.$fBitsWord_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsWord_$crotateL_closure+2;
         const Data.Bits.$fBitsWord_$crotateR_closure+2;
         const Data.Bits.$fBitsWord_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.573897888 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_closure" {
     Data.Bits.$fFiniteBitsWord_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsWord_closure+1;
         const Data.Bits.$fBitsWord_$cfiniteBitSize_closure+1;
         const Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure+1;
         const Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.575863219 UTC

[section ""data" . Data.Bits.$fBitsInt_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsInt_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsInt_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsInt_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1Ga6,
                       label: Data.Bits.$fBitsInt_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ga6: // global
           R1 = Data.Bits.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.579530032 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotateL_closure" {
     Data.Bits.$fBitsInt_$crotateL_closure:
         const Data.Bits.$fBitsInt_$crotateL_info;
 },
 Data.Bits.$fBitsInt_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1Gai,
                       label: Data.Bits.$fBitsInt_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gai: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInt_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.583918357 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotateR_closure" {
     Data.Bits.$fBitsInt_$crotateR_closure:
         const Data.Bits.$fBitsInt_$crotateR_info;
 },
 Data.Bits.$fBitsInt_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1Gaw,
                       label: Data.Bits.$fBitsInt_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gaw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1GaX; else goto c1GaY;
       c1GaX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1GaY: // global
           I64[Sp - 16] = block_c1Gat_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Gb4; else goto c1Gau;
       u1Gb4: // global
           call _c1Gat(R1) args: 0, res: 0, upd: 0;
       c1Gau: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gat() //  [R1]
         { info_tbl: [(c1Gat,
                       label: block_c1Gat_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gat: // global
           I64[Sp] = block_c1Gaz_info;
           _s1CVn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CVn::I64;
           if (R1 & 7 != 0) goto u1Gb3; else goto c1GaA;
       u1Gb3: // global
           call _c1Gaz(R1) args: 0, res: 0, upd: 0;
       c1GaA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gaz() //  [R1]
         { info_tbl: [(c1Gaz,
                       label: block_c1Gaz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gaz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gb2; else goto c1Gb1;
       c1Gb2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gb1: // global
           _s1CVq::I64 = -I64[R1 + 7] & 63;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _s1CVn::I64 = I64[Sp + 8];
           I64[Hp] = (_s1CVn::I64 << _s1CVq::I64) | (_s1CVn::I64 >> 64 - _s1CVq::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.592386945 UTC

[section ""data" . Data.Bits.$fBitsInt_$cbit_closure" {
     Data.Bits.$fBitsInt_$cbit_closure:
         const Data.Bits.$fBitsInt_$cbit_info;
 },
 Data.Bits.$fBitsInt_$cbit_entry() //  [R2]
         { info_tbl: [(c1Gbw,
                       label: Data.Bits.$fBitsInt_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gbw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Gbx; else goto c1Gby;
       c1Gbx: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Gby: // global
           I64[Sp - 8] = block_c1Gbt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GbO; else goto c1Gbu;
       u1GbO: // global
           call _c1Gbt(R1) args: 0, res: 0, upd: 0;
       c1Gbu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gbt() //  [R1]
         { info_tbl: [(c1Gbt,
                       label: block_c1Gbt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gbt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1GbD; else goto c1GbC;
       c1GbD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1GbC: // global
           _s1CVy::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVy::I64, 64)) goto c1GbM; else goto c1GbN;
       c1GbM: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = 1 << _s1CVy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1GbN: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.599470626 UTC

[section ""data" . Data.Bits.$fBitsInt_$ctestBit_closure" {
     Data.Bits.$fBitsInt_$ctestBit_closure:
         const Data.Bits.$fBitsInt_$ctestBit_info;
 },
 Data.Bits.$fBitsInt_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1Gc8,
                       label: Data.Bits.$fBitsInt_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gc8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Gcc; else goto c1Gcd;
       c1Gcc: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Gcd: // global
           I64[Sp - 16] = block_c1Gc5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1GcJ; else goto c1Gc6;
       u1GcJ: // global
           call _c1Gc5(R1) args: 0, res: 0, upd: 0;
       c1Gc6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gc5() //  [R1]
         { info_tbl: [(c1Gc5,
                       label: block_c1Gc5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gc5: // global
           I64[Sp] = block_c1Gcb_info;
           _s1CVE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CVE::I64;
           if (R1 & 7 != 0) goto u1GcI; else goto c1Gcf;
       u1GcI: // global
           call _c1Gcb(R1) args: 0, res: 0, upd: 0;
       c1Gcf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gcb() //  [R1]
         { info_tbl: [(c1Gcb,
                       label: block_c1Gcb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gcb: // global
           _s1CVG::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1CVG::I64, 64)) goto c1GcH; else goto c1GcG;
       c1GcG: // global
           if (I64[Sp + 8] & (1 << _s1CVG::I64) == 0) goto c1GcH; else goto c1Gcv;
       c1GcH: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Gcv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.608003133 UTC

[section ""data" . Data.Bits.$fBitsInt_$csetBit_closure" {
     Data.Bits.$fBitsInt_$csetBit_closure:
         const Data.Bits.$fBitsInt_$csetBit_info;
 },
 Data.Bits.$fBitsInt_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1Gd9,
                       label: Data.Bits.$fBitsInt_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gd9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Gdd; else goto c1Gde;
       c1Gdd: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Gde: // global
           I64[Sp - 16] = block_c1Gd6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1GdB; else goto c1Gd7;
       u1GdB: // global
           call _c1Gd6(R1) args: 0, res: 0, upd: 0;
       c1Gd7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gd6() //  [R1]
         { info_tbl: [(c1Gd6,
                       label: block_c1Gd6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gd6: // global
           I64[Sp - 8] = block_c1Gdc_info;
           _s1CVM::P64 = R1;
           _s1CVN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CVN::I64;
           P64[Sp + 8] = _s1CVM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GdA; else goto c1Gdg;
       u1GdA: // global
           call _c1Gdc(R1) args: 0, res: 0, upd: 0;
       c1Gdg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gdc() //  [R1]
         { info_tbl: [(c1Gdc,
                       label: block_c1Gdc_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gdc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gdm; else goto c1Gdl;
       c1Gdm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gdl: // global
           _s1CVP::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVP::I64, 64)) goto c1Gdy; else goto c1Gdz;
       c1Gdy: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s1CVP::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Gdz: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.617521087 UTC

[section ""data" . Data.Bits.$fBitsInt_$cclearBit_closure" {
     Data.Bits.$fBitsInt_$cclearBit_closure:
         const Data.Bits.$fBitsInt_$cclearBit_info;
 },
 Data.Bits.$fBitsInt_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1Ge2,
                       label: Data.Bits.$fBitsInt_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ge2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Ge6; else goto c1Ge7;
       c1Ge6: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ge7: // global
           I64[Sp - 16] = block_c1GdZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1GeC; else goto c1Ge0;
       u1GeC: // global
           call _c1GdZ(R1) args: 0, res: 0, upd: 0;
       c1Ge0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GdZ() //  [R1]
         { info_tbl: [(c1GdZ,
                       label: block_c1GdZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GdZ: // global
           I64[Sp] = block_c1Ge5_info;
           _s1CVW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CVW::I64;
           if (R1 & 7 != 0) goto u1GeB; else goto c1Ge9;
       u1GeB: // global
           call _c1Ge5(R1) args: 0, res: 0, upd: 0;
       c1Ge9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ge5() //  [R1]
         { info_tbl: [(c1Ge5,
                       label: block_c1Ge5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ge5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gef; else goto c1Gee;
       c1Gef: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gee: // global
           _s1CVW::I64 = I64[Sp + 8];
           _s1CVY::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CVY::I64, 64)) goto c1Geu; else goto c1GeA;
       c1Geu: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CVW::I64 & ~(1 << _s1CVY::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1GeA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CVW::I64 & (-1);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.626563962 UTC

[section ""data" . Data.Bits.$fBitsInt_$ccomplementBit_closure" {
     Data.Bits.$fBitsInt_$ccomplementBit_closure:
         const Data.Bits.$fBitsInt_$ccomplementBit_info;
 },
 Data.Bits.$fBitsInt_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1Gf5,
                       label: Data.Bits.$fBitsInt_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gf5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Gf9; else goto c1Gfa;
       c1Gf9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Gfa: // global
           I64[Sp - 16] = block_c1Gf2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Gfx; else goto c1Gf3;
       u1Gfx: // global
           call _c1Gf2(R1) args: 0, res: 0, upd: 0;
       c1Gf3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gf2() //  [R1]
         { info_tbl: [(c1Gf2,
                       label: block_c1Gf2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gf2: // global
           I64[Sp - 8] = block_c1Gf8_info;
           _s1CW6::P64 = R1;
           _s1CW7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1CW7::I64;
           P64[Sp + 8] = _s1CW6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Gfw; else goto c1Gfc;
       u1Gfw: // global
           call _c1Gf8(R1) args: 0, res: 0, upd: 0;
       c1Gfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gf8() //  [R1]
         { info_tbl: [(c1Gf8,
                       label: block_c1Gf8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gf8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gfi; else goto c1Gfh;
       c1Gfi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gfh: // global
           _s1CW9::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1CW9::I64, 64)) goto c1Gfu; else goto c1Gfv;
       c1Gfu: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s1CW9::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Gfv: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.635414318 UTC

[section ""data" . Data.Bits.$fBitsInt_closure" {
     Data.Bits.$fBitsInt_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqInt_closure;
         const Data.Bits.$fBitsInt_$c.&._closure+2;
         const Data.Bits.$fBitsInt_$c.|._closure+2;
         const Data.Bits.$fBitsInt_$cxor_closure+2;
         const Data.Bits.$fBitsInt_$ccomplement_closure+1;
         const Data.Bits.$fBitsInt_$cshift_closure+2;
         const Data.Bits.$fBitsInt_$crotate_closure+2;
         const Data.Bits.$fBitsBool2_closure+1;
         const Data.Bits.$fBitsInt_$cbit_closure+1;
         const Data.Bits.$fBitsInt_$csetBit_closure+2;
         const Data.Bits.$fBitsInt_$cclearBit_closure+2;
         const Data.Bits.$fBitsInt_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsInt_$ctestBit_closure+2;
         const Data.Bits.$fBitsInt_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsInt_$cfiniteBitSize_closure+1;
         const Data.Bits.$fBitsInt_$cisSigned_closure+1;
         const Data.Bits.$fBitsInt_$cshiftL_closure+2;
         const Data.Bits.$fBitsInt_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsInt_$cshiftR_closure+2;
         const Data.Bits.$fBitsInt_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsInt_$crotateL_closure+2;
         const Data.Bits.$fBitsInt_$crotateR_closure+2;
         const Data.Bits.$fBitsInt_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.63764736 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_closure" {
     Data.Bits.$fFiniteBitsInt_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsInt_closure+1;
         const Data.Bits.$fBitsInt_$cfiniteBitSize_closure+1;
         const Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure+1;
         const Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.640801546 UTC

[section ""data" . Data.Bits.$wpopCountDefault_closure" {
     Data.Bits.$wpopCountDefault_closure:
         const Data.Bits.$wpopCountDefault_info;
         const 0;
 },
 lvl1_s1CWg_entry() //  [R1]
         { info_tbl: [(c1Ggh,
                       label: lvl1_s1CWg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ggh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Ggi; else goto c1Ggj;
       c1Ggi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Ggj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl2_s1CWh_entry() //  [R1]
         { info_tbl: [(c1Ggm,
                       label: lvl2_s1CWh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ggm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Ggn; else goto c1Ggo;
       c1Ggn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Ggo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CWo_entry() //  [R1]
         { info_tbl: [(c1Ggw,
                       label: sat_s1CWo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ggw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1Ggx; else goto c1Ggy;
       c1Ggx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Ggy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1CWp_entry() //  [R1]
         { info_tbl: [(c1Ggz,
                       label: sat_s1CWp_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ggz: // global
           _s1CWp::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1GgA; else goto c1GgB;
       c1GgB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1GgD; else goto c1GgC;
       c1GgD: // global
           HpAlloc = 40;
           goto c1GgA;
       c1GgA: // global
           R1 = _s1CWp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1GgC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CWp::P64;
           _s1CWd::P64 = P64[_s1CWp::P64 + 16];
           _s1CWe::P64 = P64[_s1CWp::P64 + 24];
           _s1CWg::P64 = P64[_s1CWp::P64 + 32];
           _s1CWl::P64 = P64[_s1CWp::P64 + 40];
           I64[Hp - 32] = sat_s1CWo_info;
           P64[Hp - 16] = _s1CWe::P64;
           P64[Hp - 8] = _s1CWg::P64;
           P64[Hp] = _s1CWl::P64;
           R2 = _s1CWd::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1CWl::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call Data.Bits..&._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Bits.$wpopCountDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1GgE,
                       label: Data.Bits.$wpopCountDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GgE: // global
           _s1CWf::P64 = R4;
           _s1CWe::P64 = R3;
           _s1CWd::P64 = R2;
           if ((Sp + -88) < SpLim) (likely: False) goto c1GgF; else goto c1GgG;
       c1GgG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1GgI; else goto c1GgH;
       c1GgI: // global
           HpAlloc = 48;
           goto c1GgF;
       c1GgF: // global
           R4 = _s1CWf::P64;
           R3 = _s1CWe::P64;
           R2 = _s1CWd::P64;
           R1 = Data.Bits.$wpopCountDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1GgH: // global
           I64[Hp - 40] = lvl1_s1CWg_info;
           P64[Hp - 24] = _s1CWe::P64;
           I64[Hp - 16] = lvl2_s1CWh_info;
           P64[Hp] = _s1CWe::P64;
           I64[Sp - 48] = block_c1Gg1_info;
           R2 = _s1CWd::P64;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _s1CWd::P64;
           P64[Sp - 16] = _s1CWe::P64;
           P64[Sp - 8] = _s1CWf::P64;
           Sp = Sp - 48;
           call Data.Bits.$p1Bits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gg1() //  [R1]
         { info_tbl: [(c1Gg1,
                       label: block_c1Gg1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gg1: // global
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp] = 0;
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call _c1Gg7() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gg7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gg7: // global
           I64[Sp - 8] = block_c1Gga_info;
           R2 = P64[Sp + 48];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp];
           P64[Sp - 16] = P64[Sp + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1Gga() //  [R1]
         { info_tbl: [(c1Gga,
                       label: block_c1Gga_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gga: // global
           _s1CWk::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c1GgM; else goto c1GgT;
       c1GgM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1GgP; else goto c1GgO;
       c1GgP: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1GgO: // global
           I64[Hp - 40] = sat_s1CWp_info;
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 16] = _s1CWk::I64 + 1;
           P64[Sp + 8] = Hp - 40;
           Sp = Sp + 8;
           call _c1Gg7() args: 0, res: 0, upd: 0;
       c1GgT: // global
           R1 = _s1CWk::I64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.659376193 UTC

[section ""data" . Data.Bits.popCountDefault_closure" {
     Data.Bits.popCountDefault_closure:
         const Data.Bits.popCountDefault_info;
         const 0;
 },
 Data.Bits.popCountDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1GhQ,
                       label: Data.Bits.popCountDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GhQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1GhU; else goto c1GhV;
       c1GhU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.popCountDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1GhV: // global
           I64[Sp - 8] = block_c1GhO_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Bits.$wpopCountDefault_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1GhO() //  [R1]
         { info_tbl: [(c1GhO,
                       label: block_c1GhO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GhO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1GhY; else goto c1GhX;
       c1GhY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1GhX: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.665715044 UTC

[section ""data" . Data.Bits.$fBitsInteger_closure" {
     Data.Bits.$fBitsInteger_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Integer.Type.$fEqInteger_closure;
         const GHC.Integer.Type.andInteger_closure+2;
         const GHC.Integer.Type.orInteger_closure+2;
         const GHC.Integer.Type.xorInteger_closure+2;
         const GHC.Integer.Type.complementInteger_closure+1;
         const Data.Bits.$fBitsInteger_$cshift_closure+2;
         const Data.Bits.$fBitsInteger_$cshift_closure+2;
         const Data.Bits.$fBitsInteger_$czeroBits_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure+1;
         const Data.Bits.$fBitsInteger_$csetBit_closure+2;
         const Data.Bits.$fBitsInteger_$cclearBit_closure+2;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsInteger_$ctestBit_closure+2;
         const Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsInteger_$cbitSize_closure+1;
         const Data.Bits.$fBitsInteger_$cisSigned_closure+1;
         const Data.Bits.$fBitsInteger_$cshiftL_closure+2;
         const Data.Bits.$fBitsInteger_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsInteger_$cshiftR_closure+2;
         const Data.Bits.$fBitsInteger_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsInteger_$crotateL_closure+2;
         const Data.Bits.$fBitsInteger_$crotateR_closure+2;
         const Data.Bits.$fBitsInteger_$cpopCount_closure+1;
         const 0;
 },
 section ""data" . Data.Bits.$fBitsInteger_$cpopCount_closure" {
     Data.Bits.$fBitsInteger_$cpopCount_closure:
         const Data.Bits.$fBitsInteger_$cpopCount_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1Gie,
                       label: Data.Bits.$fBitsInteger_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gie: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Gii; else goto c1Gij;
       c1Gii: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Gij: // global
           I64[Sp - 8] = block_c1Gic_info;
           R4 = R2;
           R3 = GHC.Num.$fNumInteger_closure;
           R2 = Data.Bits.$fBitsInteger_closure+1;
           Sp = Sp - 8;
           call Data.Bits.$wpopCountDefault_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gic() //  [R1]
         { info_tbl: [(c1Gic,
                       label: block_c1Gic_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gic: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gim; else goto c1Gil;
       c1Gim: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1Gil: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.696802576 UTC

[section ""data" . Data.Bits.toIntegralSized_closure" {
     Data.Bits.toIntegralSized_closure:
         const Data.Bits.toIntegralSized_info;
         const 0;
 },
 sat_s1CWF_entry() //  [R1]
         { info_tbl: [(c1GiN,
                       label: sat_s1CWF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GiN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1GiO; else goto c1GiP;
       c1GiO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1GiP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 y_s1CWC_entry() //  [R1]
         { info_tbl: [(c1GiS,
                       label: y_s1CWC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GiS: // global
           _s1CWC::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1GiW; else goto c1GiX;
       c1GiX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1GiZ; else goto c1GiY;
       c1GiZ: // global
           HpAlloc = 32;
           goto c1GiW;
       c1GiW: // global
           R1 = _s1CWC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1GiY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CWC::P64;
           _s1CWw::P64 = P64[_s1CWC::P64 + 16];
           _s1CWx::P64 = P64[_s1CWC::P64 + 24];
           _s1CWA::P64 = P64[_s1CWC::P64 + 32];
           I64[Hp - 24] = sat_s1CWF_info;
           P64[Hp - 8] = _s1CWw::P64;
           P64[Hp] = _s1CWA::P64;
           I64[Sp - 32] = block_c1GiQ_info;
           R2 = _s1CWx::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1GiQ() //  [R1]
         { info_tbl: [(c1GiQ,
                       label: block_c1GiQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GiQ: // global
           I64[Sp] = block_c1GiV_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1GiV() //  [R1]
         { info_tbl: [(c1GiV,
                       label: block_c1GiV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GiV: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 xSigned_s1CWI_entry() //  [R1]
         { info_tbl: [(c1Gjh,
                       label: xSigned_s1CWI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gjh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Gji; else goto c1Gjj;
       c1Gji: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Gjj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.isSigned_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dReal_s1CWJ_entry() //  [R1]
         { info_tbl: [(c1Gjo,
                       label: $dReal_s1CWJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gjo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Gjp; else goto c1Gjq;
       c1Gjp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Gjq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dNum_s1CWK_entry() //  [R1]
         { info_tbl: [(c1Gjv,
                       label: $dNum_s1CWK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gjv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Gjw; else goto c1Gjx;
       c1Gjw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Gjx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dOrd_s1CWL_entry() //  [R1]
         { info_tbl: [(c1GjC,
                       label: $dOrd_s1CWL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GjC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1GjD; else goto c1GjE;
       c1GjD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1GjE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1CX0_entry() //  [R1]
         { info_tbl: [(c1Gks,
                       label: sat_s1CX0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gks: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Gkt; else goto c1Gku;
       c1Gkt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Gku: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CWZ_entry() //  [R1]
         { info_tbl: [(c1Gkz,
                       label: sat_s1CWZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gkz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1GkA; else goto c1GkB;
       c1GkA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1GkB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CX1_entry() //  [R1]
         { info_tbl: [(c1GkC,
                       label: sat_s1CX1_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GkC: // global
           _s1CX1::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1GkD; else goto c1GkE;
       c1GkE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1GkG; else goto c1GkF;
       c1GkG: // global
           HpAlloc = 56;
           goto c1GkD;
       c1GkD: // global
           R1 = _s1CX1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1GkF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CX1::P64;
           _s1CWy::P64 = P64[_s1CX1::P64 + 16];
           _s1CWK::P64 = P64[_s1CX1::P64 + 24];
           _s1CWX::P64 = P64[_s1CX1::P64 + 32];
           I64[Hp - 48] = sat_s1CX0_info;
           P64[Hp - 32] = _s1CWK::P64;
           I64[Hp - 24] = sat_s1CWZ_info;
           P64[Hp - 8] = _s1CWy::P64;
           P64[Hp] = _s1CWX::P64;
           R2 = _s1CWK::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1CX8_entry() //  [R1]
         { info_tbl: [(c1GkR,
                       label: sat_s1CX8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GkR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1GkS; else goto c1GkT;
       c1GkS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1GkT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CX6_entry() //  [R1]
         { info_tbl: [(c1Gl5,
                       label: sat_s1CX6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gl5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Glc; else goto c1Gld;
       c1Glc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Gld: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1Gl2_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1Glh; else goto c1Gl3;
       u1Glh: // global
           call _c1Gl2(R1) args: 0, res: 0, upd: 0;
       c1Gl3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1Gl2() //  [R1]
         { info_tbl: [(c1Gl2,
                       label: block_c1Gl2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gl2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Glg; else goto c1Glf;
       c1Glg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1Glf: // global
           _s1CX5::I64 = I64[R1 + 7] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CX5::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1CX7_entry() //  [R1]
         { info_tbl: [(c1Gli,
                       label: sat_s1CX7_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gli: // global
           _s1CX7::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1Glj; else goto c1Glk;
       c1Glk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Glm; else goto c1Gll;
       c1Glm: // global
           HpAlloc = 24;
           goto c1Glj;
       c1Glj: // global
           R1 = _s1CX7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Gll: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CX7::P64;
           _s1CWy::P64 = P64[_s1CX7::P64 + 16];
           _s1CWX::P64 = P64[_s1CX7::P64 + 24];
           I64[Hp - 16] = sat_s1CX6_info;
           P64[Hp] = _s1CWX::P64;
           R2 = _s1CWy::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CX9_entry() //  [R1]
         { info_tbl: [(c1Gln,
                       label: sat_s1CX9_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gln: // global
           _s1CX9::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1Glo; else goto c1Glp;
       c1Glp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1Glr; else goto c1Glq;
       c1Glr: // global
           HpAlloc = 56;
           goto c1Glo;
       c1Glo: // global
           R1 = _s1CX9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Glq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CX9::P64;
           _s1CWy::P64 = P64[_s1CX9::P64 + 16];
           _s1CWK::P64 = P64[_s1CX9::P64 + 24];
           _s1CWX::P64 = P64[_s1CX9::P64 + 32];
           I64[Hp - 48] = sat_s1CX8_info;
           P64[Hp - 32] = _s1CWK::P64;
           I64[Hp - 24] = sat_s1CX7_info;
           P64[Hp - 8] = _s1CWy::P64;
           P64[Hp] = _s1CWX::P64;
           R2 = _s1CWK::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1CYp_entry() //  [R1]
         { info_tbl: [(c1Gmo,
                       label: sat_s1CYp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gmo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Gmv; else goto c1Gmw;
       c1Gmv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Gmw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1Gml_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1GmA; else goto c1Gmm;
       u1GmA: // global
           call _c1Gml(R1) args: 0, res: 0, upd: 0;
       c1Gmm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1Gml() //  [R1]
         { info_tbl: [(c1Gml,
                       label: block_c1Gml_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gml: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gmz; else goto c1Gmy;
       c1Gmz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1Gmy: // global
           _s1CYo::I64 = I64[R1 + 7] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1CYo::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1CYq_entry() //  [R1]
         { info_tbl: [(c1GmB,
                       label: sat_s1CYq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GmB: // global
           _s1CYq::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1GmC; else goto c1GmD;
       c1GmD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1GmF; else goto c1GmE;
       c1GmF: // global
           HpAlloc = 24;
           goto c1GmC;
       c1GmC: // global
           R1 = _s1CYq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1GmE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CYq::P64;
           _s1CWy::P64 = P64[_s1CYq::P64 + 16];
           _s1CYl::P64 = P64[_s1CYq::P64 + 24];
           I64[Hp - 16] = sat_s1CYp_info;
           P64[Hp] = _s1CYl::P64;
           R2 = _s1CWy::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CYr_entry() //  [R1]
         { info_tbl: [(c1GmG,
                       label: sat_s1CYr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GmG: // global
           _s1CYr::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1GmH; else goto c1GmI;
       c1GmI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1GmK; else goto c1GmJ;
       c1GmK: // global
           HpAlloc = 32;
           goto c1GmH;
       c1GmH: // global
           R1 = _s1CYr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1GmJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1CYr::P64;
           _s1CWy::P64 = P64[_s1CYr::P64 + 16];
           _s1CWK::P64 = P64[_s1CYr::P64 + 24];
           _s1CYl::P64 = P64[_s1CYr::P64 + 32];
           I64[Hp - 24] = sat_s1CYq_info;
           P64[Hp - 8] = _s1CWy::P64;
           P64[Hp] = _s1CYl::P64;
           R2 = _s1CWK::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1CYv_entry() //  [R1]
         { info_tbl: [(c1Gn0,
                       label: sat_s1CYv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gn0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Gn1; else goto c1Gn2;
       c1Gn1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Gn2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.toIntegralSized_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1Gn3,
                       label: Data.Bits.toIntegralSized_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gn3: // global
           if ((Sp + -104) < SpLim) (likely: False) goto c1Gn4; else goto c1Gn5;
       c1Gn4: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.toIntegralSized_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Gn5: // global
           I64[Sp - 48] = block_c1GiB_info;
           _s1CWw::P64 = R2;
           R2 = R4;
           I64[Sp - 64] = stg_ap_p_info;
           P64[Sp - 56] = R6;
           P64[Sp - 40] = _s1CWw::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 64;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1GiB() //  [R1]
         { info_tbl: [(c1GiB,
                       label: block_c1GiB_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GiB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1Gn8; else goto c1Gn7;
       c1Gn8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gn7: // global
           I64[Hp - 32] = y_s1CWC_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 40];
           I64[Sp - 8] = block_c1Gj5_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_p_info;
           _c1GiF::P64 = Hp - 32;
           P64[Sp - 16] = _c1GiF::P64;
           P64[Sp] = R1;
           P64[Sp + 16] = _c1GiF::P64;
           Sp = Sp - 24;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1Gj5() //  [R1]
         { info_tbl: [(c1Gj5,
                       label: block_c1Gj5_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gj5: // global
           I64[Sp] = block_c1Gj9_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 40] = R1;
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1Gj9() //  [R1]
         { info_tbl: [(c1Gj9,
                       label: block_c1Gj9_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gj9: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1Gnf; else goto c1Gne;
       c1Gnf: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gne: // global
           I64[Hp - 96] = xSigned_s1CWI_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 48];
           I64[Hp - 64] = $dReal_s1CWJ_info;
           P64[Hp - 48] = P64[Sp + 16];
           I64[Hp - 40] = $dNum_s1CWK_info;
           _c1Gjk::P64 = Hp - 64;
           P64[Hp - 24] = _c1Gjk::P64;
           I64[Hp - 16] = $dOrd_s1CWL_info;
           P64[Hp] = _c1Gjk::P64;
           I64[Sp - 24] = block_c1Gnc_info;
           _s1CWH::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1CWH::P64;
           P64[Sp] = Hp - 40;
           P64[Sp + 16] = Hp - 96;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1GCz; else goto c1GzI;
       u1GCz: // global
           call _c1Gnc(R1) args: 0, res: 0, upd: 0;
       c1GzI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gnc() //  [R1]
         { info_tbl: [(c1Gnc,
                       label: block_c1Gnc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gnc: // global
           _s1CWH::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1GzP; else goto c1GA5;
       c1GzP: // global
           I64[Sp] = block_c1GzM_info;
           R1 = _s1CWH::P64;
           if (R1 & 7 != 0) goto u1GCJ; else goto c1GzQ;
       u1GCJ: // global
           call _c1GzM(R1) args: 0, res: 0, upd: 0;
       c1GzQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1GA5: // global
           I64[Sp - 8] = block_c1GA3_info;
           _s1CZb::P64 = P64[R1 + 6];
           R1 = _s1CWH::P64;
           P64[Sp] = _s1CZb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GCK; else goto c1GA6;
       u1GCK: // global
           call _c1GA3(R1) args: 0, res: 0, upd: 0;
       c1GA6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GzM() //  [R1]
         { info_tbl: [(c1GzM,
                       label: block_c1GzM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GzM: // global
           if (R1 & 7 == 1) goto u1GBu; else goto u1GBv;
       u1GBu: // global
           Sp = Sp + 8;
           call _s1CZ4() args: 0, res: 0, upd: 0;
       u1GBv: // global
           Sp = Sp + 8;
           call _s1CY9() args: 0, res: 0, upd: 0;
     }
 },
 _c1GA3() //  [R1]
         { info_tbl: [(c1GA3,
                       label: block_c1GA3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GA3: // global
           if (R1 & 7 == 1) goto u1GBr; else goto c1GAm;
       u1GBr: // global
           Sp = Sp + 16;
           call _s1CY9() args: 0, res: 0, upd: 0;
       c1GAm: // global
           I64[Sp] = block_c1GAf_info;
           _s1CZd::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CZd::P64;
           if (R1 & 7 != 0) goto u1GEp; else goto c1GAg;
       u1GEp: // global
           call _c1GAf(R1) args: 0, res: 0, upd: 0;
       c1GAg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GAf() //  [R1]
         { info_tbl: [(c1GAf,
                       label: block_c1GAf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GAf: // global
           I64[Sp] = block_c1GAk_info;
           _s1CZf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CZf::I64;
           if (R1 & 7 != 0) goto u1GEr; else goto c1GAo;
       u1GEr: // global
           call _c1GAk(R1) args: 0, res: 0, upd: 0;
       c1GAo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GAk() //  [R1]
         { info_tbl: [(c1GAk,
                       label: block_c1GAk_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GAk: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u1GBs; else goto u1GBt;
       u1GBs: // global
           Sp = Sp + 16;
           call _s1CZ4() args: 0, res: 0, upd: 0;
       u1GBt: // global
           Sp = Sp + 16;
           call _s1CY9() args: 0, res: 0, upd: 0;
     }
 },
 _s1CZ4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CZ4: // global
           I64[Sp - 8] = block_c1Gz7_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEK; else goto c1Gz9;
       u1GEK: // global
           call _c1Gz7(R1) args: 0, res: 0, upd: 0;
       c1Gz9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gz7() //  [R1]
         { info_tbl: [(c1Gz7,
                       label: block_c1Gz7_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gz7: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1Gzg; else goto c1Gzw;
       c1Gzg: // global
           I64[Sp] = block_c1Gzd_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1GEh; else goto c1Gzh;
       u1GEh: // global
           call _c1Gzd(R1) args: 0, res: 0, upd: 0;
       c1Gzh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1Gzw: // global
           I64[Sp] = block_c1Gzu_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1GEi; else goto c1Gzx;
       u1GEi: // global
           call _c1Gzu(R1) args: 0, res: 0, upd: 0;
       c1Gzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gzd() //  [R1]
         { info_tbl: [(c1Gzd,
                       label: block_c1Gzd_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gzd: // global
           if (R1 & 7 == 1) goto u1GBy; else goto u1GBz;
       u1GBy: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       u1GBz: // global
           Sp = Sp + 8;
           call _s1CY9() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gzu() //  [R1]
         { info_tbl: [(c1Gzu,
                       label: block_c1Gzu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gzu: // global
           if (R1 & 7 == 1) goto u1GBw; else goto u1GBx;
       u1GBw: // global
           Sp = Sp + 8;
           call _s1CY9() args: 0, res: 0, upd: 0;
       u1GBx: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CY9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CY9: // global
           I64[Sp - 8] = block_c1GuC_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GED; else goto c1GyH;
       u1GED: // global
           call _c1GuC(R1) args: 0, res: 0, upd: 0;
       c1GyH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GuC() //  [R1]
         { info_tbl: [(c1GuC,
                       label: block_c1GuC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GuC: // global
           if (R1 & 7 == 1) goto u1GBA; else goto c1GyS;
       u1GBA: // global
           Sp = Sp + 8;
           call _s1CYb() args: 0, res: 0, upd: 0;
       c1GyS: // global
           I64[Sp] = block_c1GyQ_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1GDF; else goto c1GyT;
       u1GDF: // global
           call _c1GyQ(R1) args: 0, res: 0, upd: 0;
       c1GyT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GyQ() //  [R1]
         { info_tbl: [(c1GyQ,
                       label: block_c1GyQ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GyQ: // global
           if (R1 & 7 == 1) goto u1GBB; else goto u1GBC;
       u1GBB: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       u1GBC: // global
           Sp = Sp + 8;
           call _s1CYb() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYb() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYb: // global
           I64[Sp - 8] = block_c1GuE_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEE; else goto c1Gy8;
       u1GEE: // global
           call _c1GuE(R1) args: 0, res: 0, upd: 0;
       c1Gy8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GuE() //  [R1]
         { info_tbl: [(c1GuE,
                       label: block_c1GuE_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GuE: // global
           if (R1 & 7 == 1) goto c1Gyf; else goto u1GBD;
       c1Gyf: // global
           I64[Sp] = block_c1Gyc_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1GDH; else goto c1Gyg;
       u1GDH: // global
           call _c1Gyc(R1) args: 0, res: 0, upd: 0;
       c1Gyg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1GBD: // global
           Sp = Sp + 8;
           call _s1CYd() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gyc() //  [R1]
         { info_tbl: [(c1Gyc,
                       label: block_c1Gyc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gyc: // global
           if (R1 & 7 == 1) goto c1Gyn; else goto u1GBE;
       c1Gyn: // global
           I64[Sp] = block_c1Gyk_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1GEb; else goto c1Gyo;
       u1GEb: // global
           call _c1Gyk(R1) args: 0, res: 0, upd: 0;
       c1Gyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1GBE: // global
           Sp = Sp + 8;
           call _s1CYd() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gyk() //  [R1]
         { info_tbl: [(c1Gyk,
                       label: block_c1Gyk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gyk: // global
           if (R1 & 7 == 1) goto u1GBF; else goto u1GBG;
       u1GBF: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       u1GBG: // global
           Sp = Sp + 8;
           call _s1CYd() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYd: // global
           I64[Sp - 8] = block_c1GuK_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEF; else goto c1Gxz;
       u1GEF: // global
           call _c1GuK(R1) args: 0, res: 0, upd: 0;
       c1Gxz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GuK() //  [R1]
         { info_tbl: [(c1GuK,
                       label: block_c1GuK_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GuK: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1GxG; else goto c1GxW;
       c1GxG: // global
           I64[Sp] = block_c1GxD_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1GDJ; else goto c1GxH;
       u1GDJ: // global
           call _c1GxD(R1) args: 0, res: 0, upd: 0;
       c1GxH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1GxW: // global
           I64[Sp] = block_c1GxU_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1GDK; else goto c1GxX;
       u1GDK: // global
           call _c1GxU(R1) args: 0, res: 0, upd: 0;
       c1GxX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GxD() //  [R1]
         { info_tbl: [(c1GxD,
                       label: block_c1GxD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GxD: // global
           if (R1 & 7 == 1) goto u1GBJ; else goto u1GBK;
       u1GBJ: // global
           Sp = Sp + 8;
           call _s1CYK() args: 0, res: 0, upd: 0;
       u1GBK: // global
           Sp = Sp + 8;
           call _s1CYx() args: 0, res: 0, upd: 0;
     }
 },
 _c1GxU() //  [R1]
         { info_tbl: [(c1GxU,
                       label: block_c1GxU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GxU: // global
           if (R1 & 7 == 1) goto u1GBH; else goto u1GBI;
       u1GBH: // global
           Sp = Sp + 8;
           call _s1CYx() args: 0, res: 0, upd: 0;
       u1GBI: // global
           Sp = Sp + 8;
           call _s1CYK() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYK: // global
           I64[Sp - 8] = block_c1GwT_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEJ; else goto c1GwV;
       u1GEJ: // global
           call _c1GwT(R1) args: 0, res: 0, upd: 0;
       c1GwV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GwT() //  [R1]
         { info_tbl: [(c1GwT,
                       label: block_c1GwT_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GwT: // global
           if (R1 & 7 == 1) goto u1GBL; else goto c1Gx6;
       u1GBL: // global
           Sp = Sp + 8;
           call _s1CYx() args: 0, res: 0, upd: 0;
       c1Gx6: // global
           I64[Sp - 8] = block_c1Gx4_info;
           _s1CYM::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CYM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GE0; else goto c1Gx7;
       u1GE0: // global
           call _c1Gx4(R1) args: 0, res: 0, upd: 0;
       c1Gx7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gx4() //  [R1]
         { info_tbl: [(c1Gx4,
                       label: block_c1Gx4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gx4: // global
           if (R1 & 7 == 1) goto u1GBM; else goto c1Gxn;
       u1GBM: // global
           Sp = Sp + 16;
           call _s1CYx() args: 0, res: 0, upd: 0;
       c1Gxn: // global
           I64[Sp] = block_c1Gxg_info;
           _s1CYO::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CYO::P64;
           if (R1 & 7 != 0) goto u1GE2; else goto c1Gxh;
       u1GE2: // global
           call _c1Gxg(R1) args: 0, res: 0, upd: 0;
       c1Gxh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _s1CYx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYx: // global
           I64[Sp - 8] = block_c1GvM_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEI; else goto c1GvO;
       u1GEI: // global
           call _c1GvM(R1) args: 0, res: 0, upd: 0;
       c1GvO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GvM() //  [R1]
         { info_tbl: [(c1GvM,
                       label: block_c1GvM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GvM: // global
           if (R1 & 7 == 1) goto c1GvV; else goto u1GBP;
       c1GvV: // global
           I64[Sp] = block_c1GvS_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1GDP; else goto c1GvW;
       u1GDP: // global
           call _c1GvS(R1) args: 0, res: 0, upd: 0;
       c1GvW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1GBP: // global
           Sp = Sp + 8;
           call _s1CYf() args: 0, res: 0, upd: 0;
     }
 },
 _c1GvS() //  [R1]
         { info_tbl: [(c1GvS,
                       label: block_c1GvS_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GvS: // global
           if (R1 & 7 == 1) goto u1GBQ; else goto c1Gw7;
       u1GBQ: // global
           Sp = Sp + 8;
           call _s1CYf() args: 0, res: 0, upd: 0;
       c1Gw7: // global
           I64[Sp] = block_c1Gw5_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1GDR; else goto c1Gw8;
       u1GDR: // global
           call _c1Gw5(R1) args: 0, res: 0, upd: 0;
       c1Gw8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gw5() //  [R1]
         { info_tbl: [(c1Gw5,
                       label: block_c1Gw5_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gw5: // global
           if (R1 & 7 == 1) goto u1GBR; else goto c1Gwj;
       u1GBR: // global
           Sp = Sp + 8;
           call _s1CYf() args: 0, res: 0, upd: 0;
       c1Gwj: // global
           I64[Sp - 8] = block_c1Gwh_info;
           _s1CYC::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CYC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GDT; else goto c1Gwk;
       u1GDT: // global
           call _c1Gwh(R1) args: 0, res: 0, upd: 0;
       c1Gwk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gwh() //  [R1]
         { info_tbl: [(c1Gwh,
                       label: block_c1Gwh_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gwh: // global
           if (R1 & 7 == 1) goto u1GBS; else goto c1GwA;
       u1GBS: // global
           Sp = Sp + 16;
           call _s1CYf() args: 0, res: 0, upd: 0;
       c1GwA: // global
           I64[Sp] = block_c1Gwt_info;
           _s1CYE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CYE::P64;
           if (R1 & 7 != 0) goto u1GDV; else goto c1Gwu;
       u1GDV: // global
           call _c1Gwt(R1) args: 0, res: 0, upd: 0;
       c1Gwu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gwt() //  [R1]
         { info_tbl: [(c1Gwt,
                       label: block_c1Gwt_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gwt: // global
           I64[Sp] = block_c1Gwy_info;
           _s1CYG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CYG::I64;
           if (R1 & 7 != 0) goto u1GDX; else goto c1GwC;
       u1GDX: // global
           call _c1Gwy(R1) args: 0, res: 0, upd: 0;
       c1GwC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gwy() //  [R1]
         { info_tbl: [(c1Gwy,
                       label: block_c1Gwy_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gwy: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1GBU; else goto u1GBT;
       u1GBU: // global
           Sp = Sp + 16;
           call _s1CYf() args: 0, res: 0, upd: 0;
       u1GBT: // global
           Sp = Sp + 16;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gxg() //  [R1]
         { info_tbl: [(c1Gxg,
                       label: block_c1Gxg_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gxg: // global
           I64[Sp] = block_c1Gxl_info;
           _s1CYQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CYQ::I64;
           if (R1 & 7 != 0) goto u1GE4; else goto c1Gxp;
       u1GE4: // global
           call _c1Gxl(R1) args: 0, res: 0, upd: 0;
       c1Gxp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gxl() //  [R1]
         { info_tbl: [(c1Gxl,
                       label: block_c1Gxl_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gxl: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1GBO; else goto u1GBN;
       u1GBO: // global
           Sp = Sp + 16;
           call _s1CYf() args: 0, res: 0, upd: 0;
       u1GBN: // global
           Sp = Sp + 16;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYf: // global
           I64[Sp - 8] = block_c1GmL_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEG; else goto c1GmM;
       u1GEG: // global
           call _c1GmL(R1) args: 0, res: 0, upd: 0;
       c1GmM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GmL() //  [R1]
         { info_tbl: [(c1GmL,
                       label: block_c1GmL_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GmL: // global
           if (R1 & 7 == 1) goto u1GBV; else goto c1Gvo;
       u1GBV: // global
           Sp = Sp + 8;
           call _s1CYg() args: 0, res: 0, upd: 0;
       c1Gvo: // global
           I64[Sp] = block_c1GmR_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1GCG; else goto c1GmS;
       u1GCG: // global
           call _c1GmR(R1) args: 0, res: 0, upd: 0;
       c1GmS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GmR() //  [R1]
         { info_tbl: [(c1GmR,
                       label: block_c1GmR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GmR: // global
           if (R1 & 7 == 1) goto c1Gvr; else goto u1GBW;
       c1Gvr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Gvu; else goto c1Gvt;
       c1Gvu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gvt: // global
           I64[Hp - 16] = sat_s1CYv_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1Gvp_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
       u1GBW: // global
           Sp = Sp + 8;
           call _s1CYg() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gvp() //  [R1]
         { info_tbl: [(c1Gvp,
                       label: block_c1Gvp_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gvp: // global
           if (R1 & 7 == 1) goto u1GBX; else goto u1GBY;
       u1GBX: // global
           Sp = Sp + 80;
           call _c1GvA() args: 0, res: 0, upd: 0;
       u1GBY: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CYg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CYg: // global
           I64[Sp - 8] = block_c1GlR_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEH; else goto c1GlS;
       u1GEH: // global
           call _c1GlR(R1) args: 0, res: 0, upd: 0;
       c1GlS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GlR() //  [R1]
         { info_tbl: [(c1GlR,
                       label: block_c1GlR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GlR: // global
           if (R1 & 7 == 1) goto u1GBZ; else goto c1GuT;
       u1GBZ: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       c1GuT: // global
           I64[Sp] = block_c1GlX_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1GCB; else goto c1GlY;
       u1GCB: // global
           call _c1GlX(R1) args: 0, res: 0, upd: 0;
       c1GlY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GlX() //  [R1]
         { info_tbl: [(c1GlX,
                       label: block_c1GlX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GlX: // global
           if (R1 & 7 == 1) goto u1GC0; else goto c1GuZ;
       u1GC0: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       c1GuZ: // global
           I64[Sp] = block_c1Gm3_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1GCD; else goto c1Gm4;
       u1GCD: // global
           call _c1Gm3(R1) args: 0, res: 0, upd: 0;
       c1Gm4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gm3() //  [R1]
         { info_tbl: [(c1Gm3,
                       label: block_c1Gm3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gm3: // global
           if (R1 & 7 == 1) goto u1GC1; else goto c1Gv5;
       u1GC1: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
       c1Gv5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1Gv8; else goto c1Gv7;
       c1Gv8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gv7: // global
           _s1CYl::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_s1CYr_info;
           P64[Hp - 16] = P64[Sp + 56];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s1CYl::P64;
           I64[Sp] = block_c1Gv4_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1Gv4() //  [R1]
         { info_tbl: [(c1Gv4,
                       label: block_c1Gv4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gv4: // global
           if (R1 & 7 == 1) goto u1GC2; else goto u1GC3;
       u1GC2: // global
           Sp = Sp + 80;
           call _c1GvA() args: 0, res: 0, upd: 0;
       u1GC3: // global
           Sp = Sp + 8;
           call _s1CWM() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWM: // global
           I64[Sp - 8] = block_c1Gni_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEu; else goto c1GtM;
       u1GEu: // global
           call _c1Gni(R1) args: 0, res: 0, upd: 0;
       c1GtM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gni() //  [R1]
         { info_tbl: [(c1Gni,
                       label: block_c1Gni_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gni: // global
           _s1CWH::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1GtT; else goto c1Gu9;
       c1GtT: // global
           I64[Sp] = block_c1GtQ_info;
           R1 = _s1CWH::P64;
           if (R1 & 7 != 0) goto u1GCL; else goto c1GtU;
       u1GCL: // global
           call _c1GtQ(R1) args: 0, res: 0, upd: 0;
       c1GtU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1Gu9: // global
           I64[Sp - 8] = block_c1Gu7_info;
           _s1CY1::P64 = P64[R1 + 6];
           R1 = _s1CWH::P64;
           P64[Sp] = _s1CY1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GCM; else goto c1Gua;
       u1GCM: // global
           call _c1Gu7(R1) args: 0, res: 0, upd: 0;
       c1Gua: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GtQ() //  [R1]
         { info_tbl: [(c1GtQ,
                       label: block_c1GtQ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GtQ: // global
           if (R1 & 7 == 1) goto u1GC7; else goto u1GC8;
       u1GC7: // global
           Sp = Sp + 8;
           call _s1CXU() args: 0, res: 0, upd: 0;
       u1GC8: // global
           Sp = Sp + 8;
           call _s1CWN() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gu7() //  [R1]
         { info_tbl: [(c1Gu7,
                       label: block_c1Gu7_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gu7: // global
           if (R1 & 7 == 1) goto u1GC4; else goto c1Guq;
       u1GC4: // global
           Sp = Sp + 16;
           call _s1CWN() args: 0, res: 0, upd: 0;
       c1Guq: // global
           I64[Sp] = block_c1Guj_info;
           _s1CY3::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CY3::P64;
           if (R1 & 7 != 0) goto u1GDA; else goto c1Guk;
       u1GDA: // global
           call _c1Guj(R1) args: 0, res: 0, upd: 0;
       c1Guk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Guj() //  [R1]
         { info_tbl: [(c1Guj,
                       label: block_c1Guj_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Guj: // global
           I64[Sp] = block_c1Guo_info;
           _s1CY5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CY5::I64;
           if (R1 & 7 != 0) goto u1GDC; else goto c1Gus;
       u1GDC: // global
           call _c1Guo(R1) args: 0, res: 0, upd: 0;
       c1Gus: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Guo() //  [R1]
         { info_tbl: [(c1Guo,
                       label: block_c1Guo_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Guo: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u1GC5; else goto u1GC6;
       u1GC5: // global
           Sp = Sp + 16;
           call _s1CXU() args: 0, res: 0, upd: 0;
       u1GC6: // global
           Sp = Sp + 16;
           call _s1CWN() args: 0, res: 0, upd: 0;
     }
 },
 _s1CXU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CXU: // global
           I64[Sp - 8] = block_c1Gt5_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEC; else goto c1Gt7;
       u1GEC: // global
           call _c1Gt5(R1) args: 0, res: 0, upd: 0;
       c1Gt7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gt5() //  [R1]
         { info_tbl: [(c1Gt5,
                       label: block_c1Gt5_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gt5: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1Gte; else goto c1Gtx;
       c1Gte: // global
           I64[Sp] = block_c1Gtb_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1GDu; else goto c1Gtf;
       u1GDu: // global
           call _c1Gtb(R1) args: 0, res: 0, upd: 0;
       c1Gtf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1Gtx: // global
           I64[Sp] = block_c1Gtv_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1GDv; else goto c1Gty;
       u1GDv: // global
           call _c1Gtv(R1) args: 0, res: 0, upd: 0;
       c1Gty: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gtb() //  [R1]
         { info_tbl: [(c1Gtb,
                       label: block_c1Gtb_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gtb: // global
           if (R1 & 7 == 1) goto c1Gtl; else goto u1GCa;
       c1Gtl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gto; else goto c1Gtn;
       c1Gto: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gtn: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1GCa: // global
           Sp = Sp + 8;
           call _s1CWN() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gtv() //  [R1]
         { info_tbl: [(c1Gtv,
                       label: block_c1Gtv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gtv: // global
           if (R1 & 7 == 1) goto u1GC9; else goto c1GtI;
       u1GC9: // global
           Sp = Sp + 8;
           call _s1CWN() args: 0, res: 0, upd: 0;
       c1GtI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1GtL; else goto c1GtK;
       c1GtL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1GtK: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1CWN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWN: // global
           I64[Sp - 8] = block_c1Gnk_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEv; else goto c1GsC;
       u1GEv: // global
           call _c1Gnk(R1) args: 0, res: 0, upd: 0;
       c1GsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gnk() //  [R1]
         { info_tbl: [(c1Gnk,
                       label: block_c1Gnk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gnk: // global
           if (R1 & 7 == 1) goto u1GCb; else goto c1GsN;
       u1GCb: // global
           Sp = Sp + 8;
           call _s1CWP() args: 0, res: 0, upd: 0;
       c1GsN: // global
           I64[Sp] = block_c1GsL_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1GCN; else goto c1GsO;
       u1GCN: // global
           call _c1GsL(R1) args: 0, res: 0, upd: 0;
       c1GsO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GsL() //  [R1]
         { info_tbl: [(c1GsL,
                       label: block_c1GsL_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GsL: // global
           if (R1 & 7 == 1) goto c1GsU; else goto u1GCc;
       c1GsU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1GsX; else goto c1GsW;
       c1GsX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1GsW: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1GCc: // global
           Sp = Sp + 8;
           call _s1CWP() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWP: // global
           I64[Sp - 8] = block_c1Gnm_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEw; else goto c1Gs0;
       u1GEw: // global
           call _c1Gnm(R1) args: 0, res: 0, upd: 0;
       c1Gs0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gnm() //  [R1]
         { info_tbl: [(c1Gnm,
                       label: block_c1Gnm_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gnm: // global
           if (R1 & 7 == 1) goto c1Gs7; else goto u1GCd;
       c1Gs7: // global
           I64[Sp] = block_c1Gs4_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1GCP; else goto c1Gs8;
       u1GCP: // global
           call _c1Gs4(R1) args: 0, res: 0, upd: 0;
       c1Gs8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1GCd: // global
           Sp = Sp + 8;
           call _s1CWR() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gs4() //  [R1]
         { info_tbl: [(c1Gs4,
                       label: block_c1Gs4_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gs4: // global
           if (R1 & 7 == 1) goto c1Gsf; else goto u1GCe;
       c1Gsf: // global
           I64[Sp] = block_c1Gsc_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1GDq; else goto c1Gsg;
       u1GDq: // global
           call _c1Gsc(R1) args: 0, res: 0, upd: 0;
       c1Gsg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1GCe: // global
           Sp = Sp + 8;
           call _s1CWR() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gsc() //  [R1]
         { info_tbl: [(c1Gsc,
                       label: block_c1Gsc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gsc: // global
           if (R1 & 7 == 1) goto c1Gsm; else goto u1GCf;
       c1Gsm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gsp; else goto c1Gso;
       c1Gsp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gso: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1GCf: // global
           Sp = Sp + 8;
           call _s1CWR() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWR: // global
           I64[Sp - 8] = block_c1Gns_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEx; else goto c1Grr;
       u1GEx: // global
           call _c1Gns(R1) args: 0, res: 0, upd: 0;
       c1Grr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gns() //  [R1]
         { info_tbl: [(c1Gns,
                       label: block_c1Gns_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gns: // global
           _s1CWG::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1Gry; else goto c1GrO;
       c1Gry: // global
           I64[Sp] = block_c1Grv_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1GCR; else goto c1Grz;
       u1GCR: // global
           call _c1Grv(R1) args: 0, res: 0, upd: 0;
       c1Grz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1GrO: // global
           I64[Sp] = block_c1GrM_info;
           R1 = _s1CWG::P64;
           if (R1 & 7 != 0) goto u1GCS; else goto c1GrP;
       u1GCS: // global
           call _c1GrM(R1) args: 0, res: 0, upd: 0;
       c1GrP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Grv() //  [R1]
         { info_tbl: [(c1Grv,
                       label: block_c1Grv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Grv: // global
           if (R1 & 7 == 1) goto u1GCi; else goto u1GCj;
       u1GCi: // global
           Sp = Sp + 8;
           call _s1CXA() args: 0, res: 0, upd: 0;
       u1GCj: // global
           Sp = Sp + 8;
           call _s1CXn() args: 0, res: 0, upd: 0;
     }
 },
 _c1GrM() //  [R1]
         { info_tbl: [(c1GrM,
                       label: block_c1GrM_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GrM: // global
           if (R1 & 7 == 1) goto u1GCg; else goto u1GCh;
       u1GCg: // global
           Sp = Sp + 8;
           call _s1CXn() args: 0, res: 0, upd: 0;
       u1GCh: // global
           Sp = Sp + 8;
           call _s1CXA() args: 0, res: 0, upd: 0;
     }
 },
 _s1CXA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CXA: // global
           I64[Sp - 8] = block_c1GqG_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEB; else goto c1GqI;
       u1GEB: // global
           call _c1GqG(R1) args: 0, res: 0, upd: 0;
       c1GqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GqG() //  [R1]
         { info_tbl: [(c1GqG,
                       label: block_c1GqG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GqG: // global
           if (R1 & 7 == 1) goto u1GCk; else goto c1GqT;
       u1GCk: // global
           Sp = Sp + 8;
           call _s1CXn() args: 0, res: 0, upd: 0;
       c1GqT: // global
           I64[Sp - 8] = block_c1GqR_info;
           _s1CXC::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CXC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GDf; else goto c1GqU;
       u1GDf: // global
           call _c1GqR(R1) args: 0, res: 0, upd: 0;
       c1GqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GqR() //  [R1]
         { info_tbl: [(c1GqR,
                       label: block_c1GqR_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GqR: // global
           if (R1 & 7 == 1) goto u1GCl; else goto c1Gra;
       u1GCl: // global
           Sp = Sp + 16;
           call _s1CXn() args: 0, res: 0, upd: 0;
       c1Gra: // global
           I64[Sp] = block_c1Gr3_info;
           _s1CXE::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CXE::P64;
           if (R1 & 7 != 0) goto u1GDh; else goto c1Gr4;
       u1GDh: // global
           call _c1Gr3(R1) args: 0, res: 0, upd: 0;
       c1Gr4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _s1CXn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CXn: // global
           I64[Sp - 8] = block_c1Gpu_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEA; else goto c1Gpw;
       u1GEA: // global
           call _c1Gpu(R1) args: 0, res: 0, upd: 0;
       c1Gpw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gpu() //  [R1]
         { info_tbl: [(c1Gpu,
                       label: block_c1Gpu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gpu: // global
           if (R1 & 7 == 1) goto c1GpD; else goto u1GCn;
       c1GpD: // global
           I64[Sp] = block_c1GpA_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1GD5; else goto c1GpE;
       u1GD5: // global
           call _c1GpA(R1) args: 0, res: 0, upd: 0;
       c1GpE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1GCn: // global
           Sp = Sp + 8;
           call _s1CWT() args: 0, res: 0, upd: 0;
     }
 },
 _c1GpA() //  [R1]
         { info_tbl: [(c1GpA,
                       label: block_c1GpA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GpA: // global
           if (R1 & 7 == 1) goto u1GCo; else goto c1GpP;
       u1GCo: // global
           Sp = Sp + 8;
           call _s1CWT() args: 0, res: 0, upd: 0;
       c1GpP: // global
           I64[Sp] = block_c1GpN_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1GD7; else goto c1GpQ;
       u1GD7: // global
           call _c1GpN(R1) args: 0, res: 0, upd: 0;
       c1GpQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GpN() //  [R1]
         { info_tbl: [(c1GpN,
                       label: block_c1GpN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GpN: // global
           if (R1 & 7 == 1) goto u1GCp; else goto c1Gq1;
       u1GCp: // global
           Sp = Sp + 8;
           call _s1CWT() args: 0, res: 0, upd: 0;
       c1Gq1: // global
           I64[Sp - 8] = block_c1GpZ_info;
           _s1CXs::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1CXs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GD9; else goto c1Gq2;
       u1GD9: // global
           call _c1GpZ(R1) args: 0, res: 0, upd: 0;
       c1Gq2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GpZ() //  [R1]
         { info_tbl: [(c1GpZ,
                       label: block_c1GpZ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GpZ: // global
           if (R1 & 7 == 1) goto u1GCq; else goto c1Gqi;
       u1GCq: // global
           Sp = Sp + 16;
           call _s1CWT() args: 0, res: 0, upd: 0;
       c1Gqi: // global
           I64[Sp] = block_c1Gqb_info;
           _s1CXu::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1CXu::P64;
           if (R1 & 7 != 0) goto u1GDb; else goto c1Gqc;
       u1GDb: // global
           call _c1Gqb(R1) args: 0, res: 0, upd: 0;
       c1Gqc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gqb() //  [R1]
         { info_tbl: [(c1Gqb,
                       label: block_c1Gqb_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gqb: // global
           I64[Sp] = block_c1Gqg_info;
           _s1CXw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CXw::I64;
           if (R1 & 7 != 0) goto u1GDd; else goto c1Gqk;
       u1GDd: // global
           call _c1Gqg(R1) args: 0, res: 0, upd: 0;
       c1Gqk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gqg() //  [R1]
         { info_tbl: [(c1Gqg,
                       label: block_c1Gqg_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gqg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gqq; else goto c1Gqp;
       c1Gqq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gqp: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1GCr; else goto c1Gqy;
       u1GCr: // global
           Sp = Sp + 16;
           call _c1Grm() args: 0, res: 0, upd: 0;
       c1Gqy: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 6;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Gr3() //  [R1]
         { info_tbl: [(c1Gr3,
                       label: block_c1Gr3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gr3: // global
           I64[Sp] = block_c1Gr8_info;
           _s1CXG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1CXG::I64;
           if (R1 & 7 != 0) goto u1GDj; else goto c1Grc;
       u1GDj: // global
           call _c1Gr8(R1) args: 0, res: 0, upd: 0;
       c1Grc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gr8() //  [R1]
         { info_tbl: [(c1Gr8,
                       label: block_c1Gr8_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gr8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gri; else goto c1Grh;
       c1Gri: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Grh: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1GCm; else goto c1Grq;
       u1GCm: // global
           Sp = Sp + 16;
           call _c1Grm() args: 0, res: 0, upd: 0;
       c1Grq: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 6;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Grm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Grm: // global
           Hp = Hp - 16;
           call _s1CWT() args: 0, res: 0, upd: 0;
     }
 },
 _s1CWT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWT: // global
           I64[Sp - 8] = block_c1Gnu_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEy; else goto c1Goh;
       u1GEy: // global
           call _c1Gnu(R1) args: 0, res: 0, upd: 0;
       c1Goh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gnu() //  [R1]
         { info_tbl: [(c1Gnu,
                       label: block_c1Gnu_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gnu: // global
           if (R1 & 7 == 1) goto u1GCs; else goto c1Gos;
       u1GCs: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1Gos: // global
           I64[Sp] = block_c1Goq_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1GCT; else goto c1Got;
       u1GCT: // global
           call _c1Goq(R1) args: 0, res: 0, upd: 0;
       c1Got: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Goq() //  [R1]
         { info_tbl: [(c1Goq,
                       label: block_c1Goq_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Goq: // global
           if (R1 & 7 == 1) goto c1GoA; else goto u1GCt;
       c1GoA: // global
           I64[Sp] = block_c1Gox_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1GCX; else goto c1GoB;
       u1GCX: // global
           call _c1Gox(R1) args: 0, res: 0, upd: 0;
       c1GoB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1GCt: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
     }
 },
 _c1Gox() //  [R1]
         { info_tbl: [(c1Gox,
                       label: block_c1Gox_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gox: // global
           if (R1 & 7 == 1) goto u1GCu; else goto c1GoM;
       u1GCu: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1GoM: // global
           I64[Sp] = block_c1GoK_info;
           _s1CXe::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 40] = _s1CXe::P64;
           if (R1 & 7 != 0) goto u1GCZ; else goto c1GoN;
       u1GCZ: // global
           call _c1GoK(R1) args: 0, res: 0, upd: 0;
       c1GoN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GoK() //  [R1]
         { info_tbl: [(c1GoK,
                       label: block_c1GoK_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GoK: // global
           if (R1 & 7 == 1) goto u1GCv; else goto c1Gp3;
       u1GCv: // global
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1Gp3: // global
           I64[Sp] = block_c1GoW_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u1GD1; else goto c1GoX;
       u1GD1: // global
           call _c1GoW(R1) args: 0, res: 0, upd: 0;
       c1GoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1GoW() //  [R1]
         { info_tbl: [(c1GoW,
                       label: block_c1GoW_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GoW: // global
           I64[Sp] = block_c1Gp1_info;
           _s1CXi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _s1CXi::I64;
           if (R1 & 7 != 0) goto u1GD3; else goto c1Gp5;
       u1GD3: // global
           call _c1Gp1(R1) args: 0, res: 0, upd: 0;
       c1Gp5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gp1() //  [R1]
         { info_tbl: [(c1Gp1,
                       label: block_c1Gp1_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gp1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gpb; else goto c1Gpa;
       c1Gpb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gpa: // global
           if (%MO_S_Gt_W64(I64[R1 + 7],
                            I64[Sp + 40] + 1)) goto c1Gpi; else goto c1Gpm;
       c1Gpi: // global
           Hp = Hp - 16;
           Sp = Sp + 8;
           call _s1CWU() args: 0, res: 0, upd: 0;
       c1Gpm: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1CWU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1CWU: // global
           I64[Sp - 8] = block_c1Gk9_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1GEz; else goto c1Gka;
       u1GEz: // global
           call _c1Gk9(R1) args: 0, res: 0, upd: 0;
       c1Gka: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gk9() //  [R1]
         { info_tbl: [(c1Gk9,
                       label: block_c1Gk9_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gk9: // global
           if (R1 & 7 == 1) goto c1GnA; else goto c1GnF;
       c1GnA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1GnD; else goto c1GnC;
       c1GnD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1GnC: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1GnF: // global
           I64[Sp] = block_c1Gkf_info;
           _s1CWX::P64 = P64[R1 + 6];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s1CWX::P64;
           if (R1 & 7 != 0) goto u1GCA; else goto c1Gkg;
       u1GCA: // global
           call _c1Gkf(R1) args: 0, res: 0, upd: 0;
       c1Gkg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Gkf() //  [R1]
         { info_tbl: [(c1Gkf,
                       label: block_c1Gkf_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Gkf: // global
           _c1Gjr::P64 = P64[Sp + 24];
           _c1Gjy::P64 = P64[Sp + 8];
           _s1CWy::P64 = P64[Sp + 56];
           _s1CWA::P64 = P64[Sp + 72];
           _s1CWX::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1GnI; else goto c1Go0;
       c1GnI: // global
           Hp = Hp + 40;
           _s1CWY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1Go3; else goto c1GnK;
       c1GnK: // global
           I64[Hp - 32] = sat_s1CX1_info;
           P64[Hp - 16] = _s1CWy::P64;
           P64[Hp - 8] = _c1Gjr::P64;
           P64[Hp] = _s1CWX::P64;
           I64[Sp + 40] = block_c1GnG_info;
           R2 = _c1Gjy::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _s1CWA::P64;
           P64[Sp + 32] = Hp - 32;
           Sp = Sp + 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
       c1Go0: // global
           Hp = Hp + 40;
           _s1CWY::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1Go3; else goto c1Go2;
       c1Go3: // global
           HpAlloc = 40;
           R1 = _s1CWY::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Go2: // global
           I64[Hp - 32] = sat_s1CX9_info;
           P64[Hp - 16] = _s1CWy::P64;
           P64[Hp - 8] = _c1Gjr::P64;
           P64[Hp] = _s1CWX::P64;
           I64[Sp + 40] = block_c1GnZ_info;
           R2 = _c1Gjy::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _s1CWA::P64;
           P64[Sp + 32] = Hp - 32;
           Sp = Sp + 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1GnG() //  [R1]
         { info_tbl: [(c1GnG,
                       label: block_c1GnG_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GnG: // global
           if (R1 & 7 == 1) goto u1GCy; else goto c1GnV;
       u1GCy: // global
           Sp = Sp + 40;
           call _c1GvA() args: 0, res: 0, upd: 0;
       c1GnV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1GnY; else goto c1GnX;
       c1GnY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1GnX: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1GnZ() //  [R1]
         { info_tbl: [(c1GnZ,
                       label: block_c1GnZ_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GnZ: // global
           if (R1 & 7 == 1) goto u1GCx; else goto c1God;
       u1GCx: // global
           Sp = Sp + 40;
           call _c1GvA() args: 0, res: 0, upd: 0;
       c1God: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Gog; else goto c1Gof;
       c1Gog: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Gof: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1GvA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GvA: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.911163927 UTC

[section ""cstring" . Data.Bits.$trModule4_bytes" {
     Data.Bits.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.913388462 UTC

[section ""data" . Data.Bits.$trModule3_closure" {
     Data.Bits.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.915115901 UTC

[section ""cstring" . Data.Bits.$trModule2_bytes" {
     Data.Bits.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.916750997 UTC

[section ""data" . Data.Bits.$trModule1_closure" {
     Data.Bits.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.918708324 UTC

[section ""data" . Data.Bits.$trModule_closure" {
     Data.Bits.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bits.$trModule3_closure+1;
         const Data.Bits.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.920510808 UTC

[section ""data" . $krep_r1CDE_closure" {
     $krep_r1CDE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.922725215 UTC

[section ""data" . $krep1_r1CDF_closure" {
     $krep1_r1CDF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.924420478 UTC

[section ""data" . $krep2_r1CDG_closure" {
     $krep2_r1CDG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.926207675 UTC

[section ""data" . $krep3_r1CDH_closure" {
     $krep3_r1CDH_closure:
         const :_con_info;
         const $krep1_r1CDF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.927886597 UTC

[section ""data" . $krep4_r1CDI_closure" {
     $krep4_r1CDI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep3_r1CDH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.929980576 UTC

[section ""data" . $krep5_r1CDJ_closure" {
     $krep5_r1CDJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1CDF_closure+1;
         const $krep_r1CDE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.931722363 UTC

[section ""data" . Data.Bits.$tcBits1_closure" {
     Data.Bits.$tcBits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep2_r1CDG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.933765447 UTC

[section ""data" . $krep6_r1CDK_closure" {
     $krep6_r1CDK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.935467413 UTC

[section ""data" . $krep7_r1CDL_closure" {
     $krep7_r1CDL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep6_r1CDK_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.937616461 UTC

[section ""data" . $krep8_r1CDM_closure" {
     $krep8_r1CDM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep7_r1CDL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.939392164 UTC

[section ""data" . $krep9_r1CDN_closure" {
     $krep9_r1CDN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep5_r1CDJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.941102569 UTC

[section ""data" . $krep10_r1CDO_closure" {
     $krep10_r1CDO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep4_r1CDI_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.943162687 UTC

[section ""data" . $krep11_r1CDP_closure" {
     $krep11_r1CDP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep1_r1CDF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.944907208 UTC

[section ""data" . $krep12_r1CDQ_closure" {
     $krep12_r1CDQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep_r1CDE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.947047028 UTC

[section ""data" . $krep13_r1CDR_closure" {
     $krep13_r1CDR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1CDF_closure+1;
         const $krep6_r1CDK_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.948713076 UTC

[section ""data" . $krep14_r1CDS_closure" {
     $krep14_r1CDS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep13_r1CDR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.950449521 UTC

[section ""data" . $krep15_r1CDT_closure" {
     $krep15_r1CDT_closure:
         const :_con_info;
         const $krep6_r1CDK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.95218159 UTC

[section ""data" . $krep16_r1CDU_closure" {
     $krep16_r1CDU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Classes.$tcEq_closure;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.954346623 UTC

[section ""cstring" . Data.Bits.$tcBits3_bytes" {
     Data.Bits.$tcBits3_bytes:
         I8[] [66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.956051047 UTC

[section ""data" . Data.Bits.$tcBits2_closure" {
     Data.Bits.$tcBits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tcBits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.958191185 UTC

[section ""data" . Data.Bits.$tcBits_closure" {
     Data.Bits.$tcBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tcBits2_closure+1;
         const Data.Bits.$tcBits1_closure+4;
         const 7088815172979416363;
         const 4990916430057605838;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.960063839 UTC

[section ""data" . $krep17_r1CDV_closure" {
     $krep17_r1CDV_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Bits.$tcBits_closure+1;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.961775849 UTC

[section ""data" . $krep18_r1CDW_closure" {
     $krep18_r1CDW_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep17_r1CDV_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.96382435 UTC

[section ""data" . $krep19_r1CDX_closure" {
     $krep19_r1CDX_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep18_r1CDW_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.96593629 UTC

[section ""data" . $krep20_r1CDY_closure" {
     $krep20_r1CDY_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep19_r1CDX_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.967553732 UTC

[section ""data" . $krep21_r1CDZ_closure" {
     $krep21_r1CDZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep20_r1CDY_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.969339339 UTC

[section ""data" . $krep22_r1CE0_closure" {
     $krep22_r1CE0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep21_r1CDZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.971455237 UTC

[section ""data" . $krep23_r1CE1_closure" {
     $krep23_r1CE1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep22_r1CE0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.973135241 UTC

[section ""data" . $krep24_r1CE2_closure" {
     $krep24_r1CE2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep23_r1CE1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.974907141 UTC

[section ""data" . $krep25_r1CE3_closure" {
     $krep25_r1CE3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r1CDQ_closure+4;
         const $krep24_r1CE2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.976587487 UTC

[section ""data" . $krep26_r1CE4_closure" {
     $krep26_r1CE4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep25_r1CE3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.978599935 UTC

[section ""data" . $krep27_r1CE5_closure" {
     $krep27_r1CE5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1CDO_closure+4;
         const $krep26_r1CE4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.980634303 UTC

[section ""data" . $krep28_r1CE6_closure" {
     $krep28_r1CE6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r1CDN_closure+4;
         const $krep27_r1CE5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.982369511 UTC

[section ""data" . $krep29_r1CE7_closure" {
     $krep29_r1CE7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep28_r1CE6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.984074292 UTC

[section ""data" . $krep30_r1CE8_closure" {
     $krep30_r1CE8_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep29_r1CE7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.985750299 UTC

[section ""data" . $krep31_r1CE9_closure" {
     $krep31_r1CE9_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep30_r1CE8_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.987757335 UTC

[section ""data" . $krep32_r1CEa_closure" {
     $krep32_r1CEa_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_r1CDR_closure+4;
         const $krep31_r1CE9_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.989688963 UTC

[section ""data" . $krep33_r1CEb_closure" {
     $krep33_r1CEb_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep32_r1CEa_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.991352846 UTC

[section ""data" . $krep34_r1CEc_closure" {
     $krep34_r1CEc_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep33_r1CEb_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.99298654 UTC

[section ""data" . $krep35_r1CEd_closure" {
     $krep35_r1CEd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep34_r1CEc_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.994718936 UTC

[section ""data" . $krep36_r1CEe_closure" {
     $krep36_r1CEe_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1CDL_closure+4;
         const $krep35_r1CEd_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.996718868 UTC

[section ""data" . $krep37_r1CEf_closure" {
     $krep37_r1CEf_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep36_r1CEe_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:24.998717971 UTC

[section ""data" . $krep38_r1CEg_closure" {
     $krep38_r1CEg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep37_r1CEf_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.000311612 UTC

[section ""data" . $krep39_r1CEh_closure" {
     $krep39_r1CEh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep38_r1CEg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.001998341 UTC

[section ""data" . Data.Bits.$tc'C:Bits1_closure" {
     Data.Bits.$tc'C:Bits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r1CDU_closure+1;
         const $krep39_r1CEh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.003655079 UTC

[section ""cstring" . Data.Bits.$tc'C:Bits3_bytes" {
     Data.Bits.$tc'C:Bits3_bytes:
         I8[] [39,67,58,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.005712864 UTC

[section ""data" . Data.Bits.$tc'C:Bits2_closure" {
     Data.Bits.$tc'C:Bits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tc'C:Bits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.007312985 UTC

[section ""data" . Data.Bits.$tc'C:Bits_closure" {
     Data.Bits.$tc'C:Bits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tc'C:Bits2_closure+1;
         const Data.Bits.$tc'C:Bits1_closure+4;
         const 744071653035646959;
         const 2574978498160477882;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.00910441 UTC

[section ""cstring" . Data.Bits.$tcFiniteBits2_bytes" {
     Data.Bits.$tcFiniteBits2_bytes:
         I8[] [70,105,110,105,116,101,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.010758205 UTC

[section ""data" . Data.Bits.$tcFiniteBits1_closure" {
     Data.Bits.$tcFiniteBits1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tcFiniteBits2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.012824288 UTC

[section ""data" . Data.Bits.$tcFiniteBits_closure" {
     Data.Bits.$tcFiniteBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tcFiniteBits1_closure+1;
         const Data.Bits.$tcBits1_closure+4;
         const 2363162769622202131;
         const 10110405838341883172;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.014938211 UTC

[section ""data" . $krep40_r1CEi_closure" {
     $krep40_r1CEi_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Bits.$tcFiniteBits_closure+1;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.016580241 UTC

[section ""data" . $krep41_r1CEj_closure" {
     $krep41_r1CEj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep40_r1CEi_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.018298399 UTC

[section ""data" . $krep42_r1CEk_closure" {
     $krep42_r1CEk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep41_r1CEj_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.019978537 UTC

[section ""data" . $krep43_r1CEl_closure" {
     $krep43_r1CEl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep42_r1CEk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.022533764 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits1_closure" {
     Data.Bits.$tc'C:FiniteBits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_r1CDV_closure+1;
         const $krep43_r1CEl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.024205339 UTC

[section ""cstring" . Data.Bits.$tc'C:FiniteBits3_bytes" {
     Data.Bits.$tc'C:FiniteBits3_bytes:
         I8[] [39,67,58,70,105,110,105,116,101,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.025910449 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits2_closure" {
     Data.Bits.$tc'C:FiniteBits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tc'C:FiniteBits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.02759122 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits_closure" {
     Data.Bits.$tc'C:FiniteBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tc'C:FiniteBits2_closure+1;
         const Data.Bits.$tc'C:FiniteBits1_closure+4;
         const 7500562306525175158;
         const 16051895206261500648;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.030177266 UTC

[section ""data" . Data.Bits.C:FiniteBits_closure" {
     Data.Bits.C:FiniteBits_closure:
         const Data.Bits.C:FiniteBits_info;
 },
 Data.Bits.C:FiniteBits_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1GPd,
                       label: Data.Bits.C:FiniteBits_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GPd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1GPh; else goto c1GPg;
       c1GPh: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.C:FiniteBits_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1GPg: // global
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.035064557 UTC

[section ""data" . Data.Bits.C:Bits_closure" {
     Data.Bits.C:Bits_closure:
         const Data.Bits.C:Bits_info;
 },
 Data.Bits.C:Bits_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GPo: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Bits.C:Bits_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2,
                                       R1) args: 152, res: 0, upd: 8;
     }
 },
 Data.Bits.C:Bits_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1GPt,
                       label: Data.Bits.C:Bits_info
                       rep:HeapRep static {
                             Fun {arity: 23
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GPt: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c1GPx; else goto c1GPw;
       c1GPx: // global
           HpAlloc = 192;
           R1 = Data.Bits.C:Bits_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 192, res: 0, upd: 8;
       c1GPw: // global
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           P64[Hp - 152] = R5;
           P64[Hp - 144] = R6;
           P64[Hp - 136] = P64[Sp];
           P64[Hp - 128] = P64[Sp + 8];
           P64[Hp - 120] = P64[Sp + 16];
           P64[Hp - 112] = P64[Sp + 24];
           P64[Hp - 104] = P64[Sp + 32];
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 48];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 72];
           P64[Hp - 56] = P64[Sp + 80];
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = P64[Sp + 96];
           P64[Hp - 32] = P64[Sp + 104];
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = P64[Sp + 136];
           R1 = Hp - 183;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.041664726 UTC

[Data.Bits.C:FiniteBits_con_entry() //  [R1]
         { info_tbl: [(c1GPX,
                       label: Data.Bits.C:FiniteBits_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,115,46,67,58,70,105,110,105,116,101,66,105,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GPX: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.044867222 UTC

[Data.Bits.C:Bits_con_entry() //  [R1]
         { info_tbl: [(c1GQ3,
                       label: Data.Bits.C:Bits_con_info
                       rep:HeapRep 23 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,115,46,67,58,66,105,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1GQ3: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:25.048555159 UTC

[section ""relreadonly" . S1D79_srt" {
     S1D79_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Bits.$fBitsInteger1_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const Data.Bits.$fBitsInteger_$cshift_closure;
         const Data.Bits.$w$cshift_closure;
         const sat_s1COy_closure;
         const Data.Bits.$fBitsInteger3_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure;
         const GHC.Integer.Type.complementInteger_closure;
         const Data.Bits.$fBitsInteger_$cclearBit_closure;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure;
         const Data.Bits.$fBitsInteger_$csetBit_closure;
         const Data.Bits.$fBitsInteger_$cshiftR_closure;
         const Data.Bits.$fBitsInteger_$crotateR_closure;
         const Data.Bits.bitDefault_closure;
         const Data.Bits.$fBitsInteger_$czeroBits_closure;
         const Data.Bits.testBitDefault_closure;
         const Data.Bits.$wpopCountDefault_closure;
         const Data.Bits.popCountDefault_closure;
         const GHC.Num.$fNumInteger_closure;
         const Data.Bits.$fBitsInteger_closure;
         const Data.Bits.$fBitsInteger_$cpopCount_closure;
         const Data.Bits.toIntegralSized_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.711881418 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:56:28.713507377 UTC

[section ""data" . Data.Bits.$p1FiniteBits_closure" {
     Data.Bits.$p1FiniteBits_closure:
         const Data.Bits.$p1FiniteBits_info;
 },
 Data.Bits.$p1FiniteBits_entry() //  [R2]
         { info_tbl: [(c1Hbd,
                       label: Data.Bits.$p1FiniteBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hbd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hbe; else goto c1Hbf;
       c1Hbe: // global
           R2 = R2;
           R1 = Data.Bits.$p1FiniteBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hbf: // global
           I64[Sp - 8] = block_c1Hba_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hbj; else goto c1Hbb;
       u1Hbj: // global
           call _c1Hba(R1) args: 0, res: 0, upd: 0;
       c1Hbb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hba() //  [R1]
         { info_tbl: [(c1Hba,
                       label: block_c1Hba_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hba: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.719578665 UTC

[section ""data" . Data.Bits.finiteBitSize_closure" {
     Data.Bits.finiteBitSize_closure:
         const Data.Bits.finiteBitSize_info;
 },
 Data.Bits.finiteBitSize_entry() //  [R2]
         { info_tbl: [(c1HbD,
                       label: Data.Bits.finiteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HbD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HbE; else goto c1HbF;
       c1HbE: // global
           R2 = R2;
           R1 = Data.Bits.finiteBitSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HbF: // global
           I64[Sp - 8] = block_c1HbA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HbJ; else goto c1HbB;
       u1HbJ: // global
           call _c1HbA(R1) args: 0, res: 0, upd: 0;
       c1HbB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HbA() //  [R1]
         { info_tbl: [(c1HbA,
                       label: block_c1HbA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HbA: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.726553196 UTC

[section ""data" . Data.Bits.countLeadingZeros_closure" {
     Data.Bits.countLeadingZeros_closure:
         const Data.Bits.countLeadingZeros_info;
 },
 Data.Bits.countLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1Hc1,
                       label: Data.Bits.countLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hc1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hc2; else goto c1Hc3;
       c1Hc2: // global
           R2 = R2;
           R1 = Data.Bits.countLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hc3: // global
           I64[Sp - 8] = block_c1HbY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hc7; else goto c1HbZ;
       u1Hc7: // global
           call _c1HbY(R1) args: 0, res: 0, upd: 0;
       c1HbZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HbY() //  [R1]
         { info_tbl: [(c1HbY,
                       label: block_c1HbY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HbY: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.732256522 UTC

[section ""data" . Data.Bits.countTrailingZeros_closure" {
     Data.Bits.countTrailingZeros_closure:
         const Data.Bits.countTrailingZeros_info;
 },
 Data.Bits.countTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1Hcp,
                       label: Data.Bits.countTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hcp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hcq; else goto c1Hcr;
       c1Hcq: // global
           R2 = R2;
           R1 = Data.Bits.countTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hcr: // global
           I64[Sp - 8] = block_c1Hcm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hcv; else goto c1Hcn;
       u1Hcv: // global
           call _c1Hcm(R1) args: 0, res: 0, upd: 0;
       c1Hcn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hcm() //  [R1]
         { info_tbl: [(c1Hcm,
                       label: block_c1Hcm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hcm: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.737990385 UTC

[section ""data" . Data.Bits.$p1Bits_closure" {
     Data.Bits.$p1Bits_closure:
         const Data.Bits.$p1Bits_info;
 },
 Data.Bits.$p1Bits_entry() //  [R2]
         { info_tbl: [(c1HcN,
                       label: Data.Bits.$p1Bits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HcN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HcO; else goto c1HcP;
       c1HcO: // global
           R2 = R2;
           R1 = Data.Bits.$p1Bits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HcP: // global
           I64[Sp - 8] = block_c1HcK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HcT; else goto c1HcL;
       u1HcT: // global
           call _c1HcK(R1) args: 0, res: 0, upd: 0;
       c1HcL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HcK() //  [R1]
         { info_tbl: [(c1HcK,
                       label: block_c1HcK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HcK: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.743817304 UTC

[section ""data" . Data.Bits..&._closure" {
     Data.Bits..&._closure:
         const Data.Bits..&._info;
 },
 Data.Bits..&._entry() //  [R2]
         { info_tbl: [(c1Hdd,
                       label: Data.Bits..&._info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hdd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hde; else goto c1Hdf;
       c1Hde: // global
           R2 = R2;
           R1 = Data.Bits..&._closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hdf: // global
           I64[Sp - 8] = block_c1Hda_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hdj; else goto c1Hdb;
       u1Hdj: // global
           call _c1Hda(R1) args: 0, res: 0, upd: 0;
       c1Hdb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hda() //  [R1]
         { info_tbl: [(c1Hda,
                       label: block_c1Hda_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hda: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.749906527 UTC

[section ""data" . Data.Bits..|._closure" {
     Data.Bits..|._closure:
         const Data.Bits..|._info;
 },
 Data.Bits..|._entry() //  [R2]
         { info_tbl: [(c1HdB,
                       label: Data.Bits..|._info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HdB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HdC; else goto c1HdD;
       c1HdC: // global
           R2 = R2;
           R1 = Data.Bits..|._closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HdD: // global
           I64[Sp - 8] = block_c1Hdy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HdH; else goto c1Hdz;
       u1HdH: // global
           call _c1Hdy(R1) args: 0, res: 0, upd: 0;
       c1Hdz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hdy() //  [R1]
         { info_tbl: [(c1Hdy,
                       label: block_c1Hdy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hdy: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.755727641 UTC

[section ""data" . Data.Bits.xor_closure" {
     Data.Bits.xor_closure:
         const Data.Bits.xor_info;
 },
 Data.Bits.xor_entry() //  [R2]
         { info_tbl: [(c1HdZ,
                       label: Data.Bits.xor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HdZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1He0; else goto c1He1;
       c1He0: // global
           R2 = R2;
           R1 = Data.Bits.xor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1He1: // global
           I64[Sp - 8] = block_c1HdW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1He5; else goto c1HdX;
       u1He5: // global
           call _c1HdW(R1) args: 0, res: 0, upd: 0;
       c1HdX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HdW() //  [R1]
         { info_tbl: [(c1HdW,
                       label: block_c1HdW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HdW: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.762105226 UTC

[section ""data" . Data.Bits.complement_closure" {
     Data.Bits.complement_closure:
         const Data.Bits.complement_info;
 },
 Data.Bits.complement_entry() //  [R2]
         { info_tbl: [(c1Hen,
                       label: Data.Bits.complement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hen: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Heo; else goto c1Hep;
       c1Heo: // global
           R2 = R2;
           R1 = Data.Bits.complement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hep: // global
           I64[Sp - 8] = block_c1Hek_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Het; else goto c1Hel;
       u1Het: // global
           call _c1Hek(R1) args: 0, res: 0, upd: 0;
       c1Hel: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hek() //  [R1]
         { info_tbl: [(c1Hek,
                       label: block_c1Hek_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hek: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.767847316 UTC

[section ""data" . Data.Bits.shift_closure" {
     Data.Bits.shift_closure:
         const Data.Bits.shift_info;
 },
 Data.Bits.shift_entry() //  [R2]
         { info_tbl: [(c1HeL,
                       label: Data.Bits.shift_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HeL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HeM; else goto c1HeN;
       c1HeM: // global
           R2 = R2;
           R1 = Data.Bits.shift_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HeN: // global
           I64[Sp - 8] = block_c1HeI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HeR; else goto c1HeJ;
       u1HeR: // global
           call _c1HeI(R1) args: 0, res: 0, upd: 0;
       c1HeJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HeI() //  [R1]
         { info_tbl: [(c1HeI,
                       label: block_c1HeI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HeI: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.773642748 UTC

[section ""data" . Data.Bits.rotate_closure" {
     Data.Bits.rotate_closure:
         const Data.Bits.rotate_info;
 },
 Data.Bits.rotate_entry() //  [R2]
         { info_tbl: [(c1Hf9,
                       label: Data.Bits.rotate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hf9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hfa; else goto c1Hfb;
       c1Hfa: // global
           R2 = R2;
           R1 = Data.Bits.rotate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hfb: // global
           I64[Sp - 8] = block_c1Hf6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hff; else goto c1Hf7;
       u1Hff: // global
           call _c1Hf6(R1) args: 0, res: 0, upd: 0;
       c1Hf7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hf6() //  [R1]
         { info_tbl: [(c1Hf6,
                       label: block_c1Hf6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hf6: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.779724894 UTC

[section ""data" . Data.Bits.zeroBits_closure" {
     Data.Bits.zeroBits_closure:
         const Data.Bits.zeroBits_info;
 },
 Data.Bits.zeroBits_entry() //  [R2]
         { info_tbl: [(c1Hfx,
                       label: Data.Bits.zeroBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hfx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hfy; else goto c1Hfz;
       c1Hfy: // global
           R2 = R2;
           R1 = Data.Bits.zeroBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hfz: // global
           I64[Sp - 8] = block_c1Hfu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HfD; else goto c1Hfv;
       u1HfD: // global
           call _c1Hfu(R1) args: 0, res: 0, upd: 0;
       c1Hfv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hfu() //  [R1]
         { info_tbl: [(c1Hfu,
                       label: block_c1Hfu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hfu: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.785501251 UTC

[section ""data" . Data.Bits.bit_closure" {
     Data.Bits.bit_closure:
         const Data.Bits.bit_info;
 },
 Data.Bits.bit_entry() //  [R2]
         { info_tbl: [(c1HfV,
                       label: Data.Bits.bit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HfV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HfW; else goto c1HfX;
       c1HfW: // global
           R2 = R2;
           R1 = Data.Bits.bit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HfX: // global
           I64[Sp - 8] = block_c1HfS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hg1; else goto c1HfT;
       u1Hg1: // global
           call _c1HfS(R1) args: 0, res: 0, upd: 0;
       c1HfT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HfS() //  [R1]
         { info_tbl: [(c1HfS,
                       label: block_c1HfS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HfS: // global
           R1 = P64[R1 + 71];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.791401101 UTC

[section ""data" . Data.Bits.setBit_closure" {
     Data.Bits.setBit_closure:
         const Data.Bits.setBit_info;
 },
 Data.Bits.setBit_entry() //  [R2]
         { info_tbl: [(c1Hgj,
                       label: Data.Bits.setBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hgj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hgk; else goto c1Hgl;
       c1Hgk: // global
           R2 = R2;
           R1 = Data.Bits.setBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hgl: // global
           I64[Sp - 8] = block_c1Hgg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hgp; else goto c1Hgh;
       u1Hgp: // global
           call _c1Hgg(R1) args: 0, res: 0, upd: 0;
       c1Hgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hgg() //  [R1]
         { info_tbl: [(c1Hgg,
                       label: block_c1Hgg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hgg: // global
           R1 = P64[R1 + 79];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.798400599 UTC

[section ""data" . Data.Bits.clearBit_closure" {
     Data.Bits.clearBit_closure:
         const Data.Bits.clearBit_info;
 },
 Data.Bits.clearBit_entry() //  [R2]
         { info_tbl: [(c1HgH,
                       label: Data.Bits.clearBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HgH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HgI; else goto c1HgJ;
       c1HgI: // global
           R2 = R2;
           R1 = Data.Bits.clearBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HgJ: // global
           I64[Sp - 8] = block_c1HgE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HgN; else goto c1HgF;
       u1HgN: // global
           call _c1HgE(R1) args: 0, res: 0, upd: 0;
       c1HgF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HgE() //  [R1]
         { info_tbl: [(c1HgE,
                       label: block_c1HgE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HgE: // global
           R1 = P64[R1 + 87];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.804063577 UTC

[section ""data" . Data.Bits.complementBit_closure" {
     Data.Bits.complementBit_closure:
         const Data.Bits.complementBit_info;
 },
 Data.Bits.complementBit_entry() //  [R2]
         { info_tbl: [(c1Hh5,
                       label: Data.Bits.complementBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hh5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hh6; else goto c1Hh7;
       c1Hh6: // global
           R2 = R2;
           R1 = Data.Bits.complementBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hh7: // global
           I64[Sp - 8] = block_c1Hh2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hhb; else goto c1Hh3;
       u1Hhb: // global
           call _c1Hh2(R1) args: 0, res: 0, upd: 0;
       c1Hh3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hh2() //  [R1]
         { info_tbl: [(c1Hh2,
                       label: block_c1Hh2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hh2: // global
           R1 = P64[R1 + 95];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.809906239 UTC

[section ""data" . Data.Bits.testBit_closure" {
     Data.Bits.testBit_closure:
         const Data.Bits.testBit_info;
 },
 Data.Bits.testBit_entry() //  [R2]
         { info_tbl: [(c1Hht,
                       label: Data.Bits.testBit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hht: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hhu; else goto c1Hhv;
       c1Hhu: // global
           R2 = R2;
           R1 = Data.Bits.testBit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hhv: // global
           I64[Sp - 8] = block_c1Hhq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hhz; else goto c1Hhr;
       u1Hhz: // global
           call _c1Hhq(R1) args: 0, res: 0, upd: 0;
       c1Hhr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hhq() //  [R1]
         { info_tbl: [(c1Hhq,
                       label: block_c1Hhq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hhq: // global
           R1 = P64[R1 + 103];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.815513491 UTC

[section ""data" . Data.Bits.bitSizeMaybe_closure" {
     Data.Bits.bitSizeMaybe_closure:
         const Data.Bits.bitSizeMaybe_info;
 },
 Data.Bits.bitSizeMaybe_entry() //  [R2]
         { info_tbl: [(c1HhR,
                       label: Data.Bits.bitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HhR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HhS; else goto c1HhT;
       c1HhS: // global
           R2 = R2;
           R1 = Data.Bits.bitSizeMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HhT: // global
           I64[Sp - 8] = block_c1HhO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HhX; else goto c1HhP;
       u1HhX: // global
           call _c1HhO(R1) args: 0, res: 0, upd: 0;
       c1HhP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HhO() //  [R1]
         { info_tbl: [(c1HhO,
                       label: block_c1HhO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HhO: // global
           R1 = P64[R1 + 111];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.82181382 UTC

[section ""data" . Data.Bits.bitSize_closure" {
     Data.Bits.bitSize_closure:
         const Data.Bits.bitSize_info;
 },
 Data.Bits.bitSize_entry() //  [R2]
         { info_tbl: [(c1Hif,
                       label: Data.Bits.bitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hif: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hig; else goto c1Hih;
       c1Hig: // global
           R2 = R2;
           R1 = Data.Bits.bitSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hih: // global
           I64[Sp - 8] = block_c1Hic_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hil; else goto c1Hid;
       u1Hil: // global
           call _c1Hic(R1) args: 0, res: 0, upd: 0;
       c1Hid: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hic() //  [R1]
         { info_tbl: [(c1Hic,
                       label: block_c1Hic_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hic: // global
           R1 = P64[R1 + 119];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.827766165 UTC

[section ""data" . Data.Bits.isSigned_closure" {
     Data.Bits.isSigned_closure:
         const Data.Bits.isSigned_info;
 },
 Data.Bits.isSigned_entry() //  [R2]
         { info_tbl: [(c1HiD,
                       label: Data.Bits.isSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HiD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HiE; else goto c1HiF;
       c1HiE: // global
           R2 = R2;
           R1 = Data.Bits.isSigned_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HiF: // global
           I64[Sp - 8] = block_c1HiA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HiJ; else goto c1HiB;
       u1HiJ: // global
           call _c1HiA(R1) args: 0, res: 0, upd: 0;
       c1HiB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HiA() //  [R1]
         { info_tbl: [(c1HiA,
                       label: block_c1HiA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HiA: // global
           R1 = P64[R1 + 127];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.833823345 UTC

[section ""data" . Data.Bits.shiftL_closure" {
     Data.Bits.shiftL_closure:
         const Data.Bits.shiftL_info;
 },
 Data.Bits.shiftL_entry() //  [R2]
         { info_tbl: [(c1Hj1,
                       label: Data.Bits.shiftL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hj1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hj2; else goto c1Hj3;
       c1Hj2: // global
           R2 = R2;
           R1 = Data.Bits.shiftL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hj3: // global
           I64[Sp - 8] = block_c1HiY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hj7; else goto c1HiZ;
       u1Hj7: // global
           call _c1HiY(R1) args: 0, res: 0, upd: 0;
       c1HiZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HiY() //  [R1]
         { info_tbl: [(c1HiY,
                       label: block_c1HiY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HiY: // global
           R1 = P64[R1 + 135];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.840008675 UTC

[section ""data" . Data.Bits.unsafeShiftL_closure" {
     Data.Bits.unsafeShiftL_closure:
         const Data.Bits.unsafeShiftL_info;
 },
 Data.Bits.unsafeShiftL_entry() //  [R2]
         { info_tbl: [(c1Hjp,
                       label: Data.Bits.unsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hjp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hjq; else goto c1Hjr;
       c1Hjq: // global
           R2 = R2;
           R1 = Data.Bits.unsafeShiftL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hjr: // global
           I64[Sp - 8] = block_c1Hjm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hjv; else goto c1Hjn;
       u1Hjv: // global
           call _c1Hjm(R1) args: 0, res: 0, upd: 0;
       c1Hjn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hjm() //  [R1]
         { info_tbl: [(c1Hjm,
                       label: block_c1Hjm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hjm: // global
           R1 = P64[R1 + 143];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.845733605 UTC

[section ""data" . Data.Bits.shiftR_closure" {
     Data.Bits.shiftR_closure:
         const Data.Bits.shiftR_info;
 },
 Data.Bits.shiftR_entry() //  [R2]
         { info_tbl: [(c1HjN,
                       label: Data.Bits.shiftR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HjN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HjO; else goto c1HjP;
       c1HjO: // global
           R2 = R2;
           R1 = Data.Bits.shiftR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HjP: // global
           I64[Sp - 8] = block_c1HjK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HjT; else goto c1HjL;
       u1HjT: // global
           call _c1HjK(R1) args: 0, res: 0, upd: 0;
       c1HjL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HjK() //  [R1]
         { info_tbl: [(c1HjK,
                       label: block_c1HjK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HjK: // global
           R1 = P64[R1 + 151];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.851804667 UTC

[section ""data" . Data.Bits.unsafeShiftR_closure" {
     Data.Bits.unsafeShiftR_closure:
         const Data.Bits.unsafeShiftR_info;
 },
 Data.Bits.unsafeShiftR_entry() //  [R2]
         { info_tbl: [(c1Hkb,
                       label: Data.Bits.unsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hkb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hkc; else goto c1Hkd;
       c1Hkc: // global
           R2 = R2;
           R1 = Data.Bits.unsafeShiftR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hkd: // global
           I64[Sp - 8] = block_c1Hk8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hkh; else goto c1Hk9;
       u1Hkh: // global
           call _c1Hk8(R1) args: 0, res: 0, upd: 0;
       c1Hk9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hk8() //  [R1]
         { info_tbl: [(c1Hk8,
                       label: block_c1Hk8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hk8: // global
           R1 = P64[R1 + 159];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.857607287 UTC

[section ""data" . Data.Bits.rotateL_closure" {
     Data.Bits.rotateL_closure:
         const Data.Bits.rotateL_info;
 },
 Data.Bits.rotateL_entry() //  [R2]
         { info_tbl: [(c1Hkz,
                       label: Data.Bits.rotateL_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hkz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HkA; else goto c1HkB;
       c1HkA: // global
           R2 = R2;
           R1 = Data.Bits.rotateL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HkB: // global
           I64[Sp - 8] = block_c1Hkw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HkF; else goto c1Hkx;
       u1HkF: // global
           call _c1Hkw(R1) args: 0, res: 0, upd: 0;
       c1Hkx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hkw() //  [R1]
         { info_tbl: [(c1Hkw,
                       label: block_c1Hkw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hkw: // global
           R1 = P64[R1 + 167];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.863556427 UTC

[section ""data" . Data.Bits.rotateR_closure" {
     Data.Bits.rotateR_closure:
         const Data.Bits.rotateR_info;
 },
 Data.Bits.rotateR_entry() //  [R2]
         { info_tbl: [(c1HkX,
                       label: Data.Bits.rotateR_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HkX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HkY; else goto c1HkZ;
       c1HkY: // global
           R2 = R2;
           R1 = Data.Bits.rotateR_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HkZ: // global
           I64[Sp - 8] = block_c1HkU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hl3; else goto c1HkV;
       u1Hl3: // global
           call _c1HkU(R1) args: 0, res: 0, upd: 0;
       c1HkV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HkU() //  [R1]
         { info_tbl: [(c1HkU,
                       label: block_c1HkU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HkU: // global
           R1 = P64[R1 + 175];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.869533704 UTC

[section ""data" . Data.Bits.popCount_closure" {
     Data.Bits.popCount_closure:
         const Data.Bits.popCount_info;
 },
 Data.Bits.popCount_entry() //  [R2]
         { info_tbl: [(c1Hll,
                       label: Data.Bits.popCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hll: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hlm; else goto c1Hln;
       c1Hlm: // global
           R2 = R2;
           R1 = Data.Bits.popCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hln: // global
           I64[Sp - 8] = block_c1Hli_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hlr; else goto c1Hlj;
       u1Hlr: // global
           call _c1Hli(R1) args: 0, res: 0, upd: 0;
       c1Hlj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hli() //  [R1]
         { info_tbl: [(c1Hli,
                       label: block_c1Hli_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hli: // global
           R1 = P64[R1 + 183];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.875640434 UTC

[section ""data" . Data.Bits.$fBitsBool2_closure" {
     Data.Bits.$fBitsBool2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.877441542 UTC

[section ""data" . Data.Bits.$fBitsBool1_closure" {
     Data.Bits.$fBitsBool1_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.879629841 UTC

[section ""data" . Data.Bits.$fBitsBool_$cpopCount_closure" {
     Data.Bits.$fBitsBool_$cpopCount_closure:
         const Data.Bits.$fBitsBool_$cpopCount_info;
 },
 Data.Bits.$fBitsBool_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1HlP,
                       label: Data.Bits.$fBitsBool_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HlP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HlQ; else goto c1HlR;
       c1HlQ: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HlR: // global
           I64[Sp - 8] = block_c1HlI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HlY; else goto c1HlJ;
       u1HlY: // global
           call _c1HlI(R1) args: 0, res: 0, upd: 0;
       c1HlJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HlI() //  [R1]
         { info_tbl: [(c1HlI,
                       label: block_c1HlI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HlI: // global
           if (R1 & 7 == 1) goto c1HlM; else goto c1HlN;
       c1HlM: // global
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HlN: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.886138378 UTC

[section ""data" . Data.Bits.$fBitsBool_$cisSigned_closure" {
     Data.Bits.$fBitsBool_$cisSigned_closure:
         const Data.Bits.$fBitsBool_$cisSigned_info;
 },
 Data.Bits.$fBitsBool_$cisSigned_entry() //  []
         { info_tbl: [(c1Hmh,
                       label: Data.Bits.$fBitsBool_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hmh: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.889519727 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbitSize_closure" {
     Data.Bits.$fBitsBool_$cbitSize_closure:
         const Data.Bits.$fBitsBool_$cbitSize_info;
 },
 Data.Bits.$fBitsBool_$cbitSize_entry() //  []
         { info_tbl: [(c1Hmu,
                       label: Data.Bits.$fBitsBool_$cbitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hmu: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.892820497 UTC

[section ""data" . Data.Bits.$fBitsBool3_closure" {
     Data.Bits.$fBitsBool3_closure:
         const GHC.Base.Just_con_info;
         const Data.Bits.$fBitsBool1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.894725478 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsBool_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsBool_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsBool_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1HmH,
                       label: Data.Bits.$fBitsBool_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HmH: // global
           R1 = Data.Bits.$fBitsBool3_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.898557881 UTC

[section ""data" . Data.Bits.$fBitsBool_$ctestBit_closure" {
     Data.Bits.$fBitsBool_$ctestBit_closure:
         const Data.Bits.$fBitsBool_$ctestBit_info;
 },
 Data.Bits.$fBitsBool_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1HmW,
                       label: Data.Bits.$fBitsBool_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HmW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HmX; else goto c1HmY;
       c1HmX: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HmY: // global
           I64[Sp - 16] = block_c1HmT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Hn6; else goto c1HmU;
       u1Hn6: // global
           call _c1HmT(R1) args: 0, res: 0, upd: 0;
       c1HmU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HmT() //  [R1]
         { info_tbl: [(c1HmT,
                       label: block_c1HmT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HmT: // global
           if (I64[R1 + 7] == 0) goto c1Hn5; else goto c1Hn4;
       c1Hn5: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c1Hn4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.906058236 UTC

[section ""data" . Data.Bits.$fBitsBool_$cbit_closure" {
     Data.Bits.$fBitsBool_$cbit_closure:
         const Data.Bits.$fBitsBool_$cbit_info;
 },
 Data.Bits.$fBitsBool_$cbit_entry() //  [R2]
         { info_tbl: [(c1Hns,
                       label: Data.Bits.$fBitsBool_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hns: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1Hnt; else goto c1Hnu;
       c1Hnt: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1Hnu: // global
           I64[Sp - 8] = block_c1Hnp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HnC; else goto c1Hnq;
       u1HnC: // global
           call _c1Hnp(R1) args: 0, res: 0, upd: 0;
       c1Hnq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hnp() //  [R1]
         { info_tbl: [(c1Hnp,
                       label: block_c1Hnp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hnp: // global
           if (I64[R1 + 7] == 0) goto c1HnB; else goto c1HnA;
       c1HnB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HnA: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.911951454 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotate_closure" {
     Data.Bits.$fBitsBool_$crotate_closure:
         const Data.Bits.$fBitsBool_$crotate_info;
 },
 Data.Bits.$fBitsBool_$crotate_entry() //  [R2]
         { info_tbl: [(c1HnV,
                       label: Data.Bits.$fBitsBool_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HnV: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.915793227 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cisSigned_closure" {
     Data.Bits.$fBitsInteger_$cisSigned_closure:
         const Data.Bits.$fBitsInteger_$cisSigned_info;
 },
 Data.Bits.$fBitsInteger_$cisSigned_entry() //  []
         { info_tbl: [(c1Ho8,
                       label: Data.Bits.$fBitsInteger_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ho8: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.919204207 UTC

[section ""cstring" . Data.Bits.$fBitsInteger2_bytes" {
     Data.Bits.$fBitsInteger2_bytes:
         I8[] [68,97,116,97,46,66,105,116,115,46,98,105,116,83,105,122,101,40,73,110,116,101,103,101,114,41]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.921291546 UTC

[section ""data" . Data.Bits.$fBitsInteger1_closure" {
     Data.Bits.$fBitsInteger1_closure:
         const Data.Bits.$fBitsInteger1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger1_entry() //  [R1]
         { info_tbl: [(c1Hoo,
                       label: Data.Bits.$fBitsInteger1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hoo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hop; else goto c1Hoq;
       c1Hop: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Hoq: // global
           (_c1Hol::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1Hol::I64 == 0) goto c1Hon; else goto c1Hom;
       c1Hon: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1Hom: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1Hol::I64;
           R2 = Data.Bits.$fBitsInteger2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.925800361 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbitSize_closure" {
     Data.Bits.$fBitsInteger_$cbitSize_closure:
         const Data.Bits.$fBitsInteger_$cbitSize_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cbitSize_entry() //  []
         { info_tbl: [(c1HoD,
                       label: Data.Bits.$fBitsInteger_$cbitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HoD: // global
           R2 = Data.Bits.$fBitsInteger1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.929317234 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsInteger_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsInteger_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1HoP,
                       label: Data.Bits.$fBitsInteger_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HoP: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.933036409 UTC

[section ""data" . Data.Bits.$fBitsInteger_$ctestBit_closure" {
     Data.Bits.$fBitsInteger_$ctestBit_closure:
         const Data.Bits.$fBitsInteger_$ctestBit_info;
 },
 Data.Bits.$fBitsInteger_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1Hp5,
                       label: Data.Bits.$fBitsInteger_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hp5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hp6; else goto c1Hp7;
       c1Hp6: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Hp7: // global
           I64[Sp - 16] = block_c1Hp2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Hpb; else goto c1Hp3;
       u1Hpb: // global
           call _c1Hp2(R1) args: 0, res: 0, upd: 0;
       c1Hp3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hp2() //  [R1]
         { info_tbl: [(c1Hp2,
                       label: block_c1Hp2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hp2: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.testBitInteger_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.93973531 UTC

[section ""data" . Data.Bits.$fBitsInteger_$czeroBits_closure" {
     Data.Bits.$fBitsInteger_$czeroBits_closure:
         const Data.Bits.$fBitsInteger_$czeroBits_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger_$czeroBits_entry() //  [R1]
         { info_tbl: [(c1Hps,
                       label: Data.Bits.$fBitsInteger_$czeroBits_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hps: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hpt; else goto c1Hpu;
       c1Hpt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Hpu: // global
           (_c1Hpp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1Hpp::I64 == 0) goto c1Hpr; else goto c1Hpq;
       c1Hpr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1Hpq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1Hpp::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.944711103 UTC

[section ""data" . Data.Bits.$w$cshift_closure" {
     Data.Bits.$w$cshift_closure:
         const Data.Bits.$w$cshift_info;
         const 0;
 },
 Data.Bits.$w$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1HpO,
                       label: Data.Bits.$w$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HpO: // global
           if (%MO_S_Lt_W64(R3, 0)) goto c1HpM; else goto c1HpN;
       c1HpM: // global
           R3 = -R3;
           R2 = R2;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1HpN: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.948681754 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshift_closure" {
     Data.Bits.$fBitsInteger_$cshift_closure:
         const Data.Bits.$fBitsInteger_$cshift_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1Hq4,
                       label: Data.Bits.$fBitsInteger_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hq4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hq5; else goto c1Hq6;
       c1Hq5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Hq6: // global
           I64[Sp - 16] = block_c1Hq1_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Hqa; else goto c1Hq2;
       u1Hqa: // global
           call _c1Hq1(R1) args: 0, res: 0, upd: 0;
       c1Hq2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hq1() //  [R1]
         { info_tbl: [(c1Hq1,
                       label: block_c1Hq1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hq1: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Bits.$w$cshift_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.954282479 UTC

[section ""data" . sat_s1H0k_closure" {
     sat_s1H0k_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.956149072 UTC

[section ""data" . sat_s1H0l_closure" {
     sat_s1H0l_closure:
         const :_con_info;
         const sat_s1H0k_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.958374835 UTC

[section ""data" . Data.Bits.$fBitsInteger3_closure" {
     Data.Bits.$fBitsInteger3_closure:
         const Data.Bits.$fBitsInteger3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Bits.$fBitsInteger3_entry() //  [R1]
         { info_tbl: [(c1Hqt,
                       label: Data.Bits.$fBitsInteger3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hqt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hqu; else goto c1Hqv;
       c1Hqu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Hqv: // global
           (_c1Hqq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c1Hqq::I64 == 0) goto c1Hqs; else goto c1Hqr;
       c1Hqs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c1Hqr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c1Hqq::I64;
           R3 = sat_s1H0l_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.963162283 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cbit_closure" {
     Data.Bits.$fBitsInteger_$cbit_closure:
         const Data.Bits.$fBitsInteger_$cbit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cbit_entry() //  [R2]
         { info_tbl: [(c1HqM,
                       label: Data.Bits.$fBitsInteger_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HqM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HqN; else goto c1HqO;
       c1HqN: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HqO: // global
           I64[Sp - 8] = block_c1HqJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HqZ; else goto c1HqK;
       u1HqZ: // global
           call _c1HqJ(R1) args: 0, res: 0, upd: 0;
       c1HqK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HqJ() //  [R1]
         { info_tbl: [(c1HqJ,
                       label: block_c1HqJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HqJ: // global
           _s1H0o::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H0o::I64, 0)) goto c1HqV; else goto c1HqW;
       c1HqV: // global
           R3 = -_s1H0o::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1HqW: // global
           R3 = _s1H0o::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.970092229 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cclearBit_closure" {
     Data.Bits.$fBitsInteger_$cclearBit_closure:
         const Data.Bits.$fBitsInteger_$cclearBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1Hrh,
                       label: Data.Bits.$fBitsInteger_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hrh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hri; else goto c1Hrj;
       c1Hri: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Hrj: // global
           I64[Sp - 16] = block_c1Hre_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HrR; else goto c1Hrf;
       u1HrR: // global
           call _c1Hre(R1) args: 0, res: 0, upd: 0;
       c1Hrf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hre() //  [R1]
         { info_tbl: [(c1Hre,
                       label: block_c1Hre_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hre: // global
           _s1H0u::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H0u::I64, 0)) goto c1Hrz; else goto c1HrL;
       c1Hrz: // global
           I64[Sp] = block_c1Hrt_info;
           R3 = -_s1H0u::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1HrL: // global
           I64[Sp] = block_c1HrG_info;
           R3 = _s1H0u::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hrt() //  [R1]
         { info_tbl: [(c1Hrt,
                       label: block_c1Hrt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hrt: // global
           I64[Sp] = block_c1Hrx_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hrx() //  [R1]
         { info_tbl: [(c1Hrx,
                       label: block_c1Hrx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hrx: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1HrG() //  [R1]
         { info_tbl: [(c1HrG,
                       label: block_c1HrG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HrG: // global
           I64[Sp] = block_c1HrK_info;
           R2 = R1;
           call GHC.Integer.Type.complementInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1HrK() //  [R1]
         { info_tbl: [(c1HrK,
                       label: block_c1HrK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HrK: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.984081788 UTC

[section ""data" . Data.Bits.$fBitsInteger_$ccomplementBit_closure" {
     Data.Bits.$fBitsInteger_$ccomplementBit_closure:
         const Data.Bits.$fBitsInteger_$ccomplementBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1Hsp,
                       label: Data.Bits.$fBitsInteger_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hsp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hsq; else goto c1Hsr;
       c1Hsq: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Hsr: // global
           I64[Sp - 16] = block_c1Hsm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HsP; else goto c1Hsn;
       u1HsP: // global
           call _c1Hsm(R1) args: 0, res: 0, upd: 0;
       c1Hsn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hsm() //  [R1]
         { info_tbl: [(c1Hsm,
                       label: block_c1Hsm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hsm: // global
           _s1H0E::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H0E::I64, 0)) goto c1HsD; else goto c1HsK;
       c1HsD: // global
           I64[Sp] = block_c1HsB_info;
           R3 = -_s1H0E::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1HsK: // global
           I64[Sp] = block_c1HsJ_info;
           R3 = _s1H0E::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1HsB() //  [R1]
         { info_tbl: [(c1HsB,
                       label: block_c1HsB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HsB: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1HsJ() //  [R1]
         { info_tbl: [(c1HsJ,
                       label: block_c1HsJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HsJ: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:28.993991569 UTC

[section ""data" . Data.Bits.$fBitsInteger_$csetBit_closure" {
     Data.Bits.$fBitsInteger_$csetBit_closure:
         const Data.Bits.$fBitsInteger_$csetBit_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1Htf,
                       label: Data.Bits.$fBitsInteger_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Htf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Htg; else goto c1Hth;
       c1Htg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Hth: // global
           I64[Sp - 16] = block_c1Htc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HtF; else goto c1Htd;
       u1HtF: // global
           call _c1Htc(R1) args: 0, res: 0, upd: 0;
       c1Htd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Htc() //  [R1]
         { info_tbl: [(c1Htc,
                       label: block_c1Htc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Htc: // global
           _s1H0M::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H0M::I64, 0)) goto c1Htt; else goto c1HtA;
       c1Htt: // global
           I64[Sp] = block_c1Htr_info;
           R3 = -_s1H0M::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       c1HtA: // global
           I64[Sp] = block_c1Htz_info;
           R3 = _s1H0M::I64;
           R2 = Data.Bits.$fBitsInteger3_closure;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Htr() //  [R1]
         { info_tbl: [(c1Htr,
                       label: block_c1Htr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Htr: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 _c1Htz() //  [R1]
         { info_tbl: [(c1Htz,
                       label: block_c1Htz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Htz: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.003604343 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsInteger_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsInteger_$cunsafeShiftL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Hu2,
                       label: Data.Bits.$fBitsInteger_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hu2: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.007426197 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshiftL_closure" {
     Data.Bits.$fBitsInteger_$cshiftL_closure:
         const Data.Bits.$fBitsInteger_$cshiftL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Hud,
                       label: Data.Bits.$fBitsInteger_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hud: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.011254517 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cshiftR_closure" {
     Data.Bits.$fBitsInteger_$cshiftR_closure:
         const Data.Bits.$fBitsInteger_$cshiftR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1Hur,
                       label: Data.Bits.$fBitsInteger_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hur: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hus; else goto c1Hut;
       c1Hus: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Hut: // global
           I64[Sp - 16] = block_c1Huo_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HuH; else goto c1Hup;
       u1HuH: // global
           call _c1Huo(R1) args: 0, res: 0, upd: 0;
       c1Hup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Huo() //  [R1]
         { info_tbl: [(c1Huo,
                       label: block_c1Huo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Huo: // global
           _s1H0R::P64 = P64[Sp + 8];
           _s1H0V::I64 = -I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H0V::I64, 0)) goto c1HuD; else goto c1HuE;
       c1HuD: // global
           R3 = -_s1H0V::I64;
           R2 = _s1H0R::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1HuE: // global
           R3 = _s1H0V::I64;
           R2 = _s1H0R::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.018317344 UTC

[section ""data" . Data.Bits.$fBitsInteger_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsInteger_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsInteger_$cunsafeShiftR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1HuW,
                       label: Data.Bits.$fBitsInteger_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HuW: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.022582113 UTC

[section ""data" . Data.Bits.$fBitsInteger_$crotateR_closure" {
     Data.Bits.$fBitsInteger_$crotateR_closure:
         const Data.Bits.$fBitsInteger_$crotateR_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1Hva,
                       label: Data.Bits.$fBitsInteger_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hva: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hvb; else goto c1Hvc;
       c1Hvb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Hvc: // global
           I64[Sp - 16] = block_c1Hv7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Hvq; else goto c1Hv8;
       u1Hvq: // global
           call _c1Hv7(R1) args: 0, res: 0, upd: 0;
       c1Hv8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hv7() //  [R1]
         { info_tbl: [(c1Hv7,
                       label: block_c1Hv7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hv7: // global
           _s1H0Y::P64 = P64[Sp + 8];
           _s1H12::I64 = -I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H12::I64, 0)) goto c1Hvm; else goto c1Hvn;
       c1Hvm: // global
           R3 = -_s1H12::I64;
           R2 = _s1H0Y::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c1Hvn: // global
           R3 = _s1H12::I64;
           R2 = _s1H0Y::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.028816907 UTC

[section ""data" . Data.Bits.$fBitsInteger_$crotateL_closure" {
     Data.Bits.$fBitsInteger_$crotateL_closure:
         const Data.Bits.$fBitsInteger_$crotateL_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1HvF,
                       label: Data.Bits.$fBitsInteger_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HvF: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.03263101 UTC

[section ""data" . Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1HvX,
                       label: Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HvX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HvY; else goto c1HvZ;
       c1HvY: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HvZ: // global
           I64[Sp - 8] = block_c1HvQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Hw6; else goto c1HvR;
       u1Hw6: // global
           call _c1HvQ(R1) args: 0, res: 0, upd: 0;
       c1HvR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HvQ() //  [R1]
         { info_tbl: [(c1HvQ,
                       label: block_c1HvQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HvQ: // global
           if (R1 & 7 == 1) goto c1HvU; else goto c1HvV;
       c1HvU: // global
           R1 = Data.Bits.$fBitsBool1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HvV: // global
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.03915518 UTC

[section ""data" . Data.Bits.$fBitsInt_$cpopCount_closure" {
     Data.Bits.$fBitsInt_$cpopCount_closure:
         const Data.Bits.$fBitsInt_$cpopCount_info;
 },
 Data.Bits.$fBitsInt_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1Hws,
                       label: Data.Bits.$fBitsInt_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hws: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HwG; else goto c1HwH;
       c1HwG: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HwH: // global
           I64[Sp - 8] = block_c1Hwp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HwL; else goto c1Hwq;
       u1HwL: // global
           call _c1Hwp(R1) args: 0, res: 0, upd: 0;
       c1Hwq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hwp() //  [R1]
         { info_tbl: [(c1Hwp,
                       label: block_c1Hwp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hwp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HwK; else goto c1HwJ;
       c1HwK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HwJ: // global
           (_c1Hwy::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1Hwy::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.04561951 UTC

[section ""data" . Data.Bits.$fBitsInt_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsInt_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsInt_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsInt_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1Hx5,
                       label: Data.Bits.$fBitsInt_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hx5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hxh; else goto c1Hxi;
       c1Hxh: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Hxi: // global
           I64[Sp - 16] = block_c1Hx2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Hxo; else goto c1Hx3;
       u1Hxo: // global
           call _c1Hx2(R1) args: 0, res: 0, upd: 0;
       c1Hx3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hx2() //  [R1]
         { info_tbl: [(c1Hx2,
                       label: block_c1Hx2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hx2: // global
           I64[Sp] = block_c1Hx8_info;
           _s1H1g::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H1g::I64;
           if (R1 & 7 != 0) goto u1Hxn; else goto c1Hx9;
       u1Hxn: // global
           call _c1Hx8(R1) args: 0, res: 0, upd: 0;
       c1Hx9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hx8() //  [R1]
         { info_tbl: [(c1Hx8,
                       label: block_c1Hx8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hx8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Hxm; else goto c1Hxl;
       c1Hxm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Hxl: // global
           _s1H1j::I64 = %MO_S_Shr_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H1j::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.05441428 UTC

[section ""data" . lvl_r1CDD_closure" {
     lvl_r1CDD_closure:
         const GHC.Types.I#_con_info;
         const (-1);
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.056819978 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshiftR_closure" {
     Data.Bits.$fBitsInt_$cshiftR_closure:
         const Data.Bits.$fBitsInt_$cshiftR_info;
 },
 Data.Bits.$fBitsInt_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1HxP,
                       label: Data.Bits.$fBitsInt_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HxP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HxT; else goto c1HxU;
       c1HxT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HxU: // global
           I64[Sp - 16] = block_c1HxM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Hyk; else goto c1HxN;
       u1Hyk: // global
           call _c1HxM(R1) args: 0, res: 0, upd: 0;
       c1HxN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HxM() //  [R1]
         { info_tbl: [(c1HxM,
                       label: block_c1HxM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HxM: // global
           I64[Sp] = block_c1HxS_info;
           _s1H1n::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H1n::I64;
           if (R1 & 7 != 0) goto u1Hyj; else goto c1HxW;
       u1Hyj: // global
           call _c1HxS(R1) args: 0, res: 0, upd: 0;
       c1HxW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HxS() //  [R1]
         { info_tbl: [(c1HxS,
                       label: block_c1HxS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HxS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Hy2; else goto c1Hy1;
       c1Hy2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Hy1: // global
           _s1H1n::I64 = I64[Sp + 8];
           _s1H1p::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H1p::I64, 64)) goto c1Hyb; else goto c1Hyi;
       c1Hyb: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s1H1n::I64, _s1H1p::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Hyi: // global
           if (%MO_S_Ge_W64(_s1H1n::I64, 0)) goto c1Hyg; else goto c1Hyh;
       c1Hyg: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Hyh: // global
           Hp = Hp - 16;
           R1 = lvl_r1CDD_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.065676783 UTC

[section ""data" . Data.Bits.$fBitsInt_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsInt_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsInt_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsInt_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1HyM,
                       label: Data.Bits.$fBitsInt_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HyM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HyY; else goto c1HyZ;
       c1HyY: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HyZ: // global
           I64[Sp - 16] = block_c1HyJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Hz5; else goto c1HyK;
       u1Hz5: // global
           call _c1HyJ(R1) args: 0, res: 0, upd: 0;
       c1HyK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HyJ() //  [R1]
         { info_tbl: [(c1HyJ,
                       label: block_c1HyJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HyJ: // global
           I64[Sp] = block_c1HyP_info;
           _s1H1w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H1w::I64;
           if (R1 & 7 != 0) goto u1Hz4; else goto c1HyQ;
       u1Hz4: // global
           call _c1HyP(R1) args: 0, res: 0, upd: 0;
       c1HyQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HyP() //  [R1]
         { info_tbl: [(c1HyP,
                       label: block_c1HyP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HyP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Hz3; else goto c1Hz2;
       c1Hz3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Hz2: // global
           _s1H1z::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H1z::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.074424305 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshiftL_closure" {
     Data.Bits.$fBitsInt_$cshiftL_closure:
         const Data.Bits.$fBitsInt_$cshiftL_info;
 },
 Data.Bits.$fBitsInt_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1Hzv,
                       label: Data.Bits.$fBitsInt_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hzv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Hzz; else goto c1HzA;
       c1Hzz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HzA: // global
           I64[Sp - 16] = block_c1Hzs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HzU; else goto c1Hzt;
       u1HzU: // global
           call _c1Hzs(R1) args: 0, res: 0, upd: 0;
       c1Hzt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hzs() //  [R1]
         { info_tbl: [(c1Hzs,
                       label: block_c1Hzs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hzs: // global
           I64[Sp] = block_c1Hzy_info;
           _s1H1D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H1D::I64;
           if (R1 & 7 != 0) goto u1HzT; else goto c1HzC;
       u1HzT: // global
           call _c1Hzy(R1) args: 0, res: 0, upd: 0;
       c1HzC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Hzy() //  [R1]
         { info_tbl: [(c1Hzy,
                       label: block_c1Hzy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Hzy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HzI; else goto c1HzH;
       c1HzI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HzH: // global
           _s1H1F::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H1F::I64, 64)) goto c1HzR; else goto c1HzS;
       c1HzR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] << _s1H1F::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HzS: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.082979408 UTC

[section ""data" . Data.Bits.$fBitsInt_$cisSigned_closure" {
     Data.Bits.$fBitsInt_$cisSigned_closure:
         const Data.Bits.$fBitsInt_$cisSigned_info;
 },
 Data.Bits.$fBitsInt_$cisSigned_entry() //  []
         { info_tbl: [(c1HAi,
                       label: Data.Bits.$fBitsInt_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HAi: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.087032966 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotate_closure" {
     Data.Bits.$fBitsInt_$crotate_closure:
         const Data.Bits.$fBitsInt_$crotate_info;
 },
 Data.Bits.$fBitsInt_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c1HAy,
                       label: Data.Bits.$fBitsInt_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HAy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HAW; else goto c1HAX;
       c1HAW: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HAX: // global
           I64[Sp - 16] = block_c1HAv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HB3; else goto c1HAw;
       u1HB3: // global
           call _c1HAv(R1) args: 0, res: 0, upd: 0;
       c1HAw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HAv() //  [R1]
         { info_tbl: [(c1HAv,
                       label: block_c1HAv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HAv: // global
           I64[Sp] = block_c1HAB_info;
           _s1H1M::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H1M::I64;
           if (R1 & 7 != 0) goto u1HB2; else goto c1HAC;
       u1HB2: // global
           call _c1HAB(R1) args: 0, res: 0, upd: 0;
       c1HAC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HAB() //  [R1]
         { info_tbl: [(c1HAB,
                       label: block_c1HAB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HAB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HB1; else goto c1HB0;
       c1HB1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HB0: // global
           _s1H1P::I64 = I64[R1 + 7] & 63;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _s1H1M::I64 = I64[Sp + 8];
           I64[Hp] = (_s1H1M::I64 << _s1H1P::I64) | (_s1H1M::I64 >> 64 - _s1H1P::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.097073998 UTC

[section ""data" . Data.Bits.$fBitsInt_$cshift_closure" {
     Data.Bits.$fBitsInt_$cshift_closure:
         const Data.Bits.$fBitsInt_$cshift_info;
 },
 Data.Bits.$fBitsInt_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1HBy,
                       label: Data.Bits.$fBitsInt_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HBy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HBC; else goto c1HBD;
       c1HBC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HBD: // global
           I64[Sp - 16] = block_c1HBv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HCn; else goto c1HBw;
       u1HCn: // global
           call _c1HBv(R1) args: 0, res: 0, upd: 0;
       c1HBw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HBv() //  [R1]
         { info_tbl: [(c1HBv,
                       label: block_c1HBv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HBv: // global
           I64[Sp] = block_c1HBB_info;
           _s1H1X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H1X::I64;
           if (R1 & 7 != 0) goto u1HCm; else goto c1HBF;
       u1HCm: // global
           call _c1HBB(R1) args: 0, res: 0, upd: 0;
       c1HBF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HBB() //  [R1]
         { info_tbl: [(c1HBB,
                       label: block_c1HBB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HBB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HBL; else goto c1HBK;
       c1HBL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HBK: // global
           _s1H1X::I64 = I64[Sp + 8];
           _s1H1Z::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H1Z::I64, 0)) goto c1HC9; else goto c1HCl;
       c1HC9: // global
           _s1H21::I64 = -_s1H1Z::I64;
           if (%MO_S_Lt_W64(_s1H21::I64, 64)) goto c1HC0; else goto c1HC7;
       c1HC0: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_S_Shr_W64(_s1H1X::I64, _s1H21::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HC7: // global
           if (%MO_S_Ge_W64(_s1H1X::I64, 0)) goto c1HCk; else goto c1HC6;
       c1HC6: // global
           Hp = Hp - 16;
           R1 = lvl_r1CDD_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HCl: // global
           if (%MO_S_Ge_W64(_s1H1Z::I64, 64)) goto c1HCk; else goto c1HCj;
       c1HCk: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HCj: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H1X::I64 << _s1H1Z::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.106834444 UTC

[section ""data" . Data.Bits.$fBitsInt_$ccomplement_closure" {
     Data.Bits.$fBitsInt_$ccomplement_closure:
         const Data.Bits.$fBitsInt_$ccomplement_info;
 },
 Data.Bits.$fBitsInt_$ccomplement_entry() //  [R2]
         { info_tbl: [(c1HCS,
                       label: Data.Bits.$fBitsInt_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HCS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HCZ; else goto c1HD0;
       c1HCZ: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HD0: // global
           I64[Sp - 8] = block_c1HCP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HD4; else goto c1HCQ;
       u1HD4: // global
           call _c1HCP(R1) args: 0, res: 0, upd: 0;
       c1HCQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HCP() //  [R1]
         { info_tbl: [(c1HCP,
                       label: block_c1HCP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HCP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HD3; else goto c1HD2;
       c1HD3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HD2: // global
           _s1H2a::I64 = ~I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H2a::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.113221205 UTC

[section ""data" . Data.Bits.$fBitsInt_$cxor_closure" {
     Data.Bits.$fBitsInt_$cxor_closure:
         const Data.Bits.$fBitsInt_$cxor_info;
 },
 Data.Bits.$fBitsInt_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c1HDo,
                       label: Data.Bits.$fBitsInt_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HDo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HDA; else goto c1HDB;
       c1HDA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HDB: // global
           I64[Sp - 16] = block_c1HDl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HDH; else goto c1HDm;
       u1HDH: // global
           call _c1HDl(R1) args: 0, res: 0, upd: 0;
       c1HDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HDl() //  [R1]
         { info_tbl: [(c1HDl,
                       label: block_c1HDl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HDl: // global
           I64[Sp] = block_c1HDr_info;
           _s1H2e::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H2e::I64;
           if (R1 & 7 != 0) goto u1HDG; else goto c1HDs;
       u1HDG: // global
           call _c1HDr(R1) args: 0, res: 0, upd: 0;
       c1HDs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HDr() //  [R1]
         { info_tbl: [(c1HDr,
                       label: block_c1HDr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HDr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HDF; else goto c1HDE;
       c1HDF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HDE: // global
           _s1H2h::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H2h::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.121680052 UTC

[section ""data" . Data.Bits.$fBitsInt_$c.|._closure" {
     Data.Bits.$fBitsInt_$c.|._closure:
         const Data.Bits.$fBitsInt_$c.|._info;
 },
 Data.Bits.$fBitsInt_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c1HE8,
                       label: Data.Bits.$fBitsInt_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HE8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HEk; else goto c1HEl;
       c1HEk: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HEl: // global
           I64[Sp - 16] = block_c1HE5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HEr; else goto c1HE6;
       u1HEr: // global
           call _c1HE5(R1) args: 0, res: 0, upd: 0;
       c1HE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HE5() //  [R1]
         { info_tbl: [(c1HE5,
                       label: block_c1HE5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HE5: // global
           I64[Sp] = block_c1HEb_info;
           _s1H2l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H2l::I64;
           if (R1 & 7 != 0) goto u1HEq; else goto c1HEc;
       u1HEq: // global
           call _c1HEb(R1) args: 0, res: 0, upd: 0;
       c1HEc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HEb() //  [R1]
         { info_tbl: [(c1HEb,
                       label: block_c1HEb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HEb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HEp; else goto c1HEo;
       c1HEp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HEo: // global
           _s1H2o::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H2o::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.129965584 UTC

[section ""data" . Data.Bits.$fBitsInt_$c.&._closure" {
     Data.Bits.$fBitsInt_$c.&._closure:
         const Data.Bits.$fBitsInt_$c.&._info;
 },
 Data.Bits.$fBitsInt_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c1HES,
                       label: Data.Bits.$fBitsInt_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HES: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HF4; else goto c1HF5;
       c1HF4: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HF5: // global
           I64[Sp - 16] = block_c1HEP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HFb; else goto c1HEQ;
       u1HFb: // global
           call _c1HEP(R1) args: 0, res: 0, upd: 0;
       c1HEQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HEP() //  [R1]
         { info_tbl: [(c1HEP,
                       label: block_c1HEP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HEP: // global
           I64[Sp] = block_c1HEV_info;
           _s1H2s::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H2s::I64;
           if (R1 & 7 != 0) goto u1HFa; else goto c1HEW;
       u1HFa: // global
           call _c1HEV(R1) args: 0, res: 0, upd: 0;
       c1HEW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HEV() //  [R1]
         { info_tbl: [(c1HEV,
                       label: block_c1HEV_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HEV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HF9; else goto c1HF8;
       c1HF9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HF8: // global
           _s1H2v::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H2v::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.139256427 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1HFC,
                       label: Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HFC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HFQ; else goto c1HFR;
       c1HFQ: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HFR: // global
           I64[Sp - 8] = block_c1HFz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HFV; else goto c1HFA;
       u1HFV: // global
           call _c1HFz(R1) args: 0, res: 0, upd: 0;
       c1HFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HFz() //  [R1]
         { info_tbl: [(c1HFz,
                       label: block_c1HFz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HFz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HFU; else goto c1HFT;
       c1HFU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HFT: // global
           (_c1HFI::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1HFI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.145447063 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure" {
     Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure:
         const Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_info;
 },
 Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1HGh,
                       label: Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HGh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HGv; else goto c1HGw;
       c1HGv: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HGw: // global
           I64[Sp - 8] = block_c1HGe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HGA; else goto c1HGf;
       u1HGA: // global
           call _c1HGe(R1) args: 0, res: 0, upd: 0;
       c1HGf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HGe() //  [R1]
         { info_tbl: [(c1HGe,
                       label: block_c1HGe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HGe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HGz; else goto c1HGy;
       c1HGz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HGy: // global
           (_c1HGn::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1HGn::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.151584661 UTC

[section ""data" . Data.Bits.$fBitsInt1_closure" {
     Data.Bits.$fBitsInt1_closure:
         const GHC.Types.I#_con_info;
         const 64;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.153586713 UTC

[section ""data" . Data.Bits.$fBitsInt_$cfiniteBitSize_closure" {
     Data.Bits.$fBitsInt_$cfiniteBitSize_closure:
         const Data.Bits.$fBitsInt_$cfiniteBitSize_info;
 },
 Data.Bits.$fBitsInt_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c1HGU,
                       label: Data.Bits.$fBitsInt_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HGU: // global
           R1 = Data.Bits.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.157491768 UTC

[section ""data" . Data.Bits.$fBitsWord_$cpopCount_closure" {
     Data.Bits.$fBitsWord_$cpopCount_closure:
         const Data.Bits.$fBitsWord_$cpopCount_info;
 },
 Data.Bits.$fBitsWord_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1HH9,
                       label: Data.Bits.$fBitsWord_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HH9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HHk; else goto c1HHl;
       c1HHk: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HHl: // global
           I64[Sp - 8] = block_c1HH6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HHp; else goto c1HH7;
       u1HHp: // global
           call _c1HH6(R1) args: 0, res: 0, upd: 0;
       c1HH7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HH6() //  [R1]
         { info_tbl: [(c1HH6,
                       label: block_c1HH6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HH6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HHo; else goto c1HHn;
       c1HHo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HHn: // global
           (_c1HHc::I64) = call MO_PopCnt W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1HHc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.164293183 UTC

[section ""data" . Data.Bits.$fBitsWord_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsWord_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsWord_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsWord_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1HHJ,
                       label: Data.Bits.$fBitsWord_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HHJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HHV; else goto c1HHW;
       c1HHV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cunsafeShiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HHW: // global
           I64[Sp - 16] = block_c1HHG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HI2; else goto c1HHH;
       u1HI2: // global
           call _c1HHG(R1) args: 0, res: 0, upd: 0;
       c1HHH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HHG() //  [R1]
         { info_tbl: [(c1HHG,
                       label: block_c1HHG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HHG: // global
           I64[Sp] = block_c1HHM_info;
           _s1H2R::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H2R::I64;
           if (R1 & 7 != 0) goto u1HI1; else goto c1HHN;
       u1HI1: // global
           call _c1HHM(R1) args: 0, res: 0, upd: 0;
       c1HHN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HHM() //  [R1]
         { info_tbl: [(c1HHM,
                       label: block_c1HHM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HHM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HI0; else goto c1HHZ;
       c1HI0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HHZ: // global
           _s1H2U::I64 = I64[Sp + 8] >> I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1H2U::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.173189795 UTC

[section ""data" . Data.Bits.$fBitsWord1_closure" {
     Data.Bits.$fBitsWord1_closure:
         const GHC.Types.W#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.175919191 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshiftR_closure" {
     Data.Bits.$fBitsWord_$cshiftR_closure:
         const Data.Bits.$fBitsWord_$cshiftR_info;
 },
 Data.Bits.$fBitsWord_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1HIt,
                       label: Data.Bits.$fBitsWord_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HIt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HIx; else goto c1HIy;
       c1HIx: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshiftR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HIy: // global
           I64[Sp - 16] = block_c1HIq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HIS; else goto c1HIr;
       u1HIS: // global
           call _c1HIq(R1) args: 0, res: 0, upd: 0;
       c1HIr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HIq() //  [R1]
         { info_tbl: [(c1HIq,
                       label: block_c1HIq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HIq: // global
           I64[Sp] = block_c1HIw_info;
           _s1H2Y::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H2Y::I64;
           if (R1 & 7 != 0) goto u1HIR; else goto c1HIA;
       u1HIR: // global
           call _c1HIw(R1) args: 0, res: 0, upd: 0;
       c1HIA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HIw() //  [R1]
         { info_tbl: [(c1HIw,
                       label: block_c1HIw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HIw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HIG; else goto c1HIF;
       c1HIG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HIF: // global
           _s1H30::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H30::I64, 64)) goto c1HIP; else goto c1HIQ;
       c1HIP: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] >> _s1H30::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HIQ: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.184770171 UTC

[section ""data" . Data.Bits.$fBitsWord_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsWord_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsWord_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsWord_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1HJj,
                       label: Data.Bits.$fBitsWord_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HJj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HJv; else goto c1HJw;
       c1HJv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cunsafeShiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HJw: // global
           I64[Sp - 16] = block_c1HJg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HJC; else goto c1HJh;
       u1HJC: // global
           call _c1HJg(R1) args: 0, res: 0, upd: 0;
       c1HJh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HJg() //  [R1]
         { info_tbl: [(c1HJg,
                       label: block_c1HJg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HJg: // global
           I64[Sp] = block_c1HJm_info;
           _s1H36::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H36::I64;
           if (R1 & 7 != 0) goto u1HJB; else goto c1HJn;
       u1HJB: // global
           call _c1HJm(R1) args: 0, res: 0, upd: 0;
       c1HJn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HJm() //  [R1]
         { info_tbl: [(c1HJm,
                       label: block_c1HJm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HJm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HJA; else goto c1HJz;
       c1HJA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HJz: // global
           _s1H39::I64 = I64[Sp + 8] << I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1H39::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.193139635 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshiftL_closure" {
     Data.Bits.$fBitsWord_$cshiftL_closure:
         const Data.Bits.$fBitsWord_$cshiftL_info;
 },
 Data.Bits.$fBitsWord_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1HK2,
                       label: Data.Bits.$fBitsWord_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HK2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HK6; else goto c1HK7;
       c1HK6: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshiftL_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HK7: // global
           I64[Sp - 16] = block_c1HJZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HKr; else goto c1HK0;
       u1HKr: // global
           call _c1HJZ(R1) args: 0, res: 0, upd: 0;
       c1HK0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HJZ() //  [R1]
         { info_tbl: [(c1HJZ,
                       label: block_c1HJZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HJZ: // global
           I64[Sp] = block_c1HK5_info;
           _s1H3d::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H3d::I64;
           if (R1 & 7 != 0) goto u1HKq; else goto c1HK9;
       u1HKq: // global
           call _c1HK5(R1) args: 0, res: 0, upd: 0;
       c1HK9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HK5() //  [R1]
         { info_tbl: [(c1HK5,
                       label: block_c1HK5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HK5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HKf; else goto c1HKe;
       c1HKf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HKe: // global
           _s1H3f::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H3f::I64, 64)) goto c1HKo; else goto c1HKp;
       c1HKo: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] << _s1H3f::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HKp: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.201476115 UTC

[section ""data" . Data.Bits.$fBitsWord_$cisSigned_closure" {
     Data.Bits.$fBitsWord_$cisSigned_closure:
         const Data.Bits.$fBitsWord_$cisSigned_info;
 },
 Data.Bits.$fBitsWord_$cisSigned_entry() //  []
         { info_tbl: [(c1HKP,
                       label: Data.Bits.$fBitsWord_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HKP: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.206073936 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotate_closure" {
     Data.Bits.$fBitsWord_$crotate_closure:
         const Data.Bits.$fBitsWord_$crotate_info;
 },
 Data.Bits.$fBitsWord_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c1HL5,
                       label: Data.Bits.$fBitsWord_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HL5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1HL9; else goto c1HLa;
       c1HL9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$crotate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HLa: // global
           I64[Sp - 16] = block_c1HL2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HLO; else goto c1HL3;
       u1HLO: // global
           call _c1HL2(R1) args: 0, res: 0, upd: 0;
       c1HL3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HL2() //  [R1]
         { info_tbl: [(c1HL2,
                       label: block_c1HL2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HL2: // global
           I64[Sp - 8] = block_c1HL8_info;
           _s1H3l::P64 = R1;
           _s1H3m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1H3m::I64;
           P64[Sp + 8] = _s1H3l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HLN; else goto c1HLc;
       u1HLN: // global
           call _c1HL8(R1) args: 0, res: 0, upd: 0;
       c1HLc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HL8() //  [R1]
         { info_tbl: [(c1HL8,
                       label: block_c1HL8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HL8: // global
           _s1H3p::I64 = I64[R1 + 7] & 63;
           if (_s1H3p::I64 != 0) goto u1HLL; else goto c1HLH;
       u1HLL: // global
           I64[Sp + 16] = _s1H3p::I64;
           Sp = Sp + 8;
           call _c1HLl() args: 0, res: 0, upd: 0;
       c1HLH: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1HLl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HLl: // global
           Hp = Hp + 16;
           _s1H3p::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1HLE; else goto c1HLD;
       c1HLE: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1HLk_info;
           R1 = _s1H3p::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1HLD: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           _s1H3m::I64 = I64[Sp];
           I64[Hp] = (_s1H3m::I64 << _s1H3p::I64) | (_s1H3m::I64 >> 64 - _s1H3p::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1HLk() //  [R1]
         { info_tbl: [(c1HLk,
                       label: block_c1HLk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HLk: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1HLl() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.21900289 UTC

[section ""data" . Data.Bits.$fBitsWord_$cshift_closure" {
     Data.Bits.$fBitsWord_$cshift_closure:
         const Data.Bits.$fBitsWord_$cshift_info;
 },
 Data.Bits.$fBitsWord_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c1HMt,
                       label: Data.Bits.$fBitsWord_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HMt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HMx; else goto c1HMy;
       c1HMx: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cshift_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HMy: // global
           I64[Sp - 16] = block_c1HMq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HNc; else goto c1HMr;
       u1HNc: // global
           call _c1HMq(R1) args: 0, res: 0, upd: 0;
       c1HMr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HMq() //  [R1]
         { info_tbl: [(c1HMq,
                       label: block_c1HMq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HMq: // global
           I64[Sp] = block_c1HMw_info;
           _s1H3x::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H3x::I64;
           if (R1 & 7 != 0) goto u1HNb; else goto c1HMA;
       u1HNb: // global
           call _c1HMw(R1) args: 0, res: 0, upd: 0;
       c1HMA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HMw() //  [R1]
         { info_tbl: [(c1HMw,
                       label: block_c1HMw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HMw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HMG; else goto c1HMF;
       c1HMG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HMF: // global
           _s1H3x::I64 = I64[Sp + 8];
           _s1H3z::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H3z::I64, 0)) goto c1HMY; else goto c1HNa;
       c1HMY: // global
           _s1H3B::I64 = -_s1H3z::I64;
           if (%MO_S_Ge_W64(_s1H3B::I64, 64)) goto c1HN9; else goto c1HMV;
       c1HMV: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1H3x::I64 >> _s1H3B::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HNa: // global
           if (%MO_S_Ge_W64(_s1H3z::I64, 64)) goto c1HN9; else goto c1HN8;
       c1HN9: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1HN8: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1H3x::I64 << _s1H3z::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.228150007 UTC

[section ""data" . Data.Bits.$fBitsWord_$ccomplement_closure" {
     Data.Bits.$fBitsWord_$ccomplement_closure:
         const Data.Bits.$fBitsWord_$ccomplement_info;
 },
 Data.Bits.$fBitsWord_$ccomplement_entry() //  [R2]
         { info_tbl: [(c1HNG,
                       label: Data.Bits.$fBitsWord_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HNG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HNN; else goto c1HNO;
       c1HNN: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ccomplement_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HNO: // global
           I64[Sp - 8] = block_c1HND_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HNS; else goto c1HNE;
       u1HNS: // global
           call _c1HND(R1) args: 0, res: 0, upd: 0;
       c1HNE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HND() //  [R1]
         { info_tbl: [(c1HND,
                       label: block_c1HND_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HND: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HNR; else goto c1HNQ;
       c1HNR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HNQ: // global
           _s1H3J::I64 = I64[R1 + 7] ^ 18446744073709551615;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1H3J::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.234642304 UTC

[section ""data" . Data.Bits.$fBitsWord_$cxor_closure" {
     Data.Bits.$fBitsWord_$cxor_closure:
         const Data.Bits.$fBitsWord_$cxor_info;
 },
 Data.Bits.$fBitsWord_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c1HOd,
                       label: Data.Bits.$fBitsWord_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HOd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HOp; else goto c1HOq;
       c1HOp: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HOq: // global
           I64[Sp - 16] = block_c1HOa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HOw; else goto c1HOb;
       u1HOw: // global
           call _c1HOa(R1) args: 0, res: 0, upd: 0;
       c1HOb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HOa() //  [R1]
         { info_tbl: [(c1HOa,
                       label: block_c1HOa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HOa: // global
           I64[Sp] = block_c1HOg_info;
           _s1H3N::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H3N::I64;
           if (R1 & 7 != 0) goto u1HOv; else goto c1HOh;
       u1HOv: // global
           call _c1HOg(R1) args: 0, res: 0, upd: 0;
       c1HOh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HOg() //  [R1]
         { info_tbl: [(c1HOg,
                       label: block_c1HOg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HOg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HOu; else goto c1HOt;
       c1HOu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HOt: // global
           _s1H3Q::I64 = I64[Sp + 8] ^ I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1H3Q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.242954218 UTC

[section ""data" . Data.Bits.$fBitsWord_$c.|._closure" {
     Data.Bits.$fBitsWord_$c.|._closure:
         const Data.Bits.$fBitsWord_$c.|._info;
 },
 Data.Bits.$fBitsWord_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c1HOX,
                       label: Data.Bits.$fBitsWord_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HOX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HP9; else goto c1HPa;
       c1HP9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$c.|._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HPa: // global
           I64[Sp - 16] = block_c1HOU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HPg; else goto c1HOV;
       u1HPg: // global
           call _c1HOU(R1) args: 0, res: 0, upd: 0;
       c1HOV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HOU() //  [R1]
         { info_tbl: [(c1HOU,
                       label: block_c1HOU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HOU: // global
           I64[Sp] = block_c1HP0_info;
           _s1H3U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H3U::I64;
           if (R1 & 7 != 0) goto u1HPf; else goto c1HP1;
       u1HPf: // global
           call _c1HP0(R1) args: 0, res: 0, upd: 0;
       c1HP1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HP0() //  [R1]
         { info_tbl: [(c1HP0,
                       label: block_c1HP0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HP0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HPe; else goto c1HPd;
       c1HPe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HPd: // global
           _s1H3X::I64 = I64[Sp + 8] | I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1H3X::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.251478482 UTC

[section ""data" . Data.Bits.$fBitsWord_$c.&._closure" {
     Data.Bits.$fBitsWord_$c.&._closure:
         const Data.Bits.$fBitsWord_$c.&._info;
 },
 Data.Bits.$fBitsWord_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c1HPH,
                       label: Data.Bits.$fBitsWord_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HPH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HPT; else goto c1HPU;
       c1HPT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$c.&._closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HPU: // global
           I64[Sp - 16] = block_c1HPE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1HQ0; else goto c1HPF;
       u1HQ0: // global
           call _c1HPE(R1) args: 0, res: 0, upd: 0;
       c1HPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HPE() //  [R1]
         { info_tbl: [(c1HPE,
                       label: block_c1HPE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HPE: // global
           I64[Sp] = block_c1HPK_info;
           _s1H41::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H41::I64;
           if (R1 & 7 != 0) goto u1HPZ; else goto c1HPL;
       u1HPZ: // global
           call _c1HPK(R1) args: 0, res: 0, upd: 0;
       c1HPL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HPK() //  [R1]
         { info_tbl: [(c1HPK,
                       label: block_c1HPK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HPK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HPY; else goto c1HPX;
       c1HPY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HPX: // global
           _s1H44::I64 = I64[Sp + 8] & I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1H44::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.260905749 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure" {
     Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure:
         const Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_info;
 },
 Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_entry() //  [R2]
         { info_tbl: [(c1HQr,
                       label: Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HQr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HQC; else goto c1HQD;
       c1HQC: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HQD: // global
           I64[Sp - 8] = block_c1HQo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HQH; else goto c1HQp;
       u1HQH: // global
           call _c1HQo(R1) args: 0, res: 0, upd: 0;
       c1HQp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HQo() //  [R1]
         { info_tbl: [(c1HQo,
                       label: block_c1HQo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HQo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HQG; else goto c1HQF;
       c1HQG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HQF: // global
           (_c1HQu::I64) = call MO_Ctz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1HQu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.267565487 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure" {
     Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure:
         const Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_info;
 },
 Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_entry() //  [R2]
         { info_tbl: [(c1HR3,
                       label: Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HR3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1HRe; else goto c1HRf;
       c1HRe: // global
           R2 = R2;
           R1 = Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1HRf: // global
           I64[Sp - 8] = block_c1HR0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1HRj; else goto c1HR1;
       u1HRj: // global
           call _c1HR0(R1) args: 0, res: 0, upd: 0;
       c1HR1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1HR0() //  [R1]
         { info_tbl: [(c1HR0,
                       label: block_c1HR0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HR0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HRi; else goto c1HRh;
       c1HRi: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HRh: // global
           (_c1HR6::I64) = call MO_Clz W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _c1HR6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.273618847 UTC

[section ""data" . Data.Bits.$fBitsWord_$cfiniteBitSize_closure" {
     Data.Bits.$fBitsWord_$cfiniteBitSize_closure:
         const Data.Bits.$fBitsWord_$cfiniteBitSize_info;
 },
 Data.Bits.$fBitsWord_$cfiniteBitSize_entry() //  []
         { info_tbl: [(c1HRC,
                       label: Data.Bits.$fBitsWord_$cfiniteBitSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HRC: // global
           R1 = Data.Bits.$fBitsInt1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.278415393 UTC

[section ""data" . Data.Bits.$dmcountTrailingZeros_closure" {
     Data.Bits.$dmcountTrailingZeros_closure:
         const Data.Bits.$dmcountTrailingZeros_info;
 },
 $dBits_s1H4k_entry() //  [R1]
         { info_tbl: [(c1HRW,
                       label: $dBits_s1H4k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HRW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HRX; else goto c1HRY;
       c1HRX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1HRY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcountTrailingZeros_entry() //  [R2, R3]
         { info_tbl: [(c1HRZ,
                       label: Data.Bits.$dmcountTrailingZeros_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HRZ: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c1HS0; else goto c1HS1;
       c1HS0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmcountTrailingZeros_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HS1: // global
           I64[Sp - 24] = block_c1HRO_info;
           _s1H4g::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R3;
           P64[Sp - 16] = _s1H4g::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1HRO() //  [R1]
         { info_tbl: [(c1HRO,
                       label: block_c1HRO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HRO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1HS4; else goto c1HS3;
       c1HS4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HS3: // global
           _s1H4j::I64 = I64[R1 + 7];
           I64[Hp - 16] = $dBits_s1H4k_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           I64[Sp] = _s1H4j::I64;
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call _c1HS8() args: 0, res: 0, upd: 0;
     }
 },
 _c1HS8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HS8: // global
           Hp = Hp + 16;
           _s1H4m::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c1HSc; else goto c1HSb;
       c1HSc: // global
           HpAlloc = 16;
           I64[Sp] = block_c1HS7_info;
           R1 = _s1H4m::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1HSb: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H4m::I64;
           _c1HSd::P64 = Hp - 7;
           if (%MO_S_Lt_W64(_s1H4m::I64,
                            I64[Sp + 8])) goto c1HSj; else goto u1HSz;
       c1HSj: // global
           I64[Sp - 16] = block_c1HSh_info;
           R2 = P64[Sp + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[Sp + 24];
           P64[Sp - 24] = _c1HSd::P64;
           P64[Sp - 8] = _c1HSd::P64;
           Sp = Sp - 40;
           call Data.Bits.testBit_entry(R2) args: 32, res: 8, upd: 8;
       u1HSz: // global
           P64[Sp + 24] = _c1HSd::P64;
           Sp = Sp + 24;
           call _c1HSu() args: 0, res: 0, upd: 0;
     }
 },
 _c1HS7() //  [R1]
         { info_tbl: [(c1HS7,
                       label: block_c1HS7_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HS7: // global
           I64[Sp] = R1;
           call _c1HS8() args: 0, res: 0, upd: 0;
     }
 },
 _c1HSh() //  [R1]
         { info_tbl: [(c1HSh,
                       label: block_c1HSh_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HSh: // global
           if (R1 & 7 == 1) goto c1HSp; else goto u1HSA;
       c1HSp: // global
           I64[Sp + 16] = I64[Sp + 16] + 1;
           Sp = Sp + 16;
           call _c1HS8() args: 0, res: 0, upd: 0;
       u1HSA: // global
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call _c1HSu() args: 0, res: 0, upd: 0;
     }
 },
 _c1HSu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HSu: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.294217755 UTC

[section ""data" . Data.Bits.$dmcountLeadingZeros_closure" {
     Data.Bits.$dmcountLeadingZeros_closure:
         const Data.Bits.$dmcountLeadingZeros_info;
 },
 $dBits_s1H4v_entry() //  [R1]
         { info_tbl: [(c1HTu,
                       label: $dBits_s1H4v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HTu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1HTv; else goto c1HTw;
       c1HTv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1HTw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Bits.$p1FiniteBits_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcountLeadingZeros_entry() //  [R2, R3]
         { info_tbl: [(c1HTx,
                       label: Data.Bits.$dmcountLeadingZeros_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HTx: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c1HTy; else goto c1HTz;
       c1HTy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmcountLeadingZeros_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HTz: // global
           I64[Sp - 24] = block_c1HTm_info;
           _s1H4r::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R3;
           P64[Sp - 16] = _s1H4r::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Data.Bits.finiteBitSize_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1HTm() //  [R1]
         { info_tbl: [(c1HTm,
                       label: block_c1HTm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HTm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1HTC; else goto c1HTB;
       c1HTC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1HTB: // global
           _s1H4u::I64 = I64[R1 + 7];
           I64[Hp - 16] = $dBits_s1H4v_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = _s1H4u::I64 - 1;
           I64[Sp] = _s1H4u::I64;
           P64[Sp + 8] = Hp - 16;
           Sp = Sp - 8;
           call _c1HUd() args: 0, res: 0, upd: 0;
     }
 },
 _c1HUd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HUd: // global
           Hp = Hp + 16;
           _s1H4F::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c1HUh; else goto c1HUg;
       c1HUh: // global
           HpAlloc = 16;
           I64[Sp] = block_c1HUc_info;
           R1 = _s1H4F::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1HUg: // global
           if (%MO_S_Ge_W64(_s1H4F::I64, 0)) goto c1HUo; else goto c1HUz;
       c1HUo: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H4F::I64;
           I64[Sp - 8] = block_c1HUm_info;
           R2 = P64[Sp + 16];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = Hp - 7;
           Sp = Sp - 32;
           call Data.Bits.testBit_entry(R2) args: 32, res: 8, upd: 8;
       c1HUz: // global
           Hp = Hp - 16;
           I64[Sp + 24] = _s1H4F::I64;
           Sp = Sp + 8;
           call _c1HTY() args: 0, res: 0, upd: 0;
     }
 },
 _c1HUc() //  [R1]
         { info_tbl: [(c1HUc,
                       label: block_c1HUc_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HUc: // global
           I64[Sp] = R1;
           call _c1HUd() args: 0, res: 0, upd: 0;
     }
 },
 _c1HUm() //  [R1]
         { info_tbl: [(c1HUm,
                       label: block_c1HUm_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HUm: // global
           _s1H4F::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c1HUu; else goto c1HUy;
       c1HUu: // global
           I64[Sp + 8] = _s1H4F::I64 - 1;
           Sp = Sp + 8;
           call _c1HUd() args: 0, res: 0, upd: 0;
       c1HUy: // global
           I64[Sp + 32] = _s1H4F::I64;
           Sp = Sp + 16;
           call _c1HTJ() args: 0, res: 0, upd: 0;
     }
 },
 _c1HTJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HTJ: // global
           Hp = Hp + 16;
           _s1H4x::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c1HTU; else goto c1HTT;
       c1HTU: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1HTI_info;
           R1 = _s1H4x::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1HTT: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp] + ((-1) - _s1H4x::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1HTI() //  [R1]
         { info_tbl: [(c1HTI,
                       label: block_c1HTI_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HTI: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c1HTJ() args: 0, res: 0, upd: 0;
     }
 },
 _c1HTY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HTY: // global
           Hp = Hp + 16;
           _s1H4B::I64 = I64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c1HU9; else goto c1HU8;
       c1HU9: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1HTX_info;
           R1 = _s1H4B::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1HU8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp] + ((-1) - _s1H4B::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1HTX() //  [R1]
         { info_tbl: [(c1HTX,
                       label: block_c1HTX_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HTX: // global
           I64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c1HTY() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.314764618 UTC

[section ""data" . Data.Bits.$dmrotateR_closure" {
     Data.Bits.$dmrotateR_closure:
         const Data.Bits.$dmrotateR_info;
 },
 sat_s1H4R_entry() //  [R1]
         { info_tbl: [(c1HVZ,
                       label: sat_s1H4R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HVZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1HW6; else goto c1HW7;
       c1HW6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1HW7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1HVW_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1HWb; else goto c1HVX;
       u1HWb: // global
           call _c1HVW(R1) args: 0, res: 0, upd: 0;
       c1HVX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1HVW() //  [R1]
         { info_tbl: [(c1HVW,
                       label: block_c1HVW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HVW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HWa; else goto c1HW9;
       c1HWa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1HW9: // global
           _s1H4Q::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H4Q::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmrotateR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1HWc,
                       label: Data.Bits.$dmrotateR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HWc: // global
           _s1H4N::P64 = R4;
           _s1H4M::P64 = R3;
           _s1H4L::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1HWd; else goto c1HWe;
       c1HWe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1HWg; else goto c1HWf;
       c1HWg: // global
           HpAlloc = 24;
           goto c1HWd;
       c1HWd: // global
           R4 = _s1H4N::P64;
           R3 = _s1H4M::P64;
           R2 = _s1H4L::P64;
           R1 = Data.Bits.$dmrotateR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HWf: // global
           I64[Hp - 16] = sat_s1H4R_info;
           P64[Hp] = _s1H4N::P64;
           R2 = _s1H4L::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1H4M::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Data.Bits.rotate_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.323541173 UTC

[section ""data" . Data.Bits.$dmrotateL_closure" {
     Data.Bits.$dmrotateL_closure:
         const Data.Bits.$dmrotateL_info;
 },
 Data.Bits.$dmrotateL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1HWF,
                       label: Data.Bits.$dmrotateL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HWF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1HWG; else goto c1HWH;
       c1HWG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmrotateL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HWH: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.rotate_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.327624593 UTC

[section ""data" . Data.Bits.$dmunsafeShiftR_closure" {
     Data.Bits.$dmunsafeShiftR_closure:
         const Data.Bits.$dmunsafeShiftR_info;
 },
 Data.Bits.$dmunsafeShiftR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1HWS,
                       label: Data.Bits.$dmunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HWS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1HWT; else goto c1HWU;
       c1HWT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmunsafeShiftR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HWU: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shiftR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.332222414 UTC

[section ""data" . Data.Bits.$dmshiftR_closure" {
     Data.Bits.$dmshiftR_closure:
         const Data.Bits.$dmshiftR_info;
 },
 sat_s1H54_entry() //  [R1]
         { info_tbl: [(c1HXc,
                       label: sat_s1H54_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HXc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1HXj; else goto c1HXk;
       c1HXj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1HXk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1HX9_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1HXo; else goto c1HXa;
       u1HXo: // global
           call _c1HX9(R1) args: 0, res: 0, upd: 0;
       c1HXa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1HX9() //  [R1]
         { info_tbl: [(c1HX9,
                       label: block_c1HX9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HX9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1HXn; else goto c1HXm;
       c1HXn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1HXm: // global
           _s1H53::I64 = -I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H53::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmshiftR_entry() //  [R2, R3, R4]
         { info_tbl: [(c1HXp,
                       label: Data.Bits.$dmshiftR_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HXp: // global
           _s1H50::P64 = R4;
           _s1H4Z::P64 = R3;
           _s1H4Y::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1HXq; else goto c1HXr;
       c1HXr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1HXt; else goto c1HXs;
       c1HXt: // global
           HpAlloc = 24;
           goto c1HXq;
       c1HXq: // global
           R4 = _s1H50::P64;
           R3 = _s1H4Z::P64;
           R2 = _s1H4Y::P64;
           R1 = Data.Bits.$dmshiftR_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HXs: // global
           I64[Hp - 16] = sat_s1H54_info;
           P64[Hp] = _s1H50::P64;
           R2 = _s1H4Y::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1H4Z::P64;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 24;
           call Data.Bits.shift_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.341833224 UTC

[section ""data" . Data.Bits.$dmunsafeShiftL_closure" {
     Data.Bits.$dmunsafeShiftL_closure:
         const Data.Bits.$dmunsafeShiftL_info;
 },
 Data.Bits.$dmunsafeShiftL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1HXS,
                       label: Data.Bits.$dmunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HXS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1HXT; else goto c1HXU;
       c1HXT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmunsafeShiftL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HXU: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.346008492 UTC

[section ""data" . Data.Bits.$dmshiftL_closure" {
     Data.Bits.$dmshiftL_closure:
         const Data.Bits.$dmshiftL_info;
 },
 Data.Bits.$dmshiftL_entry() //  [R2, R3, R4]
         { info_tbl: [(c1HY5,
                       label: Data.Bits.$dmshiftL_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HY5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1HY6; else goto c1HY7;
       c1HY6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmshiftL_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HY7: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call Data.Bits.shift_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.350188099 UTC

[section ""data" . Data.Bits.$dmcomplementBit_closure" {
     Data.Bits.$dmcomplementBit_closure:
         const Data.Bits.$dmcomplementBit_info;
 },
 sat_s1H5e_entry() //  [R1]
         { info_tbl: [(c1HYm,
                       label: sat_s1H5e_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HYm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1HYn; else goto c1HYo;
       c1HYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1HYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmcomplementBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1HYp,
                       label: Data.Bits.$dmcomplementBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HYp: // global
           _s1H5d::P64 = R4;
           _s1H5c::P64 = R3;
           _s1H5b::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1HYq; else goto c1HYr;
       c1HYr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1HYt; else goto c1HYs;
       c1HYt: // global
           HpAlloc = 32;
           goto c1HYq;
       c1HYq: // global
           R4 = _s1H5d::P64;
           R3 = _s1H5c::P64;
           R2 = _s1H5b::P64;
           R1 = Data.Bits.$dmcomplementBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HYs: // global
           I64[Hp - 24] = sat_s1H5e_info;
           P64[Hp - 8] = _s1H5b::P64;
           P64[Hp] = _s1H5d::P64;
           R2 = _s1H5b::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1H5c::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits.xor_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.357065834 UTC

[section ""data" . Data.Bits.$dmclearBit_closure" {
     Data.Bits.$dmclearBit_closure:
         const Data.Bits.$dmclearBit_info;
 },
 sat_s1H5i_entry() //  [R1]
         { info_tbl: [(c1HYV,
                       label: sat_s1H5i_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HYV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1HYW; else goto c1HYX;
       c1HYW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1HYX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1H5j_entry() //  [R1]
         { info_tbl: [(c1HYY,
                       label: sat_s1H5j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HYY: // global
           _s1H5j::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1HYZ; else goto c1HZ0;
       c1HZ0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1HZ2; else goto c1HZ1;
       c1HZ2: // global
           HpAlloc = 32;
           goto c1HYZ;
       c1HYZ: // global
           R1 = _s1H5j::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1HZ1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1H5j::P64;
           _s1H5f::P64 = P64[_s1H5j::P64 + 16];
           _s1H5h::P64 = P64[_s1H5j::P64 + 24];
           I64[Hp - 24] = sat_s1H5i_info;
           P64[Hp - 8] = _s1H5f::P64;
           P64[Hp] = _s1H5h::P64;
           R2 = _s1H5f::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call Data.Bits.complement_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmclearBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1HZ3,
                       label: Data.Bits.$dmclearBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HZ3: // global
           _s1H5h::P64 = R4;
           _s1H5g::P64 = R3;
           _s1H5f::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1HZ4; else goto c1HZ5;
       c1HZ5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1HZ7; else goto c1HZ6;
       c1HZ7: // global
           HpAlloc = 32;
           goto c1HZ4;
       c1HZ4: // global
           R4 = _s1H5h::P64;
           R3 = _s1H5g::P64;
           R2 = _s1H5f::P64;
           R1 = Data.Bits.$dmclearBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HZ6: // global
           I64[Hp - 24] = sat_s1H5j_info;
           P64[Hp - 8] = _s1H5f::P64;
           P64[Hp] = _s1H5h::P64;
           R2 = _s1H5f::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1H5g::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits..&._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.366212321 UTC

[section ""data" . Data.Bits.$dmsetBit_closure" {
     Data.Bits.$dmsetBit_closure:
         const Data.Bits.$dmsetBit_info;
 },
 sat_s1H5n_entry() //  [R1]
         { info_tbl: [(c1HZD,
                       label: sat_s1H5n_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HZD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1HZE; else goto c1HZF;
       c1HZE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1HZF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmsetBit_entry() //  [R2, R3, R4]
         { info_tbl: [(c1HZG,
                       label: Data.Bits.$dmsetBit_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1HZG: // global
           _s1H5m::P64 = R4;
           _s1H5l::P64 = R3;
           _s1H5k::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1HZH; else goto c1HZI;
       c1HZI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1HZK; else goto c1HZJ;
       c1HZK: // global
           HpAlloc = 32;
           goto c1HZH;
       c1HZH: // global
           R4 = _s1H5m::P64;
           R3 = _s1H5l::P64;
           R2 = _s1H5k::P64;
           R1 = Data.Bits.$dmsetBit_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1HZJ: // global
           I64[Hp - 24] = sat_s1H5n_info;
           P64[Hp - 8] = _s1H5k::P64;
           P64[Hp] = _s1H5m::P64;
           R2 = _s1H5k::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s1H5l::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Data.Bits..|._entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.372969646 UTC

[section ""data" . Data.Bits.$dmzeroBits_closure" {
     Data.Bits.$dmzeroBits_closure:
         const Data.Bits.$dmzeroBits_info;
 },
 sat_s1H5p_entry() //  [R1]
         { info_tbl: [(c1I08,
                       label: sat_s1H5p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I08: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1I09; else goto c1I0a;
       c1I09: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1I0a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.$dmzeroBits_entry() //  [R2]
         { info_tbl: [(c1I0b,
                       label: Data.Bits.$dmzeroBits_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I0b: // global
           _s1H5o::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1I0c; else goto c1I0d;
       c1I0d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1I0f; else goto c1I0e;
       c1I0f: // global
           HpAlloc = 24;
           goto c1I0c;
       c1I0c: // global
           R2 = _s1H5o::P64;
           R1 = Data.Bits.$dmzeroBits_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1I0e: // global
           I64[Hp - 16] = sat_s1H5p_info;
           P64[Hp] = _s1H5o::P64;
           R2 = _s1H5o::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp - 24;
           call Data.Bits.clearBit_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.380408854 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotateL_closure" {
     Data.Bits.$fBitsBool_$crotateL_closure:
         const Data.Bits.$fBitsBool_$crotateL_info;
 },
 Data.Bits.$fBitsBool_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1I0A,
                       label: Data.Bits.$fBitsBool_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I0A: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.384052587 UTC

[section ""data" . Data.Bits.$fBitsBool_$cshiftR_closure" {
     Data.Bits.$fBitsBool_$cshiftR_closure:
         const Data.Bits.$fBitsBool_$cshiftR_info;
 },
 Data.Bits.$fBitsBool_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c1I0L,
                       label: Data.Bits.$fBitsBool_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I0L: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$ctestBit_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.387659026 UTC

[section ""data" . Data.Bits.$fBitsBool_$cunsafeShiftR_closure" {
     Data.Bits.$fBitsBool_$cunsafeShiftR_closure:
         const Data.Bits.$fBitsBool_$cunsafeShiftR_info;
 },
 Data.Bits.$fBitsBool_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c1I0W,
                       label: Data.Bits.$fBitsBool_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I0W: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$cshiftR_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.391163051 UTC

[section ""data" . Data.Bits.$fBitsBool_$cshiftL_closure" {
     Data.Bits.$fBitsBool_$cshiftL_closure:
         const Data.Bits.$fBitsBool_$cshiftL_info;
 },
 Data.Bits.$fBitsBool_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c1I17,
                       label: Data.Bits.$fBitsBool_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I17: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$ctestBit_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.394669714 UTC

[section ""data" . Data.Bits.$fBitsBool_$cunsafeShiftL_closure" {
     Data.Bits.$fBitsBool_$cunsafeShiftL_closure:
         const Data.Bits.$fBitsBool_$cunsafeShiftL_info;
 },
 Data.Bits.$fBitsBool_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c1I1i,
                       label: Data.Bits.$fBitsBool_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I1i: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$cshiftL_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.398925371 UTC

[section ""data" . Data.Bits.$fBitsBool_$ccomplementBit_closure" {
     Data.Bits.$fBitsBool_$ccomplementBit_closure:
         const Data.Bits.$fBitsBool_$ccomplementBit_info;
 },
 Data.Bits.$fBitsBool_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1I1A,
                       label: Data.Bits.$fBitsBool_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I1A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1I1B; else goto c1I1C;
       c1I1B: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1I1C: // global
           I64[Sp - 16] = block_c1I1t_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1I29; else goto c1I1u;
       u1I29: // global
           call _c1I1t(R1) args: 0, res: 0, upd: 0;
       c1I1u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I1t() //  [R1]
         { info_tbl: [(c1I1t,
                       label: block_c1I1t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I1t: // global
           _s1H5r::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c1I1x; else goto c1I1y;
       c1I1x: // global
           I64[Sp + 8] = block_c1I1F_info;
           R1 = _s1H5r::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1I27; else goto c1I1H;
       u1I27: // global
           call _c1I1F(R1) args: 0, res: 0, upd: 0;
       c1I1H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1I1y: // global
           I64[Sp + 8] = block_c1I1S_info;
           R1 = _s1H5r::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1I28; else goto c1I1U;
       u1I28: // global
           call _c1I1S(R1) args: 0, res: 0, upd: 0;
       c1I1U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I1F() //  [R1]
         { info_tbl: [(c1I1F,
                       label: block_c1I1F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I1F: // global
           if (I64[R1 + 7] == 0) goto u1I25; else goto u1I26;
       u1I25: // global
           Sp = Sp + 8;
           call _c1I21() args: 0, res: 0, upd: 0;
       u1I26: // global
           Sp = Sp + 8;
           call _c1I22() args: 0, res: 0, upd: 0;
     }
 },
 _c1I1S() //  [R1]
         { info_tbl: [(c1I1S,
                       label: block_c1I1S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I1S: // global
           if (I64[R1 + 7] == 0) goto u1I23; else goto u1I24;
       u1I23: // global
           Sp = Sp + 8;
           call _c1I22() args: 0, res: 0, upd: 0;
       u1I24: // global
           Sp = Sp + 8;
           call _c1I21() args: 0, res: 0, upd: 0;
     }
 },
 _c1I22() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I22: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1I21() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I21: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.411835045 UTC

[section ""data" . Data.Bits.$fBitsBool_$cclearBit_closure" {
     Data.Bits.$fBitsBool_$cclearBit_closure:
         const Data.Bits.$fBitsBool_$cclearBit_info;
 },
 Data.Bits.$fBitsBool_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1I2T,
                       label: Data.Bits.$fBitsBool_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I2T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1I2U; else goto c1I2V;
       c1I2U: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1I2V: // global
           I64[Sp - 16] = block_c1I2M_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1I3g; else goto c1I2N;
       u1I3g: // global
           call _c1I2M(R1) args: 0, res: 0, upd: 0;
       c1I2N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I2M() //  [R1]
         { info_tbl: [(c1I2M,
                       label: block_c1I2M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I2M: // global
           if (R1 & 7 == 1) goto u1I3c; else goto c1I2R;
       u1I3c: // global
           Sp = Sp + 16;
           call _c1I3b() args: 0, res: 0, upd: 0;
       c1I2R: // global
           _s1H5A::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c1I31_info;
           R1 = _s1H5A::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u1I3e; else goto c1I33;
       u1I3e: // global
           call _c1I31(R1) args: 0, res: 0, upd: 0;
       c1I33: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I31() //  [R1]
         { info_tbl: [(c1I31,
                       label: block_c1I31_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I31: // global
           if (I64[R1 + 7] == 0) goto u1I3d; else goto c1I3a;
       u1I3d: // global
           Sp = Sp + 8;
           call _c1I3b() args: 0, res: 0, upd: 0;
       c1I3a: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1I3b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I3b: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.421079065 UTC

[section ""data" . Data.Bits.$fBitsBool_$csetBit_closure" {
     Data.Bits.$fBitsBool_$csetBit_closure:
         const Data.Bits.$fBitsBool_$csetBit_info;
 },
 Data.Bits.$fBitsBool_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1I3Q,
                       label: Data.Bits.$fBitsBool_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I3Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1I3R; else goto c1I3S;
       c1I3R: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsBool_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1I3S: // global
           I64[Sp - 16] = block_c1I3J_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1I3Z; else goto c1I3K;
       u1I3Z: // global
           call _c1I3J(R1) args: 0, res: 0, upd: 0;
       c1I3K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I3J() //  [R1]
         { info_tbl: [(c1I3J,
                       label: block_c1I3J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I3J: // global
           if (R1 & 7 == 1) goto c1I3N; else goto c1I3O;
       c1I3N: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Bits.$fBitsBool_$cbit_entry(R2) args: 8, res: 0, upd: 8;
       c1I3O: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.427258286 UTC

[section ""data" . Data.Bits.$fBitsBool_$crotateR_closure" {
     Data.Bits.$fBitsBool_$crotateR_closure:
         const Data.Bits.$fBitsBool_$crotateR_info;
 },
 Data.Bits.$fBitsBool_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1I4i,
                       label: Data.Bits.$fBitsBool_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I4i: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsBool_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.430712567 UTC

[section ""data" . Data.Bits.$fBitsBool_closure" {
     Data.Bits.$fBitsBool_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqBool_closure;
         const GHC.Classes.&&_closure+2;
         const GHC.Classes.||_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const GHC.Classes.not_closure+1;
         const Data.Bits.$fBitsBool_$ctestBit_closure+2;
         const Data.Bits.$fBitsBool_$crotate_closure+2;
         const GHC.Types.False_closure+1;
         const Data.Bits.$fBitsBool_$cbit_closure+1;
         const Data.Bits.$fBitsBool_$csetBit_closure+2;
         const Data.Bits.$fBitsBool_$cclearBit_closure+2;
         const Data.Bits.$fBitsBool_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsBool_$ctestBit_closure+2;
         const Data.Bits.$fBitsBool_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsBool_$cbitSize_closure+1;
         const Data.Bits.$fBitsBool_$cisSigned_closure+1;
         const Data.Bits.$fBitsBool_$cshiftL_closure+2;
         const Data.Bits.$fBitsBool_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsBool_$cshiftR_closure+2;
         const Data.Bits.$fBitsBool_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsBool_$crotateL_closure+2;
         const Data.Bits.$fBitsBool_$crotateR_closure+2;
         const Data.Bits.$fBitsBool_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.433082298 UTC

[section ""data" . Data.Bits.$fFiniteBitsBool_closure" {
     Data.Bits.$fFiniteBitsBool_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsBool_closure+1;
         const Data.Bits.$fBitsBool_$cbitSize_closure+1;
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure+1;
         const Data.Bits.$fFiniteBitsBool_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.436048671 UTC

[section ""data" . Data.Bits.$dmrotate_closure" {
     Data.Bits.$dmrotate_closure:
         const Data.Bits.$dmrotate_info;
 },
 Data.Bits.$dmrotate_entry() //  [R2, R3, R4]
         { info_tbl: [(c1I4y,
                       label: Data.Bits.$dmrotate_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I4y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1I4z; else goto c1I4A;
       c1I4z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmrotate_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1I4A: // global
           I64[Sp - 24] = block_c1I4v_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1I4W; else goto c1I4w;
       u1I4W: // global
           call _c1I4v(R1) args: 0, res: 0, upd: 0;
       c1I4w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I4v() //  [R1]
         { info_tbl: [(c1I4v,
                       label: block_c1I4v_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I4v: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1I4F; else goto c1I4E;
       c1I4F: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1I4E: // global
           _s1H5I::P64 = P64[Sp + 8];
           _s1H5J::P64 = P64[Sp + 16];
           _s1H5M::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1H5M::I64, 0)) goto c1I4P; else goto c1I4Q;
       c1I4P: // global
           if (%MO_S_Le_W64(_s1H5M::I64, 0)) goto c1I4M; else goto c1I4N;
       c1I4M: // global
           Hp = Hp - 16;
           R1 = _s1H5J::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1I4N: // global
           Hp = Hp - 16;
           R2 = _s1H5I::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1H5J::P64;
           P64[Sp + 16] = R1;
           call Data.Bits.rotateL_entry(R2) args: 32, res: 0, upd: 8;
       c1I4Q: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1H5M::I64;
           R2 = _s1H5I::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1H5J::P64;
           P64[Sp + 16] = Hp - 7;
           call Data.Bits.rotateR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.443878893 UTC

[section ""data" . Data.Bits.$dmshift_closure" {
     Data.Bits.$dmshift_closure:
         const Data.Bits.$dmshift_info;
 },
 Data.Bits.$dmshift_entry() //  [R2, R3, R4]
         { info_tbl: [(c1I5j,
                       label: Data.Bits.$dmshift_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I5j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1I5k; else goto c1I5l;
       c1I5k: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$dmshift_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1I5l: // global
           I64[Sp - 24] = block_c1I5g_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1I5H; else goto c1I5h;
       u1I5H: // global
           call _c1I5g(R1) args: 0, res: 0, upd: 0;
       c1I5h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I5g() //  [R1]
         { info_tbl: [(c1I5g,
                       label: block_c1I5g_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I5g: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1I5q; else goto c1I5p;
       c1I5q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1I5p: // global
           _s1H5R::P64 = P64[Sp + 8];
           _s1H5S::P64 = P64[Sp + 16];
           _s1H5V::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1H5V::I64, 0)) goto c1I5A; else goto c1I5B;
       c1I5A: // global
           if (%MO_S_Le_W64(_s1H5V::I64, 0)) goto c1I5x; else goto c1I5y;
       c1I5x: // global
           Hp = Hp - 16;
           R1 = _s1H5S::P64;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c1I5y: // global
           Hp = Hp - 16;
           R2 = _s1H5R::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1H5S::P64;
           P64[Sp + 16] = R1;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
       c1I5B: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = -_s1H5V::I64;
           R2 = _s1H5R::P64;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = _s1H5S::P64;
           P64[Sp + 16] = Hp - 7;
           call Data.Bits.shiftR_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.452445978 UTC

[section ""data" . Data.Bits.bitDefault_closure" {
     Data.Bits.bitDefault_closure:
         const Data.Bits.bitDefault_info;
         const 0;
 },
 sat_s1H63_entry() //  [R1]
         { info_tbl: [(c1I65,
                       label: sat_s1H63_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I65: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1I66; else goto c1I67;
       c1I66: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1I67: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.bitDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1I68,
                       label: Data.Bits.bitDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I68: // global
           _s1H62::P64 = R4;
           _s1H61::P64 = R3;
           _s1H60::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1I69; else goto c1I6a;
       c1I6a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1I6c; else goto c1I6b;
       c1I6c: // global
           HpAlloc = 24;
           goto c1I69;
       c1I69: // global
           R4 = _s1H62::P64;
           R3 = _s1H61::P64;
           R2 = _s1H60::P64;
           R1 = Data.Bits.bitDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1I6b: // global
           I64[Hp - 16] = sat_s1H63_info;
           P64[Hp] = _s1H61::P64;
           R2 = _s1H60::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1H62::P64;
           Sp = Sp - 24;
           call Data.Bits.shiftL_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.4596765 UTC

[section ""data" . Data.Bits.testBitDefault_closure" {
     Data.Bits.testBitDefault_closure:
         const Data.Bits.testBitDefault_info;
         const 0;
 },
 sat_s1H6b_entry() //  [R1]
         { info_tbl: [(c1I6A,
                       label: sat_s1H6b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I6A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1I6B; else goto c1I6C;
       c1I6B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1I6C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1H69_entry() //  [R1]
         { info_tbl: [(c1I6L,
                       label: sat_s1H69_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I6L: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1I6M; else goto c1I6N;
       c1I6M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1I6N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1H6a_entry() //  [R1]
         { info_tbl: [(c1I6O,
                       label: sat_s1H6a_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I6O: // global
           _s1H6a::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1I6P; else goto c1I6Q;
       c1I6Q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1I6S; else goto c1I6R;
       c1I6S: // global
           HpAlloc = 32;
           goto c1I6P;
       c1I6P: // global
           R1 = _s1H6a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1I6R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1H6a::P64;
           _s1H64::P64 = P64[_s1H6a::P64 + 16];
           _s1H66::P64 = P64[_s1H6a::P64 + 24];
           _s1H67::P64 = P64[_s1H6a::P64 + 32];
           I64[Hp - 24] = sat_s1H69_info;
           P64[Hp - 8] = _s1H64::P64;
           P64[Hp] = _s1H67::P64;
           R2 = _s1H64::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1H66::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 40;
           call Data.Bits..&._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Bits.testBitDefault_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1I6V,
                       label: Data.Bits.testBitDefault_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I6V: // global
           _s1H67::P64 = R5;
           _s1H66::P64 = R4;
           _s1H65::P64 = R3;
           _s1H64::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c1I6W; else goto c1I6X;
       c1I6X: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c1I6Z; else goto c1I6Y;
       c1I6Z: // global
           HpAlloc = 64;
           goto c1I6W;
       c1I6W: // global
           R5 = _s1H67::P64;
           R4 = _s1H66::P64;
           R3 = _s1H65::P64;
           R2 = _s1H64::P64;
           R1 = Data.Bits.testBitDefault_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1I6Y: // global
           I64[Hp - 56] = sat_s1H6b_info;
           P64[Hp - 40] = _s1H65::P64;
           I64[Hp - 32] = sat_s1H6a_info;
           P64[Hp - 16] = _s1H64::P64;
           P64[Hp - 8] = _s1H66::P64;
           P64[Hp] = _s1H67::P64;
           I64[Sp - 24] = block_c1I6T_info;
           R2 = _s1H64::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 24;
           call Data.Bits.$p1Bits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1I6T() //  [R1]
         { info_tbl: [(c1I6T,
                       label: block_c1I6T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I6T: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _c1I6w::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _c1I6w::P64;
           call GHC.Classes./=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.472642679 UTC

[section ""data" . Data.Bits.$fBitsInt2_closure" {
     Data.Bits.$fBitsInt2_closure:
         const GHC.Base.Just_con_info;
         const Data.Bits.$fBitsInt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.474778845 UTC

[section ""data" . Data.Bits.$fBitsWord_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsWord_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsWord_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsWord_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1I7J,
                       label: Data.Bits.$fBitsWord_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I7J: // global
           R1 = Data.Bits.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.478791859 UTC

[section ""data" . Data.Bits.$fBitsWord_$cbit_closure" {
     Data.Bits.$fBitsWord_$cbit_closure:
         const Data.Bits.$fBitsWord_$cbit_info;
 },
 Data.Bits.$fBitsWord_$cbit_entry() //  [R2]
         { info_tbl: [(c1I7Y,
                       label: Data.Bits.$fBitsWord_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I7Y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1I7Z; else goto c1I80;
       c1I7Z: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1I80: // global
           I64[Sp - 8] = block_c1I7V_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1I8g; else goto c1I7W;
       u1I8g: // global
           call _c1I7V(R1) args: 0, res: 0, upd: 0;
       c1I7W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I7V() //  [R1]
         { info_tbl: [(c1I7V,
                       label: block_c1I7V_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I7V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1I85; else goto c1I84;
       c1I85: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1I84: // global
           _s1H6f::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H6f::I64, 64)) goto c1I8e; else goto c1I8f;
       c1I8e: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = 1 << _s1H6f::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1I8f: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsWord1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.485953608 UTC

[section ""data" . Data.Bits.$fBitsWord_$ctestBit_closure" {
     Data.Bits.$fBitsWord_$ctestBit_closure:
         const Data.Bits.$fBitsWord_$ctestBit_info;
 },
 Data.Bits.$fBitsWord_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1I8C,
                       label: Data.Bits.$fBitsWord_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I8C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1I8G; else goto c1I8H;
       c1I8G: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1I8H: // global
           I64[Sp - 16] = block_c1I8z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1I9d; else goto c1I8A;
       u1I9d: // global
           call _c1I8z(R1) args: 0, res: 0, upd: 0;
       c1I8A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I8z() //  [R1]
         { info_tbl: [(c1I8z,
                       label: block_c1I8z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I8z: // global
           I64[Sp] = block_c1I8F_info;
           _s1H6l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H6l::I64;
           if (R1 & 7 != 0) goto u1I9c; else goto c1I8J;
       u1I9c: // global
           call _c1I8F(R1) args: 0, res: 0, upd: 0;
       c1I8J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I8F() //  [R1]
         { info_tbl: [(c1I8F,
                       label: block_c1I8F_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I8F: // global
           _s1H6n::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1H6n::I64, 64)) goto c1I9b; else goto c1I9a;
       c1I9a: // global
           if (I64[Sp + 8] & (1 << _s1H6n::I64) == 0) goto c1I9b; else goto c1I8Z;
       c1I9b: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1I8Z: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.496021715 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotateR_closure" {
     Data.Bits.$fBitsWord_$crotateR_closure:
         const Data.Bits.$fBitsWord_$crotateR_info;
 },
 Data.Bits.$fBitsWord_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1I9H,
                       label: Data.Bits.$fBitsWord_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I9H: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1I9L; else goto c1I9M;
       c1I9L: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1I9M: // global
           I64[Sp - 16] = block_c1I9E_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Iat; else goto c1I9F;
       u1Iat: // global
           call _c1I9E(R1) args: 0, res: 0, upd: 0;
       c1I9F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I9E() //  [R1]
         { info_tbl: [(c1I9E,
                       label: block_c1I9E_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I9E: // global
           I64[Sp - 8] = block_c1I9K_info;
           _s1H6t::P64 = R1;
           _s1H6u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1H6u::I64;
           P64[Sp + 8] = _s1H6t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Ias; else goto c1I9O;
       u1Ias: // global
           call _c1I9K(R1) args: 0, res: 0, upd: 0;
       c1I9O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1I9K() //  [R1]
         { info_tbl: [(c1I9K,
                       label: block_c1I9K_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I9K: // global
           _s1H6y::I64 = -I64[R1 + 7] & 63;
           if (_s1H6y::I64 != 0) goto u1Iaq; else goto c1Iam;
       u1Iaq: // global
           I64[Sp + 16] = _s1H6y::I64;
           Sp = Sp + 8;
           call _c1Ia0() args: 0, res: 0, upd: 0;
       c1Iam: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Ia0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ia0: // global
           Hp = Hp + 16;
           _s1H6y::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c1Iaj; else goto c1Iai;
       c1Iaj: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c1I9Z_info;
           R1 = _s1H6y::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1Iai: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           _s1H6u::I64 = I64[Sp];
           I64[Hp] = (_s1H6u::I64 << _s1H6y::I64) | (_s1H6u::I64 >> 64 - _s1H6y::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1I9Z() //  [R1]
         { info_tbl: [(c1I9Z,
                       label: block_c1I9Z_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1I9Z: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c1Ia0() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.507836765 UTC

[section ""data" . Data.Bits.$fBitsWord_$ccomplementBit_closure" {
     Data.Bits.$fBitsWord_$ccomplementBit_closure:
         const Data.Bits.$fBitsWord_$ccomplementBit_info;
 },
 Data.Bits.$fBitsWord_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1Ib8,
                       label: Data.Bits.$fBitsWord_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ib8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Ibc; else goto c1Ibd;
       c1Ibc: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ibd: // global
           I64[Sp - 16] = block_c1Ib5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1IbA; else goto c1Ib6;
       u1IbA: // global
           call _c1Ib5(R1) args: 0, res: 0, upd: 0;
       c1Ib6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ib5() //  [R1]
         { info_tbl: [(c1Ib5,
                       label: block_c1Ib5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ib5: // global
           I64[Sp - 8] = block_c1Ibb_info;
           _s1H6F::P64 = R1;
           _s1H6G::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1H6G::I64;
           P64[Sp + 8] = _s1H6F::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Ibz; else goto c1Ibf;
       u1Ibz: // global
           call _c1Ibb(R1) args: 0, res: 0, upd: 0;
       c1Ibf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ibb() //  [R1]
         { info_tbl: [(c1Ibb,
                       label: block_c1Ibb_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ibb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ibl; else goto c1Ibk;
       c1Ibl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Ibk: // global
           _s1H6I::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H6I::I64, 64)) goto c1Ibx; else goto c1Iby;
       c1Ibx: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s1H6I::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Iby: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.517167164 UTC

[section ""data" . Data.Bits.$fBitsWord_$cclearBit_closure" {
     Data.Bits.$fBitsWord_$cclearBit_closure:
         const Data.Bits.$fBitsWord_$cclearBit_info;
 },
 Data.Bits.$fBitsWord_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1Ic4,
                       label: Data.Bits.$fBitsWord_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ic4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Ic8; else goto c1Ic9;
       c1Ic8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ic9: // global
           I64[Sp - 16] = block_c1Ic1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1IcE; else goto c1Ic2;
       u1IcE: // global
           call _c1Ic1(R1) args: 0, res: 0, upd: 0;
       c1Ic2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ic1() //  [R1]
         { info_tbl: [(c1Ic1,
                       label: block_c1Ic1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ic1: // global
           I64[Sp] = block_c1Ic7_info;
           _s1H6P::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H6P::I64;
           if (R1 & 7 != 0) goto u1IcD; else goto c1Icb;
       u1IcD: // global
           call _c1Ic7(R1) args: 0, res: 0, upd: 0;
       c1Icb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ic7() //  [R1]
         { info_tbl: [(c1Ic7,
                       label: block_c1Ic7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ic7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ich; else goto c1Icg;
       c1Ich: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Icg: // global
           _s1H6P::I64 = I64[Sp + 8];
           _s1H6R::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H6R::I64, 64)) goto c1Icw; else goto c1IcC;
       c1Icw: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1H6P::I64 & (1 << _s1H6R::I64) ^ 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1IcC: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s1H6P::I64 & 18446744073709551615;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.526692173 UTC

[section ""data" . Data.Bits.$fBitsWord_$csetBit_closure" {
     Data.Bits.$fBitsWord_$csetBit_closure:
         const Data.Bits.$fBitsWord_$csetBit_info;
 },
 Data.Bits.$fBitsWord_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1Idc,
                       label: Data.Bits.$fBitsWord_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Idc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Idg; else goto c1Idh;
       c1Idg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsWord_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Idh: // global
           I64[Sp - 16] = block_c1Id9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1IdE; else goto c1Ida;
       u1IdE: // global
           call _c1Id9(R1) args: 0, res: 0, upd: 0;
       c1Ida: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Id9() //  [R1]
         { info_tbl: [(c1Id9,
                       label: block_c1Id9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Id9: // global
           I64[Sp - 8] = block_c1Idf_info;
           _s1H6Z::P64 = R1;
           _s1H70::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1H70::I64;
           P64[Sp + 8] = _s1H6Z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IdD; else goto c1Idj;
       u1IdD: // global
           call _c1Idf(R1) args: 0, res: 0, upd: 0;
       c1Idj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Idf() //  [R1]
         { info_tbl: [(c1Idf,
                       label: block_c1Idf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Idf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Idp; else goto c1Ido;
       c1Idp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Ido: // global
           _s1H72::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H72::I64, 64)) goto c1IdB; else goto c1IdC;
       c1IdB: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s1H72::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1IdC: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.536535464 UTC

[section ""data" . Data.Bits.$fBitsWord_$crotateL_closure" {
     Data.Bits.$fBitsWord_$crotateL_closure:
         const Data.Bits.$fBitsWord_$crotateL_info;
 },
 Data.Bits.$fBitsWord_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1Ie5,
                       label: Data.Bits.$fBitsWord_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ie5: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsWord_$crotate_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.540037577 UTC

[section ""data" . Data.Bits.$fBitsWord_closure" {
     Data.Bits.$fBitsWord_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqWord_closure;
         const Data.Bits.$fBitsWord_$c.&._closure+2;
         const Data.Bits.$fBitsWord_$c.|._closure+2;
         const Data.Bits.$fBitsWord_$cxor_closure+2;
         const Data.Bits.$fBitsWord_$ccomplement_closure+1;
         const Data.Bits.$fBitsWord_$cshift_closure+2;
         const Data.Bits.$fBitsWord_$crotate_closure+2;
         const Data.Bits.$fBitsWord1_closure+1;
         const Data.Bits.$fBitsWord_$cbit_closure+1;
         const Data.Bits.$fBitsWord_$csetBit_closure+2;
         const Data.Bits.$fBitsWord_$cclearBit_closure+2;
         const Data.Bits.$fBitsWord_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsWord_$ctestBit_closure+2;
         const Data.Bits.$fBitsWord_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsWord_$cfiniteBitSize_closure+1;
         const Data.Bits.$fBitsWord_$cisSigned_closure+1;
         const Data.Bits.$fBitsWord_$cshiftL_closure+2;
         const Data.Bits.$fBitsWord_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsWord_$cshiftR_closure+2;
         const Data.Bits.$fBitsWord_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsWord_$crotateL_closure+2;
         const Data.Bits.$fBitsWord_$crotateR_closure+2;
         const Data.Bits.$fBitsWord_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.54236899 UTC

[section ""data" . Data.Bits.$fFiniteBitsWord_closure" {
     Data.Bits.$fFiniteBitsWord_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsWord_closure+1;
         const Data.Bits.$fBitsWord_$cfiniteBitSize_closure+1;
         const Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros_closure+1;
         const Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.544444323 UTC

[section ""data" . Data.Bits.$fBitsInt_$cbitSizeMaybe_closure" {
     Data.Bits.$fBitsInt_$cbitSizeMaybe_closure:
         const Data.Bits.$fBitsInt_$cbitSizeMaybe_info;
 },
 Data.Bits.$fBitsInt_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c1Iei,
                       label: Data.Bits.$fBitsInt_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iei: // global
           R1 = Data.Bits.$fBitsInt2_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.548320016 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotateL_closure" {
     Data.Bits.$fBitsInt_$crotateL_closure:
         const Data.Bits.$fBitsInt_$crotateL_info;
 },
 Data.Bits.$fBitsInt_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c1Ieu,
                       label: Data.Bits.$fBitsInt_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ieu: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInt_$crotate_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.552320328 UTC

[section ""data" . Data.Bits.$fBitsInt_$crotateR_closure" {
     Data.Bits.$fBitsInt_$crotateR_closure:
         const Data.Bits.$fBitsInt_$crotateR_info;
 },
 Data.Bits.$fBitsInt_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c1IeI,
                       label: Data.Bits.$fBitsInt_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IeI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1If9; else goto c1Ifa;
       c1If9: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$crotateR_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ifa: // global
           I64[Sp - 16] = block_c1IeF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Ifg; else goto c1IeG;
       u1Ifg: // global
           call _c1IeF(R1) args: 0, res: 0, upd: 0;
       c1IeG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IeF() //  [R1]
         { info_tbl: [(c1IeF,
                       label: block_c1IeF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IeF: // global
           I64[Sp] = block_c1IeL_info;
           _s1H7a::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H7a::I64;
           if (R1 & 7 != 0) goto u1Iff; else goto c1IeM;
       u1Iff: // global
           call _c1IeL(R1) args: 0, res: 0, upd: 0;
       c1IeM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IeL() //  [R1]
         { info_tbl: [(c1IeL,
                       label: block_c1IeL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IeL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ife; else goto c1Ifd;
       c1Ife: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Ifd: // global
           _s1H7d::I64 = -I64[R1 + 7] & 63;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           _s1H7a::I64 = I64[Sp + 8];
           I64[Hp] = (_s1H7a::I64 << _s1H7d::I64) | (_s1H7a::I64 >> 64 - _s1H7d::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.560950327 UTC

[section ""data" . Data.Bits.$fBitsInt_$cbit_closure" {
     Data.Bits.$fBitsInt_$cbit_closure:
         const Data.Bits.$fBitsInt_$cbit_info;
 },
 Data.Bits.$fBitsInt_$cbit_entry() //  [R2]
         { info_tbl: [(c1IfL,
                       label: Data.Bits.$fBitsInt_$cbit_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IfL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1IfM; else goto c1IfN;
       c1IfM: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cbit_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1IfN: // global
           I64[Sp - 8] = block_c1IfI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1Ig3; else goto c1IfJ;
       u1Ig3: // global
           call _c1IfI(R1) args: 0, res: 0, upd: 0;
       c1IfJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IfI() //  [R1]
         { info_tbl: [(c1IfI,
                       label: block_c1IfI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IfI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1IfS; else goto c1IfR;
       c1IfS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IfR: // global
           _s1H7l::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H7l::I64, 64)) goto c1Ig1; else goto c1Ig2;
       c1Ig1: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = 1 << _s1H7l::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Ig2: // global
           Hp = Hp - 16;
           R1 = Data.Bits.$fBitsBool2_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.568513447 UTC

[section ""data" . Data.Bits.$fBitsInt_$ctestBit_closure" {
     Data.Bits.$fBitsInt_$ctestBit_closure:
         const Data.Bits.$fBitsInt_$ctestBit_info;
 },
 Data.Bits.$fBitsInt_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c1Igp,
                       label: Data.Bits.$fBitsInt_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Igp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Igt; else goto c1Igu;
       c1Igt: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ctestBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Igu: // global
           I64[Sp - 16] = block_c1Igm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Ih0; else goto c1Ign;
       u1Ih0: // global
           call _c1Igm(R1) args: 0, res: 0, upd: 0;
       c1Ign: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Igm() //  [R1]
         { info_tbl: [(c1Igm,
                       label: block_c1Igm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Igm: // global
           I64[Sp] = block_c1Igs_info;
           _s1H7r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H7r::I64;
           if (R1 & 7 != 0) goto u1IgZ; else goto c1Igw;
       u1IgZ: // global
           call _c1Igs(R1) args: 0, res: 0, upd: 0;
       c1Igw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Igs() //  [R1]
         { info_tbl: [(c1Igs,
                       label: block_c1Igs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Igs: // global
           _s1H7t::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s1H7t::I64, 64)) goto c1IgY; else goto c1IgX;
       c1IgX: // global
           if (I64[Sp + 8] & (1 << _s1H7t::I64) == 0) goto c1IgY; else goto c1IgM;
       c1IgY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1IgM: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.578220704 UTC

[section ""data" . Data.Bits.$fBitsInt_$csetBit_closure" {
     Data.Bits.$fBitsInt_$csetBit_closure:
         const Data.Bits.$fBitsInt_$csetBit_info;
 },
 Data.Bits.$fBitsInt_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c1Ihu,
                       label: Data.Bits.$fBitsInt_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ihu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Ihy; else goto c1Ihz;
       c1Ihy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$csetBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ihz: // global
           I64[Sp - 16] = block_c1Ihr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1IhW; else goto c1Ihs;
       u1IhW: // global
           call _c1Ihr(R1) args: 0, res: 0, upd: 0;
       c1Ihs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ihr() //  [R1]
         { info_tbl: [(c1Ihr,
                       label: block_c1Ihr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ihr: // global
           I64[Sp - 8] = block_c1Ihx_info;
           _s1H7z::P64 = R1;
           _s1H7A::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1H7A::I64;
           P64[Sp + 8] = _s1H7z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IhV; else goto c1IhB;
       u1IhV: // global
           call _c1Ihx(R1) args: 0, res: 0, upd: 0;
       c1IhB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ihx() //  [R1]
         { info_tbl: [(c1Ihx,
                       label: block_c1Ihx_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ihx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1IhH; else goto c1IhG;
       c1IhH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IhG: // global
           _s1H7C::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H7C::I64, 64)) goto c1IhT; else goto c1IhU;
       c1IhT: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] | (1 << _s1H7C::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1IhU: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.587590906 UTC

[section ""data" . Data.Bits.$fBitsInt_$cclearBit_closure" {
     Data.Bits.$fBitsInt_$cclearBit_closure:
         const Data.Bits.$fBitsInt_$cclearBit_info;
 },
 Data.Bits.$fBitsInt_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c1Iiq,
                       label: Data.Bits.$fBitsInt_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iiq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Iiu; else goto c1Iiv;
       c1Iiu: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$cclearBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Iiv: // global
           I64[Sp - 16] = block_c1Iin_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1Ij0; else goto c1Iio;
       u1Ij0: // global
           call _c1Iin(R1) args: 0, res: 0, upd: 0;
       c1Iio: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Iin() //  [R1]
         { info_tbl: [(c1Iin,
                       label: block_c1Iin_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iin: // global
           I64[Sp] = block_c1Iit_info;
           _s1H7J::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H7J::I64;
           if (R1 & 7 != 0) goto u1IiZ; else goto c1Iix;
       u1IiZ: // global
           call _c1Iit(R1) args: 0, res: 0, upd: 0;
       c1Iix: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Iit() //  [R1]
         { info_tbl: [(c1Iit,
                       label: block_c1Iit_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iit: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1IiD; else goto c1IiC;
       c1IiD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IiC: // global
           _s1H7J::I64 = I64[Sp + 8];
           _s1H7L::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H7L::I64, 64)) goto c1IiS; else goto c1IiY;
       c1IiS: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H7J::I64 & ~(1 << _s1H7L::I64);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1IiY: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H7J::I64 & (-1);
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.596872541 UTC

[section ""data" . Data.Bits.$fBitsInt_$ccomplementBit_closure" {
     Data.Bits.$fBitsInt_$ccomplementBit_closure:
         const Data.Bits.$fBitsInt_$ccomplementBit_info;
 },
 Data.Bits.$fBitsInt_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c1Ijx,
                       label: Data.Bits.$fBitsInt_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ijx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1IjB; else goto c1IjC;
       c1IjB: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.$fBitsInt_$ccomplementBit_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c1IjC: // global
           I64[Sp - 16] = block_c1Iju_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u1IjZ; else goto c1Ijv;
       u1IjZ: // global
           call _c1Iju(R1) args: 0, res: 0, upd: 0;
       c1Ijv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Iju() //  [R1]
         { info_tbl: [(c1Iju,
                       label: block_c1Iju_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iju: // global
           I64[Sp - 8] = block_c1IjA_info;
           _s1H7T::P64 = R1;
           _s1H7U::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _s1H7U::I64;
           P64[Sp + 8] = _s1H7T::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IjY; else goto c1IjE;
       u1IjY: // global
           call _c1IjA(R1) args: 0, res: 0, upd: 0;
       c1IjE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IjA() //  [R1]
         { info_tbl: [(c1IjA,
                       label: block_c1IjA_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IjA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1IjK; else goto c1IjJ;
       c1IjK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IjJ: // global
           _s1H7W::I64 = I64[R1 + 7];
           if (%MO_S_Lt_W64(_s1H7W::I64, 64)) goto c1IjW; else goto c1IjX;
       c1IjW: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 8] ^ (1 << _s1H7W::I64);
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1IjX: // global
           Hp = Hp - 16;
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.605624134 UTC

[section ""data" . Data.Bits.$fBitsInt_closure" {
     Data.Bits.$fBitsInt_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Classes.$fEqInt_closure;
         const Data.Bits.$fBitsInt_$c.&._closure+2;
         const Data.Bits.$fBitsInt_$c.|._closure+2;
         const Data.Bits.$fBitsInt_$cxor_closure+2;
         const Data.Bits.$fBitsInt_$ccomplement_closure+1;
         const Data.Bits.$fBitsInt_$cshift_closure+2;
         const Data.Bits.$fBitsInt_$crotate_closure+2;
         const Data.Bits.$fBitsBool2_closure+1;
         const Data.Bits.$fBitsInt_$cbit_closure+1;
         const Data.Bits.$fBitsInt_$csetBit_closure+2;
         const Data.Bits.$fBitsInt_$cclearBit_closure+2;
         const Data.Bits.$fBitsInt_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsInt_$ctestBit_closure+2;
         const Data.Bits.$fBitsInt_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsInt_$cfiniteBitSize_closure+1;
         const Data.Bits.$fBitsInt_$cisSigned_closure+1;
         const Data.Bits.$fBitsInt_$cshiftL_closure+2;
         const Data.Bits.$fBitsInt_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsInt_$cshiftR_closure+2;
         const Data.Bits.$fBitsInt_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsInt_$crotateL_closure+2;
         const Data.Bits.$fBitsInt_$crotateR_closure+2;
         const Data.Bits.$fBitsInt_$cpopCount_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.608079503 UTC

[section ""data" . Data.Bits.$fFiniteBitsInt_closure" {
     Data.Bits.$fFiniteBitsInt_closure:
         const Data.Bits.C:FiniteBits_con_info;
         const Data.Bits.$fBitsInt_closure+1;
         const Data.Bits.$fBitsInt_$cfiniteBitSize_closure+1;
         const Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros_closure+1;
         const Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.611951777 UTC

[section ""data" . Data.Bits.$wpopCountDefault_closure" {
     Data.Bits.$wpopCountDefault_closure:
         const Data.Bits.$wpopCountDefault_info;
         const 0;
 },
 lvl1_s1H83_entry() //  [R1]
         { info_tbl: [(c1IkM,
                       label: lvl1_s1H83_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IkM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1IkN; else goto c1IkO;
       c1IkN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1IkO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl2_s1H84_entry() //  [R1]
         { info_tbl: [(c1IkR,
                       label: lvl2_s1H84_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IkR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1IkS; else goto c1IkT;
       c1IkS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1IkT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1H8b_entry() //  [R1]
         { info_tbl: [(c1Il1,
                       label: sat_s1H8b_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Il1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c1Il2; else goto c1Il3;
       c1Il2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Il3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1H8c_entry() //  [R1]
         { info_tbl: [(c1Il4,
                       label: sat_s1H8c_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Il4: // global
           _s1H8c::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1Il5; else goto c1Il6;
       c1Il6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1Il8; else goto c1Il7;
       c1Il8: // global
           HpAlloc = 40;
           goto c1Il5;
       c1Il5: // global
           R1 = _s1H8c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Il7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1H8c::P64;
           _s1H80::P64 = P64[_s1H8c::P64 + 16];
           _s1H81::P64 = P64[_s1H8c::P64 + 24];
           _s1H83::P64 = P64[_s1H8c::P64 + 32];
           _s1H88::P64 = P64[_s1H8c::P64 + 40];
           I64[Hp - 32] = sat_s1H8b_info;
           P64[Hp - 16] = _s1H81::P64;
           P64[Hp - 8] = _s1H83::P64;
           P64[Hp] = _s1H88::P64;
           R2 = _s1H80::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s1H88::P64;
           P64[Sp - 24] = Hp - 32;
           Sp = Sp - 40;
           call Data.Bits..&._entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Bits.$wpopCountDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1Il9,
                       label: Data.Bits.$wpopCountDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Il9: // global
           _s1H82::P64 = R4;
           _s1H81::P64 = R3;
           _s1H80::P64 = R2;
           if ((Sp + -88) < SpLim) (likely: False) goto c1Ila; else goto c1Ilb;
       c1Ilb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1Ild; else goto c1Ilc;
       c1Ild: // global
           HpAlloc = 48;
           goto c1Ila;
       c1Ila: // global
           R4 = _s1H82::P64;
           R3 = _s1H81::P64;
           R2 = _s1H80::P64;
           R1 = Data.Bits.$wpopCountDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1Ilc: // global
           I64[Hp - 40] = lvl1_s1H83_info;
           P64[Hp - 24] = _s1H81::P64;
           I64[Hp - 16] = lvl2_s1H84_info;
           P64[Hp] = _s1H81::P64;
           I64[Sp - 48] = block_c1Ikw_info;
           R2 = _s1H80::P64;
           P64[Sp - 40] = Hp - 40;
           P64[Sp - 32] = Hp - 16;
           P64[Sp - 24] = _s1H80::P64;
           P64[Sp - 16] = _s1H81::P64;
           P64[Sp - 8] = _s1H82::P64;
           Sp = Sp - 48;
           call Data.Bits.$p1Bits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ikw() //  [R1]
         { info_tbl: [(c1Ikw,
                       label: block_c1Ikw_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ikw: // global
           P64[Sp - 8] = P64[Sp + 40];
           I64[Sp] = 0;
           P64[Sp + 40] = R1;
           Sp = Sp - 8;
           call _c1IkC() args: 0, res: 0, upd: 0;
     }
 },
 _c1IkC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IkC: // global
           I64[Sp - 8] = block_c1IkF_info;
           R2 = P64[Sp + 48];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp];
           P64[Sp - 16] = P64[Sp + 24];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1IkF() //  [R1]
         { info_tbl: [(c1IkF,
                       label: block_c1IkF_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IkF: // global
           _s1H87::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c1Ilh; else goto c1Ilo;
       c1Ilh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c1Ilk; else goto c1Ilj;
       c1Ilk: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Ilj: // global
           I64[Hp - 40] = sat_s1H8c_info;
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = P64[Sp + 48];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 16] = _s1H87::I64 + 1;
           P64[Sp + 8] = Hp - 40;
           Sp = Sp + 8;
           call _c1IkC() args: 0, res: 0, upd: 0;
       c1Ilo: // global
           R1 = _s1H87::I64;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.63208826 UTC

[section ""data" . Data.Bits.popCountDefault_closure" {
     Data.Bits.popCountDefault_closure:
         const Data.Bits.popCountDefault_info;
         const 0;
 },
 Data.Bits.popCountDefault_entry() //  [R2, R3, R4]
         { info_tbl: [(c1ImC,
                       label: Data.Bits.popCountDefault_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ImC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1ImG; else goto c1ImH;
       c1ImG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.popCountDefault_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1ImH: // global
           I64[Sp - 8] = block_c1ImA_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.Bits.$wpopCountDefault_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1ImA() //  [R1]
         { info_tbl: [(c1ImA,
                       label: block_c1ImA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ImA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1ImK; else goto c1ImJ;
       c1ImK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1ImJ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.638667625 UTC

[section ""data" . Data.Bits.$fBitsInteger_closure" {
     Data.Bits.$fBitsInteger_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Integer.Type.$fEqInteger_closure;
         const GHC.Integer.Type.andInteger_closure+2;
         const GHC.Integer.Type.orInteger_closure+2;
         const GHC.Integer.Type.xorInteger_closure+2;
         const GHC.Integer.Type.complementInteger_closure+1;
         const Data.Bits.$fBitsInteger_$cshift_closure+2;
         const Data.Bits.$fBitsInteger_$cshift_closure+2;
         const Data.Bits.$fBitsInteger_$czeroBits_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure+1;
         const Data.Bits.$fBitsInteger_$csetBit_closure+2;
         const Data.Bits.$fBitsInteger_$cclearBit_closure+2;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure+2;
         const Data.Bits.$fBitsInteger_$ctestBit_closure+2;
         const Data.Bits.$fBitsInteger_$cbitSizeMaybe_closure+1;
         const Data.Bits.$fBitsInteger_$cbitSize_closure+1;
         const Data.Bits.$fBitsInteger_$cisSigned_closure+1;
         const Data.Bits.$fBitsInteger_$cshiftL_closure+2;
         const Data.Bits.$fBitsInteger_$cunsafeShiftL_closure+2;
         const Data.Bits.$fBitsInteger_$cshiftR_closure+2;
         const Data.Bits.$fBitsInteger_$cunsafeShiftR_closure+2;
         const Data.Bits.$fBitsInteger_$crotateL_closure+2;
         const Data.Bits.$fBitsInteger_$crotateR_closure+2;
         const Data.Bits.$fBitsInteger_$cpopCount_closure+1;
         const 0;
 },
 section ""data" . Data.Bits.$fBitsInteger_$cpopCount_closure" {
     Data.Bits.$fBitsInteger_$cpopCount_closure:
         const Data.Bits.$fBitsInteger_$cpopCount_info;
         const 0;
 },
 Data.Bits.$fBitsInteger_$cpopCount_entry() //  [R2]
         { info_tbl: [(c1In2,
                       label: Data.Bits.$fBitsInteger_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1In2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c1In6; else goto c1In7;
       c1In6: // global
           R2 = R2;
           R1 = Data.Bits.$fBitsInteger_$cpopCount_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c1In7: // global
           I64[Sp - 8] = block_c1In0_info;
           R4 = R2;
           R3 = GHC.Num.$fNumInteger_closure;
           R2 = Data.Bits.$fBitsInteger_closure+1;
           Sp = Sp - 8;
           call Data.Bits.$wpopCountDefault_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c1In0() //  [R1]
         { info_tbl: [(c1In0,
                       label: block_c1In0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1In0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ina; else goto c1In9;
       c1Ina: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c1In9: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.672696439 UTC

[section ""data" . Data.Bits.toIntegralSized_closure" {
     Data.Bits.toIntegralSized_closure:
         const Data.Bits.toIntegralSized_info;
         const 0;
 },
 sat_s1H8s_entry() //  [R1]
         { info_tbl: [(c1InD,
                       label: sat_s1H8s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1InD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1InE; else goto c1InF;
       c1InE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1InF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 y_s1H8p_entry() //  [R1]
         { info_tbl: [(c1InI,
                       label: y_s1H8p_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1InI: // global
           _s1H8p::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1InM; else goto c1InN;
       c1InN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1InP; else goto c1InO;
       c1InP: // global
           HpAlloc = 32;
           goto c1InM;
       c1InM: // global
           R1 = _s1H8p::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1InO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1H8p::P64;
           _s1H8j::P64 = P64[_s1H8p::P64 + 16];
           _s1H8k::P64 = P64[_s1H8p::P64 + 24];
           _s1H8n::P64 = P64[_s1H8p::P64 + 32];
           I64[Hp - 24] = sat_s1H8s_info;
           P64[Hp - 8] = _s1H8j::P64;
           P64[Hp] = _s1H8n::P64;
           I64[Sp - 32] = block_c1InG_info;
           R2 = _s1H8k::P64;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1InG() //  [R1]
         { info_tbl: [(c1InG,
                       label: block_c1InG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1InG: // global
           I64[Sp] = block_c1InL_info;
           R2 = R1;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c1InL() //  [R1]
         { info_tbl: [(c1InL,
                       label: block_c1InL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1InL: // global
           R2 = R1;
           I64[Sp] = stg_ap_p_info;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 xSigned_s1H8v_entry() //  [R1]
         { info_tbl: [(c1Io7,
                       label: xSigned_s1H8v_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Io7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Io8; else goto c1Io9;
       c1Io8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Io9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.isSigned_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dReal_s1H8w_entry() //  [R1]
         { info_tbl: [(c1Ioe,
                       label: $dReal_s1H8w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ioe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Iof; else goto c1Iog;
       c1Iof: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Iog: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Integral_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dNum_s1H8x_entry() //  [R1]
         { info_tbl: [(c1Iol,
                       label: $dNum_s1H8x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iol: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Iom; else goto c1Ion;
       c1Iom: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Ion: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $dOrd_s1H8y_entry() //  [R1]
         { info_tbl: [(c1Ios,
                       label: $dOrd_s1H8y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ios: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c1Iot; else goto c1Iou;
       c1Iot: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Iou: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1H8N_entry() //  [R1]
         { info_tbl: [(c1Ipi,
                       label: sat_s1H8N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ipi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Ipj; else goto c1Ipk;
       c1Ipj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Ipk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1H8M_entry() //  [R1]
         { info_tbl: [(c1Ipp,
                       label: sat_s1H8M_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ipp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1Ipq; else goto c1Ipr;
       c1Ipq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Ipr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1H8O_entry() //  [R1]
         { info_tbl: [(c1Ips,
                       label: sat_s1H8O_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ips: // global
           _s1H8O::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1Ipt; else goto c1Ipu;
       c1Ipu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1Ipw; else goto c1Ipv;
       c1Ipw: // global
           HpAlloc = 56;
           goto c1Ipt;
       c1Ipt: // global
           R1 = _s1H8O::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Ipv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1H8O::P64;
           _s1H8l::P64 = P64[_s1H8O::P64 + 16];
           _s1H8x::P64 = P64[_s1H8O::P64 + 24];
           _s1H8K::P64 = P64[_s1H8O::P64 + 32];
           I64[Hp - 48] = sat_s1H8N_info;
           P64[Hp - 32] = _s1H8x::P64;
           I64[Hp - 24] = sat_s1H8M_info;
           P64[Hp - 8] = _s1H8l::P64;
           P64[Hp] = _s1H8K::P64;
           R2 = _s1H8x::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1H8V_entry() //  [R1]
         { info_tbl: [(c1IpH,
                       label: sat_s1H8V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IpH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1IpI; else goto c1IpJ;
       c1IpI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1IpJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger3_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1H8T_entry() //  [R1]
         { info_tbl: [(c1IpV,
                       label: sat_s1H8T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IpV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Iq2; else goto c1Iq3;
       c1Iq2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Iq3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1IpS_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1Iq7; else goto c1IpT;
       u1Iq7: // global
           call _c1IpS(R1) args: 0, res: 0, upd: 0;
       c1IpT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1IpS() //  [R1]
         { info_tbl: [(c1IpS,
                       label: block_c1IpS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IpS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Iq6; else goto c1Iq5;
       c1Iq6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1Iq5: // global
           _s1H8S::I64 = I64[R1 + 7] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1H8S::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1H8U_entry() //  [R1]
         { info_tbl: [(c1Iq8,
                       label: sat_s1H8U_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iq8: // global
           _s1H8U::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1Iq9; else goto c1Iqa;
       c1Iqa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Iqc; else goto c1Iqb;
       c1Iqc: // global
           HpAlloc = 24;
           goto c1Iq9;
       c1Iq9: // global
           R1 = _s1H8U::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Iqb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1H8U::P64;
           _s1H8l::P64 = P64[_s1H8U::P64 + 16];
           _s1H8K::P64 = P64[_s1H8U::P64 + 24];
           I64[Hp - 16] = sat_s1H8T_info;
           P64[Hp] = _s1H8K::P64;
           R2 = _s1H8l::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1H8W_entry() //  [R1]
         { info_tbl: [(c1Iqd,
                       label: sat_s1H8W_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iqd: // global
           _s1H8W::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c1Iqe; else goto c1Iqf;
       c1Iqf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c1Iqh; else goto c1Iqg;
       c1Iqh: // global
           HpAlloc = 56;
           goto c1Iqe;
       c1Iqe: // global
           R1 = _s1H8W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Iqg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1H8W::P64;
           _s1H8l::P64 = P64[_s1H8W::P64 + 16];
           _s1H8x::P64 = P64[_s1H8W::P64 + 24];
           _s1H8K::P64 = P64[_s1H8W::P64 + 32];
           I64[Hp - 48] = sat_s1H8V_info;
           P64[Hp - 32] = _s1H8x::P64;
           I64[Hp - 24] = sat_s1H8U_info;
           P64[Hp - 8] = _s1H8l::P64;
           P64[Hp] = _s1H8K::P64;
           R2 = _s1H8x::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 24;
           P64[Sp - 24] = Hp - 48;
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s1Hac_entry() //  [R1]
         { info_tbl: [(c1Ire,
                       label: sat_s1Hac_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ire: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c1Irl; else goto c1Irm;
       c1Irl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Irm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c1Irb_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1Irq; else goto c1Irc;
       u1Irq: // global
           call _c1Irb(R1) args: 0, res: 0, upd: 0;
       c1Irc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c1Irb() //  [R1]
         { info_tbl: [(c1Irb,
                       label: block_c1Irb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Irb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Irp; else goto c1Iro;
       c1Irp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c1Iro: // global
           _s1Hab::I64 = I64[R1 + 7] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s1Hab::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s1Had_entry() //  [R1]
         { info_tbl: [(c1Irr,
                       label: sat_s1Had_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Irr: // global
           _s1Had::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1Irs; else goto c1Irt;
       c1Irt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1Irv; else goto c1Iru;
       c1Irv: // global
           HpAlloc = 24;
           goto c1Irs;
       c1Irs: // global
           R1 = _s1Had::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Iru: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1Had::P64;
           _s1H8l::P64 = P64[_s1Had::P64 + 16];
           _s1Ha8::P64 = P64[_s1Had::P64 + 24];
           I64[Hp - 16] = sat_s1Hac_info;
           P64[Hp] = _s1Ha8::P64;
           R2 = _s1H8l::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 32;
           call Data.Bits.bit_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1Hae_entry() //  [R1]
         { info_tbl: [(c1Irw,
                       label: sat_s1Hae_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Irw: // global
           _s1Hae::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c1Irx; else goto c1Iry;
       c1Iry: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c1IrA; else goto c1Irz;
       c1IrA: // global
           HpAlloc = 32;
           goto c1Irx;
       c1Irx: // global
           R1 = _s1Hae::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1Irz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s1Hae::P64;
           _s1H8l::P64 = P64[_s1Hae::P64 + 16];
           _s1H8x::P64 = P64[_s1Hae::P64 + 24];
           _s1Ha8::P64 = P64[_s1Hae::P64 + 32];
           I64[Hp - 24] = sat_s1Had_info;
           P64[Hp - 8] = _s1H8l::P64;
           P64[Hp] = _s1Ha8::P64;
           R2 = _s1H8x::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.negate_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s1Hai_entry() //  [R1]
         { info_tbl: [(c1IrQ,
                       label: sat_s1Hai_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IrQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c1IrR; else goto c1IrS;
       c1IrR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c1IrS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Bits.$fBitsInteger_$czeroBits_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Bits.toIntegralSized_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1IrT,
                       label: Data.Bits.toIntegralSized_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IrT: // global
           if ((Sp + -104) < SpLim) (likely: False) goto c1IrU; else goto c1IrV;
       c1IrU: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.toIntegralSized_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1IrV: // global
           I64[Sp - 48] = block_c1Inr_info;
           _s1H8j::P64 = R2;
           R2 = R4;
           I64[Sp - 64] = stg_ap_p_info;
           P64[Sp - 56] = R6;
           P64[Sp - 40] = _s1H8j::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 64;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1Inr() //  [R1]
         { info_tbl: [(c1Inr,
                       label: block_c1Inr_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Inr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1IrY; else goto c1IrX;
       c1IrY: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IrX: // global
           I64[Hp - 32] = y_s1H8p_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 40];
           I64[Sp - 8] = block_c1InV_info;
           R2 = P64[Sp + 32];
           I64[Sp - 24] = stg_ap_p_info;
           _c1Inv::P64 = Hp - 32;
           P64[Sp - 16] = _c1Inv::P64;
           P64[Sp] = R1;
           P64[Sp + 16] = _c1Inv::P64;
           Sp = Sp - 24;
           call Data.Bits.isSigned_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1InV() //  [R1]
         { info_tbl: [(c1InV,
                       label: block_c1InV_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1InV: // global
           I64[Sp] = block_c1InZ_info;
           R2 = P64[Sp + 40];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp + 40] = R1;
           Sp = Sp - 16;
           call Data.Bits.bitSizeMaybe_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c1InZ() //  [R1]
         { info_tbl: [(c1InZ,
                       label: block_c1InZ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1InZ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c1Is5; else goto c1Is4;
       c1Is5: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Is4: // global
           I64[Hp - 96] = xSigned_s1H8v_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 48];
           I64[Hp - 64] = $dReal_s1H8w_info;
           P64[Hp - 48] = P64[Sp + 16];
           I64[Hp - 40] = $dNum_s1H8x_info;
           _c1Ioa::P64 = Hp - 64;
           P64[Hp - 24] = _c1Ioa::P64;
           I64[Hp - 16] = $dOrd_s1H8y_info;
           P64[Hp] = _c1Ioa::P64;
           I64[Sp - 24] = block_c1Is2_info;
           _s1H8u::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _s1H8u::P64;
           P64[Sp] = Hp - 40;
           P64[Sp + 16] = Hp - 96;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u1IHp; else goto c1IEy;
       u1IHp: // global
           call _c1Is2(R1) args: 0, res: 0, upd: 0;
       c1IEy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Is2() //  [R1]
         { info_tbl: [(c1Is2,
                       label: block_c1Is2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Is2: // global
           _s1H8u::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1IEF; else goto c1IEV;
       c1IEF: // global
           I64[Sp] = block_c1IEC_info;
           R1 = _s1H8u::P64;
           if (R1 & 7 != 0) goto u1IHz; else goto c1IEG;
       u1IHz: // global
           call _c1IEC(R1) args: 0, res: 0, upd: 0;
       c1IEG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1IEV: // global
           I64[Sp - 8] = block_c1IET_info;
           _s1HaY::P64 = P64[R1 + 6];
           R1 = _s1H8u::P64;
           P64[Sp] = _s1HaY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IHA; else goto c1IEW;
       u1IHA: // global
           call _c1IET(R1) args: 0, res: 0, upd: 0;
       c1IEW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IEC() //  [R1]
         { info_tbl: [(c1IEC,
                       label: block_c1IEC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IEC: // global
           if (R1 & 7 == 1) goto u1IGk; else goto u1IGl;
       u1IGk: // global
           Sp = Sp + 8;
           call _s1HaR() args: 0, res: 0, upd: 0;
       u1IGl: // global
           Sp = Sp + 8;
           call _s1H9W() args: 0, res: 0, upd: 0;
     }
 },
 _c1IET() //  [R1]
         { info_tbl: [(c1IET,
                       label: block_c1IET_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IET: // global
           if (R1 & 7 == 1) goto u1IGh; else goto c1IFc;
       u1IGh: // global
           Sp = Sp + 16;
           call _s1H9W() args: 0, res: 0, upd: 0;
       c1IFc: // global
           I64[Sp] = block_c1IF5_info;
           _s1Hb0::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1Hb0::P64;
           if (R1 & 7 != 0) goto u1IJf; else goto c1IF6;
       u1IJf: // global
           call _c1IF5(R1) args: 0, res: 0, upd: 0;
       c1IF6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IF5() //  [R1]
         { info_tbl: [(c1IF5,
                       label: block_c1IF5_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IF5: // global
           I64[Sp] = block_c1IFa_info;
           _s1Hb2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1Hb2::I64;
           if (R1 & 7 != 0) goto u1IJh; else goto c1IFe;
       u1IJh: // global
           call _c1IFa(R1) args: 0, res: 0, upd: 0;
       c1IFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IFa() //  [R1]
         { info_tbl: [(c1IFa,
                       label: block_c1IFa_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IFa: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u1IGi; else goto u1IGj;
       u1IGi: // global
           Sp = Sp + 16;
           call _s1HaR() args: 0, res: 0, upd: 0;
       u1IGj: // global
           Sp = Sp + 16;
           call _s1H9W() args: 0, res: 0, upd: 0;
     }
 },
 _s1HaR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1HaR: // global
           I64[Sp - 8] = block_c1IDX_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJA; else goto c1IDZ;
       u1IJA: // global
           call _c1IDX(R1) args: 0, res: 0, upd: 0;
       c1IDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IDX() //  [R1]
         { info_tbl: [(c1IDX,
                       label: block_c1IDX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IDX: // global
           _s1H8t::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1IE6; else goto c1IEm;
       c1IE6: // global
           I64[Sp] = block_c1IE3_info;
           R1 = _s1H8t::P64;
           if (R1 & 7 != 0) goto u1IJ7; else goto c1IE7;
       u1IJ7: // global
           call _c1IE3(R1) args: 0, res: 0, upd: 0;
       c1IE7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1IEm: // global
           I64[Sp] = block_c1IEk_info;
           R1 = _s1H8t::P64;
           if (R1 & 7 != 0) goto u1IJ8; else goto c1IEn;
       u1IJ8: // global
           call _c1IEk(R1) args: 0, res: 0, upd: 0;
       c1IEn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IE3() //  [R1]
         { info_tbl: [(c1IE3,
                       label: block_c1IE3_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IE3: // global
           if (R1 & 7 == 1) goto u1IGo; else goto u1IGp;
       u1IGo: // global
           Sp = Sp + 8;
           call _s1H8z() args: 0, res: 0, upd: 0;
       u1IGp: // global
           Sp = Sp + 8;
           call _s1H9W() args: 0, res: 0, upd: 0;
     }
 },
 _c1IEk() //  [R1]
         { info_tbl: [(c1IEk,
                       label: block_c1IEk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IEk: // global
           if (R1 & 7 == 1) goto u1IGm; else goto u1IGn;
       u1IGm: // global
           Sp = Sp + 8;
           call _s1H9W() args: 0, res: 0, upd: 0;
       u1IGn: // global
           Sp = Sp + 8;
           call _s1H8z() args: 0, res: 0, upd: 0;
     }
 },
 _s1H9W() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H9W: // global
           I64[Sp - 8] = block_c1Izs_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJt; else goto c1IDx;
       u1IJt: // global
           call _c1Izs(R1) args: 0, res: 0, upd: 0;
       c1IDx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Izs() //  [R1]
         { info_tbl: [(c1Izs,
                       label: block_c1Izs_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Izs: // global
           if (R1 & 7 == 1) goto u1IGq; else goto c1IDI;
       u1IGq: // global
           Sp = Sp + 8;
           call _s1H9Y() args: 0, res: 0, upd: 0;
       c1IDI: // global
           I64[Sp] = block_c1IDG_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1IIv; else goto c1IDJ;
       u1IIv: // global
           call _c1IDG(R1) args: 0, res: 0, upd: 0;
       c1IDJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IDG() //  [R1]
         { info_tbl: [(c1IDG,
                       label: block_c1IDG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IDG: // global
           if (R1 & 7 == 1) goto u1IGr; else goto u1IGs;
       u1IGr: // global
           Sp = Sp + 8;
           call _s1H8z() args: 0, res: 0, upd: 0;
       u1IGs: // global
           Sp = Sp + 8;
           call _s1H9Y() args: 0, res: 0, upd: 0;
     }
 },
 _s1H9Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H9Y: // global
           I64[Sp - 8] = block_c1Izu_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJu; else goto c1ICY;
       u1IJu: // global
           call _c1Izu(R1) args: 0, res: 0, upd: 0;
       c1ICY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Izu() //  [R1]
         { info_tbl: [(c1Izu,
                       label: block_c1Izu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Izu: // global
           if (R1 & 7 == 1) goto c1ID5; else goto u1IGt;
       c1ID5: // global
           I64[Sp] = block_c1ID2_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1IIx; else goto c1ID6;
       u1IIx: // global
           call _c1ID2(R1) args: 0, res: 0, upd: 0;
       c1ID6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1IGt: // global
           Sp = Sp + 8;
           call _s1Ha0() args: 0, res: 0, upd: 0;
     }
 },
 _c1ID2() //  [R1]
         { info_tbl: [(c1ID2,
                       label: block_c1ID2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ID2: // global
           if (R1 & 7 == 1) goto c1IDd; else goto u1IGu;
       c1IDd: // global
           I64[Sp] = block_c1IDa_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1IJ1; else goto c1IDe;
       u1IJ1: // global
           call _c1IDa(R1) args: 0, res: 0, upd: 0;
       c1IDe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1IGu: // global
           Sp = Sp + 8;
           call _s1Ha0() args: 0, res: 0, upd: 0;
     }
 },
 _c1IDa() //  [R1]
         { info_tbl: [(c1IDa,
                       label: block_c1IDa_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IDa: // global
           if (R1 & 7 == 1) goto u1IGv; else goto u1IGw;
       u1IGv: // global
           Sp = Sp + 8;
           call _s1H8z() args: 0, res: 0, upd: 0;
       u1IGw: // global
           Sp = Sp + 8;
           call _s1Ha0() args: 0, res: 0, upd: 0;
     }
 },
 _s1Ha0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1Ha0: // global
           I64[Sp - 8] = block_c1IzA_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJv; else goto c1ICp;
       u1IJv: // global
           call _c1IzA(R1) args: 0, res: 0, upd: 0;
       c1ICp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IzA() //  [R1]
         { info_tbl: [(c1IzA,
                       label: block_c1IzA_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IzA: // global
           _s1H8t::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1ICw; else goto c1ICM;
       c1ICw: // global
           I64[Sp] = block_c1ICt_info;
           R1 = _s1H8t::P64;
           if (R1 & 7 != 0) goto u1IIz; else goto c1ICx;
       u1IIz: // global
           call _c1ICt(R1) args: 0, res: 0, upd: 0;
       c1ICx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1ICM: // global
           I64[Sp] = block_c1ICK_info;
           R1 = _s1H8t::P64;
           if (R1 & 7 != 0) goto u1IIA; else goto c1ICN;
       u1IIA: // global
           call _c1ICK(R1) args: 0, res: 0, upd: 0;
       c1ICN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ICt() //  [R1]
         { info_tbl: [(c1ICt,
                       label: block_c1ICt_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ICt: // global
           if (R1 & 7 == 1) goto u1IGz; else goto u1IGA;
       u1IGz: // global
           Sp = Sp + 8;
           call _s1Hax() args: 0, res: 0, upd: 0;
       u1IGA: // global
           Sp = Sp + 8;
           call _s1Hak() args: 0, res: 0, upd: 0;
     }
 },
 _c1ICK() //  [R1]
         { info_tbl: [(c1ICK,
                       label: block_c1ICK_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ICK: // global
           if (R1 & 7 == 1) goto u1IGx; else goto u1IGy;
       u1IGx: // global
           Sp = Sp + 8;
           call _s1Hak() args: 0, res: 0, upd: 0;
       u1IGy: // global
           Sp = Sp + 8;
           call _s1Hax() args: 0, res: 0, upd: 0;
     }
 },
 _s1Hax() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1Hax: // global
           I64[Sp - 8] = block_c1IBJ_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJz; else goto c1IBL;
       u1IJz: // global
           call _c1IBJ(R1) args: 0, res: 0, upd: 0;
       c1IBL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IBJ() //  [R1]
         { info_tbl: [(c1IBJ,
                       label: block_c1IBJ_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IBJ: // global
           if (R1 & 7 == 1) goto u1IGB; else goto c1IBW;
       u1IGB: // global
           Sp = Sp + 8;
           call _s1Hak() args: 0, res: 0, upd: 0;
       c1IBW: // global
           I64[Sp - 8] = block_c1IBU_info;
           _s1Haz::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1Haz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IIQ; else goto c1IBX;
       u1IIQ: // global
           call _c1IBU(R1) args: 0, res: 0, upd: 0;
       c1IBX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IBU() //  [R1]
         { info_tbl: [(c1IBU,
                       label: block_c1IBU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IBU: // global
           if (R1 & 7 == 1) goto u1IGC; else goto c1ICd;
       u1IGC: // global
           Sp = Sp + 16;
           call _s1Hak() args: 0, res: 0, upd: 0;
       c1ICd: // global
           I64[Sp] = block_c1IC6_info;
           _s1HaB::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1HaB::P64;
           if (R1 & 7 != 0) goto u1IIS; else goto c1IC7;
       u1IIS: // global
           call _c1IC6(R1) args: 0, res: 0, upd: 0;
       c1IC7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _s1Hak() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1Hak: // global
           I64[Sp - 8] = block_c1IAC_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJy; else goto c1IAE;
       u1IJy: // global
           call _c1IAC(R1) args: 0, res: 0, upd: 0;
       c1IAE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IAC() //  [R1]
         { info_tbl: [(c1IAC,
                       label: block_c1IAC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IAC: // global
           if (R1 & 7 == 1) goto c1IAL; else goto u1IGF;
       c1IAL: // global
           I64[Sp] = block_c1IAI_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1IIF; else goto c1IAM;
       u1IIF: // global
           call _c1IAI(R1) args: 0, res: 0, upd: 0;
       c1IAM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1IGF: // global
           Sp = Sp + 8;
           call _s1Ha2() args: 0, res: 0, upd: 0;
     }
 },
 _c1IAI() //  [R1]
         { info_tbl: [(c1IAI,
                       label: block_c1IAI_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IAI: // global
           if (R1 & 7 == 1) goto u1IGG; else goto c1IAX;
       u1IGG: // global
           Sp = Sp + 8;
           call _s1Ha2() args: 0, res: 0, upd: 0;
       c1IAX: // global
           I64[Sp] = block_c1IAV_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1IIH; else goto c1IAY;
       u1IIH: // global
           call _c1IAV(R1) args: 0, res: 0, upd: 0;
       c1IAY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IAV() //  [R1]
         { info_tbl: [(c1IAV,
                       label: block_c1IAV_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IAV: // global
           if (R1 & 7 == 1) goto u1IGH; else goto c1IB9;
       u1IGH: // global
           Sp = Sp + 8;
           call _s1Ha2() args: 0, res: 0, upd: 0;
       c1IB9: // global
           I64[Sp - 8] = block_c1IB7_info;
           _s1Hap::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1Hap::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IIJ; else goto c1IBa;
       u1IIJ: // global
           call _c1IB7(R1) args: 0, res: 0, upd: 0;
       c1IBa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IB7() //  [R1]
         { info_tbl: [(c1IB7,
                       label: block_c1IB7_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IB7: // global
           if (R1 & 7 == 1) goto u1IGI; else goto c1IBq;
       u1IGI: // global
           Sp = Sp + 16;
           call _s1Ha2() args: 0, res: 0, upd: 0;
       c1IBq: // global
           I64[Sp] = block_c1IBj_info;
           _s1Har::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1Har::P64;
           if (R1 & 7 != 0) goto u1IIL; else goto c1IBk;
       u1IIL: // global
           call _c1IBj(R1) args: 0, res: 0, upd: 0;
       c1IBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IBj() //  [R1]
         { info_tbl: [(c1IBj,
                       label: block_c1IBj_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IBj: // global
           I64[Sp] = block_c1IBo_info;
           _s1Hat::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1Hat::I64;
           if (R1 & 7 != 0) goto u1IIN; else goto c1IBs;
       u1IIN: // global
           call _c1IBo(R1) args: 0, res: 0, upd: 0;
       c1IBs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IBo() //  [R1]
         { info_tbl: [(c1IBo,
                       label: block_c1IBo_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IBo: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1IGK; else goto u1IGJ;
       u1IGK: // global
           Sp = Sp + 16;
           call _s1Ha2() args: 0, res: 0, upd: 0;
       u1IGJ: // global
           Sp = Sp + 16;
           call _s1H8z() args: 0, res: 0, upd: 0;
     }
 },
 _c1IC6() //  [R1]
         { info_tbl: [(c1IC6,
                       label: block_c1IC6_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IC6: // global
           I64[Sp] = block_c1ICb_info;
           _s1HaD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1HaD::I64;
           if (R1 & 7 != 0) goto u1IIU; else goto c1ICf;
       u1IIU: // global
           call _c1ICb(R1) args: 0, res: 0, upd: 0;
       c1ICf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ICb() //  [R1]
         { info_tbl: [(c1ICb,
                       label: block_c1ICb_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ICb: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1IGE; else goto u1IGD;
       u1IGE: // global
           Sp = Sp + 16;
           call _s1Ha2() args: 0, res: 0, upd: 0;
       u1IGD: // global
           Sp = Sp + 16;
           call _s1H8z() args: 0, res: 0, upd: 0;
     }
 },
 _s1Ha2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1Ha2: // global
           I64[Sp - 8] = block_c1IrB_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJw; else goto c1IrC;
       u1IJw: // global
           call _c1IrB(R1) args: 0, res: 0, upd: 0;
       c1IrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IrB() //  [R1]
         { info_tbl: [(c1IrB,
                       label: block_c1IrB_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IrB: // global
           if (R1 & 7 == 1) goto u1IGL; else goto c1IAe;
       u1IGL: // global
           Sp = Sp + 8;
           call _s1Ha3() args: 0, res: 0, upd: 0;
       c1IAe: // global
           I64[Sp] = block_c1IrH_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1IHw; else goto c1IrI;
       u1IHw: // global
           call _c1IrH(R1) args: 0, res: 0, upd: 0;
       c1IrI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IrH() //  [R1]
         { info_tbl: [(c1IrH,
                       label: block_c1IrH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IrH: // global
           if (R1 & 7 == 1) goto c1IAh; else goto u1IGM;
       c1IAh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c1IAk; else goto c1IAj;
       c1IAk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IAj: // global
           I64[Hp - 16] = sat_s1Hai_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_c1IAf_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
       u1IGM: // global
           Sp = Sp + 8;
           call _s1Ha3() args: 0, res: 0, upd: 0;
     }
 },
 _c1IAf() //  [R1]
         { info_tbl: [(c1IAf,
                       label: block_c1IAf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IAf: // global
           if (R1 & 7 == 1) goto u1IGN; else goto u1IGO;
       u1IGN: // global
           Sp = Sp + 80;
           call _c1IAq() args: 0, res: 0, upd: 0;
       u1IGO: // global
           Sp = Sp + 8;
           call _s1H8z() args: 0, res: 0, upd: 0;
     }
 },
 _s1Ha3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1Ha3: // global
           I64[Sp - 8] = block_c1IqH_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJx; else goto c1IqI;
       u1IJx: // global
           call _c1IqH(R1) args: 0, res: 0, upd: 0;
       c1IqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IqH() //  [R1]
         { info_tbl: [(c1IqH,
                       label: block_c1IqH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IqH: // global
           if (R1 & 7 == 1) goto u1IGP; else goto c1IzJ;
       u1IGP: // global
           Sp = Sp + 8;
           call _s1H8z() args: 0, res: 0, upd: 0;
       c1IzJ: // global
           I64[Sp] = block_c1IqN_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1IHr; else goto c1IqO;
       u1IHr: // global
           call _c1IqN(R1) args: 0, res: 0, upd: 0;
       c1IqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IqN() //  [R1]
         { info_tbl: [(c1IqN,
                       label: block_c1IqN_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IqN: // global
           if (R1 & 7 == 1) goto u1IGQ; else goto c1IzP;
       u1IGQ: // global
           Sp = Sp + 8;
           call _s1H8z() args: 0, res: 0, upd: 0;
       c1IzP: // global
           I64[Sp] = block_c1IqT_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1IHt; else goto c1IqU;
       u1IHt: // global
           call _c1IqT(R1) args: 0, res: 0, upd: 0;
       c1IqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IqT() //  [R1]
         { info_tbl: [(c1IqT,
                       label: block_c1IqT_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IqT: // global
           if (R1 & 7 == 1) goto u1IGR; else goto c1IzV;
       u1IGR: // global
           Sp = Sp + 8;
           call _s1H8z() args: 0, res: 0, upd: 0;
       c1IzV: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1IzY; else goto c1IzX;
       c1IzY: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IzX: // global
           _s1Ha8::P64 = P64[R1 + 6];
           I64[Hp - 32] = sat_s1Hae_info;
           P64[Hp - 16] = P64[Sp + 56];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s1Ha8::P64;
           I64[Sp] = block_c1IzU_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1IzU() //  [R1]
         { info_tbl: [(c1IzU,
                       label: block_c1IzU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IzU: // global
           if (R1 & 7 == 1) goto u1IGS; else goto u1IGT;
       u1IGS: // global
           Sp = Sp + 80;
           call _c1IAq() args: 0, res: 0, upd: 0;
       u1IGT: // global
           Sp = Sp + 8;
           call _s1H8z() args: 0, res: 0, upd: 0;
     }
 },
 _s1H8z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H8z: // global
           I64[Sp - 8] = block_c1Is8_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJk; else goto c1IyC;
       u1IJk: // global
           call _c1Is8(R1) args: 0, res: 0, upd: 0;
       c1IyC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Is8() //  [R1]
         { info_tbl: [(c1Is8,
                       label: block_c1Is8_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Is8: // global
           _s1H8u::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c1IyJ; else goto c1IyZ;
       c1IyJ: // global
           I64[Sp] = block_c1IyG_info;
           R1 = _s1H8u::P64;
           if (R1 & 7 != 0) goto u1IHB; else goto c1IyK;
       u1IHB: // global
           call _c1IyG(R1) args: 0, res: 0, upd: 0;
       c1IyK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1IyZ: // global
           I64[Sp - 8] = block_c1IyX_info;
           _s1H9O::P64 = P64[R1 + 6];
           R1 = _s1H8u::P64;
           P64[Sp] = _s1H9O::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IHC; else goto c1Iz0;
       u1IHC: // global
           call _c1IyX(R1) args: 0, res: 0, upd: 0;
       c1Iz0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IyG() //  [R1]
         { info_tbl: [(c1IyG,
                       label: block_c1IyG_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IyG: // global
           if (R1 & 7 == 1) goto u1IGX; else goto u1IGY;
       u1IGX: // global
           Sp = Sp + 8;
           call _s1H9H() args: 0, res: 0, upd: 0;
       u1IGY: // global
           Sp = Sp + 8;
           call _s1H8A() args: 0, res: 0, upd: 0;
     }
 },
 _c1IyX() //  [R1]
         { info_tbl: [(c1IyX,
                       label: block_c1IyX_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IyX: // global
           if (R1 & 7 == 1) goto u1IGU; else goto c1Izg;
       u1IGU: // global
           Sp = Sp + 16;
           call _s1H8A() args: 0, res: 0, upd: 0;
       c1Izg: // global
           I64[Sp] = block_c1Iz9_info;
           _s1H9Q::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1H9Q::P64;
           if (R1 & 7 != 0) goto u1IIq; else goto c1Iza;
       u1IIq: // global
           call _c1Iz9(R1) args: 0, res: 0, upd: 0;
       c1Iza: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Iz9() //  [R1]
         { info_tbl: [(c1Iz9,
                       label: block_c1Iz9_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iz9: // global
           I64[Sp] = block_c1Ize_info;
           _s1H9S::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H9S::I64;
           if (R1 & 7 != 0) goto u1IIs; else goto c1Izi;
       u1IIs: // global
           call _c1Ize(R1) args: 0, res: 0, upd: 0;
       c1Izi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ize() //  [R1]
         { info_tbl: [(c1Ize,
                       label: block_c1Ize_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ize: // global
           if (I64[Sp + 8] == I64[R1 + 7]) goto u1IGV; else goto u1IGW;
       u1IGV: // global
           Sp = Sp + 16;
           call _s1H9H() args: 0, res: 0, upd: 0;
       u1IGW: // global
           Sp = Sp + 16;
           call _s1H8A() args: 0, res: 0, upd: 0;
     }
 },
 _s1H9H() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H9H: // global
           I64[Sp - 8] = block_c1IxV_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJs; else goto c1IxX;
       u1IJs: // global
           call _c1IxV(R1) args: 0, res: 0, upd: 0;
       c1IxX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IxV() //  [R1]
         { info_tbl: [(c1IxV,
                       label: block_c1IxV_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IxV: // global
           _s1H8t::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1Iy4; else goto c1Iyn;
       c1Iy4: // global
           I64[Sp] = block_c1Iy1_info;
           R1 = _s1H8t::P64;
           if (R1 & 7 != 0) goto u1IIk; else goto c1Iy5;
       u1IIk: // global
           call _c1Iy1(R1) args: 0, res: 0, upd: 0;
       c1Iy5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1Iyn: // global
           I64[Sp] = block_c1Iyl_info;
           R1 = _s1H8t::P64;
           if (R1 & 7 != 0) goto u1IIl; else goto c1Iyo;
       u1IIl: // global
           call _c1Iyl(R1) args: 0, res: 0, upd: 0;
       c1Iyo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Iy1() //  [R1]
         { info_tbl: [(c1Iy1,
                       label: block_c1Iy1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iy1: // global
           if (R1 & 7 == 1) goto c1Iyb; else goto u1IH0;
       c1Iyb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Iye; else goto c1Iyd;
       c1Iye: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Iyd: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1IH0: // global
           Sp = Sp + 8;
           call _s1H8A() args: 0, res: 0, upd: 0;
     }
 },
 _c1Iyl() //  [R1]
         { info_tbl: [(c1Iyl,
                       label: block_c1Iyl_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iyl: // global
           if (R1 & 7 == 1) goto u1IGZ; else goto c1Iyy;
       u1IGZ: // global
           Sp = Sp + 8;
           call _s1H8A() args: 0, res: 0, upd: 0;
       c1Iyy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1IyB; else goto c1IyA;
       c1IyB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IyA: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1H8A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H8A: // global
           I64[Sp - 8] = block_c1Isa_info;
           R1 = P64[Sp + 56];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJl; else goto c1Ixs;
       u1IJl: // global
           call _c1Isa(R1) args: 0, res: 0, upd: 0;
       c1Ixs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Isa() //  [R1]
         { info_tbl: [(c1Isa,
                       label: block_c1Isa_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Isa: // global
           if (R1 & 7 == 1) goto u1IH1; else goto c1IxD;
       u1IH1: // global
           Sp = Sp + 8;
           call _s1H8C() args: 0, res: 0, upd: 0;
       c1IxD: // global
           I64[Sp] = block_c1IxB_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1IHD; else goto c1IxE;
       u1IHD: // global
           call _c1IxB(R1) args: 0, res: 0, upd: 0;
       c1IxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IxB() //  [R1]
         { info_tbl: [(c1IxB,
                       label: block_c1IxB_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IxB: // global
           if (R1 & 7 == 1) goto c1IxK; else goto u1IH2;
       c1IxK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1IxN; else goto c1IxM;
       c1IxN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IxM: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1IH2: // global
           Sp = Sp + 8;
           call _s1H8C() args: 0, res: 0, upd: 0;
     }
 },
 _s1H8C() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H8C: // global
           I64[Sp - 8] = block_c1Isc_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJm; else goto c1IwQ;
       u1IJm: // global
           call _c1Isc(R1) args: 0, res: 0, upd: 0;
       c1IwQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Isc() //  [R1]
         { info_tbl: [(c1Isc,
                       label: block_c1Isc_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Isc: // global
           if (R1 & 7 == 1) goto c1IwX; else goto u1IH3;
       c1IwX: // global
           I64[Sp] = block_c1IwU_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1IHF; else goto c1IwY;
       u1IHF: // global
           call _c1IwU(R1) args: 0, res: 0, upd: 0;
       c1IwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1IH3: // global
           Sp = Sp + 8;
           call _s1H8E() args: 0, res: 0, upd: 0;
     }
 },
 _c1IwU() //  [R1]
         { info_tbl: [(c1IwU,
                       label: block_c1IwU_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IwU: // global
           if (R1 & 7 == 1) goto c1Ix5; else goto u1IH4;
       c1Ix5: // global
           I64[Sp] = block_c1Ix2_info;
           R1 = P64[Sp + 16];
           if (R1 & 7 != 0) goto u1IIg; else goto c1Ix6;
       u1IIg: // global
           call _c1Ix2(R1) args: 0, res: 0, upd: 0;
       c1Ix6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1IH4: // global
           Sp = Sp + 8;
           call _s1H8E() args: 0, res: 0, upd: 0;
     }
 },
 _c1Ix2() //  [R1]
         { info_tbl: [(c1Ix2,
                       label: block_c1Ix2_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ix2: // global
           if (R1 & 7 == 1) goto c1Ixc; else goto u1IH5;
       c1Ixc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ixf; else goto c1Ixe;
       c1Ixf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Ixe: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       u1IH5: // global
           Sp = Sp + 8;
           call _s1H8E() args: 0, res: 0, upd: 0;
     }
 },
 _s1H8E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H8E: // global
           I64[Sp - 8] = block_c1Isi_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJn; else goto c1Iwh;
       u1IJn: // global
           call _c1Isi(R1) args: 0, res: 0, upd: 0;
       c1Iwh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Isi() //  [R1]
         { info_tbl: [(c1Isi,
                       label: block_c1Isi_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Isi: // global
           _s1H8t::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1Iwo; else goto c1IwE;
       c1Iwo: // global
           I64[Sp] = block_c1Iwl_info;
           R1 = _s1H8t::P64;
           if (R1 & 7 != 0) goto u1IHH; else goto c1Iwp;
       u1IHH: // global
           call _c1Iwl(R1) args: 0, res: 0, upd: 0;
       c1Iwp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c1IwE: // global
           I64[Sp] = block_c1IwC_info;
           R1 = _s1H8t::P64;
           if (R1 & 7 != 0) goto u1IHI; else goto c1IwF;
       u1IHI: // global
           call _c1IwC(R1) args: 0, res: 0, upd: 0;
       c1IwF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Iwl() //  [R1]
         { info_tbl: [(c1Iwl,
                       label: block_c1Iwl_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iwl: // global
           if (R1 & 7 == 1) goto u1IH8; else goto u1IH9;
       u1IH8: // global
           Sp = Sp + 8;
           call _s1H9n() args: 0, res: 0, upd: 0;
       u1IH9: // global
           Sp = Sp + 8;
           call _s1H9a() args: 0, res: 0, upd: 0;
     }
 },
 _c1IwC() //  [R1]
         { info_tbl: [(c1IwC,
                       label: block_c1IwC_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IwC: // global
           if (R1 & 7 == 1) goto u1IH6; else goto u1IH7;
       u1IH6: // global
           Sp = Sp + 8;
           call _s1H9a() args: 0, res: 0, upd: 0;
       u1IH7: // global
           Sp = Sp + 8;
           call _s1H9n() args: 0, res: 0, upd: 0;
     }
 },
 _s1H9n() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H9n: // global
           I64[Sp - 8] = block_c1Ivw_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJr; else goto c1Ivy;
       u1IJr: // global
           call _c1Ivw(R1) args: 0, res: 0, upd: 0;
       c1Ivy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ivw() //  [R1]
         { info_tbl: [(c1Ivw,
                       label: block_c1Ivw_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ivw: // global
           if (R1 & 7 == 1) goto u1IHa; else goto c1IvJ;
       u1IHa: // global
           Sp = Sp + 8;
           call _s1H9a() args: 0, res: 0, upd: 0;
       c1IvJ: // global
           I64[Sp - 8] = block_c1IvH_info;
           _s1H9p::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1H9p::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1II5; else goto c1IvK;
       u1II5: // global
           call _c1IvH(R1) args: 0, res: 0, upd: 0;
       c1IvK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IvH() //  [R1]
         { info_tbl: [(c1IvH,
                       label: block_c1IvH_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IvH: // global
           if (R1 & 7 == 1) goto u1IHb; else goto c1Iw0;
       u1IHb: // global
           Sp = Sp + 16;
           call _s1H9a() args: 0, res: 0, upd: 0;
       c1Iw0: // global
           I64[Sp] = block_c1IvT_info;
           _s1H9r::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1H9r::P64;
           if (R1 & 7 != 0) goto u1II7; else goto c1IvU;
       u1II7: // global
           call _c1IvT(R1) args: 0, res: 0, upd: 0;
       c1IvU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _s1H9a() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H9a: // global
           I64[Sp - 8] = block_c1Iuk_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJq; else goto c1Ium;
       u1IJq: // global
           call _c1Iuk(R1) args: 0, res: 0, upd: 0;
       c1Ium: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Iuk() //  [R1]
         { info_tbl: [(c1Iuk,
                       label: block_c1Iuk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iuk: // global
           if (R1 & 7 == 1) goto c1Iut; else goto u1IHd;
       c1Iut: // global
           I64[Sp] = block_c1Iuq_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1IHV; else goto c1Iuu;
       u1IHV: // global
           call _c1Iuq(R1) args: 0, res: 0, upd: 0;
       c1Iuu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1IHd: // global
           Sp = Sp + 8;
           call _s1H8G() args: 0, res: 0, upd: 0;
     }
 },
 _c1Iuq() //  [R1]
         { info_tbl: [(c1Iuq,
                       label: block_c1Iuq_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iuq: // global
           if (R1 & 7 == 1) goto u1IHe; else goto c1IuF;
       u1IHe: // global
           Sp = Sp + 8;
           call _s1H8G() args: 0, res: 0, upd: 0;
       c1IuF: // global
           I64[Sp] = block_c1IuD_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1IHX; else goto c1IuG;
       u1IHX: // global
           call _c1IuD(R1) args: 0, res: 0, upd: 0;
       c1IuG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IuD() //  [R1]
         { info_tbl: [(c1IuD,
                       label: block_c1IuD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IuD: // global
           if (R1 & 7 == 1) goto u1IHf; else goto c1IuR;
       u1IHf: // global
           Sp = Sp + 8;
           call _s1H8G() args: 0, res: 0, upd: 0;
       c1IuR: // global
           I64[Sp - 8] = block_c1IuP_info;
           _s1H9f::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp] = _s1H9f::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IHZ; else goto c1IuS;
       u1IHZ: // global
           call _c1IuP(R1) args: 0, res: 0, upd: 0;
       c1IuS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IuP() //  [R1]
         { info_tbl: [(c1IuP,
                       label: block_c1IuP_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IuP: // global
           if (R1 & 7 == 1) goto u1IHg; else goto c1Iv8;
       u1IHg: // global
           Sp = Sp + 16;
           call _s1H8G() args: 0, res: 0, upd: 0;
       c1Iv8: // global
           I64[Sp] = block_c1Iv1_info;
           _s1H9h::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s1H9h::P64;
           if (R1 & 7 != 0) goto u1II1; else goto c1Iv2;
       u1II1: // global
           call _c1Iv1(R1) args: 0, res: 0, upd: 0;
       c1Iv2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Iv1() //  [R1]
         { info_tbl: [(c1Iv1,
                       label: block_c1Iv1_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iv1: // global
           I64[Sp] = block_c1Iv6_info;
           _s1H9j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H9j::I64;
           if (R1 & 7 != 0) goto u1II3; else goto c1Iva;
       u1II3: // global
           call _c1Iv6(R1) args: 0, res: 0, upd: 0;
       c1Iva: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Iv6() //  [R1]
         { info_tbl: [(c1Iv6,
                       label: block_c1Iv6_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iv6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ivg; else goto c1Ivf;
       c1Ivg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Ivf: // global
           if (%MO_S_Ge_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1IHh; else goto c1Ivo;
       u1IHh: // global
           Sp = Sp + 16;
           call _c1Iwc() args: 0, res: 0, upd: 0;
       c1Ivo: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 6;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1IvT() //  [R1]
         { info_tbl: [(c1IvT,
                       label: block_c1IvT_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IvT: // global
           I64[Sp] = block_c1IvY_info;
           _s1H9t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s1H9t::I64;
           if (R1 & 7 != 0) goto u1II9; else goto c1Iw2;
       u1II9: // global
           call _c1IvY(R1) args: 0, res: 0, upd: 0;
       c1Iw2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IvY() //  [R1]
         { info_tbl: [(c1IvY,
                       label: block_c1IvY_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IvY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Iw8; else goto c1Iw7;
       c1Iw8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Iw7: // global
           if (%MO_S_Gt_W64(I64[Sp + 8],
                            I64[R1 + 7])) goto u1IHc; else goto c1Iwg;
       u1IHc: // global
           Sp = Sp + 16;
           call _c1Iwc() args: 0, res: 0, upd: 0;
       c1Iwg: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 56];
           R1 = Hp - 6;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1Iwc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Iwc: // global
           Hp = Hp - 16;
           call _s1H8G() args: 0, res: 0, upd: 0;
     }
 },
 _s1H8G() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H8G: // global
           I64[Sp - 8] = block_c1Isk_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJo; else goto c1It7;
       u1IJo: // global
           call _c1Isk(R1) args: 0, res: 0, upd: 0;
       c1It7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Isk() //  [R1]
         { info_tbl: [(c1Isk,
                       label: block_c1Isk_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Isk: // global
           if (R1 & 7 == 1) goto u1IHi; else goto c1Iti;
       u1IHi: // global
           Sp = Sp + 8;
           call _s1H8H() args: 0, res: 0, upd: 0;
       c1Iti: // global
           I64[Sp] = block_c1Itg_info;
           R1 = P64[Sp + 64];
           if (R1 & 7 != 0) goto u1IHJ; else goto c1Itj;
       u1IHJ: // global
           call _c1Itg(R1) args: 0, res: 0, upd: 0;
       c1Itj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Itg() //  [R1]
         { info_tbl: [(c1Itg,
                       label: block_c1Itg_info
                       rep:StackRep [False, False, False, False, True, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Itg: // global
           if (R1 & 7 == 1) goto c1Itq; else goto u1IHj;
       c1Itq: // global
           I64[Sp] = block_c1Itn_info;
           R1 = P64[Sp + 32];
           if (R1 & 7 != 0) goto u1IHN; else goto c1Itr;
       u1IHN: // global
           call _c1Itn(R1) args: 0, res: 0, upd: 0;
       c1Itr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       u1IHj: // global
           Sp = Sp + 8;
           call _s1H8H() args: 0, res: 0, upd: 0;
     }
 },
 _c1Itn() //  [R1]
         { info_tbl: [(c1Itn,
                       label: block_c1Itn_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Itn: // global
           if (R1 & 7 == 1) goto u1IHk; else goto c1ItC;
       u1IHk: // global
           Sp = Sp + 8;
           call _s1H8H() args: 0, res: 0, upd: 0;
       c1ItC: // global
           I64[Sp] = block_c1ItA_info;
           _s1H91::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 40] = _s1H91::P64;
           if (R1 & 7 != 0) goto u1IHP; else goto c1ItD;
       u1IHP: // global
           call _c1ItA(R1) args: 0, res: 0, upd: 0;
       c1ItD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ItA() //  [R1]
         { info_tbl: [(c1ItA,
                       label: block_c1ItA_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ItA: // global
           if (R1 & 7 == 1) goto u1IHl; else goto c1ItT;
       u1IHl: // global
           Sp = Sp + 8;
           call _s1H8H() args: 0, res: 0, upd: 0;
       c1ItT: // global
           I64[Sp] = block_c1ItM_info;
           R1 = P64[R1 + 6];
           if (R1 & 7 != 0) goto u1IHR; else goto c1ItN;
       u1IHR: // global
           call _c1ItM(R1) args: 0, res: 0, upd: 0;
       c1ItN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ItM() //  [R1]
         { info_tbl: [(c1ItM,
                       label: block_c1ItM_info
                       rep:StackRep [False, False, False, True, False, False, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ItM: // global
           I64[Sp] = block_c1ItR_info;
           _s1H95::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _s1H95::I64;
           if (R1 & 7 != 0) goto u1IHT; else goto c1ItV;
       u1IHT: // global
           call _c1ItR(R1) args: 0, res: 0, upd: 0;
       c1ItV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1ItR() //  [R1]
         { info_tbl: [(c1ItR,
                       label: block_c1ItR_info
                       rep:StackRep [False, False, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1ItR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Iu1; else goto c1Iu0;
       c1Iu1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Iu0: // global
           if (%MO_S_Gt_W64(I64[R1 + 7],
                            I64[Sp + 40] + 1)) goto c1Iu8; else goto c1Iuc;
       c1Iu8: // global
           Hp = Hp - 16;
           Sp = Sp + 8;
           call _s1H8H() args: 0, res: 0, upd: 0;
       c1Iuc: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _s1H8H() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s1H8H: // global
           I64[Sp - 8] = block_c1IoZ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u1IJp; else goto c1Ip0;
       u1IJp: // global
           call _c1IoZ(R1) args: 0, res: 0, upd: 0;
       c1Ip0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1IoZ() //  [R1]
         { info_tbl: [(c1IoZ,
                       label: block_c1IoZ_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IoZ: // global
           if (R1 & 7 == 1) goto c1Isq; else goto c1Isv;
       c1Isq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1Ist; else goto c1Iss;
       c1Ist: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1Iss: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 48];
           R1 = Hp - 6;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c1Isv: // global
           I64[Sp] = block_c1Ip5_info;
           _s1H8K::P64 = P64[R1 + 6];
           R1 = P64[Sp + 64];
           P64[Sp + 64] = _s1H8K::P64;
           if (R1 & 7 != 0) goto u1IHq; else goto c1Ip6;
       u1IHq: // global
           call _c1Ip5(R1) args: 0, res: 0, upd: 0;
       c1Ip6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c1Ip5() //  [R1]
         { info_tbl: [(c1Ip5,
                       label: block_c1Ip5_info
                       rep:StackRep [False, True, False, True, True, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Ip5: // global
           _c1Ioh::P64 = P64[Sp + 24];
           _c1Ioo::P64 = P64[Sp + 8];
           _s1H8l::P64 = P64[Sp + 56];
           _s1H8n::P64 = P64[Sp + 72];
           _s1H8K::P64 = P64[Sp + 64];
           if (R1 & 7 == 1) goto c1Isy; else goto c1IsQ;
       c1Isy: // global
           Hp = Hp + 40;
           _s1H8L::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1IsT; else goto c1IsA;
       c1IsA: // global
           I64[Hp - 32] = sat_s1H8O_info;
           P64[Hp - 16] = _s1H8l::P64;
           P64[Hp - 8] = _c1Ioh::P64;
           P64[Hp] = _s1H8K::P64;
           I64[Sp + 40] = block_c1Isw_info;
           R2 = _c1Ioo::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _s1H8n::P64;
           P64[Sp + 32] = Hp - 32;
           Sp = Sp + 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
       c1IsQ: // global
           Hp = Hp + 40;
           _s1H8L::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c1IsT; else goto c1IsS;
       c1IsT: // global
           HpAlloc = 40;
           R1 = _s1H8L::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IsS: // global
           I64[Hp - 32] = sat_s1H8W_info;
           P64[Hp - 16] = _s1H8l::P64;
           P64[Hp - 8] = _c1Ioh::P64;
           P64[Hp] = _s1H8K::P64;
           I64[Sp + 40] = block_c1IsP_info;
           R2 = _c1Ioo::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = _s1H8n::P64;
           P64[Sp + 32] = Hp - 32;
           Sp = Sp + 16;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c1Isw() //  [R1]
         { info_tbl: [(c1Isw,
                       label: block_c1Isw_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1Isw: // global
           if (R1 & 7 == 1) goto u1IHo; else goto c1IsL;
       u1IHo: // global
           Sp = Sp + 40;
           call _c1IAq() args: 0, res: 0, upd: 0;
       c1IsL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1IsO; else goto c1IsN;
       c1IsO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1IsN: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1IsP() //  [R1]
         { info_tbl: [(c1IsP,
                       label: block_c1IsP_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IsP: // global
           if (R1 & 7 == 1) goto u1IHn; else goto c1It3;
       u1IHn: // global
           Sp = Sp + 40;
           call _c1IAq() args: 0, res: 0, upd: 0;
       c1It3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c1It6; else goto c1It5;
       c1It6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c1It5: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c1IAq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IAq: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.893099731 UTC

[section ""cstring" . Data.Bits.$trModule4_bytes" {
     Data.Bits.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.894978115 UTC

[section ""data" . Data.Bits.$trModule3_closure" {
     Data.Bits.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.89682491 UTC

[section ""cstring" . Data.Bits.$trModule2_bytes" {
     Data.Bits.$trModule2_bytes:
         I8[] [68,97,116,97,46,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.898587815 UTC

[section ""data" . Data.Bits.$trModule1_closure" {
     Data.Bits.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.90034929 UTC

[section ""data" . Data.Bits.$trModule_closure" {
     Data.Bits.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Bits.$trModule3_closure+1;
         const Data.Bits.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.902971568 UTC

[section ""data" . $krep_r1CDE_closure" {
     $krep_r1CDE_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.904811635 UTC

[section ""data" . $krep1_r1CDF_closure" {
     $krep1_r1CDF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.906563168 UTC

[section ""data" . $krep2_r1CDG_closure" {
     $krep2_r1CDG_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.908335191 UTC

[section ""data" . $krep3_r1CDH_closure" {
     $krep3_r1CDH_closure:
         const :_con_info;
         const $krep1_r1CDF_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.910194515 UTC

[section ""data" . $krep4_r1CDI_closure" {
     $krep4_r1CDI_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure;
         const $krep3_r1CDH_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.911997089 UTC

[section ""data" . $krep5_r1CDJ_closure" {
     $krep5_r1CDJ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1CDF_closure+1;
         const $krep_r1CDE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.913859294 UTC

[section ""data" . Data.Bits.$tcBits1_closure" {
     Data.Bits.$tcBits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep2_r1CDG_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.915660548 UTC

[section ""data" . $krep6_r1CDK_closure" {
     $krep6_r1CDK_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.917399793 UTC

[section ""data" . $krep7_r1CDL_closure" {
     $krep7_r1CDL_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep6_r1CDK_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.919106705 UTC

[section ""data" . $krep8_r1CDM_closure" {
     $krep8_r1CDM_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep7_r1CDL_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.920902931 UTC

[section ""data" . $krep9_r1CDN_closure" {
     $krep9_r1CDN_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep5_r1CDJ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.922695357 UTC

[section ""data" . $krep10_r1CDO_closure" {
     $krep10_r1CDO_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep4_r1CDI_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.924441421 UTC

[section ""data" . $krep11_r1CDP_closure" {
     $krep11_r1CDP_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep1_r1CDF_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.926278773 UTC

[section ""data" . $krep12_r1CDQ_closure" {
     $krep12_r1CDQ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep_r1CDE_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.928708794 UTC

[section ""data" . $krep13_r1CDR_closure" {
     $krep13_r1CDR_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r1CDF_closure+1;
         const $krep6_r1CDK_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.930576665 UTC

[section ""data" . $krep14_r1CDS_closure" {
     $krep14_r1CDS_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep13_r1CDR_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.93233572 UTC

[section ""data" . $krep15_r1CDT_closure" {
     $krep15_r1CDT_closure:
         const :_con_info;
         const $krep6_r1CDK_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.934268701 UTC

[section ""data" . $krep16_r1CDU_closure" {
     $krep16_r1CDU_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Classes.$tcEq_closure;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.936002835 UTC

[section ""cstring" . Data.Bits.$tcBits3_bytes" {
     Data.Bits.$tcBits3_bytes:
         I8[] [66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.937718058 UTC

[section ""data" . Data.Bits.$tcBits2_closure" {
     Data.Bits.$tcBits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tcBits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.939435682 UTC

[section ""data" . Data.Bits.$tcBits_closure" {
     Data.Bits.$tcBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tcBits2_closure+1;
         const Data.Bits.$tcBits1_closure+4;
         const 7088815172979416363;
         const 4990916430057605838;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.94137921 UTC

[section ""data" . $krep17_r1CDV_closure" {
     $krep17_r1CDV_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Bits.$tcBits_closure+1;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.94310351 UTC

[section ""data" . $krep18_r1CDW_closure" {
     $krep18_r1CDW_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep17_r1CDV_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.944872417 UTC

[section ""data" . $krep19_r1CDX_closure" {
     $krep19_r1CDX_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep18_r1CDW_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.946707291 UTC

[section ""data" . $krep20_r1CDY_closure" {
     $krep20_r1CDY_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep19_r1CDX_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.948452955 UTC

[section ""data" . $krep21_r1CDZ_closure" {
     $krep21_r1CDZ_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep20_r1CDY_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.951430278 UTC

[section ""data" . $krep22_r1CE0_closure" {
     $krep22_r1CE0_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep21_r1CDZ_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.953171344 UTC

[section ""data" . $krep23_r1CE1_closure" {
     $krep23_r1CE1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep22_r1CE0_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.955604686 UTC

[section ""data" . $krep24_r1CE2_closure" {
     $krep24_r1CE2_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep23_r1CE1_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.957443739 UTC

[section ""data" . $krep25_r1CE3_closure" {
     $krep25_r1CE3_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep12_r1CDQ_closure+4;
         const $krep24_r1CE2_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.95918675 UTC

[section ""data" . $krep26_r1CE4_closure" {
     $krep26_r1CE4_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep25_r1CE3_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.96091794 UTC

[section ""data" . $krep27_r1CE5_closure" {
     $krep27_r1CE5_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep10_r1CDO_closure+4;
         const $krep26_r1CE4_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.96269121 UTC

[section ""data" . $krep28_r1CE6_closure" {
     $krep28_r1CE6_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r1CDN_closure+4;
         const $krep27_r1CE5_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.964443153 UTC

[section ""data" . $krep29_r1CE7_closure" {
     $krep29_r1CE7_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep28_r1CE6_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.967483133 UTC

[section ""data" . $krep30_r1CE8_closure" {
     $krep30_r1CE8_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep29_r1CE7_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.969215652 UTC

[section ""data" . $krep31_r1CE9_closure" {
     $krep31_r1CE9_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep30_r1CE8_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.97100576 UTC

[section ""data" . $krep32_r1CEa_closure" {
     $krep32_r1CEa_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep13_r1CDR_closure+4;
         const $krep31_r1CE9_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.97273783 UTC

[section ""data" . $krep33_r1CEb_closure" {
     $krep33_r1CEb_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r1CDK_closure+2;
         const $krep32_r1CEa_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.97450344 UTC

[section ""data" . $krep34_r1CEc_closure" {
     $krep34_r1CEc_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep33_r1CEb_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.976253458 UTC

[section ""data" . $krep35_r1CEd_closure" {
     $krep35_r1CEd_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep14_r1CDS_closure+4;
         const $krep34_r1CEc_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.978014327 UTC

[section ""data" . $krep36_r1CEe_closure" {
     $krep36_r1CEe_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep7_r1CDL_closure+4;
         const $krep35_r1CEd_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.979679832 UTC

[section ""data" . $krep37_r1CEf_closure" {
     $krep37_r1CEf_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep36_r1CEe_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.981490991 UTC

[section ""data" . $krep38_r1CEg_closure" {
     $krep38_r1CEg_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep37_r1CEf_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.983944378 UTC

[section ""data" . $krep39_r1CEh_closure" {
     $krep39_r1CEh_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep8_r1CDM_closure+4;
         const $krep38_r1CEg_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.985707086 UTC

[section ""data" . Data.Bits.$tc'C:Bits1_closure" {
     Data.Bits.$tc'C:Bits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep16_r1CDU_closure+1;
         const $krep39_r1CEh_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.987357506 UTC

[section ""cstring" . Data.Bits.$tc'C:Bits3_bytes" {
     Data.Bits.$tc'C:Bits3_bytes:
         I8[] [39,67,58,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.98897845 UTC

[section ""data" . Data.Bits.$tc'C:Bits2_closure" {
     Data.Bits.$tc'C:Bits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tc'C:Bits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.990663144 UTC

[section ""data" . Data.Bits.$tc'C:Bits_closure" {
     Data.Bits.$tc'C:Bits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tc'C:Bits2_closure+1;
         const Data.Bits.$tc'C:Bits1_closure+4;
         const 744071653035646959;
         const 2574978498160477882;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.992452934 UTC

[section ""cstring" . Data.Bits.$tcFiniteBits2_bytes" {
     Data.Bits.$tcFiniteBits2_bytes:
         I8[] [70,105,110,105,116,101,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.994202145 UTC

[section ""data" . Data.Bits.$tcFiniteBits1_closure" {
     Data.Bits.$tcFiniteBits1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tcFiniteBits2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.995768875 UTC

[section ""data" . Data.Bits.$tcFiniteBits_closure" {
     Data.Bits.$tcFiniteBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tcFiniteBits1_closure+1;
         const Data.Bits.$tcBits1_closure+4;
         const 2363162769622202131;
         const 10110405838341883172;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.997612941 UTC

[section ""data" . $krep40_r1CEi_closure" {
     $krep40_r1CEi_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Bits.$tcFiniteBits_closure+1;
         const $krep15_r1CDT_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:29.999347974 UTC

[section ""data" . $krep41_r1CEj_closure" {
     $krep41_r1CEj_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep40_r1CEi_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.001016782 UTC

[section ""data" . $krep42_r1CEk_closure" {
     $krep42_r1CEk_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep41_r1CEj_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.002781799 UTC

[section ""data" . $krep43_r1CEl_closure" {
     $krep43_r1CEl_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep11_r1CDP_closure+4;
         const $krep42_r1CEk_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.004524607 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits1_closure" {
     Data.Bits.$tc'C:FiniteBits1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep17_r1CDV_closure+1;
         const $krep43_r1CEl_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.006321893 UTC

[section ""cstring" . Data.Bits.$tc'C:FiniteBits3_bytes" {
     Data.Bits.$tc'C:FiniteBits3_bytes:
         I8[] [39,67,58,70,105,110,105,116,101,66,105,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.008696742 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits2_closure" {
     Data.Bits.$tc'C:FiniteBits2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Bits.$tc'C:FiniteBits3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.010470054 UTC

[section ""data" . Data.Bits.$tc'C:FiniteBits_closure" {
     Data.Bits.$tc'C:FiniteBits_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Bits.$trModule_closure+1;
         const Data.Bits.$tc'C:FiniteBits2_closure+1;
         const Data.Bits.$tc'C:FiniteBits1_closure+4;
         const 7500562306525175158;
         const 16051895206261500648;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.012666776 UTC

[section ""data" . Data.Bits.C:FiniteBits_closure" {
     Data.Bits.C:FiniteBits_closure:
         const Data.Bits.C:FiniteBits_info;
 },
 Data.Bits.C:FiniteBits_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c1IWo,
                       label: Data.Bits.C:FiniteBits_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IWo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c1IWs; else goto c1IWr;
       c1IWs: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Bits.C:FiniteBits_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c1IWr: // global
           I64[Hp - 32] = Data.Bits.C:FiniteBits_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.017763927 UTC

[section ""data" . Data.Bits.C:Bits_closure" {
     Data.Bits.C:Bits_closure:
         const Data.Bits.C:Bits_info;
 },
 Data.Bits.C:Bits_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IWA: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Data.Bits.C:Bits_entry(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2,
                                       R1) args: 152, res: 0, upd: 8;
     }
 },
 Data.Bits.C:Bits_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c1IWF,
                       label: Data.Bits.C:Bits_info
                       rep:HeapRep static {
                             Fun {arity: 23
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False, False, False, False, False, False,
                                                    False, False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IWF: // global
           Hp = Hp + 192;
           if (Hp > HpLim) (likely: False) goto c1IWJ; else goto c1IWI;
       c1IWJ: // global
           HpAlloc = 192;
           R1 = Data.Bits.C:Bits_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 192, res: 0, upd: 8;
       c1IWI: // global
           I64[Hp - 184] = Data.Bits.C:Bits_con_info;
           P64[Hp - 176] = R2;
           P64[Hp - 168] = R3;
           P64[Hp - 160] = R4;
           P64[Hp - 152] = R5;
           P64[Hp - 144] = R6;
           P64[Hp - 136] = P64[Sp];
           P64[Hp - 128] = P64[Sp + 8];
           P64[Hp - 120] = P64[Sp + 16];
           P64[Hp - 112] = P64[Sp + 24];
           P64[Hp - 104] = P64[Sp + 32];
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 48];
           P64[Hp - 80] = P64[Sp + 56];
           P64[Hp - 72] = P64[Sp + 64];
           P64[Hp - 64] = P64[Sp + 72];
           P64[Hp - 56] = P64[Sp + 80];
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = P64[Sp + 96];
           P64[Hp - 32] = P64[Sp + 104];
           P64[Hp - 24] = P64[Sp + 112];
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 128];
           P64[Hp] = P64[Sp + 136];
           R1 = Hp - 183;
           Sp = Sp + 144;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.023862042 UTC

[Data.Bits.C:FiniteBits_con_entry() //  [R1]
         { info_tbl: [(c1IXa,
                       label: Data.Bits.C:FiniteBits_con_info
                       rep:HeapRep 4 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,115,46,67,58,70,105,110,105,116,101,66,105,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IXa: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.027283811 UTC

[Data.Bits.C:Bits_con_entry() //  [R1]
         { info_tbl: [(c1IXh,
                       label: Data.Bits.C:Bits_con_info
                       rep:HeapRep 23 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,68,97,116,97,46,66,105,116,115,46,67,58,66,105,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c1IXh: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:56:30.030496152 UTC

[section ""relreadonly" . S1HoG_srt" {
     S1HoG_srt:
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Bits.$fBitsInteger1_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const Data.Bits.$fBitsInteger_$cshift_closure;
         const Data.Bits.$w$cshift_closure;
         const sat_s1H0l_closure;
         const Data.Bits.$fBitsInteger3_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure;
         const GHC.Integer.Type.complementInteger_closure;
         const Data.Bits.$fBitsInteger_$cclearBit_closure;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure;
         const Data.Bits.$fBitsInteger_$csetBit_closure;
         const Data.Bits.$fBitsInteger_$cshiftR_closure;
         const Data.Bits.$fBitsInteger_$crotateR_closure;
         const Data.Bits.bitDefault_closure;
         const Data.Bits.$fBitsInteger_$czeroBits_closure;
         const Data.Bits.testBitDefault_closure;
         const Data.Bits.$wpopCountDefault_closure;
         const Data.Bits.popCountDefault_closure;
         const GHC.Num.$fNumInteger_closure;
         const Data.Bits.$fBitsInteger_closure;
         const Data.Bits.$fBitsInteger_$cpopCount_closure;
         const Data.Bits.toIntegralSized_closure;
 }]

