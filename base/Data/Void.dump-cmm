
==================== Output Cmm ====================
2018-03-16 16:11:45.271426678 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:45.272010783 UTC

[section ""data" . Data.Void.$fIxVoid1_closure" {
     Data.Void.$fIxVoid1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.272817647 UTC

[section ""data" . Data.Void.$fIxVoid_$crangeSize_closure" {
     Data.Void.$fIxVoid_$crangeSize_closure:
         const Data.Void.$fIxVoid_$crangeSize_info;
 },
 Data.Void.$fIxVoid_$crangeSize_entry() //  []
         { info_tbl: [(cfVVD,
                       label: Data.Void.$fIxVoid_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVVD: // global
           R1 = Data.Void.$fIxVoid1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.273719523 UTC

[section ""data" . Data.Void.$fIxVoid_$crange_closure" {
     Data.Void.$fIxVoid_$crange_closure:
         const Data.Void.$fIxVoid_$crange_info;
 },
 Data.Void.$fIxVoid_$crange_entry() //  []
         { info_tbl: [(cfVVK,
                       label: Data.Void.$fIxVoid_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVVK: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.274558655 UTC

[section ""data" . Data.Void.$fSemigroupVoid_$cstimes_closure" {
     Data.Void.$fSemigroupVoid_$cstimes_closure:
         const Data.Void.$fSemigroupVoid_$cstimes_info;
         const 0;
 },
 Data.Void.$fSemigroupVoid_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(cfVVR,
                       label: Data.Void.$fSemigroupVoid_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVVR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotent_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.275445953 UTC

[section ""data" . Data.Void.$fOrdVoid_$c<>_closure" {
     Data.Void.$fOrdVoid_$c<>_closure:
         const Data.Void.$fOrdVoid_$c<>_info;
 },
 Data.Void.$fOrdVoid_$c<>_entry() //  [R2]
         { info_tbl: [(cfVVZ,
                       label: Data.Void.$fOrdVoid_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVVZ: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.276450401 UTC

[section ""data" . Data.Void.$fSemigroupVoid_$csconcat_closure" {
     Data.Void.$fSemigroupVoid_$csconcat_closure:
         const Data.Void.$fSemigroupVoid_$csconcat_info;
 },
 Data.Void.$fSemigroupVoid_$csconcat_entry() //  [R2]
         { info_tbl: [(cfVW9,
                       label: Data.Void.$fSemigroupVoid_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVW9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfVWd; else goto cfVWe;
       cfVWd: // global
           R2 = R2;
           R1 = Data.Void.$fSemigroupVoid_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfVWe: // global
           I64[Sp - 8] = block_cfVW6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufVWm; else goto cfVW7;
       ufVWm: // global
           call _cfVW6(R1) args: 0, res: 0, upd: 0;
       cfVW7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfVW6() //  [R1]
         { info_tbl: [(cfVW6,
                       label: block_cfVW6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVW6: // global
           I64[Sp - 8] = block_cfVWc_info;
           _sfVTo::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfVTo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufVWl; else goto cfVWg;
       ufVWl: // global
           call _cfVWc() args: 0, res: 0, upd: 0;
       cfVWg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfVWc() //  []
         { info_tbl: [(cfVWc,
                       label: block_cfVWc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVWc: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.27766206 UTC

[section ""data" . Data.Void.$fSemigroupVoid_closure" {
     Data.Void.$fSemigroupVoid_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Void.$fOrdVoid_$c<>_closure+2;
         const Data.Void.$fSemigroupVoid_$csconcat_closure+1;
         const Data.Void.$fSemigroupVoid_$cstimes_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.278343057 UTC

[section ""data" . Data.Void.$fShowVoid_$cshowsPrec_closure" {
     Data.Void.$fShowVoid_$cshowsPrec_closure:
         const Data.Void.$fShowVoid_$cshowsPrec_info;
 },
 Data.Void.$fShowVoid_$cshowsPrec_entry() //  [R3]
         { info_tbl: [(cfVWr,
                       label: Data.Void.$fShowVoid_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVWr: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.279157824 UTC

[section ""data" . Data.Void.$fExceptionVoid_$cshow_closure" {
     Data.Void.$fExceptionVoid_$cshow_closure:
         const Data.Void.$fExceptionVoid_$cshow_info;
 },
 Data.Void.$fExceptionVoid_$cshow_entry() //  [R2]
         { info_tbl: [(cfVWy,
                       label: Data.Void.$fExceptionVoid_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVWy: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.279985994 UTC

[section ""data" . Data.Void.$fShowVoid1_closure" {
     Data.Void.$fShowVoid1_closure:
         const Data.Void.$fShowVoid1_info;
 },
 Data.Void.$fShowVoid1_entry() //  [R2]
         { info_tbl: [(cfVWF,
                       label: Data.Void.$fShowVoid1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVWF: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.280821093 UTC

[section ""data" . Data.Void.$fShowVoid_$cshowList_closure" {
     Data.Void.$fShowVoid_$cshowList_closure:
         const Data.Void.$fShowVoid_$cshowList_info;
 },
 Data.Void.$fShowVoid_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cfVWM,
                       label: Data.Void.$fShowVoid_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVWM: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Void.$fShowVoid1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.281639089 UTC

[section ""data" . Data.Void.$fShowVoid_closure" {
     Data.Void.$fShowVoid_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Void.$fShowVoid_$cshowsPrec_closure+2;
         const Data.Void.$fExceptionVoid_$cshow_closure+1;
         const Data.Void.$fShowVoid_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.282350809 UTC

[section ""data" . Data.Void.$fReadVoid2_closure" {
     Data.Void.$fReadVoid2_closure:
         const Data.Void.$fReadVoid2_info;
 },
 Data.Void.$fReadVoid2_entry() //  [R2]
         { info_tbl: [(cfVWT,
                       label: Data.Void.$fReadVoid2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVWT: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.283151284 UTC

[section ""data" . Data.Void.$fReadVoid_$creadsPrec_closure" {
     Data.Void.$fReadVoid_$creadsPrec_closure:
         const Data.Void.$fReadVoid_$creadsPrec_info;
 },
 Data.Void.$fReadVoid_$creadsPrec_entry() //  [R3]
         { info_tbl: [(cfVX0,
                       label: Data.Void.$fReadVoid_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVX0: // global
           R2 = R3;
           call Data.Void.$fReadVoid2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.284032173 UTC

[section ""data" . Data.Void.$fReadVoid_$creadListPrec_closure" {
     Data.Void.$fReadVoid_$creadListPrec_closure:
         const Data.Void.$fReadVoid_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fReadVoid_$creadListPrec_entry() //  [R1]
         { info_tbl: [(cfVX9,
                       label: Data.Void.$fReadVoid_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVX9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfVXa; else goto cfVXb;
       cfVXa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfVXb: // global
           (_cfVX6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfVX6::I64 == 0) goto cfVX8; else goto cfVX7;
       cfVX8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfVX7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfVX6::I64;
           R2 = Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.285114038 UTC

[section ""data" . Data.Void.$fReadVoid1_closure" {
     Data.Void.$fReadVoid1_closure:
         const Data.Void.$fReadVoid1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fReadVoid1_entry() //  [R1]
         { info_tbl: [(cfVXi,
                       label: Data.Void.$fReadVoid1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVXi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfVXj; else goto cfVXk;
       cfVXj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfVXk: // global
           (_cfVXf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfVXf::I64 == 0) goto cfVXh; else goto cfVXg;
       cfVXh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfVXg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfVXf::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Void.$fReadVoid_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.286186116 UTC

[section ""data" . Data.Void.$fReadVoid_$creadList_closure" {
     Data.Void.$fReadVoid_$creadList_closure:
         const Data.Void.$fReadVoid_$creadList_info;
         const 0;
 },
 Data.Void.$fReadVoid_$creadList_entry() //  [R2]
         { info_tbl: [(cfVXp,
                       label: Data.Void.$fReadVoid_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVXp: // global
           R3 = R2;
           R2 = Data.Void.$fReadVoid1_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.286925999 UTC

[section ""data" . Data.Void.$fReadVoid_closure" {
     Data.Void.$fReadVoid_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Void.$fReadVoid_$creadsPrec_closure+2;
         const Data.Void.$fReadVoid_$creadList_closure+1;
         const Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
         const Data.Void.$fReadVoid_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.287654213 UTC

[section ""data" . Data.Void.$fOrdVoid_$ccompare_closure" {
     Data.Void.$fOrdVoid_$ccompare_closure:
         const Data.Void.$fOrdVoid_$ccompare_info;
 },
 Data.Void.$fOrdVoid_$ccompare_entry() //  []
         { info_tbl: [(cfVXw,
                       label: Data.Void.$fOrdVoid_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVXw: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.288466457 UTC

[section ""data" . Data.Void.$fGenericVoid_$cto_closure" {
     Data.Void.$fGenericVoid_$cto_closure:
         const Data.Void.$fGenericVoid_$cto_info;
 },
 Data.Void.$fGenericVoid_$cto_entry() //  [R2]
         { info_tbl: [(cfVXD,
                       label: Data.Void.$fGenericVoid_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVXD: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.289290643 UTC

[section ""data" . Data.Void.$fGenericVoid1_closure" {
     Data.Void.$fGenericVoid1_closure:
         const Data.Void.$fGenericVoid1_info;
 },
 Data.Void.$fGenericVoid1_entry() //  [R2]
         { info_tbl: [(cfVXK,
                       label: Data.Void.$fGenericVoid1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVXK: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.29006791 UTC

[section ""data" . Data.Void.$fGenericVoid_closure" {
     Data.Void.$fGenericVoid_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Void.$fGenericVoid1_closure+1;
         const Data.Void.$fGenericVoid_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.290769294 UTC

[section ""data" . Data.Void.$fDataVoid_$ctoConstr_closure" {
     Data.Void.$fDataVoid_$ctoConstr_closure:
         const Data.Void.$fDataVoid_$ctoConstr_info;
 },
 Data.Void.$fDataVoid_$ctoConstr_entry() //  [R2]
         { info_tbl: [(cfVXR,
                       label: Data.Void.$fDataVoid_$ctoConstr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVXR: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.291488463 UTC

[section ""cstring" . lvl_rfVTe_bytes" {
     lvl_rfVTe_bytes:
         I8[] [68,97,116,97,47,86,111,105,100,46,104,115,58,51,57,58,53,45,56,124,99,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.292211965 UTC

[section ""data" . lvl1_rfVTf_closure" {
     lvl1_rfVTf_closure:
         const lvl1_rfVTf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rfVTf_entry() //  [R1]
         { info_tbl: [(cfVY0,
                       label: lvl1_rfVTf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVY0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfVY1; else goto cfVY2;
       cfVY1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfVY2: // global
           (_cfVXX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfVXX::I64 == 0) goto cfVXZ; else goto cfVXY;
       cfVXZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfVXY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfVXX::I64;
           R2 = lvl_rfVTe_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.293644464 UTC

[section ""data" . Data.Void.$w$cgunfold_closure" {
     Data.Void.$w$cgunfold_closure:
         const Data.Void.$w$cgunfold_info;
         const 0;
 },
 Data.Void.$w$cgunfold_entry() //  [R2, R3]
         { info_tbl: [(cfVYe,
                       label: Data.Void.$w$cgunfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVYe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfVYf; else goto cfVYg;
       cfVYf: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Void.$w$cgunfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfVYg: // global
           I64[Sp - 16] = block_cfVY7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufVYu; else goto cfVY8;
       ufVYu: // global
           call _cfVY7(R1) args: 0, res: 0, upd: 0;
       cfVY8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfVY7() //  [R1]
         { info_tbl: [(cfVY7,
                       label: block_cfVY7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVY7: // global
           if (R1 & 7 == 1) goto cfVYc; else goto cfVYb;
       cfVYc: // global
           I64[Sp + 8] = block_cfVYm_info;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufVYt; else goto cfVYo;
       ufVYt: // global
           call _cfVYm() args: 0, res: 0, upd: 0;
       cfVYo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfVYb: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Data.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cfVYm() //  []
         { info_tbl: [(cfVYm,
                       label: block_cfVYm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVYm: // global
           R1 = lvl1_rfVTf_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.295122074 UTC

[section ""data" . Data.Void.$fDataVoid_$cgunfold_closure" {
     Data.Void.$fDataVoid_$cgunfold_closure:
         const Data.Void.$fDataVoid_$cgunfold_info;
         const 0;
 },
 Data.Void.$fDataVoid_$cgunfold_entry() //  [R2, R3, R4]
         { info_tbl: [(cfVYC,
                       label: Data.Void.$fDataVoid_$cgunfold_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVYC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfVYG; else goto cfVYH;
       cfVYG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Void.$fDataVoid_$cgunfold_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfVYH: // global
           I64[Sp - 8] = block_cfVYz_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufVYP; else goto cfVYA;
       ufVYP: // global
           call _cfVYz(R1) args: 0, res: 0, upd: 0;
       cfVYA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfVYz() //  [R1]
         { info_tbl: [(cfVYz,
                       label: block_cfVYz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVYz: // global
           I64[Sp - 8] = block_cfVYF_info;
           _sfVTU::P64 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           P64[Sp] = _sfVTU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufVYO; else goto cfVYJ;
       ufVYO: // global
           call _cfVYF(R1) args: 0, res: 0, upd: 0;
       cfVYJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfVYF() //  [R1]
         { info_tbl: [(cfVYF,
                       label: block_cfVYF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVYF: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Void.$w$cgunfold_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.296428591 UTC

[section ""data" . Data.Void.$fDataVoid_$cgfoldl_closure" {
     Data.Void.$fDataVoid_$cgfoldl_closure:
         const Data.Void.$fDataVoid_$cgfoldl_info;
 },
 Data.Void.$fDataVoid_$cgfoldl_entry() //  [R4]
         { info_tbl: [(cfVYU,
                       label: Data.Void.$fDataVoid_$cgfoldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVYU: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.297282126 UTC

[section ""data" . Data.Void.$fEqVoid_$c==_closure" {
     Data.Void.$fEqVoid_$c==_closure:
         const Data.Void.$fEqVoid_$c==_info;
 },
 Data.Void.$fEqVoid_$c==_entry() //  []
         { info_tbl: [(cfVZ1,
                       label: Data.Void.$fEqVoid_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVZ1: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.298096502 UTC

[section ""data" . Data.Void.$fEqVoid_$c/=_closure" {
     Data.Void.$fEqVoid_$c/=_closure:
         const Data.Void.$fEqVoid_$c/=_info;
 },
 Data.Void.$fEqVoid_$c/=_entry() //  []
         { info_tbl: [(cfVZ8,
                       label: Data.Void.$fEqVoid_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVZ8: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.298816775 UTC

[section ""data" . Data.Void.$fEqVoid_closure" {
     Data.Void.$fEqVoid_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fEqVoid_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.299460919 UTC

[section ""data" . Data.Void.$fOrdVoid_$c<_closure" {
     Data.Void.$fOrdVoid_$c<_closure:
         const Data.Void.$fOrdVoid_$c<_info;
 },
 Data.Void.$fOrdVoid_$c<_entry() //  []
         { info_tbl: [(cfVZf,
                       label: Data.Void.$fOrdVoid_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVZf: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.300263779 UTC

[section ""data" . Data.Void.$fOrdVoid_$cmax_closure" {
     Data.Void.$fOrdVoid_$cmax_closure:
         const Data.Void.$fOrdVoid_$cmax_info;
 },
 Data.Void.$fOrdVoid_$cmax_entry() //  [R3]
         { info_tbl: [(cfVZm,
                       label: Data.Void.$fOrdVoid_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVZm: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.300983132 UTC

[section ""data" . Data.Void.$fOrdVoid_closure" {
     Data.Void.$fOrdVoid_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Void.$fEqVoid_closure+1;
         const Data.Void.$fOrdVoid_$ccompare_closure+2;
         const Data.Void.$fOrdVoid_$c<_closure+2;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fOrdVoid_$c<_closure+2;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fOrdVoid_$cmax_closure+2;
         const Data.Void.$fOrdVoid_$c<>_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.30195732 UTC

[section ""data" . Data.Void.absurd_closure" {
     Data.Void.absurd_closure:
         const Data.Void.absurd_info;
 },
 Data.Void.absurd_entry() //  [R2]
         { info_tbl: [(cfVZt,
                       label: Data.Void.absurd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVZt: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.302767609 UTC

[section ""data" . Data.Void.vacuous_closure" {
     Data.Void.vacuous_closure:
         const Data.Void.vacuous_info;
 },
 Data.Void.vacuous_entry() //  [R2]
         { info_tbl: [(cfVZA,
                       label: Data.Void.vacuous_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVZA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfVZB; else goto cfVZC;
       cfVZB: // global
           R2 = R2;
           R1 = Data.Void.vacuous_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfVZC: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Void.absurd_closure+1;
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.303694641 UTC

[section ""data" . Data.Void.$fIxVoid_$cindex_closure" {
     Data.Void.$fIxVoid_$cindex_closure:
         const Data.Void.$fIxVoid_$cindex_info;
 },
 Data.Void.$fIxVoid_$cindex_entry() //  [R3]
         { info_tbl: [(cfVZH,
                       label: Data.Void.$fIxVoid_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVZH: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.304527921 UTC

[section ""data" . Data.Void.$fIxVoid_$cinRange_closure" {
     Data.Void.$fIxVoid_$cinRange_closure:
         const Data.Void.$fIxVoid_$cinRange_info;
 },
 Data.Void.$fIxVoid_$cinRange_entry() //  [R3]
         { info_tbl: [(cfVZO,
                       label: Data.Void.$fIxVoid_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVZO: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.305504937 UTC

[section ""data" . Data.Void.$fIxVoid_$cunsafeRangeSize_closure" {
     Data.Void.$fIxVoid_$cunsafeRangeSize_closure:
         const Data.Void.$fIxVoid_$cunsafeRangeSize_info;
 },
 Data.Void.$fIxVoid_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(cfVZY,
                       label: Data.Void.$fIxVoid_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVZY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfVZZ; else goto cfW00;
       cfVZZ: // global
           R2 = R2;
           R1 = Data.Void.$fIxVoid_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfW00: // global
           I64[Sp - 8] = block_cfVZV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufW04; else goto cfVZW;
       ufW04: // global
           call _cfVZV(R1) args: 0, res: 0, upd: 0;
       cfVZW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfVZV() //  [R1]
         { info_tbl: [(cfVZV,
                       label: block_cfVZV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfVZV: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.30772999 UTC

[section ""data" . Data.Void.$fIxVoid_closure" {
     Data.Void.$fIxVoid_closure:
         const GHC.Arr.C:Ix_con_info;
         const Data.Void.$fOrdVoid_closure+1;
         const Data.Void.$fIxVoid_$crange_closure+1;
         const Data.Void.$fIxVoid_$cindex_closure+2;
         const Data.Void.$fIxVoid_$cindex_closure+2;
         const Data.Void.$fIxVoid_$cinRange_closure+2;
         const Data.Void.$fIxVoid_$crangeSize_closure+1;
         const Data.Void.$fIxVoid_$cunsafeRangeSize_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.3083592 UTC

[section ""cstring" . Data.Void.$fDataVoid5_bytes" {
     Data.Void.$fDataVoid5_bytes:
         I8[] [86,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.309108577 UTC

[section ""data" . Data.Void.$fDataVoid4_closure" {
     Data.Void.$fDataVoid4_closure:
         const Data.Void.$fDataVoid4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fDataVoid4_entry() //  [R1]
         { info_tbl: [(cfW0b,
                       label: Data.Void.$fDataVoid4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW0b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW0c; else goto cfW0d;
       cfW0c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfW0d: // global
           (_cfW08::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfW08::I64 == 0) goto cfW0a; else goto cfW09;
       cfW0a: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfW09: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfW08::I64;
           R2 = Data.Void.$fDataVoid5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.310068695 UTC

[section ""data" . Data.Void.$fDataVoid3_closure" {
     Data.Void.$fDataVoid3_closure:
         const Data.Data.AlgRep_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.310658419 UTC

[section ""data" . Data.Void.$tVoid_closure" {
     Data.Void.$tVoid_closure:
         const Data.Data.DataType_con_info;
         const Data.Void.$fDataVoid4_closure;
         const Data.Void.$fDataVoid3_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.311353436 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataTypeOf_closure" {
     Data.Void.$fDataVoid_$cdataTypeOf_closure:
         const Data.Void.$fDataVoid_$cdataTypeOf_info;
         const 0;
 },
 Data.Void.$fDataVoid_$cdataTypeOf_entry() //  []
         { info_tbl: [(cfW0i,
                       label: Data.Void.$fDataVoid_$cdataTypeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW0i: // global
           R1 = Data.Void.$tVoid_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.312072764 UTC

[section ""cstring" . Data.Void.$trModule4_bytes" {
     Data.Void.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.312608086 UTC

[section ""data" . Data.Void.$trModule3_closure" {
     Data.Void.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.313149059 UTC

[section ""cstring" . Data.Void.$trModule2_bytes" {
     Data.Void.$trModule2_bytes:
         I8[] [68,97,116,97,46,86,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.313967519 UTC

[section ""data" . Data.Void.$trModule1_closure" {
     Data.Void.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.314544906 UTC

[section ""data" . Data.Void.$trModule_closure" {
     Data.Void.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Void.$trModule3_closure+1;
         const Data.Void.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.31513233 UTC

[section ""data" . Data.Void.$fDataVoid7_closure" {
     Data.Void.$fDataVoid7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$fDataVoid5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.315726144 UTC

[section ""data" . Data.Void.$tcVoid_closure" {
     Data.Void.$tcVoid_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Void.$trModule_closure+1;
         const Data.Void.$fDataVoid7_closure+1;
         const GHC.Types.krep$*_closure;
         const 1716938828100304260;
         const 9065598981067935587;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.316767481 UTC

[section ""data" . Data.Void.$fDataVoid6_closure" {
     Data.Void.$fDataVoid6_closure:
         const Data.Void.$fDataVoid6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fDataVoid6_entry() //  [R1]
         { info_tbl: [(cfW0w,
                       label: Data.Void.$fDataVoid6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW0w: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cfW0x; else goto cfW0y;
       cfW0x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfW0y: // global
           (_cfW0o::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfW0o::I64 == 0) goto cfW0q; else goto cfW0p;
       cfW0q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfW0p: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfW0o::I64;
           I64[Sp - 24] = block_cfW0r_info;
           R6 = 0;
           R5 = Data.Void.$fDataVoid7_closure+1;
           R4 = Data.Void.$trModule_closure+1;
           R3 = 9065598981067935587;
           R2 = 1716938828100304260;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cfW0r() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfW0r,
                       label: block_cfW0r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW0r: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cfW0s() args: 0, res: 0, upd: 0;
     }
 },
 _cfW0s() //  []
         { info_tbl: [(cfW0s,
                       label: block_cfW0s_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW0s: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfW0B; else goto cfW0A;
       cfW0B: // global
           HpAlloc = 48;
           I64[Sp] = block_cfW0s_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cfW0A: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.318385153 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataCast1_closure" {
     Data.Void.$fDataVoid_$cdataCast1_closure:
         const Data.Void.$fDataVoid_$cdataCast1_info;
 },
 Data.Void.$fDataVoid_$cdataCast1_entry() //  []
         { info_tbl: [(cfW0I,
                       label: Data.Void.$fDataVoid_$cdataCast1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW0I: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.319903141 UTC

[section ""data" . Data.Void.$w$cgmapMp_closure" {
     Data.Void.$w$cgmapMp_closure:
         const Data.Void.$w$cgmapMp_info;
 },
 lvl2_sfVUD_entry() //  [R1]
         { info_tbl: [(cfW0T,
                       label: lvl2_sfVUD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW0T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW0U; else goto cfW0V;
       cfW0U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfW0V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfVUL_entry() //  [R1, R2]
         { info_tbl: [(cfW18,
                       label: sat_sfVUL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW18: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfW19; else goto cfW1a;
       cfW19: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfW1a: // global
           I64[Sp - 24] = block_cfW15_info;
           _sfVUD::P64 = P64[R1 + 7];
           _sfVUE::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfVUD::P64;
           P64[Sp - 8] = _sfVUE::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufW1s; else goto cfW16;
       ufW1s: // global
           call _cfW15(R1) args: 0, res: 0, upd: 0;
       cfW16: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW15() //  [R1]
         { info_tbl: [(cfW15,
                       label: block_cfW15_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW15: // global
           I64[Sp - 8] = block_cfW1d_info;
           _sfVUI::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfVUI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufW1r; else goto cfW1f;
       ufW1r: // global
           call _cfW1d(R1) args: 0, res: 0, upd: 0;
       cfW1f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW1d() //  [R1]
         { info_tbl: [(cfW1d,
                       label: block_cfW1d_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW1d: // global
           if (R1 & 7 == 1) goto cfW1l; else goto cfW1p;
       cfW1l: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfW1p: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Void.$w$cgmapMp_entry() //  [R2, R3]
         { info_tbl: [(cfW1t,
                       label: Data.Void.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW1t: // global
           _sfVUC::P64 = R3;
           _sfVUB::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cfW1u; else goto cfW1v;
       cfW1v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfW1x; else goto cfW1w;
       cfW1x: // global
           HpAlloc = 24;
           goto cfW1u;
       cfW1u: // global
           R3 = _sfVUC::P64;
           R2 = _sfVUB::P64;
           R1 = Data.Void.$w$cgmapMp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfW1w: // global
           I64[Hp - 16] = lvl2_sfVUD_info;
           P64[Hp] = _sfVUB::P64;
           I64[Sp - 24] = block_cfW0W_info;
           R2 = _sfVUB::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _sfVUC::P64;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfW0W() //  [R1]
         { info_tbl: [(cfW0W,
                       label: block_cfW0W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW0W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfW1A; else goto cfW1z;
       cfW1A: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfW1z: // global
           I64[Hp - 16] = sat_sfVUL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 15;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.322193865 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapMp_closure" {
     Data.Void.$fDataVoid_$cgmapMp_closure:
         const Data.Void.$fDataVoid_$cgmapMp_info;
 },
 Data.Void.$fDataVoid_$cgmapMp_entry() //  [R2, R4]
         { info_tbl: [(cfW1F,
                       label: Data.Void.$fDataVoid_$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW1F: // global
           R3 = R4;
           R2 = R2;
           call Data.Void.$w$cgmapMp_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.323025055 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapM_closure" {
     Data.Void.$fDataVoid_$cgmapM_closure:
         const Data.Void.$fDataVoid_$cgmapM_info;
 },
 Data.Void.$fDataVoid_$cgmapM_entry() //  [R4]
         { info_tbl: [(cfW1M,
                       label: Data.Void.$fDataVoid_$cgmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW1M: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.323839794 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQi_closure" {
     Data.Void.$fDataVoid_$cgmapQi_closure:
         const Data.Void.$fDataVoid_$cgmapQi_info;
 },
 Data.Void.$fDataVoid_$cgmapQi_entry() //  [R4]
         { info_tbl: [(cfW1T,
                       label: Data.Void.$fDataVoid_$cgmapQi_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW1T: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.32463905 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQr_closure" {
     Data.Void.$fDataVoid_$cgmapQr_closure:
         const Data.Void.$fDataVoid_$cgmapQr_info;
 },
 Data.Void.$fDataVoid_$cgmapQr_entry() //  [R5]
         { info_tbl: [(cfW20,
                       label: Data.Void.$fDataVoid_$cgmapQr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW20: // global
           R1 = R5 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.325550867 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQ_closure" {
     Data.Void.$fDataVoid_$cgmapQ_closure:
         const Data.Void.$fDataVoid_$cgmapQ_info;
 },
 Data.Void.$fDataVoid_$cgmapQ_entry() //  [R3]
         { info_tbl: [(cfW27,
                       label: Data.Void.$fDataVoid_$cgmapQ_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW27: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.326478835 UTC

[section ""data" . Data.Void.$fDataVoid1_closure" {
     Data.Void.$fDataVoid1_closure:
         const Data.Void.$fDataVoid1_info;
 },
 Data.Void.$fDataVoid1_entry() //  [R5]
         { info_tbl: [(cfW2e,
                       label: Data.Void.$fDataVoid1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW2e: // global
           R1 = R5 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.327258383 UTC

[section ""data" . Data.Void.$fDataVoid2_closure" {
     Data.Void.$fDataVoid2_closure:
         const Data.Void.$fDataVoid2_info;
 },
 Data.Void.$fDataVoid2_entry() //  [R3]
         { info_tbl: [(cfW2l,
                       label: Data.Void.$fDataVoid2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW2l: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.328071517 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataCast2_closure" {
     Data.Void.$fDataVoid_$cdataCast2_closure:
         const Data.Void.$fDataVoid_$cdataCast2_info;
 },
 Data.Void.$fDataVoid_$cdataCast2_entry() //  []
         { info_tbl: [(cfW2s,
                       label: Data.Void.$fDataVoid_$cdataCast2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW2s: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.329687336 UTC

[section ""data" . Data.Void.$w$cgmapMo_closure" {
     Data.Void.$w$cgmapMo_closure:
         const Data.Void.$w$cgmapMo_info;
 },
 lvl2_sfVVh_entry() //  [R1]
         { info_tbl: [(cfW2D,
                       label: lvl2_sfVVh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW2D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW2E; else goto cfW2F;
       cfW2E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfW2F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfVVp_entry() //  [R1, R2]
         { info_tbl: [(cfW2S,
                       label: sat_sfVVp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW2S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfW2T; else goto cfW2U;
       cfW2T: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfW2U: // global
           I64[Sp - 24] = block_cfW2P_info;
           _sfVVh::P64 = P64[R1 + 7];
           _sfVVi::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfVVh::P64;
           P64[Sp - 8] = _sfVVi::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufW3c; else goto cfW2Q;
       ufW3c: // global
           call _cfW2P(R1) args: 0, res: 0, upd: 0;
       cfW2Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW2P() //  [R1]
         { info_tbl: [(cfW2P,
                       label: block_cfW2P_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW2P: // global
           I64[Sp - 8] = block_cfW2X_info;
           _sfVVm::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfVVm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufW3b; else goto cfW2Z;
       ufW3b: // global
           call _cfW2X(R1) args: 0, res: 0, upd: 0;
       cfW2Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW2X() //  [R1]
         { info_tbl: [(cfW2X,
                       label: block_cfW2X_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW2X: // global
           if (R1 & 7 == 1) goto cfW35; else goto cfW39;
       cfW35: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfW39: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Void.$w$cgmapMo_entry() //  [R2, R3]
         { info_tbl: [(cfW3d,
                       label: Data.Void.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW3d: // global
           _sfVVg::P64 = R3;
           _sfVVf::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cfW3e; else goto cfW3f;
       cfW3f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfW3h; else goto cfW3g;
       cfW3h: // global
           HpAlloc = 24;
           goto cfW3e;
       cfW3e: // global
           R3 = _sfVVg::P64;
           R2 = _sfVVf::P64;
           R1 = Data.Void.$w$cgmapMo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfW3g: // global
           I64[Hp - 16] = lvl2_sfVVh_info;
           P64[Hp] = _sfVVf::P64;
           I64[Sp - 24] = block_cfW2G_info;
           R2 = _sfVVf::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _sfVVg::P64;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfW2G() //  [R1]
         { info_tbl: [(cfW2G,
                       label: block_cfW2G_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW2G: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfW3k; else goto cfW3j;
       cfW3k: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfW3j: // global
           I64[Hp - 16] = sat_sfVVp_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 15;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.331875228 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapMo_closure" {
     Data.Void.$fDataVoid_$cgmapMo_closure:
         const Data.Void.$fDataVoid_$cgmapMo_info;
 },
 Data.Void.$fDataVoid_$cgmapMo_entry() //  [R2, R4]
         { info_tbl: [(cfW3p,
                       label: Data.Void.$fDataVoid_$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW3p: // global
           R3 = R4;
           R2 = R2;
           call Data.Void.$w$cgmapMo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.332576492 UTC

[section ""data" . Data.Void.$fDataVoid_closure" {
     Data.Void.$fDataVoid_closure:
         const Data.Data.C:Data_con_info;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fDataVoid_$cgfoldl_closure+3;
         const Data.Void.$fDataVoid_$cgunfold_closure+3;
         const Data.Void.$fDataVoid_$ctoConstr_closure+1;
         const Data.Void.$fDataVoid_$cdataTypeOf_closure+1;
         const Data.Void.$fDataVoid_$cdataCast1_closure+2;
         const Data.Void.$fDataVoid_$cdataCast2_closure+2;
         const Data.Void.$fDataVoid2_closure+2;
         const Data.Void.$fDataVoid1_closure+4;
         const Data.Void.$fDataVoid_$cgmapQr_closure+4;
         const Data.Void.$fDataVoid_$cgmapQ_closure+2;
         const Data.Void.$fDataVoid_$cgmapQi_closure+3;
         const Data.Void.$fDataVoid_$cgmapM_closure+3;
         const Data.Void.$fDataVoid_$cgmapMp_closure+3;
         const Data.Void.$fDataVoid_$cgmapMo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.33369743 UTC

[section ""data" . Data.Void.$fExceptionVoid_$cfromException_closure" {
     Data.Void.$fExceptionVoid_$cfromException_closure:
         const Data.Void.$fExceptionVoid_$cfromException_info;
         const 0;
 },
 Data.Void.$fExceptionVoid_$cfromException_entry() //  [R2]
         { info_tbl: [(cfW3z,
                       label: Data.Void.$fExceptionVoid_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW3z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW3D; else goto cfW3E;
       cfW3D: // global
           R2 = R2;
           R1 = Data.Void.$fExceptionVoid_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfW3E: // global
           I64[Sp - 8] = block_cfW3w_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufW3Z; else goto cfW3x;
       ufW3Z: // global
           call _cfW3w(R1) args: 0, res: 0, upd: 0;
       cfW3x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW3w() //  [R1]
         { info_tbl: [(cfW3w,
                       label: block_cfW3w_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW3w: // global
           I64[Sp - 8] = block_cfW3C_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfW3C() //  [R1]
         { info_tbl: [(cfW3C,
                       label: block_cfW3C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW3C: // global
           I64[Sp] = block_cfW3J_info;
           R3 = Data.Void.$fDataVoid6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfW3J() //  [R1]
         { info_tbl: [(cfW3J,
                       label: block_cfW3J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW3J: // global
           if (R1 & 7 == 1) goto cfW3Q; else goto cfW3U;
       cfW3Q: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfW3U: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfW3X; else goto cfW3W;
       cfW3X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfW3W: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.335270115 UTC

[section ""data" . Data.Void.$fExceptionVoid_closure" {
     Data.Void.$fExceptionVoid_closure:
         const GHC.Exception.C:Exception_con_info;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fShowVoid_closure+1;
         const Data.Void.$fExceptionVoid_$ctoException_closure+1;
         const Data.Void.$fExceptionVoid_$cfromException_closure+1;
         const Data.Void.$fExceptionVoid_$cshow_closure+1;
         const 0;
 },
 section ""data" . Data.Void.$fExceptionVoid_$ctoException_closure" {
     Data.Void.$fExceptionVoid_$ctoException_closure:
         const Data.Void.$fExceptionVoid_$ctoException_info;
         const 0;
 },
 Data.Void.$fExceptionVoid_$ctoException_entry() //  [R2]
         { info_tbl: [(cfW45,
                       label: Data.Void.$fExceptionVoid_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW45: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfW49; else goto cfW48;
       cfW49: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Void.$fExceptionVoid_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfW48: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = Data.Void.$fExceptionVoid_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.336190251 UTC

[section ""relreadonly" . SfVVU_srt" {
     SfVVU_srt:
         const Data.Semigroup.Internal.stimesIdempotent_closure;
         const GHC.Read.list_closure;
         const Data.Void.$fReadVoid_$creadListPrec_closure;
         const Data.Void.$fReadVoid1_closure;
         const Control.Exception.Base.patError_closure;
         const Data.Data.$wlvl_closure;
         const Data.Void.$w$cgunfold_closure;
         const lvl1_rfVTf_closure;
         const Data.Void.$fDataVoid_$cgunfold_closure;
         const Data.Void.$tVoid_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fExceptionVoid_$cfromException_closure;
         const Data.Void.$fExceptionVoid_closure;
         const Data.Void.$fExceptionVoid_$ctoException_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.336847392 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:45.337525239 UTC

[section ""data" . Data.Void.$fIxVoid1_closure" {
     Data.Void.$fIxVoid1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.338198559 UTC

[section ""data" . Data.Void.$fIxVoid_$crangeSize_closure" {
     Data.Void.$fIxVoid_$crangeSize_closure:
         const Data.Void.$fIxVoid_$crangeSize_info;
 },
 Data.Void.$fIxVoid_$crangeSize_entry() //  []
         { info_tbl: [(cfW4e,
                       label: Data.Void.$fIxVoid_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW4e: // global
           R1 = Data.Void.$fIxVoid1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.339010106 UTC

[section ""data" . Data.Void.$fIxVoid_$crange_closure" {
     Data.Void.$fIxVoid_$crange_closure:
         const Data.Void.$fIxVoid_$crange_info;
 },
 Data.Void.$fIxVoid_$crange_entry() //  []
         { info_tbl: [(cfW4l,
                       label: Data.Void.$fIxVoid_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW4l: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.339879677 UTC

[section ""data" . Data.Void.$fSemigroupVoid_$cstimes_closure" {
     Data.Void.$fSemigroupVoid_$cstimes_closure:
         const Data.Void.$fSemigroupVoid_$cstimes_info;
         const 0;
 },
 Data.Void.$fSemigroupVoid_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(cfW4s,
                       label: Data.Void.$fSemigroupVoid_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW4s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotent_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.340782447 UTC

[section ""data" . Data.Void.$fOrdVoid_$c<>_closure" {
     Data.Void.$fOrdVoid_$c<>_closure:
         const Data.Void.$fOrdVoid_$c<>_info;
 },
 Data.Void.$fOrdVoid_$c<>_entry() //  [R2]
         { info_tbl: [(cfW4z,
                       label: Data.Void.$fOrdVoid_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW4z: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.341873693 UTC

[section ""data" . Data.Void.$fSemigroupVoid_$csconcat_closure" {
     Data.Void.$fSemigroupVoid_$csconcat_closure:
         const Data.Void.$fSemigroupVoid_$csconcat_info;
 },
 Data.Void.$fSemigroupVoid_$csconcat_entry() //  [R2]
         { info_tbl: [(cfW4J,
                       label: Data.Void.$fSemigroupVoid_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW4J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW4N; else goto cfW4O;
       cfW4N: // global
           R2 = R2;
           R1 = Data.Void.$fSemigroupVoid_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfW4O: // global
           I64[Sp - 8] = block_cfW4G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufW4W; else goto cfW4H;
       ufW4W: // global
           call _cfW4G(R1) args: 0, res: 0, upd: 0;
       cfW4H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW4G() //  [R1]
         { info_tbl: [(cfW4G,
                       label: block_cfW4G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW4G: // global
           I64[Sp - 8] = block_cfW4M_info;
           _sfVTo::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfVTo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufW4V; else goto cfW4Q;
       ufW4V: // global
           call _cfW4M() args: 0, res: 0, upd: 0;
       cfW4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW4M() //  []
         { info_tbl: [(cfW4M,
                       label: block_cfW4M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW4M: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.343070084 UTC

[section ""data" . Data.Void.$fSemigroupVoid_closure" {
     Data.Void.$fSemigroupVoid_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Void.$fOrdVoid_$c<>_closure+2;
         const Data.Void.$fSemigroupVoid_$csconcat_closure+1;
         const Data.Void.$fSemigroupVoid_$cstimes_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.343850591 UTC

[section ""data" . Data.Void.$fShowVoid_$cshowsPrec_closure" {
     Data.Void.$fShowVoid_$cshowsPrec_closure:
         const Data.Void.$fShowVoid_$cshowsPrec_info;
 },
 Data.Void.$fShowVoid_$cshowsPrec_entry() //  [R3]
         { info_tbl: [(cfW51,
                       label: Data.Void.$fShowVoid_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW51: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.344673243 UTC

[section ""data" . Data.Void.$fExceptionVoid_$cshow_closure" {
     Data.Void.$fExceptionVoid_$cshow_closure:
         const Data.Void.$fExceptionVoid_$cshow_info;
 },
 Data.Void.$fExceptionVoid_$cshow_entry() //  [R2]
         { info_tbl: [(cfW58,
                       label: Data.Void.$fExceptionVoid_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW58: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.345575309 UTC

[section ""data" . Data.Void.$fShowVoid1_closure" {
     Data.Void.$fShowVoid1_closure:
         const Data.Void.$fShowVoid1_info;
 },
 Data.Void.$fShowVoid1_entry() //  [R2]
         { info_tbl: [(cfW5f,
                       label: Data.Void.$fShowVoid1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW5f: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.34644799 UTC

[section ""data" . Data.Void.$fShowVoid_$cshowList_closure" {
     Data.Void.$fShowVoid_$cshowList_closure:
         const Data.Void.$fShowVoid_$cshowList_info;
 },
 Data.Void.$fShowVoid_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cfW5m,
                       label: Data.Void.$fShowVoid_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW5m: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Void.$fShowVoid1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.348461599 UTC

[section ""data" . Data.Void.$fShowVoid_closure" {
     Data.Void.$fShowVoid_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Void.$fShowVoid_$cshowsPrec_closure+2;
         const Data.Void.$fExceptionVoid_$cshow_closure+1;
         const Data.Void.$fShowVoid_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.34957559 UTC

[section ""data" . Data.Void.$fReadVoid2_closure" {
     Data.Void.$fReadVoid2_closure:
         const Data.Void.$fReadVoid2_info;
 },
 Data.Void.$fReadVoid2_entry() //  [R2]
         { info_tbl: [(cfW5t,
                       label: Data.Void.$fReadVoid2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW5t: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.350451688 UTC

[section ""data" . Data.Void.$fReadVoid_$creadsPrec_closure" {
     Data.Void.$fReadVoid_$creadsPrec_closure:
         const Data.Void.$fReadVoid_$creadsPrec_info;
 },
 Data.Void.$fReadVoid_$creadsPrec_entry() //  [R3]
         { info_tbl: [(cfW5A,
                       label: Data.Void.$fReadVoid_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW5A: // global
           R2 = R3;
           call Data.Void.$fReadVoid2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.351432093 UTC

[section ""data" . Data.Void.$fReadVoid_$creadListPrec_closure" {
     Data.Void.$fReadVoid_$creadListPrec_closure:
         const Data.Void.$fReadVoid_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fReadVoid_$creadListPrec_entry() //  [R1]
         { info_tbl: [(cfW5J,
                       label: Data.Void.$fReadVoid_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW5J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW5K; else goto cfW5L;
       cfW5K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfW5L: // global
           (_cfW5G::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfW5G::I64 == 0) goto cfW5I; else goto cfW5H;
       cfW5I: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfW5H: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfW5G::I64;
           R2 = Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.352522474 UTC

[section ""data" . Data.Void.$fReadVoid1_closure" {
     Data.Void.$fReadVoid1_closure:
         const Data.Void.$fReadVoid1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fReadVoid1_entry() //  [R1]
         { info_tbl: [(cfW5S,
                       label: Data.Void.$fReadVoid1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW5S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW5T; else goto cfW5U;
       cfW5T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfW5U: // global
           (_cfW5P::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfW5P::I64 == 0) goto cfW5R; else goto cfW5Q;
       cfW5R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfW5Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfW5P::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Void.$fReadVoid_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.353680387 UTC

[section ""data" . Data.Void.$fReadVoid_$creadList_closure" {
     Data.Void.$fReadVoid_$creadList_closure:
         const Data.Void.$fReadVoid_$creadList_info;
         const 0;
 },
 Data.Void.$fReadVoid_$creadList_entry() //  [R2]
         { info_tbl: [(cfW5Z,
                       label: Data.Void.$fReadVoid_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW5Z: // global
           R3 = R2;
           R2 = Data.Void.$fReadVoid1_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.354407667 UTC

[section ""data" . Data.Void.$fReadVoid_closure" {
     Data.Void.$fReadVoid_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Void.$fReadVoid_$creadsPrec_closure+2;
         const Data.Void.$fReadVoid_$creadList_closure+1;
         const Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
         const Data.Void.$fReadVoid_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.355076925 UTC

[section ""data" . Data.Void.$fOrdVoid_$ccompare_closure" {
     Data.Void.$fOrdVoid_$ccompare_closure:
         const Data.Void.$fOrdVoid_$ccompare_info;
 },
 Data.Void.$fOrdVoid_$ccompare_entry() //  []
         { info_tbl: [(cfW66,
                       label: Data.Void.$fOrdVoid_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW66: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.355826495 UTC

[section ""data" . Data.Void.$fGenericVoid_$cto_closure" {
     Data.Void.$fGenericVoid_$cto_closure:
         const Data.Void.$fGenericVoid_$cto_info;
 },
 Data.Void.$fGenericVoid_$cto_entry() //  [R2]
         { info_tbl: [(cfW6d,
                       label: Data.Void.$fGenericVoid_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW6d: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.356635222 UTC

[section ""data" . Data.Void.$fGenericVoid1_closure" {
     Data.Void.$fGenericVoid1_closure:
         const Data.Void.$fGenericVoid1_info;
 },
 Data.Void.$fGenericVoid1_entry() //  [R2]
         { info_tbl: [(cfW6k,
                       label: Data.Void.$fGenericVoid1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW6k: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.357401943 UTC

[section ""data" . Data.Void.$fGenericVoid_closure" {
     Data.Void.$fGenericVoid_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Void.$fGenericVoid1_closure+1;
         const Data.Void.$fGenericVoid_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.358105856 UTC

[section ""data" . Data.Void.$fDataVoid_$ctoConstr_closure" {
     Data.Void.$fDataVoid_$ctoConstr_closure:
         const Data.Void.$fDataVoid_$ctoConstr_info;
 },
 Data.Void.$fDataVoid_$ctoConstr_entry() //  [R2]
         { info_tbl: [(cfW6r,
                       label: Data.Void.$fDataVoid_$ctoConstr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW6r: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.358795638 UTC

[section ""cstring" . lvl_rfVTe_bytes" {
     lvl_rfVTe_bytes:
         I8[] [68,97,116,97,47,86,111,105,100,46,104,115,58,51,57,58,53,45,56,124,99,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.35954666 UTC

[section ""data" . lvl1_rfVTf_closure" {
     lvl1_rfVTf_closure:
         const lvl1_rfVTf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rfVTf_entry() //  [R1]
         { info_tbl: [(cfW6A,
                       label: lvl1_rfVTf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW6A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW6B; else goto cfW6C;
       cfW6B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfW6C: // global
           (_cfW6x::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfW6x::I64 == 0) goto cfW6z; else goto cfW6y;
       cfW6z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfW6y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfW6x::I64;
           R2 = lvl_rfVTe_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.360834222 UTC

[section ""data" . Data.Void.$w$cgunfold_closure" {
     Data.Void.$w$cgunfold_closure:
         const Data.Void.$w$cgunfold_info;
         const 0;
 },
 Data.Void.$w$cgunfold_entry() //  [R2, R3]
         { info_tbl: [(cfW6O,
                       label: Data.Void.$w$cgunfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW6O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW6P; else goto cfW6Q;
       cfW6P: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Void.$w$cgunfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfW6Q: // global
           I64[Sp - 16] = block_cfW6H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufW74; else goto cfW6I;
       ufW74: // global
           call _cfW6H(R1) args: 0, res: 0, upd: 0;
       cfW6I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW6H() //  [R1]
         { info_tbl: [(cfW6H,
                       label: block_cfW6H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW6H: // global
           if (R1 & 7 == 1) goto cfW6M; else goto cfW6L;
       cfW6M: // global
           I64[Sp + 8] = block_cfW6W_info;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufW73; else goto cfW6Y;
       ufW73: // global
           call _cfW6W() args: 0, res: 0, upd: 0;
       cfW6Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfW6L: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Data.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cfW6W() //  []
         { info_tbl: [(cfW6W,
                       label: block_cfW6W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW6W: // global
           R1 = lvl1_rfVTf_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.362426108 UTC

[section ""data" . Data.Void.$fDataVoid_$cgunfold_closure" {
     Data.Void.$fDataVoid_$cgunfold_closure:
         const Data.Void.$fDataVoid_$cgunfold_info;
         const 0;
 },
 Data.Void.$fDataVoid_$cgunfold_entry() //  [R2, R3, R4]
         { info_tbl: [(cfW7c,
                       label: Data.Void.$fDataVoid_$cgunfold_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW7c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW7g; else goto cfW7h;
       cfW7g: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Void.$fDataVoid_$cgunfold_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfW7h: // global
           I64[Sp - 8] = block_cfW79_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufW7p; else goto cfW7a;
       ufW7p: // global
           call _cfW79(R1) args: 0, res: 0, upd: 0;
       cfW7a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW79() //  [R1]
         { info_tbl: [(cfW79,
                       label: block_cfW79_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW79: // global
           I64[Sp - 8] = block_cfW7f_info;
           _sfVTU::P64 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           P64[Sp] = _sfVTU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufW7o; else goto cfW7j;
       ufW7o: // global
           call _cfW7f(R1) args: 0, res: 0, upd: 0;
       cfW7j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW7f() //  [R1]
         { info_tbl: [(cfW7f,
                       label: block_cfW7f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW7f: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Void.$w$cgunfold_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.363749255 UTC

[section ""data" . Data.Void.$fDataVoid_$cgfoldl_closure" {
     Data.Void.$fDataVoid_$cgfoldl_closure:
         const Data.Void.$fDataVoid_$cgfoldl_info;
 },
 Data.Void.$fDataVoid_$cgfoldl_entry() //  [R4]
         { info_tbl: [(cfW7u,
                       label: Data.Void.$fDataVoid_$cgfoldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW7u: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.364506977 UTC

[section ""data" . Data.Void.$fEqVoid_$c==_closure" {
     Data.Void.$fEqVoid_$c==_closure:
         const Data.Void.$fEqVoid_$c==_info;
 },
 Data.Void.$fEqVoid_$c==_entry() //  []
         { info_tbl: [(cfW7B,
                       label: Data.Void.$fEqVoid_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW7B: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.36537119 UTC

[section ""data" . Data.Void.$fEqVoid_$c/=_closure" {
     Data.Void.$fEqVoid_$c/=_closure:
         const Data.Void.$fEqVoid_$c/=_info;
 },
 Data.Void.$fEqVoid_$c/=_entry() //  []
         { info_tbl: [(cfW7I,
                       label: Data.Void.$fEqVoid_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW7I: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.36605848 UTC

[section ""data" . Data.Void.$fEqVoid_closure" {
     Data.Void.$fEqVoid_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fEqVoid_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.366722258 UTC

[section ""data" . Data.Void.$fOrdVoid_$c<_closure" {
     Data.Void.$fOrdVoid_$c<_closure:
         const Data.Void.$fOrdVoid_$c<_info;
 },
 Data.Void.$fOrdVoid_$c<_entry() //  []
         { info_tbl: [(cfW7P,
                       label: Data.Void.$fOrdVoid_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW7P: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.367531314 UTC

[section ""data" . Data.Void.$fOrdVoid_$cmax_closure" {
     Data.Void.$fOrdVoid_$cmax_closure:
         const Data.Void.$fOrdVoid_$cmax_info;
 },
 Data.Void.$fOrdVoid_$cmax_entry() //  [R3]
         { info_tbl: [(cfW7W,
                       label: Data.Void.$fOrdVoid_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW7W: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.36825449 UTC

[section ""data" . Data.Void.$fOrdVoid_closure" {
     Data.Void.$fOrdVoid_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Void.$fEqVoid_closure+1;
         const Data.Void.$fOrdVoid_$ccompare_closure+2;
         const Data.Void.$fOrdVoid_$c<_closure+2;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fOrdVoid_$c<_closure+2;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fOrdVoid_$cmax_closure+2;
         const Data.Void.$fOrdVoid_$c<>_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.368978786 UTC

[section ""data" . Data.Void.absurd_closure" {
     Data.Void.absurd_closure:
         const Data.Void.absurd_info;
 },
 Data.Void.absurd_entry() //  [R2]
         { info_tbl: [(cfW83,
                       label: Data.Void.absurd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW83: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.369985254 UTC

[section ""data" . Data.Void.vacuous_closure" {
     Data.Void.vacuous_closure:
         const Data.Void.vacuous_info;
 },
 Data.Void.vacuous_entry() //  [R2]
         { info_tbl: [(cfW8a,
                       label: Data.Void.vacuous_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW8a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW8b; else goto cfW8c;
       cfW8b: // global
           R2 = R2;
           R1 = Data.Void.vacuous_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfW8c: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Void.absurd_closure+1;
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.370918817 UTC

[section ""data" . Data.Void.$fIxVoid_$cindex_closure" {
     Data.Void.$fIxVoid_$cindex_closure:
         const Data.Void.$fIxVoid_$cindex_info;
 },
 Data.Void.$fIxVoid_$cindex_entry() //  [R3]
         { info_tbl: [(cfW8h,
                       label: Data.Void.$fIxVoid_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW8h: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.371720842 UTC

[section ""data" . Data.Void.$fIxVoid_$cinRange_closure" {
     Data.Void.$fIxVoid_$cinRange_closure:
         const Data.Void.$fIxVoid_$cinRange_info;
 },
 Data.Void.$fIxVoid_$cinRange_entry() //  [R3]
         { info_tbl: [(cfW8o,
                       label: Data.Void.$fIxVoid_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW8o: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.37265848 UTC

[section ""data" . Data.Void.$fIxVoid_$cunsafeRangeSize_closure" {
     Data.Void.$fIxVoid_$cunsafeRangeSize_closure:
         const Data.Void.$fIxVoid_$cunsafeRangeSize_info;
 },
 Data.Void.$fIxVoid_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(cfW8y,
                       label: Data.Void.$fIxVoid_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW8y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfW8z; else goto cfW8A;
       cfW8z: // global
           R2 = R2;
           R1 = Data.Void.$fIxVoid_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfW8A: // global
           I64[Sp - 8] = block_cfW8v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufW8E; else goto cfW8w;
       ufW8E: // global
           call _cfW8v(R1) args: 0, res: 0, upd: 0;
       cfW8w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW8v() //  [R1]
         { info_tbl: [(cfW8v,
                       label: block_cfW8v_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW8v: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.373733992 UTC

[section ""data" . Data.Void.$fIxVoid_closure" {
     Data.Void.$fIxVoid_closure:
         const GHC.Arr.C:Ix_con_info;
         const Data.Void.$fOrdVoid_closure+1;
         const Data.Void.$fIxVoid_$crange_closure+1;
         const Data.Void.$fIxVoid_$cindex_closure+2;
         const Data.Void.$fIxVoid_$cindex_closure+2;
         const Data.Void.$fIxVoid_$cinRange_closure+2;
         const Data.Void.$fIxVoid_$crangeSize_closure+1;
         const Data.Void.$fIxVoid_$cunsafeRangeSize_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.374339205 UTC

[section ""cstring" . Data.Void.$fDataVoid5_bytes" {
     Data.Void.$fDataVoid5_bytes:
         I8[] [86,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.375104486 UTC

[section ""data" . Data.Void.$fDataVoid4_closure" {
     Data.Void.$fDataVoid4_closure:
         const Data.Void.$fDataVoid4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fDataVoid4_entry() //  [R1]
         { info_tbl: [(cfW8L,
                       label: Data.Void.$fDataVoid4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW8L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW8M; else goto cfW8N;
       cfW8M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfW8N: // global
           (_cfW8I::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfW8I::I64 == 0) goto cfW8K; else goto cfW8J;
       cfW8K: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfW8J: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfW8I::I64;
           R2 = Data.Void.$fDataVoid5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.376004145 UTC

[section ""data" . Data.Void.$fDataVoid3_closure" {
     Data.Void.$fDataVoid3_closure:
         const Data.Data.AlgRep_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.37661806 UTC

[section ""data" . Data.Void.$tVoid_closure" {
     Data.Void.$tVoid_closure:
         const Data.Data.DataType_con_info;
         const Data.Void.$fDataVoid4_closure;
         const Data.Void.$fDataVoid3_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.377668122 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataTypeOf_closure" {
     Data.Void.$fDataVoid_$cdataTypeOf_closure:
         const Data.Void.$fDataVoid_$cdataTypeOf_info;
         const 0;
 },
 Data.Void.$fDataVoid_$cdataTypeOf_entry() //  []
         { info_tbl: [(cfW8S,
                       label: Data.Void.$fDataVoid_$cdataTypeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW8S: // global
           R1 = Data.Void.$tVoid_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.378424621 UTC

[section ""cstring" . Data.Void.$trModule4_bytes" {
     Data.Void.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.378994909 UTC

[section ""data" . Data.Void.$trModule3_closure" {
     Data.Void.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.379611035 UTC

[section ""cstring" . Data.Void.$trModule2_bytes" {
     Data.Void.$trModule2_bytes:
         I8[] [68,97,116,97,46,86,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.380174527 UTC

[section ""data" . Data.Void.$trModule1_closure" {
     Data.Void.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.380773656 UTC

[section ""data" . Data.Void.$trModule_closure" {
     Data.Void.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Void.$trModule3_closure+1;
         const Data.Void.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.381397501 UTC

[section ""data" . Data.Void.$fDataVoid7_closure" {
     Data.Void.$fDataVoid7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$fDataVoid5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.382012324 UTC

[section ""data" . Data.Void.$tcVoid_closure" {
     Data.Void.$tcVoid_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Void.$trModule_closure+1;
         const Data.Void.$fDataVoid7_closure+1;
         const GHC.Types.krep$*_closure;
         const 1716938828100304260;
         const 9065598981067935587;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.38315418 UTC

[section ""data" . Data.Void.$fDataVoid6_closure" {
     Data.Void.$fDataVoid6_closure:
         const Data.Void.$fDataVoid6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fDataVoid6_entry() //  [R1]
         { info_tbl: [(cfW96,
                       label: Data.Void.$fDataVoid6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW96: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cfW97; else goto cfW98;
       cfW97: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfW98: // global
           (_cfW8Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfW8Y::I64 == 0) goto cfW90; else goto cfW8Z;
       cfW90: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfW8Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfW8Y::I64;
           I64[Sp - 24] = block_cfW91_info;
           R6 = 0;
           R5 = Data.Void.$fDataVoid7_closure+1;
           R4 = Data.Void.$trModule_closure+1;
           R3 = 9065598981067935587;
           R2 = 1716938828100304260;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cfW91() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfW91,
                       label: block_cfW91_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW91: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cfW92() args: 0, res: 0, upd: 0;
     }
 },
 _cfW92() //  []
         { info_tbl: [(cfW92,
                       label: block_cfW92_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW92: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfW9b; else goto cfW9a;
       cfW9b: // global
           HpAlloc = 48;
           I64[Sp] = block_cfW92_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cfW9a: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.384761248 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataCast1_closure" {
     Data.Void.$fDataVoid_$cdataCast1_closure:
         const Data.Void.$fDataVoid_$cdataCast1_info;
 },
 Data.Void.$fDataVoid_$cdataCast1_entry() //  []
         { info_tbl: [(cfW9i,
                       label: Data.Void.$fDataVoid_$cdataCast1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW9i: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.387401703 UTC

[section ""data" . Data.Void.$w$cgmapMp_closure" {
     Data.Void.$w$cgmapMp_closure:
         const Data.Void.$w$cgmapMp_info;
 },
 lvl2_sfVUD_entry() //  [R1]
         { info_tbl: [(cfW9t,
                       label: lvl2_sfVUD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW9t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfW9u; else goto cfW9v;
       cfW9u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfW9v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfVUL_entry() //  [R1, R2]
         { info_tbl: [(cfW9I,
                       label: sat_sfVUL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW9I: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfW9J; else goto cfW9K;
       cfW9J: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfW9K: // global
           I64[Sp - 24] = block_cfW9F_info;
           _sfVUD::P64 = P64[R1 + 7];
           _sfVUE::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfVUD::P64;
           P64[Sp - 8] = _sfVUE::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufWa2; else goto cfW9G;
       ufWa2: // global
           call _cfW9F(R1) args: 0, res: 0, upd: 0;
       cfW9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW9F() //  [R1]
         { info_tbl: [(cfW9F,
                       label: block_cfW9F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW9F: // global
           I64[Sp - 8] = block_cfW9N_info;
           _sfVUI::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfVUI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWa1; else goto cfW9P;
       ufWa1: // global
           call _cfW9N(R1) args: 0, res: 0, upd: 0;
       cfW9P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfW9N() //  [R1]
         { info_tbl: [(cfW9N,
                       label: block_cfW9N_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW9N: // global
           if (R1 & 7 == 1) goto cfW9V; else goto cfW9Z;
       cfW9V: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfW9Z: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Void.$w$cgmapMp_entry() //  [R2, R3]
         { info_tbl: [(cfWa3,
                       label: Data.Void.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWa3: // global
           _sfVUC::P64 = R3;
           _sfVUB::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cfWa4; else goto cfWa5;
       cfWa5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWa7; else goto cfWa6;
       cfWa7: // global
           HpAlloc = 24;
           goto cfWa4;
       cfWa4: // global
           R3 = _sfVUC::P64;
           R2 = _sfVUB::P64;
           R1 = Data.Void.$w$cgmapMp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfWa6: // global
           I64[Hp - 16] = lvl2_sfVUD_info;
           P64[Hp] = _sfVUB::P64;
           I64[Sp - 24] = block_cfW9w_info;
           R2 = _sfVUB::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _sfVUC::P64;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfW9w() //  [R1]
         { info_tbl: [(cfW9w,
                       label: block_cfW9w_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfW9w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWaa; else goto cfWa9;
       cfWaa: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfWa9: // global
           I64[Hp - 16] = sat_sfVUL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 15;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.390584045 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapMp_closure" {
     Data.Void.$fDataVoid_$cgmapMp_closure:
         const Data.Void.$fDataVoid_$cgmapMp_info;
 },
 Data.Void.$fDataVoid_$cgmapMp_entry() //  [R2, R4]
         { info_tbl: [(cfWaf,
                       label: Data.Void.$fDataVoid_$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWaf: // global
           R3 = R4;
           R2 = R2;
           call Data.Void.$w$cgmapMp_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.391430321 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapM_closure" {
     Data.Void.$fDataVoid_$cgmapM_closure:
         const Data.Void.$fDataVoid_$cgmapM_info;
 },
 Data.Void.$fDataVoid_$cgmapM_entry() //  [R4]
         { info_tbl: [(cfWam,
                       label: Data.Void.$fDataVoid_$cgmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWam: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.392275736 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQi_closure" {
     Data.Void.$fDataVoid_$cgmapQi_closure:
         const Data.Void.$fDataVoid_$cgmapQi_info;
 },
 Data.Void.$fDataVoid_$cgmapQi_entry() //  [R4]
         { info_tbl: [(cfWat,
                       label: Data.Void.$fDataVoid_$cgmapQi_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWat: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.393104714 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQr_closure" {
     Data.Void.$fDataVoid_$cgmapQr_closure:
         const Data.Void.$fDataVoid_$cgmapQr_info;
 },
 Data.Void.$fDataVoid_$cgmapQr_entry() //  [R5]
         { info_tbl: [(cfWaA,
                       label: Data.Void.$fDataVoid_$cgmapQr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWaA: // global
           R1 = R5 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.395283757 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQ_closure" {
     Data.Void.$fDataVoid_$cgmapQ_closure:
         const Data.Void.$fDataVoid_$cgmapQ_info;
 },
 Data.Void.$fDataVoid_$cgmapQ_entry() //  [R3]
         { info_tbl: [(cfWaH,
                       label: Data.Void.$fDataVoid_$cgmapQ_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWaH: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.396154878 UTC

[section ""data" . Data.Void.$fDataVoid1_closure" {
     Data.Void.$fDataVoid1_closure:
         const Data.Void.$fDataVoid1_info;
 },
 Data.Void.$fDataVoid1_entry() //  [R5]
         { info_tbl: [(cfWaO,
                       label: Data.Void.$fDataVoid1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWaO: // global
           R1 = R5 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.397043746 UTC

[section ""data" . Data.Void.$fDataVoid2_closure" {
     Data.Void.$fDataVoid2_closure:
         const Data.Void.$fDataVoid2_info;
 },
 Data.Void.$fDataVoid2_entry() //  [R3]
         { info_tbl: [(cfWaV,
                       label: Data.Void.$fDataVoid2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWaV: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.397867197 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataCast2_closure" {
     Data.Void.$fDataVoid_$cdataCast2_closure:
         const Data.Void.$fDataVoid_$cdataCast2_info;
 },
 Data.Void.$fDataVoid_$cdataCast2_entry() //  []
         { info_tbl: [(cfWb2,
                       label: Data.Void.$fDataVoid_$cdataCast2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWb2: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.399459839 UTC

[section ""data" . Data.Void.$w$cgmapMo_closure" {
     Data.Void.$w$cgmapMo_closure:
         const Data.Void.$w$cgmapMo_info;
 },
 lvl2_sfVVh_entry() //  [R1]
         { info_tbl: [(cfWbd,
                       label: lvl2_sfVVh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWbd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWbe; else goto cfWbf;
       cfWbe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWbf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfVVp_entry() //  [R1, R2]
         { info_tbl: [(cfWbs,
                       label: sat_sfVVp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWbs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfWbt; else goto cfWbu;
       cfWbt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWbu: // global
           I64[Sp - 24] = block_cfWbp_info;
           _sfVVh::P64 = P64[R1 + 7];
           _sfVVi::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfVVh::P64;
           P64[Sp - 8] = _sfVVi::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufWbM; else goto cfWbq;
       ufWbM: // global
           call _cfWbp(R1) args: 0, res: 0, upd: 0;
       cfWbq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWbp() //  [R1]
         { info_tbl: [(cfWbp,
                       label: block_cfWbp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWbp: // global
           I64[Sp - 8] = block_cfWbx_info;
           _sfVVm::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfVVm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWbL; else goto cfWbz;
       ufWbL: // global
           call _cfWbx(R1) args: 0, res: 0, upd: 0;
       cfWbz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWbx() //  [R1]
         { info_tbl: [(cfWbx,
                       label: block_cfWbx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWbx: // global
           if (R1 & 7 == 1) goto cfWbF; else goto cfWbJ;
       cfWbF: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfWbJ: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Void.$w$cgmapMo_entry() //  [R2, R3]
         { info_tbl: [(cfWbN,
                       label: Data.Void.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWbN: // global
           _sfVVg::P64 = R3;
           _sfVVf::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cfWbO; else goto cfWbP;
       cfWbP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWbR; else goto cfWbQ;
       cfWbR: // global
           HpAlloc = 24;
           goto cfWbO;
       cfWbO: // global
           R3 = _sfVVg::P64;
           R2 = _sfVVf::P64;
           R1 = Data.Void.$w$cgmapMo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfWbQ: // global
           I64[Hp - 16] = lvl2_sfVVh_info;
           P64[Hp] = _sfVVf::P64;
           I64[Sp - 24] = block_cfWbg_info;
           R2 = _sfVVf::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _sfVVg::P64;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWbg() //  [R1]
         { info_tbl: [(cfWbg,
                       label: block_cfWbg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWbg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWbU; else goto cfWbT;
       cfWbU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfWbT: // global
           I64[Hp - 16] = sat_sfVVp_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 15;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.401820153 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapMo_closure" {
     Data.Void.$fDataVoid_$cgmapMo_closure:
         const Data.Void.$fDataVoid_$cgmapMo_info;
 },
 Data.Void.$fDataVoid_$cgmapMo_entry() //  [R2, R4]
         { info_tbl: [(cfWbZ,
                       label: Data.Void.$fDataVoid_$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWbZ: // global
           R3 = R4;
           R2 = R2;
           call Data.Void.$w$cgmapMo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.402601453 UTC

[section ""data" . Data.Void.$fDataVoid_closure" {
     Data.Void.$fDataVoid_closure:
         const Data.Data.C:Data_con_info;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fDataVoid_$cgfoldl_closure+3;
         const Data.Void.$fDataVoid_$cgunfold_closure+3;
         const Data.Void.$fDataVoid_$ctoConstr_closure+1;
         const Data.Void.$fDataVoid_$cdataTypeOf_closure+1;
         const Data.Void.$fDataVoid_$cdataCast1_closure+2;
         const Data.Void.$fDataVoid_$cdataCast2_closure+2;
         const Data.Void.$fDataVoid2_closure+2;
         const Data.Void.$fDataVoid1_closure+4;
         const Data.Void.$fDataVoid_$cgmapQr_closure+4;
         const Data.Void.$fDataVoid_$cgmapQ_closure+2;
         const Data.Void.$fDataVoid_$cgmapQi_closure+3;
         const Data.Void.$fDataVoid_$cgmapM_closure+3;
         const Data.Void.$fDataVoid_$cgmapMp_closure+3;
         const Data.Void.$fDataVoid_$cgmapMo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.403656455 UTC

[section ""data" . Data.Void.$fExceptionVoid_$cfromException_closure" {
     Data.Void.$fExceptionVoid_$cfromException_closure:
         const Data.Void.$fExceptionVoid_$cfromException_info;
         const 0;
 },
 Data.Void.$fExceptionVoid_$cfromException_entry() //  [R2]
         { info_tbl: [(cfWc9,
                       label: Data.Void.$fExceptionVoid_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWc9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWcd; else goto cfWce;
       cfWcd: // global
           R2 = R2;
           R1 = Data.Void.$fExceptionVoid_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWce: // global
           I64[Sp - 8] = block_cfWc6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWcz; else goto cfWc7;
       ufWcz: // global
           call _cfWc6(R1) args: 0, res: 0, upd: 0;
       cfWc7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWc6() //  [R1]
         { info_tbl: [(cfWc6,
                       label: block_cfWc6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWc6: // global
           I64[Sp - 8] = block_cfWcc_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWcc() //  [R1]
         { info_tbl: [(cfWcc,
                       label: block_cfWcc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWcc: // global
           I64[Sp] = block_cfWcj_info;
           R3 = Data.Void.$fDataVoid6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWcj() //  [R1]
         { info_tbl: [(cfWcj,
                       label: block_cfWcj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWcj: // global
           if (R1 & 7 == 1) goto cfWcq; else goto cfWcu;
       cfWcq: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfWcu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfWcx; else goto cfWcw;
       cfWcx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfWcw: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.405291669 UTC

[section ""data" . Data.Void.$fExceptionVoid_closure" {
     Data.Void.$fExceptionVoid_closure:
         const GHC.Exception.C:Exception_con_info;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fShowVoid_closure+1;
         const Data.Void.$fExceptionVoid_$ctoException_closure+1;
         const Data.Void.$fExceptionVoid_$cfromException_closure+1;
         const Data.Void.$fExceptionVoid_$cshow_closure+1;
         const 0;
 },
 section ""data" . Data.Void.$fExceptionVoid_$ctoException_closure" {
     Data.Void.$fExceptionVoid_$ctoException_closure:
         const Data.Void.$fExceptionVoid_$ctoException_info;
         const 0;
 },
 Data.Void.$fExceptionVoid_$ctoException_entry() //  [R2]
         { info_tbl: [(cfWcF,
                       label: Data.Void.$fExceptionVoid_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWcF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWcJ; else goto cfWcI;
       cfWcJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Void.$fExceptionVoid_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWcI: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = Data.Void.$fExceptionVoid_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.40617954 UTC

[section ""relreadonly" . SfVVU_srt" {
     SfVVU_srt:
         const Data.Semigroup.Internal.stimesIdempotent_closure;
         const GHC.Read.list_closure;
         const Data.Void.$fReadVoid_$creadListPrec_closure;
         const Data.Void.$fReadVoid1_closure;
         const Control.Exception.Base.patError_closure;
         const Data.Data.$wlvl_closure;
         const Data.Void.$w$cgunfold_closure;
         const lvl1_rfVTf_closure;
         const Data.Void.$fDataVoid_$cgunfold_closure;
         const Data.Void.$tVoid_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fExceptionVoid_$cfromException_closure;
         const Data.Void.$fExceptionVoid_closure;
         const Data.Void.$fExceptionVoid_$ctoException_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.407056306 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:45.40822498 UTC

[section ""data" . Data.Void.$fIxVoid1_closure" {
     Data.Void.$fIxVoid1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.410180558 UTC

[section ""data" . Data.Void.$fIxVoid_$crangeSize_closure" {
     Data.Void.$fIxVoid_$crangeSize_closure:
         const Data.Void.$fIxVoid_$crangeSize_info;
 },
 Data.Void.$fIxVoid_$crangeSize_entry() //  []
         { info_tbl: [(cfWcP,
                       label: Data.Void.$fIxVoid_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWcP: // global
           R1 = Data.Void.$fIxVoid1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.413629813 UTC

[section ""data" . Data.Void.$fIxVoid_$crange_closure" {
     Data.Void.$fIxVoid_$crange_closure:
         const Data.Void.$fIxVoid_$crange_info;
 },
 Data.Void.$fIxVoid_$crange_entry() //  []
         { info_tbl: [(cfWd1,
                       label: Data.Void.$fIxVoid_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWd1: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.41699216 UTC

[section ""data" . Data.Void.$fSemigroupVoid_$cstimes_closure" {
     Data.Void.$fSemigroupVoid_$cstimes_closure:
         const Data.Void.$fSemigroupVoid_$cstimes_info;
         const 0;
 },
 Data.Void.$fSemigroupVoid_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(cfWdd,
                       label: Data.Void.$fSemigroupVoid_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWdd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotent_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.420550249 UTC

[section ""data" . Data.Void.$fOrdVoid_$c<>_closure" {
     Data.Void.$fOrdVoid_$c<>_closure:
         const Data.Void.$fOrdVoid_$c<>_info;
 },
 Data.Void.$fOrdVoid_$c<>_entry() //  [R2]
         { info_tbl: [(cfWdo,
                       label: Data.Void.$fOrdVoid_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWdo: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.424567031 UTC

[section ""data" . Data.Void.$fSemigroupVoid_$csconcat_closure" {
     Data.Void.$fSemigroupVoid_$csconcat_closure:
         const Data.Void.$fSemigroupVoid_$csconcat_info;
 },
 Data.Void.$fSemigroupVoid_$csconcat_entry() //  [R2]
         { info_tbl: [(cfWdE,
                       label: Data.Void.$fSemigroupVoid_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWdE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWdI; else goto cfWdJ;
       cfWdI: // global
           R2 = R2;
           R1 = Data.Void.$fSemigroupVoid_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWdJ: // global
           I64[Sp - 8] = block_cfWdB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWdR; else goto cfWdC;
       ufWdR: // global
           call _cfWdB(R1) args: 0, res: 0, upd: 0;
       cfWdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWdB() //  [R1]
         { info_tbl: [(cfWdB,
                       label: block_cfWdB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWdB: // global
           I64[Sp - 8] = block_cfWdH_info;
           _sfVTo::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfVTo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWdQ; else goto cfWdL;
       ufWdQ: // global
           call _cfWdH() args: 0, res: 0, upd: 0;
       cfWdL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWdH() //  []
         { info_tbl: [(cfWdH,
                       label: block_cfWdH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWdH: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.432881447 UTC

[section ""data" . Data.Void.$fSemigroupVoid_closure" {
     Data.Void.$fSemigroupVoid_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Void.$fOrdVoid_$c<>_closure+2;
         const Data.Void.$fSemigroupVoid_$csconcat_closure+1;
         const Data.Void.$fSemigroupVoid_$cstimes_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.435070275 UTC

[section ""data" . Data.Void.$fShowVoid_$cshowsPrec_closure" {
     Data.Void.$fShowVoid_$cshowsPrec_closure:
         const Data.Void.$fShowVoid_$cshowsPrec_info;
 },
 Data.Void.$fShowVoid_$cshowsPrec_entry() //  [R3]
         { info_tbl: [(cfWec,
                       label: Data.Void.$fShowVoid_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWec: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.438447338 UTC

[section ""data" . Data.Void.$fExceptionVoid_$cshow_closure" {
     Data.Void.$fExceptionVoid_$cshow_closure:
         const Data.Void.$fExceptionVoid_$cshow_info;
 },
 Data.Void.$fExceptionVoid_$cshow_entry() //  [R2]
         { info_tbl: [(cfWep,
                       label: Data.Void.$fExceptionVoid_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWep: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.441789353 UTC

[section ""data" . Data.Void.$fShowVoid1_closure" {
     Data.Void.$fShowVoid1_closure:
         const Data.Void.$fShowVoid1_info;
 },
 Data.Void.$fShowVoid1_entry() //  [R2]
         { info_tbl: [(cfWeC,
                       label: Data.Void.$fShowVoid1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWeC: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.445035589 UTC

[section ""data" . Data.Void.$fShowVoid_$cshowList_closure" {
     Data.Void.$fShowVoid_$cshowList_closure:
         const Data.Void.$fShowVoid_$cshowList_info;
 },
 Data.Void.$fShowVoid_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cfWeP,
                       label: Data.Void.$fShowVoid_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWeP: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Void.$fShowVoid1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.448665965 UTC

[section ""data" . Data.Void.$fShowVoid_closure" {
     Data.Void.$fShowVoid_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Void.$fShowVoid_$cshowsPrec_closure+2;
         const Data.Void.$fExceptionVoid_$cshow_closure+1;
         const Data.Void.$fShowVoid_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.450620002 UTC

[section ""data" . Data.Void.$fReadVoid2_closure" {
     Data.Void.$fReadVoid2_closure:
         const Data.Void.$fReadVoid2_info;
 },
 Data.Void.$fReadVoid2_entry() //  [R2]
         { info_tbl: [(cfWf1,
                       label: Data.Void.$fReadVoid2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWf1: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.453962283 UTC

[section ""data" . Data.Void.$fReadVoid_$creadsPrec_closure" {
     Data.Void.$fReadVoid_$creadsPrec_closure:
         const Data.Void.$fReadVoid_$creadsPrec_info;
 },
 Data.Void.$fReadVoid_$creadsPrec_entry() //  [R3]
         { info_tbl: [(cfWfc,
                       label: Data.Void.$fReadVoid_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWfc: // global
           R2 = R3;
           call Data.Void.$fReadVoid2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.458011446 UTC

[section ""data" . Data.Void.$fReadVoid_$creadListPrec_closure" {
     Data.Void.$fReadVoid_$creadListPrec_closure:
         const Data.Void.$fReadVoid_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fReadVoid_$creadListPrec_entry() //  [R1]
         { info_tbl: [(cfWfp,
                       label: Data.Void.$fReadVoid_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWfp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWfq; else goto cfWfr;
       cfWfq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWfr: // global
           (_cfWfm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfWfm::I64 == 0) goto cfWfo; else goto cfWfn;
       cfWfo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfWfn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfWfm::I64;
           R2 = Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.463011242 UTC

[section ""data" . Data.Void.$fReadVoid1_closure" {
     Data.Void.$fReadVoid1_closure:
         const Data.Void.$fReadVoid1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fReadVoid1_entry() //  [R1]
         { info_tbl: [(cfWfF,
                       label: Data.Void.$fReadVoid1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWfF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWfG; else goto cfWfH;
       cfWfG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWfH: // global
           (_cfWfC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfWfC::I64 == 0) goto cfWfE; else goto cfWfD;
       cfWfE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfWfD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfWfC::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Void.$fReadVoid_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.467026272 UTC

[section ""data" . Data.Void.$fReadVoid_$creadList_closure" {
     Data.Void.$fReadVoid_$creadList_closure:
         const Data.Void.$fReadVoid_$creadList_info;
         const 0;
 },
 Data.Void.$fReadVoid_$creadList_entry() //  [R2]
         { info_tbl: [(cfWfT,
                       label: Data.Void.$fReadVoid_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWfT: // global
           R3 = R2;
           R2 = Data.Void.$fReadVoid1_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.470486335 UTC

[section ""data" . Data.Void.$fReadVoid_closure" {
     Data.Void.$fReadVoid_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Void.$fReadVoid_$creadsPrec_closure+2;
         const Data.Void.$fReadVoid_$creadList_closure+1;
         const Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
         const Data.Void.$fReadVoid_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.472397752 UTC

[section ""data" . Data.Void.$fOrdVoid_$ccompare_closure" {
     Data.Void.$fOrdVoid_$ccompare_closure:
         const Data.Void.$fOrdVoid_$ccompare_info;
 },
 Data.Void.$fOrdVoid_$ccompare_entry() //  []
         { info_tbl: [(cfWg5,
                       label: Data.Void.$fOrdVoid_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWg5: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.475902174 UTC

[section ""data" . Data.Void.$fGenericVoid_$cto_closure" {
     Data.Void.$fGenericVoid_$cto_closure:
         const Data.Void.$fGenericVoid_$cto_info;
 },
 Data.Void.$fGenericVoid_$cto_entry() //  [R2]
         { info_tbl: [(cfWgh,
                       label: Data.Void.$fGenericVoid_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWgh: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.47920701 UTC

[section ""data" . Data.Void.$fGenericVoid1_closure" {
     Data.Void.$fGenericVoid1_closure:
         const Data.Void.$fGenericVoid1_info;
 },
 Data.Void.$fGenericVoid1_entry() //  [R2]
         { info_tbl: [(cfWgs,
                       label: Data.Void.$fGenericVoid1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWgs: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.482953396 UTC

[section ""data" . Data.Void.$fGenericVoid_closure" {
     Data.Void.$fGenericVoid_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Void.$fGenericVoid1_closure+1;
         const Data.Void.$fGenericVoid_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.484841004 UTC

[section ""data" . Data.Void.$fDataVoid_$ctoConstr_closure" {
     Data.Void.$fDataVoid_$ctoConstr_closure:
         const Data.Void.$fDataVoid_$ctoConstr_info;
 },
 Data.Void.$fDataVoid_$ctoConstr_entry() //  [R2]
         { info_tbl: [(cfWgG,
                       label: Data.Void.$fDataVoid_$ctoConstr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWgG: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.488087831 UTC

[section ""cstring" . lvl_rfVTe_bytes" {
     lvl_rfVTe_bytes:
         I8[] [68,97,116,97,47,86,111,105,100,46,104,115,58,51,57,58,53,45,56,124,99,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.490633569 UTC

[section ""data" . lvl1_rfVTf_closure" {
     lvl1_rfVTf_closure:
         const lvl1_rfVTf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rfVTf_entry() //  [R1]
         { info_tbl: [(cfWgW,
                       label: lvl1_rfVTf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWgW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWgX; else goto cfWgY;
       cfWgX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWgY: // global
           (_cfWgT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfWgT::I64 == 0) goto cfWgV; else goto cfWgU;
       cfWgV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfWgU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfWgT::I64;
           R2 = lvl_rfVTe_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.495351954 UTC

[section ""data" . Data.Void.$w$cgunfold_closure" {
     Data.Void.$w$cgunfold_closure:
         const Data.Void.$w$cgunfold_info;
         const 0;
 },
 Data.Void.$w$cgunfold_entry() //  [R2, R3]
         { info_tbl: [(cfWhh,
                       label: Data.Void.$w$cgunfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWhh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWhi; else goto cfWhj;
       cfWhi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Void.$w$cgunfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfWhj: // global
           I64[Sp - 16] = block_cfWha_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufWhx; else goto cfWhb;
       ufWhx: // global
           call _cfWha(R1) args: 0, res: 0, upd: 0;
       cfWhb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWha() //  [R1]
         { info_tbl: [(cfWha,
                       label: block_cfWha_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWha: // global
           if (R1 & 7 == 1) goto cfWhf; else goto cfWhe;
       cfWhf: // global
           I64[Sp + 8] = block_cfWhp_info;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufWhw; else goto cfWhr;
       ufWhw: // global
           call _cfWhp() args: 0, res: 0, upd: 0;
       cfWhr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfWhe: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Data.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cfWhp() //  []
         { info_tbl: [(cfWhp,
                       label: block_cfWhp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWhp: // global
           R1 = lvl1_rfVTf_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.502889412 UTC

[section ""data" . Data.Void.$fDataVoid_$cgunfold_closure" {
     Data.Void.$fDataVoid_$cgunfold_closure:
         const Data.Void.$fDataVoid_$cgunfold_info;
         const 0;
 },
 Data.Void.$fDataVoid_$cgunfold_entry() //  [R2, R3, R4]
         { info_tbl: [(cfWhU,
                       label: Data.Void.$fDataVoid_$cgunfold_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWhU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWhY; else goto cfWhZ;
       cfWhY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Void.$fDataVoid_$cgunfold_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfWhZ: // global
           I64[Sp - 8] = block_cfWhR_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWi7; else goto cfWhS;
       ufWi7: // global
           call _cfWhR(R1) args: 0, res: 0, upd: 0;
       cfWhS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWhR() //  [R1]
         { info_tbl: [(cfWhR,
                       label: block_cfWhR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWhR: // global
           I64[Sp - 8] = block_cfWhX_info;
           _sfVTU::P64 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           P64[Sp] = _sfVTU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWi6; else goto cfWi1;
       ufWi6: // global
           call _cfWhX(R1) args: 0, res: 0, upd: 0;
       cfWi1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWhX() //  [R1]
         { info_tbl: [(cfWhX,
                       label: block_cfWhX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWhX: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Void.$w$cgunfold_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.510162973 UTC

[section ""data" . Data.Void.$fDataVoid_$cgfoldl_closure" {
     Data.Void.$fDataVoid_$cgfoldl_closure:
         const Data.Void.$fDataVoid_$cgfoldl_info;
 },
 Data.Void.$fDataVoid_$cgfoldl_entry() //  [R4]
         { info_tbl: [(cfWip,
                       label: Data.Void.$fDataVoid_$cgfoldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWip: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.514485472 UTC

[section ""data" . Data.Void.$fEqVoid_$c==_closure" {
     Data.Void.$fEqVoid_$c==_closure:
         const Data.Void.$fEqVoid_$c==_info;
 },
 Data.Void.$fEqVoid_$c==_entry() //  []
         { info_tbl: [(cfWiC,
                       label: Data.Void.$fEqVoid_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWiC: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.517965454 UTC

[section ""data" . Data.Void.$fEqVoid_$c/=_closure" {
     Data.Void.$fEqVoid_$c/=_closure:
         const Data.Void.$fEqVoid_$c/=_info;
 },
 Data.Void.$fEqVoid_$c/=_entry() //  []
         { info_tbl: [(cfWiO,
                       label: Data.Void.$fEqVoid_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWiO: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.521548319 UTC

[section ""data" . Data.Void.$fEqVoid_closure" {
     Data.Void.$fEqVoid_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fEqVoid_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.524530588 UTC

[section ""data" . Data.Void.$fOrdVoid_$c<_closure" {
     Data.Void.$fOrdVoid_$c<_closure:
         const Data.Void.$fOrdVoid_$c<_info;
 },
 Data.Void.$fOrdVoid_$c<_entry() //  []
         { info_tbl: [(cfWj1,
                       label: Data.Void.$fOrdVoid_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWj1: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.528475382 UTC

[section ""data" . Data.Void.$fOrdVoid_$cmax_closure" {
     Data.Void.$fOrdVoid_$cmax_closure:
         const Data.Void.$fOrdVoid_$cmax_info;
 },
 Data.Void.$fOrdVoid_$cmax_entry() //  [R3]
         { info_tbl: [(cfWjd,
                       label: Data.Void.$fOrdVoid_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWjd: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.532365534 UTC

[section ""data" . Data.Void.$fOrdVoid_closure" {
     Data.Void.$fOrdVoid_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Void.$fEqVoid_closure+1;
         const Data.Void.$fOrdVoid_$ccompare_closure+2;
         const Data.Void.$fOrdVoid_$c<_closure+2;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fOrdVoid_$c<_closure+2;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fOrdVoid_$cmax_closure+2;
         const Data.Void.$fOrdVoid_$c<>_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.534567344 UTC

[section ""data" . Data.Void.absurd_closure" {
     Data.Void.absurd_closure:
         const Data.Void.absurd_info;
 },
 Data.Void.absurd_entry() //  [R2]
         { info_tbl: [(cfWjr,
                       label: Data.Void.absurd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWjr: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.538803363 UTC

[section ""data" . Data.Void.vacuous_closure" {
     Data.Void.vacuous_closure:
         const Data.Void.vacuous_info;
 },
 Data.Void.vacuous_entry() //  [R2]
         { info_tbl: [(cfWjE,
                       label: Data.Void.vacuous_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWjE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWjF; else goto cfWjG;
       cfWjF: // global
           R2 = R2;
           R1 = Data.Void.vacuous_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWjG: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Void.absurd_closure+1;
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.543563034 UTC

[section ""data" . Data.Void.$fIxVoid_$cindex_closure" {
     Data.Void.$fIxVoid_$cindex_closure:
         const Data.Void.$fIxVoid_$cindex_info;
 },
 Data.Void.$fIxVoid_$cindex_entry() //  [R3]
         { info_tbl: [(cfWjQ,
                       label: Data.Void.$fIxVoid_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWjQ: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.547307838 UTC

[section ""data" . Data.Void.$fIxVoid_$cinRange_closure" {
     Data.Void.$fIxVoid_$cinRange_closure:
         const Data.Void.$fIxVoid_$cinRange_info;
 },
 Data.Void.$fIxVoid_$cinRange_entry() //  [R3]
         { info_tbl: [(cfWk3,
                       label: Data.Void.$fIxVoid_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWk3: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.551519181 UTC

[section ""data" . Data.Void.$fIxVoid_$cunsafeRangeSize_closure" {
     Data.Void.$fIxVoid_$cunsafeRangeSize_closure:
         const Data.Void.$fIxVoid_$cunsafeRangeSize_info;
 },
 Data.Void.$fIxVoid_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(cfWkj,
                       label: Data.Void.$fIxVoid_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWkj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfWkk; else goto cfWkl;
       cfWkk: // global
           R2 = R2;
           R1 = Data.Void.$fIxVoid_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWkl: // global
           I64[Sp - 8] = block_cfWkg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWkp; else goto cfWkh;
       ufWkp: // global
           call _cfWkg(R1) args: 0, res: 0, upd: 0;
       cfWkh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWkg() //  [R1]
         { info_tbl: [(cfWkg,
                       label: block_cfWkg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWkg: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.558073456 UTC

[section ""data" . Data.Void.$fIxVoid_closure" {
     Data.Void.$fIxVoid_closure:
         const GHC.Arr.C:Ix_con_info;
         const Data.Void.$fOrdVoid_closure+1;
         const Data.Void.$fIxVoid_$crange_closure+1;
         const Data.Void.$fIxVoid_$cindex_closure+2;
         const Data.Void.$fIxVoid_$cindex_closure+2;
         const Data.Void.$fIxVoid_$cinRange_closure+2;
         const Data.Void.$fIxVoid_$crangeSize_closure+1;
         const Data.Void.$fIxVoid_$cunsafeRangeSize_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.560446961 UTC

[section ""cstring" . Data.Void.$fDataVoid5_bytes" {
     Data.Void.$fDataVoid5_bytes:
         I8[] [86,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.562727605 UTC

[section ""data" . Data.Void.$fDataVoid4_closure" {
     Data.Void.$fDataVoid4_closure:
         const Data.Void.$fDataVoid4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fDataVoid4_entry() //  [R1]
         { info_tbl: [(cfWkJ,
                       label: Data.Void.$fDataVoid4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWkJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWkK; else goto cfWkL;
       cfWkK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWkL: // global
           (_cfWkG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfWkG::I64 == 0) goto cfWkI; else goto cfWkH;
       cfWkI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfWkH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfWkG::I64;
           R2 = Data.Void.$fDataVoid5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.566783975 UTC

[section ""data" . Data.Void.$fDataVoid3_closure" {
     Data.Void.$fDataVoid3_closure:
         const Data.Data.AlgRep_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.568503034 UTC

[section ""data" . Data.Void.$tVoid_closure" {
     Data.Void.$tVoid_closure:
         const Data.Data.DataType_con_info;
         const Data.Void.$fDataVoid4_closure;
         const Data.Void.$fDataVoid3_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.570492837 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataTypeOf_closure" {
     Data.Void.$fDataVoid_$cdataTypeOf_closure:
         const Data.Void.$fDataVoid_$cdataTypeOf_info;
         const 0;
 },
 Data.Void.$fDataVoid_$cdataTypeOf_entry() //  []
         { info_tbl: [(cfWkZ,
                       label: Data.Void.$fDataVoid_$cdataTypeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWkZ: // global
           R1 = Data.Void.$tVoid_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.573844002 UTC

[section ""cstring" . Data.Void.$trModule4_bytes" {
     Data.Void.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.575547344 UTC

[section ""data" . Data.Void.$trModule3_closure" {
     Data.Void.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.577671496 UTC

[section ""cstring" . Data.Void.$trModule2_bytes" {
     Data.Void.$trModule2_bytes:
         I8[] [68,97,116,97,46,86,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.579318187 UTC

[section ""data" . Data.Void.$trModule1_closure" {
     Data.Void.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.581090007 UTC

[section ""data" . Data.Void.$trModule_closure" {
     Data.Void.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Void.$trModule3_closure+1;
         const Data.Void.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.582969096 UTC

[section ""data" . Data.Void.$fDataVoid7_closure" {
     Data.Void.$fDataVoid7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$fDataVoid5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.584694879 UTC

[section ""data" . Data.Void.$tcVoid_closure" {
     Data.Void.$tcVoid_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Void.$trModule_closure+1;
         const Data.Void.$fDataVoid7_closure+1;
         const GHC.Types.krep$*_closure;
         const 1716938828100304260;
         const 9065598981067935587;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.58726882 UTC

[section ""data" . Data.Void.$fDataVoid6_closure" {
     Data.Void.$fDataVoid6_closure:
         const Data.Void.$fDataVoid6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fDataVoid6_entry() //  [R1]
         { info_tbl: [(cfWlp,
                       label: Data.Void.$fDataVoid6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWlp: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cfWlq; else goto cfWlr;
       cfWlq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWlr: // global
           (_cfWlh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfWlh::I64 == 0) goto cfWlj; else goto cfWli;
       cfWlj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfWli: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfWlh::I64;
           I64[Sp - 24] = block_cfWlk_info;
           R6 = 0;
           R5 = Data.Void.$fDataVoid7_closure+1;
           R4 = Data.Void.$trModule_closure+1;
           R3 = 9065598981067935587;
           R2 = 1716938828100304260;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cfWlk() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfWlk,
                       label: block_cfWlk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWlk: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cfWll() args: 0, res: 0, upd: 0;
     }
 },
 _cfWll() //  []
         { info_tbl: [(cfWll,
                       label: block_cfWll_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWll: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfWlu; else goto cfWlt;
       cfWlu: // global
           HpAlloc = 48;
           I64[Sp] = block_cfWll_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cfWlt: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.596411151 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataCast1_closure" {
     Data.Void.$fDataVoid_$cdataCast1_closure:
         const Data.Void.$fDataVoid_$cdataCast1_info;
 },
 Data.Void.$fDataVoid_$cdataCast1_entry() //  []
         { info_tbl: [(cfWlU,
                       label: Data.Void.$fDataVoid_$cdataCast1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWlU: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.601465918 UTC

[section ""data" . Data.Void.$w$cgmapMp_closure" {
     Data.Void.$w$cgmapMp_closure:
         const Data.Void.$w$cgmapMp_info;
 },
 lvl2_sfVUD_entry() //  [R1]
         { info_tbl: [(cfWma,
                       label: lvl2_sfVUD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWma: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWmb; else goto cfWmc;
       cfWmb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWmc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfVUL_entry() //  [R1, R2]
         { info_tbl: [(cfWmp,
                       label: sat_sfVUL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWmp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfWmq; else goto cfWmr;
       cfWmq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWmr: // global
           I64[Sp - 24] = block_cfWmm_info;
           _sfVUD::P64 = P64[R1 + 7];
           _sfVUE::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfVUD::P64;
           P64[Sp - 8] = _sfVUE::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufWmJ; else goto cfWmn;
       ufWmJ: // global
           call _cfWmm(R1) args: 0, res: 0, upd: 0;
       cfWmn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWmm() //  [R1]
         { info_tbl: [(cfWmm,
                       label: block_cfWmm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWmm: // global
           I64[Sp - 8] = block_cfWmu_info;
           _sfVUI::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfVUI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWmI; else goto cfWmw;
       ufWmI: // global
           call _cfWmu(R1) args: 0, res: 0, upd: 0;
       cfWmw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWmu() //  [R1]
         { info_tbl: [(cfWmu,
                       label: block_cfWmu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWmu: // global
           if (R1 & 7 == 1) goto cfWmC; else goto cfWmG;
       cfWmC: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfWmG: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Void.$w$cgmapMp_entry() //  [R2, R3]
         { info_tbl: [(cfWmK,
                       label: Data.Void.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWmK: // global
           _sfVUC::P64 = R3;
           _sfVUB::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cfWmL; else goto cfWmM;
       cfWmM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWmO; else goto cfWmN;
       cfWmO: // global
           HpAlloc = 24;
           goto cfWmL;
       cfWmL: // global
           R3 = _sfVUC::P64;
           R2 = _sfVUB::P64;
           R1 = Data.Void.$w$cgmapMp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfWmN: // global
           I64[Hp - 16] = lvl2_sfVUD_info;
           P64[Hp] = _sfVUB::P64;
           I64[Sp - 24] = block_cfWmd_info;
           R2 = _sfVUB::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _sfVUC::P64;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWmd() //  [R1]
         { info_tbl: [(cfWmd,
                       label: block_cfWmd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWmd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWmR; else goto cfWmQ;
       cfWmR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfWmQ: // global
           I64[Hp - 16] = sat_sfVUL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 15;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.617875468 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapMp_closure" {
     Data.Void.$fDataVoid_$cgmapMp_closure:
         const Data.Void.$fDataVoid_$cgmapMp_info;
 },
 Data.Void.$fDataVoid_$cgmapMp_entry() //  [R2, R4]
         { info_tbl: [(cfWnr,
                       label: Data.Void.$fDataVoid_$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWnr: // global
           R3 = R4;
           R2 = R2;
           call Data.Void.$w$cgmapMp_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.62147517 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapM_closure" {
     Data.Void.$fDataVoid_$cgmapM_closure:
         const Data.Void.$fDataVoid_$cgmapM_info;
 },
 Data.Void.$fDataVoid_$cgmapM_entry() //  [R4]
         { info_tbl: [(cfWnC,
                       label: Data.Void.$fDataVoid_$cgmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWnC: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.62493693 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQi_closure" {
     Data.Void.$fDataVoid_$cgmapQi_closure:
         const Data.Void.$fDataVoid_$cgmapQi_info;
 },
 Data.Void.$fDataVoid_$cgmapQi_entry() //  [R4]
         { info_tbl: [(cfWnP,
                       label: Data.Void.$fDataVoid_$cgmapQi_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWnP: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.62867808 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQr_closure" {
     Data.Void.$fDataVoid_$cgmapQr_closure:
         const Data.Void.$fDataVoid_$cgmapQr_info;
 },
 Data.Void.$fDataVoid_$cgmapQr_entry() //  [R5]
         { info_tbl: [(cfWo2,
                       label: Data.Void.$fDataVoid_$cgmapQr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWo2: // global
           R1 = R5 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.632990716 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQ_closure" {
     Data.Void.$fDataVoid_$cgmapQ_closure:
         const Data.Void.$fDataVoid_$cgmapQ_info;
 },
 Data.Void.$fDataVoid_$cgmapQ_entry() //  [R3]
         { info_tbl: [(cfWof,
                       label: Data.Void.$fDataVoid_$cgmapQ_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWof: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.636669656 UTC

[section ""data" . Data.Void.$fDataVoid1_closure" {
     Data.Void.$fDataVoid1_closure:
         const Data.Void.$fDataVoid1_info;
 },
 Data.Void.$fDataVoid1_entry() //  [R5]
         { info_tbl: [(cfWos,
                       label: Data.Void.$fDataVoid1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWos: // global
           R1 = R5 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.640102247 UTC

[section ""data" . Data.Void.$fDataVoid2_closure" {
     Data.Void.$fDataVoid2_closure:
         const Data.Void.$fDataVoid2_info;
 },
 Data.Void.$fDataVoid2_entry() //  [R3]
         { info_tbl: [(cfWoF,
                       label: Data.Void.$fDataVoid2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWoF: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.643503536 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataCast2_closure" {
     Data.Void.$fDataVoid_$cdataCast2_closure:
         const Data.Void.$fDataVoid_$cdataCast2_info;
 },
 Data.Void.$fDataVoid_$cdataCast2_entry() //  []
         { info_tbl: [(cfWoS,
                       label: Data.Void.$fDataVoid_$cdataCast2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWoS: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.647864714 UTC

[section ""data" . Data.Void.$w$cgmapMo_closure" {
     Data.Void.$w$cgmapMo_closure:
         const Data.Void.$w$cgmapMo_info;
 },
 lvl2_sfVVh_entry() //  [R1]
         { info_tbl: [(cfWp8,
                       label: lvl2_sfVVh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWp8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWp9; else goto cfWpa;
       cfWp9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWpa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfVVp_entry() //  [R1, R2]
         { info_tbl: [(cfWpn,
                       label: sat_sfVVp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWpn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfWpo; else goto cfWpp;
       cfWpo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWpp: // global
           I64[Sp - 24] = block_cfWpk_info;
           _sfVVh::P64 = P64[R1 + 7];
           _sfVVi::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfVVh::P64;
           P64[Sp - 8] = _sfVVi::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufWpH; else goto cfWpl;
       ufWpH: // global
           call _cfWpk(R1) args: 0, res: 0, upd: 0;
       cfWpl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWpk() //  [R1]
         { info_tbl: [(cfWpk,
                       label: block_cfWpk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWpk: // global
           I64[Sp - 8] = block_cfWps_info;
           _sfVVm::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfVVm::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWpG; else goto cfWpu;
       ufWpG: // global
           call _cfWps(R1) args: 0, res: 0, upd: 0;
       cfWpu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWps() //  [R1]
         { info_tbl: [(cfWps,
                       label: block_cfWps_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWps: // global
           if (R1 & 7 == 1) goto cfWpA; else goto cfWpE;
       cfWpA: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfWpE: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Void.$w$cgmapMo_entry() //  [R2, R3]
         { info_tbl: [(cfWpI,
                       label: Data.Void.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWpI: // global
           _sfVVg::P64 = R3;
           _sfVVf::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cfWpJ; else goto cfWpK;
       cfWpK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWpM; else goto cfWpL;
       cfWpM: // global
           HpAlloc = 24;
           goto cfWpJ;
       cfWpJ: // global
           R3 = _sfVVg::P64;
           R2 = _sfVVf::P64;
           R1 = Data.Void.$w$cgmapMo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfWpL: // global
           I64[Hp - 16] = lvl2_sfVVh_info;
           P64[Hp] = _sfVVf::P64;
           I64[Sp - 24] = block_cfWpb_info;
           R2 = _sfVVf::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _sfVVg::P64;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWpb() //  [R1]
         { info_tbl: [(cfWpb,
                       label: block_cfWpb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWpb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWpP; else goto cfWpO;
       cfWpP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfWpO: // global
           I64[Hp - 16] = sat_sfVVp_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 15;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.661870073 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapMo_closure" {
     Data.Void.$fDataVoid_$cgmapMo_closure:
         const Data.Void.$fDataVoid_$cgmapMo_info;
 },
 Data.Void.$fDataVoid_$cgmapMo_entry() //  [R2, R4]
         { info_tbl: [(cfWqp,
                       label: Data.Void.$fDataVoid_$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWqp: // global
           R3 = R4;
           R2 = R2;
           call Data.Void.$w$cgmapMo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.665772671 UTC

[section ""data" . Data.Void.$fDataVoid_closure" {
     Data.Void.$fDataVoid_closure:
         const Data.Data.C:Data_con_info;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fDataVoid_$cgfoldl_closure+3;
         const Data.Void.$fDataVoid_$cgunfold_closure+3;
         const Data.Void.$fDataVoid_$ctoConstr_closure+1;
         const Data.Void.$fDataVoid_$cdataTypeOf_closure+1;
         const Data.Void.$fDataVoid_$cdataCast1_closure+2;
         const Data.Void.$fDataVoid_$cdataCast2_closure+2;
         const Data.Void.$fDataVoid2_closure+2;
         const Data.Void.$fDataVoid1_closure+4;
         const Data.Void.$fDataVoid_$cgmapQr_closure+4;
         const Data.Void.$fDataVoid_$cgmapQ_closure+2;
         const Data.Void.$fDataVoid_$cgmapQi_closure+3;
         const Data.Void.$fDataVoid_$cgmapM_closure+3;
         const Data.Void.$fDataVoid_$cgmapMp_closure+3;
         const Data.Void.$fDataVoid_$cgmapMo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.668454964 UTC

[section ""data" . Data.Void.$fExceptionVoid_$cfromException_closure" {
     Data.Void.$fExceptionVoid_$cfromException_closure:
         const Data.Void.$fExceptionVoid_$cfromException_info;
         const 0;
 },
 Data.Void.$fExceptionVoid_$cfromException_entry() //  [R2]
         { info_tbl: [(cfWqE,
                       label: Data.Void.$fExceptionVoid_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWqE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWqI; else goto cfWqJ;
       cfWqI: // global
           R2 = R2;
           R1 = Data.Void.$fExceptionVoid_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWqJ: // global
           I64[Sp - 8] = block_cfWqB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWr4; else goto cfWqC;
       ufWr4: // global
           call _cfWqB(R1) args: 0, res: 0, upd: 0;
       cfWqC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWqB() //  [R1]
         { info_tbl: [(cfWqB,
                       label: block_cfWqB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWqB: // global
           I64[Sp - 8] = block_cfWqH_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWqH() //  [R1]
         { info_tbl: [(cfWqH,
                       label: block_cfWqH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWqH: // global
           I64[Sp] = block_cfWqO_info;
           R3 = Data.Void.$fDataVoid6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWqO() //  [R1]
         { info_tbl: [(cfWqO,
                       label: block_cfWqO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWqO: // global
           if (R1 & 7 == 1) goto cfWqV; else goto cfWqZ;
       cfWqV: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfWqZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfWr2; else goto cfWr1;
       cfWr2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfWr1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.677554454 UTC

[section ""data" . Data.Void.$fExceptionVoid_closure" {
     Data.Void.$fExceptionVoid_closure:
         const GHC.Exception.C:Exception_con_info;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fShowVoid_closure+1;
         const Data.Void.$fExceptionVoid_$ctoException_closure+1;
         const Data.Void.$fExceptionVoid_$cfromException_closure+1;
         const Data.Void.$fExceptionVoid_$cshow_closure+1;
         const 0;
 },
 section ""data" . Data.Void.$fExceptionVoid_$ctoException_closure" {
     Data.Void.$fExceptionVoid_$ctoException_closure:
         const Data.Void.$fExceptionVoid_$ctoException_info;
         const 0;
 },
 Data.Void.$fExceptionVoid_$ctoException_entry() //  [R2]
         { info_tbl: [(cfWrv,
                       label: Data.Void.$fExceptionVoid_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWrv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWrz; else goto cfWry;
       cfWrz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Void.$fExceptionVoid_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWry: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = Data.Void.$fExceptionVoid_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.682317316 UTC

[section ""relreadonly" . SfVVU_srt" {
     SfVVU_srt:
         const Data.Semigroup.Internal.stimesIdempotent_closure;
         const GHC.Read.list_closure;
         const Data.Void.$fReadVoid_$creadListPrec_closure;
         const Data.Void.$fReadVoid1_closure;
         const Control.Exception.Base.patError_closure;
         const Data.Data.$wlvl_closure;
         const Data.Void.$w$cgunfold_closure;
         const lvl1_rfVTf_closure;
         const Data.Void.$fDataVoid_$cgunfold_closure;
         const Data.Void.$tVoid_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fExceptionVoid_$cfromException_closure;
         const Data.Void.$fExceptionVoid_closure;
         const Data.Void.$fExceptionVoid_$ctoException_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.980845923 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:11:45.982064661 UTC

[section ""data" . Data.Void.$fIxVoid1_closure" {
     Data.Void.$fIxVoid1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.984086687 UTC

[section ""data" . Data.Void.$fIxVoid_$crangeSize_closure" {
     Data.Void.$fIxVoid_$crangeSize_closure:
         const Data.Void.$fIxVoid_$crangeSize_info;
 },
 Data.Void.$fIxVoid_$crangeSize_entry() //  []
         { info_tbl: [(cfWu4,
                       label: Data.Void.$fIxVoid_$crangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWu4: // global
           R1 = Data.Void.$fIxVoid1_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.987852334 UTC

[section ""data" . Data.Void.$fIxVoid_$crange_closure" {
     Data.Void.$fIxVoid_$crange_closure:
         const Data.Void.$fIxVoid_$crange_info;
 },
 Data.Void.$fIxVoid_$crange_entry() //  []
         { info_tbl: [(cfWug,
                       label: Data.Void.$fIxVoid_$crange_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWug: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.991583922 UTC

[section ""data" . Data.Void.$fSemigroupVoid_$cstimes_closure" {
     Data.Void.$fSemigroupVoid_$cstimes_closure:
         const Data.Void.$fSemigroupVoid_$cstimes_info;
         const 0;
 },
 Data.Void.$fSemigroupVoid_$cstimes_entry() //  [R2, R3, R4]
         { info_tbl: [(cfWut,
                       label: Data.Void.$fSemigroupVoid_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWut: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotent_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.996381879 UTC

[section ""data" . Data.Void.$fOrdVoid_$c<>_closure" {
     Data.Void.$fOrdVoid_$c<>_closure:
         const Data.Void.$fOrdVoid_$c<>_info;
 },
 Data.Void.$fOrdVoid_$c<>_entry() //  [R2]
         { info_tbl: [(cfWuF,
                       label: Data.Void.$fOrdVoid_$c<>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWuF: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:45.999858793 UTC

[section ""data" . Data.Void.$fSemigroupVoid_$csconcat_closure" {
     Data.Void.$fSemigroupVoid_$csconcat_closure:
         const Data.Void.$fSemigroupVoid_$csconcat_info;
 },
 Data.Void.$fSemigroupVoid_$csconcat_entry() //  [R2]
         { info_tbl: [(cfWuV,
                       label: Data.Void.$fSemigroupVoid_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWuV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWuZ; else goto cfWv0;
       cfWuZ: // global
           R2 = R2;
           R1 = Data.Void.$fSemigroupVoid_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWv0: // global
           I64[Sp - 8] = block_cfWuS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWv8; else goto cfWuT;
       ufWv8: // global
           call _cfWuS(R1) args: 0, res: 0, upd: 0;
       cfWuT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWuS() //  [R1]
         { info_tbl: [(cfWuS,
                       label: block_cfWuS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWuS: // global
           I64[Sp - 8] = block_cfWuY_info;
           _sfWrO::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfWrO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWv7; else goto cfWv2;
       ufWv7: // global
           call _cfWuY() args: 0, res: 0, upd: 0;
       cfWv2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWuY() //  []
         { info_tbl: [(cfWuY,
                       label: block_cfWuY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWuY: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.006879665 UTC

[section ""data" . Data.Void.$fSemigroupVoid_closure" {
     Data.Void.$fSemigroupVoid_closure:
         const GHC.Base.C:Semigroup_con_info;
         const Data.Void.$fOrdVoid_$c<>_closure+2;
         const Data.Void.$fSemigroupVoid_$csconcat_closure+1;
         const Data.Void.$fSemigroupVoid_$cstimes_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.008741004 UTC

[section ""data" . Data.Void.$fShowVoid_$cshowsPrec_closure" {
     Data.Void.$fShowVoid_$cshowsPrec_closure:
         const Data.Void.$fShowVoid_$cshowsPrec_info;
 },
 Data.Void.$fShowVoid_$cshowsPrec_entry() //  [R3]
         { info_tbl: [(cfWvv,
                       label: Data.Void.$fShowVoid_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWvv: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.011986608 UTC

[section ""data" . Data.Void.$fExceptionVoid_$cshow_closure" {
     Data.Void.$fExceptionVoid_$cshow_closure:
         const Data.Void.$fExceptionVoid_$cshow_info;
 },
 Data.Void.$fExceptionVoid_$cshow_entry() //  [R2]
         { info_tbl: [(cfWvI,
                       label: Data.Void.$fExceptionVoid_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWvI: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.015689607 UTC

[section ""data" . Data.Void.$fShowVoid1_closure" {
     Data.Void.$fShowVoid1_closure:
         const Data.Void.$fShowVoid1_info;
 },
 Data.Void.$fShowVoid1_entry() //  [R2]
         { info_tbl: [(cfWvV,
                       label: Data.Void.$fShowVoid1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWvV: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.019034062 UTC

[section ""data" . Data.Void.$fShowVoid_$cshowList_closure" {
     Data.Void.$fShowVoid_$cshowList_closure:
         const Data.Void.$fShowVoid_$cshowList_info;
 },
 Data.Void.$fShowVoid_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(cfWw8,
                       label: Data.Void.$fShowVoid_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWw8: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Void.$fShowVoid1_closure+1;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.022449782 UTC

[section ""data" . Data.Void.$fShowVoid_closure" {
     Data.Void.$fShowVoid_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Void.$fShowVoid_$cshowsPrec_closure+2;
         const Data.Void.$fExceptionVoid_$cshow_closure+1;
         const Data.Void.$fShowVoid_$cshowList_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.024973647 UTC

[section ""data" . Data.Void.$fReadVoid2_closure" {
     Data.Void.$fReadVoid2_closure:
         const Data.Void.$fReadVoid2_info;
 },
 Data.Void.$fReadVoid2_entry() //  [R2]
         { info_tbl: [(cfWwk,
                       label: Data.Void.$fReadVoid2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWwk: // global
           R3 = R2;
           R2 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.02842093 UTC

[section ""data" . Data.Void.$fReadVoid_$creadsPrec_closure" {
     Data.Void.$fReadVoid_$creadsPrec_closure:
         const Data.Void.$fReadVoid_$creadsPrec_info;
 },
 Data.Void.$fReadVoid_$creadsPrec_entry() //  [R3]
         { info_tbl: [(cfWww,
                       label: Data.Void.$fReadVoid_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWww: // global
           R2 = R3;
           call Data.Void.$fReadVoid2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.032223979 UTC

[section ""data" . Data.Void.$fReadVoid_$creadListPrec_closure" {
     Data.Void.$fReadVoid_$creadListPrec_closure:
         const Data.Void.$fReadVoid_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fReadVoid_$creadListPrec_entry() //  [R1]
         { info_tbl: [(cfWwJ,
                       label: Data.Void.$fReadVoid_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWwJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWwK; else goto cfWwL;
       cfWwK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWwL: // global
           (_cfWwG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfWwG::I64 == 0) goto cfWwI; else goto cfWwH;
       cfWwI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfWwH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfWwG::I64;
           R2 = Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.036623328 UTC

[section ""data" . Data.Void.$fReadVoid1_closure" {
     Data.Void.$fReadVoid1_closure:
         const Data.Void.$fReadVoid1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fReadVoid1_entry() //  [R1]
         { info_tbl: [(cfWx1,
                       label: Data.Void.$fReadVoid1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWx1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWx2; else goto cfWx3;
       cfWx2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWx3: // global
           (_cfWwY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfWwY::I64 == 0) goto cfWx0; else goto cfWwZ;
       cfWx0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfWwZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfWwY::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Void.$fReadVoid_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.040756962 UTC

[section ""data" . Data.Void.$fReadVoid_$creadList_closure" {
     Data.Void.$fReadVoid_$creadList_closure:
         const Data.Void.$fReadVoid_$creadList_info;
         const 0;
 },
 Data.Void.$fReadVoid_$creadList_entry() //  [R2]
         { info_tbl: [(cfWxh,
                       label: Data.Void.$fReadVoid_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWxh: // global
           R3 = R2;
           R2 = Data.Void.$fReadVoid1_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.044027504 UTC

[section ""data" . Data.Void.$fReadVoid_closure" {
     Data.Void.$fReadVoid_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Void.$fReadVoid_$creadsPrec_closure+2;
         const Data.Void.$fReadVoid_$creadList_closure+1;
         const Text.ParserCombinators.ReadPrec.$fAlternativeReadPrec4_closure+2;
         const Data.Void.$fReadVoid_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.045874117 UTC

[section ""data" . Data.Void.$fOrdVoid_$ccompare_closure" {
     Data.Void.$fOrdVoid_$ccompare_closure:
         const Data.Void.$fOrdVoid_$ccompare_info;
 },
 Data.Void.$fOrdVoid_$ccompare_entry() //  []
         { info_tbl: [(cfWxt,
                       label: Data.Void.$fOrdVoid_$ccompare_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWxt: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.049223088 UTC

[section ""data" . Data.Void.$fGenericVoid_$cto_closure" {
     Data.Void.$fGenericVoid_$cto_closure:
         const Data.Void.$fGenericVoid_$cto_info;
 },
 Data.Void.$fGenericVoid_$cto_entry() //  [R2]
         { info_tbl: [(cfWxG,
                       label: Data.Void.$fGenericVoid_$cto_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWxG: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.052943698 UTC

[section ""data" . Data.Void.$fGenericVoid1_closure" {
     Data.Void.$fGenericVoid1_closure:
         const Data.Void.$fGenericVoid1_info;
 },
 Data.Void.$fGenericVoid1_entry() //  [R2]
         { info_tbl: [(cfWxR,
                       label: Data.Void.$fGenericVoid1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWxR: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.056707661 UTC

[section ""data" . Data.Void.$fGenericVoid_closure" {
     Data.Void.$fGenericVoid_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Void.$fGenericVoid1_closure+1;
         const Data.Void.$fGenericVoid_$cto_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.058676524 UTC

[section ""data" . Data.Void.$fDataVoid_$ctoConstr_closure" {
     Data.Void.$fDataVoid_$ctoConstr_closure:
         const Data.Void.$fDataVoid_$ctoConstr_info;
 },
 Data.Void.$fDataVoid_$ctoConstr_entry() //  [R2]
         { info_tbl: [(cfWy5,
                       label: Data.Void.$fDataVoid_$ctoConstr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWy5: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.062217583 UTC

[section ""cstring" . lvl_rfVTe_bytes" {
     lvl_rfVTe_bytes:
         I8[] [68,97,116,97,47,86,111,105,100,46,104,115,58,51,57,58,53,45,56,124,99,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.064173796 UTC

[section ""data" . lvl1_rfVTf_closure" {
     lvl1_rfVTf_closure:
         const lvl1_rfVTf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rfVTf_entry() //  [R1]
         { info_tbl: [(cfWyl,
                       label: lvl1_rfVTf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWyl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWym; else goto cfWyn;
       cfWym: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWyn: // global
           (_cfWyi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfWyi::I64 == 0) goto cfWyk; else goto cfWyj;
       cfWyk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfWyj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfWyi::I64;
           R2 = lvl_rfVTe_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.068752995 UTC

[section ""data" . Data.Void.$w$cgunfold_closure" {
     Data.Void.$w$cgunfold_closure:
         const Data.Void.$w$cgunfold_info;
         const 0;
 },
 Data.Void.$w$cgunfold_entry() //  [R2, R3]
         { info_tbl: [(cfWyH,
                       label: Data.Void.$w$cgunfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWyH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWyI; else goto cfWyJ;
       cfWyI: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Void.$w$cgunfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfWyJ: // global
           I64[Sp - 16] = block_cfWyA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufWyX; else goto cfWyB;
       ufWyX: // global
           call _cfWyA(R1) args: 0, res: 0, upd: 0;
       cfWyB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWyA() //  [R1]
         { info_tbl: [(cfWyA,
                       label: block_cfWyA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWyA: // global
           if (R1 & 7 == 1) goto cfWyF; else goto cfWyE;
       cfWyF: // global
           I64[Sp + 8] = block_cfWyP_info;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ufWyW; else goto cfWyR;
       ufWyW: // global
           call _cfWyP() args: 0, res: 0, upd: 0;
       cfWyR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cfWyE: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Data.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cfWyP() //  []
         { info_tbl: [(cfWyP,
                       label: block_cfWyP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWyP: // global
           R1 = lvl1_rfVTf_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.076226523 UTC

[section ""data" . Data.Void.$fDataVoid_$cgunfold_closure" {
     Data.Void.$fDataVoid_$cgunfold_closure:
         const Data.Void.$fDataVoid_$cgunfold_info;
         const 0;
 },
 Data.Void.$fDataVoid_$cgunfold_entry() //  [R2, R3, R4]
         { info_tbl: [(cfWzm,
                       label: Data.Void.$fDataVoid_$cgunfold_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWzm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWzq; else goto cfWzr;
       cfWzq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Void.$fDataVoid_$cgunfold_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfWzr: // global
           I64[Sp - 8] = block_cfWzj_info;
           R1 = R4;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWzz; else goto cfWzk;
       ufWzz: // global
           call _cfWzj(R1) args: 0, res: 0, upd: 0;
       cfWzk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWzj() //  [R1]
         { info_tbl: [(cfWzj,
                       label: block_cfWzj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWzj: // global
           I64[Sp - 8] = block_cfWzp_info;
           _sfWsk::P64 = P64[R1 + 7];
           R1 = P64[R1 + 39];
           P64[Sp] = _sfWsk::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWzy; else goto cfWzt;
       ufWzy: // global
           call _cfWzp(R1) args: 0, res: 0, upd: 0;
       cfWzt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWzp() //  [R1]
         { info_tbl: [(cfWzp,
                       label: block_cfWzp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWzp: // global
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Void.$w$cgunfold_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.083440197 UTC

[section ""data" . Data.Void.$fDataVoid_$cgfoldl_closure" {
     Data.Void.$fDataVoid_$cgfoldl_closure:
         const Data.Void.$fDataVoid_$cgfoldl_info;
 },
 Data.Void.$fDataVoid_$cgfoldl_entry() //  [R4]
         { info_tbl: [(cfWzT,
                       label: Data.Void.$fDataVoid_$cgfoldl_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWzT: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.087053122 UTC

[section ""data" . Data.Void.$fEqVoid_$c==_closure" {
     Data.Void.$fEqVoid_$c==_closure:
         const Data.Void.$fEqVoid_$c==_info;
 },
 Data.Void.$fEqVoid_$c==_entry() //  []
         { info_tbl: [(cfWA6,
                       label: Data.Void.$fEqVoid_$c==_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWA6: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.090797603 UTC

[section ""data" . Data.Void.$fEqVoid_$c/=_closure" {
     Data.Void.$fEqVoid_$c/=_closure:
         const Data.Void.$fEqVoid_$c/=_info;
 },
 Data.Void.$fEqVoid_$c/=_entry() //  []
         { info_tbl: [(cfWAj,
                       label: Data.Void.$fEqVoid_$c/=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWAj: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.093957197 UTC

[section ""data" . Data.Void.$fEqVoid_closure" {
     Data.Void.$fEqVoid_closure:
         const GHC.Classes.C:Eq_con_info;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fEqVoid_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.095793336 UTC

[section ""data" . Data.Void.$fOrdVoid_$c<_closure" {
     Data.Void.$fOrdVoid_$c<_closure:
         const Data.Void.$fOrdVoid_$c<_info;
 },
 Data.Void.$fOrdVoid_$c<_entry() //  []
         { info_tbl: [(cfWAx,
                       label: Data.Void.$fOrdVoid_$c<_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWAx: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.099557182 UTC

[section ""data" . Data.Void.$fOrdVoid_$cmax_closure" {
     Data.Void.$fOrdVoid_$cmax_closure:
         const Data.Void.$fOrdVoid_$cmax_info;
 },
 Data.Void.$fOrdVoid_$cmax_entry() //  [R3]
         { info_tbl: [(cfWAK,
                       label: Data.Void.$fOrdVoid_$cmax_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWAK: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.102917012 UTC

[section ""data" . Data.Void.$fOrdVoid_closure" {
     Data.Void.$fOrdVoid_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Void.$fEqVoid_closure+1;
         const Data.Void.$fOrdVoid_$ccompare_closure+2;
         const Data.Void.$fOrdVoid_$c<_closure+2;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fOrdVoid_$c<_closure+2;
         const Data.Void.$fEqVoid_$c==_closure+2;
         const Data.Void.$fOrdVoid_$cmax_closure+2;
         const Data.Void.$fOrdVoid_$c<>_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.104917764 UTC

[section ""data" . Data.Void.absurd_closure" {
     Data.Void.absurd_closure:
         const Data.Void.absurd_info;
 },
 Data.Void.absurd_entry() //  [R2]
         { info_tbl: [(cfWAY,
                       label: Data.Void.absurd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWAY: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.108222922 UTC

[section ""data" . Data.Void.vacuous_closure" {
     Data.Void.vacuous_closure:
         const Data.Void.vacuous_info;
 },
 Data.Void.vacuous_entry() //  [R2]
         { info_tbl: [(cfWBb,
                       label: Data.Void.vacuous_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWBb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWBc; else goto cfWBd;
       cfWBc: // global
           R2 = R2;
           R1 = Data.Void.vacuous_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWBd: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Void.absurd_closure+1;
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.11228502 UTC

[section ""data" . Data.Void.$fIxVoid_$cindex_closure" {
     Data.Void.$fIxVoid_$cindex_closure:
         const Data.Void.$fIxVoid_$cindex_info;
 },
 Data.Void.$fIxVoid_$cindex_entry() //  [R3]
         { info_tbl: [(cfWBp,
                       label: Data.Void.$fIxVoid_$cindex_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWBp: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.115576329 UTC

[section ""data" . Data.Void.$fIxVoid_$cinRange_closure" {
     Data.Void.$fIxVoid_$cinRange_closure:
         const Data.Void.$fIxVoid_$cinRange_info;
 },
 Data.Void.$fIxVoid_$cinRange_entry() //  [R3]
         { info_tbl: [(cfWBC,
                       label: Data.Void.$fIxVoid_$cinRange_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWBC: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.119475574 UTC

[section ""data" . Data.Void.$fIxVoid_$cunsafeRangeSize_closure" {
     Data.Void.$fIxVoid_$cunsafeRangeSize_closure:
         const Data.Void.$fIxVoid_$cunsafeRangeSize_info;
 },
 Data.Void.$fIxVoid_$cunsafeRangeSize_entry() //  [R2]
         { info_tbl: [(cfWBS,
                       label: Data.Void.$fIxVoid_$cunsafeRangeSize_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWBS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfWBT; else goto cfWBU;
       cfWBT: // global
           R2 = R2;
           R1 = Data.Void.$fIxVoid_$cunsafeRangeSize_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWBU: // global
           I64[Sp - 8] = block_cfWBP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWBY; else goto cfWBQ;
       ufWBY: // global
           call _cfWBP(R1) args: 0, res: 0, upd: 0;
       cfWBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWBP() //  [R1]
         { info_tbl: [(cfWBP,
                       label: block_cfWBP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWBP: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.124550543 UTC

[section ""data" . Data.Void.$fIxVoid_closure" {
     Data.Void.$fIxVoid_closure:
         const GHC.Arr.C:Ix_con_info;
         const Data.Void.$fOrdVoid_closure+1;
         const Data.Void.$fIxVoid_$crange_closure+1;
         const Data.Void.$fIxVoid_$cindex_closure+2;
         const Data.Void.$fIxVoid_$cindex_closure+2;
         const Data.Void.$fIxVoid_$cinRange_closure+2;
         const Data.Void.$fIxVoid_$crangeSize_closure+1;
         const Data.Void.$fIxVoid_$cunsafeRangeSize_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.126743319 UTC

[section ""cstring" . Data.Void.$fDataVoid5_bytes" {
     Data.Void.$fDataVoid5_bytes:
         I8[] [86,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.128664416 UTC

[section ""data" . Data.Void.$fDataVoid4_closure" {
     Data.Void.$fDataVoid4_closure:
         const Data.Void.$fDataVoid4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fDataVoid4_entry() //  [R1]
         { info_tbl: [(cfWCj,
                       label: Data.Void.$fDataVoid4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWCj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWCk; else goto cfWCl;
       cfWCk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWCl: // global
           (_cfWCg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfWCg::I64 == 0) goto cfWCi; else goto cfWCh;
       cfWCi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfWCh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfWCg::I64;
           R2 = Data.Void.$fDataVoid5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.132818392 UTC

[section ""data" . Data.Void.$fDataVoid3_closure" {
     Data.Void.$fDataVoid3_closure:
         const Data.Data.AlgRep_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.134552449 UTC

[section ""data" . Data.Void.$tVoid_closure" {
     Data.Void.$tVoid_closure:
         const Data.Data.DataType_con_info;
         const Data.Void.$fDataVoid4_closure;
         const Data.Void.$fDataVoid3_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.13649571 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataTypeOf_closure" {
     Data.Void.$fDataVoid_$cdataTypeOf_closure:
         const Data.Void.$fDataVoid_$cdataTypeOf_info;
         const 0;
 },
 Data.Void.$fDataVoid_$cdataTypeOf_entry() //  []
         { info_tbl: [(cfWCA,
                       label: Data.Void.$fDataVoid_$cdataTypeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWCA: // global
           R1 = Data.Void.$tVoid_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.139802025 UTC

[section ""cstring" . Data.Void.$trModule4_bytes" {
     Data.Void.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.141467331 UTC

[section ""data" . Data.Void.$trModule3_closure" {
     Data.Void.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.143117727 UTC

[section ""cstring" . Data.Void.$trModule2_bytes" {
     Data.Void.$trModule2_bytes:
         I8[] [68,97,116,97,46,86,111,105,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.144788129 UTC

[section ""data" . Data.Void.$trModule1_closure" {
     Data.Void.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.146959996 UTC

[section ""data" . Data.Void.$trModule_closure" {
     Data.Void.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Void.$trModule3_closure+1;
         const Data.Void.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.149206901 UTC

[section ""data" . Data.Void.$fDataVoid7_closure" {
     Data.Void.$fDataVoid7_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Void.$fDataVoid5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.150947332 UTC

[section ""data" . Data.Void.$tcVoid_closure" {
     Data.Void.$tcVoid_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Void.$trModule_closure+1;
         const Data.Void.$fDataVoid7_closure+1;
         const GHC.Types.krep$*_closure;
         const 1716938828100304260;
         const 9065598981067935587;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.153336738 UTC

[section ""data" . Data.Void.$fDataVoid6_closure" {
     Data.Void.$fDataVoid6_closure:
         const Data.Void.$fDataVoid6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Void.$fDataVoid6_entry() //  [R1]
         { info_tbl: [(cfWD0,
                       label: Data.Void.$fDataVoid6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWD0: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cfWD1; else goto cfWD2;
       cfWD1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWD2: // global
           (_cfWCS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cfWCS::I64 == 0) goto cfWCU; else goto cfWCT;
       cfWCU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cfWCT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cfWCS::I64;
           I64[Sp - 24] = block_cfWCV_info;
           R6 = 0;
           R5 = Data.Void.$fDataVoid7_closure+1;
           R4 = Data.Void.$trModule_closure+1;
           R3 = 9065598981067935587;
           R2 = 1716938828100304260;
           P64[Sp - 40] = GHC.Types.krep$*_closure;
           P64[Sp - 32] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call Data.Typeable.Internal.$wmkTrCon_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 8, upd: 24;
     }
 },
 _cfWCV() //  [R1, R2, R3, R4, R5]
         { info_tbl: [(cfWCV,
                       label: block_cfWCV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWCV: // global
           I64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           I64[Sp] = R1;
           Sp = Sp - 40;
           call _cfWCW() args: 0, res: 0, upd: 0;
     }
 },
 _cfWCW() //  []
         { info_tbl: [(cfWCW,
                       label: block_cfWCW_info
                       rep:StackRep [True, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWCW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfWD5; else goto cfWD4;
       cfWD5: // global
           HpAlloc = 48;
           I64[Sp] = block_cfWCW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 24;
       cfWD4: // global
           I64[Hp - 40] = Data.Typeable.Internal.TrTyCon_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           I64[Hp - 8] = I64[Sp + 40];
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 38;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.161805398 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataCast1_closure" {
     Data.Void.$fDataVoid_$cdataCast1_closure:
         const Data.Void.$fDataVoid_$cdataCast1_info;
 },
 Data.Void.$fDataVoid_$cdataCast1_entry() //  []
         { info_tbl: [(cfWDC,
                       label: Data.Void.$fDataVoid_$cdataCast1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWDC: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.165982173 UTC

[section ""data" . Data.Void.$w$cgmapMp_closure" {
     Data.Void.$w$cgmapMp_closure:
         const Data.Void.$w$cgmapMp_info;
 },
 lvl2_sfWt3_entry() //  [R1]
         { info_tbl: [(cfWDT,
                       label: lvl2_sfWt3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWDT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWDU; else goto cfWDV;
       cfWDU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWDV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfWtb_entry() //  [R1, R2]
         { info_tbl: [(cfWE8,
                       label: sat_sfWtb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWE8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfWE9; else goto cfWEa;
       cfWE9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWEa: // global
           I64[Sp - 24] = block_cfWE5_info;
           _sfWt3::P64 = P64[R1 + 7];
           _sfWt4::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfWt3::P64;
           P64[Sp - 8] = _sfWt4::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufWEs; else goto cfWE6;
       ufWEs: // global
           call _cfWE5(R1) args: 0, res: 0, upd: 0;
       cfWE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWE5() //  [R1]
         { info_tbl: [(cfWE5,
                       label: block_cfWE5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWE5: // global
           I64[Sp - 8] = block_cfWEd_info;
           _sfWt8::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfWt8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWEr; else goto cfWEf;
       ufWEr: // global
           call _cfWEd(R1) args: 0, res: 0, upd: 0;
       cfWEf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWEd() //  [R1]
         { info_tbl: [(cfWEd,
                       label: block_cfWEd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWEd: // global
           if (R1 & 7 == 1) goto cfWEl; else goto cfWEp;
       cfWEl: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfWEp: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Void.$w$cgmapMp_entry() //  [R2, R3]
         { info_tbl: [(cfWEt,
                       label: Data.Void.$w$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWEt: // global
           _sfWt2::P64 = R3;
           _sfWt1::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cfWEu; else goto cfWEv;
       cfWEv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWEx; else goto cfWEw;
       cfWEx: // global
           HpAlloc = 24;
           goto cfWEu;
       cfWEu: // global
           R3 = _sfWt2::P64;
           R2 = _sfWt1::P64;
           R1 = Data.Void.$w$cgmapMp_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfWEw: // global
           I64[Hp - 16] = lvl2_sfWt3_info;
           P64[Hp] = _sfWt1::P64;
           I64[Sp - 24] = block_cfWDW_info;
           R2 = _sfWt1::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _sfWt2::P64;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWDW() //  [R1]
         { info_tbl: [(cfWDW,
                       label: block_cfWDW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWDW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWEA; else goto cfWEz;
       cfWEA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfWEz: // global
           I64[Hp - 16] = sat_sfWtb_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 15;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.180087134 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapMp_closure" {
     Data.Void.$fDataVoid_$cgmapMp_closure:
         const Data.Void.$fDataVoid_$cgmapMp_info;
 },
 Data.Void.$fDataVoid_$cgmapMp_entry() //  [R2, R4]
         { info_tbl: [(cfWFi,
                       label: Data.Void.$fDataVoid_$cgmapMp_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWFi: // global
           R3 = R4;
           R2 = R2;
           call Data.Void.$w$cgmapMp_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.183856324 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapM_closure" {
     Data.Void.$fDataVoid_$cgmapM_closure:
         const Data.Void.$fDataVoid_$cgmapM_info;
 },
 Data.Void.$fDataVoid_$cgmapM_entry() //  [R4]
         { info_tbl: [(cfWFt,
                       label: Data.Void.$fDataVoid_$cgmapM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWFt: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.187823608 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQi_closure" {
     Data.Void.$fDataVoid_$cgmapQi_closure:
         const Data.Void.$fDataVoid_$cgmapQi_info;
 },
 Data.Void.$fDataVoid_$cgmapQi_entry() //  [R4]
         { info_tbl: [(cfWFG,
                       label: Data.Void.$fDataVoid_$cgmapQi_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWFG: // global
           R1 = R4 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.191114034 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQr_closure" {
     Data.Void.$fDataVoid_$cgmapQr_closure:
         const Data.Void.$fDataVoid_$cgmapQr_info;
 },
 Data.Void.$fDataVoid_$cgmapQr_entry() //  [R5]
         { info_tbl: [(cfWFT,
                       label: Data.Void.$fDataVoid_$cgmapQr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWFT: // global
           R1 = R5 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.19436653 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapQ_closure" {
     Data.Void.$fDataVoid_$cgmapQ_closure:
         const Data.Void.$fDataVoid_$cgmapQ_info;
 },
 Data.Void.$fDataVoid_$cgmapQ_entry() //  [R3]
         { info_tbl: [(cfWG6,
                       label: Data.Void.$fDataVoid_$cgmapQ_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWG6: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.198316473 UTC

[section ""data" . Data.Void.$fDataVoid1_closure" {
     Data.Void.$fDataVoid1_closure:
         const Data.Void.$fDataVoid1_info;
 },
 Data.Void.$fDataVoid1_entry() //  [R5]
         { info_tbl: [(cfWGj,
                       label: Data.Void.$fDataVoid1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWGj: // global
           R1 = R5 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.20164709 UTC

[section ""data" . Data.Void.$fDataVoid2_closure" {
     Data.Void.$fDataVoid2_closure:
         const Data.Void.$fDataVoid2_info;
 },
 Data.Void.$fDataVoid2_entry() //  [R3]
         { info_tbl: [(cfWGw,
                       label: Data.Void.$fDataVoid2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWGw: // global
           R1 = R3 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.20486235 UTC

[section ""data" . Data.Void.$fDataVoid_$cdataCast2_closure" {
     Data.Void.$fDataVoid_$cdataCast2_closure:
         const Data.Void.$fDataVoid_$cdataCast2_info;
 },
 Data.Void.$fDataVoid_$cdataCast2_entry() //  []
         { info_tbl: [(cfWGJ,
                       label: Data.Void.$fDataVoid_$cdataCast2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWGJ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.208890736 UTC

[section ""data" . Data.Void.$w$cgmapMo_closure" {
     Data.Void.$w$cgmapMo_closure:
         const Data.Void.$w$cgmapMo_info;
 },
 lvl2_sfWtH_entry() //  [R1]
         { info_tbl: [(cfWH0,
                       label: lvl2_sfWtH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWH0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWH1; else goto cfWH2;
       cfWH1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWH2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sfWtP_entry() //  [R1, R2]
         { info_tbl: [(cfWHf,
                       label: sat_sfWtP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWHf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfWHg; else goto cfWHh;
       cfWHg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWHh: // global
           I64[Sp - 24] = block_cfWHc_info;
           _sfWtH::P64 = P64[R1 + 7];
           _sfWtI::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 16] = _sfWtH::P64;
           P64[Sp - 8] = _sfWtI::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufWHz; else goto cfWHd;
       ufWHz: // global
           call _cfWHc(R1) args: 0, res: 0, upd: 0;
       cfWHd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWHc() //  [R1]
         { info_tbl: [(cfWHc,
                       label: block_cfWHc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWHc: // global
           I64[Sp - 8] = block_cfWHk_info;
           _sfWtM::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sfWtM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWHy; else goto cfWHm;
       ufWHy: // global
           call _cfWHk(R1) args: 0, res: 0, upd: 0;
       cfWHm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWHk() //  [R1]
         { info_tbl: [(cfWHk,
                       label: block_cfWHk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWHk: // global
           if (R1 & 7 == 1) goto cfWHs; else goto cfWHw;
       cfWHs: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cfWHw: // global
           R2 = P64[Sp + 24];
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.Void.$w$cgmapMo_entry() //  [R2, R3]
         { info_tbl: [(cfWHA,
                       label: Data.Void.$w$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWHA: // global
           _sfWtG::P64 = R3;
           _sfWtF::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cfWHB; else goto cfWHC;
       cfWHC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWHE; else goto cfWHD;
       cfWHE: // global
           HpAlloc = 24;
           goto cfWHB;
       cfWHB: // global
           R3 = _sfWtG::P64;
           R2 = _sfWtF::P64;
           R1 = Data.Void.$w$cgmapMo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfWHD: // global
           I64[Hp - 16] = lvl2_sfWtH_info;
           P64[Hp] = _sfWtF::P64;
           I64[Sp - 24] = block_cfWH3_info;
           R2 = _sfWtF::P64;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = _sfWtG::P64;
           Sp = Sp - 24;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWH3() //  [R1]
         { info_tbl: [(cfWH3,
                       label: block_cfWH3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWH3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWHH; else goto cfWHG;
       cfWHH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfWHG: // global
           I64[Hp - 16] = sat_sfWtP_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = Hp - 15;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.223471016 UTC

[section ""data" . Data.Void.$fDataVoid_$cgmapMo_closure" {
     Data.Void.$fDataVoid_$cgmapMo_closure:
         const Data.Void.$fDataVoid_$cgmapMo_info;
 },
 Data.Void.$fDataVoid_$cgmapMo_entry() //  [R2, R4]
         { info_tbl: [(cfWIp,
                       label: Data.Void.$fDataVoid_$cgmapMo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWIp: // global
           R3 = R4;
           R2 = R2;
           call Data.Void.$w$cgmapMo_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.226665511 UTC

[section ""data" . Data.Void.$fDataVoid_closure" {
     Data.Void.$fDataVoid_closure:
         const Data.Data.C:Data_con_info;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fDataVoid_$cgfoldl_closure+3;
         const Data.Void.$fDataVoid_$cgunfold_closure+3;
         const Data.Void.$fDataVoid_$ctoConstr_closure+1;
         const Data.Void.$fDataVoid_$cdataTypeOf_closure+1;
         const Data.Void.$fDataVoid_$cdataCast1_closure+2;
         const Data.Void.$fDataVoid_$cdataCast2_closure+2;
         const Data.Void.$fDataVoid2_closure+2;
         const Data.Void.$fDataVoid1_closure+4;
         const Data.Void.$fDataVoid_$cgmapQr_closure+4;
         const Data.Void.$fDataVoid_$cgmapQ_closure+2;
         const Data.Void.$fDataVoid_$cgmapQi_closure+3;
         const Data.Void.$fDataVoid_$cgmapM_closure+3;
         const Data.Void.$fDataVoid_$cgmapMp_closure+3;
         const Data.Void.$fDataVoid_$cgmapMo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.22916112 UTC

[section ""data" . Data.Void.$fExceptionVoid_$cfromException_closure" {
     Data.Void.$fExceptionVoid_$cfromException_closure:
         const Data.Void.$fExceptionVoid_$cfromException_info;
         const 0;
 },
 Data.Void.$fExceptionVoid_$cfromException_entry() //  [R2]
         { info_tbl: [(cfWIE,
                       label: Data.Void.$fExceptionVoid_$cfromException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWIE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWII; else goto cfWIJ;
       cfWII: // global
           R2 = R2;
           R1 = Data.Void.$fExceptionVoid_$cfromException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWIJ: // global
           I64[Sp - 8] = block_cfWIB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufWJ4; else goto cfWIC;
       ufWJ4: // global
           call _cfWIB(R1) args: 0, res: 0, upd: 0;
       cfWIC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfWIB() //  [R1]
         { info_tbl: [(cfWIB,
                       label: block_cfWIB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWIB: // global
           I64[Sp - 8] = block_cfWIH_info;
           R2 = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 8;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWIH() //  [R1]
         { info_tbl: [(cfWIH,
                       label: block_cfWIH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWIH: // global
           I64[Sp] = block_cfWIO_info;
           R3 = Data.Void.$fDataVoid6_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cfWIO() //  [R1]
         { info_tbl: [(cfWIO,
                       label: block_cfWIO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWIO: // global
           if (R1 & 7 == 1) goto cfWIV; else goto cfWIZ;
       cfWIV: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfWIZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfWJ2; else goto cfWJ1;
       cfWJ2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfWJ1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.238790959 UTC

[section ""data" . Data.Void.$fExceptionVoid_closure" {
     Data.Void.$fExceptionVoid_closure:
         const GHC.Exception.C:Exception_con_info;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fShowVoid_closure+1;
         const Data.Void.$fExceptionVoid_$ctoException_closure+1;
         const Data.Void.$fExceptionVoid_$cfromException_closure+1;
         const Data.Void.$fExceptionVoid_$cshow_closure+1;
         const 0;
 },
 section ""data" . Data.Void.$fExceptionVoid_$ctoException_closure" {
     Data.Void.$fExceptionVoid_$ctoException_closure:
         const Data.Void.$fExceptionVoid_$ctoException_info;
         const 0;
 },
 Data.Void.$fExceptionVoid_$ctoException_entry() //  [R2]
         { info_tbl: [(cfWJA,
                       label: Data.Void.$fExceptionVoid_$ctoException_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cfWJA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cfWJE; else goto cfWJD;
       cfWJE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Void.$fExceptionVoid_$ctoException_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfWJD: // global
           I64[Hp - 16] = GHC.Exception.SomeException_con_info;
           P64[Hp - 8] = Data.Void.$fExceptionVoid_closure+1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:11:46.243249464 UTC

[section ""relreadonly" . SfWuw_srt" {
     SfWuw_srt:
         const Data.Semigroup.Internal.stimesIdempotent_closure;
         const GHC.Read.list_closure;
         const Data.Void.$fReadVoid_$creadListPrec_closure;
         const Data.Void.$fReadVoid1_closure;
         const Control.Exception.Base.patError_closure;
         const Data.Data.$wlvl_closure;
         const Data.Void.$w$cgunfold_closure;
         const lvl1_rfVTf_closure;
         const Data.Void.$fDataVoid_$cgunfold_closure;
         const Data.Void.$tVoid_closure;
         const Data.Typeable.Internal.$wmkTrCon_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const Data.Void.$fDataVoid6_closure;
         const Data.Void.$fExceptionVoid_$cfromException_closure;
         const Data.Void.$fExceptionVoid_closure;
         const Data.Void.$fExceptionVoid_$ctoException_closure;
 }]

