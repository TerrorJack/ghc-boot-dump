
==================== Pre unarise: ====================
2018-03-16 16:01:56.778532571 UTC

Data.Monoid.$fMonoidFirst_$c<>
  :: forall a.
     Data.Monoid.First a -> Data.Monoid.First a -> Data.Monoid.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6I1x b_s6I1y]
        case ds_s6I1x of wild_s6I1z {
          GHC.Base.Nothing -> b_s6I1y;
          GHC.Base.Just _ [Occ=Dead] -> wild_s6I1z;
        };

Data.Monoid.$fSemigroupFirst1 [Occ=LoopBreaker]
  :: forall a.
     Data.Monoid.First a -> [Data.Monoid.First a] -> Data.Monoid.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6I1B ds1_s6I1C]
        case ds1_s6I1C of {
          [] -> b_s6I1B;
          : c_s6I1E [Occ=Once] cs_s6I1F [Occ=Once] ->
              case b_s6I1B of wild_s6I1G {
                GHC.Base.Nothing -> Data.Monoid.$fSemigroupFirst1 c_s6I1E cs_s6I1F;
                GHC.Base.Just _ [Occ=Dead] -> wild_s6I1G;
              };
        };

Data.Monoid.$fSemigroupFirst_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Monoid.First a) -> Data.Monoid.First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6I1I]
        case ds_s6I1I of {
          GHC.Base.:| a1_s6I1K [Occ=Once] as_s6I1L [Occ=Once] ->
              Data.Monoid.$fSemigroupFirst1 a1_s6I1K as_s6I1L;
        };

Data.Monoid.$fMonoidFirst_go [Occ=LoopBreaker]
  :: forall a. [Data.Monoid.First a] -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I1M]
        case ds_s6I1M of {
          [] -> GHC.Base.Nothing [];
          : y_s6I1O [Occ=Once] ys_s6I1P [Occ=Once] ->
              case y_s6I1O of wild1_s6I1Q {
                GHC.Base.Nothing -> Data.Monoid.$fMonoidFirst_go ys_s6I1P;
                GHC.Base.Just _ [Occ=Dead] -> wild1_s6I1Q;
              };
        };

Data.Monoid.$fSemigroupFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Monoid.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Monoid.$fMonoidFirst_$c<>
                                         Data.Monoid.$fSemigroupFirst_$csconcat
                                         Data.Monoid.$fSemigroupFirst_$cstimes];
Data.Monoid.$fMonoidFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Monoid.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Monoid.$fSemigroupFirst
                                      GHC.Base.Nothing
                                      Data.Monoid.$fMonoidFirst_$c<>
                                      Data.Monoid.$fMonoidFirst_go];
Data.Monoid.$fSemigroupFirst_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Monoid.First a -> Data.Monoid.First a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6I1S eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6I1S Data.Monoid.$fMonoidFirst eta_B2 eta_B1;

Data.Monoid.$fMonoidLast_$c<>
  :: forall a.
     Data.Monoid.Last a -> Data.Monoid.Last a -> Data.Monoid.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6I1T ds_s6I1U]
        case ds_s6I1U of wild_s6I1V {
          GHC.Base.Nothing -> a1_s6I1T;
          GHC.Base.Just _ [Occ=Dead] -> wild_s6I1V;
        };

Data.Monoid.$fSemigroupLast1 [Occ=LoopBreaker]
  :: forall a.
     Data.Monoid.Last a -> [Data.Monoid.Last a] -> Data.Monoid.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6I1X ds1_s6I1Y]
        case ds1_s6I1Y of {
          [] -> b_s6I1X;
          : c_s6I20 [Occ=Once] cs_s6I21 [Occ=Once] ->
              case Data.Monoid.$fSemigroupLast1 c_s6I20 cs_s6I21 of wild_s6I22 {
                GHC.Base.Nothing -> b_s6I1X;
                GHC.Base.Just _ [Occ=Dead] -> wild_s6I22;
              };
        };

Data.Monoid.$fSemigroupLast_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Monoid.Last a) -> Data.Monoid.Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6I24]
        case ds_s6I24 of {
          GHC.Base.:| a1_s6I26 [Occ=Once] as_s6I27 [Occ=Once] ->
              Data.Monoid.$fSemigroupLast1 a1_s6I26 as_s6I27;
        };

Data.Monoid.$fMonoidLast_go [Occ=LoopBreaker]
  :: forall a. [Data.Monoid.Last a] -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I28]
        case ds_s6I28 of {
          [] -> GHC.Base.Nothing [];
          : y_s6I2a [Occ=Once] ys_s6I2b [Occ=Once] ->
              case Data.Monoid.$fMonoidLast_go ys_s6I2b of wild1_s6I2c {
                GHC.Base.Nothing -> y_s6I2a;
                GHC.Base.Just _ [Occ=Dead] -> wild1_s6I2c;
              };
        };

Data.Monoid.$fSemigroupLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Monoid.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Monoid.$fMonoidLast_$c<>
                                         Data.Monoid.$fSemigroupLast_$csconcat
                                         Data.Monoid.$fSemigroupLast_$cstimes];
Data.Monoid.$fMonoidLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Monoid.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Monoid.$fSemigroupLast
                                      GHC.Base.Nothing
                                      Data.Monoid.$fMonoidLast_$c<>
                                      Data.Monoid.$fMonoidLast_go];
Data.Monoid.$fSemigroupLast_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Monoid.Last a -> Data.Monoid.Last a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6I2e eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6I2e Data.Monoid.$fMonoidLast eta_B2 eta_B1;

Data.Monoid.$fFunctorLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

Data.Monoid.$fApplicativeLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Monoid.$fFunctorLast
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

Data.Monoid.$fMonadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Monoid.$fApplicativeLast
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

Data.Monoid.$fGeneric1Last1
  :: forall a.
     GHC.Generics.Rep1 Data.Monoid.Last a
     -> GHC.Generics.Rep1 Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I2f] ds_s6I2f;

Data.Monoid.$fGeneric1Last2
  :: forall a. Data.Monoid.Last a -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6I2g] x_s6I2g;

Data.Monoid.$fGeneric1Last [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Monoid.$fGeneric1Last2
                                            Data.Monoid.$fGeneric1Last1];

Data.Monoid.$fGenericLast1
  :: forall a x.
     GHC.Generics.Rep (Data.Monoid.Last a) x
     -> GHC.Generics.Rep (Data.Monoid.Last a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I2h] ds_s6I2h;

Data.Monoid.$fGenericLast2
  :: forall a x. Data.Monoid.Last a -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6I2i] x1_s6I2i;

Data.Monoid.$fGenericLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Monoid.Last a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Monoid.$fGenericLast2
                                           Data.Monoid.$fGenericLast1];

Data.Monoid.$fShowFirst1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Monoid.$fShowLast2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last {"#;

Data.Monoid.$fShowLast1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast = "#;

Data.Monoid.$fReadFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Monoid.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Monoid.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6I2j ww_s6I2k w1_s6I2l]
        let {
          f_s6I2m [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6I2j w1_s6I2l] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_s6I2j Data.Monoid.$fShowFirst1 w1_s6I2l;
        } in 
          case >=# [ww_s6I2k 11#] of {
            __DEFAULT ->
                let {
                  sat_s6I2s [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6I2m] \r [x_s6I2o]
                          let {
                            sat_s6I2r [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6I2m x_s6I2o] \u []
                                    let {
                                      sat_s6I2q [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6I2m x_s6I2o] \u []
                                              let {
                                                sat_s6I2p [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6I2o] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Monoid.$fReadFirst4 x_s6I2o;
                                              } in  f_s6I2m sat_s6I2p;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowLast1 sat_s6I2q;
                          } in 
                            GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast2 sat_s6I2r;
                } in  sat_s6I2s;
            1# ->
                let {
                  sat_s6I2z [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6I2m] \r [x_s6I2t]
                          let {
                            sat_s6I2y [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6I2m x_s6I2t] \u []
                                    let {
                                      sat_s6I2x [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6I2m x_s6I2t] \u []
                                              let {
                                                sat_s6I2w [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6I2m x_s6I2t] \u []
                                                        let {
                                                          sat_s6I2v [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6I2t] \u []
                                                                  let {
                                                                    sat_s6I2u [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6I2t];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Monoid.$fReadFirst4
                                                                        sat_s6I2u;
                                                        } in  f_s6I2m sat_s6I2v;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Monoid.$fShowLast1 sat_s6I2w;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowLast2 sat_s6I2x;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6I2y];
                } in  sat_s6I2z;
          };

Data.Monoid.$fShowLast_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Monoid.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6I2A w1_s6I2B w2_s6I2C]
        case w1_s6I2B of {
          GHC.Types.I# ww1_s6I2E [Occ=Once] ->
              Data.Monoid.$w$cshowsPrec1 w_s6I2A ww1_s6I2E w2_s6I2C;
        };

Data.Monoid.$fReadFirst3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst4;

Data.Monoid.$fShowFirst4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++ GHC.Show.$fShowMaybe4 Data.Monoid.$fReadFirst3;

Data.Monoid.$fShowLast_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Monoid.Last a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6I2F x_s6I2G]
        let {
          sat_s6I2L [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6I2F x_s6I2G] \u []
                  let {
                    sat_s6I2K [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6I2F x_s6I2G] \u []
                            case x_s6I2G of {
                              GHC.Base.Nothing -> Data.Monoid.$fShowFirst4;
                              GHC.Base.Just b1_s6I2I [Occ=Once] ->
                                  let {
                                    sat_s6I2J [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_s6I2F b1_s6I2I] \s []
                                            GHC.Show.showsPrec
                                                $dShow_s6I2F
                                                GHC.Show.appPrec1
                                                b1_s6I2I
                                                Data.Monoid.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_s6I2J;
                            };
                  } in 
                    GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast1 sat_s6I2K;
        } in 
          GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast2 sat_s6I2L;

Data.Monoid.$fShowLast_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Monoid.Last a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6I2M ls_s6I2N s_s6I2O]
        let {
          sat_s6I2Q [Occ=Once] :: Data.Monoid.Last a_a6Hji -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I2M] \r [w_s6I2P]
                  Data.Monoid.$w$cshowsPrec1 $dShow_s6I2M 0# w_s6I2P;
        } in  GHC.Show.showList__ sat_s6I2Q ls_s6I2N s_s6I2O;

Data.Monoid.$fShowLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6I2R]
        let {
          sat_s6I2U [Occ=Once]
            :: [Data.Monoid.Last a_a6Hji] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I2R] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowLast_$cshowList $dShow_s6I2R eta_B2 eta_B1; } in
        let {
          sat_s6I2T [Occ=Once] :: Data.Monoid.Last a_a6Hji -> GHC.Base.String
          [LclId] =
              [$dShow_s6I2R] \r [eta_B1]
                  Data.Monoid.$fShowLast_$cshow $dShow_s6I2R eta_B1; } in
        let {
          sat_s6I2S [Occ=Once]
            :: GHC.Types.Int -> Data.Monoid.Last a_a6Hji -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I2R] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowLast_$cshowsPrec $dShow_s6I2R eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6I2S sat_s6I2T sat_s6I2U];

Data.Monoid.$fReadLast5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last"#;

Data.Monoid.$fReadLast4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadLast5;

Data.Monoid.$fReadLast_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Monoid.$fReadLast4];

Data.Monoid.$fReadFirst9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Monoid.$fReadFirst8 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst9;

Data.Monoid.$fReadFirst_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Monoid.$fReadFirst8];

Data.Monoid.$fReadLast3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast"#;

Data.Monoid.$fReadLast2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadLast3;

Data.Monoid.$fReadFirst5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Monoid.$fReadFirst2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Monoid.$fReadFirst3];

Data.Monoid.$fReadLast1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Monoid.Last a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s6I2V eta_s6I2W eta1_s6I2X]
        let {
          ds_s6I2Y [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_a6Hit -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_s6I2V] \r [ds1_s6I2Z eta2_s6I30]
                  GHC.Read.$fReadMaybe1
                      $dRead_s6I2V
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_s6I30; } in
        let {
          sat_s6I3k [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_a6Hit)
          [LclId] =
              [ds_s6I2Y] \r [c_s6I31 eta2_s6I32]
                  case c_s6I31 of {
                    GHC.Types.I# x_s6I34 [Occ=Once] ->
                        case <=# [x_s6I34 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6I3h [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                [LclId] =
                                    [ds_s6I2Y eta2_s6I32] \r [a1_s6I36]
                                        let {
                                          sat_s6I3e [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                          [LclId] =
                                              [ds_s6I2Y eta2_s6I32] \r [a2_s6I37]
                                                  let {
                                                    sat_s6I3d [Occ=Once]
                                                      :: GHC.Base.Maybe a_a6Hit
                                                         -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                                    [LclId] =
                                                        [eta2_s6I32] \r [a3_s6I38]
                                                            let {
                                                              sat_s6I3a [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i6HIg
                                                              [LclId] =
                                                                  [eta2_s6I32
                                                                   a3_s6I38] \r [a4_s6I39]
                                                                      eta2_s6I32 a3_s6I38;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Monoid.$fReadFirst2
                                                                      sat_s6I3a
                                                              of
                                                              { Unit# ww1_s6I3c [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6I3c];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Monoid.$fReadLast2
                                                        ds_s6I2Y
                                                        Data.Monoid.$fReadFirst5
                                                        sat_s6I3d;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Monoid.$fReadFirst_lexeme sat_s6I3e
                                          of
                                          { Unit# ww1_s6I3g [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6I3g];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Monoid.$fReadLast_lexeme sat_s6I3h
                                of
                                { Unit# ww1_s6I3j [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6I3j];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6I3k eta_s6I2W eta1_s6I2X;

Data.Monoid.$fReadLast_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.Last a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_s6I3l n_s6I3m]
        let {
          sat_s6I3n [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Monoid.Last a_X6Hlg)
          [LclId] =
              [$dRead_s6I3l n_s6I3m] \u []
                  Data.Monoid.$fReadLast1
                      $dRead_s6I3l
                      n_s6I3m
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6I3n;

Data.Monoid.$fReadLast_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Monoid.Last a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6I3o]
        let {
          sat_s6I3p [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_X6Hle)
          [LclId] =
              [$dRead_s6I3o] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadLast1 $dRead_s6I3o eta_B2 eta_B1;
        } in  GHC.Read.list sat_s6I3p;

Data.Monoid.$fReadLast_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Monoid.Last a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6I3q]
        let {
          sat_s6I3s [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Monoid.Last a_X6Hlf]
          [LclId] =
              [$dRead_s6I3q] \u []
                  let {
                    sat_s6I3r [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Monoid.Last a_X6Hlf)
                    [LclId] =
                        [$dRead_s6I3q] \r [eta_B2 eta_B1]
                            Data.Monoid.$fReadLast1 $dRead_s6I3q eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s6I3r
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6I3s;

Data.Monoid.$fReadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s6I3t]
        let {
          sat_s6I3x [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Monoid.Last a_X6Hld]
          [LclId] =
              [$dRead_s6I3t] \u []
                  Data.Monoid.$fReadLast_$creadListPrec $dRead_s6I3t; } in
        let {
          sat_s6I3w [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_X6Hld)
          [LclId] =
              [$dRead_s6I3t] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadLast1 $dRead_s6I3t eta_B2 eta_B1; } in
        let {
          sat_s6I3v [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Monoid.Last a_X6Hld]
          [LclId] =
              [$dRead_s6I3t] \u []
                  Data.Monoid.$fReadLast_$creadList $dRead_s6I3t; } in
        let {
          sat_s6I3u [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.Last a_X6Hld)
          [LclId] =
              [$dRead_s6I3t] \r [eta_B1]
                  Data.Monoid.$fReadLast_$creadsPrec $dRead_s6I3t eta_B1;
        } in  GHC.Read.C:Read [sat_s6I3u sat_s6I3v sat_s6I3w sat_s6I3x];

Data.Monoid.$fEqLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s6I3y]
        let {
          sat_s6I3A [Occ=Once]
            :: Data.Monoid.Last a_a6Hg6
               -> Data.Monoid.Last a_a6Hg6 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6I3y] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_s6I3y eta_B2 eta_B1; } in
        let {
          sat_s6I3z [Occ=Once]
            :: Data.Monoid.Last a_a6Hg6
               -> Data.Monoid.Last a_a6Hg6 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6I3y] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_s6I3y eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s6I3z sat_s6I3A];

Data.Monoid.$fOrdLast_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Monoid.Last a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6I3B]
        let {
          sat_s6I3C [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_X6HjF
          [LclId] =
              [$dOrd_s6I3B] \u [] GHC.Classes.$p1Ord $dOrd_s6I3B;
        } in  Data.Monoid.$fEqLast sat_s6I3C;

Data.Monoid.$fOrdLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Monoid.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s6I3D]
        let {
          sat_s6I3N [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> Data.Monoid.Last a_X6HjG
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3M [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> Data.Monoid.Last a_X6HjG
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3L [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3K [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I3D] \r [a1_s6I3I b_s6I3J]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6I3D b_s6I3J a1_s6I3I; } in
        let {
          sat_s6I3H [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3G [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3F [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3E [Occ=Once] :: GHC.Classes.Eq (Data.Monoid.Last a_X6HjG)
          [LclId] =
              [$dOrd_s6I3D] \u [] Data.Monoid.$fOrdLast_$cp1Ord $dOrd_s6I3D;
        } in 
          GHC.Classes.C:Ord [sat_s6I3E
                             sat_s6I3F
                             sat_s6I3G
                             sat_s6I3H
                             sat_s6I3K
                             sat_s6I3L
                             sat_s6I3M
                             sat_s6I3N];

Data.Monoid.$fFunctorFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

Data.Monoid.$fApplicativeFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Monoid.$fFunctorFirst
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

Data.Monoid.$fMonadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Monoid.$fApplicativeFirst
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

Data.Monoid.$fGeneric1First1
  :: forall a.
     GHC.Generics.Rep1 Data.Monoid.First a
     -> GHC.Generics.Rep1 Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I3O] ds_s6I3O;

Data.Monoid.$fGeneric1First2
  :: forall a. Data.Monoid.First a -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6I3P] x_s6I3P;

Data.Monoid.$fGeneric1First [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Monoid.$fGeneric1First2
                                            Data.Monoid.$fGeneric1First1];

Data.Monoid.$fGenericFirst1
  :: forall a x.
     GHC.Generics.Rep (Data.Monoid.First a) x
     -> GHC.Generics.Rep (Data.Monoid.First a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I3Q] ds_s6I3Q;

Data.Monoid.$fGenericFirst2
  :: forall a x. Data.Monoid.First a -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6I3R] x1_s6I3R;

Data.Monoid.$fGenericFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Monoid.First a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Monoid.$fGenericFirst2
                                           Data.Monoid.$fGenericFirst1];

Data.Monoid.$fShowFirst3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First {"#;

Data.Monoid.$fShowFirst2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst = "#;

Data.Monoid.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Monoid.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6I3S ww_s6I3T w1_s6I3U]
        let {
          f_s6I3V [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6I3S w1_s6I3U] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_s6I3S Data.Monoid.$fShowFirst1 w1_s6I3U;
        } in 
          case >=# [ww_s6I3T 11#] of {
            __DEFAULT ->
                let {
                  sat_s6I41 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6I3V] \r [x_s6I3X]
                          let {
                            sat_s6I40 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6I3V x_s6I3X] \u []
                                    let {
                                      sat_s6I3Z [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6I3V x_s6I3X] \u []
                                              let {
                                                sat_s6I3Y [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6I3X] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Monoid.$fReadFirst4 x_s6I3X;
                                              } in  f_s6I3V sat_s6I3Y;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowFirst2 sat_s6I3Z;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Monoid.$fShowFirst3 sat_s6I40;
                } in  sat_s6I41;
            1# ->
                let {
                  sat_s6I48 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6I3V] \r [x_s6I42]
                          let {
                            sat_s6I47 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6I3V x_s6I42] \u []
                                    let {
                                      sat_s6I46 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6I3V x_s6I42] \u []
                                              let {
                                                sat_s6I45 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6I3V x_s6I42] \u []
                                                        let {
                                                          sat_s6I44 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6I42] \u []
                                                                  let {
                                                                    sat_s6I43 [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6I42];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Monoid.$fReadFirst4
                                                                        sat_s6I43;
                                                        } in  f_s6I3V sat_s6I44;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Monoid.$fShowFirst2 sat_s6I45;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowFirst3 sat_s6I46;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6I47];
                } in  sat_s6I48;
          };

Data.Monoid.$fShowFirst_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Monoid.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6I49 w1_s6I4a w2_s6I4b]
        case w1_s6I4a of {
          GHC.Types.I# ww1_s6I4d [Occ=Once] ->
              Data.Monoid.$w$cshowsPrec w_s6I49 ww1_s6I4d w2_s6I4b;
        };

Data.Monoid.$fShowFirst_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Monoid.First a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6I4e x_s6I4f]
        let {
          sat_s6I4k [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6I4e x_s6I4f] \u []
                  let {
                    sat_s6I4j [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6I4e x_s6I4f] \u []
                            case x_s6I4f of {
                              GHC.Base.Nothing -> Data.Monoid.$fShowFirst4;
                              GHC.Base.Just b1_s6I4h [Occ=Once] ->
                                  let {
                                    sat_s6I4i [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_s6I4e b1_s6I4h] \s []
                                            GHC.Show.showsPrec
                                                $dShow_s6I4e
                                                GHC.Show.appPrec1
                                                b1_s6I4h
                                                Data.Monoid.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_s6I4i;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Monoid.$fShowFirst2 sat_s6I4j;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Monoid.$fShowFirst3 sat_s6I4k;

Data.Monoid.$fShowFirst_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Monoid.First a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6I4l ls_s6I4m s_s6I4n]
        let {
          sat_s6I4p [Occ=Once] :: Data.Monoid.First a_a6H8s -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I4l] \r [w_s6I4o]
                  Data.Monoid.$w$cshowsPrec $dShow_s6I4l 0# w_s6I4o;
        } in  GHC.Show.showList__ sat_s6I4p ls_s6I4m s_s6I4n;

Data.Monoid.$fShowFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6I4q]
        let {
          sat_s6I4t [Occ=Once]
            :: [Data.Monoid.First a_a6H8s] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I4q] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowFirst_$cshowList $dShow_s6I4q eta_B2 eta_B1; } in
        let {
          sat_s6I4s [Occ=Once]
            :: Data.Monoid.First a_a6H8s -> GHC.Base.String
          [LclId] =
              [$dShow_s6I4q] \r [eta_B1]
                  Data.Monoid.$fShowFirst_$cshow $dShow_s6I4q eta_B1; } in
        let {
          sat_s6I4r [Occ=Once]
            :: GHC.Types.Int -> Data.Monoid.First a_a6H8s -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I4q] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowFirst_$cshowsPrec $dShow_s6I4q eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6I4r sat_s6I4s sat_s6I4t];

Data.Monoid.$fReadFirst11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First"#;

Data.Monoid.$fReadFirst10 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst11;

Data.Monoid.$fReadFirst_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Monoid.$fReadFirst10];

Data.Monoid.$fReadFirst7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst"#;

Data.Monoid.$fReadFirst6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst7;

Data.Monoid.$fReadFirst1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Monoid.First a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s6I4u eta_s6I4v eta1_s6I4w]
        let {
          ds_s6I4x [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_a6H7b -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_s6I4u] \r [ds1_s6I4y eta2_s6I4z]
                  GHC.Read.$fReadMaybe1
                      $dRead_s6I4u
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_s6I4z; } in
        let {
          sat_s6I4T [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_a6H7b)
          [LclId] =
              [ds_s6I4x] \r [c_s6I4A eta2_s6I4B]
                  case c_s6I4A of {
                    GHC.Types.I# x_s6I4D [Occ=Once] ->
                        case <=# [x_s6I4D 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6I4Q [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                [LclId] =
                                    [ds_s6I4x eta2_s6I4B] \r [a1_s6I4F]
                                        let {
                                          sat_s6I4N [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                          [LclId] =
                                              [ds_s6I4x eta2_s6I4B] \r [a2_s6I4G]
                                                  let {
                                                    sat_s6I4M [Occ=Once]
                                                      :: GHC.Base.Maybe a_a6H7b
                                                         -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                                    [LclId] =
                                                        [eta2_s6I4B] \r [a3_s6I4H]
                                                            let {
                                                              sat_s6I4J [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i6HIg
                                                              [LclId] =
                                                                  [eta2_s6I4B
                                                                   a3_s6I4H] \r [a4_s6I4I]
                                                                      eta2_s6I4B a3_s6I4H;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Monoid.$fReadFirst2
                                                                      sat_s6I4J
                                                              of
                                                              { Unit# ww1_s6I4L [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6I4L];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Monoid.$fReadFirst6
                                                        ds_s6I4x
                                                        Data.Monoid.$fReadFirst5
                                                        sat_s6I4M;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Monoid.$fReadFirst_lexeme sat_s6I4N
                                          of
                                          { Unit# ww1_s6I4P [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6I4P];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Monoid.$fReadFirst_lexeme1 sat_s6I4Q
                                of
                                { Unit# ww1_s6I4S [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6I4S];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6I4T eta_s6I4v eta1_s6I4w;

Data.Monoid.$fReadFirst_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.First a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_s6I4U n_s6I4V]
        let {
          sat_s6I4W [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Monoid.First a_X6HaX)
          [LclId] =
              [$dRead_s6I4U n_s6I4V] \u []
                  Data.Monoid.$fReadFirst1
                      $dRead_s6I4U
                      n_s6I4V
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6I4W;

Data.Monoid.$fReadFirst_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Monoid.First a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6I4X]
        let {
          sat_s6I4Y [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_X6HaV)
          [LclId] =
              [$dRead_s6I4X] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadFirst1 $dRead_s6I4X eta_B2 eta_B1;
        } in  GHC.Read.list sat_s6I4Y;

Data.Monoid.$fReadFirst_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Monoid.First a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6I4Z]
        let {
          sat_s6I51 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Monoid.First a_X6HaW]
          [LclId] =
              [$dRead_s6I4Z] \u []
                  let {
                    sat_s6I50 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Monoid.First a_X6HaW)
                    [LclId] =
                        [$dRead_s6I4Z] \r [eta_B2 eta_B1]
                            Data.Monoid.$fReadFirst1 $dRead_s6I4Z eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s6I50
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6I51;

Data.Monoid.$fReadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => GHC.Read.Read (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s6I52]
        let {
          sat_s6I56 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Monoid.First a_X6HaU]
          [LclId] =
              [$dRead_s6I52] \u []
                  Data.Monoid.$fReadFirst_$creadListPrec $dRead_s6I52; } in
        let {
          sat_s6I55 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_X6HaU)
          [LclId] =
              [$dRead_s6I52] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadFirst1 $dRead_s6I52 eta_B2 eta_B1; } in
        let {
          sat_s6I54 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Monoid.First a_X6HaU]
          [LclId] =
              [$dRead_s6I52] \u []
                  Data.Monoid.$fReadFirst_$creadList $dRead_s6I52; } in
        let {
          sat_s6I53 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.First a_X6HaU)
          [LclId] =
              [$dRead_s6I52] \r [eta_B1]
                  Data.Monoid.$fReadFirst_$creadsPrec $dRead_s6I52 eta_B1;
        } in  GHC.Read.C:Read [sat_s6I53 sat_s6I54 sat_s6I55 sat_s6I56];

Data.Monoid.$fEqFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s6I57]
        let {
          sat_s6I59 [Occ=Once]
            :: Data.Monoid.First a_a6H4O
               -> Data.Monoid.First a_a6H4O -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6I57] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_s6I57 eta_B2 eta_B1; } in
        let {
          sat_s6I58 [Occ=Once]
            :: Data.Monoid.First a_a6H4O
               -> Data.Monoid.First a_a6H4O -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6I57] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_s6I57 eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s6I58 sat_s6I59];

Data.Monoid.$fOrdFirst_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Monoid.First a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6I5a]
        let {
          sat_s6I5b [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_X6H9m
          [LclId] =
              [$dOrd_s6I5a] \u [] GHC.Classes.$p1Ord $dOrd_s6I5a;
        } in  Data.Monoid.$fEqFirst sat_s6I5b;

Data.Monoid.$fOrdFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Monoid.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s6I5c]
        let {
          sat_s6I5m [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> Data.Monoid.First a_X6H9n
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5l [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> Data.Monoid.First a_X6H9n
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5k [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5j [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I5c] \r [a1_s6I5h b_s6I5i]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6I5c b_s6I5i a1_s6I5h; } in
        let {
          sat_s6I5g [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5f [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5e [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5d [Occ=Once] :: GHC.Classes.Eq (Data.Monoid.First a_X6H9n)
          [LclId] =
              [$dOrd_s6I5c] \u [] Data.Monoid.$fOrdFirst_$cp1Ord $dOrd_s6I5c;
        } in 
          GHC.Classes.C:Ord [sat_s6I5d
                             sat_s6I5e
                             sat_s6I5f
                             sat_s6I5g
                             sat_s6I5j
                             sat_s6I5k
                             sat_s6I5l
                             sat_s6I5m];

Data.Monoid.getFirst
  :: forall a. Data.Monoid.First a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Monoid.$fGeneric1First2 eta_B1;

Data.Monoid.getLast
  :: forall a. Data.Monoid.Last a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Monoid.$fGeneric1Last2 eta_B1;

Data.Monoid.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Monoid.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$trModule4];

Data.Monoid.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Monoid"#;

Data.Monoid.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$trModule2];

Data.Monoid.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Monoid.$trModule3
                                     Data.Monoid.$trModule1];

$krep_r6I1r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_r6I1s :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r6I1r GHC.Types.[]];

$krep2_r6I1t :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep1_r6I1s];

Data.Monoid.$tcFirst1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$fReadFirst11];

Data.Monoid.$tcFirst :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12072287807032806756##
                                    12788244796562536401##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tcFirst1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep3_r6I1u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Monoid.$tcFirst
                                              $krep1_r6I1s];

Data.Monoid.$tc'First1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6I1t $krep3_r6I1u];

Data.Monoid.$tc'First3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'First"#;

Data.Monoid.$tc'First2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$tc'First3];

Data.Monoid.$tc'First :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7752528083504400280##
                                    15965132804789246607##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tc'First2
                                    1#
                                    Data.Monoid.$tc'First1];

Data.Monoid.$tcLast1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$fReadLast5];

Data.Monoid.$tcLast :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6920195955404695016##
                                    2388797855174213212##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tcLast1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_r6I1v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Monoid.$tcLast
                                              $krep1_r6I1s];

Data.Monoid.$tc'Last1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6I1t $krep4_r6I1v];

Data.Monoid.$tc'Last3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Last"#;

Data.Monoid.$tc'Last2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$tc'Last3];

Data.Monoid.$tc'Last :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5411164464353425083##
                                    12998161994081761510##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tc'Last2
                                    1#
                                    Data.Monoid.$tc'Last1];


==================== STG syntax: ====================
2018-03-16 16:01:56.799965799 UTC

Data.Monoid.$fMonoidFirst_$c<>
  :: forall a.
     Data.Monoid.First a -> Data.Monoid.First a -> Data.Monoid.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6I1x b_s6I1y]
        case ds_s6I1x of wild_s6I1z {
          GHC.Base.Nothing -> b_s6I1y;
          GHC.Base.Just _ [Occ=Dead] -> wild_s6I1z;
        };

Data.Monoid.$fSemigroupFirst1 [Occ=LoopBreaker]
  :: forall a.
     Data.Monoid.First a -> [Data.Monoid.First a] -> Data.Monoid.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6I1B ds1_s6I1C]
        case ds1_s6I1C of {
          [] -> b_s6I1B;
          : c_s6I1E [Occ=Once] cs_s6I1F [Occ=Once] ->
              case b_s6I1B of wild_s6I1G {
                GHC.Base.Nothing -> Data.Monoid.$fSemigroupFirst1 c_s6I1E cs_s6I1F;
                GHC.Base.Just _ [Occ=Dead] -> wild_s6I1G;
              };
        };

Data.Monoid.$fSemigroupFirst_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Monoid.First a) -> Data.Monoid.First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6I1I]
        case ds_s6I1I of {
          GHC.Base.:| a1_s6I1K [Occ=Once] as_s6I1L [Occ=Once] ->
              Data.Monoid.$fSemigroupFirst1 a1_s6I1K as_s6I1L;
        };

Data.Monoid.$fMonoidFirst_go [Occ=LoopBreaker]
  :: forall a. [Data.Monoid.First a] -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I1M]
        case ds_s6I1M of {
          [] -> GHC.Base.Nothing [];
          : y_s6I1O [Occ=Once] ys_s6I1P [Occ=Once] ->
              case y_s6I1O of wild1_s6I1Q {
                GHC.Base.Nothing -> Data.Monoid.$fMonoidFirst_go ys_s6I1P;
                GHC.Base.Just _ [Occ=Dead] -> wild1_s6I1Q;
              };
        };

Data.Monoid.$fSemigroupFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Monoid.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Monoid.$fMonoidFirst_$c<>
                                         Data.Monoid.$fSemigroupFirst_$csconcat
                                         Data.Monoid.$fSemigroupFirst_$cstimes];
Data.Monoid.$fMonoidFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Monoid.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Monoid.$fSemigroupFirst
                                      GHC.Base.Nothing
                                      Data.Monoid.$fMonoidFirst_$c<>
                                      Data.Monoid.$fMonoidFirst_go];
Data.Monoid.$fSemigroupFirst_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Monoid.First a -> Data.Monoid.First a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6I1S eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6I1S Data.Monoid.$fMonoidFirst eta_B2 eta_B1;

Data.Monoid.$fMonoidLast_$c<>
  :: forall a.
     Data.Monoid.Last a -> Data.Monoid.Last a -> Data.Monoid.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6I1T ds_s6I1U]
        case ds_s6I1U of wild_s6I1V {
          GHC.Base.Nothing -> a1_s6I1T;
          GHC.Base.Just _ [Occ=Dead] -> wild_s6I1V;
        };

Data.Monoid.$fSemigroupLast1 [Occ=LoopBreaker]
  :: forall a.
     Data.Monoid.Last a -> [Data.Monoid.Last a] -> Data.Monoid.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6I1X ds1_s6I1Y]
        case ds1_s6I1Y of {
          [] -> b_s6I1X;
          : c_s6I20 [Occ=Once] cs_s6I21 [Occ=Once] ->
              case Data.Monoid.$fSemigroupLast1 c_s6I20 cs_s6I21 of wild_s6I22 {
                GHC.Base.Nothing -> b_s6I1X;
                GHC.Base.Just _ [Occ=Dead] -> wild_s6I22;
              };
        };

Data.Monoid.$fSemigroupLast_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Monoid.Last a) -> Data.Monoid.Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6I24]
        case ds_s6I24 of {
          GHC.Base.:| a1_s6I26 [Occ=Once] as_s6I27 [Occ=Once] ->
              Data.Monoid.$fSemigroupLast1 a1_s6I26 as_s6I27;
        };

Data.Monoid.$fMonoidLast_go [Occ=LoopBreaker]
  :: forall a. [Data.Monoid.Last a] -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I28]
        case ds_s6I28 of {
          [] -> GHC.Base.Nothing [];
          : y_s6I2a [Occ=Once] ys_s6I2b [Occ=Once] ->
              case Data.Monoid.$fMonoidLast_go ys_s6I2b of wild1_s6I2c {
                GHC.Base.Nothing -> y_s6I2a;
                GHC.Base.Just _ [Occ=Dead] -> wild1_s6I2c;
              };
        };

Data.Monoid.$fSemigroupLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Monoid.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Monoid.$fMonoidLast_$c<>
                                         Data.Monoid.$fSemigroupLast_$csconcat
                                         Data.Monoid.$fSemigroupLast_$cstimes];
Data.Monoid.$fMonoidLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Monoid.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Monoid.$fSemigroupLast
                                      GHC.Base.Nothing
                                      Data.Monoid.$fMonoidLast_$c<>
                                      Data.Monoid.$fMonoidLast_go];
Data.Monoid.$fSemigroupLast_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Monoid.Last a -> Data.Monoid.Last a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6I2e eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6I2e Data.Monoid.$fMonoidLast eta_B2 eta_B1;

Data.Monoid.$fFunctorLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

Data.Monoid.$fApplicativeLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Monoid.$fFunctorLast
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

Data.Monoid.$fMonadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Monoid.$fApplicativeLast
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

Data.Monoid.$fGeneric1Last1
  :: forall a.
     GHC.Generics.Rep1 Data.Monoid.Last a
     -> GHC.Generics.Rep1 Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I2f] ds_s6I2f;

Data.Monoid.$fGeneric1Last2
  :: forall a. Data.Monoid.Last a -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6I2g] x_s6I2g;

Data.Monoid.$fGeneric1Last [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Monoid.$fGeneric1Last2
                                            Data.Monoid.$fGeneric1Last1];

Data.Monoid.$fGenericLast1
  :: forall a x.
     GHC.Generics.Rep (Data.Monoid.Last a) x
     -> GHC.Generics.Rep (Data.Monoid.Last a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I2h] ds_s6I2h;

Data.Monoid.$fGenericLast2
  :: forall a x. Data.Monoid.Last a -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6I2i] x1_s6I2i;

Data.Monoid.$fGenericLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Monoid.Last a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Monoid.$fGenericLast2
                                           Data.Monoid.$fGenericLast1];

Data.Monoid.$fShowFirst1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Monoid.$fShowLast2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last {"#;

Data.Monoid.$fShowLast1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast = "#;

Data.Monoid.$fReadFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Monoid.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Monoid.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6I2j ww_s6I2k w1_s6I2l]
        let {
          f_s6I2m [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6I2j w1_s6I2l] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_s6I2j Data.Monoid.$fShowFirst1 w1_s6I2l;
        } in 
          case >=# [ww_s6I2k 11#] of {
            __DEFAULT ->
                let {
                  sat_s6I2s [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6I2m] \r [x_s6I2o]
                          let {
                            sat_s6I2r [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6I2m x_s6I2o] \u []
                                    let {
                                      sat_s6I2q [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6I2m x_s6I2o] \u []
                                              let {
                                                sat_s6I2p [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6I2o] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Monoid.$fReadFirst4 x_s6I2o;
                                              } in  f_s6I2m sat_s6I2p;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowLast1 sat_s6I2q;
                          } in 
                            GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast2 sat_s6I2r;
                } in  sat_s6I2s;
            1# ->
                let {
                  sat_s6I2z [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6I2m] \r [x_s6I2t]
                          let {
                            sat_s6I2y [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6I2m x_s6I2t] \u []
                                    let {
                                      sat_s6I2x [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6I2m x_s6I2t] \u []
                                              let {
                                                sat_s6I2w [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6I2m x_s6I2t] \u []
                                                        let {
                                                          sat_s6I2v [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6I2t] \u []
                                                                  let {
                                                                    sat_s6I2u [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6I2t];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Monoid.$fReadFirst4
                                                                        sat_s6I2u;
                                                        } in  f_s6I2m sat_s6I2v;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Monoid.$fShowLast1 sat_s6I2w;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowLast2 sat_s6I2x;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6I2y];
                } in  sat_s6I2z;
          };

Data.Monoid.$fShowLast_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Monoid.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6I2A w1_s6I2B w2_s6I2C]
        case w1_s6I2B of {
          GHC.Types.I# ww1_s6I2E [Occ=Once] ->
              Data.Monoid.$w$cshowsPrec1 w_s6I2A ww1_s6I2E w2_s6I2C;
        };

Data.Monoid.$fReadFirst3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst4;

Data.Monoid.$fShowFirst4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++ GHC.Show.$fShowMaybe4 Data.Monoid.$fReadFirst3;

Data.Monoid.$fShowLast_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Monoid.Last a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6I2F x_s6I2G]
        let {
          sat_s6I2L [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6I2F x_s6I2G] \u []
                  let {
                    sat_s6I2K [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6I2F x_s6I2G] \u []
                            case x_s6I2G of {
                              GHC.Base.Nothing -> Data.Monoid.$fShowFirst4;
                              GHC.Base.Just b1_s6I2I [Occ=Once] ->
                                  let {
                                    sat_s6I2J [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_s6I2F b1_s6I2I] \s []
                                            GHC.Show.showsPrec
                                                $dShow_s6I2F
                                                GHC.Show.appPrec1
                                                b1_s6I2I
                                                Data.Monoid.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_s6I2J;
                            };
                  } in 
                    GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast1 sat_s6I2K;
        } in 
          GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast2 sat_s6I2L;

Data.Monoid.$fShowLast_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Monoid.Last a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6I2M ls_s6I2N s_s6I2O]
        let {
          sat_s6I2Q [Occ=Once] :: Data.Monoid.Last a_a6Hji -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I2M] \r [w_s6I2P]
                  Data.Monoid.$w$cshowsPrec1 $dShow_s6I2M 0# w_s6I2P;
        } in  GHC.Show.showList__ sat_s6I2Q ls_s6I2N s_s6I2O;

Data.Monoid.$fShowLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6I2R]
        let {
          sat_s6I2U [Occ=Once]
            :: [Data.Monoid.Last a_a6Hji] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I2R] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowLast_$cshowList $dShow_s6I2R eta_B2 eta_B1; } in
        let {
          sat_s6I2T [Occ=Once] :: Data.Monoid.Last a_a6Hji -> GHC.Base.String
          [LclId] =
              [$dShow_s6I2R] \r [eta_B1]
                  Data.Monoid.$fShowLast_$cshow $dShow_s6I2R eta_B1; } in
        let {
          sat_s6I2S [Occ=Once]
            :: GHC.Types.Int -> Data.Monoid.Last a_a6Hji -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I2R] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowLast_$cshowsPrec $dShow_s6I2R eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6I2S sat_s6I2T sat_s6I2U];

Data.Monoid.$fReadLast5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last"#;

Data.Monoid.$fReadLast4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadLast5;

Data.Monoid.$fReadLast_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Monoid.$fReadLast4];

Data.Monoid.$fReadFirst9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Monoid.$fReadFirst8 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst9;

Data.Monoid.$fReadFirst_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Monoid.$fReadFirst8];

Data.Monoid.$fReadLast3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast"#;

Data.Monoid.$fReadLast2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadLast3;

Data.Monoid.$fReadFirst5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Monoid.$fReadFirst2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Monoid.$fReadFirst3];

Data.Monoid.$fReadLast1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Monoid.Last a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s6I2V eta_s6I2W eta1_s6I2X]
        let {
          ds_s6I2Y [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_a6Hit -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_s6I2V] \r [ds1_s6I2Z eta2_s6I30]
                  GHC.Read.$fReadMaybe1
                      $dRead_s6I2V
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_s6I30; } in
        let {
          sat_s6I3k [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_a6Hit)
          [LclId] =
              [ds_s6I2Y] \r [c_s6I31 eta2_s6I32]
                  case c_s6I31 of {
                    GHC.Types.I# x_s6I34 [Occ=Once] ->
                        case <=# [x_s6I34 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6I3h [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                [LclId] =
                                    [ds_s6I2Y eta2_s6I32] \r [a1_s6I36]
                                        let {
                                          sat_s6I3e [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                          [LclId] =
                                              [ds_s6I2Y eta2_s6I32] \r [a2_s6I37]
                                                  let {
                                                    sat_s6I3d [Occ=Once]
                                                      :: GHC.Base.Maybe a_a6Hit
                                                         -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                                    [LclId] =
                                                        [eta2_s6I32] \r [a3_s6I38]
                                                            let {
                                                              sat_s6I3a [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i6HIg
                                                              [LclId] =
                                                                  [eta2_s6I32
                                                                   a3_s6I38] \r [a4_s6I39]
                                                                      eta2_s6I32 a3_s6I38;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Monoid.$fReadFirst2
                                                                      sat_s6I3a
                                                              of
                                                              { Unit# ww1_s6I3c [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6I3c];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Monoid.$fReadLast2
                                                        ds_s6I2Y
                                                        Data.Monoid.$fReadFirst5
                                                        sat_s6I3d;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Monoid.$fReadFirst_lexeme sat_s6I3e
                                          of
                                          { Unit# ww1_s6I3g [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6I3g];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Monoid.$fReadLast_lexeme sat_s6I3h
                                of
                                { Unit# ww1_s6I3j [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6I3j];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6I3k eta_s6I2W eta1_s6I2X;

Data.Monoid.$fReadLast_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.Last a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_s6I3l n_s6I3m]
        let {
          sat_s6I3n [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Monoid.Last a_X6Hlg)
          [LclId] =
              [$dRead_s6I3l n_s6I3m] \u []
                  Data.Monoid.$fReadLast1
                      $dRead_s6I3l
                      n_s6I3m
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6I3n;

Data.Monoid.$fReadLast_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Monoid.Last a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6I3o]
        let {
          sat_s6I3p [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_X6Hle)
          [LclId] =
              [$dRead_s6I3o] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadLast1 $dRead_s6I3o eta_B2 eta_B1;
        } in  GHC.Read.list sat_s6I3p;

Data.Monoid.$fReadLast_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Monoid.Last a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6I3q]
        let {
          sat_s6I3s [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Monoid.Last a_X6Hlf]
          [LclId] =
              [$dRead_s6I3q] \u []
                  let {
                    sat_s6I3r [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Monoid.Last a_X6Hlf)
                    [LclId] =
                        [$dRead_s6I3q] \r [eta_B2 eta_B1]
                            Data.Monoid.$fReadLast1 $dRead_s6I3q eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s6I3r
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6I3s;

Data.Monoid.$fReadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s6I3t]
        let {
          sat_s6I3x [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Monoid.Last a_X6Hld]
          [LclId] =
              [$dRead_s6I3t] \u []
                  Data.Monoid.$fReadLast_$creadListPrec $dRead_s6I3t; } in
        let {
          sat_s6I3w [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_X6Hld)
          [LclId] =
              [$dRead_s6I3t] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadLast1 $dRead_s6I3t eta_B2 eta_B1; } in
        let {
          sat_s6I3v [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Monoid.Last a_X6Hld]
          [LclId] =
              [$dRead_s6I3t] \u []
                  Data.Monoid.$fReadLast_$creadList $dRead_s6I3t; } in
        let {
          sat_s6I3u [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.Last a_X6Hld)
          [LclId] =
              [$dRead_s6I3t] \r [eta_B1]
                  Data.Monoid.$fReadLast_$creadsPrec $dRead_s6I3t eta_B1;
        } in  GHC.Read.C:Read [sat_s6I3u sat_s6I3v sat_s6I3w sat_s6I3x];

Data.Monoid.$fEqLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s6I3y]
        let {
          sat_s6I3A [Occ=Once]
            :: Data.Monoid.Last a_a6Hg6
               -> Data.Monoid.Last a_a6Hg6 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6I3y] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_s6I3y eta_B2 eta_B1; } in
        let {
          sat_s6I3z [Occ=Once]
            :: Data.Monoid.Last a_a6Hg6
               -> Data.Monoid.Last a_a6Hg6 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6I3y] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_s6I3y eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s6I3z sat_s6I3A];

Data.Monoid.$fOrdLast_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Monoid.Last a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6I3B]
        let {
          sat_s6I3C [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_X6HjF
          [LclId] =
              [$dOrd_s6I3B] \u [] GHC.Classes.$p1Ord $dOrd_s6I3B;
        } in  Data.Monoid.$fEqLast sat_s6I3C;

Data.Monoid.$fOrdLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Monoid.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s6I3D]
        let {
          sat_s6I3N [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> Data.Monoid.Last a_X6HjG
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3M [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> Data.Monoid.Last a_X6HjG
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3L [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3K [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I3D] \r [a1_s6I3I b_s6I3J]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6I3D b_s6I3J a1_s6I3I; } in
        let {
          sat_s6I3H [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3G [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3F [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6I3D] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_s6I3D eta_B2 eta_B1; } in
        let {
          sat_s6I3E [Occ=Once] :: GHC.Classes.Eq (Data.Monoid.Last a_X6HjG)
          [LclId] =
              [$dOrd_s6I3D] \u [] Data.Monoid.$fOrdLast_$cp1Ord $dOrd_s6I3D;
        } in 
          GHC.Classes.C:Ord [sat_s6I3E
                             sat_s6I3F
                             sat_s6I3G
                             sat_s6I3H
                             sat_s6I3K
                             sat_s6I3L
                             sat_s6I3M
                             sat_s6I3N];

Data.Monoid.$fFunctorFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

Data.Monoid.$fApplicativeFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Monoid.$fFunctorFirst
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

Data.Monoid.$fMonadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Monoid.$fApplicativeFirst
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

Data.Monoid.$fGeneric1First1
  :: forall a.
     GHC.Generics.Rep1 Data.Monoid.First a
     -> GHC.Generics.Rep1 Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I3O] ds_s6I3O;

Data.Monoid.$fGeneric1First2
  :: forall a. Data.Monoid.First a -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6I3P] x_s6I3P;

Data.Monoid.$fGeneric1First [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Monoid.$fGeneric1First2
                                            Data.Monoid.$fGeneric1First1];

Data.Monoid.$fGenericFirst1
  :: forall a x.
     GHC.Generics.Rep (Data.Monoid.First a) x
     -> GHC.Generics.Rep (Data.Monoid.First a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6I3Q] ds_s6I3Q;

Data.Monoid.$fGenericFirst2
  :: forall a x. Data.Monoid.First a -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6I3R] x1_s6I3R;

Data.Monoid.$fGenericFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Monoid.First a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Monoid.$fGenericFirst2
                                           Data.Monoid.$fGenericFirst1];

Data.Monoid.$fShowFirst3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First {"#;

Data.Monoid.$fShowFirst2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst = "#;

Data.Monoid.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Monoid.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6I3S ww_s6I3T w1_s6I3U]
        let {
          f_s6I3V [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6I3S w1_s6I3U] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_s6I3S Data.Monoid.$fShowFirst1 w1_s6I3U;
        } in 
          case >=# [ww_s6I3T 11#] of {
            __DEFAULT ->
                let {
                  sat_s6I41 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6I3V] \r [x_s6I3X]
                          let {
                            sat_s6I40 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6I3V x_s6I3X] \u []
                                    let {
                                      sat_s6I3Z [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6I3V x_s6I3X] \u []
                                              let {
                                                sat_s6I3Y [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6I3X] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Monoid.$fReadFirst4 x_s6I3X;
                                              } in  f_s6I3V sat_s6I3Y;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowFirst2 sat_s6I3Z;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Monoid.$fShowFirst3 sat_s6I40;
                } in  sat_s6I41;
            1# ->
                let {
                  sat_s6I48 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6I3V] \r [x_s6I42]
                          let {
                            sat_s6I47 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6I3V x_s6I42] \u []
                                    let {
                                      sat_s6I46 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6I3V x_s6I42] \u []
                                              let {
                                                sat_s6I45 [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6I3V x_s6I42] \u []
                                                        let {
                                                          sat_s6I44 [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6I42] \u []
                                                                  let {
                                                                    sat_s6I43 [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6I42];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Monoid.$fReadFirst4
                                                                        sat_s6I43;
                                                        } in  f_s6I3V sat_s6I44;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Monoid.$fShowFirst2 sat_s6I45;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowFirst3 sat_s6I46;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6I47];
                } in  sat_s6I48;
          };

Data.Monoid.$fShowFirst_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Monoid.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6I49 w1_s6I4a w2_s6I4b]
        case w1_s6I4a of {
          GHC.Types.I# ww1_s6I4d [Occ=Once] ->
              Data.Monoid.$w$cshowsPrec w_s6I49 ww1_s6I4d w2_s6I4b;
        };

Data.Monoid.$fShowFirst_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Monoid.First a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6I4e x_s6I4f]
        let {
          sat_s6I4k [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6I4e x_s6I4f] \u []
                  let {
                    sat_s6I4j [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6I4e x_s6I4f] \u []
                            case x_s6I4f of {
                              GHC.Base.Nothing -> Data.Monoid.$fShowFirst4;
                              GHC.Base.Just b1_s6I4h [Occ=Once] ->
                                  let {
                                    sat_s6I4i [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_s6I4e b1_s6I4h] \s []
                                            GHC.Show.showsPrec
                                                $dShow_s6I4e
                                                GHC.Show.appPrec1
                                                b1_s6I4h
                                                Data.Monoid.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_s6I4i;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Monoid.$fShowFirst2 sat_s6I4j;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Monoid.$fShowFirst3 sat_s6I4k;

Data.Monoid.$fShowFirst_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Monoid.First a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6I4l ls_s6I4m s_s6I4n]
        let {
          sat_s6I4p [Occ=Once] :: Data.Monoid.First a_a6H8s -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I4l] \r [w_s6I4o]
                  Data.Monoid.$w$cshowsPrec $dShow_s6I4l 0# w_s6I4o;
        } in  GHC.Show.showList__ sat_s6I4p ls_s6I4m s_s6I4n;

Data.Monoid.$fShowFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6I4q]
        let {
          sat_s6I4t [Occ=Once]
            :: [Data.Monoid.First a_a6H8s] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I4q] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowFirst_$cshowList $dShow_s6I4q eta_B2 eta_B1; } in
        let {
          sat_s6I4s [Occ=Once]
            :: Data.Monoid.First a_a6H8s -> GHC.Base.String
          [LclId] =
              [$dShow_s6I4q] \r [eta_B1]
                  Data.Monoid.$fShowFirst_$cshow $dShow_s6I4q eta_B1; } in
        let {
          sat_s6I4r [Occ=Once]
            :: GHC.Types.Int -> Data.Monoid.First a_a6H8s -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6I4q] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowFirst_$cshowsPrec $dShow_s6I4q eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6I4r sat_s6I4s sat_s6I4t];

Data.Monoid.$fReadFirst11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First"#;

Data.Monoid.$fReadFirst10 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst11;

Data.Monoid.$fReadFirst_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Monoid.$fReadFirst10];

Data.Monoid.$fReadFirst7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst"#;

Data.Monoid.$fReadFirst6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst7;

Data.Monoid.$fReadFirst1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Monoid.First a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s6I4u eta_s6I4v eta1_s6I4w]
        let {
          ds_s6I4x [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_a6H7b -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_s6I4u] \r [ds1_s6I4y eta2_s6I4z]
                  GHC.Read.$fReadMaybe1
                      $dRead_s6I4u
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_s6I4z; } in
        let {
          sat_s6I4T [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_a6H7b)
          [LclId] =
              [ds_s6I4x] \r [c_s6I4A eta2_s6I4B]
                  case c_s6I4A of {
                    GHC.Types.I# x_s6I4D [Occ=Once] ->
                        case <=# [x_s6I4D 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6I4Q [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                [LclId] =
                                    [ds_s6I4x eta2_s6I4B] \r [a1_s6I4F]
                                        let {
                                          sat_s6I4N [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                          [LclId] =
                                              [ds_s6I4x eta2_s6I4B] \r [a2_s6I4G]
                                                  let {
                                                    sat_s6I4M [Occ=Once]
                                                      :: GHC.Base.Maybe a_a6H7b
                                                         -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                                    [LclId] =
                                                        [eta2_s6I4B] \r [a3_s6I4H]
                                                            let {
                                                              sat_s6I4J [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i6HIg
                                                              [LclId] =
                                                                  [eta2_s6I4B
                                                                   a3_s6I4H] \r [a4_s6I4I]
                                                                      eta2_s6I4B a3_s6I4H;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Monoid.$fReadFirst2
                                                                      sat_s6I4J
                                                              of
                                                              { Unit# ww1_s6I4L [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6I4L];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Monoid.$fReadFirst6
                                                        ds_s6I4x
                                                        Data.Monoid.$fReadFirst5
                                                        sat_s6I4M;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Monoid.$fReadFirst_lexeme sat_s6I4N
                                          of
                                          { Unit# ww1_s6I4P [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6I4P];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Monoid.$fReadFirst_lexeme1 sat_s6I4Q
                                of
                                { Unit# ww1_s6I4S [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6I4S];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6I4T eta_s6I4v eta1_s6I4w;

Data.Monoid.$fReadFirst_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.First a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_s6I4U n_s6I4V]
        let {
          sat_s6I4W [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Monoid.First a_X6HaX)
          [LclId] =
              [$dRead_s6I4U n_s6I4V] \u []
                  Data.Monoid.$fReadFirst1
                      $dRead_s6I4U
                      n_s6I4V
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6I4W;

Data.Monoid.$fReadFirst_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Monoid.First a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6I4X]
        let {
          sat_s6I4Y [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_X6HaV)
          [LclId] =
              [$dRead_s6I4X] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadFirst1 $dRead_s6I4X eta_B2 eta_B1;
        } in  GHC.Read.list sat_s6I4Y;

Data.Monoid.$fReadFirst_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Monoid.First a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6I4Z]
        let {
          sat_s6I51 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Monoid.First a_X6HaW]
          [LclId] =
              [$dRead_s6I4Z] \u []
                  let {
                    sat_s6I50 [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Monoid.First a_X6HaW)
                    [LclId] =
                        [$dRead_s6I4Z] \r [eta_B2 eta_B1]
                            Data.Monoid.$fReadFirst1 $dRead_s6I4Z eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s6I50
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6I51;

Data.Monoid.$fReadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => GHC.Read.Read (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s6I52]
        let {
          sat_s6I56 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Monoid.First a_X6HaU]
          [LclId] =
              [$dRead_s6I52] \u []
                  Data.Monoid.$fReadFirst_$creadListPrec $dRead_s6I52; } in
        let {
          sat_s6I55 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_X6HaU)
          [LclId] =
              [$dRead_s6I52] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadFirst1 $dRead_s6I52 eta_B2 eta_B1; } in
        let {
          sat_s6I54 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Monoid.First a_X6HaU]
          [LclId] =
              [$dRead_s6I52] \u []
                  Data.Monoid.$fReadFirst_$creadList $dRead_s6I52; } in
        let {
          sat_s6I53 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.First a_X6HaU)
          [LclId] =
              [$dRead_s6I52] \r [eta_B1]
                  Data.Monoid.$fReadFirst_$creadsPrec $dRead_s6I52 eta_B1;
        } in  GHC.Read.C:Read [sat_s6I53 sat_s6I54 sat_s6I55 sat_s6I56];

Data.Monoid.$fEqFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s6I57]
        let {
          sat_s6I59 [Occ=Once]
            :: Data.Monoid.First a_a6H4O
               -> Data.Monoid.First a_a6H4O -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6I57] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_s6I57 eta_B2 eta_B1; } in
        let {
          sat_s6I58 [Occ=Once]
            :: Data.Monoid.First a_a6H4O
               -> Data.Monoid.First a_a6H4O -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6I57] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_s6I57 eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s6I58 sat_s6I59];

Data.Monoid.$fOrdFirst_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Monoid.First a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6I5a]
        let {
          sat_s6I5b [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_X6H9m
          [LclId] =
              [$dOrd_s6I5a] \u [] GHC.Classes.$p1Ord $dOrd_s6I5a;
        } in  Data.Monoid.$fEqFirst sat_s6I5b;

Data.Monoid.$fOrdFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Monoid.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s6I5c]
        let {
          sat_s6I5m [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> Data.Monoid.First a_X6H9n
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5l [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> Data.Monoid.First a_X6H9n
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5k [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5j [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I5c] \r [a1_s6I5h b_s6I5i]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6I5c b_s6I5i a1_s6I5h; } in
        let {
          sat_s6I5g [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5f [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5e [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6I5c] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_s6I5c eta_B2 eta_B1; } in
        let {
          sat_s6I5d [Occ=Once] :: GHC.Classes.Eq (Data.Monoid.First a_X6H9n)
          [LclId] =
              [$dOrd_s6I5c] \u [] Data.Monoid.$fOrdFirst_$cp1Ord $dOrd_s6I5c;
        } in 
          GHC.Classes.C:Ord [sat_s6I5d
                             sat_s6I5e
                             sat_s6I5f
                             sat_s6I5g
                             sat_s6I5j
                             sat_s6I5k
                             sat_s6I5l
                             sat_s6I5m];

Data.Monoid.getFirst
  :: forall a. Data.Monoid.First a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Monoid.$fGeneric1First2 eta_B1;

Data.Monoid.getLast
  :: forall a. Data.Monoid.Last a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Monoid.$fGeneric1Last2 eta_B1;

Data.Monoid.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Monoid.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$trModule4];

Data.Monoid.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Monoid"#;

Data.Monoid.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$trModule2];

Data.Monoid.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Monoid.$trModule3
                                     Data.Monoid.$trModule1];

$krep_r6I1r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_r6I1s :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r6I1r GHC.Types.[]];

$krep2_r6I1t :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep1_r6I1s];

Data.Monoid.$tcFirst1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$fReadFirst11];

Data.Monoid.$tcFirst :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12072287807032806756##
                                    12788244796562536401##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tcFirst1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep3_r6I1u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Monoid.$tcFirst
                                              $krep1_r6I1s];

Data.Monoid.$tc'First1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6I1t $krep3_r6I1u];

Data.Monoid.$tc'First3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'First"#;

Data.Monoid.$tc'First2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$tc'First3];

Data.Monoid.$tc'First :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7752528083504400280##
                                    15965132804789246607##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tc'First2
                                    1#
                                    Data.Monoid.$tc'First1];

Data.Monoid.$tcLast1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$fReadLast5];

Data.Monoid.$tcLast :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6920195955404695016##
                                    2388797855174213212##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tcLast1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_r6I1v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Monoid.$tcLast
                                              $krep1_r6I1s];

Data.Monoid.$tc'Last1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6I1t $krep4_r6I1v];

Data.Monoid.$tc'Last3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Last"#;

Data.Monoid.$tc'Last2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$tc'Last3];

Data.Monoid.$tc'Last :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5411164464353425083##
                                    12998161994081761510##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tc'Last2
                                    1#
                                    Data.Monoid.$tc'Last1];


==================== Pre unarise: ====================
2018-03-16 16:01:59.102563601 UTC

Data.Monoid.$fMonoidFirst_$c<>
  :: forall a.
     Data.Monoid.First a -> Data.Monoid.First a -> Data.Monoid.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6Jpq b_s6Jpr]
        case ds_s6Jpq of wild_s6Jps {
          GHC.Base.Nothing -> b_s6Jpr;
          GHC.Base.Just _ [Occ=Dead] -> wild_s6Jps;
        };

Data.Monoid.$fSemigroupFirst1 [Occ=LoopBreaker]
  :: forall a.
     Data.Monoid.First a -> [Data.Monoid.First a] -> Data.Monoid.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6Jpu ds1_s6Jpv]
        case ds1_s6Jpv of {
          [] -> b_s6Jpu;
          : c_s6Jpx [Occ=Once] cs_s6Jpy [Occ=Once] ->
              case b_s6Jpu of wild_s6Jpz {
                GHC.Base.Nothing -> Data.Monoid.$fSemigroupFirst1 c_s6Jpx cs_s6Jpy;
                GHC.Base.Just _ [Occ=Dead] -> wild_s6Jpz;
              };
        };

Data.Monoid.$fSemigroupFirst_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Monoid.First a) -> Data.Monoid.First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6JpB]
        case ds_s6JpB of {
          GHC.Base.:| a1_s6JpD [Occ=Once] as_s6JpE [Occ=Once] ->
              Data.Monoid.$fSemigroupFirst1 a1_s6JpD as_s6JpE;
        };

Data.Monoid.$fMonoidFirst_go [Occ=LoopBreaker]
  :: forall a. [Data.Monoid.First a] -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6JpF]
        case ds_s6JpF of {
          [] -> GHC.Base.Nothing [];
          : y_s6JpH [Occ=Once] ys_s6JpI [Occ=Once] ->
              case y_s6JpH of wild1_s6JpJ {
                GHC.Base.Nothing -> Data.Monoid.$fMonoidFirst_go ys_s6JpI;
                GHC.Base.Just _ [Occ=Dead] -> wild1_s6JpJ;
              };
        };

Data.Monoid.$fSemigroupFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Monoid.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Monoid.$fMonoidFirst_$c<>
                                         Data.Monoid.$fSemigroupFirst_$csconcat
                                         Data.Monoid.$fSemigroupFirst_$cstimes];
Data.Monoid.$fMonoidFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Monoid.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Monoid.$fSemigroupFirst
                                      GHC.Base.Nothing
                                      Data.Monoid.$fMonoidFirst_$c<>
                                      Data.Monoid.$fMonoidFirst_go];
Data.Monoid.$fSemigroupFirst_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Monoid.First a -> Data.Monoid.First a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6JpL eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6JpL Data.Monoid.$fMonoidFirst eta_B2 eta_B1;

Data.Monoid.$fMonoidLast_$c<>
  :: forall a.
     Data.Monoid.Last a -> Data.Monoid.Last a -> Data.Monoid.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6JpM ds_s6JpN]
        case ds_s6JpN of wild_s6JpO {
          GHC.Base.Nothing -> a1_s6JpM;
          GHC.Base.Just _ [Occ=Dead] -> wild_s6JpO;
        };

Data.Monoid.$fSemigroupLast1 [Occ=LoopBreaker]
  :: forall a.
     Data.Monoid.Last a -> [Data.Monoid.Last a] -> Data.Monoid.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6JpQ ds1_s6JpR]
        case ds1_s6JpR of {
          [] -> b_s6JpQ;
          : c_s6JpT [Occ=Once] cs_s6JpU [Occ=Once] ->
              case Data.Monoid.$fSemigroupLast1 c_s6JpT cs_s6JpU of wild_s6JpV {
                GHC.Base.Nothing -> b_s6JpQ;
                GHC.Base.Just _ [Occ=Dead] -> wild_s6JpV;
              };
        };

Data.Monoid.$fSemigroupLast_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Monoid.Last a) -> Data.Monoid.Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6JpX]
        case ds_s6JpX of {
          GHC.Base.:| a1_s6JpZ [Occ=Once] as_s6Jq0 [Occ=Once] ->
              Data.Monoid.$fSemigroupLast1 a1_s6JpZ as_s6Jq0;
        };

Data.Monoid.$fMonoidLast_go [Occ=LoopBreaker]
  :: forall a. [Data.Monoid.Last a] -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6Jq1]
        case ds_s6Jq1 of {
          [] -> GHC.Base.Nothing [];
          : y_s6Jq3 [Occ=Once] ys_s6Jq4 [Occ=Once] ->
              case Data.Monoid.$fMonoidLast_go ys_s6Jq4 of wild1_s6Jq5 {
                GHC.Base.Nothing -> y_s6Jq3;
                GHC.Base.Just _ [Occ=Dead] -> wild1_s6Jq5;
              };
        };

Data.Monoid.$fSemigroupLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Monoid.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Monoid.$fMonoidLast_$c<>
                                         Data.Monoid.$fSemigroupLast_$csconcat
                                         Data.Monoid.$fSemigroupLast_$cstimes];
Data.Monoid.$fMonoidLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Monoid.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Monoid.$fSemigroupLast
                                      GHC.Base.Nothing
                                      Data.Monoid.$fMonoidLast_$c<>
                                      Data.Monoid.$fMonoidLast_go];
Data.Monoid.$fSemigroupLast_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Monoid.Last a -> Data.Monoid.Last a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6Jq7 eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6Jq7 Data.Monoid.$fMonoidLast eta_B2 eta_B1;

Data.Monoid.$fFunctorLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

Data.Monoid.$fApplicativeLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Monoid.$fFunctorLast
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

Data.Monoid.$fMonadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Monoid.$fApplicativeLast
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

Data.Monoid.$fGeneric1Last1
  :: forall a.
     GHC.Generics.Rep1 Data.Monoid.Last a
     -> GHC.Generics.Rep1 Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6Jq8] ds_s6Jq8;

Data.Monoid.$fGeneric1Last2
  :: forall a. Data.Monoid.Last a -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Jq9] x_s6Jq9;

Data.Monoid.$fGeneric1Last [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Monoid.$fGeneric1Last2
                                            Data.Monoid.$fGeneric1Last1];

Data.Monoid.$fGenericLast1
  :: forall a x.
     GHC.Generics.Rep (Data.Monoid.Last a) x
     -> GHC.Generics.Rep (Data.Monoid.Last a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6Jqa] ds_s6Jqa;

Data.Monoid.$fGenericLast2
  :: forall a x. Data.Monoid.Last a -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6Jqb] x1_s6Jqb;

Data.Monoid.$fGenericLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Monoid.Last a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Monoid.$fGenericLast2
                                           Data.Monoid.$fGenericLast1];

Data.Monoid.$fShowFirst1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Monoid.$fShowLast2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last {"#;

Data.Monoid.$fShowLast1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast = "#;

Data.Monoid.$fReadFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Monoid.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Monoid.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Jqc ww_s6Jqd w1_s6Jqe]
        let {
          f_s6Jqf [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6Jqc w1_s6Jqe] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_s6Jqc Data.Monoid.$fShowFirst1 w1_s6Jqe;
        } in 
          case >=# [ww_s6Jqd 11#] of {
            __DEFAULT ->
                let {
                  sat_s6Jql [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6Jqf] \r [x_s6Jqh]
                          let {
                            sat_s6Jqk [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6Jqf x_s6Jqh] \u []
                                    let {
                                      sat_s6Jqj [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6Jqf x_s6Jqh] \u []
                                              let {
                                                sat_s6Jqi [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6Jqh] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Monoid.$fReadFirst4 x_s6Jqh;
                                              } in  f_s6Jqf sat_s6Jqi;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowLast1 sat_s6Jqj;
                          } in 
                            GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast2 sat_s6Jqk;
                } in  sat_s6Jql;
            1# ->
                let {
                  sat_s6Jqs [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6Jqf] \r [x_s6Jqm]
                          let {
                            sat_s6Jqr [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6Jqf x_s6Jqm] \u []
                                    let {
                                      sat_s6Jqq [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6Jqf x_s6Jqm] \u []
                                              let {
                                                sat_s6Jqp [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6Jqf x_s6Jqm] \u []
                                                        let {
                                                          sat_s6Jqo [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6Jqm] \u []
                                                                  let {
                                                                    sat_s6Jqn [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6Jqm];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Monoid.$fReadFirst4
                                                                        sat_s6Jqn;
                                                        } in  f_s6Jqf sat_s6Jqo;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Monoid.$fShowLast1 sat_s6Jqp;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowLast2 sat_s6Jqq;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6Jqr];
                } in  sat_s6Jqs;
          };

Data.Monoid.$fShowLast_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Monoid.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Jqt w1_s6Jqu w2_s6Jqv]
        case w1_s6Jqu of {
          GHC.Types.I# ww1_s6Jqx [Occ=Once] ->
              Data.Monoid.$w$cshowsPrec1 w_s6Jqt ww1_s6Jqx w2_s6Jqv;
        };

Data.Monoid.$fReadFirst3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst4;

Data.Monoid.$fShowFirst4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++ GHC.Show.$fShowMaybe4 Data.Monoid.$fReadFirst3;

Data.Monoid.$fShowLast_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Monoid.Last a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6Jqy x_s6Jqz]
        let {
          sat_s6JqE [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6Jqy x_s6Jqz] \u []
                  let {
                    sat_s6JqD [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6Jqy x_s6Jqz] \u []
                            case x_s6Jqz of {
                              GHC.Base.Nothing -> Data.Monoid.$fShowFirst4;
                              GHC.Base.Just b1_s6JqB [Occ=Once] ->
                                  let {
                                    sat_s6JqC [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_s6Jqy b1_s6JqB] \s []
                                            GHC.Show.showsPrec
                                                $dShow_s6Jqy
                                                GHC.Show.appPrec1
                                                b1_s6JqB
                                                Data.Monoid.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_s6JqC;
                            };
                  } in 
                    GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast1 sat_s6JqD;
        } in 
          GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast2 sat_s6JqE;

Data.Monoid.$fShowLast_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Monoid.Last a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6JqF ls_s6JqG s_s6JqH]
        let {
          sat_s6JqJ [Occ=Once] :: Data.Monoid.Last a_a6Hji -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6JqF] \r [w_s6JqI]
                  Data.Monoid.$w$cshowsPrec1 $dShow_s6JqF 0# w_s6JqI;
        } in  GHC.Show.showList__ sat_s6JqJ ls_s6JqG s_s6JqH;

Data.Monoid.$fShowLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6JqK]
        let {
          sat_s6JqN [Occ=Once]
            :: [Data.Monoid.Last a_a6Hji] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6JqK] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowLast_$cshowList $dShow_s6JqK eta_B2 eta_B1; } in
        let {
          sat_s6JqM [Occ=Once] :: Data.Monoid.Last a_a6Hji -> GHC.Base.String
          [LclId] =
              [$dShow_s6JqK] \r [eta_B1]
                  Data.Monoid.$fShowLast_$cshow $dShow_s6JqK eta_B1; } in
        let {
          sat_s6JqL [Occ=Once]
            :: GHC.Types.Int -> Data.Monoid.Last a_a6Hji -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6JqK] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowLast_$cshowsPrec $dShow_s6JqK eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6JqL sat_s6JqM sat_s6JqN];

Data.Monoid.$fReadLast5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last"#;

Data.Monoid.$fReadLast4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadLast5;

Data.Monoid.$fReadLast_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Monoid.$fReadLast4];

Data.Monoid.$fReadFirst9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Monoid.$fReadFirst8 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst9;

Data.Monoid.$fReadFirst_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Monoid.$fReadFirst8];

Data.Monoid.$fReadLast3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast"#;

Data.Monoid.$fReadLast2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadLast3;

Data.Monoid.$fReadFirst5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Monoid.$fReadFirst2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Monoid.$fReadFirst3];

Data.Monoid.$fReadLast1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Monoid.Last a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s6JqO eta_s6JqP eta1_s6JqQ]
        let {
          ds_s6JqR [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_a6Hit -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_s6JqO] \r [ds1_s6JqS eta2_s6JqT]
                  GHC.Read.$fReadMaybe1
                      $dRead_s6JqO
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_s6JqT; } in
        let {
          sat_s6Jrd [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_a6Hit)
          [LclId] =
              [ds_s6JqR] \r [c_s6JqU eta2_s6JqV]
                  case c_s6JqU of {
                    GHC.Types.I# x_s6JqX [Occ=Once] ->
                        case <=# [x_s6JqX 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6Jra [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                [LclId] =
                                    [ds_s6JqR eta2_s6JqV] \r [a1_s6JqZ]
                                        let {
                                          sat_s6Jr7 [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                          [LclId] =
                                              [ds_s6JqR eta2_s6JqV] \r [a2_s6Jr0]
                                                  let {
                                                    sat_s6Jr6 [Occ=Once]
                                                      :: GHC.Base.Maybe a_a6Hit
                                                         -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                                    [LclId] =
                                                        [eta2_s6JqV] \r [a3_s6Jr1]
                                                            let {
                                                              sat_s6Jr3 [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i6HIg
                                                              [LclId] =
                                                                  [eta2_s6JqV
                                                                   a3_s6Jr1] \r [a4_s6Jr2]
                                                                      eta2_s6JqV a3_s6Jr1;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Monoid.$fReadFirst2
                                                                      sat_s6Jr3
                                                              of
                                                              { Unit# ww1_s6Jr5 [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6Jr5];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Monoid.$fReadLast2
                                                        ds_s6JqR
                                                        Data.Monoid.$fReadFirst5
                                                        sat_s6Jr6;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Monoid.$fReadFirst_lexeme sat_s6Jr7
                                          of
                                          { Unit# ww1_s6Jr9 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6Jr9];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Monoid.$fReadLast_lexeme sat_s6Jra
                                of
                                { Unit# ww1_s6Jrc [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6Jrc];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6Jrd eta_s6JqP eta1_s6JqQ;

Data.Monoid.$fReadLast_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.Last a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_s6Jre n_s6Jrf]
        let {
          sat_s6Jrg [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Monoid.Last a_X6Hlg)
          [LclId] =
              [$dRead_s6Jre n_s6Jrf] \u []
                  Data.Monoid.$fReadLast1
                      $dRead_s6Jre
                      n_s6Jrf
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6Jrg;

Data.Monoid.$fReadLast_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Monoid.Last a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6Jrh]
        let {
          sat_s6Jri [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_X6Hle)
          [LclId] =
              [$dRead_s6Jrh] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadLast1 $dRead_s6Jrh eta_B2 eta_B1;
        } in  GHC.Read.list sat_s6Jri;

Data.Monoid.$fReadLast_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Monoid.Last a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6Jrj]
        let {
          sat_s6Jrl [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Monoid.Last a_X6Hlf]
          [LclId] =
              [$dRead_s6Jrj] \u []
                  let {
                    sat_s6Jrk [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Monoid.Last a_X6Hlf)
                    [LclId] =
                        [$dRead_s6Jrj] \r [eta_B2 eta_B1]
                            Data.Monoid.$fReadLast1 $dRead_s6Jrj eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s6Jrk
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6Jrl;

Data.Monoid.$fReadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s6Jrm]
        let {
          sat_s6Jrq [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Monoid.Last a_X6Hld]
          [LclId] =
              [$dRead_s6Jrm] \u []
                  Data.Monoid.$fReadLast_$creadListPrec $dRead_s6Jrm; } in
        let {
          sat_s6Jrp [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_X6Hld)
          [LclId] =
              [$dRead_s6Jrm] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadLast1 $dRead_s6Jrm eta_B2 eta_B1; } in
        let {
          sat_s6Jro [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Monoid.Last a_X6Hld]
          [LclId] =
              [$dRead_s6Jrm] \u []
                  Data.Monoid.$fReadLast_$creadList $dRead_s6Jrm; } in
        let {
          sat_s6Jrn [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.Last a_X6Hld)
          [LclId] =
              [$dRead_s6Jrm] \r [eta_B1]
                  Data.Monoid.$fReadLast_$creadsPrec $dRead_s6Jrm eta_B1;
        } in  GHC.Read.C:Read [sat_s6Jrn sat_s6Jro sat_s6Jrp sat_s6Jrq];

Data.Monoid.$fEqLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s6Jrr]
        let {
          sat_s6Jrt [Occ=Once]
            :: Data.Monoid.Last a_a6Hg6
               -> Data.Monoid.Last a_a6Hg6 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Jrr] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_s6Jrr eta_B2 eta_B1; } in
        let {
          sat_s6Jrs [Occ=Once]
            :: Data.Monoid.Last a_a6Hg6
               -> Data.Monoid.Last a_a6Hg6 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Jrr] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_s6Jrr eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s6Jrs sat_s6Jrt];

Data.Monoid.$fOrdLast_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Monoid.Last a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6Jru]
        let {
          sat_s6Jrv [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_X6HjF
          [LclId] =
              [$dOrd_s6Jru] \u [] GHC.Classes.$p1Ord $dOrd_s6Jru;
        } in  Data.Monoid.$fEqLast sat_s6Jrv;

Data.Monoid.$fOrdLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Monoid.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s6Jrw]
        let {
          sat_s6JrG [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> Data.Monoid.Last a_X6HjG
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6JrF [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> Data.Monoid.Last a_X6HjG
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6JrE [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6JrD [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jrw] \r [a1_s6JrB b_s6JrC]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6Jrw b_s6JrC a1_s6JrB; } in
        let {
          sat_s6JrA [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6Jrz [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6Jry [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6Jrx [Occ=Once] :: GHC.Classes.Eq (Data.Monoid.Last a_X6HjG)
          [LclId] =
              [$dOrd_s6Jrw] \u [] Data.Monoid.$fOrdLast_$cp1Ord $dOrd_s6Jrw;
        } in 
          GHC.Classes.C:Ord [sat_s6Jrx
                             sat_s6Jry
                             sat_s6Jrz
                             sat_s6JrA
                             sat_s6JrD
                             sat_s6JrE
                             sat_s6JrF
                             sat_s6JrG];

Data.Monoid.$fFunctorFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

Data.Monoid.$fApplicativeFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Monoid.$fFunctorFirst
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

Data.Monoid.$fMonadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Monoid.$fApplicativeFirst
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

Data.Monoid.$fGeneric1First1
  :: forall a.
     GHC.Generics.Rep1 Data.Monoid.First a
     -> GHC.Generics.Rep1 Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6JrH] ds_s6JrH;

Data.Monoid.$fGeneric1First2
  :: forall a. Data.Monoid.First a -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6JrI] x_s6JrI;

Data.Monoid.$fGeneric1First [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Monoid.$fGeneric1First2
                                            Data.Monoid.$fGeneric1First1];

Data.Monoid.$fGenericFirst1
  :: forall a x.
     GHC.Generics.Rep (Data.Monoid.First a) x
     -> GHC.Generics.Rep (Data.Monoid.First a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6JrJ] ds_s6JrJ;

Data.Monoid.$fGenericFirst2
  :: forall a x. Data.Monoid.First a -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6JrK] x1_s6JrK;

Data.Monoid.$fGenericFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Monoid.First a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Monoid.$fGenericFirst2
                                           Data.Monoid.$fGenericFirst1];

Data.Monoid.$fShowFirst3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First {"#;

Data.Monoid.$fShowFirst2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst = "#;

Data.Monoid.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Monoid.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6JrL ww_s6JrM w1_s6JrN]
        let {
          f_s6JrO [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6JrL w1_s6JrN] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_s6JrL Data.Monoid.$fShowFirst1 w1_s6JrN;
        } in 
          case >=# [ww_s6JrM 11#] of {
            __DEFAULT ->
                let {
                  sat_s6JrU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6JrO] \r [x_s6JrQ]
                          let {
                            sat_s6JrT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6JrO x_s6JrQ] \u []
                                    let {
                                      sat_s6JrS [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6JrO x_s6JrQ] \u []
                                              let {
                                                sat_s6JrR [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6JrQ] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Monoid.$fReadFirst4 x_s6JrQ;
                                              } in  f_s6JrO sat_s6JrR;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowFirst2 sat_s6JrS;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Monoid.$fShowFirst3 sat_s6JrT;
                } in  sat_s6JrU;
            1# ->
                let {
                  sat_s6Js1 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6JrO] \r [x_s6JrV]
                          let {
                            sat_s6Js0 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6JrO x_s6JrV] \u []
                                    let {
                                      sat_s6JrZ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6JrO x_s6JrV] \u []
                                              let {
                                                sat_s6JrY [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6JrO x_s6JrV] \u []
                                                        let {
                                                          sat_s6JrX [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6JrV] \u []
                                                                  let {
                                                                    sat_s6JrW [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6JrV];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Monoid.$fReadFirst4
                                                                        sat_s6JrW;
                                                        } in  f_s6JrO sat_s6JrX;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Monoid.$fShowFirst2 sat_s6JrY;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowFirst3 sat_s6JrZ;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6Js0];
                } in  sat_s6Js1;
          };

Data.Monoid.$fShowFirst_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Monoid.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Js2 w1_s6Js3 w2_s6Js4]
        case w1_s6Js3 of {
          GHC.Types.I# ww1_s6Js6 [Occ=Once] ->
              Data.Monoid.$w$cshowsPrec w_s6Js2 ww1_s6Js6 w2_s6Js4;
        };

Data.Monoid.$fShowFirst_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Monoid.First a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6Js7 x_s6Js8]
        let {
          sat_s6Jsd [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6Js7 x_s6Js8] \u []
                  let {
                    sat_s6Jsc [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6Js7 x_s6Js8] \u []
                            case x_s6Js8 of {
                              GHC.Base.Nothing -> Data.Monoid.$fShowFirst4;
                              GHC.Base.Just b1_s6Jsa [Occ=Once] ->
                                  let {
                                    sat_s6Jsb [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_s6Js7 b1_s6Jsa] \s []
                                            GHC.Show.showsPrec
                                                $dShow_s6Js7
                                                GHC.Show.appPrec1
                                                b1_s6Jsa
                                                Data.Monoid.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_s6Jsb;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Monoid.$fShowFirst2 sat_s6Jsc;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Monoid.$fShowFirst3 sat_s6Jsd;

Data.Monoid.$fShowFirst_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Monoid.First a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6Jse ls_s6Jsf s_s6Jsg]
        let {
          sat_s6Jsi [Occ=Once] :: Data.Monoid.First a_a6H8s -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6Jse] \r [w_s6Jsh]
                  Data.Monoid.$w$cshowsPrec $dShow_s6Jse 0# w_s6Jsh;
        } in  GHC.Show.showList__ sat_s6Jsi ls_s6Jsf s_s6Jsg;

Data.Monoid.$fShowFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6Jsj]
        let {
          sat_s6Jsm [Occ=Once]
            :: [Data.Monoid.First a_a6H8s] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6Jsj] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowFirst_$cshowList $dShow_s6Jsj eta_B2 eta_B1; } in
        let {
          sat_s6Jsl [Occ=Once]
            :: Data.Monoid.First a_a6H8s -> GHC.Base.String
          [LclId] =
              [$dShow_s6Jsj] \r [eta_B1]
                  Data.Monoid.$fShowFirst_$cshow $dShow_s6Jsj eta_B1; } in
        let {
          sat_s6Jsk [Occ=Once]
            :: GHC.Types.Int -> Data.Monoid.First a_a6H8s -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6Jsj] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowFirst_$cshowsPrec $dShow_s6Jsj eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6Jsk sat_s6Jsl sat_s6Jsm];

Data.Monoid.$fReadFirst11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First"#;

Data.Monoid.$fReadFirst10 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst11;

Data.Monoid.$fReadFirst_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Monoid.$fReadFirst10];

Data.Monoid.$fReadFirst7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst"#;

Data.Monoid.$fReadFirst6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst7;

Data.Monoid.$fReadFirst1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Monoid.First a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s6Jsn eta_s6Jso eta1_s6Jsp]
        let {
          ds_s6Jsq [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_a6H7b -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_s6Jsn] \r [ds1_s6Jsr eta2_s6Jss]
                  GHC.Read.$fReadMaybe1
                      $dRead_s6Jsn
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_s6Jss; } in
        let {
          sat_s6JsM [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_a6H7b)
          [LclId] =
              [ds_s6Jsq] \r [c_s6Jst eta2_s6Jsu]
                  case c_s6Jst of {
                    GHC.Types.I# x_s6Jsw [Occ=Once] ->
                        case <=# [x_s6Jsw 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6JsJ [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                [LclId] =
                                    [ds_s6Jsq eta2_s6Jsu] \r [a1_s6Jsy]
                                        let {
                                          sat_s6JsG [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                          [LclId] =
                                              [ds_s6Jsq eta2_s6Jsu] \r [a2_s6Jsz]
                                                  let {
                                                    sat_s6JsF [Occ=Once]
                                                      :: GHC.Base.Maybe a_a6H7b
                                                         -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                                    [LclId] =
                                                        [eta2_s6Jsu] \r [a3_s6JsA]
                                                            let {
                                                              sat_s6JsC [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i6HIg
                                                              [LclId] =
                                                                  [eta2_s6Jsu
                                                                   a3_s6JsA] \r [a4_s6JsB]
                                                                      eta2_s6Jsu a3_s6JsA;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Monoid.$fReadFirst2
                                                                      sat_s6JsC
                                                              of
                                                              { Unit# ww1_s6JsE [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6JsE];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Monoid.$fReadFirst6
                                                        ds_s6Jsq
                                                        Data.Monoid.$fReadFirst5
                                                        sat_s6JsF;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Monoid.$fReadFirst_lexeme sat_s6JsG
                                          of
                                          { Unit# ww1_s6JsI [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6JsI];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Monoid.$fReadFirst_lexeme1 sat_s6JsJ
                                of
                                { Unit# ww1_s6JsL [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6JsL];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6JsM eta_s6Jso eta1_s6Jsp;

Data.Monoid.$fReadFirst_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.First a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_s6JsN n_s6JsO]
        let {
          sat_s6JsP [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Monoid.First a_X6HaX)
          [LclId] =
              [$dRead_s6JsN n_s6JsO] \u []
                  Data.Monoid.$fReadFirst1
                      $dRead_s6JsN
                      n_s6JsO
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6JsP;

Data.Monoid.$fReadFirst_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Monoid.First a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6JsQ]
        let {
          sat_s6JsR [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_X6HaV)
          [LclId] =
              [$dRead_s6JsQ] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadFirst1 $dRead_s6JsQ eta_B2 eta_B1;
        } in  GHC.Read.list sat_s6JsR;

Data.Monoid.$fReadFirst_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Monoid.First a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6JsS]
        let {
          sat_s6JsU [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Monoid.First a_X6HaW]
          [LclId] =
              [$dRead_s6JsS] \u []
                  let {
                    sat_s6JsT [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Monoid.First a_X6HaW)
                    [LclId] =
                        [$dRead_s6JsS] \r [eta_B2 eta_B1]
                            Data.Monoid.$fReadFirst1 $dRead_s6JsS eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s6JsT
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6JsU;

Data.Monoid.$fReadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => GHC.Read.Read (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s6JsV]
        let {
          sat_s6JsZ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Monoid.First a_X6HaU]
          [LclId] =
              [$dRead_s6JsV] \u []
                  Data.Monoid.$fReadFirst_$creadListPrec $dRead_s6JsV; } in
        let {
          sat_s6JsY [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_X6HaU)
          [LclId] =
              [$dRead_s6JsV] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadFirst1 $dRead_s6JsV eta_B2 eta_B1; } in
        let {
          sat_s6JsX [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Monoid.First a_X6HaU]
          [LclId] =
              [$dRead_s6JsV] \u []
                  Data.Monoid.$fReadFirst_$creadList $dRead_s6JsV; } in
        let {
          sat_s6JsW [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.First a_X6HaU)
          [LclId] =
              [$dRead_s6JsV] \r [eta_B1]
                  Data.Monoid.$fReadFirst_$creadsPrec $dRead_s6JsV eta_B1;
        } in  GHC.Read.C:Read [sat_s6JsW sat_s6JsX sat_s6JsY sat_s6JsZ];

Data.Monoid.$fEqFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s6Jt0]
        let {
          sat_s6Jt2 [Occ=Once]
            :: Data.Monoid.First a_a6H4O
               -> Data.Monoid.First a_a6H4O -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Jt0] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_s6Jt0 eta_B2 eta_B1; } in
        let {
          sat_s6Jt1 [Occ=Once]
            :: Data.Monoid.First a_a6H4O
               -> Data.Monoid.First a_a6H4O -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Jt0] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_s6Jt0 eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s6Jt1 sat_s6Jt2];

Data.Monoid.$fOrdFirst_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Monoid.First a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6Jt3]
        let {
          sat_s6Jt4 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_X6H9m
          [LclId] =
              [$dOrd_s6Jt3] \u [] GHC.Classes.$p1Ord $dOrd_s6Jt3;
        } in  Data.Monoid.$fEqFirst sat_s6Jt4;

Data.Monoid.$fOrdFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Monoid.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s6Jt5]
        let {
          sat_s6Jtf [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> Data.Monoid.First a_X6H9n
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jte [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> Data.Monoid.First a_X6H9n
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jtd [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jtc [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jt5] \r [a1_s6Jta b_s6Jtb]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6Jt5 b_s6Jtb a1_s6Jta; } in
        let {
          sat_s6Jt9 [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jt8 [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jt7 [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jt6 [Occ=Once] :: GHC.Classes.Eq (Data.Monoid.First a_X6H9n)
          [LclId] =
              [$dOrd_s6Jt5] \u [] Data.Monoid.$fOrdFirst_$cp1Ord $dOrd_s6Jt5;
        } in 
          GHC.Classes.C:Ord [sat_s6Jt6
                             sat_s6Jt7
                             sat_s6Jt8
                             sat_s6Jt9
                             sat_s6Jtc
                             sat_s6Jtd
                             sat_s6Jte
                             sat_s6Jtf];

Data.Monoid.getFirst
  :: forall a. Data.Monoid.First a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Monoid.$fGeneric1First2 eta_B1;

Data.Monoid.getLast
  :: forall a. Data.Monoid.Last a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Monoid.$fGeneric1Last2 eta_B1;

Data.Monoid.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Monoid.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$trModule4];

Data.Monoid.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Monoid"#;

Data.Monoid.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$trModule2];

Data.Monoid.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Monoid.$trModule3
                                     Data.Monoid.$trModule1];

$krep_r6I1r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_r6I1s :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r6I1r GHC.Types.[]];

$krep2_r6I1t :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep1_r6I1s];

Data.Monoid.$tcFirst1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$fReadFirst11];

Data.Monoid.$tcFirst :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12072287807032806756##
                                    12788244796562536401##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tcFirst1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep3_r6I1u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Monoid.$tcFirst
                                              $krep1_r6I1s];

Data.Monoid.$tc'First1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6I1t $krep3_r6I1u];

Data.Monoid.$tc'First3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'First"#;

Data.Monoid.$tc'First2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$tc'First3];

Data.Monoid.$tc'First :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7752528083504400280##
                                    15965132804789246607##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tc'First2
                                    1#
                                    Data.Monoid.$tc'First1];

Data.Monoid.$tcLast1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$fReadLast5];

Data.Monoid.$tcLast :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6920195955404695016##
                                    2388797855174213212##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tcLast1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_r6I1v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Monoid.$tcLast
                                              $krep1_r6I1s];

Data.Monoid.$tc'Last1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6I1t $krep4_r6I1v];

Data.Monoid.$tc'Last3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Last"#;

Data.Monoid.$tc'Last2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$tc'Last3];

Data.Monoid.$tc'Last :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5411164464353425083##
                                    12998161994081761510##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tc'Last2
                                    1#
                                    Data.Monoid.$tc'Last1];


==================== STG syntax: ====================
2018-03-16 16:01:59.127637677 UTC

Data.Monoid.$fMonoidFirst_$c<>
  :: forall a.
     Data.Monoid.First a -> Data.Monoid.First a -> Data.Monoid.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6Jpq b_s6Jpr]
        case ds_s6Jpq of wild_s6Jps {
          GHC.Base.Nothing -> b_s6Jpr;
          GHC.Base.Just _ [Occ=Dead] -> wild_s6Jps;
        };

Data.Monoid.$fSemigroupFirst1 [Occ=LoopBreaker]
  :: forall a.
     Data.Monoid.First a -> [Data.Monoid.First a] -> Data.Monoid.First a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6Jpu ds1_s6Jpv]
        case ds1_s6Jpv of {
          [] -> b_s6Jpu;
          : c_s6Jpx [Occ=Once] cs_s6Jpy [Occ=Once] ->
              case b_s6Jpu of wild_s6Jpz {
                GHC.Base.Nothing -> Data.Monoid.$fSemigroupFirst1 c_s6Jpx cs_s6Jpy;
                GHC.Base.Just _ [Occ=Dead] -> wild_s6Jpz;
              };
        };

Data.Monoid.$fSemigroupFirst_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Monoid.First a) -> Data.Monoid.First a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6JpB]
        case ds_s6JpB of {
          GHC.Base.:| a1_s6JpD [Occ=Once] as_s6JpE [Occ=Once] ->
              Data.Monoid.$fSemigroupFirst1 a1_s6JpD as_s6JpE;
        };

Data.Monoid.$fMonoidFirst_go [Occ=LoopBreaker]
  :: forall a. [Data.Monoid.First a] -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6JpF]
        case ds_s6JpF of {
          [] -> GHC.Base.Nothing [];
          : y_s6JpH [Occ=Once] ys_s6JpI [Occ=Once] ->
              case y_s6JpH of wild1_s6JpJ {
                GHC.Base.Nothing -> Data.Monoid.$fMonoidFirst_go ys_s6JpI;
                GHC.Base.Just _ [Occ=Dead] -> wild1_s6JpJ;
              };
        };

Data.Monoid.$fSemigroupFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Monoid.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Monoid.$fMonoidFirst_$c<>
                                         Data.Monoid.$fSemigroupFirst_$csconcat
                                         Data.Monoid.$fSemigroupFirst_$cstimes];
Data.Monoid.$fMonoidFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Monoid.First a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Monoid.$fSemigroupFirst
                                      GHC.Base.Nothing
                                      Data.Monoid.$fMonoidFirst_$c<>
                                      Data.Monoid.$fMonoidFirst_go];
Data.Monoid.$fSemigroupFirst_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Monoid.First a -> Data.Monoid.First a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6JpL eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6JpL Data.Monoid.$fMonoidFirst eta_B2 eta_B1;

Data.Monoid.$fMonoidLast_$c<>
  :: forall a.
     Data.Monoid.Last a -> Data.Monoid.Last a -> Data.Monoid.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6JpM ds_s6JpN]
        case ds_s6JpN of wild_s6JpO {
          GHC.Base.Nothing -> a1_s6JpM;
          GHC.Base.Just _ [Occ=Dead] -> wild_s6JpO;
        };

Data.Monoid.$fSemigroupLast1 [Occ=LoopBreaker]
  :: forall a.
     Data.Monoid.Last a -> [Data.Monoid.Last a] -> Data.Monoid.Last a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6JpQ ds1_s6JpR]
        case ds1_s6JpR of {
          [] -> b_s6JpQ;
          : c_s6JpT [Occ=Once] cs_s6JpU [Occ=Once] ->
              case Data.Monoid.$fSemigroupLast1 c_s6JpT cs_s6JpU of wild_s6JpV {
                GHC.Base.Nothing -> b_s6JpQ;
                GHC.Base.Just _ [Occ=Dead] -> wild_s6JpV;
              };
        };

Data.Monoid.$fSemigroupLast_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Monoid.Last a) -> Data.Monoid.Last a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6JpX]
        case ds_s6JpX of {
          GHC.Base.:| a1_s6JpZ [Occ=Once] as_s6Jq0 [Occ=Once] ->
              Data.Monoid.$fSemigroupLast1 a1_s6JpZ as_s6Jq0;
        };

Data.Monoid.$fMonoidLast_go [Occ=LoopBreaker]
  :: forall a. [Data.Monoid.Last a] -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6Jq1]
        case ds_s6Jq1 of {
          [] -> GHC.Base.Nothing [];
          : y_s6Jq3 [Occ=Once] ys_s6Jq4 [Occ=Once] ->
              case Data.Monoid.$fMonoidLast_go ys_s6Jq4 of wild1_s6Jq5 {
                GHC.Base.Nothing -> y_s6Jq3;
                GHC.Base.Just _ [Occ=Dead] -> wild1_s6Jq5;
              };
        };

Data.Monoid.$fSemigroupLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Monoid.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [Data.Monoid.$fMonoidLast_$c<>
                                         Data.Monoid.$fSemigroupLast_$csconcat
                                         Data.Monoid.$fSemigroupLast_$cstimes];
Data.Monoid.$fMonoidLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Monoid.Last a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Monoid.$fSemigroupLast
                                      GHC.Base.Nothing
                                      Data.Monoid.$fMonoidLast_$c<>
                                      Data.Monoid.$fMonoidLast_go];
Data.Monoid.$fSemigroupLast_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b -> Data.Monoid.Last a -> Data.Monoid.Last a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6Jq7 eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6Jq7 Data.Monoid.$fMonoidLast eta_B2 eta_B1;

Data.Monoid.$fFunctorLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

Data.Monoid.$fApplicativeLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Monoid.$fFunctorLast
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

Data.Monoid.$fMonadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Monoid.$fApplicativeLast
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

Data.Monoid.$fGeneric1Last1
  :: forall a.
     GHC.Generics.Rep1 Data.Monoid.Last a
     -> GHC.Generics.Rep1 Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6Jq8] ds_s6Jq8;

Data.Monoid.$fGeneric1Last2
  :: forall a. Data.Monoid.Last a -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6Jq9] x_s6Jq9;

Data.Monoid.$fGeneric1Last [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Monoid.Last
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Monoid.$fGeneric1Last2
                                            Data.Monoid.$fGeneric1Last1];

Data.Monoid.$fGenericLast1
  :: forall a x.
     GHC.Generics.Rep (Data.Monoid.Last a) x
     -> GHC.Generics.Rep (Data.Monoid.Last a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6Jqa] ds_s6Jqa;

Data.Monoid.$fGenericLast2
  :: forall a x. Data.Monoid.Last a -> Data.Monoid.Last a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6Jqb] x1_s6Jqb;

Data.Monoid.$fGenericLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Monoid.Last a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Monoid.$fGenericLast2
                                           Data.Monoid.$fGenericLast1];

Data.Monoid.$fShowFirst1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Monoid.$fShowLast2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last {"#;

Data.Monoid.$fShowLast1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast = "#;

Data.Monoid.$fReadFirst4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Monoid.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Monoid.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Jqc ww_s6Jqd w1_s6Jqe]
        let {
          f_s6Jqf [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6Jqc w1_s6Jqe] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_s6Jqc Data.Monoid.$fShowFirst1 w1_s6Jqe;
        } in 
          case >=# [ww_s6Jqd 11#] of {
            __DEFAULT ->
                let {
                  sat_s6Jql [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6Jqf] \r [x_s6Jqh]
                          let {
                            sat_s6Jqk [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6Jqf x_s6Jqh] \u []
                                    let {
                                      sat_s6Jqj [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6Jqf x_s6Jqh] \u []
                                              let {
                                                sat_s6Jqi [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6Jqh] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Monoid.$fReadFirst4 x_s6Jqh;
                                              } in  f_s6Jqf sat_s6Jqi;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowLast1 sat_s6Jqj;
                          } in 
                            GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast2 sat_s6Jqk;
                } in  sat_s6Jql;
            1# ->
                let {
                  sat_s6Jqs [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6Jqf] \r [x_s6Jqm]
                          let {
                            sat_s6Jqr [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6Jqf x_s6Jqm] \u []
                                    let {
                                      sat_s6Jqq [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6Jqf x_s6Jqm] \u []
                                              let {
                                                sat_s6Jqp [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6Jqf x_s6Jqm] \u []
                                                        let {
                                                          sat_s6Jqo [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6Jqm] \u []
                                                                  let {
                                                                    sat_s6Jqn [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6Jqm];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Monoid.$fReadFirst4
                                                                        sat_s6Jqn;
                                                        } in  f_s6Jqf sat_s6Jqo;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Monoid.$fShowLast1 sat_s6Jqp;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowLast2 sat_s6Jqq;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6Jqr];
                } in  sat_s6Jqs;
          };

Data.Monoid.$fShowLast_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Monoid.Last a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Jqt w1_s6Jqu w2_s6Jqv]
        case w1_s6Jqu of {
          GHC.Types.I# ww1_s6Jqx [Occ=Once] ->
              Data.Monoid.$w$cshowsPrec1 w_s6Jqt ww1_s6Jqx w2_s6Jqv;
        };

Data.Monoid.$fReadFirst3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst4;

Data.Monoid.$fShowFirst4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++ GHC.Show.$fShowMaybe4 Data.Monoid.$fReadFirst3;

Data.Monoid.$fShowLast_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Monoid.Last a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6Jqy x_s6Jqz]
        let {
          sat_s6JqE [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6Jqy x_s6Jqz] \u []
                  let {
                    sat_s6JqD [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6Jqy x_s6Jqz] \u []
                            case x_s6Jqz of {
                              GHC.Base.Nothing -> Data.Monoid.$fShowFirst4;
                              GHC.Base.Just b1_s6JqB [Occ=Once] ->
                                  let {
                                    sat_s6JqC [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_s6Jqy b1_s6JqB] \s []
                                            GHC.Show.showsPrec
                                                $dShow_s6Jqy
                                                GHC.Show.appPrec1
                                                b1_s6JqB
                                                Data.Monoid.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_s6JqC;
                            };
                  } in 
                    GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast1 sat_s6JqD;
        } in 
          GHC.CString.unpackAppendCString# Data.Monoid.$fShowLast2 sat_s6JqE;

Data.Monoid.$fShowLast_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Monoid.Last a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6JqF ls_s6JqG s_s6JqH]
        let {
          sat_s6JqJ [Occ=Once] :: Data.Monoid.Last a_a6Hji -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6JqF] \r [w_s6JqI]
                  Data.Monoid.$w$cshowsPrec1 $dShow_s6JqF 0# w_s6JqI;
        } in  GHC.Show.showList__ sat_s6JqJ ls_s6JqG s_s6JqH;

Data.Monoid.$fShowLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6JqK]
        let {
          sat_s6JqN [Occ=Once]
            :: [Data.Monoid.Last a_a6Hji] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6JqK] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowLast_$cshowList $dShow_s6JqK eta_B2 eta_B1; } in
        let {
          sat_s6JqM [Occ=Once] :: Data.Monoid.Last a_a6Hji -> GHC.Base.String
          [LclId] =
              [$dShow_s6JqK] \r [eta_B1]
                  Data.Monoid.$fShowLast_$cshow $dShow_s6JqK eta_B1; } in
        let {
          sat_s6JqL [Occ=Once]
            :: GHC.Types.Int -> Data.Monoid.Last a_a6Hji -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6JqK] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowLast_$cshowsPrec $dShow_s6JqK eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6JqL sat_s6JqM sat_s6JqN];

Data.Monoid.$fReadLast5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Last"#;

Data.Monoid.$fReadLast4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadLast5;

Data.Monoid.$fReadLast_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Monoid.$fReadLast4];

Data.Monoid.$fReadFirst9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Monoid.$fReadFirst8 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst9;

Data.Monoid.$fReadFirst_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Monoid.$fReadFirst8];

Data.Monoid.$fReadLast3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getLast"#;

Data.Monoid.$fReadLast2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadLast3;

Data.Monoid.$fReadFirst5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Monoid.$fReadFirst2 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Monoid.$fReadFirst3];

Data.Monoid.$fReadLast1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Monoid.Last a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s6JqO eta_s6JqP eta1_s6JqQ]
        let {
          ds_s6JqR [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_a6Hit -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_s6JqO] \r [ds1_s6JqS eta2_s6JqT]
                  GHC.Read.$fReadMaybe1
                      $dRead_s6JqO
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_s6JqT; } in
        let {
          sat_s6Jrd [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_a6Hit)
          [LclId] =
              [ds_s6JqR] \r [c_s6JqU eta2_s6JqV]
                  case c_s6JqU of {
                    GHC.Types.I# x_s6JqX [Occ=Once] ->
                        case <=# [x_s6JqX 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6Jra [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                [LclId] =
                                    [ds_s6JqR eta2_s6JqV] \r [a1_s6JqZ]
                                        let {
                                          sat_s6Jr7 [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                          [LclId] =
                                              [ds_s6JqR eta2_s6JqV] \r [a2_s6Jr0]
                                                  let {
                                                    sat_s6Jr6 [Occ=Once]
                                                      :: GHC.Base.Maybe a_a6Hit
                                                         -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                                    [LclId] =
                                                        [eta2_s6JqV] \r [a3_s6Jr1]
                                                            let {
                                                              sat_s6Jr3 [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i6HIg
                                                              [LclId] =
                                                                  [eta2_s6JqV
                                                                   a3_s6Jr1] \r [a4_s6Jr2]
                                                                      eta2_s6JqV a3_s6Jr1;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Monoid.$fReadFirst2
                                                                      sat_s6Jr3
                                                              of
                                                              { Unit# ww1_s6Jr5 [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6Jr5];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Monoid.$fReadLast2
                                                        ds_s6JqR
                                                        Data.Monoid.$fReadFirst5
                                                        sat_s6Jr6;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Monoid.$fReadFirst_lexeme sat_s6Jr7
                                          of
                                          { Unit# ww1_s6Jr9 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6Jr9];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Monoid.$fReadLast_lexeme sat_s6Jra
                                of
                                { Unit# ww1_s6Jrc [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6Jrc];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6Jrd eta_s6JqP eta1_s6JqQ;

Data.Monoid.$fReadLast_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.Last a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_s6Jre n_s6Jrf]
        let {
          sat_s6Jrg [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Monoid.Last a_X6Hlg)
          [LclId] =
              [$dRead_s6Jre n_s6Jrf] \u []
                  Data.Monoid.$fReadLast1
                      $dRead_s6Jre
                      n_s6Jrf
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6Jrg;

Data.Monoid.$fReadLast_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Monoid.Last a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6Jrh]
        let {
          sat_s6Jri [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_X6Hle)
          [LclId] =
              [$dRead_s6Jrh] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadLast1 $dRead_s6Jrh eta_B2 eta_B1;
        } in  GHC.Read.list sat_s6Jri;

Data.Monoid.$fReadLast_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Monoid.Last a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6Jrj]
        let {
          sat_s6Jrl [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Monoid.Last a_X6Hlf]
          [LclId] =
              [$dRead_s6Jrj] \u []
                  let {
                    sat_s6Jrk [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Monoid.Last a_X6Hlf)
                    [LclId] =
                        [$dRead_s6Jrj] \r [eta_B2 eta_B1]
                            Data.Monoid.$fReadLast1 $dRead_s6Jrj eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s6Jrk
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6Jrl;

Data.Monoid.$fReadLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s6Jrm]
        let {
          sat_s6Jrq [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Monoid.Last a_X6Hld]
          [LclId] =
              [$dRead_s6Jrm] \u []
                  Data.Monoid.$fReadLast_$creadListPrec $dRead_s6Jrm; } in
        let {
          sat_s6Jrp [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.Last a_X6Hld)
          [LclId] =
              [$dRead_s6Jrm] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadLast1 $dRead_s6Jrm eta_B2 eta_B1; } in
        let {
          sat_s6Jro [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Monoid.Last a_X6Hld]
          [LclId] =
              [$dRead_s6Jrm] \u []
                  Data.Monoid.$fReadLast_$creadList $dRead_s6Jrm; } in
        let {
          sat_s6Jrn [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.Last a_X6Hld)
          [LclId] =
              [$dRead_s6Jrm] \r [eta_B1]
                  Data.Monoid.$fReadLast_$creadsPrec $dRead_s6Jrm eta_B1;
        } in  GHC.Read.C:Read [sat_s6Jrn sat_s6Jro sat_s6Jrp sat_s6Jrq];

Data.Monoid.$fEqLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Monoid.Last a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s6Jrr]
        let {
          sat_s6Jrt [Occ=Once]
            :: Data.Monoid.Last a_a6Hg6
               -> Data.Monoid.Last a_a6Hg6 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Jrr] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_s6Jrr eta_B2 eta_B1; } in
        let {
          sat_s6Jrs [Occ=Once]
            :: Data.Monoid.Last a_a6Hg6
               -> Data.Monoid.Last a_a6Hg6 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Jrr] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_s6Jrr eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s6Jrs sat_s6Jrt];

Data.Monoid.$fOrdLast_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Monoid.Last a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6Jru]
        let {
          sat_s6Jrv [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_X6HjF
          [LclId] =
              [$dOrd_s6Jru] \u [] GHC.Classes.$p1Ord $dOrd_s6Jru;
        } in  Data.Monoid.$fEqLast sat_s6Jrv;

Data.Monoid.$fOrdLast [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Monoid.Last a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s6Jrw]
        let {
          sat_s6JrG [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> Data.Monoid.Last a_X6HjG
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6JrF [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> Data.Monoid.Last a_X6HjG
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6JrE [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6JrD [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jrw] \r [a1_s6JrB b_s6JrC]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6Jrw b_s6JrC a1_s6JrB; } in
        let {
          sat_s6JrA [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6Jrz [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6Jry [Occ=Once]
            :: Data.Monoid.Last a_X6HjG
               -> Data.Monoid.Last a_X6HjG -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6Jrw] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_s6Jrw eta_B2 eta_B1; } in
        let {
          sat_s6Jrx [Occ=Once] :: GHC.Classes.Eq (Data.Monoid.Last a_X6HjG)
          [LclId] =
              [$dOrd_s6Jrw] \u [] Data.Monoid.$fOrdLast_$cp1Ord $dOrd_s6Jrw;
        } in 
          GHC.Classes.C:Ord [sat_s6Jrx
                             sat_s6Jry
                             sat_s6Jrz
                             sat_s6JrA
                             sat_s6JrD
                             sat_s6JrE
                             sat_s6JrF
                             sat_s6JrG];

Data.Monoid.$fFunctorFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [GHC.Base.$fApplicativeMaybe_$cfmap
                                       GHC.Base.$fFunctorMaybe_$c<$];

Data.Monoid.$fApplicativeFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Monoid.$fFunctorFirst
                                           GHC.Base.Just
                                           GHC.Base.$fApplicativeMaybe_$c<*>
                                           GHC.Base.$fApplicativeMaybe_$cliftA2
                                           GHC.Base.$fApplicativeMaybe_$c*>
                                           GHC.Base.$fApplicativeMaybe_$c<*];

Data.Monoid.$fMonadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Monoid.$fApplicativeFirst
                                     GHC.Base.$fMonadMaybe_$c>>=
                                     GHC.Base.$fApplicativeMaybe_$c*>
                                     GHC.Base.Just
                                     GHC.Base.$fMonadMaybe_$cfail];

Data.Monoid.$fGeneric1First1
  :: forall a.
     GHC.Generics.Rep1 Data.Monoid.First a
     -> GHC.Generics.Rep1 Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6JrH] ds_s6JrH;

Data.Monoid.$fGeneric1First2
  :: forall a. Data.Monoid.First a -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6JrI] x_s6JrI;

Data.Monoid.$fGeneric1First [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Monoid.First
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Monoid.$fGeneric1First2
                                            Data.Monoid.$fGeneric1First1];

Data.Monoid.$fGenericFirst1
  :: forall a x.
     GHC.Generics.Rep (Data.Monoid.First a) x
     -> GHC.Generics.Rep (Data.Monoid.First a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6JrJ] ds_s6JrJ;

Data.Monoid.$fGenericFirst2
  :: forall a x. Data.Monoid.First a -> Data.Monoid.First a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6JrK] x1_s6JrK;

Data.Monoid.$fGenericFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Monoid.First a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Monoid.$fGenericFirst2
                                           Data.Monoid.$fGenericFirst1];

Data.Monoid.$fShowFirst3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First {"#;

Data.Monoid.$fShowFirst2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst = "#;

Data.Monoid.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Monoid.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6JrL ww_s6JrM w1_s6JrN]
        let {
          f_s6JrO [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6JrL w1_s6JrN] \u []
                  GHC.Show.$fShowMaybe_$cshowsPrec
                      w_s6JrL Data.Monoid.$fShowFirst1 w1_s6JrN;
        } in 
          case >=# [ww_s6JrM 11#] of {
            __DEFAULT ->
                let {
                  sat_s6JrU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6JrO] \r [x_s6JrQ]
                          let {
                            sat_s6JrT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6JrO x_s6JrQ] \u []
                                    let {
                                      sat_s6JrS [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6JrO x_s6JrQ] \u []
                                              let {
                                                sat_s6JrR [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6JrQ] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Monoid.$fReadFirst4 x_s6JrQ;
                                              } in  f_s6JrO sat_s6JrR;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowFirst2 sat_s6JrS;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Monoid.$fShowFirst3 sat_s6JrT;
                } in  sat_s6JrU;
            1# ->
                let {
                  sat_s6Js1 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6JrO] \r [x_s6JrV]
                          let {
                            sat_s6Js0 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6JrO x_s6JrV] \u []
                                    let {
                                      sat_s6JrZ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6JrO x_s6JrV] \u []
                                              let {
                                                sat_s6JrY [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6JrO x_s6JrV] \u []
                                                        let {
                                                          sat_s6JrX [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6JrV] \u []
                                                                  let {
                                                                    sat_s6JrW [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6JrV];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Monoid.$fReadFirst4
                                                                        sat_s6JrW;
                                                        } in  f_s6JrO sat_s6JrX;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Monoid.$fShowFirst2 sat_s6JrY;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Monoid.$fShowFirst3 sat_s6JrZ;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6Js0];
                } in  sat_s6Js1;
          };

Data.Monoid.$fShowFirst_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Monoid.First a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6Js2 w1_s6Js3 w2_s6Js4]
        case w1_s6Js3 of {
          GHC.Types.I# ww1_s6Js6 [Occ=Once] ->
              Data.Monoid.$w$cshowsPrec w_s6Js2 ww1_s6Js6 w2_s6Js4;
        };

Data.Monoid.$fShowFirst_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Monoid.First a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6Js7 x_s6Js8]
        let {
          sat_s6Jsd [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6Js7 x_s6Js8] \u []
                  let {
                    sat_s6Jsc [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6Js7 x_s6Js8] \u []
                            case x_s6Js8 of {
                              GHC.Base.Nothing -> Data.Monoid.$fShowFirst4;
                              GHC.Base.Just b1_s6Jsa [Occ=Once] ->
                                  let {
                                    sat_s6Jsb [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [$dShow_s6Js7 b1_s6Jsa] \s []
                                            GHC.Show.showsPrec
                                                $dShow_s6Js7
                                                GHC.Show.appPrec1
                                                b1_s6Jsa
                                                Data.Monoid.$fReadFirst3;
                                  } in  GHC.Base.++ GHC.Show.$fShowMaybe1 sat_s6Jsb;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Monoid.$fShowFirst2 sat_s6Jsc;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Monoid.$fShowFirst3 sat_s6Jsd;

Data.Monoid.$fShowFirst_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Monoid.First a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6Jse ls_s6Jsf s_s6Jsg]
        let {
          sat_s6Jsi [Occ=Once] :: Data.Monoid.First a_a6H8s -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6Jse] \r [w_s6Jsh]
                  Data.Monoid.$w$cshowsPrec $dShow_s6Jse 0# w_s6Jsh;
        } in  GHC.Show.showList__ sat_s6Jsi ls_s6Jsf s_s6Jsg;

Data.Monoid.$fShowFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Show.Show a => GHC.Show.Show (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6Jsj]
        let {
          sat_s6Jsm [Occ=Once]
            :: [Data.Monoid.First a_a6H8s] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6Jsj] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowFirst_$cshowList $dShow_s6Jsj eta_B2 eta_B1; } in
        let {
          sat_s6Jsl [Occ=Once]
            :: Data.Monoid.First a_a6H8s -> GHC.Base.String
          [LclId] =
              [$dShow_s6Jsj] \r [eta_B1]
                  Data.Monoid.$fShowFirst_$cshow $dShow_s6Jsj eta_B1; } in
        let {
          sat_s6Jsk [Occ=Once]
            :: GHC.Types.Int -> Data.Monoid.First a_a6H8s -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6Jsj] \r [eta_B2 eta_B1]
                  Data.Monoid.$fShowFirst_$cshowsPrec $dShow_s6Jsj eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6Jsk sat_s6Jsl sat_s6Jsm];

Data.Monoid.$fReadFirst11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "First"#;

Data.Monoid.$fReadFirst10 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst11;

Data.Monoid.$fReadFirst_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Monoid.$fReadFirst10];

Data.Monoid.$fReadFirst7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getFirst"#;

Data.Monoid.$fReadFirst6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Monoid.$fReadFirst7;

Data.Monoid.$fReadFirst1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Monoid.First a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId,
 Arity=3,
 Str=<L,U(A,A,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRead_s6Jsn eta_s6Jso eta1_s6Jsp]
        let {
          ds_s6Jsq [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b1.
                  (GHC.Base.Maybe a_a6H7b -> Text.ParserCombinators.ReadP.P b1)
                  -> Text.ParserCombinators.ReadP.P b1
          [LclId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
              [$dRead_s6Jsn] \r [ds1_s6Jsr eta2_s6Jss]
                  GHC.Read.$fReadMaybe1
                      $dRead_s6Jsn
                      Text.ParserCombinators.ReadPrec.minPrec
                      eta2_s6Jss; } in
        let {
          sat_s6JsM [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_a6H7b)
          [LclId] =
              [ds_s6Jsq] \r [c_s6Jst eta2_s6Jsu]
                  case c_s6Jst of {
                    GHC.Types.I# x_s6Jsw [Occ=Once] ->
                        case <=# [x_s6Jsw 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6JsJ [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                [LclId] =
                                    [ds_s6Jsq eta2_s6Jsu] \r [a1_s6Jsy]
                                        let {
                                          sat_s6JsG [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                          [LclId] =
                                              [ds_s6Jsq eta2_s6Jsu] \r [a2_s6Jsz]
                                                  let {
                                                    sat_s6JsF [Occ=Once]
                                                      :: GHC.Base.Maybe a_a6H7b
                                                         -> Text.ParserCombinators.ReadP.P b1_i6HIg
                                                    [LclId] =
                                                        [eta2_s6Jsu] \r [a3_s6JsA]
                                                            let {
                                                              sat_s6JsC [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b1_i6HIg
                                                              [LclId] =
                                                                  [eta2_s6Jsu
                                                                   a3_s6JsA] \r [a4_s6JsB]
                                                                      eta2_s6Jsu a3_s6JsA;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Monoid.$fReadFirst2
                                                                      sat_s6JsC
                                                              of
                                                              { Unit# ww1_s6JsE [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6JsE];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Monoid.$fReadFirst6
                                                        ds_s6Jsq
                                                        Data.Monoid.$fReadFirst5
                                                        sat_s6JsF;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Monoid.$fReadFirst_lexeme sat_s6JsG
                                          of
                                          { Unit# ww1_s6JsI [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6JsI];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect Data.Monoid.$fReadFirst_lexeme1 sat_s6JsJ
                                of
                                { Unit# ww1_s6JsL [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6JsL];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6JsM eta_s6Jso eta1_s6Jsp;

Data.Monoid.$fReadFirst_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.First a)
[GblId, Arity=2, Str=<L,U(A,A,C(C1(U)),A)><L,U>, Unf=OtherCon []] =
    [] \r [$dRead_s6JsN n_s6JsO]
        let {
          sat_s6JsP [Occ=Once]
            :: Text.ParserCombinators.ReadP.P (Data.Monoid.First a_X6HaX)
          [LclId] =
              [$dRead_s6JsN n_s6JsO] \u []
                  Data.Monoid.$fReadFirst1
                      $dRead_s6JsN
                      n_s6JsO
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6JsP;

Data.Monoid.$fReadFirst_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec [Data.Monoid.First a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6JsQ]
        let {
          sat_s6JsR [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_X6HaV)
          [LclId] =
              [$dRead_s6JsQ] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadFirst1 $dRead_s6JsQ eta_B2 eta_B1;
        } in  GHC.Read.list sat_s6JsR;

Data.Monoid.$fReadFirst_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Monoid.First a]
[GblId, Arity=1, Str=<L,U(A,A,C(C1(U)),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6JsS]
        let {
          sat_s6JsU [Occ=Once]
            :: Text.ParserCombinators.ReadP.P [Data.Monoid.First a_X6HaW]
          [LclId] =
              [$dRead_s6JsS] \u []
                  let {
                    sat_s6JsT [Occ=Once]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Monoid.First a_X6HaW)
                    [LclId] =
                        [$dRead_s6JsS] \r [eta_B2 eta_B1]
                            Data.Monoid.$fReadFirst1 $dRead_s6JsS eta_B2 eta_B1;
                  } in 
                    GHC.Read.list
                        sat_s6JsT
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6JsU;

Data.Monoid.$fReadFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Read.Read a => GHC.Read.Read (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(C1(U)),A)>m] =
    [] \r [$dRead_s6JsV]
        let {
          sat_s6JsZ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Monoid.First a_X6HaU]
          [LclId] =
              [$dRead_s6JsV] \u []
                  Data.Monoid.$fReadFirst_$creadListPrec $dRead_s6JsV; } in
        let {
          sat_s6JsY [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Monoid.First a_X6HaU)
          [LclId] =
              [$dRead_s6JsV] \r [eta_B2 eta_B1]
                  Data.Monoid.$fReadFirst1 $dRead_s6JsV eta_B2 eta_B1; } in
        let {
          sat_s6JsX [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS [Data.Monoid.First a_X6HaU]
          [LclId] =
              [$dRead_s6JsV] \u []
                  Data.Monoid.$fReadFirst_$creadList $dRead_s6JsV; } in
        let {
          sat_s6JsW [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS (Data.Monoid.First a_X6HaU)
          [LclId] =
              [$dRead_s6JsV] \r [eta_B1]
                  Data.Monoid.$fReadFirst_$creadsPrec $dRead_s6JsV eta_B1;
        } in  GHC.Read.C:Read [sat_s6JsW sat_s6JsX sat_s6JsY sat_s6JsZ];

Data.Monoid.$fEqFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Monoid.First a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(C(C1(U)),A)>m] =
    [] \r [$dEq_s6Jt0]
        let {
          sat_s6Jt2 [Occ=Once]
            :: Data.Monoid.First a_a6H4O
               -> Data.Monoid.First a_a6H4O -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Jt0] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c/= $dEq_s6Jt0 eta_B2 eta_B1; } in
        let {
          sat_s6Jt1 [Occ=Once]
            :: Data.Monoid.First a_a6H4O
               -> Data.Monoid.First a_a6H4O -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6Jt0] \r [eta_B2 eta_B1]
                  GHC.Base.$fEqMaybe_$c== $dEq_s6Jt0 eta_B2 eta_B1;
        } in  GHC.Classes.C:Eq [sat_s6Jt1 sat_s6Jt2];

Data.Monoid.$fOrdFirst_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Monoid.First a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6Jt3]
        let {
          sat_s6Jt4 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq a_X6H9m
          [LclId] =
              [$dOrd_s6Jt3] \u [] GHC.Classes.$p1Ord $dOrd_s6Jt3;
        } in  Data.Monoid.$fEqFirst sat_s6Jt4;

Data.Monoid.$fOrdFirst [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Monoid.First a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dOrd_s6Jt5]
        let {
          sat_s6Jtf [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> Data.Monoid.First a_X6H9n
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmin $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jte [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> Data.Monoid.First a_X6H9n
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$cmax $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jtd [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c>= $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jtc [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jt5] \r [a1_s6Jta b_s6Jtb]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6Jt5 b_s6Jtb a1_s6Jta; } in
        let {
          sat_s6Jt9 [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c<= $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jt8 [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$c< $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jt7 [Occ=Once]
            :: Data.Monoid.First a_X6H9n
               -> Data.Monoid.First a_X6H9n -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6Jt5] \r [eta_B2 eta_B1]
                  GHC.Base.$fOrdMaybe_$ccompare $dOrd_s6Jt5 eta_B2 eta_B1; } in
        let {
          sat_s6Jt6 [Occ=Once] :: GHC.Classes.Eq (Data.Monoid.First a_X6H9n)
          [LclId] =
              [$dOrd_s6Jt5] \u [] Data.Monoid.$fOrdFirst_$cp1Ord $dOrd_s6Jt5;
        } in 
          GHC.Classes.C:Ord [sat_s6Jt6
                             sat_s6Jt7
                             sat_s6Jt8
                             sat_s6Jt9
                             sat_s6Jtc
                             sat_s6Jtd
                             sat_s6Jte
                             sat_s6Jtf];

Data.Monoid.getFirst
  :: forall a. Data.Monoid.First a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Monoid.$fGeneric1First2 eta_B1;

Data.Monoid.getLast
  :: forall a. Data.Monoid.Last a -> GHC.Base.Maybe a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Monoid.$fGeneric1Last2 eta_B1;

Data.Monoid.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Monoid.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$trModule4];

Data.Monoid.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Monoid"#;

Data.Monoid.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$trModule2];

Data.Monoid.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Monoid.$trModule3
                                     Data.Monoid.$trModule1];

$krep_r6I1r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep1_r6I1s :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep_r6I1r GHC.Types.[]];

$krep2_r6I1t :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Base.$tcMaybe
                                              $krep1_r6I1s];

Data.Monoid.$tcFirst1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$fReadFirst11];

Data.Monoid.$tcFirst :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12072287807032806756##
                                    12788244796562536401##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tcFirst1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep3_r6I1u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Monoid.$tcFirst
                                              $krep1_r6I1s];

Data.Monoid.$tc'First1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6I1t $krep3_r6I1u];

Data.Monoid.$tc'First3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'First"#;

Data.Monoid.$tc'First2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$tc'First3];

Data.Monoid.$tc'First :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7752528083504400280##
                                    15965132804789246607##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tc'First2
                                    1#
                                    Data.Monoid.$tc'First1];

Data.Monoid.$tcLast1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$fReadLast5];

Data.Monoid.$tcLast :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [6920195955404695016##
                                    2388797855174213212##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tcLast1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep4_r6I1v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Monoid.$tcLast
                                              $krep1_r6I1s];

Data.Monoid.$tc'Last1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6I1t $krep4_r6I1v];

Data.Monoid.$tc'Last3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Last"#;

Data.Monoid.$tc'Last2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Monoid.$tc'Last3];

Data.Monoid.$tc'Last :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [5411164464353425083##
                                    12998161994081761510##
                                    Data.Monoid.$trModule
                                    Data.Monoid.$tc'Last2
                                    1#
                                    Data.Monoid.$tc'Last1];

