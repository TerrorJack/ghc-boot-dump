
==================== Pre unarise: ====================
2018-03-16 16:08:58.520440538 UTC

Data.Bifoldable.bifold
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m. GHC.Base.Monoid m => p m m -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdL8U]
        case v_sdL8U of {
          Data.Bifoldable.C:Bifoldable v_sdL8W [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdL8W;
        };

Data.Bifoldable.bifoldMap
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> p a b -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdL90]
        case v_sdL90 of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       v_sdL93 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdL93;
        };

Data.Bifoldable.bifoldr
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdL96]
        case v_sdL96 of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdL9a [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdL9a;
        };

Data.Bifoldable.bifoldl
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdL9c]
        case v_sdL9c of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdL9h [Occ=Once] ->
              v_sdL9h;
        };

Data.Bifoldable.$fBifoldable(,)_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdL9i f_sdL9j g_sdL9k ds_sdL9l]
        let {
          sat_sdL9v [Occ=Once] :: m_adKxe
          [LclId] =
              [g_sdL9k ds_sdL9l] \u []
                  let {
                    sat_sdL9u [Occ=Once] :: b_adKxg
                    [LclId] =
                        [ds_sdL9l] \u []
                            case ds_sdL9l of {
                              (,) _ [Occ=Dead] b1_sdL9t [Occ=Once] -> b1_sdL9t;
                            };
                  } in  g_sdL9k sat_sdL9u; } in
        let {
          sat_sdL9q [Occ=Once] :: m_adKxe
          [LclId] =
              [f_sdL9j ds_sdL9l] \u []
                  let {
                    sat_sdL9p [Occ=Once] :: a_adKxf
                    [LclId] =
                        [ds_sdL9l] \u []
                            case ds_sdL9l of {
                              (,) a1_sdL9n [Occ=Once] _ [Occ=Dead] -> a1_sdL9n;
                            };
                  } in  f_sdL9j sat_sdL9p;
        } in  GHC.Base.mappend $dMonoid_sdL9i sat_sdL9q sat_sdL9v;

Data.Bifoldable.$fBifoldableConst_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Functor.Const.Const a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdL9w f_sdL9x ds_sdL9y ds1_sdL9z]
        f_sdL9x ds1_sdL9z;

Data.Bifoldable.$fBifoldableK1_$cbifoldMap
  :: forall i m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> GHC.Generics.K1 i a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdL9A f_sdL9B ds_sdL9C ds1_sdL9D]
        f_sdL9B ds1_sdL9D;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap
  :: forall x m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdL9E f_sdL9F g_sdL9G ds_sdL9H]
        let {
          sat_sdL9T [Occ=Once] :: m_adKv0
          [LclId] =
              [g_sdL9G ds_sdL9H] \u []
                  let {
                    sat_sdL9S [Occ=Once] :: b_adKv2
                    [LclId] =
                        [ds_sdL9H] \u []
                            case ds_sdL9H of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdL9R [Occ=Once] -> b1_sdL9R;
                            };
                  } in  g_sdL9G sat_sdL9S; } in
        let {
          sat_sdL9N [Occ=Once] :: m_adKv0
          [LclId] =
              [f_sdL9F ds_sdL9H] \u []
                  let {
                    sat_sdL9M [Occ=Once] :: a_adKv1
                    [LclId] =
                        [ds_sdL9H] \u []
                            case ds_sdL9H of {
                              (,,) _ [Occ=Dead] a1_sdL9K [Occ=Once] _ [Occ=Dead] -> a1_sdL9K;
                            };
                  } in  f_sdL9F sat_sdL9M;
        } in  GHC.Base.mappend $dMonoid_sdL9E sat_sdL9N sat_sdL9T;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap
  :: forall x y m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdL9U f_sdL9V g_sdL9W ds_sdL9X]
        let {
          sat_sdLab [Occ=Once] :: m_adKue
          [LclId] =
              [g_sdL9W ds_sdL9X] \u []
                  let {
                    sat_sdLaa [Occ=Once] :: b_adKug
                    [LclId] =
                        [ds_sdL9X] \u []
                            case ds_sdL9X of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdLa9 [Occ=Once] ->
                                  b1_sdLa9;
                            };
                  } in  g_sdL9W sat_sdLaa; } in
        let {
          sat_sdLa4 [Occ=Once] :: m_adKue
          [LclId] =
              [f_sdL9V ds_sdL9X] \u []
                  let {
                    sat_sdLa3 [Occ=Once] :: a_adKuf
                    [LclId] =
                        [ds_sdL9X] \u []
                            case ds_sdL9X of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdLa1 [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdLa1;
                            };
                  } in  f_sdL9V sat_sdLa3;
        } in  GHC.Base.mappend $dMonoid_sdL9U sat_sdLa4 sat_sdLab;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap
  :: forall x y z m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLac f_sdLad g_sdLae ds_sdLaf]
        let {
          sat_sdLav [Occ=Once] :: m_adKtr
          [LclId] =
              [g_sdLae ds_sdLaf] \u []
                  let {
                    sat_sdLau [Occ=Once] :: b_adKtt
                    [LclId] =
                        [ds_sdLaf] \u []
                            case ds_sdLaf of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdLat [Occ=Once] ->
                                  b1_sdLat;
                            };
                  } in  g_sdLae sat_sdLau; } in
        let {
          sat_sdLan [Occ=Once] :: m_adKtr
          [LclId] =
              [f_sdLad ds_sdLaf] \u []
                  let {
                    sat_sdLam [Occ=Once] :: a_adKts
                    [LclId] =
                        [ds_sdLaf] \u []
                            case ds_sdLaf of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdLak [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdLak;
                            };
                  } in  f_sdLad sat_sdLam;
        } in  GHC.Base.mappend $dMonoid_sdLac sat_sdLan sat_sdLav;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap
  :: forall x y z w m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, w, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLaw f_sdLax g_sdLay ds_sdLaz]
        let {
          sat_sdLaR [Occ=Once] :: m_adKsD
          [LclId] =
              [g_sdLay ds_sdLaz] \u []
                  let {
                    sat_sdLaQ [Occ=Once] :: b_adKsF
                    [LclId] =
                        [ds_sdLaz] \u []
                            case ds_sdLaz of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdLaP [Occ=Once] ->
                                  b1_sdLaP;
                            };
                  } in  g_sdLay sat_sdLaQ; } in
        let {
          sat_sdLaI [Occ=Once] :: m_adKsD
          [LclId] =
              [f_sdLax ds_sdLaz] \u []
                  let {
                    sat_sdLaH [Occ=Once] :: a_adKsE
                    [LclId] =
                        [ds_sdLaz] \u []
                            case ds_sdLaz of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdLaF [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdLaF;
                            };
                  } in  f_sdLax sat_sdLaH;
        } in  GHC.Base.mappend $dMonoid_sdLaw sat_sdLaI sat_sdLaR;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap
  :: forall x y z w v m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, w, v, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLaS f_sdLaT g_sdLaU ds_sdLaV]
        let {
          sat_sdLbf [Occ=Once] :: m_adKrO
          [LclId] =
              [g_sdLaU ds_sdLaV] \u []
                  let {
                    sat_sdLbe [Occ=Once] :: b_adKrQ
                    [LclId] =
                        [ds_sdLaV] \u []
                            case ds_sdLaV of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdLbd [Occ=Once] ->
                                  b1_sdLbd;
                            };
                  } in  g_sdLaU sat_sdLbe; } in
        let {
          sat_sdLb5 [Occ=Once] :: m_adKrO
          [LclId] =
              [f_sdLaT ds_sdLaV] \u []
                  let {
                    sat_sdLb4 [Occ=Once] :: a_adKrP
                    [LclId] =
                        [ds_sdLaV] \u []
                            case ds_sdLaV of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdLb2 [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdLb2;
                            };
                  } in  f_sdLaT sat_sdLb4;
        } in  GHC.Base.mappend $dMonoid_sdLaS sat_sdLb5 sat_sdLbf;

Data.Bifoldable.$fBifoldableEither_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Either.Either a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLbg f_sdLbh ds_sdLbi ds1_sdLbj]
        case ds1_sdLbj of {
          Data.Either.Left a1_sdLbl [Occ=Once] -> f_sdLbh a1_sdLbl;
          Data.Either.Right b1_sdLbm [Occ=Once] -> ds_sdLbi b1_sdLbm;
        };

poly_$dMonoid_rdL8r
  :: forall c.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo c))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Bifoldable.$dmbifoldl
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
[GblId,
 Arity=5,
 Str=<S(LC(C(C(C(S))))LL),1*U(A,1*C1(C1(C1(C1(U)))),A,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLbn f_sdLbo g_sdLbp z_sdLbq t_sdLbr]
        let {
          sat_sdLbx [Occ=Once]
            :: b_adKqf
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo c_adKqd)
          [LclId] =
              [g_sdLbp] \r [x_sdLbv y_sdLbw] g_sdLbp y_sdLbw x_sdLbv; } in
        let {
          sat_sdLbu [Occ=Once]
            :: a_adKqe
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo c_adKqd)
          [LclId] =
              [f_sdLbo] \r [x_sdLbs y_sdLbt] f_sdLbo y_sdLbt x_sdLbs;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLbn
              poly_$dMonoid_rdL8r
              sat_sdLbu
              sat_sdLbx
              t_sdLbr
              z_sdLbq;

Data.Bifoldable.$dmbifoldr
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
[GblId,
 Arity=5,
 Str=<S(LC(C(C(C(S))))LL),1*U(A,1*C1(C1(C1(C1(U)))),A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLby f_sdLbz g_sdLbA z_sdLbB t_sdLbC]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdLby
            Data.Semigroup.Internal.$fMonoidEndo
            f_sdLbz
            g_sdLbA
            t_sdLbC
            z_sdLbB;

Data.Bifoldable.$dmbifoldMap
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> p a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLbD $dMonoid_sdLbE f_sdLbF g_sdLbG]
        let {
          sat_sdLbN [Occ=Once] :: m_adKpn
          [LclId] =
              [$dMonoid_sdLbE] \u [] GHC.Base.mempty $dMonoid_sdLbE; } in
        let {
          sat_sdLbM [Occ=Once] :: b_adKpp -> m_adKpn -> m_adKpn
          [LclId] =
              [$dMonoid_sdLbE g_sdLbG] \r [x_sdLbK]
                  let {
                    sat_sdLbL [Occ=Once] :: m_adKpn
                    [LclId] =
                        [g_sdLbG x_sdLbK] \u [] g_sdLbG x_sdLbK;
                  } in  GHC.Base.mappend $dMonoid_sdLbE sat_sdLbL; } in
        let {
          sat_sdLbJ [Occ=Once] :: a_adKpo -> m_adKpn -> m_adKpn
          [LclId] =
              [$dMonoid_sdLbE f_sdLbF] \r [x_sdLbH]
                  let {
                    sat_sdLbI [Occ=Once] :: m_adKpn
                    [LclId] =
                        [f_sdLbF x_sdLbH] \u [] f_sdLbF x_sdLbH;
                  } in  GHC.Base.mappend $dMonoid_sdLbE sat_sdLbI;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLbD sat_sdLbJ sat_sdLbM sat_sdLbN;

Data.Bifoldable.$dmbifold
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m. GHC.Base.Monoid m => p m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLbO $dMonoid_sdLbP]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdLbO $dMonoid_sdLbP GHC.Base.id GHC.Base.id;

Data.Bifoldable.$fBifoldableEither_$cbifold
  :: forall m. GHC.Base.Monoid m => Data.Either.Either m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLbQ ds_sdLbR]
        case ds_sdLbR of {
          Data.Either.Left a_sdLbT [Occ=Once] -> a_sdLbT;
          Data.Either.Right b_sdLbU [Occ=Once] -> b_sdLbU;
        };

Data.Bifoldable.$fBifoldableEither_$cbifoldr
  :: forall a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> Data.Either.Either a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdLbV g_sdLbW z_sdLbX t_sdLbY]
        case t_sdLbY of {
          Data.Either.Left a1_sdLc0 [Occ=Once] -> f_sdLbV a1_sdLc0 z_sdLbX;
          Data.Either.Right b1_sdLc1 [Occ=Once] -> g_sdLbW b1_sdLc1 z_sdLbX;
        };

Data.Bifoldable.$fBifoldableEither_$cbifoldl
  :: forall c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> Data.Either.Either a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdLc2 g_sdLc3 z_sdLc4 t_sdLc5]
        case t_sdLc5 of {
          Data.Either.Left a1_sdLc7 [Occ=Once] -> f_sdLc2 z_sdLc4 a1_sdLc7;
          Data.Either.Right b1_sdLc8 [Occ=Once] -> g_sdLc3 z_sdLc4 b1_sdLc8;
        };

Data.Bifoldable.$fBifoldableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableEither_$cbifold
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold
  :: forall x y z w v m.
     GHC.Base.Monoid m =>
     (x, y, z, w, v, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLc9 ds_sdLca]
        let {
          sat_sdLcs [Occ=Once] :: m_adKrE
          [LclId] =
              [ds_sdLca] \u []
                  case ds_sdLca of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b_sdLcr [Occ=Once] ->
                        b_sdLcr;
                  }; } in
        let {
          sat_sdLcj [Occ=Once] :: m_adKrE
          [LclId] =
              [ds_sdLca] \u []
                  case ds_sdLca of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a_sdLch [Occ=Once]
                             _ [Occ=Dead] ->
                        a_sdLch;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLc9 sat_sdLcj sat_sdLcs;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr
  :: forall x y z w v a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, w, v, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLct g_sdLcu z1_sdLcv t_sdLcw]
        let {
          sat_sdLcP [Occ=Once] :: c_adKs0
          [LclId] =
              [g_sdLcu z1_sdLcv t_sdLcw] \u []
                  let {
                    sat_sdLcO [Occ=Once] :: b_adKs1
                    [LclId] =
                        [t_sdLcw] \u []
                            case t_sdLcw of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdLcN [Occ=Once] ->
                                  b1_sdLcN;
                            };
                  } in  g_sdLcu sat_sdLcO z1_sdLcv; } in
        let {
          sat_sdLcF [Occ=Once] :: a_adKrZ
          [LclId] =
              [t_sdLcw] \u []
                  case t_sdLcw of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a1_sdLcD [Occ=Once]
                             _ [Occ=Dead] ->
                        a1_sdLcD;
                  };
        } in  f_sdLct sat_sdLcF sat_sdLcP;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl
  :: forall x y z w v c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, w, v, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLcQ g_sdLcR z1_sdLcS t_sdLcT]
        let {
          sat_sdLdc [Occ=Once] :: b_adKsd
          [LclId] =
              [t_sdLcT] \u []
                  case t_sdLcT of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b1_sdLdb [Occ=Once] ->
                        b1_sdLdb;
                  }; } in
        let {
          sat_sdLd3 [Occ=Once] :: c_adKsb
          [LclId] =
              [f_sdLcQ z1_sdLcS t_sdLcT] \u []
                  let {
                    sat_sdLd2 [Occ=Once] :: a_adKsc
                    [LclId] =
                        [t_sdLcT] \u []
                            case t_sdLcT of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdLd0 [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdLd0;
                            };
                  } in  f_sdLcQ z1_sdLcS sat_sdLd2;
        } in  g_sdLcR sat_sdLd3 sat_sdLdc;

Data.Bifoldable.$fBifoldable(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w v.
     Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold
  :: forall x y z w m. GHC.Base.Monoid m => (x, y, z, w, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLdd ds_sdLde]
        let {
          sat_sdLdu [Occ=Once] :: m_adKst
          [LclId] =
              [ds_sdLde] \u []
                  case ds_sdLde of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b_sdLdt [Occ=Once] ->
                        b_sdLdt;
                  }; } in
        let {
          sat_sdLdm [Occ=Once] :: m_adKst
          [LclId] =
              [ds_sdLde] \u []
                  case ds_sdLde of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a_sdLdk [Occ=Once]
                            _ [Occ=Dead] ->
                        a_sdLdk;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLdd sat_sdLdm sat_sdLdu;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr
  :: forall x y z w a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, w, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLdv g_sdLdw z1_sdLdx t_sdLdy]
        let {
          sat_sdLdP [Occ=Once] :: c_adKsP
          [LclId] =
              [g_sdLdw z1_sdLdx t_sdLdy] \u []
                  let {
                    sat_sdLdO [Occ=Once] :: b_adKsQ
                    [LclId] =
                        [t_sdLdy] \u []
                            case t_sdLdy of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdLdN [Occ=Once] ->
                                  b1_sdLdN;
                            };
                  } in  g_sdLdw sat_sdLdO z1_sdLdx; } in
        let {
          sat_sdLdG [Occ=Once] :: a_adKsO
          [LclId] =
              [t_sdLdy] \u []
                  case t_sdLdy of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a1_sdLdE [Occ=Once]
                            _ [Occ=Dead] ->
                        a1_sdLdE;
                  };
        } in  f_sdLdv sat_sdLdG sat_sdLdP;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl
  :: forall x y z w c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, w, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLdQ g_sdLdR z1_sdLdS t_sdLdT]
        let {
          sat_sdLea [Occ=Once] :: b_adKt2
          [LclId] =
              [t_sdLdT] \u []
                  case t_sdLdT of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b1_sdLe9 [Occ=Once] ->
                        b1_sdLe9;
                  }; } in
        let {
          sat_sdLe2 [Occ=Once] :: c_adKt0
          [LclId] =
              [f_sdLdQ z1_sdLdS t_sdLdT] \u []
                  let {
                    sat_sdLe1 [Occ=Once] :: a_adKt1
                    [LclId] =
                        [t_sdLdT] \u []
                            case t_sdLdT of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdLdZ [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdLdZ;
                            };
                  } in  f_sdLdQ z1_sdLdS sat_sdLe1;
        } in  g_sdLdR sat_sdLe2 sat_sdLea;

Data.Bifoldable.$fBifoldable(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w. Data.Bifoldable.Bifoldable ((,,,,,) x y z w)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,)_$cbifold
  :: forall x y z m. GHC.Base.Monoid m => (x, y, z, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLeb ds_sdLec]
        let {
          sat_sdLeq [Occ=Once] :: m_adKth
          [LclId] =
              [ds_sdLec] \u []
                  case ds_sdLec of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b_sdLep [Occ=Once] ->
                        b_sdLep;
                  }; } in
        let {
          sat_sdLej [Occ=Once] :: m_adKth
          [LclId] =
              [ds_sdLec] \u []
                  case ds_sdLec of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a_sdLeh [Occ=Once]
                           _ [Occ=Dead] ->
                        a_sdLeh;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLeb sat_sdLej sat_sdLeq;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr
  :: forall x y z a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLer g_sdLes z1_sdLet t_sdLeu]
        let {
          sat_sdLeJ [Occ=Once] :: c_adKtD
          [LclId] =
              [g_sdLes z1_sdLet t_sdLeu] \u []
                  let {
                    sat_sdLeI [Occ=Once] :: b_adKtE
                    [LclId] =
                        [t_sdLeu] \u []
                            case t_sdLeu of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdLeH [Occ=Once] ->
                                  b1_sdLeH;
                            };
                  } in  g_sdLes sat_sdLeI z1_sdLet; } in
        let {
          sat_sdLeB [Occ=Once] :: a_adKtC
          [LclId] =
              [t_sdLeu] \u []
                  case t_sdLeu of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a1_sdLez [Occ=Once]
                           _ [Occ=Dead] ->
                        a1_sdLez;
                  };
        } in  f_sdLer sat_sdLeB sat_sdLeJ;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl
  :: forall x y z c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLeK g_sdLeL z1_sdLeM t_sdLeN]
        let {
          sat_sdLf2 [Occ=Once] :: b_adKtQ
          [LclId] =
              [t_sdLeN] \u []
                  case t_sdLeN of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b1_sdLf1 [Occ=Once] ->
                        b1_sdLf1;
                  }; } in
        let {
          sat_sdLeV [Occ=Once] :: c_adKtO
          [LclId] =
              [f_sdLeK z1_sdLeM t_sdLeN] \u []
                  let {
                    sat_sdLeU [Occ=Once] :: a_adKtP
                    [LclId] =
                        [t_sdLeN] \u []
                            case t_sdLeN of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdLeS [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdLeS;
                            };
                  } in  f_sdLeK z1_sdLeM sat_sdLeU;
        } in  g_sdLeL sat_sdLeV sat_sdLf2;

Data.Bifoldable.$fBifoldable(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z. Data.Bifoldable.Bifoldable ((,,,,) x y z)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,)_$cbifold
  :: forall x y m. GHC.Base.Monoid m => (x, y, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLf3 ds_sdLf4]
        let {
          sat_sdLfg [Occ=Once] :: m_adKu4
          [LclId] =
              [ds_sdLf4] \u []
                  case ds_sdLf4 of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b_sdLff [Occ=Once] ->
                        b_sdLff;
                  }; } in
        let {
          sat_sdLfa [Occ=Once] :: m_adKu4
          [LclId] =
              [ds_sdLf4] \u []
                  case ds_sdLf4 of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a_sdLf8 [Occ=Once] _ [Occ=Dead] ->
                        a_sdLf8;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLf3 sat_sdLfa sat_sdLfg;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr
  :: forall x y a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLfh g_sdLfi z_sdLfj t_sdLfk]
        let {
          sat_sdLfx [Occ=Once] :: c_adKuq
          [LclId] =
              [g_sdLfi z_sdLfj t_sdLfk] \u []
                  let {
                    sat_sdLfw [Occ=Once] :: b_adKur
                    [LclId] =
                        [t_sdLfk] \u []
                            case t_sdLfk of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdLfv [Occ=Once] ->
                                  b1_sdLfv;
                            };
                  } in  g_sdLfi sat_sdLfw z_sdLfj; } in
        let {
          sat_sdLfq [Occ=Once] :: a_adKup
          [LclId] =
              [t_sdLfk] \u []
                  case t_sdLfk of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdLfo [Occ=Once] _ [Occ=Dead] ->
                        a1_sdLfo;
                  };
        } in  f_sdLfh sat_sdLfq sat_sdLfx;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl
  :: forall x y c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLfy g_sdLfz z_sdLfA t_sdLfB]
        let {
          sat_sdLfO [Occ=Once] :: b_adKuD
          [LclId] =
              [t_sdLfB] \u []
                  case t_sdLfB of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdLfN [Occ=Once] ->
                        b1_sdLfN;
                  }; } in
        let {
          sat_sdLfI [Occ=Once] :: c_adKuB
          [LclId] =
              [f_sdLfy z_sdLfA t_sdLfB] \u []
                  let {
                    sat_sdLfH [Occ=Once] :: a_adKuC
                    [LclId] =
                        [t_sdLfB] \u []
                            case t_sdLfB of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdLfF [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdLfF;
                            };
                  } in  f_sdLfy z_sdLfA sat_sdLfH;
        } in  g_sdLfz sat_sdLfI sat_sdLfO;

Data.Bifoldable.$fBifoldable(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y. Data.Bifoldable.Bifoldable ((,,,) x y)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,)_$cbifold
  :: forall x m. GHC.Base.Monoid m => (x, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLfP ds_sdLfQ]
        let {
          sat_sdLg0 [Occ=Once] :: m_adKuQ
          [LclId] =
              [ds_sdLfQ] \u []
                  case ds_sdLfQ of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b_sdLfZ [Occ=Once] -> b_sdLfZ;
                  }; } in
        let {
          sat_sdLfV [Occ=Once] :: m_adKuQ
          [LclId] =
              [ds_sdLfQ] \u []
                  case ds_sdLfQ of {
                    (,,) _ [Occ=Dead] a_sdLfT [Occ=Once] _ [Occ=Dead] -> a_sdLfT;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLfP sat_sdLfV sat_sdLg0;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldr
  :: forall x a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLg1 g_sdLg2 z_sdLg3 t_sdLg4]
        let {
          sat_sdLgf [Occ=Once] :: c_adKvc
          [LclId] =
              [g_sdLg2 z_sdLg3 t_sdLg4] \u []
                  let {
                    sat_sdLge [Occ=Once] :: b_adKvd
                    [LclId] =
                        [t_sdLg4] \u []
                            case t_sdLg4 of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdLgd [Occ=Once] -> b1_sdLgd;
                            };
                  } in  g_sdLg2 sat_sdLge z_sdLg3; } in
        let {
          sat_sdLg9 [Occ=Once] :: a_adKvb
          [LclId] =
              [t_sdLg4] \u []
                  case t_sdLg4 of {
                    (,,) _ [Occ=Dead] a1_sdLg7 [Occ=Once] _ [Occ=Dead] -> a1_sdLg7;
                  };
        } in  f_sdLg1 sat_sdLg9 sat_sdLgf;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldl
  :: forall x c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLgg g_sdLgh z_sdLgi t_sdLgj]
        let {
          sat_sdLgu [Occ=Once] :: b_adKvp
          [LclId] =
              [t_sdLgj] \u []
                  case t_sdLgj of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdLgt [Occ=Once] -> b1_sdLgt;
                  }; } in
        let {
          sat_sdLgp [Occ=Once] :: c_adKvn
          [LclId] =
              [f_sdLgg z_sdLgi t_sdLgj] \u []
                  let {
                    sat_sdLgo [Occ=Once] :: a_adKvo
                    [LclId] =
                        [t_sdLgj] \u []
                            case t_sdLgj of {
                              (,,) _ [Occ=Dead] a1_sdLgm [Occ=Once] _ [Occ=Dead] -> a1_sdLgm;
                            };
                  } in  f_sdLgg z_sdLgi sat_sdLgo;
        } in  g_sdLgh sat_sdLgp sat_sdLgu;

Data.Bifoldable.$fBifoldable(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x. Data.Bifoldable.Bifoldable ((,,) x)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldl];

Data.Bifoldable.$fBifoldableK2
  :: forall i m.
     GHC.Base.Monoid m =>
     GHC.Generics.K1 i m m -> GHC.Generics.K1 i m m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLgv ds_sdLgw] ds_sdLgw;

Data.Bifoldable.$fBifoldableK1_$cbifoldr
  :: forall i a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> GHC.Generics.K1 i a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdLgx g_sdLgy z_sdLgz t_sdLgA] f_sdLgx t_sdLgA z_sdLgz;

Data.Bifoldable.$fBifoldableK1_$cbifoldl
  :: forall i c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> GHC.Generics.K1 i a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdLgB g_sdLgC z_sdLgD t_sdLgE] f_sdLgB z_sdLgD t_sdLgE;

Data.Bifoldable.$fBifoldableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bifoldable.Bifoldable (GHC.Generics.K1 i)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableK2
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldl];

Data.Bifoldable.$fBifoldableConst1
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Const.Const m m -> Data.Functor.Const.Const m m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLgF ds_sdLgG] ds_sdLgG;

Data.Bifoldable.$fBifoldableConst_$cbifoldr
  :: forall a c b.
     (a -> c -> c)
     -> (b -> c -> c) -> c -> Data.Functor.Const.Const a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdLgH g_sdLgI z_sdLgJ t_sdLgK] f_sdLgH t_sdLgK z_sdLgJ;

Data.Bifoldable.$fBifoldableConst_$cbifoldl
  :: forall c a b.
     (c -> a -> c)
     -> (c -> b -> c) -> c -> Data.Functor.Const.Const a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdLgL g_sdLgM z_sdLgN t_sdLgO] f_sdLgL z_sdLgN t_sdLgO;

Data.Bifoldable.$fBifoldableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Functor.Const.Const
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableConst1
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldl];

Data.Bifoldable.$fBifoldable(,)_$cbifold
  :: forall m. GHC.Base.Monoid m => (m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLgP ds_sdLgQ]
        let {
          sat_sdLgY [Occ=Once] :: m_adKx4
          [LclId] =
              [ds_sdLgQ] \u []
                  case ds_sdLgQ of {
                    (,) _ [Occ=Dead] b_sdLgX [Occ=Once] -> b_sdLgX;
                  }; } in
        let {
          sat_sdLgU [Occ=Once] :: m_adKx4
          [LclId] =
              [ds_sdLgQ] \u []
                  case ds_sdLgQ of {
                    (,) a_sdLgS [Occ=Once] _ [Occ=Dead] -> a_sdLgS;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLgP sat_sdLgU sat_sdLgY;

Data.Bifoldable.$fBifoldable(,)_$cbifoldr
  :: forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> (a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLgZ g_sdLh0 z_sdLh1 t_sdLh2]
        let {
          sat_sdLhb [Occ=Once] :: c_adKxq
          [LclId] =
              [g_sdLh0 z_sdLh1 t_sdLh2] \u []
                  let {
                    sat_sdLha [Occ=Once] :: b_adKxr
                    [LclId] =
                        [t_sdLh2] \u []
                            case t_sdLh2 of {
                              (,) _ [Occ=Dead] b1_sdLh9 [Occ=Once] -> b1_sdLh9;
                            };
                  } in  g_sdLh0 sat_sdLha z_sdLh1; } in
        let {
          sat_sdLh6 [Occ=Once] :: a_adKxp
          [LclId] =
              [t_sdLh2] \u []
                  case t_sdLh2 of {
                    (,) a1_sdLh4 [Occ=Once] _ [Occ=Dead] -> a1_sdLh4;
                  };
        } in  f_sdLgZ sat_sdLh6 sat_sdLhb;

Data.Bifoldable.$fBifoldable(,)_$cbifoldl
  :: forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> (a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLhc g_sdLhd z_sdLhe t_sdLhf]
        let {
          sat_sdLho [Occ=Once] :: b_adKxD
          [LclId] =
              [t_sdLhf] \u []
                  case t_sdLhf of {
                    (,) _ [Occ=Dead] b1_sdLhn [Occ=Once] -> b1_sdLhn;
                  }; } in
        let {
          sat_sdLhk [Occ=Once] :: c_adKxB
          [LclId] =
              [f_sdLhc z_sdLhe t_sdLhf] \u []
                  let {
                    sat_sdLhj [Occ=Once] :: a_adKxC
                    [LclId] =
                        [t_sdLhf] \u []
                            case t_sdLhf of {
                              (,) a1_sdLhh [Occ=Once] _ [Occ=Dead] -> a1_sdLhh;
                            };
                  } in  f_sdLhc z_sdLhe sat_sdLhj;
        } in  g_sdLhd sat_sdLhk sat_sdLho;

Data.Bifoldable.$fBifoldable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldl];

Data.Bifoldable.bifoldr'
  :: forall (t :: * -> * -> *) a c b.
     Data.Bifoldable.Bifoldable t =>
     (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLhp f_sdLhq g_sdLhr z0_sdLhs xs_sdLht]
        let {
          sat_sdLhD [Occ=Once]
            :: (c_adKoc -> c_adKoc) -> b_adKod -> c_adKoc -> c_adKoc
          [LclId] =
              [g_sdLhr] \r [k_sdLhz x_sdLhA z_sdLhB]
                  case g_sdLhr x_sdLhA z_sdLhB of vx_sdLhC {
                    __DEFAULT -> k_sdLhz vx_sdLhC;
                  }; } in
        let {
          sat_sdLhy [Occ=Once]
            :: (c_adKoc -> c_adKoc) -> a_adKob -> c_adKoc -> c_adKoc
          [LclId] =
              [f_sdLhq] \r [k_sdLhu x_sdLhv z_sdLhw]
                  case f_sdLhq x_sdLhv z_sdLhw of vx_sdLhx {
                    __DEFAULT -> k_sdLhu vx_sdLhx;
                  };
        } in 
          Data.Bifoldable.bifoldl
              $dBifoldable_sdLhp
              sat_sdLhy
              sat_sdLhD
              GHC.Base.id
              xs_sdLht
              z0_sdLhs;

lvl_rdL8s :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

lvl1_rdL8t :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_rdL8s;

Data.Bifoldable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl2_rdL8u :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bifoldable.$trModule4;

Data.Bifoldable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bifoldable"#;

lvl3_rdL8v :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bifoldable.$trModule2;

lvl4_rdL8w :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Data/Bifoldable.hs"#;

lvl5_rdL8x :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_rdL8w;

lvl6_rdL8y :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [188#];

lvl7_rdL8z :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [28#];

lvl8_rdL8A :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [61#];

lvl9_rdL8B :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl6_rdL8y
                                           lvl7_rdL8z
                                           lvl6_rdL8y
                                           lvl8_rdL8A];

lvl10_rdL8C :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl9_rdL8B
                                                  GHC.Stack.Types.EmptyCallStack];

lvl11_rdL8D :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bifoldr1: empty structure"#;

Data.Bifoldable.bifoldr2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_rdL8D of sat_sdLhE {
          __DEFAULT -> GHC.Err.error lvl10_rdL8C sat_sdLhE;
        };

Data.Bifoldable.bifoldr1
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> a) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLhF f_sdLhG xs_sdLhH]
        let {
          mbf_sdLhI
            :: a_adKmT -> GHC.Base.Maybe a_adKmT -> GHC.Base.Maybe a_adKmT
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [f_sdLhG] \r [x_sdLhJ m_sdLhK]
                  let {
                    sat_sdLhN [Occ=Once] :: a_adKmT
                    [LclId] =
                        [f_sdLhG x_sdLhJ m_sdLhK] \u []
                            case m_sdLhK of {
                              GHC.Base.Nothing -> x_sdLhJ;
                              GHC.Base.Just y_sdLhM [Occ=Once] -> f_sdLhG x_sdLhJ y_sdLhM;
                            };
                  } in  GHC.Base.Just [sat_sdLhN];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdLhF mbf_sdLhI mbf_sdLhI GHC.Base.Nothing xs_sdLhH
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdLhP [Occ=Once] -> v_sdLhP;
          };

Data.Bifoldable.bimaximumBy
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLhQ cmp_sdLhR xs_sdLhS]
        let {
          mbf_sdLhT
            :: a_adKnp -> GHC.Base.Maybe a_adKnp -> GHC.Base.Maybe a_adKnp
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [cmp_sdLhR] \r [x_sdLhU m_sdLhV]
                  let {
                    sat_sdLhZ [Occ=Once] :: a_adKnp
                    [LclId] =
                        [cmp_sdLhR x_sdLhU m_sdLhV] \u []
                            case m_sdLhV of {
                              GHC.Base.Nothing -> x_sdLhU;
                              GHC.Base.Just y_sdLhX ->
                                  case cmp_sdLhR x_sdLhU y_sdLhX of {
                                    __DEFAULT -> y_sdLhX;
                                    GHC.Types.GT -> x_sdLhU;
                                  };
                            };
                  } in  GHC.Base.Just [sat_sdLhZ];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdLhQ mbf_sdLhT mbf_sdLhT GHC.Base.Nothing xs_sdLhS
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdLi1 [Occ=Once] -> v_sdLi1;
          };

Data.Bifoldable.biminimumBy
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLi2 cmp_sdLi3 xs_sdLi4]
        let {
          mbf_sdLi5
            :: a_adKnN -> GHC.Base.Maybe a_adKnN -> GHC.Base.Maybe a_adKnN
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [cmp_sdLi3] \r [x_sdLi6 m_sdLi7]
                  let {
                    sat_sdLib [Occ=Once] :: a_adKnN
                    [LclId] =
                        [cmp_sdLi3 x_sdLi6 m_sdLi7] \u []
                            case m_sdLi7 of {
                              GHC.Base.Nothing -> x_sdLi6;
                              GHC.Base.Just y_sdLi9 ->
                                  case cmp_sdLi3 x_sdLi6 y_sdLi9 of {
                                    __DEFAULT -> x_sdLi6;
                                    GHC.Types.GT -> y_sdLi9;
                                  };
                            };
                  } in  GHC.Base.Just [sat_sdLib];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdLi2 mbf_sdLi5 mbf_sdLi5 GHC.Base.Nothing xs_sdLi4
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdLid [Occ=Once] -> v_sdLid;
          };

Data.Bifoldable.bifoldrM
  :: forall (t :: * -> * -> *) (m :: * -> *) a c b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Monad m) =>
     (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLie
           $dMonad_sdLif
           f_sdLig
           g_sdLih
           z0_sdLii
           xs_sdLij]
        let {
          sat_sdLiu [Occ=Once] :: c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdLif] \u [] GHC.Base.return $dMonad_sdLif; } in
        let {
          sat_sdLit [Occ=Once]
            :: (c_adKlQ -> m_adKlO c_adKlQ)
               -> b_adKlR -> c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdLif g_sdLih] \r [k_sdLip x_sdLiq z_sdLir]
                  let {
                    sat_sdLis [Occ=Once] :: m_adKlO c_adKlQ
                    [LclId] =
                        [g_sdLih x_sdLiq z_sdLir] \u [] g_sdLih x_sdLiq z_sdLir;
                  } in  GHC.Base.>>= $dMonad_sdLif sat_sdLis k_sdLip; } in
        let {
          sat_sdLio [Occ=Once]
            :: (c_adKlQ -> m_adKlO c_adKlQ)
               -> a_adKlP -> c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdLif f_sdLig] \r [k_sdLik x_sdLil z_sdLim]
                  let {
                    sat_sdLin [Occ=Once] :: m_adKlO c_adKlQ
                    [LclId] =
                        [f_sdLig x_sdLil z_sdLim] \u [] f_sdLig x_sdLil z_sdLim;
                  } in  GHC.Base.>>= $dMonad_sdLif sat_sdLin k_sdLik;
        } in 
          Data.Bifoldable.bifoldl
              $dBifoldable_sdLie sat_sdLio sat_sdLit sat_sdLiu xs_sdLij z0_sdLii;

Data.Bifoldable.bifoldl'
  :: forall (t :: * -> * -> *) a b c.
     Data.Bifoldable.Bifoldable t =>
     (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLiv f_sdLiw g_sdLix z0_sdLiy xs_sdLiz]
        let {
          sat_sdLiJ [Occ=Once]
            :: c_adKky -> (a_adKkw -> a_adKkw) -> a_adKkw -> a_adKkw
          [LclId] =
              [g_sdLix] \r [x_sdLiF k_sdLiG z_sdLiH]
                  case g_sdLix z_sdLiH x_sdLiF of vx_sdLiI {
                    __DEFAULT -> k_sdLiG vx_sdLiI;
                  }; } in
        let {
          sat_sdLiE [Occ=Once]
            :: b_adKkx -> (a_adKkw -> a_adKkw) -> a_adKkw -> a_adKkw
          [LclId] =
              [f_sdLiw] \r [x_sdLiA k_sdLiB z_sdLiC]
                  case f_sdLiw z_sdLiC x_sdLiA of vx_sdLiD {
                    __DEFAULT -> k_sdLiB vx_sdLiD;
                  };
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLiv
              sat_sdLiE
              sat_sdLiJ
              GHC.Base.id
              xs_sdLiz
              z0_sdLiy;

Data.Bifoldable.bilength2
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sdLiK k_sdLiL z_sdLiM]
        case z_sdLiM of {
          GHC.Types.I# x1_sdLiO [Occ=Once] ->
              case +# [x1_sdLiO 1#] of sat_sdLiP {
                __DEFAULT ->
                    let {
                      sat_sdLiQ [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sdLiP];
                    } in  k_sdLiL sat_sdLiQ;
              };
        };

Data.Bifoldable.bilength1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Bifoldable.bilength
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     t a b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLiR eta_sdLiS]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdLiR
            Data.Bifoldable.bilength2
            Data.Bifoldable.bilength2
            GHC.Base.id
            eta_sdLiS
            Data.Bifoldable.bilength1;

lvl12_rdL8E :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [223#];

lvl13_rdL8F :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl12_rdL8E
                                           lvl7_rdL8z
                                           lvl12_rdL8E
                                           lvl8_rdL8A];

lvl14_rdL8G :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl13_rdL8F
                                                  GHC.Stack.Types.EmptyCallStack];

lvl15_rdL8H :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bifoldl1: empty structure"#;

Data.Bifoldable.bifoldl2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl15_rdL8H of sat_sdLiT {
          __DEFAULT -> GHC.Err.error lvl14_rdL8G sat_sdLiT;
        };

Data.Bifoldable.bifoldl1
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> a) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLiU f_sdLiV xs_sdLiW]
        let {
          mbf_sdLiX
            :: GHC.Base.Maybe a_adKk0 -> a_adKk0 -> GHC.Base.Maybe a_adKk0
          [LclId, Arity=2, Str=<L,1*U><L,U>, Unf=OtherCon []] =
              [f_sdLiV] \r [m_sdLiY y_sdLiZ]
                  let {
                    sat_sdLj2 [Occ=Once] :: a_adKk0
                    [LclId] =
                        [f_sdLiV m_sdLiY y_sdLiZ] \u []
                            case m_sdLiY of {
                              GHC.Base.Nothing -> y_sdLiZ;
                              GHC.Base.Just x_sdLj1 [Occ=Once] -> f_sdLiV x_sdLj1 y_sdLiZ;
                            };
                  } in  GHC.Base.Just [sat_sdLj2];
        } in 
          case
              Data.Bifoldable.bifoldl
                  $dBifoldable_sdLiU mbf_sdLiX mbf_sdLiX GHC.Base.Nothing xs_sdLiW
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldl2;
            GHC.Base.Just v_sdLj4 [Occ=Once] -> v_sdLj4;
          };

Data.Bifoldable.bifoldlM
  :: forall (t :: * -> * -> *) (m :: * -> *) a b c.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Monad m) =>
     (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLj5
           $dMonad_sdLj6
           f_sdLj7
           g_sdLj8
           z0_sdLj9
           xs_sdLja]
        let {
          sat_sdLjl [Occ=Once] :: a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdLj6] \u [] GHC.Base.return $dMonad_sdLj6; } in
        let {
          sat_sdLjk [Occ=Once]
            :: c_adKiY
               -> (a_adKiW -> m_adKiV a_adKiW) -> a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdLj6 g_sdLj8] \r [x_sdLjg k_sdLjh z_sdLji]
                  let {
                    sat_sdLjj [Occ=Once] :: m_adKiV a_adKiW
                    [LclId] =
                        [g_sdLj8 x_sdLjg z_sdLji] \u [] g_sdLj8 z_sdLji x_sdLjg;
                  } in  GHC.Base.>>= $dMonad_sdLj6 sat_sdLjj k_sdLjh; } in
        let {
          sat_sdLjf [Occ=Once]
            :: b_adKiX
               -> (a_adKiW -> m_adKiV a_adKiW) -> a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdLj6 f_sdLj7] \r [x_sdLjb k_sdLjc z_sdLjd]
                  let {
                    sat_sdLje [Occ=Once] :: m_adKiV a_adKiW
                    [LclId] =
                        [f_sdLj7 x_sdLjb z_sdLjd] \u [] f_sdLj7 z_sdLjd x_sdLjb;
                  } in  GHC.Base.>>= $dMonad_sdLj6 sat_sdLje k_sdLjc;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLj5 sat_sdLjf sat_sdLjk sat_sdLjl xs_sdLja z0_sdLj9;

Data.Bifoldable.bitraverse_
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjm $dApplicative_sdLjn f1_sdLjo g_sdLjp]
        let {
          sat_sdLjw [Occ=Once] :: f_adKhx ()
          [LclId] =
              [$dApplicative_sdLjn] \u []
                  GHC.Base.pure $dApplicative_sdLjn GHC.Tuple.(); } in
        let {
          sat_sdLjv [Occ=Once] :: b_adKhA -> f_adKhx () -> f_adKhx ()
          [LclId] =
              [$dApplicative_sdLjn g_sdLjp] \r [x_sdLjt]
                  let {
                    sat_sdLju [Occ=Once] :: f_adKhx d_adKhB
                    [LclId] =
                        [g_sdLjp x_sdLjt] \u [] g_sdLjp x_sdLjt;
                  } in  GHC.Base.*> $dApplicative_sdLjn sat_sdLju; } in
        let {
          sat_sdLjs [Occ=Once] :: a_adKhy -> f_adKhx () -> f_adKhx ()
          [LclId] =
              [$dApplicative_sdLjn f1_sdLjo] \r [x_sdLjq]
                  let {
                    sat_sdLjr [Occ=Once] :: f_adKhx c_adKhz
                    [LclId] =
                        [f1_sdLjo x_sdLjq] \u [] f1_sdLjo x_sdLjq;
                  } in  GHC.Base.*> $dApplicative_sdLjn sat_sdLjr;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLjm sat_sdLjs sat_sdLjv sat_sdLjw;

Data.Bifoldable.bifor_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f ()
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjx
           $dApplicative_sdLjy
           t1_sdLjz
           f1_sdLjA
           g_sdLjB]
        Data.Bifoldable.bitraverse_
            $dBifoldable_sdLjx $dApplicative_sdLjy f1_sdLjA g_sdLjB t1_sdLjz;

Data.Bifoldable.biforM_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f ()
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bifor_ eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bimapM_
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bitraverse_ eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bisequence_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,U,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjC $dApplicative_sdLjD]
        let {
          sat_sdLjG [Occ=Once] :: f_adKgV ()
          [LclId] =
              [$dApplicative_sdLjD] \u []
                  GHC.Base.pure $dApplicative_sdLjD GHC.Tuple.(); } in
        let {
          sat_sdLjF [Occ=Once] :: f_adKgV b_adKgX -> f_adKgV () -> f_adKgV ()
          [LclId] =
              [$dApplicative_sdLjD] \u [] GHC.Base.*> $dApplicative_sdLjD; } in
        let {
          sat_sdLjE [Occ=Once] :: f_adKgV a_adKgW -> f_adKgV () -> f_adKgV ()
          [LclId] =
              [$dApplicative_sdLjD] \u [] GHC.Base.*> $dApplicative_sdLjD;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLjC sat_sdLjE sat_sdLjF sat_sdLjG;

Data.Bifoldable.bisequenceA_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.bisequence_ eta_B2 eta_B1;

Data.Bifoldable.biasum
  :: forall (t :: * -> * -> *) (f :: * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Alternative f) =>
     t (f a) (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjH $dAlternative_sdLjI]
        let {
          sat_sdLjL [Occ=Once] :: f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdLjI] \u []
                  GHC.Base.empty $dAlternative_sdLjI; } in
        let {
          sat_sdLjK [Occ=Once]
            :: f_adKgo a_adKgp -> f_adKgo a_adKgp -> f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdLjI] \u [] GHC.Base.<|> $dAlternative_sdLjI; } in
        let {
          sat_sdLjJ [Occ=Once]
            :: f_adKgo a_adKgp -> f_adKgo a_adKgp -> f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdLjI] \u [] GHC.Base.<|> $dAlternative_sdLjI;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLjH sat_sdLjJ sat_sdLjK sat_sdLjL;

Data.Bifoldable.bimsum
  :: forall (t :: * -> * -> *) (f :: * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Alternative f) =>
     t (f a) (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,U,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.biasum eta_B2 eta_B1;

Data.Bifoldable.biList
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     t a a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjM]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdLjM GHC.Types.: GHC.Types.: GHC.Types.[];

Data.Bifoldable.binull1
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdLjN ds1_sdLjO] GHC.Types.False [];

Data.Bifoldable.binull
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     t a b -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjP]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdLjP
            Data.Bifoldable.binull1
            Data.Bifoldable.binull1
            GHC.Types.True;

Data.Bifoldable.biconcat
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     t [a] [a] -> [a]
[GblId,
 Arity=1,
 Str=<S(C(S)LLL),1*U(1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjQ]
        Data.Bifoldable.bifold $dBifoldable_sdLjQ GHC.Base.$fMonoid[];

lvl16_rdL8I :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [334#];

lvl17_rdL8J :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [24#];

lvl18_rdL8K :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [58#];

lvl19_rdL8L :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl16_rdL8I
                                           lvl17_rdL8J
                                           lvl16_rdL8I
                                           lvl18_rdL8K];

lvl20_rdL8M :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl19_rdL8L
                                                  GHC.Stack.Types.EmptyCallStack];

lvl21_rdL8N :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bimaximum: empty structure"#;

Data.Bifoldable.bimaximum1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl21_rdL8N of sat_sdLjR {
          __DEFAULT -> GHC.Err.error lvl20_rdL8M sat_sdLjR;
        };

Data.Bifoldable.bimaximum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Ord a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjS $dOrd_sdLjT]
        let {
          g_sdLjU [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKeD a_adKeE a_adKeE -> Data.Functor.Utils.Max a_adKeE
          [LclId] =
              [$dBifoldable_sdLjS $dOrd_sdLjT] \u []
                  let {
                    sat_sdLjV [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Max a_adKeE)
                    [LclId] =
                        [$dOrd_sdLjT] \u [] Data.Functor.Utils.$fMonoidMax $dOrd_sdLjT;
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdLjS sat_sdLjV GHC.Base.Just GHC.Base.Just; } in
        let {
          sat_sdLjZ [Occ=OnceT[0]] :: t_adKeD a_adKeE a_adKeE -> a_adKeE
          [LclId] =
              [g_sdLjU] \r [x_sdLjW]
                  case g_sdLjU x_sdLjW of {
                    GHC.Base.Nothing -> Data.Bifoldable.bimaximum1;
                    GHC.Base.Just v_sdLjY [Occ=Once] -> v_sdLjY;
                  };
        } in  sat_sdLjZ;

lvl22_rdL8O :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [342#];

lvl23_rdL8P :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl22_rdL8O
                                           lvl17_rdL8J
                                           lvl22_rdL8O
                                           lvl18_rdL8K];

lvl24_rdL8Q :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl23_rdL8P
                                                  GHC.Stack.Types.EmptyCallStack];

lvl25_rdL8R :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "biminimum: empty structure"#;

Data.Bifoldable.biminimum1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl25_rdL8R of sat_sdLk0 {
          __DEFAULT -> GHC.Err.error lvl24_rdL8Q sat_sdLk0;
        };

Data.Bifoldable.biminimum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Ord a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLk1 $dOrd_sdLk2]
        let {
          g_sdLk3 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKdQ a_adKdR a_adKdR -> Data.Functor.Utils.Min a_adKdR
          [LclId] =
              [$dBifoldable_sdLk1 $dOrd_sdLk2] \u []
                  let {
                    sat_sdLk4 [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Min a_adKdR)
                    [LclId] =
                        [$dOrd_sdLk2] \u [] Data.Functor.Utils.$fMonoidMin $dOrd_sdLk2;
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdLk1 sat_sdLk4 GHC.Base.Just GHC.Base.Just; } in
        let {
          sat_sdLk8 [Occ=OnceT[0]] :: t_adKdQ a_adKdR a_adKdR -> a_adKdR
          [LclId] =
              [g_sdLk3] \r [x_sdLk5]
                  case g_sdLk3 x_sdLk5 of {
                    GHC.Base.Nothing -> Data.Bifoldable.biminimum1;
                    GHC.Base.Just v_sdLk7 [Occ=Once] -> v_sdLk7;
                  };
        } in  sat_sdLk8;

Data.Bifoldable.biproduct2 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdLk9] v_sdLk9;

Data.Bifoldable.bisum1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLka $dNum_sdLkb]
        let {
          sat_sdLkc [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_adKdy)
          [LclId] =
              [$dNum_sdLkb] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sdLkb;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLka
              sat_sdLkc
              Data.Bifoldable.biproduct2
              Data.Bifoldable.biproduct2;

Data.Bifoldable.bisum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.bisum1 eta_B2 eta_B1;

Data.Bifoldable.biproduct1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkd $dNum_sdLke]
        let {
          sat_sdLkf [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_adKdf)
          [LclId] =
              [$dNum_sdLke] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sdLke;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLkd
              sat_sdLkf
              Data.Bifoldable.biproduct2
              Data.Bifoldable.biproduct2;

Data.Bifoldable.biproduct
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.biproduct1 eta_B2 eta_B1;

Data.Bifoldable.biconcatMap
  :: forall (t :: * -> * -> *) a c b.
     Data.Bifoldable.Bifoldable t =>
     (a -> [c]) -> (b -> [c]) -> t a b -> [c]
[GblId,
 Arity=1,
 Str=<S(LC(S)LL),1*U(A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkg]
        Data.Bifoldable.bifoldMap $dBifoldable_sdLkg GHC.Base.$fMonoid[];

Data.Bifoldable.biand2 :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdLkh] v_sdLkh;

Data.Bifoldable.biand1
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLki]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdLki
            Data.Semigroup.Internal.$fMonoidAll
            Data.Bifoldable.biand2
            Data.Bifoldable.biand2;

Data.Bifoldable.biand
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Bifoldable.biand1 eta_B1;

Data.Bifoldable.bior1
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkj]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdLkj
            Data.Semigroup.Internal.$fMonoidAny
            Data.Bifoldable.biand2
            Data.Bifoldable.biand2;

Data.Bifoldable.bior
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Bifoldable.bior1 eta_B1;

Data.Bifoldable.biany1
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkk p_sdLkl q_sdLkm]
        let {
          sat_sdLkq [Occ=Once] :: b_adKcd -> Data.Semigroup.Internal.Any
          [LclId] =
              [q_sdLkm] \r [x_sdLkp] q_sdLkm x_sdLkp; } in
        let {
          sat_sdLko [Occ=Once] :: a_adKcc -> Data.Semigroup.Internal.Any
          [LclId] =
              [p_sdLkl] \r [x_sdLkn] p_sdLkl x_sdLkn;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLkk
              Data.Semigroup.Internal.$fMonoidAny
              sat_sdLko
              sat_sdLkq;

Data.Bifoldable.biany
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.biany1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bielem1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkr $dEq_sdLks x_sdLkt]
        let {
          sat_sdLkx [Occ=Once] :: a_adKfA -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_sdLks x_sdLkt] \r [x1_sdLkw]
                  GHC.Classes.== $dEq_sdLks x1_sdLkw x_sdLkt; } in
        let {
          sat_sdLkv [Occ=Once] :: a_adKfA -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_sdLks x_sdLkt] \r [x1_sdLku]
                  GHC.Classes.== $dEq_sdLks x1_sdLku x_sdLkt;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLkr
              Data.Semigroup.Internal.$fMonoidAny
              sat_sdLkv
              sat_sdLkx;

Data.Bifoldable.bielem
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bielem1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.binotElem
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLky $dEq_sdLkz x_sdLkA]
        let {
          g_sdLkB [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKfN a_adKfO a_adKfO -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dBifoldable_sdLky $dEq_sdLkz x_sdLkA] \u []
                  Data.Bifoldable.bielem1 $dBifoldable_sdLky $dEq_sdLkz x_sdLkA; } in
        let {
          sat_sdLkE [Occ=OnceT[0]]
            :: t_adKfN a_adKfO a_adKfO -> GHC.Types.Bool
          [LclId] =
              [g_sdLkB] \r [x1_sdLkC]
                  case g_sdLkB x1_sdLkC of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  sat_sdLkE;

Data.Bifoldable.biall1
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkF p_sdLkG q_sdLkH]
        let {
          sat_sdLkL [Occ=Once] :: b_adKbP -> Data.Semigroup.Internal.All
          [LclId] =
              [q_sdLkH] \r [x_sdLkK] q_sdLkH x_sdLkK; } in
        let {
          sat_sdLkJ [Occ=Once] :: a_adKbO -> Data.Semigroup.Internal.All
          [LclId] =
              [p_sdLkG] \r [x_sdLkI] p_sdLkG x_sdLkI;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLkF
              Data.Semigroup.Internal.$fMonoidAll
              sat_sdLkJ
              sat_sdLkL;

Data.Bifoldable.biall
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.biall1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bifind
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool) -> t a a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkM p_sdLkN]
        let {
          g_sdLkO [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKbl a_adKbm a_adKbm -> Data.Monoid.First a_adKbm
          [LclId] =
              [$dBifoldable_sdLkM p_sdLkN] \u []
                  let {
                    finder_sdLkP :: a_adKbm -> GHC.Base.Maybe a_adKbm
                    [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                        [p_sdLkN] \r [x_sdLkQ]
                            case p_sdLkN x_sdLkQ of {
                              GHC.Types.False -> GHC.Base.Nothing [];
                              GHC.Types.True -> GHC.Base.Just [x_sdLkQ];
                            };
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdLkM
                        Data.Monoid.$fMonoidFirst
                        finder_sdLkP
                        finder_sdLkP; } in
        let {
          sat_sdLkT [Occ=Once]
            :: t_adKbl a_adKbm a_adKbm -> Data.Monoid.First a_adKbm
          [LclId] =
              [g_sdLkO] \r [x_sdLkS] g_sdLkO x_sdLkS;
        } in  sat_sdLkT;

Data.Bifoldable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$trModule4];

Data.Bifoldable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$trModule2];

Data.Bifoldable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bifoldable.$trModule3
                                     Data.Bifoldable.$trModule1];

$krep_rdL8S :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bifoldable.$tcBifoldable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdL8S];

Data.Bifoldable.$tcBifoldable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bifoldable"#;

Data.Bifoldable.$tcBifoldable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$tcBifoldable3];

Data.Bifoldable.$tcBifoldable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13881323671910883383##
                                    7079945659398195047##
                                    Data.Bifoldable.$trModule
                                    Data.Bifoldable.$tcBifoldable2
                                    0#
                                    Data.Bifoldable.$tcBifoldable1];

Data.Bifoldable.C:Bifoldable
  :: forall (p :: * -> * -> *).
     (forall m. GHC.Base.Monoid m => p m m -> m)
     -> (forall m a b.
         GHC.Base.Monoid m =>
         (a -> m) -> (b -> m) -> p a b -> m)
     -> (forall a c b.
         (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c)
     -> (forall c a b.
         (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c)
     -> Data.Bifoldable.Bifoldable p
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.C:Bifoldable [eta_B4 eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:08:58.563459966 UTC

Data.Bifoldable.bifold
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m. GHC.Base.Monoid m => p m m -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdL8U]
        case v_sdL8U of {
          Data.Bifoldable.C:Bifoldable v_sdL8W [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdL8W;
        };

Data.Bifoldable.bifoldMap
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> p a b -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdL90]
        case v_sdL90 of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       v_sdL93 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdL93;
        };

Data.Bifoldable.bifoldr
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdL96]
        case v_sdL96 of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdL9a [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdL9a;
        };

Data.Bifoldable.bifoldl
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdL9c]
        case v_sdL9c of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdL9h [Occ=Once] ->
              v_sdL9h;
        };

Data.Bifoldable.$fBifoldable(,)_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdL9i f_sdL9j g_sdL9k ds_sdL9l]
        let {
          sat_sdL9v [Occ=Once] :: m_adKxe
          [LclId] =
              [g_sdL9k ds_sdL9l] \u []
                  let {
                    sat_sdL9u [Occ=Once] :: b_adKxg
                    [LclId] =
                        [ds_sdL9l] \u []
                            case ds_sdL9l of {
                              (,) _ [Occ=Dead] b1_sdL9t [Occ=Once] -> b1_sdL9t;
                            };
                  } in  g_sdL9k sat_sdL9u; } in
        let {
          sat_sdL9q [Occ=Once] :: m_adKxe
          [LclId] =
              [f_sdL9j ds_sdL9l] \u []
                  let {
                    sat_sdL9p [Occ=Once] :: a_adKxf
                    [LclId] =
                        [ds_sdL9l] \u []
                            case ds_sdL9l of {
                              (,) a1_sdL9n [Occ=Once] _ [Occ=Dead] -> a1_sdL9n;
                            };
                  } in  f_sdL9j sat_sdL9p;
        } in  GHC.Base.mappend $dMonoid_sdL9i sat_sdL9q sat_sdL9v;

Data.Bifoldable.$fBifoldableConst_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Functor.Const.Const a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdL9w f_sdL9x ds_sdL9y ds1_sdL9z]
        f_sdL9x ds1_sdL9z;

Data.Bifoldable.$fBifoldableK1_$cbifoldMap
  :: forall i m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> GHC.Generics.K1 i a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdL9A f_sdL9B ds_sdL9C ds1_sdL9D]
        f_sdL9B ds1_sdL9D;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap
  :: forall x m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdL9E f_sdL9F g_sdL9G ds_sdL9H]
        let {
          sat_sdL9T [Occ=Once] :: m_adKv0
          [LclId] =
              [g_sdL9G ds_sdL9H] \u []
                  let {
                    sat_sdL9S [Occ=Once] :: b_adKv2
                    [LclId] =
                        [ds_sdL9H] \u []
                            case ds_sdL9H of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdL9R [Occ=Once] -> b1_sdL9R;
                            };
                  } in  g_sdL9G sat_sdL9S; } in
        let {
          sat_sdL9N [Occ=Once] :: m_adKv0
          [LclId] =
              [f_sdL9F ds_sdL9H] \u []
                  let {
                    sat_sdL9M [Occ=Once] :: a_adKv1
                    [LclId] =
                        [ds_sdL9H] \u []
                            case ds_sdL9H of {
                              (,,) _ [Occ=Dead] a1_sdL9K [Occ=Once] _ [Occ=Dead] -> a1_sdL9K;
                            };
                  } in  f_sdL9F sat_sdL9M;
        } in  GHC.Base.mappend $dMonoid_sdL9E sat_sdL9N sat_sdL9T;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap
  :: forall x y m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdL9U f_sdL9V g_sdL9W ds_sdL9X]
        let {
          sat_sdLab [Occ=Once] :: m_adKue
          [LclId] =
              [g_sdL9W ds_sdL9X] \u []
                  let {
                    sat_sdLaa [Occ=Once] :: b_adKug
                    [LclId] =
                        [ds_sdL9X] \u []
                            case ds_sdL9X of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdLa9 [Occ=Once] ->
                                  b1_sdLa9;
                            };
                  } in  g_sdL9W sat_sdLaa; } in
        let {
          sat_sdLa4 [Occ=Once] :: m_adKue
          [LclId] =
              [f_sdL9V ds_sdL9X] \u []
                  let {
                    sat_sdLa3 [Occ=Once] :: a_adKuf
                    [LclId] =
                        [ds_sdL9X] \u []
                            case ds_sdL9X of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdLa1 [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdLa1;
                            };
                  } in  f_sdL9V sat_sdLa3;
        } in  GHC.Base.mappend $dMonoid_sdL9U sat_sdLa4 sat_sdLab;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap
  :: forall x y z m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLac f_sdLad g_sdLae ds_sdLaf]
        let {
          sat_sdLav [Occ=Once] :: m_adKtr
          [LclId] =
              [g_sdLae ds_sdLaf] \u []
                  let {
                    sat_sdLau [Occ=Once] :: b_adKtt
                    [LclId] =
                        [ds_sdLaf] \u []
                            case ds_sdLaf of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdLat [Occ=Once] ->
                                  b1_sdLat;
                            };
                  } in  g_sdLae sat_sdLau; } in
        let {
          sat_sdLan [Occ=Once] :: m_adKtr
          [LclId] =
              [f_sdLad ds_sdLaf] \u []
                  let {
                    sat_sdLam [Occ=Once] :: a_adKts
                    [LclId] =
                        [ds_sdLaf] \u []
                            case ds_sdLaf of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdLak [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdLak;
                            };
                  } in  f_sdLad sat_sdLam;
        } in  GHC.Base.mappend $dMonoid_sdLac sat_sdLan sat_sdLav;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap
  :: forall x y z w m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, w, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLaw f_sdLax g_sdLay ds_sdLaz]
        let {
          sat_sdLaR [Occ=Once] :: m_adKsD
          [LclId] =
              [g_sdLay ds_sdLaz] \u []
                  let {
                    sat_sdLaQ [Occ=Once] :: b_adKsF
                    [LclId] =
                        [ds_sdLaz] \u []
                            case ds_sdLaz of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdLaP [Occ=Once] ->
                                  b1_sdLaP;
                            };
                  } in  g_sdLay sat_sdLaQ; } in
        let {
          sat_sdLaI [Occ=Once] :: m_adKsD
          [LclId] =
              [f_sdLax ds_sdLaz] \u []
                  let {
                    sat_sdLaH [Occ=Once] :: a_adKsE
                    [LclId] =
                        [ds_sdLaz] \u []
                            case ds_sdLaz of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdLaF [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdLaF;
                            };
                  } in  f_sdLax sat_sdLaH;
        } in  GHC.Base.mappend $dMonoid_sdLaw sat_sdLaI sat_sdLaR;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap
  :: forall x y z w v m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, w, v, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLaS f_sdLaT g_sdLaU ds_sdLaV]
        let {
          sat_sdLbf [Occ=Once] :: m_adKrO
          [LclId] =
              [g_sdLaU ds_sdLaV] \u []
                  let {
                    sat_sdLbe [Occ=Once] :: b_adKrQ
                    [LclId] =
                        [ds_sdLaV] \u []
                            case ds_sdLaV of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdLbd [Occ=Once] ->
                                  b1_sdLbd;
                            };
                  } in  g_sdLaU sat_sdLbe; } in
        let {
          sat_sdLb5 [Occ=Once] :: m_adKrO
          [LclId] =
              [f_sdLaT ds_sdLaV] \u []
                  let {
                    sat_sdLb4 [Occ=Once] :: a_adKrP
                    [LclId] =
                        [ds_sdLaV] \u []
                            case ds_sdLaV of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdLb2 [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdLb2;
                            };
                  } in  f_sdLaT sat_sdLb4;
        } in  GHC.Base.mappend $dMonoid_sdLaS sat_sdLb5 sat_sdLbf;

Data.Bifoldable.$fBifoldableEither_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Either.Either a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLbg f_sdLbh ds_sdLbi ds1_sdLbj]
        case ds1_sdLbj of {
          Data.Either.Left a1_sdLbl [Occ=Once] -> f_sdLbh a1_sdLbl;
          Data.Either.Right b1_sdLbm [Occ=Once] -> ds_sdLbi b1_sdLbm;
        };

poly_$dMonoid_rdL8r
  :: forall c.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo c))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Bifoldable.$dmbifoldl
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
[GblId,
 Arity=5,
 Str=<S(LC(C(C(C(S))))LL),1*U(A,1*C1(C1(C1(C1(U)))),A,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLbn f_sdLbo g_sdLbp z_sdLbq t_sdLbr]
        let {
          sat_sdLbx [Occ=Once]
            :: b_adKqf
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo c_adKqd)
          [LclId] =
              [g_sdLbp] \r [x_sdLbv y_sdLbw] g_sdLbp y_sdLbw x_sdLbv; } in
        let {
          sat_sdLbu [Occ=Once]
            :: a_adKqe
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo c_adKqd)
          [LclId] =
              [f_sdLbo] \r [x_sdLbs y_sdLbt] f_sdLbo y_sdLbt x_sdLbs;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLbn
              poly_$dMonoid_rdL8r
              sat_sdLbu
              sat_sdLbx
              t_sdLbr
              z_sdLbq;

Data.Bifoldable.$dmbifoldr
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
[GblId,
 Arity=5,
 Str=<S(LC(C(C(C(S))))LL),1*U(A,1*C1(C1(C1(C1(U)))),A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLby f_sdLbz g_sdLbA z_sdLbB t_sdLbC]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdLby
            Data.Semigroup.Internal.$fMonoidEndo
            f_sdLbz
            g_sdLbA
            t_sdLbC
            z_sdLbB;

Data.Bifoldable.$dmbifoldMap
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> p a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLbD $dMonoid_sdLbE f_sdLbF g_sdLbG]
        let {
          sat_sdLbN [Occ=Once] :: m_adKpn
          [LclId] =
              [$dMonoid_sdLbE] \u [] GHC.Base.mempty $dMonoid_sdLbE; } in
        let {
          sat_sdLbM [Occ=Once] :: b_adKpp -> m_adKpn -> m_adKpn
          [LclId] =
              [$dMonoid_sdLbE g_sdLbG] \r [x_sdLbK]
                  let {
                    sat_sdLbL [Occ=Once] :: m_adKpn
                    [LclId] =
                        [g_sdLbG x_sdLbK] \u [] g_sdLbG x_sdLbK;
                  } in  GHC.Base.mappend $dMonoid_sdLbE sat_sdLbL; } in
        let {
          sat_sdLbJ [Occ=Once] :: a_adKpo -> m_adKpn -> m_adKpn
          [LclId] =
              [$dMonoid_sdLbE f_sdLbF] \r [x_sdLbH]
                  let {
                    sat_sdLbI [Occ=Once] :: m_adKpn
                    [LclId] =
                        [f_sdLbF x_sdLbH] \u [] f_sdLbF x_sdLbH;
                  } in  GHC.Base.mappend $dMonoid_sdLbE sat_sdLbI;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLbD sat_sdLbJ sat_sdLbM sat_sdLbN;

Data.Bifoldable.$dmbifold
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m. GHC.Base.Monoid m => p m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLbO $dMonoid_sdLbP]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdLbO $dMonoid_sdLbP GHC.Base.id GHC.Base.id;

Data.Bifoldable.$fBifoldableEither_$cbifold
  :: forall m. GHC.Base.Monoid m => Data.Either.Either m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLbQ ds_sdLbR]
        case ds_sdLbR of {
          Data.Either.Left a_sdLbT [Occ=Once] -> a_sdLbT;
          Data.Either.Right b_sdLbU [Occ=Once] -> b_sdLbU;
        };

Data.Bifoldable.$fBifoldableEither_$cbifoldr
  :: forall a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> Data.Either.Either a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdLbV g_sdLbW z_sdLbX t_sdLbY]
        case t_sdLbY of {
          Data.Either.Left a1_sdLc0 [Occ=Once] -> f_sdLbV a1_sdLc0 z_sdLbX;
          Data.Either.Right b1_sdLc1 [Occ=Once] -> g_sdLbW b1_sdLc1 z_sdLbX;
        };

Data.Bifoldable.$fBifoldableEither_$cbifoldl
  :: forall c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> Data.Either.Either a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdLc2 g_sdLc3 z_sdLc4 t_sdLc5]
        case t_sdLc5 of {
          Data.Either.Left a1_sdLc7 [Occ=Once] -> f_sdLc2 z_sdLc4 a1_sdLc7;
          Data.Either.Right b1_sdLc8 [Occ=Once] -> g_sdLc3 z_sdLc4 b1_sdLc8;
        };

Data.Bifoldable.$fBifoldableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableEither_$cbifold
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold
  :: forall x y z w v m.
     GHC.Base.Monoid m =>
     (x, y, z, w, v, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLc9 ds_sdLca]
        let {
          sat_sdLcs [Occ=Once] :: m_adKrE
          [LclId] =
              [ds_sdLca] \u []
                  case ds_sdLca of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b_sdLcr [Occ=Once] ->
                        b_sdLcr;
                  }; } in
        let {
          sat_sdLcj [Occ=Once] :: m_adKrE
          [LclId] =
              [ds_sdLca] \u []
                  case ds_sdLca of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a_sdLch [Occ=Once]
                             _ [Occ=Dead] ->
                        a_sdLch;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLc9 sat_sdLcj sat_sdLcs;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr
  :: forall x y z w v a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, w, v, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLct g_sdLcu z1_sdLcv t_sdLcw]
        let {
          sat_sdLcP [Occ=Once] :: c_adKs0
          [LclId] =
              [g_sdLcu z1_sdLcv t_sdLcw] \u []
                  let {
                    sat_sdLcO [Occ=Once] :: b_adKs1
                    [LclId] =
                        [t_sdLcw] \u []
                            case t_sdLcw of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdLcN [Occ=Once] ->
                                  b1_sdLcN;
                            };
                  } in  g_sdLcu sat_sdLcO z1_sdLcv; } in
        let {
          sat_sdLcF [Occ=Once] :: a_adKrZ
          [LclId] =
              [t_sdLcw] \u []
                  case t_sdLcw of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a1_sdLcD [Occ=Once]
                             _ [Occ=Dead] ->
                        a1_sdLcD;
                  };
        } in  f_sdLct sat_sdLcF sat_sdLcP;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl
  :: forall x y z w v c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, w, v, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLcQ g_sdLcR z1_sdLcS t_sdLcT]
        let {
          sat_sdLdc [Occ=Once] :: b_adKsd
          [LclId] =
              [t_sdLcT] \u []
                  case t_sdLcT of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b1_sdLdb [Occ=Once] ->
                        b1_sdLdb;
                  }; } in
        let {
          sat_sdLd3 [Occ=Once] :: c_adKsb
          [LclId] =
              [f_sdLcQ z1_sdLcS t_sdLcT] \u []
                  let {
                    sat_sdLd2 [Occ=Once] :: a_adKsc
                    [LclId] =
                        [t_sdLcT] \u []
                            case t_sdLcT of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdLd0 [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdLd0;
                            };
                  } in  f_sdLcQ z1_sdLcS sat_sdLd2;
        } in  g_sdLcR sat_sdLd3 sat_sdLdc;

Data.Bifoldable.$fBifoldable(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w v.
     Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold
  :: forall x y z w m. GHC.Base.Monoid m => (x, y, z, w, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLdd ds_sdLde]
        let {
          sat_sdLdu [Occ=Once] :: m_adKst
          [LclId] =
              [ds_sdLde] \u []
                  case ds_sdLde of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b_sdLdt [Occ=Once] ->
                        b_sdLdt;
                  }; } in
        let {
          sat_sdLdm [Occ=Once] :: m_adKst
          [LclId] =
              [ds_sdLde] \u []
                  case ds_sdLde of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a_sdLdk [Occ=Once]
                            _ [Occ=Dead] ->
                        a_sdLdk;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLdd sat_sdLdm sat_sdLdu;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr
  :: forall x y z w a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, w, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLdv g_sdLdw z1_sdLdx t_sdLdy]
        let {
          sat_sdLdP [Occ=Once] :: c_adKsP
          [LclId] =
              [g_sdLdw z1_sdLdx t_sdLdy] \u []
                  let {
                    sat_sdLdO [Occ=Once] :: b_adKsQ
                    [LclId] =
                        [t_sdLdy] \u []
                            case t_sdLdy of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdLdN [Occ=Once] ->
                                  b1_sdLdN;
                            };
                  } in  g_sdLdw sat_sdLdO z1_sdLdx; } in
        let {
          sat_sdLdG [Occ=Once] :: a_adKsO
          [LclId] =
              [t_sdLdy] \u []
                  case t_sdLdy of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a1_sdLdE [Occ=Once]
                            _ [Occ=Dead] ->
                        a1_sdLdE;
                  };
        } in  f_sdLdv sat_sdLdG sat_sdLdP;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl
  :: forall x y z w c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, w, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLdQ g_sdLdR z1_sdLdS t_sdLdT]
        let {
          sat_sdLea [Occ=Once] :: b_adKt2
          [LclId] =
              [t_sdLdT] \u []
                  case t_sdLdT of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b1_sdLe9 [Occ=Once] ->
                        b1_sdLe9;
                  }; } in
        let {
          sat_sdLe2 [Occ=Once] :: c_adKt0
          [LclId] =
              [f_sdLdQ z1_sdLdS t_sdLdT] \u []
                  let {
                    sat_sdLe1 [Occ=Once] :: a_adKt1
                    [LclId] =
                        [t_sdLdT] \u []
                            case t_sdLdT of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdLdZ [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdLdZ;
                            };
                  } in  f_sdLdQ z1_sdLdS sat_sdLe1;
        } in  g_sdLdR sat_sdLe2 sat_sdLea;

Data.Bifoldable.$fBifoldable(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w. Data.Bifoldable.Bifoldable ((,,,,,) x y z w)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,)_$cbifold
  :: forall x y z m. GHC.Base.Monoid m => (x, y, z, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLeb ds_sdLec]
        let {
          sat_sdLeq [Occ=Once] :: m_adKth
          [LclId] =
              [ds_sdLec] \u []
                  case ds_sdLec of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b_sdLep [Occ=Once] ->
                        b_sdLep;
                  }; } in
        let {
          sat_sdLej [Occ=Once] :: m_adKth
          [LclId] =
              [ds_sdLec] \u []
                  case ds_sdLec of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a_sdLeh [Occ=Once]
                           _ [Occ=Dead] ->
                        a_sdLeh;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLeb sat_sdLej sat_sdLeq;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr
  :: forall x y z a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLer g_sdLes z1_sdLet t_sdLeu]
        let {
          sat_sdLeJ [Occ=Once] :: c_adKtD
          [LclId] =
              [g_sdLes z1_sdLet t_sdLeu] \u []
                  let {
                    sat_sdLeI [Occ=Once] :: b_adKtE
                    [LclId] =
                        [t_sdLeu] \u []
                            case t_sdLeu of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdLeH [Occ=Once] ->
                                  b1_sdLeH;
                            };
                  } in  g_sdLes sat_sdLeI z1_sdLet; } in
        let {
          sat_sdLeB [Occ=Once] :: a_adKtC
          [LclId] =
              [t_sdLeu] \u []
                  case t_sdLeu of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a1_sdLez [Occ=Once]
                           _ [Occ=Dead] ->
                        a1_sdLez;
                  };
        } in  f_sdLer sat_sdLeB sat_sdLeJ;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl
  :: forall x y z c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLeK g_sdLeL z1_sdLeM t_sdLeN]
        let {
          sat_sdLf2 [Occ=Once] :: b_adKtQ
          [LclId] =
              [t_sdLeN] \u []
                  case t_sdLeN of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b1_sdLf1 [Occ=Once] ->
                        b1_sdLf1;
                  }; } in
        let {
          sat_sdLeV [Occ=Once] :: c_adKtO
          [LclId] =
              [f_sdLeK z1_sdLeM t_sdLeN] \u []
                  let {
                    sat_sdLeU [Occ=Once] :: a_adKtP
                    [LclId] =
                        [t_sdLeN] \u []
                            case t_sdLeN of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdLeS [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdLeS;
                            };
                  } in  f_sdLeK z1_sdLeM sat_sdLeU;
        } in  g_sdLeL sat_sdLeV sat_sdLf2;

Data.Bifoldable.$fBifoldable(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z. Data.Bifoldable.Bifoldable ((,,,,) x y z)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,)_$cbifold
  :: forall x y m. GHC.Base.Monoid m => (x, y, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLf3 ds_sdLf4]
        let {
          sat_sdLfg [Occ=Once] :: m_adKu4
          [LclId] =
              [ds_sdLf4] \u []
                  case ds_sdLf4 of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b_sdLff [Occ=Once] ->
                        b_sdLff;
                  }; } in
        let {
          sat_sdLfa [Occ=Once] :: m_adKu4
          [LclId] =
              [ds_sdLf4] \u []
                  case ds_sdLf4 of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a_sdLf8 [Occ=Once] _ [Occ=Dead] ->
                        a_sdLf8;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLf3 sat_sdLfa sat_sdLfg;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr
  :: forall x y a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLfh g_sdLfi z_sdLfj t_sdLfk]
        let {
          sat_sdLfx [Occ=Once] :: c_adKuq
          [LclId] =
              [g_sdLfi z_sdLfj t_sdLfk] \u []
                  let {
                    sat_sdLfw [Occ=Once] :: b_adKur
                    [LclId] =
                        [t_sdLfk] \u []
                            case t_sdLfk of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdLfv [Occ=Once] ->
                                  b1_sdLfv;
                            };
                  } in  g_sdLfi sat_sdLfw z_sdLfj; } in
        let {
          sat_sdLfq [Occ=Once] :: a_adKup
          [LclId] =
              [t_sdLfk] \u []
                  case t_sdLfk of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdLfo [Occ=Once] _ [Occ=Dead] ->
                        a1_sdLfo;
                  };
        } in  f_sdLfh sat_sdLfq sat_sdLfx;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl
  :: forall x y c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLfy g_sdLfz z_sdLfA t_sdLfB]
        let {
          sat_sdLfO [Occ=Once] :: b_adKuD
          [LclId] =
              [t_sdLfB] \u []
                  case t_sdLfB of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdLfN [Occ=Once] ->
                        b1_sdLfN;
                  }; } in
        let {
          sat_sdLfI [Occ=Once] :: c_adKuB
          [LclId] =
              [f_sdLfy z_sdLfA t_sdLfB] \u []
                  let {
                    sat_sdLfH [Occ=Once] :: a_adKuC
                    [LclId] =
                        [t_sdLfB] \u []
                            case t_sdLfB of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdLfF [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdLfF;
                            };
                  } in  f_sdLfy z_sdLfA sat_sdLfH;
        } in  g_sdLfz sat_sdLfI sat_sdLfO;

Data.Bifoldable.$fBifoldable(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y. Data.Bifoldable.Bifoldable ((,,,) x y)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,)_$cbifold
  :: forall x m. GHC.Base.Monoid m => (x, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLfP ds_sdLfQ]
        let {
          sat_sdLg0 [Occ=Once] :: m_adKuQ
          [LclId] =
              [ds_sdLfQ] \u []
                  case ds_sdLfQ of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b_sdLfZ [Occ=Once] -> b_sdLfZ;
                  }; } in
        let {
          sat_sdLfV [Occ=Once] :: m_adKuQ
          [LclId] =
              [ds_sdLfQ] \u []
                  case ds_sdLfQ of {
                    (,,) _ [Occ=Dead] a_sdLfT [Occ=Once] _ [Occ=Dead] -> a_sdLfT;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLfP sat_sdLfV sat_sdLg0;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldr
  :: forall x a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLg1 g_sdLg2 z_sdLg3 t_sdLg4]
        let {
          sat_sdLgf [Occ=Once] :: c_adKvc
          [LclId] =
              [g_sdLg2 z_sdLg3 t_sdLg4] \u []
                  let {
                    sat_sdLge [Occ=Once] :: b_adKvd
                    [LclId] =
                        [t_sdLg4] \u []
                            case t_sdLg4 of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdLgd [Occ=Once] -> b1_sdLgd;
                            };
                  } in  g_sdLg2 sat_sdLge z_sdLg3; } in
        let {
          sat_sdLg9 [Occ=Once] :: a_adKvb
          [LclId] =
              [t_sdLg4] \u []
                  case t_sdLg4 of {
                    (,,) _ [Occ=Dead] a1_sdLg7 [Occ=Once] _ [Occ=Dead] -> a1_sdLg7;
                  };
        } in  f_sdLg1 sat_sdLg9 sat_sdLgf;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldl
  :: forall x c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLgg g_sdLgh z_sdLgi t_sdLgj]
        let {
          sat_sdLgu [Occ=Once] :: b_adKvp
          [LclId] =
              [t_sdLgj] \u []
                  case t_sdLgj of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdLgt [Occ=Once] -> b1_sdLgt;
                  }; } in
        let {
          sat_sdLgp [Occ=Once] :: c_adKvn
          [LclId] =
              [f_sdLgg z_sdLgi t_sdLgj] \u []
                  let {
                    sat_sdLgo [Occ=Once] :: a_adKvo
                    [LclId] =
                        [t_sdLgj] \u []
                            case t_sdLgj of {
                              (,,) _ [Occ=Dead] a1_sdLgm [Occ=Once] _ [Occ=Dead] -> a1_sdLgm;
                            };
                  } in  f_sdLgg z_sdLgi sat_sdLgo;
        } in  g_sdLgh sat_sdLgp sat_sdLgu;

Data.Bifoldable.$fBifoldable(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x. Data.Bifoldable.Bifoldable ((,,) x)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldl];

Data.Bifoldable.$fBifoldableK2
  :: forall i m.
     GHC.Base.Monoid m =>
     GHC.Generics.K1 i m m -> GHC.Generics.K1 i m m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLgv ds_sdLgw] ds_sdLgw;

Data.Bifoldable.$fBifoldableK1_$cbifoldr
  :: forall i a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> GHC.Generics.K1 i a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdLgx g_sdLgy z_sdLgz t_sdLgA] f_sdLgx t_sdLgA z_sdLgz;

Data.Bifoldable.$fBifoldableK1_$cbifoldl
  :: forall i c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> GHC.Generics.K1 i a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdLgB g_sdLgC z_sdLgD t_sdLgE] f_sdLgB z_sdLgD t_sdLgE;

Data.Bifoldable.$fBifoldableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bifoldable.Bifoldable (GHC.Generics.K1 i)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableK2
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldl];

Data.Bifoldable.$fBifoldableConst1
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Const.Const m m -> Data.Functor.Const.Const m m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLgF ds_sdLgG] ds_sdLgG;

Data.Bifoldable.$fBifoldableConst_$cbifoldr
  :: forall a c b.
     (a -> c -> c)
     -> (b -> c -> c) -> c -> Data.Functor.Const.Const a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdLgH g_sdLgI z_sdLgJ t_sdLgK] f_sdLgH t_sdLgK z_sdLgJ;

Data.Bifoldable.$fBifoldableConst_$cbifoldl
  :: forall c a b.
     (c -> a -> c)
     -> (c -> b -> c) -> c -> Data.Functor.Const.Const a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdLgL g_sdLgM z_sdLgN t_sdLgO] f_sdLgL z_sdLgN t_sdLgO;

Data.Bifoldable.$fBifoldableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Functor.Const.Const
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableConst1
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldl];

Data.Bifoldable.$fBifoldable(,)_$cbifold
  :: forall m. GHC.Base.Monoid m => (m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdLgP ds_sdLgQ]
        let {
          sat_sdLgY [Occ=Once] :: m_adKx4
          [LclId] =
              [ds_sdLgQ] \u []
                  case ds_sdLgQ of {
                    (,) _ [Occ=Dead] b_sdLgX [Occ=Once] -> b_sdLgX;
                  }; } in
        let {
          sat_sdLgU [Occ=Once] :: m_adKx4
          [LclId] =
              [ds_sdLgQ] \u []
                  case ds_sdLgQ of {
                    (,) a_sdLgS [Occ=Once] _ [Occ=Dead] -> a_sdLgS;
                  };
        } in  GHC.Base.mappend $dMonoid_sdLgP sat_sdLgU sat_sdLgY;

Data.Bifoldable.$fBifoldable(,)_$cbifoldr
  :: forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> (a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLgZ g_sdLh0 z_sdLh1 t_sdLh2]
        let {
          sat_sdLhb [Occ=Once] :: c_adKxq
          [LclId] =
              [g_sdLh0 z_sdLh1 t_sdLh2] \u []
                  let {
                    sat_sdLha [Occ=Once] :: b_adKxr
                    [LclId] =
                        [t_sdLh2] \u []
                            case t_sdLh2 of {
                              (,) _ [Occ=Dead] b1_sdLh9 [Occ=Once] -> b1_sdLh9;
                            };
                  } in  g_sdLh0 sat_sdLha z_sdLh1; } in
        let {
          sat_sdLh6 [Occ=Once] :: a_adKxp
          [LclId] =
              [t_sdLh2] \u []
                  case t_sdLh2 of {
                    (,) a1_sdLh4 [Occ=Once] _ [Occ=Dead] -> a1_sdLh4;
                  };
        } in  f_sdLgZ sat_sdLh6 sat_sdLhb;

Data.Bifoldable.$fBifoldable(,)_$cbifoldl
  :: forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> (a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdLhc g_sdLhd z_sdLhe t_sdLhf]
        let {
          sat_sdLho [Occ=Once] :: b_adKxD
          [LclId] =
              [t_sdLhf] \u []
                  case t_sdLhf of {
                    (,) _ [Occ=Dead] b1_sdLhn [Occ=Once] -> b1_sdLhn;
                  }; } in
        let {
          sat_sdLhk [Occ=Once] :: c_adKxB
          [LclId] =
              [f_sdLhc z_sdLhe t_sdLhf] \u []
                  let {
                    sat_sdLhj [Occ=Once] :: a_adKxC
                    [LclId] =
                        [t_sdLhf] \u []
                            case t_sdLhf of {
                              (,) a1_sdLhh [Occ=Once] _ [Occ=Dead] -> a1_sdLhh;
                            };
                  } in  f_sdLhc z_sdLhe sat_sdLhj;
        } in  g_sdLhd sat_sdLhk sat_sdLho;

Data.Bifoldable.$fBifoldable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldl];

Data.Bifoldable.bifoldr'
  :: forall (t :: * -> * -> *) a c b.
     Data.Bifoldable.Bifoldable t =>
     (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLhp f_sdLhq g_sdLhr z0_sdLhs xs_sdLht]
        let {
          sat_sdLhD [Occ=Once]
            :: (c_adKoc -> c_adKoc) -> b_adKod -> c_adKoc -> c_adKoc
          [LclId] =
              [g_sdLhr] \r [k_sdLhz x_sdLhA z_sdLhB]
                  case g_sdLhr x_sdLhA z_sdLhB of vx_sdLhC {
                    __DEFAULT -> k_sdLhz vx_sdLhC;
                  }; } in
        let {
          sat_sdLhy [Occ=Once]
            :: (c_adKoc -> c_adKoc) -> a_adKob -> c_adKoc -> c_adKoc
          [LclId] =
              [f_sdLhq] \r [k_sdLhu x_sdLhv z_sdLhw]
                  case f_sdLhq x_sdLhv z_sdLhw of vx_sdLhx {
                    __DEFAULT -> k_sdLhu vx_sdLhx;
                  };
        } in 
          Data.Bifoldable.bifoldl
              $dBifoldable_sdLhp
              sat_sdLhy
              sat_sdLhD
              GHC.Base.id
              xs_sdLht
              z0_sdLhs;

lvl_rdL8s :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

lvl1_rdL8t :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_rdL8s;

Data.Bifoldable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl2_rdL8u :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bifoldable.$trModule4;

Data.Bifoldable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bifoldable"#;

lvl3_rdL8v :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bifoldable.$trModule2;

lvl4_rdL8w :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Data/Bifoldable.hs"#;

lvl5_rdL8x :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_rdL8w;

lvl6_rdL8y :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [188#];

lvl7_rdL8z :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [28#];

lvl8_rdL8A :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [61#];

lvl9_rdL8B :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl6_rdL8y
                                           lvl7_rdL8z
                                           lvl6_rdL8y
                                           lvl8_rdL8A];

lvl10_rdL8C :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl9_rdL8B
                                                  GHC.Stack.Types.EmptyCallStack];

lvl11_rdL8D :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bifoldr1: empty structure"#;

Data.Bifoldable.bifoldr2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_rdL8D of sat_sdLhE {
          __DEFAULT -> GHC.Err.error lvl10_rdL8C sat_sdLhE;
        };

Data.Bifoldable.bifoldr1
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> a) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLhF f_sdLhG xs_sdLhH]
        let {
          mbf_sdLhI
            :: a_adKmT -> GHC.Base.Maybe a_adKmT -> GHC.Base.Maybe a_adKmT
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [f_sdLhG] \r [x_sdLhJ m_sdLhK]
                  let {
                    sat_sdLhN [Occ=Once] :: a_adKmT
                    [LclId] =
                        [f_sdLhG x_sdLhJ m_sdLhK] \u []
                            case m_sdLhK of {
                              GHC.Base.Nothing -> x_sdLhJ;
                              GHC.Base.Just y_sdLhM [Occ=Once] -> f_sdLhG x_sdLhJ y_sdLhM;
                            };
                  } in  GHC.Base.Just [sat_sdLhN];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdLhF mbf_sdLhI mbf_sdLhI GHC.Base.Nothing xs_sdLhH
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdLhP [Occ=Once] -> v_sdLhP;
          };

Data.Bifoldable.bimaximumBy
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLhQ cmp_sdLhR xs_sdLhS]
        let {
          mbf_sdLhT
            :: a_adKnp -> GHC.Base.Maybe a_adKnp -> GHC.Base.Maybe a_adKnp
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [cmp_sdLhR] \r [x_sdLhU m_sdLhV]
                  let {
                    sat_sdLhZ [Occ=Once] :: a_adKnp
                    [LclId] =
                        [cmp_sdLhR x_sdLhU m_sdLhV] \u []
                            case m_sdLhV of {
                              GHC.Base.Nothing -> x_sdLhU;
                              GHC.Base.Just y_sdLhX ->
                                  case cmp_sdLhR x_sdLhU y_sdLhX of {
                                    __DEFAULT -> y_sdLhX;
                                    GHC.Types.GT -> x_sdLhU;
                                  };
                            };
                  } in  GHC.Base.Just [sat_sdLhZ];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdLhQ mbf_sdLhT mbf_sdLhT GHC.Base.Nothing xs_sdLhS
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdLi1 [Occ=Once] -> v_sdLi1;
          };

Data.Bifoldable.biminimumBy
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLi2 cmp_sdLi3 xs_sdLi4]
        let {
          mbf_sdLi5
            :: a_adKnN -> GHC.Base.Maybe a_adKnN -> GHC.Base.Maybe a_adKnN
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [cmp_sdLi3] \r [x_sdLi6 m_sdLi7]
                  let {
                    sat_sdLib [Occ=Once] :: a_adKnN
                    [LclId] =
                        [cmp_sdLi3 x_sdLi6 m_sdLi7] \u []
                            case m_sdLi7 of {
                              GHC.Base.Nothing -> x_sdLi6;
                              GHC.Base.Just y_sdLi9 ->
                                  case cmp_sdLi3 x_sdLi6 y_sdLi9 of {
                                    __DEFAULT -> x_sdLi6;
                                    GHC.Types.GT -> y_sdLi9;
                                  };
                            };
                  } in  GHC.Base.Just [sat_sdLib];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdLi2 mbf_sdLi5 mbf_sdLi5 GHC.Base.Nothing xs_sdLi4
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdLid [Occ=Once] -> v_sdLid;
          };

Data.Bifoldable.bifoldrM
  :: forall (t :: * -> * -> *) (m :: * -> *) a c b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Monad m) =>
     (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLie
           $dMonad_sdLif
           f_sdLig
           g_sdLih
           z0_sdLii
           xs_sdLij]
        let {
          sat_sdLiu [Occ=Once] :: c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdLif] \u [] GHC.Base.return $dMonad_sdLif; } in
        let {
          sat_sdLit [Occ=Once]
            :: (c_adKlQ -> m_adKlO c_adKlQ)
               -> b_adKlR -> c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdLif g_sdLih] \r [k_sdLip x_sdLiq z_sdLir]
                  let {
                    sat_sdLis [Occ=Once] :: m_adKlO c_adKlQ
                    [LclId] =
                        [g_sdLih x_sdLiq z_sdLir] \u [] g_sdLih x_sdLiq z_sdLir;
                  } in  GHC.Base.>>= $dMonad_sdLif sat_sdLis k_sdLip; } in
        let {
          sat_sdLio [Occ=Once]
            :: (c_adKlQ -> m_adKlO c_adKlQ)
               -> a_adKlP -> c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdLif f_sdLig] \r [k_sdLik x_sdLil z_sdLim]
                  let {
                    sat_sdLin [Occ=Once] :: m_adKlO c_adKlQ
                    [LclId] =
                        [f_sdLig x_sdLil z_sdLim] \u [] f_sdLig x_sdLil z_sdLim;
                  } in  GHC.Base.>>= $dMonad_sdLif sat_sdLin k_sdLik;
        } in 
          Data.Bifoldable.bifoldl
              $dBifoldable_sdLie sat_sdLio sat_sdLit sat_sdLiu xs_sdLij z0_sdLii;

Data.Bifoldable.bifoldl'
  :: forall (t :: * -> * -> *) a b c.
     Data.Bifoldable.Bifoldable t =>
     (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLiv f_sdLiw g_sdLix z0_sdLiy xs_sdLiz]
        let {
          sat_sdLiJ [Occ=Once]
            :: c_adKky -> (a_adKkw -> a_adKkw) -> a_adKkw -> a_adKkw
          [LclId] =
              [g_sdLix] \r [x_sdLiF k_sdLiG z_sdLiH]
                  case g_sdLix z_sdLiH x_sdLiF of vx_sdLiI {
                    __DEFAULT -> k_sdLiG vx_sdLiI;
                  }; } in
        let {
          sat_sdLiE [Occ=Once]
            :: b_adKkx -> (a_adKkw -> a_adKkw) -> a_adKkw -> a_adKkw
          [LclId] =
              [f_sdLiw] \r [x_sdLiA k_sdLiB z_sdLiC]
                  case f_sdLiw z_sdLiC x_sdLiA of vx_sdLiD {
                    __DEFAULT -> k_sdLiB vx_sdLiD;
                  };
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLiv
              sat_sdLiE
              sat_sdLiJ
              GHC.Base.id
              xs_sdLiz
              z0_sdLiy;

Data.Bifoldable.bilength2
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sdLiK k_sdLiL z_sdLiM]
        case z_sdLiM of {
          GHC.Types.I# x1_sdLiO [Occ=Once] ->
              case +# [x1_sdLiO 1#] of sat_sdLiP {
                __DEFAULT ->
                    let {
                      sat_sdLiQ [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sdLiP];
                    } in  k_sdLiL sat_sdLiQ;
              };
        };

Data.Bifoldable.bilength1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Bifoldable.bilength
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     t a b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLiR eta_sdLiS]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdLiR
            Data.Bifoldable.bilength2
            Data.Bifoldable.bilength2
            GHC.Base.id
            eta_sdLiS
            Data.Bifoldable.bilength1;

lvl12_rdL8E :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [223#];

lvl13_rdL8F :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl12_rdL8E
                                           lvl7_rdL8z
                                           lvl12_rdL8E
                                           lvl8_rdL8A];

lvl14_rdL8G :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl13_rdL8F
                                                  GHC.Stack.Types.EmptyCallStack];

lvl15_rdL8H :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bifoldl1: empty structure"#;

Data.Bifoldable.bifoldl2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl15_rdL8H of sat_sdLiT {
          __DEFAULT -> GHC.Err.error lvl14_rdL8G sat_sdLiT;
        };

Data.Bifoldable.bifoldl1
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> a) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLiU f_sdLiV xs_sdLiW]
        let {
          mbf_sdLiX
            :: GHC.Base.Maybe a_adKk0 -> a_adKk0 -> GHC.Base.Maybe a_adKk0
          [LclId, Arity=2, Str=<L,1*U><L,U>, Unf=OtherCon []] =
              [f_sdLiV] \r [m_sdLiY y_sdLiZ]
                  let {
                    sat_sdLj2 [Occ=Once] :: a_adKk0
                    [LclId] =
                        [f_sdLiV m_sdLiY y_sdLiZ] \u []
                            case m_sdLiY of {
                              GHC.Base.Nothing -> y_sdLiZ;
                              GHC.Base.Just x_sdLj1 [Occ=Once] -> f_sdLiV x_sdLj1 y_sdLiZ;
                            };
                  } in  GHC.Base.Just [sat_sdLj2];
        } in 
          case
              Data.Bifoldable.bifoldl
                  $dBifoldable_sdLiU mbf_sdLiX mbf_sdLiX GHC.Base.Nothing xs_sdLiW
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldl2;
            GHC.Base.Just v_sdLj4 [Occ=Once] -> v_sdLj4;
          };

Data.Bifoldable.bifoldlM
  :: forall (t :: * -> * -> *) (m :: * -> *) a b c.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Monad m) =>
     (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLj5
           $dMonad_sdLj6
           f_sdLj7
           g_sdLj8
           z0_sdLj9
           xs_sdLja]
        let {
          sat_sdLjl [Occ=Once] :: a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdLj6] \u [] GHC.Base.return $dMonad_sdLj6; } in
        let {
          sat_sdLjk [Occ=Once]
            :: c_adKiY
               -> (a_adKiW -> m_adKiV a_adKiW) -> a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdLj6 g_sdLj8] \r [x_sdLjg k_sdLjh z_sdLji]
                  let {
                    sat_sdLjj [Occ=Once] :: m_adKiV a_adKiW
                    [LclId] =
                        [g_sdLj8 x_sdLjg z_sdLji] \u [] g_sdLj8 z_sdLji x_sdLjg;
                  } in  GHC.Base.>>= $dMonad_sdLj6 sat_sdLjj k_sdLjh; } in
        let {
          sat_sdLjf [Occ=Once]
            :: b_adKiX
               -> (a_adKiW -> m_adKiV a_adKiW) -> a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdLj6 f_sdLj7] \r [x_sdLjb k_sdLjc z_sdLjd]
                  let {
                    sat_sdLje [Occ=Once] :: m_adKiV a_adKiW
                    [LclId] =
                        [f_sdLj7 x_sdLjb z_sdLjd] \u [] f_sdLj7 z_sdLjd x_sdLjb;
                  } in  GHC.Base.>>= $dMonad_sdLj6 sat_sdLje k_sdLjc;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLj5 sat_sdLjf sat_sdLjk sat_sdLjl xs_sdLja z0_sdLj9;

Data.Bifoldable.bitraverse_
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjm $dApplicative_sdLjn f1_sdLjo g_sdLjp]
        let {
          sat_sdLjw [Occ=Once] :: f_adKhx ()
          [LclId] =
              [$dApplicative_sdLjn] \u []
                  GHC.Base.pure $dApplicative_sdLjn GHC.Tuple.(); } in
        let {
          sat_sdLjv [Occ=Once] :: b_adKhA -> f_adKhx () -> f_adKhx ()
          [LclId] =
              [$dApplicative_sdLjn g_sdLjp] \r [x_sdLjt]
                  let {
                    sat_sdLju [Occ=Once] :: f_adKhx d_adKhB
                    [LclId] =
                        [g_sdLjp x_sdLjt] \u [] g_sdLjp x_sdLjt;
                  } in  GHC.Base.*> $dApplicative_sdLjn sat_sdLju; } in
        let {
          sat_sdLjs [Occ=Once] :: a_adKhy -> f_adKhx () -> f_adKhx ()
          [LclId] =
              [$dApplicative_sdLjn f1_sdLjo] \r [x_sdLjq]
                  let {
                    sat_sdLjr [Occ=Once] :: f_adKhx c_adKhz
                    [LclId] =
                        [f1_sdLjo x_sdLjq] \u [] f1_sdLjo x_sdLjq;
                  } in  GHC.Base.*> $dApplicative_sdLjn sat_sdLjr;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLjm sat_sdLjs sat_sdLjv sat_sdLjw;

Data.Bifoldable.bifor_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f ()
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjx
           $dApplicative_sdLjy
           t1_sdLjz
           f1_sdLjA
           g_sdLjB]
        Data.Bifoldable.bitraverse_
            $dBifoldable_sdLjx $dApplicative_sdLjy f1_sdLjA g_sdLjB t1_sdLjz;

Data.Bifoldable.biforM_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f ()
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bifor_ eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bimapM_
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bitraverse_ eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bisequence_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,U,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjC $dApplicative_sdLjD]
        let {
          sat_sdLjG [Occ=Once] :: f_adKgV ()
          [LclId] =
              [$dApplicative_sdLjD] \u []
                  GHC.Base.pure $dApplicative_sdLjD GHC.Tuple.(); } in
        let {
          sat_sdLjF [Occ=Once] :: f_adKgV b_adKgX -> f_adKgV () -> f_adKgV ()
          [LclId] =
              [$dApplicative_sdLjD] \u [] GHC.Base.*> $dApplicative_sdLjD; } in
        let {
          sat_sdLjE [Occ=Once] :: f_adKgV a_adKgW -> f_adKgV () -> f_adKgV ()
          [LclId] =
              [$dApplicative_sdLjD] \u [] GHC.Base.*> $dApplicative_sdLjD;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLjC sat_sdLjE sat_sdLjF sat_sdLjG;

Data.Bifoldable.bisequenceA_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.bisequence_ eta_B2 eta_B1;

Data.Bifoldable.biasum
  :: forall (t :: * -> * -> *) (f :: * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Alternative f) =>
     t (f a) (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjH $dAlternative_sdLjI]
        let {
          sat_sdLjL [Occ=Once] :: f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdLjI] \u []
                  GHC.Base.empty $dAlternative_sdLjI; } in
        let {
          sat_sdLjK [Occ=Once]
            :: f_adKgo a_adKgp -> f_adKgo a_adKgp -> f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdLjI] \u [] GHC.Base.<|> $dAlternative_sdLjI; } in
        let {
          sat_sdLjJ [Occ=Once]
            :: f_adKgo a_adKgp -> f_adKgo a_adKgp -> f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdLjI] \u [] GHC.Base.<|> $dAlternative_sdLjI;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdLjH sat_sdLjJ sat_sdLjK sat_sdLjL;

Data.Bifoldable.bimsum
  :: forall (t :: * -> * -> *) (f :: * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Alternative f) =>
     t (f a) (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,U,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.biasum eta_B2 eta_B1;

Data.Bifoldable.biList
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     t a a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjM]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdLjM GHC.Types.: GHC.Types.: GHC.Types.[];

Data.Bifoldable.binull1
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdLjN ds1_sdLjO] GHC.Types.False [];

Data.Bifoldable.binull
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     t a b -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjP]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdLjP
            Data.Bifoldable.binull1
            Data.Bifoldable.binull1
            GHC.Types.True;

Data.Bifoldable.biconcat
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     t [a] [a] -> [a]
[GblId,
 Arity=1,
 Str=<S(C(S)LLL),1*U(1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjQ]
        Data.Bifoldable.bifold $dBifoldable_sdLjQ GHC.Base.$fMonoid[];

lvl16_rdL8I :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [334#];

lvl17_rdL8J :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [24#];

lvl18_rdL8K :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [58#];

lvl19_rdL8L :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl16_rdL8I
                                           lvl17_rdL8J
                                           lvl16_rdL8I
                                           lvl18_rdL8K];

lvl20_rdL8M :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl19_rdL8L
                                                  GHC.Stack.Types.EmptyCallStack];

lvl21_rdL8N :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bimaximum: empty structure"#;

Data.Bifoldable.bimaximum1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl21_rdL8N of sat_sdLjR {
          __DEFAULT -> GHC.Err.error lvl20_rdL8M sat_sdLjR;
        };

Data.Bifoldable.bimaximum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Ord a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLjS $dOrd_sdLjT]
        let {
          g_sdLjU [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKeD a_adKeE a_adKeE -> Data.Functor.Utils.Max a_adKeE
          [LclId] =
              [$dBifoldable_sdLjS $dOrd_sdLjT] \u []
                  let {
                    sat_sdLjV [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Max a_adKeE)
                    [LclId] =
                        [$dOrd_sdLjT] \u [] Data.Functor.Utils.$fMonoidMax $dOrd_sdLjT;
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdLjS sat_sdLjV GHC.Base.Just GHC.Base.Just; } in
        let {
          sat_sdLjZ [Occ=OnceT[0]] :: t_adKeD a_adKeE a_adKeE -> a_adKeE
          [LclId] =
              [g_sdLjU] \r [x_sdLjW]
                  case g_sdLjU x_sdLjW of {
                    GHC.Base.Nothing -> Data.Bifoldable.bimaximum1;
                    GHC.Base.Just v_sdLjY [Occ=Once] -> v_sdLjY;
                  };
        } in  sat_sdLjZ;

lvl22_rdL8O :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [342#];

lvl23_rdL8P :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl22_rdL8O
                                           lvl17_rdL8J
                                           lvl22_rdL8O
                                           lvl18_rdL8K];

lvl24_rdL8Q :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl23_rdL8P
                                                  GHC.Stack.Types.EmptyCallStack];

lvl25_rdL8R :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "biminimum: empty structure"#;

Data.Bifoldable.biminimum1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl25_rdL8R of sat_sdLk0 {
          __DEFAULT -> GHC.Err.error lvl24_rdL8Q sat_sdLk0;
        };

Data.Bifoldable.biminimum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Ord a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLk1 $dOrd_sdLk2]
        let {
          g_sdLk3 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKdQ a_adKdR a_adKdR -> Data.Functor.Utils.Min a_adKdR
          [LclId] =
              [$dBifoldable_sdLk1 $dOrd_sdLk2] \u []
                  let {
                    sat_sdLk4 [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Min a_adKdR)
                    [LclId] =
                        [$dOrd_sdLk2] \u [] Data.Functor.Utils.$fMonoidMin $dOrd_sdLk2;
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdLk1 sat_sdLk4 GHC.Base.Just GHC.Base.Just; } in
        let {
          sat_sdLk8 [Occ=OnceT[0]] :: t_adKdQ a_adKdR a_adKdR -> a_adKdR
          [LclId] =
              [g_sdLk3] \r [x_sdLk5]
                  case g_sdLk3 x_sdLk5 of {
                    GHC.Base.Nothing -> Data.Bifoldable.biminimum1;
                    GHC.Base.Just v_sdLk7 [Occ=Once] -> v_sdLk7;
                  };
        } in  sat_sdLk8;

Data.Bifoldable.biproduct2 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdLk9] v_sdLk9;

Data.Bifoldable.bisum1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLka $dNum_sdLkb]
        let {
          sat_sdLkc [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_adKdy)
          [LclId] =
              [$dNum_sdLkb] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sdLkb;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLka
              sat_sdLkc
              Data.Bifoldable.biproduct2
              Data.Bifoldable.biproduct2;

Data.Bifoldable.bisum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.bisum1 eta_B2 eta_B1;

Data.Bifoldable.biproduct1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkd $dNum_sdLke]
        let {
          sat_sdLkf [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_adKdf)
          [LclId] =
              [$dNum_sdLke] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sdLke;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLkd
              sat_sdLkf
              Data.Bifoldable.biproduct2
              Data.Bifoldable.biproduct2;

Data.Bifoldable.biproduct
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.biproduct1 eta_B2 eta_B1;

Data.Bifoldable.biconcatMap
  :: forall (t :: * -> * -> *) a c b.
     Data.Bifoldable.Bifoldable t =>
     (a -> [c]) -> (b -> [c]) -> t a b -> [c]
[GblId,
 Arity=1,
 Str=<S(LC(S)LL),1*U(A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkg]
        Data.Bifoldable.bifoldMap $dBifoldable_sdLkg GHC.Base.$fMonoid[];

Data.Bifoldable.biand2 :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdLkh] v_sdLkh;

Data.Bifoldable.biand1
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLki]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdLki
            Data.Semigroup.Internal.$fMonoidAll
            Data.Bifoldable.biand2
            Data.Bifoldable.biand2;

Data.Bifoldable.biand
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Bifoldable.biand1 eta_B1;

Data.Bifoldable.bior1
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkj]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdLkj
            Data.Semigroup.Internal.$fMonoidAny
            Data.Bifoldable.biand2
            Data.Bifoldable.biand2;

Data.Bifoldable.bior
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Bifoldable.bior1 eta_B1;

Data.Bifoldable.biany1
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkk p_sdLkl q_sdLkm]
        let {
          sat_sdLkq [Occ=Once] :: b_adKcd -> Data.Semigroup.Internal.Any
          [LclId] =
              [q_sdLkm] \r [x_sdLkp] q_sdLkm x_sdLkp; } in
        let {
          sat_sdLko [Occ=Once] :: a_adKcc -> Data.Semigroup.Internal.Any
          [LclId] =
              [p_sdLkl] \r [x_sdLkn] p_sdLkl x_sdLkn;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLkk
              Data.Semigroup.Internal.$fMonoidAny
              sat_sdLko
              sat_sdLkq;

Data.Bifoldable.biany
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.biany1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bielem1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkr $dEq_sdLks x_sdLkt]
        let {
          sat_sdLkx [Occ=Once] :: a_adKfA -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_sdLks x_sdLkt] \r [x1_sdLkw]
                  GHC.Classes.== $dEq_sdLks x1_sdLkw x_sdLkt; } in
        let {
          sat_sdLkv [Occ=Once] :: a_adKfA -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_sdLks x_sdLkt] \r [x1_sdLku]
                  GHC.Classes.== $dEq_sdLks x1_sdLku x_sdLkt;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLkr
              Data.Semigroup.Internal.$fMonoidAny
              sat_sdLkv
              sat_sdLkx;

Data.Bifoldable.bielem
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bielem1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.binotElem
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLky $dEq_sdLkz x_sdLkA]
        let {
          g_sdLkB [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKfN a_adKfO a_adKfO -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dBifoldable_sdLky $dEq_sdLkz x_sdLkA] \u []
                  Data.Bifoldable.bielem1 $dBifoldable_sdLky $dEq_sdLkz x_sdLkA; } in
        let {
          sat_sdLkE [Occ=OnceT[0]]
            :: t_adKfN a_adKfO a_adKfO -> GHC.Types.Bool
          [LclId] =
              [g_sdLkB] \r [x1_sdLkC]
                  case g_sdLkB x1_sdLkC of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  sat_sdLkE;

Data.Bifoldable.biall1
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkF p_sdLkG q_sdLkH]
        let {
          sat_sdLkL [Occ=Once] :: b_adKbP -> Data.Semigroup.Internal.All
          [LclId] =
              [q_sdLkH] \r [x_sdLkK] q_sdLkH x_sdLkK; } in
        let {
          sat_sdLkJ [Occ=Once] :: a_adKbO -> Data.Semigroup.Internal.All
          [LclId] =
              [p_sdLkG] \r [x_sdLkI] p_sdLkG x_sdLkI;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdLkF
              Data.Semigroup.Internal.$fMonoidAll
              sat_sdLkJ
              sat_sdLkL;

Data.Bifoldable.biall
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.biall1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bifind
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool) -> t a a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdLkM p_sdLkN]
        let {
          g_sdLkO [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKbl a_adKbm a_adKbm -> Data.Monoid.First a_adKbm
          [LclId] =
              [$dBifoldable_sdLkM p_sdLkN] \u []
                  let {
                    finder_sdLkP :: a_adKbm -> GHC.Base.Maybe a_adKbm
                    [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                        [p_sdLkN] \r [x_sdLkQ]
                            case p_sdLkN x_sdLkQ of {
                              GHC.Types.False -> GHC.Base.Nothing [];
                              GHC.Types.True -> GHC.Base.Just [x_sdLkQ];
                            };
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdLkM
                        Data.Monoid.$fMonoidFirst
                        finder_sdLkP
                        finder_sdLkP; } in
        let {
          sat_sdLkT [Occ=Once]
            :: t_adKbl a_adKbm a_adKbm -> Data.Monoid.First a_adKbm
          [LclId] =
              [g_sdLkO] \r [x_sdLkS] g_sdLkO x_sdLkS;
        } in  sat_sdLkT;

Data.Bifoldable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$trModule4];

Data.Bifoldable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$trModule2];

Data.Bifoldable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bifoldable.$trModule3
                                     Data.Bifoldable.$trModule1];

$krep_rdL8S :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bifoldable.$tcBifoldable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdL8S];

Data.Bifoldable.$tcBifoldable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bifoldable"#;

Data.Bifoldable.$tcBifoldable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$tcBifoldable3];

Data.Bifoldable.$tcBifoldable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13881323671910883383##
                                    7079945659398195047##
                                    Data.Bifoldable.$trModule
                                    Data.Bifoldable.$tcBifoldable2
                                    0#
                                    Data.Bifoldable.$tcBifoldable1];

Data.Bifoldable.C:Bifoldable
  :: forall (p :: * -> * -> *).
     (forall m. GHC.Base.Monoid m => p m m -> m)
     -> (forall m a b.
         GHC.Base.Monoid m =>
         (a -> m) -> (b -> m) -> p a b -> m)
     -> (forall a c b.
         (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c)
     -> (forall c a b.
         (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c)
     -> Data.Bifoldable.Bifoldable p
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.C:Bifoldable [eta_B4 eta_B3 eta_B2 eta_B1];


==================== Pre unarise: ====================
2018-03-16 16:09:02.167833201 UTC

Data.Bifoldable.bifold
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m. GHC.Base.Monoid m => p m m -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdN0U]
        case v_sdN0U of {
          Data.Bifoldable.C:Bifoldable v_sdN0W [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdN0W;
        };

Data.Bifoldable.bifoldMap
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> p a b -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdN10]
        case v_sdN10 of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       v_sdN13 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdN13;
        };

Data.Bifoldable.bifoldr
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdN16]
        case v_sdN16 of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdN1a [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdN1a;
        };

Data.Bifoldable.bifoldl
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdN1c]
        case v_sdN1c of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdN1h [Occ=Once] ->
              v_sdN1h;
        };

Data.Bifoldable.$fBifoldable(,)_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN1i f_sdN1j g_sdN1k ds_sdN1l]
        let {
          sat_sdN1v [Occ=Once] :: m_adKxe
          [LclId] =
              [g_sdN1k ds_sdN1l] \u []
                  let {
                    sat_sdN1u [Occ=Once] :: b_adKxg
                    [LclId] =
                        [ds_sdN1l] \u []
                            case ds_sdN1l of {
                              (,) _ [Occ=Dead] b1_sdN1t [Occ=Once] -> b1_sdN1t;
                            };
                  } in  g_sdN1k sat_sdN1u; } in
        let {
          sat_sdN1q [Occ=Once] :: m_adKxe
          [LclId] =
              [f_sdN1j ds_sdN1l] \u []
                  let {
                    sat_sdN1p [Occ=Once] :: a_adKxf
                    [LclId] =
                        [ds_sdN1l] \u []
                            case ds_sdN1l of {
                              (,) a1_sdN1n [Occ=Once] _ [Occ=Dead] -> a1_sdN1n;
                            };
                  } in  f_sdN1j sat_sdN1p;
        } in  GHC.Base.mappend $dMonoid_sdN1i sat_sdN1q sat_sdN1v;

Data.Bifoldable.$fBifoldableConst_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Functor.Const.Const a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN1w f_sdN1x ds_sdN1y ds1_sdN1z]
        f_sdN1x ds1_sdN1z;

Data.Bifoldable.$fBifoldableK1_$cbifoldMap
  :: forall i m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> GHC.Generics.K1 i a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN1A f_sdN1B ds_sdN1C ds1_sdN1D]
        f_sdN1B ds1_sdN1D;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap
  :: forall x m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN1E f_sdN1F g_sdN1G ds_sdN1H]
        let {
          sat_sdN1T [Occ=Once] :: m_adKv0
          [LclId] =
              [g_sdN1G ds_sdN1H] \u []
                  let {
                    sat_sdN1S [Occ=Once] :: b_adKv2
                    [LclId] =
                        [ds_sdN1H] \u []
                            case ds_sdN1H of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdN1R [Occ=Once] -> b1_sdN1R;
                            };
                  } in  g_sdN1G sat_sdN1S; } in
        let {
          sat_sdN1N [Occ=Once] :: m_adKv0
          [LclId] =
              [f_sdN1F ds_sdN1H] \u []
                  let {
                    sat_sdN1M [Occ=Once] :: a_adKv1
                    [LclId] =
                        [ds_sdN1H] \u []
                            case ds_sdN1H of {
                              (,,) _ [Occ=Dead] a1_sdN1K [Occ=Once] _ [Occ=Dead] -> a1_sdN1K;
                            };
                  } in  f_sdN1F sat_sdN1M;
        } in  GHC.Base.mappend $dMonoid_sdN1E sat_sdN1N sat_sdN1T;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap
  :: forall x y m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN1U f_sdN1V g_sdN1W ds_sdN1X]
        let {
          sat_sdN2b [Occ=Once] :: m_adKue
          [LclId] =
              [g_sdN1W ds_sdN1X] \u []
                  let {
                    sat_sdN2a [Occ=Once] :: b_adKug
                    [LclId] =
                        [ds_sdN1X] \u []
                            case ds_sdN1X of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdN29 [Occ=Once] ->
                                  b1_sdN29;
                            };
                  } in  g_sdN1W sat_sdN2a; } in
        let {
          sat_sdN24 [Occ=Once] :: m_adKue
          [LclId] =
              [f_sdN1V ds_sdN1X] \u []
                  let {
                    sat_sdN23 [Occ=Once] :: a_adKuf
                    [LclId] =
                        [ds_sdN1X] \u []
                            case ds_sdN1X of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdN21 [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdN21;
                            };
                  } in  f_sdN1V sat_sdN23;
        } in  GHC.Base.mappend $dMonoid_sdN1U sat_sdN24 sat_sdN2b;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap
  :: forall x y z m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN2c f_sdN2d g_sdN2e ds_sdN2f]
        let {
          sat_sdN2v [Occ=Once] :: m_adKtr
          [LclId] =
              [g_sdN2e ds_sdN2f] \u []
                  let {
                    sat_sdN2u [Occ=Once] :: b_adKtt
                    [LclId] =
                        [ds_sdN2f] \u []
                            case ds_sdN2f of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdN2t [Occ=Once] ->
                                  b1_sdN2t;
                            };
                  } in  g_sdN2e sat_sdN2u; } in
        let {
          sat_sdN2n [Occ=Once] :: m_adKtr
          [LclId] =
              [f_sdN2d ds_sdN2f] \u []
                  let {
                    sat_sdN2m [Occ=Once] :: a_adKts
                    [LclId] =
                        [ds_sdN2f] \u []
                            case ds_sdN2f of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdN2k [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdN2k;
                            };
                  } in  f_sdN2d sat_sdN2m;
        } in  GHC.Base.mappend $dMonoid_sdN2c sat_sdN2n sat_sdN2v;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap
  :: forall x y z w m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, w, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN2w f_sdN2x g_sdN2y ds_sdN2z]
        let {
          sat_sdN2R [Occ=Once] :: m_adKsD
          [LclId] =
              [g_sdN2y ds_sdN2z] \u []
                  let {
                    sat_sdN2Q [Occ=Once] :: b_adKsF
                    [LclId] =
                        [ds_sdN2z] \u []
                            case ds_sdN2z of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdN2P [Occ=Once] ->
                                  b1_sdN2P;
                            };
                  } in  g_sdN2y sat_sdN2Q; } in
        let {
          sat_sdN2I [Occ=Once] :: m_adKsD
          [LclId] =
              [f_sdN2x ds_sdN2z] \u []
                  let {
                    sat_sdN2H [Occ=Once] :: a_adKsE
                    [LclId] =
                        [ds_sdN2z] \u []
                            case ds_sdN2z of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdN2F [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdN2F;
                            };
                  } in  f_sdN2x sat_sdN2H;
        } in  GHC.Base.mappend $dMonoid_sdN2w sat_sdN2I sat_sdN2R;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap
  :: forall x y z w v m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, w, v, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN2S f_sdN2T g_sdN2U ds_sdN2V]
        let {
          sat_sdN3f [Occ=Once] :: m_adKrO
          [LclId] =
              [g_sdN2U ds_sdN2V] \u []
                  let {
                    sat_sdN3e [Occ=Once] :: b_adKrQ
                    [LclId] =
                        [ds_sdN2V] \u []
                            case ds_sdN2V of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdN3d [Occ=Once] ->
                                  b1_sdN3d;
                            };
                  } in  g_sdN2U sat_sdN3e; } in
        let {
          sat_sdN35 [Occ=Once] :: m_adKrO
          [LclId] =
              [f_sdN2T ds_sdN2V] \u []
                  let {
                    sat_sdN34 [Occ=Once] :: a_adKrP
                    [LclId] =
                        [ds_sdN2V] \u []
                            case ds_sdN2V of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdN32 [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdN32;
                            };
                  } in  f_sdN2T sat_sdN34;
        } in  GHC.Base.mappend $dMonoid_sdN2S sat_sdN35 sat_sdN3f;

Data.Bifoldable.$fBifoldableEither_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Either.Either a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN3g f_sdN3h ds_sdN3i ds1_sdN3j]
        case ds1_sdN3j of {
          Data.Either.Left a1_sdN3l [Occ=Once] -> f_sdN3h a1_sdN3l;
          Data.Either.Right b1_sdN3m [Occ=Once] -> ds_sdN3i b1_sdN3m;
        };

poly_$dMonoid_rdL8r
  :: forall c.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo c))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Bifoldable.$dmbifoldl
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
[GblId,
 Arity=5,
 Str=<S(LC(C(C(C(S))))LL),1*U(A,1*C1(C1(C1(C1(U)))),A,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN3n f_sdN3o g_sdN3p z_sdN3q t_sdN3r]
        let {
          sat_sdN3x [Occ=Once]
            :: b_adKqf
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo c_adKqd)
          [LclId] =
              [g_sdN3p] \r [x_sdN3v y_sdN3w] g_sdN3p y_sdN3w x_sdN3v; } in
        let {
          sat_sdN3u [Occ=Once]
            :: a_adKqe
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo c_adKqd)
          [LclId] =
              [f_sdN3o] \r [x_sdN3s y_sdN3t] f_sdN3o y_sdN3t x_sdN3s;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdN3n
              poly_$dMonoid_rdL8r
              sat_sdN3u
              sat_sdN3x
              t_sdN3r
              z_sdN3q;

Data.Bifoldable.$dmbifoldr
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
[GblId,
 Arity=5,
 Str=<S(LC(C(C(C(S))))LL),1*U(A,1*C1(C1(C1(C1(U)))),A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN3y f_sdN3z g_sdN3A z_sdN3B t_sdN3C]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdN3y
            Data.Semigroup.Internal.$fMonoidEndo
            f_sdN3z
            g_sdN3A
            t_sdN3C
            z_sdN3B;

Data.Bifoldable.$dmbifoldMap
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> p a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN3D $dMonoid_sdN3E f_sdN3F g_sdN3G]
        let {
          sat_sdN3N [Occ=Once] :: m_adKpn
          [LclId] =
              [$dMonoid_sdN3E] \u [] GHC.Base.mempty $dMonoid_sdN3E; } in
        let {
          sat_sdN3M [Occ=Once] :: b_adKpp -> m_adKpn -> m_adKpn
          [LclId] =
              [$dMonoid_sdN3E g_sdN3G] \r [x_sdN3K]
                  let {
                    sat_sdN3L [Occ=Once] :: m_adKpn
                    [LclId] =
                        [g_sdN3G x_sdN3K] \u [] g_sdN3G x_sdN3K;
                  } in  GHC.Base.mappend $dMonoid_sdN3E sat_sdN3L; } in
        let {
          sat_sdN3J [Occ=Once] :: a_adKpo -> m_adKpn -> m_adKpn
          [LclId] =
              [$dMonoid_sdN3E f_sdN3F] \r [x_sdN3H]
                  let {
                    sat_sdN3I [Occ=Once] :: m_adKpn
                    [LclId] =
                        [f_sdN3F x_sdN3H] \u [] f_sdN3F x_sdN3H;
                  } in  GHC.Base.mappend $dMonoid_sdN3E sat_sdN3I;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdN3D sat_sdN3J sat_sdN3M sat_sdN3N;

Data.Bifoldable.$dmbifold
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m. GHC.Base.Monoid m => p m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN3O $dMonoid_sdN3P]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdN3O $dMonoid_sdN3P GHC.Base.id GHC.Base.id;

Data.Bifoldable.$fBifoldableEither_$cbifold
  :: forall m. GHC.Base.Monoid m => Data.Either.Either m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN3Q ds_sdN3R]
        case ds_sdN3R of {
          Data.Either.Left a_sdN3T [Occ=Once] -> a_sdN3T;
          Data.Either.Right b_sdN3U [Occ=Once] -> b_sdN3U;
        };

Data.Bifoldable.$fBifoldableEither_$cbifoldr
  :: forall a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> Data.Either.Either a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdN3V g_sdN3W z_sdN3X t_sdN3Y]
        case t_sdN3Y of {
          Data.Either.Left a1_sdN40 [Occ=Once] -> f_sdN3V a1_sdN40 z_sdN3X;
          Data.Either.Right b1_sdN41 [Occ=Once] -> g_sdN3W b1_sdN41 z_sdN3X;
        };

Data.Bifoldable.$fBifoldableEither_$cbifoldl
  :: forall c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> Data.Either.Either a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdN42 g_sdN43 z_sdN44 t_sdN45]
        case t_sdN45 of {
          Data.Either.Left a1_sdN47 [Occ=Once] -> f_sdN42 z_sdN44 a1_sdN47;
          Data.Either.Right b1_sdN48 [Occ=Once] -> g_sdN43 z_sdN44 b1_sdN48;
        };

Data.Bifoldable.$fBifoldableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableEither_$cbifold
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold
  :: forall x y z w v m.
     GHC.Base.Monoid m =>
     (x, y, z, w, v, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN49 ds_sdN4a]
        let {
          sat_sdN4s [Occ=Once] :: m_adKrE
          [LclId] =
              [ds_sdN4a] \u []
                  case ds_sdN4a of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b_sdN4r [Occ=Once] ->
                        b_sdN4r;
                  }; } in
        let {
          sat_sdN4j [Occ=Once] :: m_adKrE
          [LclId] =
              [ds_sdN4a] \u []
                  case ds_sdN4a of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a_sdN4h [Occ=Once]
                             _ [Occ=Dead] ->
                        a_sdN4h;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN49 sat_sdN4j sat_sdN4s;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr
  :: forall x y z w v a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, w, v, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN4t g_sdN4u z1_sdN4v t_sdN4w]
        let {
          sat_sdN4P [Occ=Once] :: c_adKs0
          [LclId] =
              [g_sdN4u z1_sdN4v t_sdN4w] \u []
                  let {
                    sat_sdN4O [Occ=Once] :: b_adKs1
                    [LclId] =
                        [t_sdN4w] \u []
                            case t_sdN4w of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdN4N [Occ=Once] ->
                                  b1_sdN4N;
                            };
                  } in  g_sdN4u sat_sdN4O z1_sdN4v; } in
        let {
          sat_sdN4F [Occ=Once] :: a_adKrZ
          [LclId] =
              [t_sdN4w] \u []
                  case t_sdN4w of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a1_sdN4D [Occ=Once]
                             _ [Occ=Dead] ->
                        a1_sdN4D;
                  };
        } in  f_sdN4t sat_sdN4F sat_sdN4P;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl
  :: forall x y z w v c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, w, v, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN4Q g_sdN4R z1_sdN4S t_sdN4T]
        let {
          sat_sdN5c [Occ=Once] :: b_adKsd
          [LclId] =
              [t_sdN4T] \u []
                  case t_sdN4T of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b1_sdN5b [Occ=Once] ->
                        b1_sdN5b;
                  }; } in
        let {
          sat_sdN53 [Occ=Once] :: c_adKsb
          [LclId] =
              [f_sdN4Q z1_sdN4S t_sdN4T] \u []
                  let {
                    sat_sdN52 [Occ=Once] :: a_adKsc
                    [LclId] =
                        [t_sdN4T] \u []
                            case t_sdN4T of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdN50 [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdN50;
                            };
                  } in  f_sdN4Q z1_sdN4S sat_sdN52;
        } in  g_sdN4R sat_sdN53 sat_sdN5c;

Data.Bifoldable.$fBifoldable(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w v.
     Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold
  :: forall x y z w m. GHC.Base.Monoid m => (x, y, z, w, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN5d ds_sdN5e]
        let {
          sat_sdN5u [Occ=Once] :: m_adKst
          [LclId] =
              [ds_sdN5e] \u []
                  case ds_sdN5e of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b_sdN5t [Occ=Once] ->
                        b_sdN5t;
                  }; } in
        let {
          sat_sdN5m [Occ=Once] :: m_adKst
          [LclId] =
              [ds_sdN5e] \u []
                  case ds_sdN5e of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a_sdN5k [Occ=Once]
                            _ [Occ=Dead] ->
                        a_sdN5k;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN5d sat_sdN5m sat_sdN5u;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr
  :: forall x y z w a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, w, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN5v g_sdN5w z1_sdN5x t_sdN5y]
        let {
          sat_sdN5P [Occ=Once] :: c_adKsP
          [LclId] =
              [g_sdN5w z1_sdN5x t_sdN5y] \u []
                  let {
                    sat_sdN5O [Occ=Once] :: b_adKsQ
                    [LclId] =
                        [t_sdN5y] \u []
                            case t_sdN5y of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdN5N [Occ=Once] ->
                                  b1_sdN5N;
                            };
                  } in  g_sdN5w sat_sdN5O z1_sdN5x; } in
        let {
          sat_sdN5G [Occ=Once] :: a_adKsO
          [LclId] =
              [t_sdN5y] \u []
                  case t_sdN5y of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a1_sdN5E [Occ=Once]
                            _ [Occ=Dead] ->
                        a1_sdN5E;
                  };
        } in  f_sdN5v sat_sdN5G sat_sdN5P;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl
  :: forall x y z w c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, w, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN5Q g_sdN5R z1_sdN5S t_sdN5T]
        let {
          sat_sdN6a [Occ=Once] :: b_adKt2
          [LclId] =
              [t_sdN5T] \u []
                  case t_sdN5T of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b1_sdN69 [Occ=Once] ->
                        b1_sdN69;
                  }; } in
        let {
          sat_sdN62 [Occ=Once] :: c_adKt0
          [LclId] =
              [f_sdN5Q z1_sdN5S t_sdN5T] \u []
                  let {
                    sat_sdN61 [Occ=Once] :: a_adKt1
                    [LclId] =
                        [t_sdN5T] \u []
                            case t_sdN5T of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdN5Z [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdN5Z;
                            };
                  } in  f_sdN5Q z1_sdN5S sat_sdN61;
        } in  g_sdN5R sat_sdN62 sat_sdN6a;

Data.Bifoldable.$fBifoldable(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w. Data.Bifoldable.Bifoldable ((,,,,,) x y z w)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,)_$cbifold
  :: forall x y z m. GHC.Base.Monoid m => (x, y, z, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN6b ds_sdN6c]
        let {
          sat_sdN6q [Occ=Once] :: m_adKth
          [LclId] =
              [ds_sdN6c] \u []
                  case ds_sdN6c of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b_sdN6p [Occ=Once] ->
                        b_sdN6p;
                  }; } in
        let {
          sat_sdN6j [Occ=Once] :: m_adKth
          [LclId] =
              [ds_sdN6c] \u []
                  case ds_sdN6c of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a_sdN6h [Occ=Once]
                           _ [Occ=Dead] ->
                        a_sdN6h;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN6b sat_sdN6j sat_sdN6q;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr
  :: forall x y z a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN6r g_sdN6s z1_sdN6t t_sdN6u]
        let {
          sat_sdN6J [Occ=Once] :: c_adKtD
          [LclId] =
              [g_sdN6s z1_sdN6t t_sdN6u] \u []
                  let {
                    sat_sdN6I [Occ=Once] :: b_adKtE
                    [LclId] =
                        [t_sdN6u] \u []
                            case t_sdN6u of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdN6H [Occ=Once] ->
                                  b1_sdN6H;
                            };
                  } in  g_sdN6s sat_sdN6I z1_sdN6t; } in
        let {
          sat_sdN6B [Occ=Once] :: a_adKtC
          [LclId] =
              [t_sdN6u] \u []
                  case t_sdN6u of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a1_sdN6z [Occ=Once]
                           _ [Occ=Dead] ->
                        a1_sdN6z;
                  };
        } in  f_sdN6r sat_sdN6B sat_sdN6J;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl
  :: forall x y z c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN6K g_sdN6L z1_sdN6M t_sdN6N]
        let {
          sat_sdN72 [Occ=Once] :: b_adKtQ
          [LclId] =
              [t_sdN6N] \u []
                  case t_sdN6N of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b1_sdN71 [Occ=Once] ->
                        b1_sdN71;
                  }; } in
        let {
          sat_sdN6V [Occ=Once] :: c_adKtO
          [LclId] =
              [f_sdN6K z1_sdN6M t_sdN6N] \u []
                  let {
                    sat_sdN6U [Occ=Once] :: a_adKtP
                    [LclId] =
                        [t_sdN6N] \u []
                            case t_sdN6N of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdN6S [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdN6S;
                            };
                  } in  f_sdN6K z1_sdN6M sat_sdN6U;
        } in  g_sdN6L sat_sdN6V sat_sdN72;

Data.Bifoldable.$fBifoldable(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z. Data.Bifoldable.Bifoldable ((,,,,) x y z)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,)_$cbifold
  :: forall x y m. GHC.Base.Monoid m => (x, y, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN73 ds_sdN74]
        let {
          sat_sdN7g [Occ=Once] :: m_adKu4
          [LclId] =
              [ds_sdN74] \u []
                  case ds_sdN74 of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b_sdN7f [Occ=Once] ->
                        b_sdN7f;
                  }; } in
        let {
          sat_sdN7a [Occ=Once] :: m_adKu4
          [LclId] =
              [ds_sdN74] \u []
                  case ds_sdN74 of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a_sdN78 [Occ=Once] _ [Occ=Dead] ->
                        a_sdN78;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN73 sat_sdN7a sat_sdN7g;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr
  :: forall x y a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN7h g_sdN7i z_sdN7j t_sdN7k]
        let {
          sat_sdN7x [Occ=Once] :: c_adKuq
          [LclId] =
              [g_sdN7i z_sdN7j t_sdN7k] \u []
                  let {
                    sat_sdN7w [Occ=Once] :: b_adKur
                    [LclId] =
                        [t_sdN7k] \u []
                            case t_sdN7k of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdN7v [Occ=Once] ->
                                  b1_sdN7v;
                            };
                  } in  g_sdN7i sat_sdN7w z_sdN7j; } in
        let {
          sat_sdN7q [Occ=Once] :: a_adKup
          [LclId] =
              [t_sdN7k] \u []
                  case t_sdN7k of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdN7o [Occ=Once] _ [Occ=Dead] ->
                        a1_sdN7o;
                  };
        } in  f_sdN7h sat_sdN7q sat_sdN7x;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl
  :: forall x y c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN7y g_sdN7z z_sdN7A t_sdN7B]
        let {
          sat_sdN7O [Occ=Once] :: b_adKuD
          [LclId] =
              [t_sdN7B] \u []
                  case t_sdN7B of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdN7N [Occ=Once] ->
                        b1_sdN7N;
                  }; } in
        let {
          sat_sdN7I [Occ=Once] :: c_adKuB
          [LclId] =
              [f_sdN7y z_sdN7A t_sdN7B] \u []
                  let {
                    sat_sdN7H [Occ=Once] :: a_adKuC
                    [LclId] =
                        [t_sdN7B] \u []
                            case t_sdN7B of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdN7F [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdN7F;
                            };
                  } in  f_sdN7y z_sdN7A sat_sdN7H;
        } in  g_sdN7z sat_sdN7I sat_sdN7O;

Data.Bifoldable.$fBifoldable(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y. Data.Bifoldable.Bifoldable ((,,,) x y)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,)_$cbifold
  :: forall x m. GHC.Base.Monoid m => (x, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN7P ds_sdN7Q]
        let {
          sat_sdN80 [Occ=Once] :: m_adKuQ
          [LclId] =
              [ds_sdN7Q] \u []
                  case ds_sdN7Q of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b_sdN7Z [Occ=Once] -> b_sdN7Z;
                  }; } in
        let {
          sat_sdN7V [Occ=Once] :: m_adKuQ
          [LclId] =
              [ds_sdN7Q] \u []
                  case ds_sdN7Q of {
                    (,,) _ [Occ=Dead] a_sdN7T [Occ=Once] _ [Occ=Dead] -> a_sdN7T;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN7P sat_sdN7V sat_sdN80;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldr
  :: forall x a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN81 g_sdN82 z_sdN83 t_sdN84]
        let {
          sat_sdN8f [Occ=Once] :: c_adKvc
          [LclId] =
              [g_sdN82 z_sdN83 t_sdN84] \u []
                  let {
                    sat_sdN8e [Occ=Once] :: b_adKvd
                    [LclId] =
                        [t_sdN84] \u []
                            case t_sdN84 of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdN8d [Occ=Once] -> b1_sdN8d;
                            };
                  } in  g_sdN82 sat_sdN8e z_sdN83; } in
        let {
          sat_sdN89 [Occ=Once] :: a_adKvb
          [LclId] =
              [t_sdN84] \u []
                  case t_sdN84 of {
                    (,,) _ [Occ=Dead] a1_sdN87 [Occ=Once] _ [Occ=Dead] -> a1_sdN87;
                  };
        } in  f_sdN81 sat_sdN89 sat_sdN8f;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldl
  :: forall x c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN8g g_sdN8h z_sdN8i t_sdN8j]
        let {
          sat_sdN8u [Occ=Once] :: b_adKvp
          [LclId] =
              [t_sdN8j] \u []
                  case t_sdN8j of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdN8t [Occ=Once] -> b1_sdN8t;
                  }; } in
        let {
          sat_sdN8p [Occ=Once] :: c_adKvn
          [LclId] =
              [f_sdN8g z_sdN8i t_sdN8j] \u []
                  let {
                    sat_sdN8o [Occ=Once] :: a_adKvo
                    [LclId] =
                        [t_sdN8j] \u []
                            case t_sdN8j of {
                              (,,) _ [Occ=Dead] a1_sdN8m [Occ=Once] _ [Occ=Dead] -> a1_sdN8m;
                            };
                  } in  f_sdN8g z_sdN8i sat_sdN8o;
        } in  g_sdN8h sat_sdN8p sat_sdN8u;

Data.Bifoldable.$fBifoldable(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x. Data.Bifoldable.Bifoldable ((,,) x)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldl];

Data.Bifoldable.$fBifoldableK2
  :: forall i m.
     GHC.Base.Monoid m =>
     GHC.Generics.K1 i m m -> GHC.Generics.K1 i m m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN8v ds_sdN8w] ds_sdN8w;

Data.Bifoldable.$fBifoldableK1_$cbifoldr
  :: forall i a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> GHC.Generics.K1 i a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdN8x g_sdN8y z_sdN8z t_sdN8A] f_sdN8x t_sdN8A z_sdN8z;

Data.Bifoldable.$fBifoldableK1_$cbifoldl
  :: forall i c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> GHC.Generics.K1 i a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdN8B g_sdN8C z_sdN8D t_sdN8E] f_sdN8B z_sdN8D t_sdN8E;

Data.Bifoldable.$fBifoldableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bifoldable.Bifoldable (GHC.Generics.K1 i)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableK2
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldl];

Data.Bifoldable.$fBifoldableConst1
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Const.Const m m -> Data.Functor.Const.Const m m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN8F ds_sdN8G] ds_sdN8G;

Data.Bifoldable.$fBifoldableConst_$cbifoldr
  :: forall a c b.
     (a -> c -> c)
     -> (b -> c -> c) -> c -> Data.Functor.Const.Const a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdN8H g_sdN8I z_sdN8J t_sdN8K] f_sdN8H t_sdN8K z_sdN8J;

Data.Bifoldable.$fBifoldableConst_$cbifoldl
  :: forall c a b.
     (c -> a -> c)
     -> (c -> b -> c) -> c -> Data.Functor.Const.Const a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdN8L g_sdN8M z_sdN8N t_sdN8O] f_sdN8L z_sdN8N t_sdN8O;

Data.Bifoldable.$fBifoldableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Functor.Const.Const
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableConst1
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldl];

Data.Bifoldable.$fBifoldable(,)_$cbifold
  :: forall m. GHC.Base.Monoid m => (m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN8P ds_sdN8Q]
        let {
          sat_sdN8Y [Occ=Once] :: m_adKx4
          [LclId] =
              [ds_sdN8Q] \u []
                  case ds_sdN8Q of {
                    (,) _ [Occ=Dead] b_sdN8X [Occ=Once] -> b_sdN8X;
                  }; } in
        let {
          sat_sdN8U [Occ=Once] :: m_adKx4
          [LclId] =
              [ds_sdN8Q] \u []
                  case ds_sdN8Q of {
                    (,) a_sdN8S [Occ=Once] _ [Occ=Dead] -> a_sdN8S;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN8P sat_sdN8U sat_sdN8Y;

Data.Bifoldable.$fBifoldable(,)_$cbifoldr
  :: forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> (a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN8Z g_sdN90 z_sdN91 t_sdN92]
        let {
          sat_sdN9b [Occ=Once] :: c_adKxq
          [LclId] =
              [g_sdN90 z_sdN91 t_sdN92] \u []
                  let {
                    sat_sdN9a [Occ=Once] :: b_adKxr
                    [LclId] =
                        [t_sdN92] \u []
                            case t_sdN92 of {
                              (,) _ [Occ=Dead] b1_sdN99 [Occ=Once] -> b1_sdN99;
                            };
                  } in  g_sdN90 sat_sdN9a z_sdN91; } in
        let {
          sat_sdN96 [Occ=Once] :: a_adKxp
          [LclId] =
              [t_sdN92] \u []
                  case t_sdN92 of {
                    (,) a1_sdN94 [Occ=Once] _ [Occ=Dead] -> a1_sdN94;
                  };
        } in  f_sdN8Z sat_sdN96 sat_sdN9b;

Data.Bifoldable.$fBifoldable(,)_$cbifoldl
  :: forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> (a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN9c g_sdN9d z_sdN9e t_sdN9f]
        let {
          sat_sdN9o [Occ=Once] :: b_adKxD
          [LclId] =
              [t_sdN9f] \u []
                  case t_sdN9f of {
                    (,) _ [Occ=Dead] b1_sdN9n [Occ=Once] -> b1_sdN9n;
                  }; } in
        let {
          sat_sdN9k [Occ=Once] :: c_adKxB
          [LclId] =
              [f_sdN9c z_sdN9e t_sdN9f] \u []
                  let {
                    sat_sdN9j [Occ=Once] :: a_adKxC
                    [LclId] =
                        [t_sdN9f] \u []
                            case t_sdN9f of {
                              (,) a1_sdN9h [Occ=Once] _ [Occ=Dead] -> a1_sdN9h;
                            };
                  } in  f_sdN9c z_sdN9e sat_sdN9j;
        } in  g_sdN9d sat_sdN9k sat_sdN9o;

Data.Bifoldable.$fBifoldable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldl];

Data.Bifoldable.bifoldr'
  :: forall (t :: * -> * -> *) a c b.
     Data.Bifoldable.Bifoldable t =>
     (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN9p f_sdN9q g_sdN9r z0_sdN9s xs_sdN9t]
        let {
          sat_sdN9D [Occ=Once]
            :: (c_adKoc -> c_adKoc) -> b_adKod -> c_adKoc -> c_adKoc
          [LclId] =
              [g_sdN9r] \r [k_sdN9z x_sdN9A z_sdN9B]
                  case g_sdN9r x_sdN9A z_sdN9B of vx_sdN9C {
                    __DEFAULT -> k_sdN9z vx_sdN9C;
                  }; } in
        let {
          sat_sdN9y [Occ=Once]
            :: (c_adKoc -> c_adKoc) -> a_adKob -> c_adKoc -> c_adKoc
          [LclId] =
              [f_sdN9q] \r [k_sdN9u x_sdN9v z_sdN9w]
                  case f_sdN9q x_sdN9v z_sdN9w of vx_sdN9x {
                    __DEFAULT -> k_sdN9u vx_sdN9x;
                  };
        } in 
          Data.Bifoldable.bifoldl
              $dBifoldable_sdN9p
              sat_sdN9y
              sat_sdN9D
              GHC.Base.id
              xs_sdN9t
              z0_sdN9s;

lvl_rdL8s :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

lvl1_rdL8t :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_rdL8s;

Data.Bifoldable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl2_rdL8u :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bifoldable.$trModule4;

Data.Bifoldable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bifoldable"#;

lvl3_rdL8v :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bifoldable.$trModule2;

lvl4_rdL8w :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Data/Bifoldable.hs"#;

lvl5_rdL8x :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_rdL8w;

lvl6_rdL8y :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [188#];

lvl7_rdL8z :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [28#];

lvl8_rdL8A :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [61#];

lvl9_rdL8B :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl6_rdL8y
                                           lvl7_rdL8z
                                           lvl6_rdL8y
                                           lvl8_rdL8A];

lvl10_rdL8C :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl9_rdL8B
                                                  GHC.Stack.Types.EmptyCallStack];

lvl11_rdL8D :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bifoldr1: empty structure"#;

Data.Bifoldable.bifoldr2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_rdL8D of sat_sdN9E {
          __DEFAULT -> GHC.Err.error lvl10_rdL8C sat_sdN9E;
        };

Data.Bifoldable.bifoldr1
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> a) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN9F f_sdN9G xs_sdN9H]
        let {
          mbf_sdN9I
            :: a_adKmT -> GHC.Base.Maybe a_adKmT -> GHC.Base.Maybe a_adKmT
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [f_sdN9G] \r [x_sdN9J m_sdN9K]
                  let {
                    sat_sdN9N [Occ=Once] :: a_adKmT
                    [LclId] =
                        [f_sdN9G x_sdN9J m_sdN9K] \u []
                            case m_sdN9K of {
                              GHC.Base.Nothing -> x_sdN9J;
                              GHC.Base.Just y_sdN9M [Occ=Once] -> f_sdN9G x_sdN9J y_sdN9M;
                            };
                  } in  GHC.Base.Just [sat_sdN9N];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdN9F mbf_sdN9I mbf_sdN9I GHC.Base.Nothing xs_sdN9H
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdN9P [Occ=Once] -> v_sdN9P;
          };

Data.Bifoldable.bimaximumBy
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN9Q cmp_sdN9R xs_sdN9S]
        let {
          mbf_sdN9T
            :: a_adKnp -> GHC.Base.Maybe a_adKnp -> GHC.Base.Maybe a_adKnp
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [cmp_sdN9R] \r [x_sdN9U m_sdN9V]
                  let {
                    sat_sdN9Z [Occ=Once] :: a_adKnp
                    [LclId] =
                        [cmp_sdN9R x_sdN9U m_sdN9V] \u []
                            case m_sdN9V of {
                              GHC.Base.Nothing -> x_sdN9U;
                              GHC.Base.Just y_sdN9X ->
                                  case cmp_sdN9R x_sdN9U y_sdN9X of {
                                    __DEFAULT -> y_sdN9X;
                                    GHC.Types.GT -> x_sdN9U;
                                  };
                            };
                  } in  GHC.Base.Just [sat_sdN9Z];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdN9Q mbf_sdN9T mbf_sdN9T GHC.Base.Nothing xs_sdN9S
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdNa1 [Occ=Once] -> v_sdNa1;
          };

Data.Bifoldable.biminimumBy
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNa2 cmp_sdNa3 xs_sdNa4]
        let {
          mbf_sdNa5
            :: a_adKnN -> GHC.Base.Maybe a_adKnN -> GHC.Base.Maybe a_adKnN
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [cmp_sdNa3] \r [x_sdNa6 m_sdNa7]
                  let {
                    sat_sdNab [Occ=Once] :: a_adKnN
                    [LclId] =
                        [cmp_sdNa3 x_sdNa6 m_sdNa7] \u []
                            case m_sdNa7 of {
                              GHC.Base.Nothing -> x_sdNa6;
                              GHC.Base.Just y_sdNa9 ->
                                  case cmp_sdNa3 x_sdNa6 y_sdNa9 of {
                                    __DEFAULT -> x_sdNa6;
                                    GHC.Types.GT -> y_sdNa9;
                                  };
                            };
                  } in  GHC.Base.Just [sat_sdNab];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdNa2 mbf_sdNa5 mbf_sdNa5 GHC.Base.Nothing xs_sdNa4
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdNad [Occ=Once] -> v_sdNad;
          };

Data.Bifoldable.bifoldrM
  :: forall (t :: * -> * -> *) (m :: * -> *) a c b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Monad m) =>
     (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNae
           $dMonad_sdNaf
           f_sdNag
           g_sdNah
           z0_sdNai
           xs_sdNaj]
        let {
          sat_sdNau [Occ=Once] :: c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdNaf] \u [] GHC.Base.return $dMonad_sdNaf; } in
        let {
          sat_sdNat [Occ=Once]
            :: (c_adKlQ -> m_adKlO c_adKlQ)
               -> b_adKlR -> c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdNaf g_sdNah] \r [k_sdNap x_sdNaq z_sdNar]
                  let {
                    sat_sdNas [Occ=Once] :: m_adKlO c_adKlQ
                    [LclId] =
                        [g_sdNah x_sdNaq z_sdNar] \u [] g_sdNah x_sdNaq z_sdNar;
                  } in  GHC.Base.>>= $dMonad_sdNaf sat_sdNas k_sdNap; } in
        let {
          sat_sdNao [Occ=Once]
            :: (c_adKlQ -> m_adKlO c_adKlQ)
               -> a_adKlP -> c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdNaf f_sdNag] \r [k_sdNak x_sdNal z_sdNam]
                  let {
                    sat_sdNan [Occ=Once] :: m_adKlO c_adKlQ
                    [LclId] =
                        [f_sdNag x_sdNal z_sdNam] \u [] f_sdNag x_sdNal z_sdNam;
                  } in  GHC.Base.>>= $dMonad_sdNaf sat_sdNan k_sdNak;
        } in 
          Data.Bifoldable.bifoldl
              $dBifoldable_sdNae sat_sdNao sat_sdNat sat_sdNau xs_sdNaj z0_sdNai;

Data.Bifoldable.bifoldl'
  :: forall (t :: * -> * -> *) a b c.
     Data.Bifoldable.Bifoldable t =>
     (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNav f_sdNaw g_sdNax z0_sdNay xs_sdNaz]
        let {
          sat_sdNaJ [Occ=Once]
            :: c_adKky -> (a_adKkw -> a_adKkw) -> a_adKkw -> a_adKkw
          [LclId] =
              [g_sdNax] \r [x_sdNaF k_sdNaG z_sdNaH]
                  case g_sdNax z_sdNaH x_sdNaF of vx_sdNaI {
                    __DEFAULT -> k_sdNaG vx_sdNaI;
                  }; } in
        let {
          sat_sdNaE [Occ=Once]
            :: b_adKkx -> (a_adKkw -> a_adKkw) -> a_adKkw -> a_adKkw
          [LclId] =
              [f_sdNaw] \r [x_sdNaA k_sdNaB z_sdNaC]
                  case f_sdNaw z_sdNaC x_sdNaA of vx_sdNaD {
                    __DEFAULT -> k_sdNaB vx_sdNaD;
                  };
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdNav
              sat_sdNaE
              sat_sdNaJ
              GHC.Base.id
              xs_sdNaz
              z0_sdNay;

Data.Bifoldable.bilength2
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sdNaK k_sdNaL z_sdNaM]
        case z_sdNaM of {
          GHC.Types.I# x1_sdNaO [Occ=Once] ->
              case +# [x1_sdNaO 1#] of sat_sdNaP {
                __DEFAULT ->
                    let {
                      sat_sdNaQ [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sdNaP];
                    } in  k_sdNaL sat_sdNaQ;
              };
        };

Data.Bifoldable.bilength1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Bifoldable.bilength
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     t a b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNaR eta_sdNaS]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdNaR
            Data.Bifoldable.bilength2
            Data.Bifoldable.bilength2
            GHC.Base.id
            eta_sdNaS
            Data.Bifoldable.bilength1;

lvl12_rdL8E :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [223#];

lvl13_rdL8F :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl12_rdL8E
                                           lvl7_rdL8z
                                           lvl12_rdL8E
                                           lvl8_rdL8A];

lvl14_rdL8G :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl13_rdL8F
                                                  GHC.Stack.Types.EmptyCallStack];

lvl15_rdL8H :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bifoldl1: empty structure"#;

Data.Bifoldable.bifoldl2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl15_rdL8H of sat_sdNaT {
          __DEFAULT -> GHC.Err.error lvl14_rdL8G sat_sdNaT;
        };

Data.Bifoldable.bifoldl1
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> a) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNaU f_sdNaV xs_sdNaW]
        let {
          mbf_sdNaX
            :: GHC.Base.Maybe a_adKk0 -> a_adKk0 -> GHC.Base.Maybe a_adKk0
          [LclId, Arity=2, Str=<L,1*U><L,U>, Unf=OtherCon []] =
              [f_sdNaV] \r [m_sdNaY y_sdNaZ]
                  let {
                    sat_sdNb2 [Occ=Once] :: a_adKk0
                    [LclId] =
                        [f_sdNaV m_sdNaY y_sdNaZ] \u []
                            case m_sdNaY of {
                              GHC.Base.Nothing -> y_sdNaZ;
                              GHC.Base.Just x_sdNb1 [Occ=Once] -> f_sdNaV x_sdNb1 y_sdNaZ;
                            };
                  } in  GHC.Base.Just [sat_sdNb2];
        } in 
          case
              Data.Bifoldable.bifoldl
                  $dBifoldable_sdNaU mbf_sdNaX mbf_sdNaX GHC.Base.Nothing xs_sdNaW
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldl2;
            GHC.Base.Just v_sdNb4 [Occ=Once] -> v_sdNb4;
          };

Data.Bifoldable.bifoldlM
  :: forall (t :: * -> * -> *) (m :: * -> *) a b c.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Monad m) =>
     (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNb5
           $dMonad_sdNb6
           f_sdNb7
           g_sdNb8
           z0_sdNb9
           xs_sdNba]
        let {
          sat_sdNbl [Occ=Once] :: a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdNb6] \u [] GHC.Base.return $dMonad_sdNb6; } in
        let {
          sat_sdNbk [Occ=Once]
            :: c_adKiY
               -> (a_adKiW -> m_adKiV a_adKiW) -> a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdNb6 g_sdNb8] \r [x_sdNbg k_sdNbh z_sdNbi]
                  let {
                    sat_sdNbj [Occ=Once] :: m_adKiV a_adKiW
                    [LclId] =
                        [g_sdNb8 x_sdNbg z_sdNbi] \u [] g_sdNb8 z_sdNbi x_sdNbg;
                  } in  GHC.Base.>>= $dMonad_sdNb6 sat_sdNbj k_sdNbh; } in
        let {
          sat_sdNbf [Occ=Once]
            :: b_adKiX
               -> (a_adKiW -> m_adKiV a_adKiW) -> a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdNb6 f_sdNb7] \r [x_sdNbb k_sdNbc z_sdNbd]
                  let {
                    sat_sdNbe [Occ=Once] :: m_adKiV a_adKiW
                    [LclId] =
                        [f_sdNb7 x_sdNbb z_sdNbd] \u [] f_sdNb7 z_sdNbd x_sdNbb;
                  } in  GHC.Base.>>= $dMonad_sdNb6 sat_sdNbe k_sdNbc;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdNb5 sat_sdNbf sat_sdNbk sat_sdNbl xs_sdNba z0_sdNb9;

Data.Bifoldable.bitraverse_
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbm $dApplicative_sdNbn f1_sdNbo g_sdNbp]
        let {
          sat_sdNbw [Occ=Once] :: f_adKhx ()
          [LclId] =
              [$dApplicative_sdNbn] \u []
                  GHC.Base.pure $dApplicative_sdNbn GHC.Tuple.(); } in
        let {
          sat_sdNbv [Occ=Once] :: b_adKhA -> f_adKhx () -> f_adKhx ()
          [LclId] =
              [$dApplicative_sdNbn g_sdNbp] \r [x_sdNbt]
                  let {
                    sat_sdNbu [Occ=Once] :: f_adKhx d_adKhB
                    [LclId] =
                        [g_sdNbp x_sdNbt] \u [] g_sdNbp x_sdNbt;
                  } in  GHC.Base.*> $dApplicative_sdNbn sat_sdNbu; } in
        let {
          sat_sdNbs [Occ=Once] :: a_adKhy -> f_adKhx () -> f_adKhx ()
          [LclId] =
              [$dApplicative_sdNbn f1_sdNbo] \r [x_sdNbq]
                  let {
                    sat_sdNbr [Occ=Once] :: f_adKhx c_adKhz
                    [LclId] =
                        [f1_sdNbo x_sdNbq] \u [] f1_sdNbo x_sdNbq;
                  } in  GHC.Base.*> $dApplicative_sdNbn sat_sdNbr;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdNbm sat_sdNbs sat_sdNbv sat_sdNbw;

Data.Bifoldable.bifor_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f ()
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbx
           $dApplicative_sdNby
           t1_sdNbz
           f1_sdNbA
           g_sdNbB]
        Data.Bifoldable.bitraverse_
            $dBifoldable_sdNbx $dApplicative_sdNby f1_sdNbA g_sdNbB t1_sdNbz;

Data.Bifoldable.biforM_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f ()
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bifor_ eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bimapM_
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bitraverse_ eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bisequence_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,U,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbC $dApplicative_sdNbD]
        let {
          sat_sdNbG [Occ=Once] :: f_adKgV ()
          [LclId] =
              [$dApplicative_sdNbD] \u []
                  GHC.Base.pure $dApplicative_sdNbD GHC.Tuple.(); } in
        let {
          sat_sdNbF [Occ=Once] :: f_adKgV b_adKgX -> f_adKgV () -> f_adKgV ()
          [LclId] =
              [$dApplicative_sdNbD] \u [] GHC.Base.*> $dApplicative_sdNbD; } in
        let {
          sat_sdNbE [Occ=Once] :: f_adKgV a_adKgW -> f_adKgV () -> f_adKgV ()
          [LclId] =
              [$dApplicative_sdNbD] \u [] GHC.Base.*> $dApplicative_sdNbD;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdNbC sat_sdNbE sat_sdNbF sat_sdNbG;

Data.Bifoldable.bisequenceA_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.bisequence_ eta_B2 eta_B1;

Data.Bifoldable.biasum
  :: forall (t :: * -> * -> *) (f :: * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Alternative f) =>
     t (f a) (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbH $dAlternative_sdNbI]
        let {
          sat_sdNbL [Occ=Once] :: f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdNbI] \u []
                  GHC.Base.empty $dAlternative_sdNbI; } in
        let {
          sat_sdNbK [Occ=Once]
            :: f_adKgo a_adKgp -> f_adKgo a_adKgp -> f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdNbI] \u [] GHC.Base.<|> $dAlternative_sdNbI; } in
        let {
          sat_sdNbJ [Occ=Once]
            :: f_adKgo a_adKgp -> f_adKgo a_adKgp -> f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdNbI] \u [] GHC.Base.<|> $dAlternative_sdNbI;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdNbH sat_sdNbJ sat_sdNbK sat_sdNbL;

Data.Bifoldable.bimsum
  :: forall (t :: * -> * -> *) (f :: * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Alternative f) =>
     t (f a) (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,U,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.biasum eta_B2 eta_B1;

Data.Bifoldable.biList
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     t a a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbM]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdNbM GHC.Types.: GHC.Types.: GHC.Types.[];

Data.Bifoldable.binull1
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdNbN ds1_sdNbO] GHC.Types.False [];

Data.Bifoldable.binull
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     t a b -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbP]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdNbP
            Data.Bifoldable.binull1
            Data.Bifoldable.binull1
            GHC.Types.True;

Data.Bifoldable.biconcat
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     t [a] [a] -> [a]
[GblId,
 Arity=1,
 Str=<S(C(S)LLL),1*U(1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbQ]
        Data.Bifoldable.bifold $dBifoldable_sdNbQ GHC.Base.$fMonoid[];

lvl16_rdL8I :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [334#];

lvl17_rdL8J :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [24#];

lvl18_rdL8K :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [58#];

lvl19_rdL8L :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl16_rdL8I
                                           lvl17_rdL8J
                                           lvl16_rdL8I
                                           lvl18_rdL8K];

lvl20_rdL8M :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl19_rdL8L
                                                  GHC.Stack.Types.EmptyCallStack];

lvl21_rdL8N :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bimaximum: empty structure"#;

Data.Bifoldable.bimaximum1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl21_rdL8N of sat_sdNbR {
          __DEFAULT -> GHC.Err.error lvl20_rdL8M sat_sdNbR;
        };

Data.Bifoldable.bimaximum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Ord a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbS $dOrd_sdNbT]
        let {
          g_sdNbU [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKeD a_adKeE a_adKeE -> Data.Functor.Utils.Max a_adKeE
          [LclId] =
              [$dBifoldable_sdNbS $dOrd_sdNbT] \u []
                  let {
                    sat_sdNbV [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Max a_adKeE)
                    [LclId] =
                        [$dOrd_sdNbT] \u [] Data.Functor.Utils.$fMonoidMax $dOrd_sdNbT;
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdNbS sat_sdNbV GHC.Base.Just GHC.Base.Just; } in
        let {
          sat_sdNbZ [Occ=OnceT[0]] :: t_adKeD a_adKeE a_adKeE -> a_adKeE
          [LclId] =
              [g_sdNbU] \r [x_sdNbW]
                  case g_sdNbU x_sdNbW of {
                    GHC.Base.Nothing -> Data.Bifoldable.bimaximum1;
                    GHC.Base.Just v_sdNbY [Occ=Once] -> v_sdNbY;
                  };
        } in  sat_sdNbZ;

lvl22_rdL8O :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [342#];

lvl23_rdL8P :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl22_rdL8O
                                           lvl17_rdL8J
                                           lvl22_rdL8O
                                           lvl18_rdL8K];

lvl24_rdL8Q :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl23_rdL8P
                                                  GHC.Stack.Types.EmptyCallStack];

lvl25_rdL8R :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "biminimum: empty structure"#;

Data.Bifoldable.biminimum1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl25_rdL8R of sat_sdNc0 {
          __DEFAULT -> GHC.Err.error lvl24_rdL8Q sat_sdNc0;
        };

Data.Bifoldable.biminimum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Ord a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNc1 $dOrd_sdNc2]
        let {
          g_sdNc3 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKdQ a_adKdR a_adKdR -> Data.Functor.Utils.Min a_adKdR
          [LclId] =
              [$dBifoldable_sdNc1 $dOrd_sdNc2] \u []
                  let {
                    sat_sdNc4 [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Min a_adKdR)
                    [LclId] =
                        [$dOrd_sdNc2] \u [] Data.Functor.Utils.$fMonoidMin $dOrd_sdNc2;
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdNc1 sat_sdNc4 GHC.Base.Just GHC.Base.Just; } in
        let {
          sat_sdNc8 [Occ=OnceT[0]] :: t_adKdQ a_adKdR a_adKdR -> a_adKdR
          [LclId] =
              [g_sdNc3] \r [x_sdNc5]
                  case g_sdNc3 x_sdNc5 of {
                    GHC.Base.Nothing -> Data.Bifoldable.biminimum1;
                    GHC.Base.Just v_sdNc7 [Occ=Once] -> v_sdNc7;
                  };
        } in  sat_sdNc8;

Data.Bifoldable.biproduct2 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdNc9] v_sdNc9;

Data.Bifoldable.bisum1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNca $dNum_sdNcb]
        let {
          sat_sdNcc [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_adKdy)
          [LclId] =
              [$dNum_sdNcb] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sdNcb;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdNca
              sat_sdNcc
              Data.Bifoldable.biproduct2
              Data.Bifoldable.biproduct2;

Data.Bifoldable.bisum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.bisum1 eta_B2 eta_B1;

Data.Bifoldable.biproduct1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcd $dNum_sdNce]
        let {
          sat_sdNcf [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_adKdf)
          [LclId] =
              [$dNum_sdNce] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sdNce;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdNcd
              sat_sdNcf
              Data.Bifoldable.biproduct2
              Data.Bifoldable.biproduct2;

Data.Bifoldable.biproduct
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.biproduct1 eta_B2 eta_B1;

Data.Bifoldable.biconcatMap
  :: forall (t :: * -> * -> *) a c b.
     Data.Bifoldable.Bifoldable t =>
     (a -> [c]) -> (b -> [c]) -> t a b -> [c]
[GblId,
 Arity=1,
 Str=<S(LC(S)LL),1*U(A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcg]
        Data.Bifoldable.bifoldMap $dBifoldable_sdNcg GHC.Base.$fMonoid[];

Data.Bifoldable.biand2 :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdNch] v_sdNch;

Data.Bifoldable.biand1
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNci]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdNci
            Data.Semigroup.Internal.$fMonoidAll
            Data.Bifoldable.biand2
            Data.Bifoldable.biand2;

Data.Bifoldable.biand
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Bifoldable.biand1 eta_B1;

Data.Bifoldable.bior1
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcj]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdNcj
            Data.Semigroup.Internal.$fMonoidAny
            Data.Bifoldable.biand2
            Data.Bifoldable.biand2;

Data.Bifoldable.bior
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Bifoldable.bior1 eta_B1;

Data.Bifoldable.biany1
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNck p_sdNcl q_sdNcm]
        let {
          sat_sdNcq [Occ=Once] :: b_adKcd -> Data.Semigroup.Internal.Any
          [LclId] =
              [q_sdNcm] \r [x_sdNcp] q_sdNcm x_sdNcp; } in
        let {
          sat_sdNco [Occ=Once] :: a_adKcc -> Data.Semigroup.Internal.Any
          [LclId] =
              [p_sdNcl] \r [x_sdNcn] p_sdNcl x_sdNcn;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdNck
              Data.Semigroup.Internal.$fMonoidAny
              sat_sdNco
              sat_sdNcq;

Data.Bifoldable.biany
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.biany1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bielem1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcr $dEq_sdNcs x_sdNct]
        let {
          sat_sdNcx [Occ=Once] :: a_adKfA -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_sdNcs x_sdNct] \r [x1_sdNcw]
                  GHC.Classes.== $dEq_sdNcs x1_sdNcw x_sdNct; } in
        let {
          sat_sdNcv [Occ=Once] :: a_adKfA -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_sdNcs x_sdNct] \r [x1_sdNcu]
                  GHC.Classes.== $dEq_sdNcs x1_sdNcu x_sdNct;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdNcr
              Data.Semigroup.Internal.$fMonoidAny
              sat_sdNcv
              sat_sdNcx;

Data.Bifoldable.bielem
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bielem1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.binotElem
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcy $dEq_sdNcz x_sdNcA]
        let {
          g_sdNcB [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKfN a_adKfO a_adKfO -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dBifoldable_sdNcy $dEq_sdNcz x_sdNcA] \u []
                  Data.Bifoldable.bielem1 $dBifoldable_sdNcy $dEq_sdNcz x_sdNcA; } in
        let {
          sat_sdNcE [Occ=OnceT[0]]
            :: t_adKfN a_adKfO a_adKfO -> GHC.Types.Bool
          [LclId] =
              [g_sdNcB] \r [x1_sdNcC]
                  case g_sdNcB x1_sdNcC of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  sat_sdNcE;

Data.Bifoldable.biall1
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcF p_sdNcG q_sdNcH]
        let {
          sat_sdNcL [Occ=Once] :: b_adKbP -> Data.Semigroup.Internal.All
          [LclId] =
              [q_sdNcH] \r [x_sdNcK] q_sdNcH x_sdNcK; } in
        let {
          sat_sdNcJ [Occ=Once] :: a_adKbO -> Data.Semigroup.Internal.All
          [LclId] =
              [p_sdNcG] \r [x_sdNcI] p_sdNcG x_sdNcI;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdNcF
              Data.Semigroup.Internal.$fMonoidAll
              sat_sdNcJ
              sat_sdNcL;

Data.Bifoldable.biall
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.biall1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bifind
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool) -> t a a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcM p_sdNcN]
        let {
          g_sdNcO [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKbl a_adKbm a_adKbm -> Data.Monoid.First a_adKbm
          [LclId] =
              [$dBifoldable_sdNcM p_sdNcN] \u []
                  let {
                    finder_sdNcP :: a_adKbm -> GHC.Base.Maybe a_adKbm
                    [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                        [p_sdNcN] \r [x_sdNcQ]
                            case p_sdNcN x_sdNcQ of {
                              GHC.Types.False -> GHC.Base.Nothing [];
                              GHC.Types.True -> GHC.Base.Just [x_sdNcQ];
                            };
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdNcM
                        Data.Monoid.$fMonoidFirst
                        finder_sdNcP
                        finder_sdNcP; } in
        let {
          sat_sdNcT [Occ=Once]
            :: t_adKbl a_adKbm a_adKbm -> Data.Monoid.First a_adKbm
          [LclId] =
              [g_sdNcO] \r [x_sdNcS] g_sdNcO x_sdNcS;
        } in  sat_sdNcT;

Data.Bifoldable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$trModule4];

Data.Bifoldable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$trModule2];

Data.Bifoldable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bifoldable.$trModule3
                                     Data.Bifoldable.$trModule1];

$krep_rdL8S :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bifoldable.$tcBifoldable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdL8S];

Data.Bifoldable.$tcBifoldable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bifoldable"#;

Data.Bifoldable.$tcBifoldable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$tcBifoldable3];

Data.Bifoldable.$tcBifoldable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13881323671910883383##
                                    7079945659398195047##
                                    Data.Bifoldable.$trModule
                                    Data.Bifoldable.$tcBifoldable2
                                    0#
                                    Data.Bifoldable.$tcBifoldable1];

Data.Bifoldable.C:Bifoldable
  :: forall (p :: * -> * -> *).
     (forall m. GHC.Base.Monoid m => p m m -> m)
     -> (forall m a b.
         GHC.Base.Monoid m =>
         (a -> m) -> (b -> m) -> p a b -> m)
     -> (forall a c b.
         (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c)
     -> (forall c a b.
         (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c)
     -> Data.Bifoldable.Bifoldable p
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.C:Bifoldable [eta_B4 eta_B3 eta_B2 eta_B1];


==================== STG syntax: ====================
2018-03-16 16:09:02.221459857 UTC

Data.Bifoldable.bifold
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m. GHC.Base.Monoid m => p m m -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLL),U(U,A,A,A)>] =
    [] \r [v_sdN0U]
        case v_sdN0U of {
          Data.Bifoldable.C:Bifoldable v_sdN0W [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdN0W;
        };

Data.Bifoldable.bifoldMap
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> p a b -> m
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLL),U(A,U,A,A)>] =
    [] \r [v_sdN10]
        case v_sdN10 of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       v_sdN13 [Occ=Once]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead] ->
              v_sdN13;
        };

Data.Bifoldable.bifoldr
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSL),U(A,A,U,A)>] =
    [] \r [v_sdN16]
        case v_sdN16 of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdN1a [Occ=Once]
                                       _ [Occ=Dead] ->
              v_sdN1a;
        };

Data.Bifoldable.bifoldl
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLS),U(A,A,A,U)>] =
    [] \r [v_sdN1c]
        case v_sdN1c of {
          Data.Bifoldable.C:Bifoldable _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       v_sdN1h [Occ=Once] ->
              v_sdN1h;
        };

Data.Bifoldable.$fBifoldable(,)_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN1i f_sdN1j g_sdN1k ds_sdN1l]
        let {
          sat_sdN1v [Occ=Once] :: m_adKxe
          [LclId] =
              [g_sdN1k ds_sdN1l] \u []
                  let {
                    sat_sdN1u [Occ=Once] :: b_adKxg
                    [LclId] =
                        [ds_sdN1l] \u []
                            case ds_sdN1l of {
                              (,) _ [Occ=Dead] b1_sdN1t [Occ=Once] -> b1_sdN1t;
                            };
                  } in  g_sdN1k sat_sdN1u; } in
        let {
          sat_sdN1q [Occ=Once] :: m_adKxe
          [LclId] =
              [f_sdN1j ds_sdN1l] \u []
                  let {
                    sat_sdN1p [Occ=Once] :: a_adKxf
                    [LclId] =
                        [ds_sdN1l] \u []
                            case ds_sdN1l of {
                              (,) a1_sdN1n [Occ=Once] _ [Occ=Dead] -> a1_sdN1n;
                            };
                  } in  f_sdN1j sat_sdN1p;
        } in  GHC.Base.mappend $dMonoid_sdN1i sat_sdN1q sat_sdN1v;

Data.Bifoldable.$fBifoldableConst_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Functor.Const.Const a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN1w f_sdN1x ds_sdN1y ds1_sdN1z]
        f_sdN1x ds1_sdN1z;

Data.Bifoldable.$fBifoldableK1_$cbifoldMap
  :: forall i m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> GHC.Generics.K1 i a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U)><L,A><L,U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN1A f_sdN1B ds_sdN1C ds1_sdN1D]
        f_sdN1B ds1_sdN1D;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap
  :: forall x m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN1E f_sdN1F g_sdN1G ds_sdN1H]
        let {
          sat_sdN1T [Occ=Once] :: m_adKv0
          [LclId] =
              [g_sdN1G ds_sdN1H] \u []
                  let {
                    sat_sdN1S [Occ=Once] :: b_adKv2
                    [LclId] =
                        [ds_sdN1H] \u []
                            case ds_sdN1H of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdN1R [Occ=Once] -> b1_sdN1R;
                            };
                  } in  g_sdN1G sat_sdN1S; } in
        let {
          sat_sdN1N [Occ=Once] :: m_adKv0
          [LclId] =
              [f_sdN1F ds_sdN1H] \u []
                  let {
                    sat_sdN1M [Occ=Once] :: a_adKv1
                    [LclId] =
                        [ds_sdN1H] \u []
                            case ds_sdN1H of {
                              (,,) _ [Occ=Dead] a1_sdN1K [Occ=Once] _ [Occ=Dead] -> a1_sdN1K;
                            };
                  } in  f_sdN1F sat_sdN1M;
        } in  GHC.Base.mappend $dMonoid_sdN1E sat_sdN1N sat_sdN1T;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap
  :: forall x y m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN1U f_sdN1V g_sdN1W ds_sdN1X]
        let {
          sat_sdN2b [Occ=Once] :: m_adKue
          [LclId] =
              [g_sdN1W ds_sdN1X] \u []
                  let {
                    sat_sdN2a [Occ=Once] :: b_adKug
                    [LclId] =
                        [ds_sdN1X] \u []
                            case ds_sdN1X of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdN29 [Occ=Once] ->
                                  b1_sdN29;
                            };
                  } in  g_sdN1W sat_sdN2a; } in
        let {
          sat_sdN24 [Occ=Once] :: m_adKue
          [LclId] =
              [f_sdN1V ds_sdN1X] \u []
                  let {
                    sat_sdN23 [Occ=Once] :: a_adKuf
                    [LclId] =
                        [ds_sdN1X] \u []
                            case ds_sdN1X of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdN21 [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdN21;
                            };
                  } in  f_sdN1V sat_sdN23;
        } in  GHC.Base.mappend $dMonoid_sdN1U sat_sdN24 sat_sdN2b;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap
  :: forall x y z m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN2c f_sdN2d g_sdN2e ds_sdN2f]
        let {
          sat_sdN2v [Occ=Once] :: m_adKtr
          [LclId] =
              [g_sdN2e ds_sdN2f] \u []
                  let {
                    sat_sdN2u [Occ=Once] :: b_adKtt
                    [LclId] =
                        [ds_sdN2f] \u []
                            case ds_sdN2f of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdN2t [Occ=Once] ->
                                  b1_sdN2t;
                            };
                  } in  g_sdN2e sat_sdN2u; } in
        let {
          sat_sdN2n [Occ=Once] :: m_adKtr
          [LclId] =
              [f_sdN2d ds_sdN2f] \u []
                  let {
                    sat_sdN2m [Occ=Once] :: a_adKts
                    [LclId] =
                        [ds_sdN2f] \u []
                            case ds_sdN2f of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdN2k [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdN2k;
                            };
                  } in  f_sdN2d sat_sdN2m;
        } in  GHC.Base.mappend $dMonoid_sdN2c sat_sdN2n sat_sdN2v;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap
  :: forall x y z w m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, w, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN2w f_sdN2x g_sdN2y ds_sdN2z]
        let {
          sat_sdN2R [Occ=Once] :: m_adKsD
          [LclId] =
              [g_sdN2y ds_sdN2z] \u []
                  let {
                    sat_sdN2Q [Occ=Once] :: b_adKsF
                    [LclId] =
                        [ds_sdN2z] \u []
                            case ds_sdN2z of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdN2P [Occ=Once] ->
                                  b1_sdN2P;
                            };
                  } in  g_sdN2y sat_sdN2Q; } in
        let {
          sat_sdN2I [Occ=Once] :: m_adKsD
          [LclId] =
              [f_sdN2x ds_sdN2z] \u []
                  let {
                    sat_sdN2H [Occ=Once] :: a_adKsE
                    [LclId] =
                        [ds_sdN2z] \u []
                            case ds_sdN2z of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdN2F [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdN2F;
                            };
                  } in  f_sdN2x sat_sdN2H;
        } in  GHC.Base.mappend $dMonoid_sdN2w sat_sdN2I sat_sdN2R;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap
  :: forall x y z w v m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> (x, y, z, w, v, a, b) -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,1*C1(U)><L,1*C1(U)><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN2S f_sdN2T g_sdN2U ds_sdN2V]
        let {
          sat_sdN3f [Occ=Once] :: m_adKrO
          [LclId] =
              [g_sdN2U ds_sdN2V] \u []
                  let {
                    sat_sdN3e [Occ=Once] :: b_adKrQ
                    [LclId] =
                        [ds_sdN2V] \u []
                            case ds_sdN2V of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdN3d [Occ=Once] ->
                                  b1_sdN3d;
                            };
                  } in  g_sdN2U sat_sdN3e; } in
        let {
          sat_sdN35 [Occ=Once] :: m_adKrO
          [LclId] =
              [f_sdN2T ds_sdN2V] \u []
                  let {
                    sat_sdN34 [Occ=Once] :: a_adKrP
                    [LclId] =
                        [ds_sdN2V] \u []
                            case ds_sdN2V of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdN32 [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdN32;
                            };
                  } in  f_sdN2T sat_sdN34;
        } in  GHC.Base.mappend $dMonoid_sdN2S sat_sdN35 sat_sdN3f;

Data.Bifoldable.$fBifoldableEither_$cbifoldMap
  :: forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> Data.Either.Either a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,1*C1(U)><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN3g f_sdN3h ds_sdN3i ds1_sdN3j]
        case ds1_sdN3j of {
          Data.Either.Left a1_sdN3l [Occ=Once] -> f_sdN3h a1_sdN3l;
          Data.Either.Right b1_sdN3m [Occ=Once] -> ds_sdN3i b1_sdN3m;
        };

poly_$dMonoid_rdL8r
  :: forall c.
     GHC.Base.Monoid
       (Data.Semigroup.Internal.Dual (Data.Semigroup.Internal.Endo c))
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fMonoidDual
            Data.Semigroup.Internal.$fMonoidEndo;

Data.Bifoldable.$dmbifoldl
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
[GblId,
 Arity=5,
 Str=<S(LC(C(C(C(S))))LL),1*U(A,1*C1(C1(C1(C1(U)))),A,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN3n f_sdN3o g_sdN3p z_sdN3q t_sdN3r]
        let {
          sat_sdN3x [Occ=Once]
            :: b_adKqf
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo c_adKqd)
          [LclId] =
              [g_sdN3p] \r [x_sdN3v y_sdN3w] g_sdN3p y_sdN3w x_sdN3v; } in
        let {
          sat_sdN3u [Occ=Once]
            :: a_adKqe
               -> Data.Semigroup.Internal.Dual
                    (Data.Semigroup.Internal.Endo c_adKqd)
          [LclId] =
              [f_sdN3o] \r [x_sdN3s y_sdN3t] f_sdN3o y_sdN3t x_sdN3s;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdN3n
              poly_$dMonoid_rdL8r
              sat_sdN3u
              sat_sdN3x
              t_sdN3r
              z_sdN3q;

Data.Bifoldable.$dmbifoldr
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
[GblId,
 Arity=5,
 Str=<S(LC(C(C(C(S))))LL),1*U(A,1*C1(C1(C1(C1(U)))),A,A)><L,U><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN3y f_sdN3z g_sdN3A z_sdN3B t_sdN3C]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdN3y
            Data.Semigroup.Internal.$fMonoidEndo
            f_sdN3z
            g_sdN3A
            t_sdN3C
            z_sdN3B;

Data.Bifoldable.$dmbifoldMap
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m a b.
     GHC.Base.Monoid m =>
     (a -> m) -> (b -> m) -> p a b -> m
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN3D $dMonoid_sdN3E f_sdN3F g_sdN3G]
        let {
          sat_sdN3N [Occ=Once] :: m_adKpn
          [LclId] =
              [$dMonoid_sdN3E] \u [] GHC.Base.mempty $dMonoid_sdN3E; } in
        let {
          sat_sdN3M [Occ=Once] :: b_adKpp -> m_adKpn -> m_adKpn
          [LclId] =
              [$dMonoid_sdN3E g_sdN3G] \r [x_sdN3K]
                  let {
                    sat_sdN3L [Occ=Once] :: m_adKpn
                    [LclId] =
                        [g_sdN3G x_sdN3K] \u [] g_sdN3G x_sdN3K;
                  } in  GHC.Base.mappend $dMonoid_sdN3E sat_sdN3L; } in
        let {
          sat_sdN3J [Occ=Once] :: a_adKpo -> m_adKpn -> m_adKpn
          [LclId] =
              [$dMonoid_sdN3E f_sdN3F] \r [x_sdN3H]
                  let {
                    sat_sdN3I [Occ=Once] :: m_adKpn
                    [LclId] =
                        [f_sdN3F x_sdN3H] \u [] f_sdN3F x_sdN3H;
                  } in  GHC.Base.mappend $dMonoid_sdN3E sat_sdN3I;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdN3D sat_sdN3J sat_sdN3M sat_sdN3N;

Data.Bifoldable.$dmbifold
  :: forall (p :: * -> * -> *).
     Data.Bifoldable.Bifoldable p =>
     forall m. GHC.Base.Monoid m => p m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN3O $dMonoid_sdN3P]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdN3O $dMonoid_sdN3P GHC.Base.id GHC.Base.id;

Data.Bifoldable.$fBifoldableEither_$cbifold
  :: forall m. GHC.Base.Monoid m => Data.Either.Either m m -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN3Q ds_sdN3R]
        case ds_sdN3R of {
          Data.Either.Left a_sdN3T [Occ=Once] -> a_sdN3T;
          Data.Either.Right b_sdN3U [Occ=Once] -> b_sdN3U;
        };

Data.Bifoldable.$fBifoldableEither_$cbifoldr
  :: forall a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> Data.Either.Either a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdN3V g_sdN3W z_sdN3X t_sdN3Y]
        case t_sdN3Y of {
          Data.Either.Left a1_sdN40 [Occ=Once] -> f_sdN3V a1_sdN40 z_sdN3X;
          Data.Either.Right b1_sdN41 [Occ=Once] -> g_sdN3W b1_sdN41 z_sdN3X;
        };

Data.Bifoldable.$fBifoldableEither_$cbifoldl
  :: forall c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> Data.Either.Either a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sdN42 g_sdN43 z_sdN44 t_sdN45]
        case t_sdN45 of {
          Data.Either.Left a1_sdN47 [Occ=Once] -> f_sdN42 z_sdN44 a1_sdN47;
          Data.Either.Right b1_sdN48 [Occ=Once] -> g_sdN43 z_sdN44 b1_sdN48;
        };

Data.Bifoldable.$fBifoldableEither [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Either.Either
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableEither_$cbifold
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableEither_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold
  :: forall x y z w v m.
     GHC.Base.Monoid m =>
     (x, y, z, w, v, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN49 ds_sdN4a]
        let {
          sat_sdN4s [Occ=Once] :: m_adKrE
          [LclId] =
              [ds_sdN4a] \u []
                  case ds_sdN4a of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b_sdN4r [Occ=Once] ->
                        b_sdN4r;
                  }; } in
        let {
          sat_sdN4j [Occ=Once] :: m_adKrE
          [LclId] =
              [ds_sdN4a] \u []
                  case ds_sdN4a of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a_sdN4h [Occ=Once]
                             _ [Occ=Dead] ->
                        a_sdN4h;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN49 sat_sdN4j sat_sdN4s;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr
  :: forall x y z w v a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, w, v, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN4t g_sdN4u z1_sdN4v t_sdN4w]
        let {
          sat_sdN4P [Occ=Once] :: c_adKs0
          [LclId] =
              [g_sdN4u z1_sdN4v t_sdN4w] \u []
                  let {
                    sat_sdN4O [Occ=Once] :: b_adKs1
                    [LclId] =
                        [t_sdN4w] \u []
                            case t_sdN4w of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       b1_sdN4N [Occ=Once] ->
                                  b1_sdN4N;
                            };
                  } in  g_sdN4u sat_sdN4O z1_sdN4v; } in
        let {
          sat_sdN4F [Occ=Once] :: a_adKrZ
          [LclId] =
              [t_sdN4w] \u []
                  case t_sdN4w of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             a1_sdN4D [Occ=Once]
                             _ [Occ=Dead] ->
                        a1_sdN4D;
                  };
        } in  f_sdN4t sat_sdN4F sat_sdN4P;

Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl
  :: forall x y z w v c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, w, v, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN4Q g_sdN4R z1_sdN4S t_sdN4T]
        let {
          sat_sdN5c [Occ=Once] :: b_adKsd
          [LclId] =
              [t_sdN4T] \u []
                  case t_sdN4T of {
                    (,,,,,,) _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             _ [Occ=Dead]
                             b1_sdN5b [Occ=Once] ->
                        b1_sdN5b;
                  }; } in
        let {
          sat_sdN53 [Occ=Once] :: c_adKsb
          [LclId] =
              [f_sdN4Q z1_sdN4S t_sdN4T] \u []
                  let {
                    sat_sdN52 [Occ=Once] :: a_adKsc
                    [LclId] =
                        [t_sdN4T] \u []
                            case t_sdN4T of {
                              (,,,,,,) _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       _ [Occ=Dead]
                                       a1_sdN50 [Occ=Once]
                                       _ [Occ=Dead] ->
                                  a1_sdN50;
                            };
                  } in  f_sdN4Q z1_sdN4S sat_sdN52;
        } in  g_sdN4R sat_sdN53 sat_sdN5c;

Data.Bifoldable.$fBifoldable(,,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w v.
     Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold
  :: forall x y z w m. GHC.Base.Monoid m => (x, y, z, w, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN5d ds_sdN5e]
        let {
          sat_sdN5u [Occ=Once] :: m_adKst
          [LclId] =
              [ds_sdN5e] \u []
                  case ds_sdN5e of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b_sdN5t [Occ=Once] ->
                        b_sdN5t;
                  }; } in
        let {
          sat_sdN5m [Occ=Once] :: m_adKst
          [LclId] =
              [ds_sdN5e] \u []
                  case ds_sdN5e of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a_sdN5k [Occ=Once]
                            _ [Occ=Dead] ->
                        a_sdN5k;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN5d sat_sdN5m sat_sdN5u;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr
  :: forall x y z w a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, w, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN5v g_sdN5w z1_sdN5x t_sdN5y]
        let {
          sat_sdN5P [Occ=Once] :: c_adKsP
          [LclId] =
              [g_sdN5w z1_sdN5x t_sdN5y] \u []
                  let {
                    sat_sdN5O [Occ=Once] :: b_adKsQ
                    [LclId] =
                        [t_sdN5y] \u []
                            case t_sdN5y of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      b1_sdN5N [Occ=Once] ->
                                  b1_sdN5N;
                            };
                  } in  g_sdN5w sat_sdN5O z1_sdN5x; } in
        let {
          sat_sdN5G [Occ=Once] :: a_adKsO
          [LclId] =
              [t_sdN5y] \u []
                  case t_sdN5y of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            a1_sdN5E [Occ=Once]
                            _ [Occ=Dead] ->
                        a1_sdN5E;
                  };
        } in  f_sdN5v sat_sdN5G sat_sdN5P;

Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl
  :: forall x y z w c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, w, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN5Q g_sdN5R z1_sdN5S t_sdN5T]
        let {
          sat_sdN6a [Occ=Once] :: b_adKt2
          [LclId] =
              [t_sdN5T] \u []
                  case t_sdN5T of {
                    (,,,,,) _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            _ [Occ=Dead]
                            b1_sdN69 [Occ=Once] ->
                        b1_sdN69;
                  }; } in
        let {
          sat_sdN62 [Occ=Once] :: c_adKt0
          [LclId] =
              [f_sdN5Q z1_sdN5S t_sdN5T] \u []
                  let {
                    sat_sdN61 [Occ=Once] :: a_adKt1
                    [LclId] =
                        [t_sdN5T] \u []
                            case t_sdN5T of {
                              (,,,,,) _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      a1_sdN5Z [Occ=Once]
                                      _ [Occ=Dead] ->
                                  a1_sdN5Z;
                            };
                  } in  f_sdN5Q z1_sdN5S sat_sdN61;
        } in  g_sdN5R sat_sdN62 sat_sdN6a;

Data.Bifoldable.$fBifoldable(,,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z w. Data.Bifoldable.Bifoldable ((,,,,,) x y z w)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,,)_$cbifold
  :: forall x y z m. GHC.Base.Monoid m => (x, y, z, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN6b ds_sdN6c]
        let {
          sat_sdN6q [Occ=Once] :: m_adKth
          [LclId] =
              [ds_sdN6c] \u []
                  case ds_sdN6c of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b_sdN6p [Occ=Once] ->
                        b_sdN6p;
                  }; } in
        let {
          sat_sdN6j [Occ=Once] :: m_adKth
          [LclId] =
              [ds_sdN6c] \u []
                  case ds_sdN6c of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a_sdN6h [Occ=Once]
                           _ [Occ=Dead] ->
                        a_sdN6h;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN6b sat_sdN6j sat_sdN6q;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr
  :: forall x y z a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, z, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN6r g_sdN6s z1_sdN6t t_sdN6u]
        let {
          sat_sdN6J [Occ=Once] :: c_adKtD
          [LclId] =
              [g_sdN6s z1_sdN6t t_sdN6u] \u []
                  let {
                    sat_sdN6I [Occ=Once] :: b_adKtE
                    [LclId] =
                        [t_sdN6u] \u []
                            case t_sdN6u of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     b1_sdN6H [Occ=Once] ->
                                  b1_sdN6H;
                            };
                  } in  g_sdN6s sat_sdN6I z1_sdN6t; } in
        let {
          sat_sdN6B [Occ=Once] :: a_adKtC
          [LclId] =
              [t_sdN6u] \u []
                  case t_sdN6u of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           a1_sdN6z [Occ=Once]
                           _ [Occ=Dead] ->
                        a1_sdN6z;
                  };
        } in  f_sdN6r sat_sdN6B sat_sdN6J;

Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl
  :: forall x y z c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, z, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN6K g_sdN6L z1_sdN6M t_sdN6N]
        let {
          sat_sdN72 [Occ=Once] :: b_adKtQ
          [LclId] =
              [t_sdN6N] \u []
                  case t_sdN6N of {
                    (,,,,) _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           _ [Occ=Dead]
                           b1_sdN71 [Occ=Once] ->
                        b1_sdN71;
                  }; } in
        let {
          sat_sdN6V [Occ=Once] :: c_adKtO
          [LclId] =
              [f_sdN6K z1_sdN6M t_sdN6N] \u []
                  let {
                    sat_sdN6U [Occ=Once] :: a_adKtP
                    [LclId] =
                        [t_sdN6N] \u []
                            case t_sdN6N of {
                              (,,,,) _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     _ [Occ=Dead]
                                     a1_sdN6S [Occ=Once]
                                     _ [Occ=Dead] ->
                                  a1_sdN6S;
                            };
                  } in  f_sdN6K z1_sdN6M sat_sdN6U;
        } in  g_sdN6L sat_sdN6V sat_sdN72;

Data.Bifoldable.$fBifoldable(,,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y z. Data.Bifoldable.Bifoldable ((,,,,) x y z)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,,)_$cbifold
  :: forall x y m. GHC.Base.Monoid m => (x, y, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN73 ds_sdN74]
        let {
          sat_sdN7g [Occ=Once] :: m_adKu4
          [LclId] =
              [ds_sdN74] \u []
                  case ds_sdN74 of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b_sdN7f [Occ=Once] ->
                        b_sdN7f;
                  }; } in
        let {
          sat_sdN7a [Occ=Once] :: m_adKu4
          [LclId] =
              [ds_sdN74] \u []
                  case ds_sdN74 of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a_sdN78 [Occ=Once] _ [Occ=Dead] ->
                        a_sdN78;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN73 sat_sdN7a sat_sdN7g;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr
  :: forall x y a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, y, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN7h g_sdN7i z_sdN7j t_sdN7k]
        let {
          sat_sdN7x [Occ=Once] :: c_adKuq
          [LclId] =
              [g_sdN7i z_sdN7j t_sdN7k] \u []
                  let {
                    sat_sdN7w [Occ=Once] :: b_adKur
                    [LclId] =
                        [t_sdN7k] \u []
                            case t_sdN7k of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdN7v [Occ=Once] ->
                                  b1_sdN7v;
                            };
                  } in  g_sdN7i sat_sdN7w z_sdN7j; } in
        let {
          sat_sdN7q [Occ=Once] :: a_adKup
          [LclId] =
              [t_sdN7k] \u []
                  case t_sdN7k of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdN7o [Occ=Once] _ [Occ=Dead] ->
                        a1_sdN7o;
                  };
        } in  f_sdN7h sat_sdN7q sat_sdN7x;

Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl
  :: forall x y c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, y, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN7y g_sdN7z z_sdN7A t_sdN7B]
        let {
          sat_sdN7O [Occ=Once] :: b_adKuD
          [LclId] =
              [t_sdN7B] \u []
                  case t_sdN7B of {
                    (,,,) _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] b1_sdN7N [Occ=Once] ->
                        b1_sdN7N;
                  }; } in
        let {
          sat_sdN7I [Occ=Once] :: c_adKuB
          [LclId] =
              [f_sdN7y z_sdN7A t_sdN7B] \u []
                  let {
                    sat_sdN7H [Occ=Once] :: a_adKuC
                    [LclId] =
                        [t_sdN7B] \u []
                            case t_sdN7B of {
                              (,,,) _ [Occ=Dead] _ [Occ=Dead] a1_sdN7F [Occ=Once] _ [Occ=Dead] ->
                                  a1_sdN7F;
                            };
                  } in  f_sdN7y z_sdN7A sat_sdN7H;
        } in  g_sdN7z sat_sdN7I sat_sdN7O;

Data.Bifoldable.$fBifoldable(,,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x y. Data.Bifoldable.Bifoldable ((,,,) x y)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,,)_$cbifoldl];

Data.Bifoldable.$fBifoldable(,,)_$cbifold
  :: forall x m. GHC.Base.Monoid m => (x, m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN7P ds_sdN7Q]
        let {
          sat_sdN80 [Occ=Once] :: m_adKuQ
          [LclId] =
              [ds_sdN7Q] \u []
                  case ds_sdN7Q of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b_sdN7Z [Occ=Once] -> b_sdN7Z;
                  }; } in
        let {
          sat_sdN7V [Occ=Once] :: m_adKuQ
          [LclId] =
              [ds_sdN7Q] \u []
                  case ds_sdN7Q of {
                    (,,) _ [Occ=Dead] a_sdN7T [Occ=Once] _ [Occ=Dead] -> a_sdN7T;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN7P sat_sdN7V sat_sdN80;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldr
  :: forall x a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> (x, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN81 g_sdN82 z_sdN83 t_sdN84]
        let {
          sat_sdN8f [Occ=Once] :: c_adKvc
          [LclId] =
              [g_sdN82 z_sdN83 t_sdN84] \u []
                  let {
                    sat_sdN8e [Occ=Once] :: b_adKvd
                    [LclId] =
                        [t_sdN84] \u []
                            case t_sdN84 of {
                              (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdN8d [Occ=Once] -> b1_sdN8d;
                            };
                  } in  g_sdN82 sat_sdN8e z_sdN83; } in
        let {
          sat_sdN89 [Occ=Once] :: a_adKvb
          [LclId] =
              [t_sdN84] \u []
                  case t_sdN84 of {
                    (,,) _ [Occ=Dead] a1_sdN87 [Occ=Once] _ [Occ=Dead] -> a1_sdN87;
                  };
        } in  f_sdN81 sat_sdN89 sat_sdN8f;

Data.Bifoldable.$fBifoldable(,,)_$cbifoldl
  :: forall x c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> (x, a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(A,1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN8g g_sdN8h z_sdN8i t_sdN8j]
        let {
          sat_sdN8u [Occ=Once] :: b_adKvp
          [LclId] =
              [t_sdN8j] \u []
                  case t_sdN8j of {
                    (,,) _ [Occ=Dead] _ [Occ=Dead] b1_sdN8t [Occ=Once] -> b1_sdN8t;
                  }; } in
        let {
          sat_sdN8p [Occ=Once] :: c_adKvn
          [LclId] =
              [f_sdN8g z_sdN8i t_sdN8j] \u []
                  let {
                    sat_sdN8o [Occ=Once] :: a_adKvo
                    [LclId] =
                        [t_sdN8j] \u []
                            case t_sdN8j of {
                              (,,) _ [Occ=Dead] a1_sdN8m [Occ=Once] _ [Occ=Dead] -> a1_sdN8m;
                            };
                  } in  f_sdN8g z_sdN8i sat_sdN8o;
        } in  g_sdN8h sat_sdN8p sat_sdN8u;

Data.Bifoldable.$fBifoldable(,,) [InlPrag=NOUSERINLINE CONLIKE]
  :: forall x. Data.Bifoldable.Bifoldable ((,,) x)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,,)_$cbifoldl];

Data.Bifoldable.$fBifoldableK2
  :: forall i m.
     GHC.Base.Monoid m =>
     GHC.Generics.K1 i m m -> GHC.Generics.K1 i m m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN8v ds_sdN8w] ds_sdN8w;

Data.Bifoldable.$fBifoldableK1_$cbifoldr
  :: forall i a c b.
     (a -> c -> c) -> (b -> c -> c) -> c -> GHC.Generics.K1 i a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdN8x g_sdN8y z_sdN8z t_sdN8A] f_sdN8x t_sdN8A z_sdN8z;

Data.Bifoldable.$fBifoldableK1_$cbifoldl
  :: forall i c a b.
     (c -> a -> c) -> (c -> b -> c) -> c -> GHC.Generics.K1 i a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdN8B g_sdN8C z_sdN8D t_sdN8E] f_sdN8B z_sdN8D t_sdN8E;

Data.Bifoldable.$fBifoldableK1 [InlPrag=NOUSERINLINE CONLIKE]
  :: forall i. Data.Bifoldable.Bifoldable (GHC.Generics.K1 i)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableK2
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableK1_$cbifoldl];

Data.Bifoldable.$fBifoldableConst1
  :: forall m.
     GHC.Base.Monoid m =>
     Data.Functor.Const.Const m m -> Data.Functor.Const.Const m m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN8F ds_sdN8G] ds_sdN8G;

Data.Bifoldable.$fBifoldableConst_$cbifoldr
  :: forall a c b.
     (a -> c -> c)
     -> (b -> c -> c) -> c -> Data.Functor.Const.Const a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdN8H g_sdN8I z_sdN8J t_sdN8K] f_sdN8H t_sdN8K z_sdN8J;

Data.Bifoldable.$fBifoldableConst_$cbifoldl
  :: forall c a b.
     (c -> a -> c)
     -> (c -> b -> c) -> c -> Data.Functor.Const.Const a b -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,A><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sdN8L g_sdN8M z_sdN8N t_sdN8O] f_sdN8L z_sdN8N t_sdN8O;

Data.Bifoldable.$fBifoldableConst [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable Data.Functor.Const.Const
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldableConst1
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldr
                                                 Data.Bifoldable.$fBifoldableConst_$cbifoldl];

Data.Bifoldable.$fBifoldable(,)_$cbifold
  :: forall m. GHC.Base.Monoid m => (m, m) -> m
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))L),1*U(A,A,1*C1(C1(U)),A)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_sdN8P ds_sdN8Q]
        let {
          sat_sdN8Y [Occ=Once] :: m_adKx4
          [LclId] =
              [ds_sdN8Q] \u []
                  case ds_sdN8Q of {
                    (,) _ [Occ=Dead] b_sdN8X [Occ=Once] -> b_sdN8X;
                  }; } in
        let {
          sat_sdN8U [Occ=Once] :: m_adKx4
          [LclId] =
              [ds_sdN8Q] \u []
                  case ds_sdN8Q of {
                    (,) a_sdN8S [Occ=Once] _ [Occ=Dead] -> a_sdN8S;
                  };
        } in  GHC.Base.mappend $dMonoid_sdN8P sat_sdN8U sat_sdN8Y;

Data.Bifoldable.$fBifoldable(,)_$cbifoldr
  :: forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> (a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN8Z g_sdN90 z_sdN91 t_sdN92]
        let {
          sat_sdN9b [Occ=Once] :: c_adKxq
          [LclId] =
              [g_sdN90 z_sdN91 t_sdN92] \u []
                  let {
                    sat_sdN9a [Occ=Once] :: b_adKxr
                    [LclId] =
                        [t_sdN92] \u []
                            case t_sdN92 of {
                              (,) _ [Occ=Dead] b1_sdN99 [Occ=Once] -> b1_sdN99;
                            };
                  } in  g_sdN90 sat_sdN9a z_sdN91; } in
        let {
          sat_sdN96 [Occ=Once] :: a_adKxp
          [LclId] =
              [t_sdN92] \u []
                  case t_sdN92 of {
                    (,) a1_sdN94 [Occ=Once] _ [Occ=Dead] -> a1_sdN94;
                  };
        } in  f_sdN8Z sat_sdN96 sat_sdN9b;

Data.Bifoldable.$fBifoldable(,)_$cbifoldl
  :: forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> (a, b) -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [f_sdN9c g_sdN9d z_sdN9e t_sdN9f]
        let {
          sat_sdN9o [Occ=Once] :: b_adKxD
          [LclId] =
              [t_sdN9f] \u []
                  case t_sdN9f of {
                    (,) _ [Occ=Dead] b1_sdN9n [Occ=Once] -> b1_sdN9n;
                  }; } in
        let {
          sat_sdN9k [Occ=Once] :: c_adKxB
          [LclId] =
              [f_sdN9c z_sdN9e t_sdN9f] \u []
                  let {
                    sat_sdN9j [Occ=Once] :: a_adKxC
                    [LclId] =
                        [t_sdN9f] \u []
                            case t_sdN9f of {
                              (,) a1_sdN9h [Occ=Once] _ [Occ=Dead] -> a1_sdN9h;
                            };
                  } in  f_sdN9c z_sdN9e sat_sdN9j;
        } in  g_sdN9d sat_sdN9k sat_sdN9o;

Data.Bifoldable.$fBifoldable(,) [InlPrag=NOUSERINLINE CONLIKE]
  :: Data.Bifoldable.Bifoldable (,)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Data.Bifoldable.C:Bifoldable! [Data.Bifoldable.$fBifoldable(,)_$cbifold
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldMap
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldr
                                                 Data.Bifoldable.$fBifoldable(,)_$cbifoldl];

Data.Bifoldable.bifoldr'
  :: forall (t :: * -> * -> *) a c b.
     Data.Bifoldable.Bifoldable t =>
     (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN9p f_sdN9q g_sdN9r z0_sdN9s xs_sdN9t]
        let {
          sat_sdN9D [Occ=Once]
            :: (c_adKoc -> c_adKoc) -> b_adKod -> c_adKoc -> c_adKoc
          [LclId] =
              [g_sdN9r] \r [k_sdN9z x_sdN9A z_sdN9B]
                  case g_sdN9r x_sdN9A z_sdN9B of vx_sdN9C {
                    __DEFAULT -> k_sdN9z vx_sdN9C;
                  }; } in
        let {
          sat_sdN9y [Occ=Once]
            :: (c_adKoc -> c_adKoc) -> a_adKob -> c_adKoc -> c_adKoc
          [LclId] =
              [f_sdN9q] \r [k_sdN9u x_sdN9v z_sdN9w]
                  case f_sdN9q x_sdN9v z_sdN9w of vx_sdN9x {
                    __DEFAULT -> k_sdN9u vx_sdN9x;
                  };
        } in 
          Data.Bifoldable.bifoldl
              $dBifoldable_sdN9p
              sat_sdN9y
              sat_sdN9D
              GHC.Base.id
              xs_sdN9t
              z0_sdN9s;

lvl_rdL8s :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

lvl1_rdL8t :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_rdL8s;

Data.Bifoldable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl2_rdL8u :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bifoldable.$trModule4;

Data.Bifoldable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Bifoldable"#;

lvl3_rdL8v :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Data.Bifoldable.$trModule2;

lvl4_rdL8w :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Data/Bifoldable.hs"#;

lvl5_rdL8x :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_rdL8w;

lvl6_rdL8y :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [188#];

lvl7_rdL8z :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [28#];

lvl8_rdL8A :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [61#];

lvl9_rdL8B :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl6_rdL8y
                                           lvl7_rdL8z
                                           lvl6_rdL8y
                                           lvl8_rdL8A];

lvl10_rdL8C :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl9_rdL8B
                                                  GHC.Stack.Types.EmptyCallStack];

lvl11_rdL8D :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bifoldr1: empty structure"#;

Data.Bifoldable.bifoldr2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_rdL8D of sat_sdN9E {
          __DEFAULT -> GHC.Err.error lvl10_rdL8C sat_sdN9E;
        };

Data.Bifoldable.bifoldr1
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> a) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN9F f_sdN9G xs_sdN9H]
        let {
          mbf_sdN9I
            :: a_adKmT -> GHC.Base.Maybe a_adKmT -> GHC.Base.Maybe a_adKmT
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [f_sdN9G] \r [x_sdN9J m_sdN9K]
                  let {
                    sat_sdN9N [Occ=Once] :: a_adKmT
                    [LclId] =
                        [f_sdN9G x_sdN9J m_sdN9K] \u []
                            case m_sdN9K of {
                              GHC.Base.Nothing -> x_sdN9J;
                              GHC.Base.Just y_sdN9M [Occ=Once] -> f_sdN9G x_sdN9J y_sdN9M;
                            };
                  } in  GHC.Base.Just [sat_sdN9N];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdN9F mbf_sdN9I mbf_sdN9I GHC.Base.Nothing xs_sdN9H
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdN9P [Occ=Once] -> v_sdN9P;
          };

Data.Bifoldable.bimaximumBy
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdN9Q cmp_sdN9R xs_sdN9S]
        let {
          mbf_sdN9T
            :: a_adKnp -> GHC.Base.Maybe a_adKnp -> GHC.Base.Maybe a_adKnp
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [cmp_sdN9R] \r [x_sdN9U m_sdN9V]
                  let {
                    sat_sdN9Z [Occ=Once] :: a_adKnp
                    [LclId] =
                        [cmp_sdN9R x_sdN9U m_sdN9V] \u []
                            case m_sdN9V of {
                              GHC.Base.Nothing -> x_sdN9U;
                              GHC.Base.Just y_sdN9X ->
                                  case cmp_sdN9R x_sdN9U y_sdN9X of {
                                    __DEFAULT -> y_sdN9X;
                                    GHC.Types.GT -> x_sdN9U;
                                  };
                            };
                  } in  GHC.Base.Just [sat_sdN9Z];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdN9Q mbf_sdN9T mbf_sdN9T GHC.Base.Nothing xs_sdN9S
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdNa1 [Occ=Once] -> v_sdNa1;
          };

Data.Bifoldable.biminimumBy
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> GHC.Types.Ordering) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNa2 cmp_sdNa3 xs_sdNa4]
        let {
          mbf_sdNa5
            :: a_adKnN -> GHC.Base.Maybe a_adKnN -> GHC.Base.Maybe a_adKnN
          [LclId, Arity=2, Str=<L,U><L,1*U>, Unf=OtherCon []] =
              [cmp_sdNa3] \r [x_sdNa6 m_sdNa7]
                  let {
                    sat_sdNab [Occ=Once] :: a_adKnN
                    [LclId] =
                        [cmp_sdNa3 x_sdNa6 m_sdNa7] \u []
                            case m_sdNa7 of {
                              GHC.Base.Nothing -> x_sdNa6;
                              GHC.Base.Just y_sdNa9 ->
                                  case cmp_sdNa3 x_sdNa6 y_sdNa9 of {
                                    __DEFAULT -> x_sdNa6;
                                    GHC.Types.GT -> y_sdNa9;
                                  };
                            };
                  } in  GHC.Base.Just [sat_sdNab];
        } in 
          case
              Data.Bifoldable.bifoldr
                  $dBifoldable_sdNa2 mbf_sdNa5 mbf_sdNa5 GHC.Base.Nothing xs_sdNa4
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldr2;
            GHC.Base.Just v_sdNad [Occ=Once] -> v_sdNad;
          };

Data.Bifoldable.bifoldrM
  :: forall (t :: * -> * -> *) (m :: * -> *) a c b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Monad m) =>
     (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNae
           $dMonad_sdNaf
           f_sdNag
           g_sdNah
           z0_sdNai
           xs_sdNaj]
        let {
          sat_sdNau [Occ=Once] :: c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdNaf] \u [] GHC.Base.return $dMonad_sdNaf; } in
        let {
          sat_sdNat [Occ=Once]
            :: (c_adKlQ -> m_adKlO c_adKlQ)
               -> b_adKlR -> c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdNaf g_sdNah] \r [k_sdNap x_sdNaq z_sdNar]
                  let {
                    sat_sdNas [Occ=Once] :: m_adKlO c_adKlQ
                    [LclId] =
                        [g_sdNah x_sdNaq z_sdNar] \u [] g_sdNah x_sdNaq z_sdNar;
                  } in  GHC.Base.>>= $dMonad_sdNaf sat_sdNas k_sdNap; } in
        let {
          sat_sdNao [Occ=Once]
            :: (c_adKlQ -> m_adKlO c_adKlQ)
               -> a_adKlP -> c_adKlQ -> m_adKlO c_adKlQ
          [LclId] =
              [$dMonad_sdNaf f_sdNag] \r [k_sdNak x_sdNal z_sdNam]
                  let {
                    sat_sdNan [Occ=Once] :: m_adKlO c_adKlQ
                    [LclId] =
                        [f_sdNag x_sdNal z_sdNam] \u [] f_sdNag x_sdNal z_sdNam;
                  } in  GHC.Base.>>= $dMonad_sdNaf sat_sdNan k_sdNak;
        } in 
          Data.Bifoldable.bifoldl
              $dBifoldable_sdNae sat_sdNao sat_sdNat sat_sdNau xs_sdNaj z0_sdNai;

Data.Bifoldable.bifoldl'
  :: forall (t :: * -> * -> *) a b c.
     Data.Bifoldable.Bifoldable t =>
     (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNav f_sdNaw g_sdNax z0_sdNay xs_sdNaz]
        let {
          sat_sdNaJ [Occ=Once]
            :: c_adKky -> (a_adKkw -> a_adKkw) -> a_adKkw -> a_adKkw
          [LclId] =
              [g_sdNax] \r [x_sdNaF k_sdNaG z_sdNaH]
                  case g_sdNax z_sdNaH x_sdNaF of vx_sdNaI {
                    __DEFAULT -> k_sdNaG vx_sdNaI;
                  }; } in
        let {
          sat_sdNaE [Occ=Once]
            :: b_adKkx -> (a_adKkw -> a_adKkw) -> a_adKkw -> a_adKkw
          [LclId] =
              [f_sdNaw] \r [x_sdNaA k_sdNaB z_sdNaC]
                  case f_sdNaw z_sdNaC x_sdNaA of vx_sdNaD {
                    __DEFAULT -> k_sdNaB vx_sdNaD;
                  };
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdNav
              sat_sdNaE
              sat_sdNaJ
              GHC.Base.id
              xs_sdNaz
              z0_sdNay;

Data.Bifoldable.bilength2
  :: forall a.
     a
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [x_sdNaK k_sdNaL z_sdNaM]
        case z_sdNaM of {
          GHC.Types.I# x1_sdNaO [Occ=Once] ->
              case +# [x1_sdNaO 1#] of sat_sdNaP {
                __DEFAULT ->
                    let {
                      sat_sdNaQ [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sdNaP];
                    } in  k_sdNaL sat_sdNaQ;
              };
        };

Data.Bifoldable.bilength1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Bifoldable.bilength
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     t a b -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNaR eta_sdNaS]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdNaR
            Data.Bifoldable.bilength2
            Data.Bifoldable.bilength2
            GHC.Base.id
            eta_sdNaS
            Data.Bifoldable.bilength1;

lvl12_rdL8E :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [223#];

lvl13_rdL8F :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl12_rdL8E
                                           lvl7_rdL8z
                                           lvl12_rdL8E
                                           lvl8_rdL8A];

lvl14_rdL8G :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl13_rdL8F
                                                  GHC.Stack.Types.EmptyCallStack];

lvl15_rdL8H :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bifoldl1: empty structure"#;

Data.Bifoldable.bifoldl2 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl15_rdL8H of sat_sdNaT {
          __DEFAULT -> GHC.Err.error lvl14_rdL8G sat_sdNaT;
        };

Data.Bifoldable.bifoldl1
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> a -> a) -> t a a -> a
[GblId,
 Arity=3,
 Str=<S(LLLC(C(C(C(S))))),1*U(A,A,A,1*C1(C1(C1(C1(U)))))><L,C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNaU f_sdNaV xs_sdNaW]
        let {
          mbf_sdNaX
            :: GHC.Base.Maybe a_adKk0 -> a_adKk0 -> GHC.Base.Maybe a_adKk0
          [LclId, Arity=2, Str=<L,1*U><L,U>, Unf=OtherCon []] =
              [f_sdNaV] \r [m_sdNaY y_sdNaZ]
                  let {
                    sat_sdNb2 [Occ=Once] :: a_adKk0
                    [LclId] =
                        [f_sdNaV m_sdNaY y_sdNaZ] \u []
                            case m_sdNaY of {
                              GHC.Base.Nothing -> y_sdNaZ;
                              GHC.Base.Just x_sdNb1 [Occ=Once] -> f_sdNaV x_sdNb1 y_sdNaZ;
                            };
                  } in  GHC.Base.Just [sat_sdNb2];
        } in 
          case
              Data.Bifoldable.bifoldl
                  $dBifoldable_sdNaU mbf_sdNaX mbf_sdNaX GHC.Base.Nothing xs_sdNaW
          of
          { GHC.Base.Nothing -> Data.Bifoldable.bifoldl2;
            GHC.Base.Just v_sdNb4 [Occ=Once] -> v_sdNb4;
          };

Data.Bifoldable.bifoldlM
  :: forall (t :: * -> * -> *) (m :: * -> *) a b c.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Monad m) =>
     (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(C(S))))L),1*U(A,A,1*C1(C1(C1(C1(U)))),A)><L,U(A,C(C1(U)),A,1*U,A)><L,C(C1(U))><L,C(C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNb5
           $dMonad_sdNb6
           f_sdNb7
           g_sdNb8
           z0_sdNb9
           xs_sdNba]
        let {
          sat_sdNbl [Occ=Once] :: a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdNb6] \u [] GHC.Base.return $dMonad_sdNb6; } in
        let {
          sat_sdNbk [Occ=Once]
            :: c_adKiY
               -> (a_adKiW -> m_adKiV a_adKiW) -> a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdNb6 g_sdNb8] \r [x_sdNbg k_sdNbh z_sdNbi]
                  let {
                    sat_sdNbj [Occ=Once] :: m_adKiV a_adKiW
                    [LclId] =
                        [g_sdNb8 x_sdNbg z_sdNbi] \u [] g_sdNb8 z_sdNbi x_sdNbg;
                  } in  GHC.Base.>>= $dMonad_sdNb6 sat_sdNbj k_sdNbh; } in
        let {
          sat_sdNbf [Occ=Once]
            :: b_adKiX
               -> (a_adKiW -> m_adKiV a_adKiW) -> a_adKiW -> m_adKiV a_adKiW
          [LclId] =
              [$dMonad_sdNb6 f_sdNb7] \r [x_sdNbb k_sdNbc z_sdNbd]
                  let {
                    sat_sdNbe [Occ=Once] :: m_adKiV a_adKiW
                    [LclId] =
                        [f_sdNb7 x_sdNbb z_sdNbd] \u [] f_sdNb7 z_sdNbd x_sdNbb;
                  } in  GHC.Base.>>= $dMonad_sdNb6 sat_sdNbe k_sdNbc;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdNb5 sat_sdNbf sat_sdNbk sat_sdNbl xs_sdNba z0_sdNb9;

Data.Bifoldable.bitraverse_
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbm $dApplicative_sdNbn f1_sdNbo g_sdNbp]
        let {
          sat_sdNbw [Occ=Once] :: f_adKhx ()
          [LclId] =
              [$dApplicative_sdNbn] \u []
                  GHC.Base.pure $dApplicative_sdNbn GHC.Tuple.(); } in
        let {
          sat_sdNbv [Occ=Once] :: b_adKhA -> f_adKhx () -> f_adKhx ()
          [LclId] =
              [$dApplicative_sdNbn g_sdNbp] \r [x_sdNbt]
                  let {
                    sat_sdNbu [Occ=Once] :: f_adKhx d_adKhB
                    [LclId] =
                        [g_sdNbp x_sdNbt] \u [] g_sdNbp x_sdNbt;
                  } in  GHC.Base.*> $dApplicative_sdNbn sat_sdNbu; } in
        let {
          sat_sdNbs [Occ=Once] :: a_adKhy -> f_adKhx () -> f_adKhx ()
          [LclId] =
              [$dApplicative_sdNbn f1_sdNbo] \r [x_sdNbq]
                  let {
                    sat_sdNbr [Occ=Once] :: f_adKhx c_adKhz
                    [LclId] =
                        [f1_sdNbo x_sdNbq] \u [] f1_sdNbo x_sdNbq;
                  } in  GHC.Base.*> $dApplicative_sdNbn sat_sdNbr;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdNbm sat_sdNbs sat_sdNbv sat_sdNbw;

Data.Bifoldable.bifor_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f ()
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbx
           $dApplicative_sdNby
           t1_sdNbz
           f1_sdNbA
           g_sdNbB]
        Data.Bifoldable.bitraverse_
            $dBifoldable_sdNbx $dApplicative_sdNby f1_sdNbA g_sdNbB t1_sdNbz;

Data.Bifoldable.biforM_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b c d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t a b -> (a -> f c) -> (b -> f d) -> f ()
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,C(U),A,A,C(U),A)><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bifor_ eta_B5 eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bimapM_
  :: forall (t :: * -> * -> *) (f :: * -> *) a c b d.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     (a -> f c) -> (b -> f d) -> t a b -> f ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,C(U),A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bitraverse_ eta_B4 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bisequence_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,U,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbC $dApplicative_sdNbD]
        let {
          sat_sdNbG [Occ=Once] :: f_adKgV ()
          [LclId] =
              [$dApplicative_sdNbD] \u []
                  GHC.Base.pure $dApplicative_sdNbD GHC.Tuple.(); } in
        let {
          sat_sdNbF [Occ=Once] :: f_adKgV b_adKgX -> f_adKgV () -> f_adKgV ()
          [LclId] =
              [$dApplicative_sdNbD] \u [] GHC.Base.*> $dApplicative_sdNbD; } in
        let {
          sat_sdNbE [Occ=Once] :: f_adKgV a_adKgW -> f_adKgV () -> f_adKgV ()
          [LclId] =
              [$dApplicative_sdNbD] \u [] GHC.Base.*> $dApplicative_sdNbD;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdNbC sat_sdNbE sat_sdNbF sat_sdNbG;

Data.Bifoldable.bisequenceA_
  :: forall (t :: * -> * -> *) (f :: * -> *) a b.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Applicative f) =>
     t (f a) (f b) -> f ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*C1(U),A,A,U,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.bisequence_ eta_B2 eta_B1;

Data.Bifoldable.biasum
  :: forall (t :: * -> * -> *) (f :: * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Alternative f) =>
     t (f a) (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,U,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbH $dAlternative_sdNbI]
        let {
          sat_sdNbL [Occ=Once] :: f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdNbI] \u []
                  GHC.Base.empty $dAlternative_sdNbI; } in
        let {
          sat_sdNbK [Occ=Once]
            :: f_adKgo a_adKgp -> f_adKgo a_adKgp -> f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdNbI] \u [] GHC.Base.<|> $dAlternative_sdNbI; } in
        let {
          sat_sdNbJ [Occ=Once]
            :: f_adKgo a_adKgp -> f_adKgo a_adKgp -> f_adKgo a_adKgp
          [LclId] =
              [$dAlternative_sdNbI] \u [] GHC.Base.<|> $dAlternative_sdNbI;
        } in 
          Data.Bifoldable.bifoldr
              $dBifoldable_sdNbH sat_sdNbJ sat_sdNbK sat_sdNbL;

Data.Bifoldable.bimsum
  :: forall (t :: * -> * -> *) (f :: * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Base.Alternative f) =>
     t (f a) (f a) -> f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)><L,U(A,1*U,U,A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.biasum eta_B2 eta_B1;

Data.Bifoldable.biList
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     t a a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbM]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdNbM GHC.Types.: GHC.Types.: GHC.Types.[];

Data.Bifoldable.binull1
  :: forall a. a -> GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><L,A>, Unf=OtherCon []] =
    [] \r [ds_sdNbN ds1_sdNbO] GHC.Types.False [];

Data.Bifoldable.binull
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     t a b -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLC(C(C(S)))L),1*U(A,A,1*C1(C1(C1(U))),A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbP]
        Data.Bifoldable.bifoldr
            $dBifoldable_sdNbP
            Data.Bifoldable.binull1
            Data.Bifoldable.binull1
            GHC.Types.True;

Data.Bifoldable.biconcat
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     t [a] [a] -> [a]
[GblId,
 Arity=1,
 Str=<S(C(S)LLL),1*U(1*C1(U),A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbQ]
        Data.Bifoldable.bifold $dBifoldable_sdNbQ GHC.Base.$fMonoid[];

lvl16_rdL8I :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [334#];

lvl17_rdL8J :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [24#];

lvl18_rdL8K :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [58#];

lvl19_rdL8L :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl16_rdL8I
                                           lvl17_rdL8J
                                           lvl16_rdL8I
                                           lvl18_rdL8K];

lvl20_rdL8M :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl19_rdL8L
                                                  GHC.Stack.Types.EmptyCallStack];

lvl21_rdL8N :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "bimaximum: empty structure"#;

Data.Bifoldable.bimaximum1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl21_rdL8N of sat_sdNbR {
          __DEFAULT -> GHC.Err.error lvl20_rdL8M sat_sdNbR;
        };

Data.Bifoldable.bimaximum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Ord a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNbS $dOrd_sdNbT]
        let {
          g_sdNbU [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKeD a_adKeE a_adKeE -> Data.Functor.Utils.Max a_adKeE
          [LclId] =
              [$dBifoldable_sdNbS $dOrd_sdNbT] \u []
                  let {
                    sat_sdNbV [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Max a_adKeE)
                    [LclId] =
                        [$dOrd_sdNbT] \u [] Data.Functor.Utils.$fMonoidMax $dOrd_sdNbT;
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdNbS sat_sdNbV GHC.Base.Just GHC.Base.Just; } in
        let {
          sat_sdNbZ [Occ=OnceT[0]] :: t_adKeD a_adKeE a_adKeE -> a_adKeE
          [LclId] =
              [g_sdNbU] \r [x_sdNbW]
                  case g_sdNbU x_sdNbW of {
                    GHC.Base.Nothing -> Data.Bifoldable.bimaximum1;
                    GHC.Base.Just v_sdNbY [Occ=Once] -> v_sdNbY;
                  };
        } in  sat_sdNbZ;

lvl22_rdL8O :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [342#];

lvl23_rdL8P :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_rdL8u
                                           lvl3_rdL8v
                                           lvl5_rdL8x
                                           lvl22_rdL8O
                                           lvl17_rdL8J
                                           lvl22_rdL8O
                                           lvl18_rdL8K];

lvl24_rdL8Q :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_rdL8t
                                                  lvl23_rdL8P
                                                  GHC.Stack.Types.EmptyCallStack];

lvl25_rdL8R :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "biminimum: empty structure"#;

Data.Bifoldable.biminimum1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl25_rdL8R of sat_sdNc0 {
          __DEFAULT -> GHC.Err.error lvl24_rdL8Q sat_sdNc0;
        };

Data.Bifoldable.biminimum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Ord a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNc1 $dOrd_sdNc2]
        let {
          g_sdNc3 [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKdQ a_adKdR a_adKdR -> Data.Functor.Utils.Min a_adKdR
          [LclId] =
              [$dBifoldable_sdNc1 $dOrd_sdNc2] \u []
                  let {
                    sat_sdNc4 [Occ=Once]
                      :: GHC.Base.Monoid (Data.Functor.Utils.Min a_adKdR)
                    [LclId] =
                        [$dOrd_sdNc2] \u [] Data.Functor.Utils.$fMonoidMin $dOrd_sdNc2;
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdNc1 sat_sdNc4 GHC.Base.Just GHC.Base.Just; } in
        let {
          sat_sdNc8 [Occ=OnceT[0]] :: t_adKdQ a_adKdR a_adKdR -> a_adKdR
          [LclId] =
              [g_sdNc3] \r [x_sdNc5]
                  case g_sdNc3 x_sdNc5 of {
                    GHC.Base.Nothing -> Data.Bifoldable.biminimum1;
                    GHC.Base.Just v_sdNc7 [Occ=Once] -> v_sdNc7;
                  };
        } in  sat_sdNc8;

Data.Bifoldable.biproduct2 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdNc9] v_sdNc9;

Data.Bifoldable.bisum1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNca $dNum_sdNcb]
        let {
          sat_sdNcc [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Sum a_adKdy)
          [LclId] =
              [$dNum_sdNcb] \u []
                  Data.Semigroup.Internal.$fMonoidSum $dNum_sdNcb;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdNca
              sat_sdNcc
              Data.Bifoldable.biproduct2
              Data.Bifoldable.biproduct2;

Data.Bifoldable.bisum
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(U,A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.bisum1 eta_B2 eta_B1;

Data.Bifoldable.biproduct1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcd $dNum_sdNce]
        let {
          sat_sdNcf [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Product a_adKdf)
          [LclId] =
              [$dNum_sdNce] \u []
                  Data.Semigroup.Internal.$fMonoidProduct $dNum_sdNce;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdNcd
              sat_sdNcf
              Data.Bifoldable.biproduct2
              Data.Bifoldable.biproduct2;

Data.Bifoldable.biproduct
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Num.Num a) =>
     t a a -> a
[GblId,
 Arity=2,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(A,A,U,A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.Bifoldable.biproduct1 eta_B2 eta_B1;

Data.Bifoldable.biconcatMap
  :: forall (t :: * -> * -> *) a c b.
     Data.Bifoldable.Bifoldable t =>
     (a -> [c]) -> (b -> [c]) -> t a b -> [c]
[GblId,
 Arity=1,
 Str=<S(LC(S)LL),1*U(A,1*C1(U),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcg]
        Data.Bifoldable.bifoldMap $dBifoldable_sdNcg GHC.Base.$fMonoid[];

Data.Bifoldable.biand2 :: GHC.Types.Bool -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_sdNch] v_sdNch;

Data.Bifoldable.biand1
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNci]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdNci
            Data.Semigroup.Internal.$fMonoidAll
            Data.Bifoldable.biand2
            Data.Bifoldable.biand2;

Data.Bifoldable.biand
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Bifoldable.biand1 eta_B1;

Data.Bifoldable.bior1
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcj]
        Data.Bifoldable.bifoldMap
            $dBifoldable_sdNcj
            Data.Semigroup.Internal.$fMonoidAny
            Data.Bifoldable.biand2
            Data.Bifoldable.biand2;

Data.Bifoldable.bior
  :: forall (t :: * -> * -> *).
     Data.Bifoldable.Bifoldable t =>
     t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Bifoldable.bior1 eta_B1;

Data.Bifoldable.biany1
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNck p_sdNcl q_sdNcm]
        let {
          sat_sdNcq [Occ=Once] :: b_adKcd -> Data.Semigroup.Internal.Any
          [LclId] =
              [q_sdNcm] \r [x_sdNcp] q_sdNcm x_sdNcp; } in
        let {
          sat_sdNco [Occ=Once] :: a_adKcc -> Data.Semigroup.Internal.Any
          [LclId] =
              [p_sdNcl] \r [x_sdNcn] p_sdNcl x_sdNcn;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdNck
              Data.Semigroup.Internal.$fMonoidAny
              sat_sdNco
              sat_sdNcq;

Data.Bifoldable.biany
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.biany1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bielem1
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcr $dEq_sdNcs x_sdNct]
        let {
          sat_sdNcx [Occ=Once] :: a_adKfA -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_sdNcs x_sdNct] \r [x1_sdNcw]
                  GHC.Classes.== $dEq_sdNcs x1_sdNcw x_sdNct; } in
        let {
          sat_sdNcv [Occ=Once] :: a_adKfA -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dEq_sdNcs x_sdNct] \r [x1_sdNcu]
                  GHC.Classes.== $dEq_sdNcs x1_sdNcu x_sdNct;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdNcr
              Data.Semigroup.Internal.$fMonoidAny
              sat_sdNcv
              sat_sdNcx;

Data.Bifoldable.bielem
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.bielem1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.binotElem
  :: forall (t :: * -> * -> *) a.
     (Data.Bifoldable.Bifoldable t, GHC.Classes.Eq a) =>
     a -> t a a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<L,1*U(A,1*C1(C1(C1(U))),A,A)><L,U(C(C1(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcy $dEq_sdNcz x_sdNcA]
        let {
          g_sdNcB [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKfN a_adKfO a_adKfO -> Data.Semigroup.Internal.Any
          [LclId] =
              [$dBifoldable_sdNcy $dEq_sdNcz x_sdNcA] \u []
                  Data.Bifoldable.bielem1 $dBifoldable_sdNcy $dEq_sdNcz x_sdNcA; } in
        let {
          sat_sdNcE [Occ=OnceT[0]]
            :: t_adKfN a_adKfO a_adKfO -> GHC.Types.Bool
          [LclId] =
              [g_sdNcB] \r [x1_sdNcC]
                  case g_sdNcB x1_sdNcC of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  sat_sdNcE;

Data.Bifoldable.biall1
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcF p_sdNcG q_sdNcH]
        let {
          sat_sdNcL [Occ=Once] :: b_adKbP -> Data.Semigroup.Internal.All
          [LclId] =
              [q_sdNcH] \r [x_sdNcK] q_sdNcH x_sdNcK; } in
        let {
          sat_sdNcJ [Occ=Once] :: a_adKbO -> Data.Semigroup.Internal.All
          [LclId] =
              [p_sdNcG] \r [x_sdNcI] p_sdNcG x_sdNcI;
        } in 
          Data.Bifoldable.bifoldMap
              $dBifoldable_sdNcF
              Data.Semigroup.Internal.$fMonoidAll
              sat_sdNcJ
              sat_sdNcL;

Data.Bifoldable.biall
  :: forall (t :: * -> * -> *) a b.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool)
     -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
[GblId,
 Arity=3,
 Str=<S(LC(C(C(S)))LL),1*U(A,1*C1(C1(C1(U))),A,A)><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.biall1 eta_B3 eta_B2 eta_B1;

Data.Bifoldable.bifind
  :: forall (t :: * -> * -> *) a.
     Data.Bifoldable.Bifoldable t =>
     (a -> GHC.Types.Bool) -> t a a -> GHC.Base.Maybe a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(C1(C1(C(U)))),A,A)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dBifoldable_sdNcM p_sdNcN]
        let {
          g_sdNcO [Occ=OnceL!, Dmd=<L,C(U)>]
            :: t_adKbl a_adKbm a_adKbm -> Data.Monoid.First a_adKbm
          [LclId] =
              [$dBifoldable_sdNcM p_sdNcN] \u []
                  let {
                    finder_sdNcP :: a_adKbm -> GHC.Base.Maybe a_adKbm
                    [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                        [p_sdNcN] \r [x_sdNcQ]
                            case p_sdNcN x_sdNcQ of {
                              GHC.Types.False -> GHC.Base.Nothing [];
                              GHC.Types.True -> GHC.Base.Just [x_sdNcQ];
                            };
                  } in 
                    Data.Bifoldable.bifoldMap
                        $dBifoldable_sdNcM
                        Data.Monoid.$fMonoidFirst
                        finder_sdNcP
                        finder_sdNcP; } in
        let {
          sat_sdNcT [Occ=Once]
            :: t_adKbl a_adKbm a_adKbm -> Data.Monoid.First a_adKbm
          [LclId] =
              [g_sdNcO] \r [x_sdNcS] g_sdNcO x_sdNcS;
        } in  sat_sdNcT;

Data.Bifoldable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$trModule4];

Data.Bifoldable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$trModule2];

Data.Bifoldable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Bifoldable.$trModule3
                                     Data.Bifoldable.$trModule1];

$krep_rdL8S :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Data.Bifoldable.$tcBifoldable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$*->*->*
                                         $krep_rdL8S];

Data.Bifoldable.$tcBifoldable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Bifoldable"#;

Data.Bifoldable.$tcBifoldable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Bifoldable.$tcBifoldable3];

Data.Bifoldable.$tcBifoldable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [13881323671910883383##
                                    7079945659398195047##
                                    Data.Bifoldable.$trModule
                                    Data.Bifoldable.$tcBifoldable2
                                    0#
                                    Data.Bifoldable.$tcBifoldable1];

Data.Bifoldable.C:Bifoldable
  :: forall (p :: * -> * -> *).
     (forall m. GHC.Base.Monoid m => p m m -> m)
     -> (forall m a b.
         GHC.Base.Monoid m =>
         (a -> m) -> (b -> m) -> p a b -> m)
     -> (forall a c b.
         (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c)
     -> (forall c a b.
         (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c)
     -> Data.Bifoldable.Bifoldable p
[GblId[DataCon],
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B4 eta_B3 eta_B2 eta_B1]
        Data.Bifoldable.C:Bifoldable [eta_B4 eta_B3 eta_B2 eta_B1];

