
==================== Output Cmm ====================
2018-03-16 16:01:43.104614434 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:01:43.10613295 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat1_closure" {
     Data.Semigroup.Internal.$w$csconcat1_closure:
         const Data.Semigroup.Internal.$w$csconcat1_info;
 },
 go_s6v1E_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vhc,
                       label: go_s6v1E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vhc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vhd; else goto c6vhe;
       c6vhd: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vhe: // global
           I64[Sp - 32] = block_c6vh5_info;
           _s6v1E::P64 = R1;
           _s6v1B::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6v1B::P64;
           P64[Sp - 16] = _s6v1E::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6vho; else goto c6vh6;
       u6vho: // global
           call _c6vh5(R1) args: 0, res: 0, upd: 0;
       c6vh6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vh5() //  [R1]
         { info_tbl: [(c6vh5,
                       label: block_c6vh5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vh5: // global
           if (R1 & 7 == 1) goto c6vh9; else goto c6vha;
       c6vh9: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6vha: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6vhm; else goto c6vhl;
       c6vhm: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vhl: // global
           _s6v1I::P64 = P64[R1 + 6];
           _s6v1J::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6v1I::P64;
           P64[Hp] = _s6v1J::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6vhp,
                       label: Data.Semigroup.Internal.$w$csconcat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vhp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vht; else goto c6vhs;
       c6vht: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vhs: // global
           I64[Hp - 8] = go_s6v1E_info;
           P64[Hp] = R2;
           _s6v1C::P64 = R3;
           R3 = R4;
           R2 = _s6v1C::P64;
           R1 = Hp - 6;
           call go_s6v1E_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.108022764 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupDual_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupDual_$csconcat_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c6vhB,
                       label: Data.Semigroup.Internal.$fSemigroupDual_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vhB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vhC; else goto c6vhD;
       c6vhC: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vhD: // global
           I64[Sp - 16] = block_c6vhy_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6vhH; else goto c6vhz;
       u6vhH: // global
           call _c6vhy(R1) args: 0, res: 0, upd: 0;
       c6vhz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vhy() //  [R1]
         { info_tbl: [(c6vhy,
                       label: block_c6vhy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vhy: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.109685034 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupDual_closure" {
     Data.Semigroup.Internal.$fSemigroupDual_closure:
         const Data.Semigroup.Internal.$fSemigroupDual_info;
 },
 sat_s6v1Y_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6vhR,
                       label: sat_s6v1Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vhR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vhS; else goto c6vhT;
       c6vhS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vhT: // global
           _s6v1V::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s6v1V::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Base.stimes_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6v1U_entry() //  [R1, R2]
         { info_tbl: [(c6vhZ,
                       label: sat_s6v1U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vhZ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupDual_$csconcat_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v1T_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vi7,
                       label: sat_s6v1T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vi7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6vi8; else goto c6vi9;
       c6vi8: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vi9: // global
           _s6v1R::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = _s6v1R::P64;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fSemigroupDual_entry() //  [R2]
         { info_tbl: [(c6vib,
                       label: Data.Semigroup.Internal.$fSemigroupDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vib: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6vif; else goto c6vie;
       c6vif: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vie: // global
           I64[Hp - 72] = sat_s6v1Y_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v1U_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v1T_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 69;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.111570043 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_info;
 },
 sat_s6v20_entry() //  [R1]
         { info_tbl: [(c6vio,
                       label: sat_s6v20_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vio: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vip; else goto c6viq;
       c6vip: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6viq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(c6vir,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vir: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6viv; else goto c6viu;
       c6viv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6viu: // global
           I64[Hp - 16] = sat_s6v20_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fSemigroupDual_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.112800371 UTC

[section ""data" . $cmappend_r6v15_closure" {
     $cmappend_r6v15_closure:
         const $cmappend_r6v15_info;
 },
 $cmappend_r6v15_entry() //  [R2, R3, R4]
         { info_tbl: [(c6viC,
                       label: $cmappend_r6v15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6viC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6viD; else goto c6viE;
       c6viD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cmappend_r6v15_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6viE: // global
           I64[Sp - 24] = block_c6viA_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6viA() //  [R1]
         { info_tbl: [(c6viA,
                       label: block_c6viA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6viA: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _s6v22::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6v22::P64;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.113998125 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cmappend_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cmappend_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cmappend_info;
 },
 Data.Semigroup.Internal.$fMonoidDual_$cmappend_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c6viM,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cmappend_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6viM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cmappend_r6v15_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.115531308 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cmconcat_info;
 },
 lvl12_s6v27_entry() //  [R1]
         { info_tbl: [(c6viX,
                       label: lvl12_s6v27_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6viX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6viY; else goto c6viZ;
       c6viY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6viZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s6v28_entry() //  [R1]
         { info_tbl: [(c6vj4,
                       label: z_s6v28_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vj4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vj5; else goto c6vj6;
       c6vj5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vj6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s6v29_entry() //  [R1, R2]
         { info_tbl: [(c6vjj,
                       label: go_s6v29_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vjj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vjk; else goto c6vjl;
       c6vjk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vjl: // global
           I64[Sp - 32] = block_c6vjc_info;
           _s6v29::P64 = R1;
           _s6v27::P64 = P64[R1 + 7];
           _s6v28::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6v27::P64;
           P64[Sp - 16] = _s6v28::P64;
           P64[Sp - 8] = _s6v29::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6vjv; else goto c6vjd;
       u6vjv: // global
           call _c6vjc(R1) args: 0, res: 0, upd: 0;
       c6vjd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vjc() //  [R1]
         { info_tbl: [(c6vjc,
                       label: block_c6vjc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vjc: // global
           if (R1 & 7 == 1) goto c6vjg; else goto c6vjh;
       c6vjg: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6vjh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vjt; else goto c6vjs;
       c6vjt: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vjs: // global
           _s6v2c::P64 = P64[R1 + 6];
           _s6v2d::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6v2d::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = _s6v2c::P64;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c6vjw,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vjw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6vjA; else goto c6vjz;
       c6vjA: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vjz: // global
           I64[Hp - 64] = lvl12_s6v27_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = z_s6v28_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6v29_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s6v29_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.118247053 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_closure" {
     Data.Semigroup.Internal.$fMonoidDual_closure:
         const Data.Semigroup.Internal.$fMonoidDual_info;
 },
 sat_s6v2j_entry() //  [R1, R2]
         { info_tbl: [(c6vjK,
                       label: sat_s6v2j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vjK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fMonoidDual_$cmconcat_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2i_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vjS,
                       label: sat_s6v2i_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vjS: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fMonoidDual_$cmappend_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2h_entry() //  [R1]
         { info_tbl: [(c6vjZ,
                       label: sat_s6v2h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vjZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vk0; else goto c6vk1;
       c6vk0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vk1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v2g_entry() //  [R1]
         { info_tbl: [(c6vk6,
                       label: sat_s6v2g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vk6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vk7; else goto c6vk8;
       c6vk7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vk8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_entry() //  [R2]
         { info_tbl: [(c6vka,
                       label: Data.Semigroup.Internal.$fMonoidDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vka: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6vke; else goto c6vkd;
       c6vke: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vkd: // global
           I64[Hp - 112] = sat_s6v2j_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s6v2i_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v2h_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v2g_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 94;
           P64[Hp] = Hp - 111;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.120079543 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual2_closure" {
     Data.Semigroup.Internal.$fFunctorDual2_closure:
         const Data.Semigroup.Internal.$fFunctorDual2_info;
 },
 Data.Semigroup.Internal.$fFunctorDual2_entry() //  [R2]
         { info_tbl: [(c6vkj,
                       label: Data.Semigroup.Internal.$fFunctorDual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vkj: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.120920361 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual1_closure" {
     Data.Semigroup.Internal.$fFunctorDual1_closure:
         const Data.Semigroup.Internal.$fFunctorDual1_info;
 },
 Data.Semigroup.Internal.$fFunctorDual1_entry() //  [R2]
         { info_tbl: [(c6vkq,
                       label: Data.Semigroup.Internal.$fFunctorDual1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vkq: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.121681533 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual_closure" {
     Data.Semigroup.Internal.$fFunctorDual_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.122426664 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual3_closure" {
     Data.Semigroup.Internal.$fApplicativeDual3_closure:
         const Data.Semigroup.Internal.$fApplicativeDual3_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual3_entry() //  [R2]
         { info_tbl: [(c6vkx,
                       label: Data.Semigroup.Internal.$fApplicativeDual3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vkx: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.123284848 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual4_closure" {
     Data.Semigroup.Internal.$fApplicativeDual4_closure:
         const Data.Semigroup.Internal.$fApplicativeDual4_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual4_entry() //  [R2]
         { info_tbl: [(c6vkE,
                       label: Data.Semigroup.Internal.$fApplicativeDual4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vkE: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.12410699 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual2_closure" {
     Data.Semigroup.Internal.$fApplicativeDual2_closure:
         const Data.Semigroup.Internal.$fApplicativeDual2_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual2_entry() //  [R2, R3]
         { info_tbl: [(c6vkL,
                       label: Data.Semigroup.Internal.$fApplicativeDual2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vkL: // global
           _s6v2p::P64 = R2;
           R2 = R3;
           R1 = _s6v2p::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.124985269 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeDual_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual_$c*>_entry() //  [R3]
         { info_tbl: [(c6vkS,
                       label: Data.Semigroup.Internal.$fApplicativeDual_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vkS: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.129462042 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual1_closure" {
     Data.Semigroup.Internal.$fApplicativeDual1_closure:
         const Data.Semigroup.Internal.$fApplicativeDual1_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual1_entry() //  [R2]
         { info_tbl: [(c6vkZ,
                       label: Data.Semigroup.Internal.$fApplicativeDual1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vkZ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.130188449 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual_closure" {
     Data.Semigroup.Internal.$fApplicativeDual_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorDual_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.131284836 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum1_closure" {
     Data.Semigroup.Internal.$fSemigroupSum1_closure:
         const Data.Semigroup.Internal.$fSemigroupSum1_info;
 },
 sat_s6v2z_entry() //  [R1]
         { info_tbl: [(c6vle,
                       label: sat_s6v2z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vle: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vlf; else goto c6vlg;
       c6vlf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vlg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6v2A_entry() //  [R1]
         { info_tbl: [(c6vlh,
                       label: sat_s6v2A_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vlh: // global
           _s6v2A::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c6vli; else goto c6vlj;
       c6vlj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vll; else goto c6vlk;
       c6vll: // global
           HpAlloc = 32;
           goto c6vli;
       c6vli: // global
           R1 = _s6v2A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vlk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v2A::P64;
           _s6v2v::P64 = P64[_s6v2A::P64 + 16];
           _s6v2w::P64 = P64[_s6v2A::P64 + 24];
           _s6v2x::P64 = P64[_s6v2A::P64 + 32];
           I64[Hp - 24] = sat_s6v2z_info;
           P64[Hp - 8] = _s6v2w::P64;
           P64[Hp] = _s6v2x::P64;
           R2 = _s6v2v::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupSum1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c6vlm,
                       label: Data.Semigroup.Internal.$fSemigroupSum1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vlm: // global
           _s6v2y::P64 = R5;
           _s6v2x::P64 = R4;
           _s6v2w::P64 = R3;
           _s6v2v::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c6vln; else goto c6vlo;
       c6vlo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6vlq; else goto c6vlp;
       c6vlq: // global
           HpAlloc = 40;
           goto c6vln;
       c6vln: // global
           R5 = _s6v2y::P64;
           R4 = _s6v2x::P64;
           R3 = _s6v2w::P64;
           R2 = _s6v2v::P64;
           R1 = Data.Semigroup.Internal.$fSemigroupSum1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vlp: // global
           I64[Hp - 32] = sat_s6v2A_info;
           P64[Hp - 16] = _s6v2v::P64;
           P64[Hp - 8] = _s6v2w::P64;
           P64[Hp] = _s6v2x::P64;
           R2 = _s6v2v::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s6v2y::P64;
           Sp = Sp - 24;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.133525841 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat3_closure" {
     Data.Semigroup.Internal.$w$csconcat3_closure:
         const Data.Semigroup.Internal.$w$csconcat3_info;
 },
 go_s6v2E_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vlH,
                       label: go_s6v2E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vlH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vlI; else goto c6vlJ;
       c6vlI: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vlJ: // global
           I64[Sp - 32] = block_c6vlA_info;
           _s6v2E::P64 = R1;
           _s6v2B::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6v2B::P64;
           P64[Sp - 16] = _s6v2E::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6vlT; else goto c6vlB;
       u6vlT: // global
           call _c6vlA(R1) args: 0, res: 0, upd: 0;
       c6vlB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vlA() //  [R1]
         { info_tbl: [(c6vlA,
                       label: block_c6vlA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vlA: // global
           _s6v2F::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6vlE; else goto c6vlF;
       c6vlE: // global
           R1 = _s6v2F::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6vlF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6vlR; else goto c6vlQ;
       c6vlR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vlQ: // global
           _s6v2I::P64 = P64[R1 + 6];
           _s6v2J::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6v2I::P64;
           P64[Hp] = _s6v2J::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v2F::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat3_entry() //  [R2, R3, R4]
         { info_tbl: [(c6vlU,
                       label: Data.Semigroup.Internal.$w$csconcat3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vlU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vlY; else goto c6vlX;
       c6vlY: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vlX: // global
           I64[Hp - 8] = go_s6v2E_info;
           P64[Hp] = R2;
           _s6v2C::P64 = R3;
           R3 = R4;
           R2 = _s6v2C::P64;
           R1 = Hp - 6;
           call go_s6v2E_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.135400281 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupSum_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupSum_$csconcat_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c6vm6,
                       label: Data.Semigroup.Internal.$fSemigroupSum_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vm6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vm7; else goto c6vm8;
       c6vm7: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vm8: // global
           I64[Sp - 16] = block_c6vm3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6vmc; else goto c6vm4;
       u6vmc: // global
           call _c6vm3(R1) args: 0, res: 0, upd: 0;
       c6vm4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vm3() //  [R1]
         { info_tbl: [(c6vm3,
                       label: block_c6vm3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vm3: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat3_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.136992914 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum_closure" {
     Data.Semigroup.Internal.$fSemigroupSum_closure:
         const Data.Semigroup.Internal.$fSemigroupSum_info;
 },
 sat_s6v2T_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6vmm,
                       label: sat_s6v2T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vmm: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Semigroup.Internal.$fSemigroupSum1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2S_entry() //  [R1, R2]
         { info_tbl: [(c6vmu,
                       label: sat_s6v2S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vmu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupSum_$csconcat_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2R_entry() //  [R1]
         { info_tbl: [(c6vmB,
                       label: sat_s6v2R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vmB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vmC; else goto c6vmD;
       c6vmC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vmD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupSum_entry() //  [R2]
         { info_tbl: [(c6vmF,
                       label: Data.Semigroup.Internal.$fSemigroupSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vmF: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6vmJ; else goto c6vmI;
       c6vmJ: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vmI: // global
           I64[Hp - 80] = sat_s6v2T_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v2S_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6v2R_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 77;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.138933418 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum1_closure" {
     Data.Semigroup.Internal.$fMonoidSum1_closure:
         const Data.Semigroup.Internal.$fMonoidSum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidSum1_entry() //  [R1]
         { info_tbl: [(c6vmQ,
                       label: Data.Semigroup.Internal.$fMonoidSum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vmQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vmR; else goto c6vmS;
       c6vmR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vmS: // global
           (_c6vmN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6vmN::I64 == 0) goto c6vmP; else goto c6vmO;
       c6vmP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6vmO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6vmN::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.139992749 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum2_closure" {
     Data.Semigroup.Internal.$fMonoidSum2_closure:
         const Data.Semigroup.Internal.$fMonoidSum2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidSum2_entry() //  [R2]
         { info_tbl: [(c6vmX,
                       label: Data.Semigroup.Internal.$fMonoidSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vmX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vmY; else goto c6vmZ;
       c6vmY: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vmZ: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.141544129 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidSum_$cmconcat_info;
         const 0;
 },
 z_s6v2W_entry() //  [R1]
         { info_tbl: [(c6vn9,
                       label: z_s6v2W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vn9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vna; else goto c6vnb;
       c6vna: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vnb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s6v2X_entry() //  [R1, R2]
         { info_tbl: [(c6vno,
                       label: go_s6v2X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vno: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vnp; else goto c6vnq;
       c6vnp: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vnq: // global
           I64[Sp - 32] = block_c6vnh_info;
           _s6v2X::P64 = R1;
           _s6v2V::P64 = P64[R1 + 7];
           _s6v2W::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6v2V::P64;
           P64[Sp - 16] = _s6v2W::P64;
           P64[Sp - 8] = _s6v2X::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6vnA; else goto c6vni;
       u6vnA: // global
           call _c6vnh(R1) args: 0, res: 0, upd: 0;
       c6vni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vnh() //  [R1]
         { info_tbl: [(c6vnh,
                       label: block_c6vnh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vnh: // global
           if (R1 & 7 == 1) goto c6vnl; else goto c6vnm;
       c6vnl: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6vnm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vny; else goto c6vnx;
       c6vny: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vnx: // global
           _s6v30::P64 = P64[R1 + 6];
           _s6v31::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6v31::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v30::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidSum_$cmconcat_entry() //  [R2]
         { info_tbl: [(c6vnB,
                       label: Data.Semigroup.Internal.$fMonoidSum_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vnB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6vnF; else goto c6vnE;
       c6vnF: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vnE: // global
           I64[Hp - 40] = z_s6v2W_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6v2X_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.143941443 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum_closure" {
     Data.Semigroup.Internal.$fMonoidSum_closure:
         const Data.Semigroup.Internal.$fMonoidSum_info;
         const 0;
 },
 sat_s6v37_entry() //  [R1]
         { info_tbl: [(c6vnO,
                       label: sat_s6v37_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vnO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vnP; else goto c6vnQ;
       c6vnP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vnQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_$cmconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v36_entry() //  [R1]
         { info_tbl: [(c6vnV,
                       label: sat_s6v36_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vnV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vnW; else goto c6vnX;
       c6vnW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vnX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v35_entry() //  [R1]
         { info_tbl: [(c6vo2,
                       label: sat_s6v35_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vo2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vo3; else goto c6vo4;
       c6vo3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vo4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v34_entry() //  [R1]
         { info_tbl: [(c6vo9,
                       label: sat_s6v34_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vo9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6voa; else goto c6vob;
       c6voa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vob: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidSum_entry() //  [R2]
         { info_tbl: [(c6vod,
                       label: Data.Semigroup.Internal.$fMonoidSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vod: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6voh; else goto c6vog;
       c6voh: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vog: // global
           I64[Hp - 128] = sat_s6v37_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v36_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v35_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v34_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.145825896 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorSum_closure" {
     Data.Semigroup.Internal.$fFunctorSum_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.146486013 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum3_closure" {
     Data.Semigroup.Internal.$fApplicativeSum3_closure:
         const Data.Semigroup.Internal.$fApplicativeSum3_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum3_entry() //  [R2]
         { info_tbl: [(c6vom,
                       label: Data.Semigroup.Internal.$fApplicativeSum3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vom: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.147332288 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum2_closure" {
     Data.Semigroup.Internal.$fApplicativeSum2_closure:
         const Data.Semigroup.Internal.$fApplicativeSum2_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum2_entry() //  [R2, R3]
         { info_tbl: [(c6vot,
                       label: Data.Semigroup.Internal.$fApplicativeSum2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vot: // global
           _s6v39::P64 = R2;
           R2 = R3;
           R1 = _s6v39::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.148203006 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeSum_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum_$c*>_entry() //  [R3]
         { info_tbl: [(c6voA,
                       label: Data.Semigroup.Internal.$fApplicativeSum_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6voA: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.149071485 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum1_closure" {
     Data.Semigroup.Internal.$fApplicativeSum1_closure:
         const Data.Semigroup.Internal.$fApplicativeSum1_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum1_entry() //  [R2]
         { info_tbl: [(c6voH,
                       label: Data.Semigroup.Internal.$fApplicativeSum1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6voH: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.150066975 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum_closure" {
     Data.Semigroup.Internal.$fApplicativeSum_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorSum_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeSum3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeSum2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeSum1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.151290242 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat2_closure" {
     Data.Semigroup.Internal.$w$csconcat2_closure:
         const Data.Semigroup.Internal.$w$csconcat2_info;
 },
 go_s6v3i_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vp0,
                       label: go_s6v3i_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vp0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vp1; else goto c6vp2;
       c6vp1: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vp2: // global
           I64[Sp - 32] = block_c6voT_info;
           _s6v3i::P64 = R1;
           _s6v3f::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6v3f::P64;
           P64[Sp - 16] = _s6v3i::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6vpc; else goto c6voU;
       u6vpc: // global
           call _c6voT(R1) args: 0, res: 0, upd: 0;
       c6voU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6voT() //  [R1]
         { info_tbl: [(c6voT,
                       label: block_c6voT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6voT: // global
           _s6v3j::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6voX; else goto c6voY;
       c6voX: // global
           R1 = _s6v3j::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6voY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6vpa; else goto c6vp9;
       c6vpa: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vp9: // global
           _s6v3m::P64 = P64[R1 + 6];
           _s6v3n::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6v3m::P64;
           P64[Hp] = _s6v3n::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v3j::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat2_entry() //  [R2, R3, R4]
         { info_tbl: [(c6vpd,
                       label: Data.Semigroup.Internal.$w$csconcat2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vpd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vph; else goto c6vpg;
       c6vph: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vpg: // global
           I64[Hp - 8] = go_s6v3i_info;
           P64[Hp] = R2;
           _s6v3g::P64 = R3;
           R3 = R4;
           R2 = _s6v3g::P64;
           R1 = Hp - 6;
           call go_s6v3i_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.153276065 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c6vpp,
                       label: Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vpp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vpq; else goto c6vpr;
       c6vpq: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vpr: // global
           I64[Sp - 16] = block_c6vpm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6vpv; else goto c6vpn;
       u6vpv: // global
           call _c6vpm(R1) args: 0, res: 0, upd: 0;
       c6vpn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vpm() //  [R1]
         { info_tbl: [(c6vpm,
                       label: block_c6vpm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vpm: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat2_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.154916876 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupProduct_closure" {
     Data.Semigroup.Internal.$fSemigroupProduct_closure:
         const Data.Semigroup.Internal.$fSemigroupProduct_info;
         const 0;
 },
 sat_s6v3A_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6vpF,
                       label: sat_s6v3A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vpF: // global
           R5 = R3;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v3w_entry() //  [R1, R2]
         { info_tbl: [(c6vpN,
                       label: sat_s6v3w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vpN: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v3v_entry() //  [R1]
         { info_tbl: [(c6vpU,
                       label: sat_s6v3v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vpU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vpV; else goto c6vpW;
       c6vpV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vpW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupProduct_entry() //  [R2]
         { info_tbl: [(c6vpY,
                       label: Data.Semigroup.Internal.$fSemigroupProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vpY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6vq2; else goto c6vq1;
       c6vq2: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vq1: // global
           I64[Hp - 80] = sat_s6v3A_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v3w_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6v3v_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 77;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.157403484 UTC

[section ""data" . sat_s6v3B_closure" {
     sat_s6v3B_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.157999434 UTC

[section ""data" . sat_s6v3C_closure" {
     sat_s6v3C_closure:
         const :_con_info;
         const sat_s6v3B_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.158771756 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct1_closure" {
     Data.Semigroup.Internal.$fMonoidProduct1_closure:
         const Data.Semigroup.Internal.$fMonoidProduct1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidProduct1_entry() //  [R1]
         { info_tbl: [(c6vq9,
                       label: Data.Semigroup.Internal.$fMonoidProduct1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vq9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vqa; else goto c6vqb;
       c6vqa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vqb: // global
           (_c6vq6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6vq6::I64 == 0) goto c6vq8; else goto c6vq7;
       c6vq8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6vq7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6vq6::I64;
           R3 = sat_s6v3C_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.159834296 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct2_closure" {
     Data.Semigroup.Internal.$fMonoidProduct2_closure:
         const Data.Semigroup.Internal.$fMonoidProduct2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidProduct2_entry() //  [R2]
         { info_tbl: [(c6vqg,
                       label: Data.Semigroup.Internal.$fMonoidProduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vqg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vqh; else goto c6vqi;
       c6vqh: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vqi: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.161629955 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_info;
         const 0;
 },
 z_s6v3F_entry() //  [R1]
         { info_tbl: [(c6vqr,
                       label: z_s6v3F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vqr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vqs; else goto c6vqt;
       c6vqs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vqt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s6v3G_entry() //  [R1, R2]
         { info_tbl: [(c6vqG,
                       label: go_s6v3G_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vqG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vqH; else goto c6vqI;
       c6vqH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vqI: // global
           I64[Sp - 32] = block_c6vqz_info;
           _s6v3G::P64 = R1;
           _s6v3E::P64 = P64[R1 + 7];
           _s6v3F::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6v3E::P64;
           P64[Sp - 16] = _s6v3F::P64;
           P64[Sp - 8] = _s6v3G::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6vqS; else goto c6vqA;
       u6vqS: // global
           call _c6vqz(R1) args: 0, res: 0, upd: 0;
       c6vqA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vqz() //  [R1]
         { info_tbl: [(c6vqz,
                       label: block_c6vqz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vqz: // global
           if (R1 & 7 == 1) goto c6vqD; else goto c6vqE;
       c6vqD: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6vqE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vqQ; else goto c6vqP;
       c6vqQ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vqP: // global
           _s6v3J::P64 = P64[R1 + 6];
           _s6v3K::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6v3K::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v3J::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_entry() //  [R2]
         { info_tbl: [(c6vqT,
                       label: Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vqT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6vqX; else goto c6vqW;
       c6vqX: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vqW: // global
           I64[Hp - 40] = z_s6v3F_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6v3G_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.164060012 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct_closure" {
     Data.Semigroup.Internal.$fMonoidProduct_closure:
         const Data.Semigroup.Internal.$fMonoidProduct_info;
         const 0;
 },
 sat_s6v3Q_entry() //  [R1]
         { info_tbl: [(c6vr6,
                       label: sat_s6v3Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vr6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vr7; else goto c6vr8;
       c6vr7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vr8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3P_entry() //  [R1]
         { info_tbl: [(c6vrd,
                       label: sat_s6v3P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vrd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vre; else goto c6vrf;
       c6vre: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vrf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3O_entry() //  [R1]
         { info_tbl: [(c6vrk,
                       label: sat_s6v3O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vrk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vrl; else goto c6vrm;
       c6vrl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vrm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3N_entry() //  [R1]
         { info_tbl: [(c6vrr,
                       label: sat_s6v3N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vrr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vrs; else goto c6vrt;
       c6vrs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vrt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidProduct_entry() //  [R2]
         { info_tbl: [(c6vrv,
                       label: Data.Semigroup.Internal.$fMonoidProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vrv: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6vrz; else goto c6vry;
       c6vrz: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vry: // global
           I64[Hp - 128] = sat_s6v3Q_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v3P_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v3O_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v3N_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.165864936 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorProduct_closure" {
     Data.Semigroup.Internal.$fFunctorProduct_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.166570218 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct3_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct3_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct3_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct3_entry() //  [R2]
         { info_tbl: [(c6vrE,
                       label: Data.Semigroup.Internal.$fApplicativeProduct3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vrE: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.167421711 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct2_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct2_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct2_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct2_entry() //  [R2, R3]
         { info_tbl: [(c6vrL,
                       label: Data.Semigroup.Internal.$fApplicativeProduct2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vrL: // global
           _s6v3S::P64 = R2;
           R2 = R3;
           R1 = _s6v3S::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.168239152 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct_$c*>_entry() //  [R3]
         { info_tbl: [(c6vrS,
                       label: Data.Semigroup.Internal.$fApplicativeProduct_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vrS: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.169054725 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct1_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct1_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct1_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct1_entry() //  [R2]
         { info_tbl: [(c6vrZ,
                       label: Data.Semigroup.Internal.$fApplicativeProduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vrZ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.169771528 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorProduct_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeProduct3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeProduct2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeProduct1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.170792057 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorAlt_closure" {
     Data.Semigroup.Internal.$fFunctorAlt_closure:
         const Data.Semigroup.Internal.$fFunctorAlt_info;
 },
 sat_s6v40_entry() //  [R1]
         { info_tbl: [(c6vsa,
                       label: sat_s6v40_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vsa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vsb; else goto c6vsc;
       c6vsb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vsc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3Z_entry() //  [R1]
         { info_tbl: [(c6vsh,
                       label: sat_s6v3Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vsh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vsi; else goto c6vsj;
       c6vsi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vsj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fFunctorAlt_entry() //  [R2]
         { info_tbl: [(c6vsl,
                       label: Data.Semigroup.Internal.$fFunctorAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vsl: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6vsp; else goto c6vso;
       c6vsp: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fFunctorAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vso: // global
           I64[Hp - 64] = sat_s6v40_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v3Z_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.172368733 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure" {
     Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure:
         const Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_info;
 },
 sat_s6v42_entry() //  [R1]
         { info_tbl: [(c6vsy,
                       label: sat_s6v42_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vsy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vsz; else goto c6vsA;
       c6vsz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vsA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_entry() //  [R2]
         { info_tbl: [(c6vsB,
                       label: Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vsB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vsF; else goto c6vsE;
       c6vsF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vsE: // global
           I64[Hp - 16] = sat_s6v42_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fFunctorAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.174321334 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeAlt_closure" {
     Data.Semigroup.Internal.$fApplicativeAlt_closure:
         const Data.Semigroup.Internal.$fApplicativeAlt_info;
 },
 sat_s6v49_entry() //  [R1]
         { info_tbl: [(c6vsO,
                       label: sat_s6v49_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vsO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vsP; else goto c6vsQ;
       c6vsP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vsQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v48_entry() //  [R1]
         { info_tbl: [(c6vsV,
                       label: sat_s6v48_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vsV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vsW; else goto c6vsX;
       c6vsW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vsX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v47_entry() //  [R1]
         { info_tbl: [(c6vt2,
                       label: sat_s6v47_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vt2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vt3; else goto c6vt4;
       c6vt3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vt4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v46_entry() //  [R1]
         { info_tbl: [(c6vt9,
                       label: sat_s6v46_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vt9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vta; else goto c6vtb;
       c6vta: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vtb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v45_entry() //  [R1]
         { info_tbl: [(c6vtg,
                       label: sat_s6v45_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vtg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vth; else goto c6vti;
       c6vth: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vti: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v44_entry() //  [R1]
         { info_tbl: [(c6vtn,
                       label: sat_s6v44_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vtn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vto; else goto c6vtp;
       c6vto: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vtp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fApplicativeAlt_entry() //  [R2]
         { info_tbl: [(c6vtr,
                       label: Data.Semigroup.Internal.$fApplicativeAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vtr: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c6vtv; else goto c6vtu;
       c6vtv: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fApplicativeAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vtu: // global
           I64[Hp - 192] = sat_s6v49_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6v48_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s6v47_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6v46_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s6v45_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6v44_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 120;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 168;
           P64[Hp] = Hp - 192;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.176872867 UTC

[section ""data" . Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure" {
     Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure:
         const Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_info;
 },
 sat_s6v4b_entry() //  [R1]
         { info_tbl: [(c6vtE,
                       label: sat_s6v4b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vtE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vtF; else goto c6vtG;
       c6vtF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vtG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(c6vtH,
                       label: Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vtH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vtL; else goto c6vtK;
       c6vtL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vtK: // global
           I64[Hp - 16] = sat_s6v4b_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.178881477 UTC

[section ""data" . Data.Semigroup.Internal.$fAlternativeAlt_closure" {
     Data.Semigroup.Internal.$fAlternativeAlt_closure:
         const Data.Semigroup.Internal.$fAlternativeAlt_info;
 },
 sat_s6v4h_entry() //  [R1]
         { info_tbl: [(c6vtU,
                       label: sat_s6v4h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vtU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vtV; else goto c6vtW;
       c6vtV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vtW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.many_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4g_entry() //  [R1]
         { info_tbl: [(c6vu1,
                       label: sat_s6v4g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vu1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vu2; else goto c6vu3;
       c6vu2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vu3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.some_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4f_entry() //  [R1]
         { info_tbl: [(c6vu8,
                       label: sat_s6v4f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vu8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vu9; else goto c6vua;
       c6vu9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vua: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4e_entry() //  [R1]
         { info_tbl: [(c6vuf,
                       label: sat_s6v4e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vuf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vug; else goto c6vuh;
       c6vug: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vuh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4d_entry() //  [R1]
         { info_tbl: [(c6vum,
                       label: sat_s6v4d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vum: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vun; else goto c6vuo;
       c6vun: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vuo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fAlternativeAlt_entry() //  [R2]
         { info_tbl: [(c6vuq,
                       label: Data.Semigroup.Internal.$fAlternativeAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vuq: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c6vuu; else goto c6vut;
       c6vuu: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fAlternativeAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vut: // global
           I64[Hp - 160] = sat_s6v4h_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4g_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4f_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4e_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v4d_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.181287667 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_info;
 },
 sat_s6v4j_entry() //  [R1]
         { info_tbl: [(c6vuD,
                       label: sat_s6v4j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vuD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vuE; else goto c6vuF;
       c6vuE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vuF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_entry() //  [R2]
         { info_tbl: [(c6vuG,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vuG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vuK; else goto c6vuJ;
       c6vuK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vuJ: // global
           I64[Hp - 16] = sat_s6v4j_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fAlternativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.182695445 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure" {
     Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure:
         const Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_info;
 },
 sat_s6v4l_entry() //  [R1]
         { info_tbl: [(c6vuT,
                       label: sat_s6v4l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vuT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vuU; else goto c6vuV;
       c6vuU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vuV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_entry() //  [R2]
         { info_tbl: [(c6vuW,
                       label: Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vuW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vv0; else goto c6vuZ;
       c6vv0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vuZ: // global
           I64[Hp - 16] = sat_s6v4l_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.184550417 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadAlt_closure" {
     Data.Semigroup.Internal.$fMonadAlt_closure:
         const Data.Semigroup.Internal.$fMonadAlt_info;
 },
 sat_s6v4r_entry() //  [R1]
         { info_tbl: [(c6vv9,
                       label: sat_s6v4r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vv9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vva; else goto c6vvb;
       c6vva: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vvb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fail_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4q_entry() //  [R1]
         { info_tbl: [(c6vvg,
                       label: sat_s6v4q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vvg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vvh; else goto c6vvi;
       c6vvh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vvi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4p_entry() //  [R1]
         { info_tbl: [(c6vvn,
                       label: sat_s6v4p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vvn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vvo; else goto c6vvp;
       c6vvo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vvp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4o_entry() //  [R1]
         { info_tbl: [(c6vvu,
                       label: sat_s6v4o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vvu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vvv; else goto c6vvw;
       c6vvv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vvw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4n_entry() //  [R1]
         { info_tbl: [(c6vvB,
                       label: sat_s6v4n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vvB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vvC; else goto c6vvD;
       c6vvC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vvD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadAlt_entry() //  [R2]
         { info_tbl: [(c6vvF,
                       label: Data.Semigroup.Internal.$fMonadAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vvF: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c6vvJ; else goto c6vvI;
       c6vvJ: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vvI: // global
           I64[Hp - 160] = sat_s6v4r_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4q_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4p_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4o_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v4n_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.187835481 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_info;
 },
 sat_s6v4t_entry() //  [R1]
         { info_tbl: [(c6vvS,
                       label: sat_s6v4t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vvS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vvT; else goto c6vvU;
       c6vvT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vvU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_entry() //  [R2]
         { info_tbl: [(c6vvV,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vvV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vvZ; else goto c6vvY;
       c6vvZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vvY: // global
           I64[Hp - 16] = sat_s6v4t_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.189780659 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_info;
 },
 sat_s6v4y_entry() //  [R1]
         { info_tbl: [(c6vw8,
                       label: sat_s6v4y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vw8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vw9; else goto c6vwa;
       c6vw9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vwa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mplus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4x_entry() //  [R1]
         { info_tbl: [(c6vwf,
                       label: sat_s6v4x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vwf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vwg; else goto c6vwh;
       c6vwg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vwh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4w_entry() //  [R1]
         { info_tbl: [(c6vwm,
                       label: sat_s6v4w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vwm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vwn; else goto c6vwo;
       c6vwn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vwo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4v_entry() //  [R1]
         { info_tbl: [(c6vwt,
                       label: sat_s6v4v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vwt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vwu; else goto c6vwv;
       c6vwu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vwv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_entry() //  [R2]
         { info_tbl: [(c6vwx,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vwx: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6vwB; else goto c6vwA;
       c6vwB: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vwA: // global
           I64[Hp - 128] = sat_s6v4y_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v4x_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v4w_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v4v_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.19256351 UTC

[section ""data" . Data.Semigroup.Internal.$fEnumAlt_closure" {
     Data.Semigroup.Internal.$fEnumAlt_closure:
         const Data.Semigroup.Internal.$fEnumAlt_info;
 },
 sat_s6v4H_entry() //  [R1]
         { info_tbl: [(c6vwK,
                       label: sat_s6v4H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vwK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vwL; else goto c6vwM;
       c6vwL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vwM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4G_entry() //  [R1]
         { info_tbl: [(c6vwR,
                       label: sat_s6v4G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vwR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vwS; else goto c6vwT;
       c6vwS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vwT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4F_entry() //  [R1]
         { info_tbl: [(c6vwY,
                       label: sat_s6v4F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vwY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vwZ; else goto c6vx0;
       c6vwZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vx0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4E_entry() //  [R1]
         { info_tbl: [(c6vx5,
                       label: sat_s6v4E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vx5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vx6; else goto c6vx7;
       c6vx6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vx7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4D_entry() //  [R1]
         { info_tbl: [(c6vxc,
                       label: sat_s6v4D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vxc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vxd; else goto c6vxe;
       c6vxd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vxe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4C_entry() //  [R1]
         { info_tbl: [(c6vxj,
                       label: sat_s6v4C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vxj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vxk; else goto c6vxl;
       c6vxk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vxl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4B_entry() //  [R1]
         { info_tbl: [(c6vxq,
                       label: sat_s6v4B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vxq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vxr; else goto c6vxs;
       c6vxr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vxs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4A_entry() //  [R1]
         { info_tbl: [(c6vxx,
                       label: sat_s6v4A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vxx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vxy; else goto c6vxz;
       c6vxy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vxz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEnumAlt_entry() //  [R2]
         { info_tbl: [(c6vxB,
                       label: Data.Semigroup.Internal.$fEnumAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vxB: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6vxF; else goto c6vxE;
       c6vxF: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEnumAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vxE: // global
           I64[Hp - 256] = sat_s6v4H_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v4G_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v4F_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v4E_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v4D_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4C_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4B_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4A_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.19617635 UTC

[section ""data" . Data.Semigroup.Internal.$fNumAlt_closure" {
     Data.Semigroup.Internal.$fNumAlt_closure:
         const Data.Semigroup.Internal.$fNumAlt_info;
 },
 sat_s6v4P_entry() //  [R1]
         { info_tbl: [(c6vxO,
                       label: sat_s6v4P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vxO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vxP; else goto c6vxQ;
       c6vxP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vxQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4O_entry() //  [R1]
         { info_tbl: [(c6vxV,
                       label: sat_s6v4O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vxV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vxW; else goto c6vxX;
       c6vxW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vxX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4N_entry() //  [R1]
         { info_tbl: [(c6vy2,
                       label: sat_s6v4N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vy2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vy3; else goto c6vy4;
       c6vy3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vy4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4M_entry() //  [R1]
         { info_tbl: [(c6vy9,
                       label: sat_s6v4M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vy9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vya; else goto c6vyb;
       c6vya: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vyb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4L_entry() //  [R1]
         { info_tbl: [(c6vyg,
                       label: sat_s6v4L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vyg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vyh; else goto c6vyi;
       c6vyh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vyi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4K_entry() //  [R1]
         { info_tbl: [(c6vyn,
                       label: sat_s6v4K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vyn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vyo; else goto c6vyp;
       c6vyo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vyp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4J_entry() //  [R1]
         { info_tbl: [(c6vyu,
                       label: sat_s6v4J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vyu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vyv; else goto c6vyw;
       c6vyv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vyw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumAlt_entry() //  [R2]
         { info_tbl: [(c6vyy,
                       label: Data.Semigroup.Internal.$fNumAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vyy: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6vyC; else goto c6vyB;
       c6vyC: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vyB: // global
           I64[Hp - 224] = sat_s6v4P_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6v4O_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6v4N_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6v4M_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6v4L_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v4K_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v4J_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.198997319 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAlt_closure" {
     Data.Semigroup.Internal.$fEqAlt_closure:
         const Data.Semigroup.Internal.$fEqAlt_info;
 },
 sat_s6v4S_entry() //  [R1]
         { info_tbl: [(c6vyL,
                       label: sat_s6v4S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vyL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vyM; else goto c6vyN;
       c6vyM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vyN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4R_entry() //  [R1]
         { info_tbl: [(c6vyS,
                       label: sat_s6v4R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vyS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vyT; else goto c6vyU;
       c6vyT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vyU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqAlt_entry() //  [R2]
         { info_tbl: [(c6vyW,
                       label: Data.Semigroup.Internal.$fEqAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vyW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6vz0; else goto c6vyZ;
       c6vz0: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vyZ: // global
           I64[Hp - 64] = sat_s6v4S_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v4R_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.200549376 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_info;
 },
 sat_s6v4U_entry() //  [R1]
         { info_tbl: [(c6vz9,
                       label: sat_s6v4U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vz9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vza; else goto c6vzb;
       c6vza: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vzb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6vzc,
                       label: Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vzc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vzg; else goto c6vzf;
       c6vzg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vzf: // global
           I64[Hp - 16] = sat_s6v4U_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.202569537 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAlt_closure" {
     Data.Semigroup.Internal.$fOrdAlt_closure:
         const Data.Semigroup.Internal.$fOrdAlt_info;
 },
 sat_s6v53_entry() //  [R1]
         { info_tbl: [(c6vzp,
                       label: sat_s6v53_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vzp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vzq; else goto c6vzr;
       c6vzq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vzr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v52_entry() //  [R1]
         { info_tbl: [(c6vzw,
                       label: sat_s6v52_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vzw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vzx; else goto c6vzy;
       c6vzx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vzy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v51_entry() //  [R1]
         { info_tbl: [(c6vzD,
                       label: sat_s6v51_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vzD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vzE; else goto c6vzF;
       c6vzE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vzF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v50_entry() //  [R1]
         { info_tbl: [(c6vzK,
                       label: sat_s6v50_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vzK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vzL; else goto c6vzM;
       c6vzL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vzM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4Z_entry() //  [R1]
         { info_tbl: [(c6vzR,
                       label: sat_s6v4Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vzR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vzS; else goto c6vzT;
       c6vzS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vzT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4Y_entry() //  [R1]
         { info_tbl: [(c6vzY,
                       label: sat_s6v4Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vzY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vzZ; else goto c6vA0;
       c6vzZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vA0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4X_entry() //  [R1]
         { info_tbl: [(c6vA5,
                       label: sat_s6v4X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vA5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vA6; else goto c6vA7;
       c6vA6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vA7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4W_entry() //  [R1]
         { info_tbl: [(c6vAc,
                       label: sat_s6v4W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vAc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vAd; else goto c6vAe;
       c6vAd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vAe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdAlt_entry() //  [R2]
         { info_tbl: [(c6vAg,
                       label: Data.Semigroup.Internal.$fOrdAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vAg: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6vAk; else goto c6vAj;
       c6vAk: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vAj: // global
           I64[Hp - 256] = sat_s6v53_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v52_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v51_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v50_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v4Z_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4Y_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4X_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4W_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.205457471 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt1_closure" {
     Data.Semigroup.Internal.$fShowAlt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.206022113 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAlt3_bytes" {
     Data.Semigroup.Internal.$fShowAlt3_bytes:
         I8[] [65,108,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.206579999 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAlt2_bytes" {
     Data.Semigroup.Internal.$fShowAlt2_bytes:
         I8[] [103,101,116,65,108,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.207173639 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll5_bytes" {
     Data.Semigroup.Internal.$fReadAll5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.209573501 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec1_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec1_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec1_info;
 },
 f1_s6v57_entry() //  [R1]
         { info_tbl: [(c6vAt,
                       label: f1_s6v57_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vAt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6vAu; else goto c6vAv;
       c6vAu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vAv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6v5a_entry() //  [R1]
         { info_tbl: [(c6vAQ,
                       label: sat_s6v5a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vAQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vAR; else goto c6vAS;
       c6vAR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vAS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5b_entry() //  [R1]
         { info_tbl: [(c6vAT,
                       label: sat_s6v5b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vAT: // global
           _s6v5b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vAU; else goto c6vAV;
       c6vAV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vAX; else goto c6vAW;
       c6vAX: // global
           HpAlloc = 24;
           goto c6vAU;
       c6vAU: // global
           R1 = _s6v5b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vAW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5b::P64;
           _s6v57::P64 = P64[_s6v5b::P64 + 16];
           _s6v59::P64 = P64[_s6v5b::P64 + 24];
           I64[Hp - 16] = sat_s6v5a_info;
           P64[Hp] = _s6v59::P64;
           R2 = Hp - 16;
           R1 = _s6v57::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5c_entry() //  [R1]
         { info_tbl: [(c6vAY,
                       label: sat_s6v5c_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vAY: // global
           _s6v5c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vAZ; else goto c6vB0;
       c6vB0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vB2; else goto c6vB1;
       c6vB2: // global
           HpAlloc = 32;
           goto c6vAZ;
       c6vAZ: // global
           R1 = _s6v5c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vB1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5c::P64;
           _s6v57::P64 = P64[_s6v5c::P64 + 16];
           _s6v59::P64 = P64[_s6v5c::P64 + 24];
           I64[Hp - 24] = sat_s6v5b_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = _s6v59::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5d_entry() //  [R1, R2]
         { info_tbl: [(c6vB3,
                       label: sat_s6v5d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vB3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vB7; else goto c6vB6;
       c6vB7: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vB6: // global
           _s6v57::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v5c_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5g_entry() //  [R1]
         { info_tbl: [(c6vBv,
                       label: sat_s6v5g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vBv: // global
           _s6v5g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vBw; else goto c6vBx;
       c6vBx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vBz; else goto c6vBy;
       c6vBz: // global
           HpAlloc = 24;
           goto c6vBw;
       c6vBw: // global
           R1 = _s6v5g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vBy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5g::P64;
           _s6v5e::P64 = P64[_s6v5g::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v5e::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5h_entry() //  [R1]
         { info_tbl: [(c6vBA,
                       label: sat_s6v5h_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vBA: // global
           _s6v5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vBB; else goto c6vBC;
       c6vBC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vBE; else goto c6vBD;
       c6vBE: // global
           HpAlloc = 24;
           goto c6vBB;
       c6vBB: // global
           R1 = _s6v5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vBD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5h::P64;
           _s6v57::P64 = P64[_s6v5h::P64 + 16];
           _s6v5e::P64 = P64[_s6v5h::P64 + 24];
           I64[Hp - 16] = sat_s6v5g_info;
           P64[Hp] = _s6v5e::P64;
           R2 = Hp - 16;
           R1 = _s6v57::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5i_entry() //  [R1]
         { info_tbl: [(c6vBF,
                       label: sat_s6v5i_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vBF: // global
           _s6v5i::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vBG; else goto c6vBH;
       c6vBH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vBJ; else goto c6vBI;
       c6vBJ: // global
           HpAlloc = 32;
           goto c6vBG;
       c6vBG: // global
           R1 = _s6v5i::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vBI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5i::P64;
           _s6v57::P64 = P64[_s6v5i::P64 + 16];
           _s6v5e::P64 = P64[_s6v5i::P64 + 24];
           I64[Hp - 24] = sat_s6v5h_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = _s6v5e::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5j_entry() //  [R1]
         { info_tbl: [(c6vBK,
                       label: sat_s6v5j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vBK: // global
           _s6v5j::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vBL; else goto c6vBM;
       c6vBM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vBO; else goto c6vBN;
       c6vBO: // global
           HpAlloc = 32;
           goto c6vBL;
       c6vBL: // global
           R1 = _s6v5j::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vBN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5j::P64;
           _s6v57::P64 = P64[_s6v5j::P64 + 16];
           _s6v5e::P64 = P64[_s6v5j::P64 + 24];
           I64[Hp - 24] = sat_s6v5i_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = _s6v5e::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5k_entry() //  [R1, R2]
         { info_tbl: [(c6vBQ,
                       label: sat_s6v5k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vBQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6vBU; else goto c6vBT;
       c6vBU: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vBT: // global
           _s6v57::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6v5j_info;
           P64[Hp - 32] = _s6v57::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6vBY,
                       label: Data.Semigroup.Internal.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vBY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6vC2; else goto c6vC1;
       c6vC2: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vC1: // global
           I64[Hp - 40] = f1_s6v57_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6vAp::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6vBW; else goto c6vBX;
       c6vBW: // global
           I64[Hp - 8] = sat_s6v5d_info;
           P64[Hp] = _c6vAp::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6vBX: // global
           I64[Hp - 8] = sat_s6v5k_info;
           P64[Hp] = _c6vAp::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.215239153 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6vCa,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vCa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6vCb; else goto c6vCc;
       c6vCb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vCc: // global
           I64[Sp - 24] = block_c6vC7_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6vCg; else goto c6vC8;
       u6vCg: // global
           call _c6vC7(R1) args: 0, res: 0, upd: 0;
       c6vC8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vC7() //  [R1]
         { info_tbl: [(c6vC7,
                       label: block_c6vC7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vC7: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.216517645 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll4_closure" {
     Data.Semigroup.Internal.$fReadAll4_closure:
         const Data.Semigroup.Internal.$fReadAll4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll4_entry() //  [R1]
         { info_tbl: [(c6vCn,
                       label: Data.Semigroup.Internal.$fReadAll4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vCn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vCo; else goto c6vCp;
       c6vCo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vCp: // global
           (_c6vCk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6vCk::I64 == 0) goto c6vCm; else goto c6vCl;
       c6vCm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6vCl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6vCk::I64;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.218115297 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshow_info;
         const 0;
 },
 sat_s6v5s_entry() //  [R1]
         { info_tbl: [(c6vCC,
                       label: sat_s6v5s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vCC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6vCD; else goto c6vCE;
       c6vCD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vCE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6v5t_entry() //  [R1]
         { info_tbl: [(c6vCF,
                       label: sat_s6v5t_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vCF: // global
           _s6v5t::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vCG; else goto c6vCH;
       c6vCH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vCJ; else goto c6vCI;
       c6vCJ: // global
           HpAlloc = 32;
           goto c6vCG;
       c6vCG: // global
           R1 = _s6v5t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vCI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5t::P64;
           _s6v5q::P64 = P64[_s6v5t::P64 + 16];
           _s6v5r::P64 = P64[_s6v5t::P64 + 24];
           I64[Hp - 24] = sat_s6v5s_info;
           P64[Hp - 8] = _s6v5q::P64;
           P64[Hp] = _s6v5r::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6vCK,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vCK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vCO; else goto c6vCN;
       c6vCO: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vCN: // global
           I64[Hp - 24] = sat_s6v5t_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.219980543 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshowList_info;
 },
 sat_s6v5y_entry() //  [R1, R2]
         { info_tbl: [(c6vCY,
                       label: sat_s6v5y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vCY: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c6vD1,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vD1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vD5; else goto c6vD4;
       c6vD5: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vD4: // global
           I64[Hp - 8] = sat_s6v5y_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.2215711 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_closure" {
     Data.Semigroup.Internal.$fShowAlt_closure:
         const Data.Semigroup.Internal.$fShowAlt_info;
         const 0;
 },
 sat_s6v5C_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vDf,
                       label: sat_s6v5C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vDf: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowAlt_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5B_entry() //  [R1, R2]
         { info_tbl: [(c6vDn,
                       label: sat_s6v5B_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vDn: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowAlt_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5A_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vDv,
                       label: sat_s6v5A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vDv: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_entry() //  [R2]
         { info_tbl: [(c6vDz,
                       label: Data.Semigroup.Internal.$fShowAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vDz: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6vDD; else goto c6vDC;
       c6vDD: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vDC: // global
           I64[Hp - 72] = sat_s6v5C_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v5B_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v5A_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.222989706 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAlt5_bytes" {
     Data.Semigroup.Internal.$fReadAlt5_bytes:
         I8[] [65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.223777719 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt4_closure" {
     Data.Semigroup.Internal.$fReadAlt4_closure:
         const Data.Semigroup.Internal.$fReadAlt4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAlt4_entry() //  [R1]
         { info_tbl: [(c6vDK,
                       label: Data.Semigroup.Internal.$fReadAlt4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vDK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vDL; else goto c6vDM;
       c6vDL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vDM: // global
           (_c6vDH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6vDH::I64 == 0) goto c6vDJ; else goto c6vDI;
       c6vDJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6vDI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6vDH::I64;
           R2 = Data.Semigroup.Internal.$fReadAlt5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.224677 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAlt_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAlt4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.225233216 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll11_bytes" {
     Data.Semigroup.Internal.$fReadAll11_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.225969861 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll10_closure" {
     Data.Semigroup.Internal.$fReadAll10_closure:
         const Data.Semigroup.Internal.$fReadAll10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll10_entry() //  [R1]
         { info_tbl: [(c6vDT,
                       label: Data.Semigroup.Internal.$fReadAll10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vDT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vDU; else goto c6vDV;
       c6vDU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vDV: // global
           (_c6vDQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6vDQ::I64 == 0) goto c6vDS; else goto c6vDR;
       c6vDS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6vDR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6vDQ::I64;
           R2 = Data.Semigroup.Internal.$fReadAll11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.226920873 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAll_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Semigroup.Internal.$fReadAll10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.22751594 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAlt3_bytes" {
     Data.Semigroup.Internal.$fReadAlt3_bytes:
         I8[] [103,101,116,65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.228240621 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt2_closure" {
     Data.Semigroup.Internal.$fReadAlt2_closure:
         const Data.Semigroup.Internal.$fReadAlt2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAlt2_entry() //  [R1]
         { info_tbl: [(c6vE2,
                       label: Data.Semigroup.Internal.$fReadAlt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vE2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vE3; else goto c6vE4;
       c6vE3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vE4: // global
           (_c6vDZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6vDZ::I64 == 0) goto c6vE1; else goto c6vE0;
       c6vE1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6vE0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6vDZ::I64;
           R2 = Data.Semigroup.Internal.$fReadAlt3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.229175119 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll6_closure" {
     Data.Semigroup.Internal.$fReadAll6_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.230018032 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll3_closure" {
     Data.Semigroup.Internal.$fReadAll3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.232368608 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt1_closure" {
     Data.Semigroup.Internal.$fReadAlt1_closure:
         const Data.Semigroup.Internal.$fReadAlt1_info;
         const 0;
 },
 lvl12_s6v5E_entry() //  [R1]
         { info_tbl: [(c6vEd,
                       label: lvl12_s6v5E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vEd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vEe; else goto c6vEf;
       c6vEe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vEf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6v5F_entry() //  [R1]
         { info_tbl: [(c6vEl,
                       label: ds_s6v5F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vEl: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5Q_entry() //  [R1]
         { info_tbl: [(c6vEW,
                       label: sat_s6v5Q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vEW: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5T_entry() //  [R1, R2]
         { info_tbl: [(c6vF2,
                       label: sat_s6v5T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vF2: // global
           _s6v5O::P64 = R2;
           _s6v5T::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6vF3; else goto c6vF4;
       c6vF4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vF6; else goto c6vF5;
       c6vF6: // global
           HpAlloc = 24;
           goto c6vF3;
       c6vF3: // global
           R2 = _s6v5O::P64;
           R1 = _s6v5T::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vF5: // global
           _s6v5I::P64 = P64[_s6v5T::P64 + 7];
           I64[Hp - 16] = sat_s6v5Q_info;
           P64[Hp - 8] = _s6v5I::P64;
           P64[Hp] = _s6v5O::P64;
           I64[Sp - 8] = block_c6vEZ_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6vEZ() //  [R1]
         { info_tbl: [(c6vEZ,
                       label: block_c6vEZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vEZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vF9; else goto c6vF8;
       c6vF9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vF8: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5U_entry() //  [R1, R2]
         { info_tbl: [(c6vFa,
                       label: sat_s6v5U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vFa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vFe; else goto c6vFd;
       c6vFe: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vFd: // global
           _s6v5F::P64 = P64[R1 + 7];
           _s6v5I::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6v5T_info;
           P64[Hp] = _s6v5I::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6v5F::P64;
           R2 = Data.Semigroup.Internal.$fReadAlt2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5X_entry() //  [R1, R2]
         { info_tbl: [(c6vFi,
                       label: sat_s6v5X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vFi: // global
           _s6v5M::P64 = R2;
           _s6v5X::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6vFj; else goto c6vFk;
       c6vFk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vFm; else goto c6vFl;
       c6vFm: // global
           HpAlloc = 24;
           goto c6vFj;
       c6vFj: // global
           R2 = _s6v5M::P64;
           R1 = _s6v5X::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vFl: // global
           _s6v5F::P64 = P64[_s6v5X::P64 + 7];
           _s6v5I::P64 = P64[_s6v5X::P64 + 15];
           I64[Hp - 16] = sat_s6v5U_info;
           P64[Hp - 8] = _s6v5F::P64;
           P64[Hp] = _s6v5I::P64;
           I64[Sp - 8] = block_c6vFf_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6vFf() //  [R1]
         { info_tbl: [(c6vFf,
                       label: block_c6vFf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vFf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vFp; else goto c6vFo;
       c6vFp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vFo: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v60_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vFq,
                       label: sat_s6v60_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vFq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6vFr; else goto c6vFs;
       c6vFr: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vFs: // global
           I64[Sp - 24] = block_c6vEt_info;
           _s6v5F::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6v5F::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6vFF; else goto c6vEu;
       u6vFF: // global
           call _c6vEt(R1) args: 0, res: 0, upd: 0;
       c6vEu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vEt() //  [R1]
         { info_tbl: [(c6vEt,
                       label: block_c6vEt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vEt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vFv; else goto c6vFu;
       c6vFv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vFu: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6vFx; else goto c6vFB;
       c6vFx: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6vFB: // global
           I64[Hp - 16] = sat_s6v5X_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6vFy_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAlt_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6vFy() //  [R1]
         { info_tbl: [(c6vFy,
                       label: block_c6vFy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vFy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vFE; else goto c6vFD;
       c6vFE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vFD: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt1_entry() //  [R2]
         { info_tbl: [(c6vFG,
                       label: Data.Semigroup.Internal.$fReadAlt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vFG: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6vFK; else goto c6vFJ;
       c6vFK: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vFJ: // global
           I64[Hp - 48] = lvl12_s6v5E_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6v5F_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6v60_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.236855747 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadsPrec_info;
         const 0;
 },
 ds_s6v62_entry() //  [R1]
         { info_tbl: [(c6vFT,
                       label: ds_s6v62_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vFT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vFU; else goto c6vFV;
       c6vFU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vFV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v64_entry() //  [R1]
         { info_tbl: [(c6vG5,
                       label: sat_s6v64_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vG5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vG6; else goto c6vG7;
       c6vG6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vG7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v65_entry() //  [R1, R2]
         { info_tbl: [(c6vG8,
                       label: sat_s6v65_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vG8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vGc; else goto c6vGb;
       c6vGc: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vGb: // global
           _s6v62::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v64_info;
           P64[Hp - 8] = _s6v62::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6vGd,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vGd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6vGh; else goto c6vGg;
       c6vGh: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vGg: // global
           I64[Hp - 32] = ds_s6v62_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6v65_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.238825512 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadListPrec_info;
         const 0;
 },
 sat_s6v67_entry() //  [R1]
         { info_tbl: [(c6vGq,
                       label: sat_s6v67_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vGq: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6vGt,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vGt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vGx; else goto c6vGw;
       c6vGx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vGw: // global
           I64[Hp - 16] = sat_s6v67_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.240300951 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadList_info;
         const 0;
 },
 sat_s6v69_entry() //  [R1]
         { info_tbl: [(c6vGK,
                       label: sat_s6v69_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vGK: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v6a_entry() //  [R1]
         { info_tbl: [(c6vGN,
                       label: sat_s6v6a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vGN: // global
           _s6v6a::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6vGO; else goto c6vGP;
       c6vGP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vGR; else goto c6vGQ;
       c6vGR: // global
           HpAlloc = 24;
           goto c6vGO;
       c6vGO: // global
           R1 = _s6v6a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vGQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6a::P64;
           _s6v68::P64 = P64[_s6v6a::P64 + 16];
           I64[Hp - 16] = sat_s6v69_info;
           P64[Hp] = _s6v68::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadList_entry() //  [R2]
         { info_tbl: [(c6vGS,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vGS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vGW; else goto c6vGV;
       c6vGW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vGV: // global
           I64[Hp - 16] = sat_s6v6a_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.243484427 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_closure" {
     Data.Semigroup.Internal.$fReadAlt_closure:
         const Data.Semigroup.Internal.$fReadAlt_info;
         const 0;
 },
 sat_s6v6f_entry() //  [R1]
         { info_tbl: [(c6vH5,
                       label: sat_s6v6f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vH5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vH6; else goto c6vH7;
       c6vH6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vH7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6e_entry() //  [R1]
         { info_tbl: [(c6vHc,
                       label: sat_s6v6e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vHc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vHd; else goto c6vHe;
       c6vHd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vHe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6d_entry() //  [R1]
         { info_tbl: [(c6vHj,
                       label: sat_s6v6d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vHj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vHk; else goto c6vHl;
       c6vHk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vHl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6c_entry() //  [R1]
         { info_tbl: [(c6vHq,
                       label: sat_s6v6c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vHq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vHr; else goto c6vHs;
       c6vHr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vHs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_entry() //  [R2]
         { info_tbl: [(c6vHu,
                       label: Data.Semigroup.Internal.$fReadAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vHu: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6vHy; else goto c6vHx;
       c6vHy: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vHx: // global
           I64[Hp - 128] = sat_s6v6f_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v6e_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v6d_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v6c_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.245431664 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt1_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt1_closure:
         const Data.Semigroup.Internal.$fGeneric1Alt1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Alt1_entry() //  [R2]
         { info_tbl: [(c6vHD,
                       label: Data.Semigroup.Internal.$fGeneric1Alt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vHD: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.24620808 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt2_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt2_closure:
         const Data.Semigroup.Internal.$fGeneric1Alt2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Alt2_entry() //  [R2]
         { info_tbl: [(c6vHK,
                       label: Data.Semigroup.Internal.$fGeneric1Alt2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vHK: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.246894037 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Alt2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Alt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.247788417 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt1_closure" {
     Data.Semigroup.Internal.$fGenericAlt1_closure:
         const Data.Semigroup.Internal.$fGenericAlt1_info;
 },
 Data.Semigroup.Internal.$fGenericAlt1_entry() //  [R2]
         { info_tbl: [(c6vHR,
                       label: Data.Semigroup.Internal.$fGenericAlt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vHR: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.248874808 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt2_closure" {
     Data.Semigroup.Internal.$fGenericAlt2_closure:
         const Data.Semigroup.Internal.$fGenericAlt2_info;
 },
 Data.Semigroup.Internal.$fGenericAlt2_entry() //  [R2]
         { info_tbl: [(c6vHY,
                       label: Data.Semigroup.Internal.$fGenericAlt2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vHY: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.249895086 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt_closure" {
     Data.Semigroup.Internal.$fGenericAlt_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAlt2_closure+1;
         const Data.Semigroup.Internal.$fGenericAlt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.251886652 UTC

[section ""data" . Data.Semigroup.Internal.$fNumProduct_closure" {
     Data.Semigroup.Internal.$fNumProduct_closure:
         const Data.Semigroup.Internal.$fNumProduct_info;
 },
 sat_s6v6r_entry() //  [R1]
         { info_tbl: [(c6vI9,
                       label: sat_s6v6r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vI9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vIa; else goto c6vIb;
       c6vIa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vIb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6q_entry() //  [R1]
         { info_tbl: [(c6vIg,
                       label: sat_s6v6q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vIg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vIh; else goto c6vIi;
       c6vIh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vIi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6p_entry() //  [R1]
         { info_tbl: [(c6vIn,
                       label: sat_s6v6p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vIn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vIo; else goto c6vIp;
       c6vIo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vIp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6o_entry() //  [R1]
         { info_tbl: [(c6vIu,
                       label: sat_s6v6o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vIu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vIv; else goto c6vIw;
       c6vIv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vIw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6n_entry() //  [R1]
         { info_tbl: [(c6vIB,
                       label: sat_s6v6n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vIB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vIC; else goto c6vID;
       c6vIC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vID: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6m_entry() //  [R1]
         { info_tbl: [(c6vII,
                       label: sat_s6v6m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vII: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vIJ; else goto c6vIK;
       c6vIJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vIK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6l_entry() //  [R1]
         { info_tbl: [(c6vIP,
                       label: sat_s6v6l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vIP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vIQ; else goto c6vIR;
       c6vIQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vIR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumProduct_entry() //  [R2]
         { info_tbl: [(c6vIT,
                       label: Data.Semigroup.Internal.$fNumProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vIT: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6vIX; else goto c6vIW;
       c6vIX: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vIW: // global
           I64[Hp - 224] = sat_s6v6r_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6v6q_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6v6p_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6v6o_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6v6n_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v6m_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v6l_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.255510625 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product1_closure" {
     Data.Semigroup.Internal.$fGeneric1Product1_closure:
         const Data.Semigroup.Internal.$fGeneric1Product1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Product1_entry() //  [R2]
         { info_tbl: [(c6vJ2,
                       label: Data.Semigroup.Internal.$fGeneric1Product1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vJ2: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.256557428 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product2_closure" {
     Data.Semigroup.Internal.$fGeneric1Product2_closure:
         const Data.Semigroup.Internal.$fGeneric1Product2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Product2_entry() //  [R2]
         { info_tbl: [(c6vJ9,
                       label: Data.Semigroup.Internal.$fGeneric1Product2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vJ9: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.258065692 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product_closure" {
     Data.Semigroup.Internal.$fGeneric1Product_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Product2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Product1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.258943767 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct1_closure" {
     Data.Semigroup.Internal.$fGenericProduct1_closure:
         const Data.Semigroup.Internal.$fGenericProduct1_info;
 },
 Data.Semigroup.Internal.$fGenericProduct1_entry() //  [R2]
         { info_tbl: [(c6vJg,
                       label: Data.Semigroup.Internal.$fGenericProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vJg: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.259780963 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct2_closure" {
     Data.Semigroup.Internal.$fGenericProduct2_closure:
         const Data.Semigroup.Internal.$fGenericProduct2_info;
 },
 Data.Semigroup.Internal.$fGenericProduct2_entry() //  [R2]
         { info_tbl: [(c6vJn,
                       label: Data.Semigroup.Internal.$fGenericProduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vJn: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.260556906 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct_closure" {
     Data.Semigroup.Internal.$fGenericProduct_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericProduct2_closure+1;
         const Data.Semigroup.Internal.$fGenericProduct1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.261668745 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedProduct_closure" {
     Data.Semigroup.Internal.$fBoundedProduct_closure:
         const Data.Semigroup.Internal.$fBoundedProduct_info;
 },
 sat_s6v6y_entry() //  [R1]
         { info_tbl: [(c6vJy,
                       label: sat_s6v6y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vJy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vJz; else goto c6vJA;
       c6vJz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vJA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6x_entry() //  [R1]
         { info_tbl: [(c6vJF,
                       label: sat_s6v6x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vJF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vJG; else goto c6vJH;
       c6vJG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vJH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedProduct_entry() //  [R2]
         { info_tbl: [(c6vJJ,
                       label: Data.Semigroup.Internal.$fBoundedProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vJJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6vJN; else goto c6vJM;
       c6vJN: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vJM: // global
           I64[Hp - 64] = sat_s6v6y_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v6x_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.263041927 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowProduct2_bytes" {
     Data.Semigroup.Internal.$fShowProduct2_bytes:
         I8[] [80,114,111,100,117,99,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.263616002 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowProduct1_bytes" {
     Data.Semigroup.Internal.$fShowProduct1_bytes:
         I8[] [103,101,116,80,114,111,100,117,99,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.2659975 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec4_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec4_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec4_info;
 },
 f_s6v6C_entry() //  [R1]
         { info_tbl: [(c6vJW,
                       label: f_s6v6C_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vJW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6vJX; else goto c6vJY;
       c6vJX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vJY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6v6F_entry() //  [R1]
         { info_tbl: [(c6vKj,
                       label: sat_s6v6F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vKj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vKk; else goto c6vKl;
       c6vKk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vKl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6G_entry() //  [R1]
         { info_tbl: [(c6vKm,
                       label: sat_s6v6G_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vKm: // global
           _s6v6G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vKn; else goto c6vKo;
       c6vKo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vKq; else goto c6vKp;
       c6vKq: // global
           HpAlloc = 24;
           goto c6vKn;
       c6vKn: // global
           R1 = _s6v6G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vKp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6G::P64;
           _s6v6C::P64 = P64[_s6v6G::P64 + 16];
           _s6v6E::P64 = P64[_s6v6G::P64 + 24];
           I64[Hp - 16] = sat_s6v6F_info;
           P64[Hp] = _s6v6E::P64;
           R2 = Hp - 16;
           R1 = _s6v6C::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6H_entry() //  [R1]
         { info_tbl: [(c6vKr,
                       label: sat_s6v6H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vKr: // global
           _s6v6H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vKs; else goto c6vKt;
       c6vKt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vKv; else goto c6vKu;
       c6vKv: // global
           HpAlloc = 32;
           goto c6vKs;
       c6vKs: // global
           R1 = _s6v6H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vKu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6H::P64;
           _s6v6C::P64 = P64[_s6v6H::P64 + 16];
           _s6v6E::P64 = P64[_s6v6H::P64 + 24];
           I64[Hp - 24] = sat_s6v6G_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = _s6v6E::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6I_entry() //  [R1, R2]
         { info_tbl: [(c6vKw,
                       label: sat_s6v6I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vKw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vKA; else goto c6vKz;
       c6vKA: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vKz: // global
           _s6v6C::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v6H_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v6L_entry() //  [R1]
         { info_tbl: [(c6vKY,
                       label: sat_s6v6L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vKY: // global
           _s6v6L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vKZ; else goto c6vL0;
       c6vL0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vL2; else goto c6vL1;
       c6vL2: // global
           HpAlloc = 24;
           goto c6vKZ;
       c6vKZ: // global
           R1 = _s6v6L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vL1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6L::P64;
           _s6v6J::P64 = P64[_s6v6L::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v6J::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6M_entry() //  [R1]
         { info_tbl: [(c6vL3,
                       label: sat_s6v6M_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vL3: // global
           _s6v6M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vL4; else goto c6vL5;
       c6vL5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vL7; else goto c6vL6;
       c6vL7: // global
           HpAlloc = 24;
           goto c6vL4;
       c6vL4: // global
           R1 = _s6v6M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vL6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6M::P64;
           _s6v6C::P64 = P64[_s6v6M::P64 + 16];
           _s6v6J::P64 = P64[_s6v6M::P64 + 24];
           I64[Hp - 16] = sat_s6v6L_info;
           P64[Hp] = _s6v6J::P64;
           R2 = Hp - 16;
           R1 = _s6v6C::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6N_entry() //  [R1]
         { info_tbl: [(c6vL8,
                       label: sat_s6v6N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vL8: // global
           _s6v6N::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vL9; else goto c6vLa;
       c6vLa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vLc; else goto c6vLb;
       c6vLc: // global
           HpAlloc = 32;
           goto c6vL9;
       c6vL9: // global
           R1 = _s6v6N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vLb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6N::P64;
           _s6v6C::P64 = P64[_s6v6N::P64 + 16];
           _s6v6J::P64 = P64[_s6v6N::P64 + 24];
           I64[Hp - 24] = sat_s6v6M_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = _s6v6J::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6O_entry() //  [R1]
         { info_tbl: [(c6vLd,
                       label: sat_s6v6O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vLd: // global
           _s6v6O::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vLe; else goto c6vLf;
       c6vLf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vLh; else goto c6vLg;
       c6vLh: // global
           HpAlloc = 32;
           goto c6vLe;
       c6vLe: // global
           R1 = _s6v6O::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vLg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6O::P64;
           _s6v6C::P64 = P64[_s6v6O::P64 + 16];
           _s6v6J::P64 = P64[_s6v6O::P64 + 24];
           I64[Hp - 24] = sat_s6v6N_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = _s6v6J::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6P_entry() //  [R1, R2]
         { info_tbl: [(c6vLj,
                       label: sat_s6v6P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vLj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6vLn; else goto c6vLm;
       c6vLn: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vLm: // global
           _s6v6C::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6v6O_info;
           P64[Hp - 32] = _s6v6C::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec4_entry() //  [R2, R3, R4]
         { info_tbl: [(c6vLr,
                       label: Data.Semigroup.Internal.$w$cshowsPrec4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vLr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6vLv; else goto c6vLu;
       c6vLv: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vLu: // global
           I64[Hp - 40] = f_s6v6C_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6vJS::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6vLp; else goto c6vLq;
       c6vLp: // global
           I64[Hp - 8] = sat_s6v6I_info;
           P64[Hp] = _c6vJS::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6vLq: // global
           I64[Hp - 8] = sat_s6v6P_info;
           P64[Hp] = _c6vJS::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.270429286 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c6vLD,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vLD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6vLE; else goto c6vLF;
       c6vLE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vLF: // global
           I64[Sp - 24] = block_c6vLA_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6vLJ; else goto c6vLB;
       u6vLJ: // global
           call _c6vLA(R1) args: 0, res: 0, upd: 0;
       c6vLB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vLA() //  [R1]
         { info_tbl: [(c6vLA,
                       label: block_c6vLA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vLA: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.272031501 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshow_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshow_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshow_info;
         const 0;
 },
 sat_s6v6X_entry() //  [R1]
         { info_tbl: [(c6vLW,
                       label: sat_s6v6X_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vLW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6vLX; else goto c6vLY;
       c6vLX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vLY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6v6Y_entry() //  [R1]
         { info_tbl: [(c6vLZ,
                       label: sat_s6v6Y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vLZ: // global
           _s6v6Y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vM0; else goto c6vM1;
       c6vM1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vM3; else goto c6vM2;
       c6vM3: // global
           HpAlloc = 32;
           goto c6vM0;
       c6vM0: // global
           R1 = _s6v6Y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vM2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6Y::P64;
           _s6v6V::P64 = P64[_s6v6Y::P64 + 16];
           _s6v6W::P64 = P64[_s6v6Y::P64 + 24];
           I64[Hp - 24] = sat_s6v6X_info;
           P64[Hp - 8] = _s6v6V::P64;
           P64[Hp] = _s6v6W::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6vM4,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vM4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vM8; else goto c6vM7;
       c6vM8: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vM7: // global
           I64[Hp - 24] = sat_s6v6Y_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.275215849 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshowList_info;
 },
 sat_s6v73_entry() //  [R1, R2]
         { info_tbl: [(c6vMi,
                       label: sat_s6v73_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vMi: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_$cshowList_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c6vMl,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vMl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vMp; else goto c6vMo;
       c6vMp: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vMo: // global
           I64[Hp - 8] = sat_s6v73_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.276738091 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_closure" {
     Data.Semigroup.Internal.$fShowProduct_closure:
         const Data.Semigroup.Internal.$fShowProduct_info;
         const 0;
 },
 sat_s6v77_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vMz,
                       label: sat_s6v77_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vMz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowProduct_$cshowList_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v76_entry() //  [R1, R2]
         { info_tbl: [(c6vMH,
                       label: sat_s6v76_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vMH: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowProduct_$cshow_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v75_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vMP,
                       label: sat_s6v75_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vMP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_entry() //  [R2]
         { info_tbl: [(c6vMT,
                       label: Data.Semigroup.Internal.$fShowProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vMT: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6vMX; else goto c6vMW;
       c6vMX: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vMW: // global
           I64[Hp - 72] = sat_s6v77_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v76_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v75_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.278144074 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadProduct5_bytes" {
     Data.Semigroup.Internal.$fReadProduct5_bytes:
         I8[] [80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.27888303 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct4_closure" {
     Data.Semigroup.Internal.$fReadProduct4_closure:
         const Data.Semigroup.Internal.$fReadProduct4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadProduct4_entry() //  [R1]
         { info_tbl: [(c6vN4,
                       label: Data.Semigroup.Internal.$fReadProduct4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vN4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vN5; else goto c6vN6;
       c6vN5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vN6: // global
           (_c6vN1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6vN1::I64 == 0) goto c6vN3; else goto c6vN2;
       c6vN3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6vN2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6vN1::I64;
           R2 = Data.Semigroup.Internal.$fReadProduct5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.279797099 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_lexeme_closure" {
     Data.Semigroup.Internal.$fReadProduct_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadProduct4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.28035397 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadProduct3_bytes" {
     Data.Semigroup.Internal.$fReadProduct3_bytes:
         I8[] [103,101,116,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.28106705 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct2_closure" {
     Data.Semigroup.Internal.$fReadProduct2_closure:
         const Data.Semigroup.Internal.$fReadProduct2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadProduct2_entry() //  [R1]
         { info_tbl: [(c6vNd,
                       label: Data.Semigroup.Internal.$fReadProduct2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vNd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vNe; else goto c6vNf;
       c6vNe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vNf: // global
           (_c6vNa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6vNa::I64 == 0) goto c6vNc; else goto c6vNb;
       c6vNc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6vNb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6vNa::I64;
           R2 = Data.Semigroup.Internal.$fReadProduct3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.283678486 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct1_closure" {
     Data.Semigroup.Internal.$fReadProduct1_closure:
         const Data.Semigroup.Internal.$fReadProduct1_info;
         const 0;
 },
 lvl12_s6v79_entry() //  [R1]
         { info_tbl: [(c6vNo,
                       label: lvl12_s6v79_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vNo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vNp; else goto c6vNq;
       c6vNp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vNq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6v7a_entry() //  [R1]
         { info_tbl: [(c6vNw,
                       label: ds_s6v7a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vNw: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7l_entry() //  [R1]
         { info_tbl: [(c6vO7,
                       label: sat_s6v7l_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vO7: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7o_entry() //  [R1, R2]
         { info_tbl: [(c6vOd,
                       label: sat_s6v7o_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vOd: // global
           _s6v7j::P64 = R2;
           _s6v7o::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6vOe; else goto c6vOf;
       c6vOf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vOh; else goto c6vOg;
       c6vOh: // global
           HpAlloc = 24;
           goto c6vOe;
       c6vOe: // global
           R2 = _s6v7j::P64;
           R1 = _s6v7o::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vOg: // global
           _s6v7d::P64 = P64[_s6v7o::P64 + 7];
           I64[Hp - 16] = sat_s6v7l_info;
           P64[Hp - 8] = _s6v7d::P64;
           P64[Hp] = _s6v7j::P64;
           I64[Sp - 8] = block_c6vOa_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6vOa() //  [R1]
         { info_tbl: [(c6vOa,
                       label: block_c6vOa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vOa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vOk; else goto c6vOj;
       c6vOk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vOj: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7p_entry() //  [R1, R2]
         { info_tbl: [(c6vOl,
                       label: sat_s6v7p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vOl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vOp; else goto c6vOo;
       c6vOp: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vOo: // global
           _s6v7a::P64 = P64[R1 + 7];
           _s6v7d::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6v7o_info;
           P64[Hp] = _s6v7d::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6v7a::P64;
           R2 = Data.Semigroup.Internal.$fReadProduct2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7s_entry() //  [R1, R2]
         { info_tbl: [(c6vOt,
                       label: sat_s6v7s_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vOt: // global
           _s6v7h::P64 = R2;
           _s6v7s::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6vOu; else goto c6vOv;
       c6vOv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vOx; else goto c6vOw;
       c6vOx: // global
           HpAlloc = 24;
           goto c6vOu;
       c6vOu: // global
           R2 = _s6v7h::P64;
           R1 = _s6v7s::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vOw: // global
           _s6v7a::P64 = P64[_s6v7s::P64 + 7];
           _s6v7d::P64 = P64[_s6v7s::P64 + 15];
           I64[Hp - 16] = sat_s6v7p_info;
           P64[Hp - 8] = _s6v7a::P64;
           P64[Hp] = _s6v7d::P64;
           I64[Sp - 8] = block_c6vOq_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6vOq() //  [R1]
         { info_tbl: [(c6vOq,
                       label: block_c6vOq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vOq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vOA; else goto c6vOz;
       c6vOA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vOz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7v_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vOB,
                       label: sat_s6v7v_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vOB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6vOC; else goto c6vOD;
       c6vOC: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vOD: // global
           I64[Sp - 24] = block_c6vNE_info;
           _s6v7a::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6v7a::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6vOQ; else goto c6vNF;
       u6vOQ: // global
           call _c6vNE(R1) args: 0, res: 0, upd: 0;
       c6vNF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vNE() //  [R1]
         { info_tbl: [(c6vNE,
                       label: block_c6vNE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vNE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vOG; else goto c6vOF;
       c6vOG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vOF: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6vOI; else goto c6vOM;
       c6vOI: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6vOM: // global
           I64[Hp - 16] = sat_s6v7s_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6vOJ_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadProduct_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6vOJ() //  [R1]
         { info_tbl: [(c6vOJ,
                       label: block_c6vOJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vOJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vOP; else goto c6vOO;
       c6vOP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vOO: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct1_entry() //  [R2]
         { info_tbl: [(c6vOR,
                       label: Data.Semigroup.Internal.$fReadProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vOR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6vOV; else goto c6vOU;
       c6vOV: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vOU: // global
           I64[Hp - 48] = lvl12_s6v79_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6v7a_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6v7v_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.288371983 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadsPrec_info;
         const 0;
 },
 ds_s6v7x_entry() //  [R1]
         { info_tbl: [(c6vP4,
                       label: ds_s6v7x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vP4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vP5; else goto c6vP6;
       c6vP5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vP6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7z_entry() //  [R1]
         { info_tbl: [(c6vPg,
                       label: sat_s6v7z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vPg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vPh; else goto c6vPi;
       c6vPh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vPi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7A_entry() //  [R1, R2]
         { info_tbl: [(c6vPj,
                       label: sat_s6v7A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vPj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vPn; else goto c6vPm;
       c6vPn: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vPm: // global
           _s6v7x::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v7z_info;
           P64[Hp - 8] = _s6v7x::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6vPo,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vPo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6vPs; else goto c6vPr;
       c6vPs: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vPr: // global
           I64[Hp - 32] = ds_s6v7x_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6v7A_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.290262765 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadListPrec_info;
         const 0;
 },
 sat_s6v7C_entry() //  [R1]
         { info_tbl: [(c6vPB,
                       label: sat_s6v7C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vPB: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6vPE,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vPE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vPI; else goto c6vPH;
       c6vPI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vPH: // global
           I64[Hp - 16] = sat_s6v7C_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.291671824 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadList_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadList_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadList_info;
         const 0;
 },
 sat_s6v7E_entry() //  [R1]
         { info_tbl: [(c6vPV,
                       label: sat_s6v7E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vPV: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7F_entry() //  [R1]
         { info_tbl: [(c6vPY,
                       label: sat_s6v7F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vPY: // global
           _s6v7F::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6vPZ; else goto c6vQ0;
       c6vQ0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vQ2; else goto c6vQ1;
       c6vQ2: // global
           HpAlloc = 24;
           goto c6vPZ;
       c6vPZ: // global
           R1 = _s6v7F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vQ1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v7F::P64;
           _s6v7D::P64 = P64[_s6v7F::P64 + 16];
           I64[Hp - 16] = sat_s6v7E_info;
           P64[Hp] = _s6v7D::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadList_entry() //  [R2]
         { info_tbl: [(c6vQ3,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vQ3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vQ7; else goto c6vQ6;
       c6vQ7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vQ6: // global
           I64[Hp - 16] = sat_s6v7F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.29365058 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_closure" {
     Data.Semigroup.Internal.$fReadProduct_closure:
         const Data.Semigroup.Internal.$fReadProduct_info;
         const 0;
 },
 sat_s6v7K_entry() //  [R1]
         { info_tbl: [(c6vQg,
                       label: sat_s6v7K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vQg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vQh; else goto c6vQi;
       c6vQh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vQi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7J_entry() //  [R1]
         { info_tbl: [(c6vQn,
                       label: sat_s6v7J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vQn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vQo; else goto c6vQp;
       c6vQo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vQp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7I_entry() //  [R1]
         { info_tbl: [(c6vQu,
                       label: sat_s6v7I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vQu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vQv; else goto c6vQw;
       c6vQv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vQw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7H_entry() //  [R1]
         { info_tbl: [(c6vQB,
                       label: sat_s6v7H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vQB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vQC; else goto c6vQD;
       c6vQC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vQD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_entry() //  [R2]
         { info_tbl: [(c6vQF,
                       label: Data.Semigroup.Internal.$fReadProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vQF: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6vQJ; else goto c6vQI;
       c6vQJ: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vQI: // global
           I64[Hp - 128] = sat_s6v7K_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v7J_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v7I_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v7H_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.295841298 UTC

[section ""data" . Data.Semigroup.Internal.$fEqProduct_closure" {
     Data.Semigroup.Internal.$fEqProduct_closure:
         const Data.Semigroup.Internal.$fEqProduct_info;
 },
 sat_s6v7N_entry() //  [R1]
         { info_tbl: [(c6vQS,
                       label: sat_s6v7N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vQS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vQT; else goto c6vQU;
       c6vQT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vQU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7M_entry() //  [R1]
         { info_tbl: [(c6vQZ,
                       label: sat_s6v7M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vQZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vR0; else goto c6vR1;
       c6vR0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vR1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqProduct_entry() //  [R2]
         { info_tbl: [(c6vR3,
                       label: Data.Semigroup.Internal.$fEqProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vR3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6vR7; else goto c6vR6;
       c6vR7: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vR6: // global
           I64[Hp - 64] = sat_s6v7N_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v7M_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.297502159 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_info;
 },
 sat_s6v7P_entry() //  [R1]
         { info_tbl: [(c6vRg,
                       label: sat_s6v7P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vRg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vRh; else goto c6vRi;
       c6vRh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vRi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6vRj,
                       label: Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vRj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vRn; else goto c6vRm;
       c6vRn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vRm: // global
           I64[Hp - 16] = sat_s6v7P_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqProduct_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.299650185 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdProduct_closure" {
     Data.Semigroup.Internal.$fOrdProduct_closure:
         const Data.Semigroup.Internal.$fOrdProduct_info;
 },
 sat_s6v7Y_entry() //  [R1]
         { info_tbl: [(c6vRw,
                       label: sat_s6v7Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vRw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vRx; else goto c6vRy;
       c6vRx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vRy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7X_entry() //  [R1]
         { info_tbl: [(c6vRD,
                       label: sat_s6v7X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vRD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vRE; else goto c6vRF;
       c6vRE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vRF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7W_entry() //  [R1]
         { info_tbl: [(c6vRK,
                       label: sat_s6v7W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vRK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vRL; else goto c6vRM;
       c6vRL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vRM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7V_entry() //  [R1]
         { info_tbl: [(c6vRR,
                       label: sat_s6v7V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vRR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vRS; else goto c6vRT;
       c6vRS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vRT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7U_entry() //  [R1]
         { info_tbl: [(c6vRY,
                       label: sat_s6v7U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vRY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vRZ; else goto c6vS0;
       c6vRZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vS0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7T_entry() //  [R1]
         { info_tbl: [(c6vS5,
                       label: sat_s6v7T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vS5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vS6; else goto c6vS7;
       c6vS6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vS7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7S_entry() //  [R1]
         { info_tbl: [(c6vSc,
                       label: sat_s6v7S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vSc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vSd; else goto c6vSe;
       c6vSd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vSe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7R_entry() //  [R1]
         { info_tbl: [(c6vSj,
                       label: sat_s6v7R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vSj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vSk; else goto c6vSl;
       c6vSk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vSl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdProduct_entry() //  [R2]
         { info_tbl: [(c6vSn,
                       label: Data.Semigroup.Internal.$fOrdProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vSn: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6vSr; else goto c6vSq;
       c6vSr: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vSq: // global
           I64[Hp - 256] = sat_s6v7Y_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v7X_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v7W_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v7V_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v7U_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v7T_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v7S_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v7R_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.304513823 UTC

[section ""data" . Data.Semigroup.Internal.$fNumSum_closure" {
     Data.Semigroup.Internal.$fNumSum_closure:
         const Data.Semigroup.Internal.$fNumSum_info;
 },
 sat_s6v86_entry() //  [R1]
         { info_tbl: [(c6vSA,
                       label: sat_s6v86_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vSA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vSB; else goto c6vSC;
       c6vSB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vSC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v85_entry() //  [R1]
         { info_tbl: [(c6vSH,
                       label: sat_s6v85_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vSH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vSI; else goto c6vSJ;
       c6vSI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vSJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v84_entry() //  [R1]
         { info_tbl: [(c6vSO,
                       label: sat_s6v84_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vSO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vSP; else goto c6vSQ;
       c6vSP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vSQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v83_entry() //  [R1]
         { info_tbl: [(c6vSV,
                       label: sat_s6v83_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vSV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vSW; else goto c6vSX;
       c6vSW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vSX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v82_entry() //  [R1]
         { info_tbl: [(c6vT2,
                       label: sat_s6v82_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vT2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vT3; else goto c6vT4;
       c6vT3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vT4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v81_entry() //  [R1]
         { info_tbl: [(c6vT9,
                       label: sat_s6v81_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vT9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vTa; else goto c6vTb;
       c6vTa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vTb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v80_entry() //  [R1]
         { info_tbl: [(c6vTg,
                       label: sat_s6v80_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vTg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vTh; else goto c6vTi;
       c6vTh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vTi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumSum_entry() //  [R2]
         { info_tbl: [(c6vTk,
                       label: Data.Semigroup.Internal.$fNumSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vTk: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6vTo; else goto c6vTn;
       c6vTo: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vTn: // global
           I64[Hp - 224] = sat_s6v86_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6v85_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6v84_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6v83_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6v82_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v81_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v80_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.307139075 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum1_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum1_closure:
         const Data.Semigroup.Internal.$fGeneric1Sum1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Sum1_entry() //  [R2]
         { info_tbl: [(c6vTt,
                       label: Data.Semigroup.Internal.$fGeneric1Sum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vTt: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.307964347 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum2_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum2_closure:
         const Data.Semigroup.Internal.$fGeneric1Sum2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Sum2_entry() //  [R2]
         { info_tbl: [(c6vTA,
                       label: Data.Semigroup.Internal.$fGeneric1Sum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vTA: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.308712831 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Sum2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Sum1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.309656681 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum1_closure" {
     Data.Semigroup.Internal.$fGenericSum1_closure:
         const Data.Semigroup.Internal.$fGenericSum1_info;
 },
 Data.Semigroup.Internal.$fGenericSum1_entry() //  [R2]
         { info_tbl: [(c6vTH,
                       label: Data.Semigroup.Internal.$fGenericSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vTH: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.310473654 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum2_closure" {
     Data.Semigroup.Internal.$fGenericSum2_closure:
         const Data.Semigroup.Internal.$fGenericSum2_info;
 },
 Data.Semigroup.Internal.$fGenericSum2_entry() //  [R2]
         { info_tbl: [(c6vTO,
                       label: Data.Semigroup.Internal.$fGenericSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vTO: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.311176823 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum_closure" {
     Data.Semigroup.Internal.$fGenericSum_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericSum2_closure+1;
         const Data.Semigroup.Internal.$fGenericSum1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.312187584 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedSum_closure" {
     Data.Semigroup.Internal.$fBoundedSum_closure:
         const Data.Semigroup.Internal.$fBoundedSum_info;
 },
 sat_s6v8d_entry() //  [R1]
         { info_tbl: [(c6vTZ,
                       label: sat_s6v8d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vTZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vU0; else goto c6vU1;
       c6vU0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vU1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8c_entry() //  [R1]
         { info_tbl: [(c6vU6,
                       label: sat_s6v8c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vU6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vU7; else goto c6vU8;
       c6vU7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vU8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedSum_entry() //  [R2]
         { info_tbl: [(c6vUa,
                       label: Data.Semigroup.Internal.$fBoundedSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vUa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6vUe; else goto c6vUd;
       c6vUe: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vUd: // global
           I64[Hp - 64] = sat_s6v8d_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v8c_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.313528909 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowSum2_bytes" {
     Data.Semigroup.Internal.$fShowSum2_bytes:
         I8[] [83,117,109,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.314117483 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowSum1_bytes" {
     Data.Semigroup.Internal.$fShowSum1_bytes:
         I8[] [103,101,116,83,117,109,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.31647233 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec5_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec5_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec5_info;
 },
 f_s6v8h_entry() //  [R1]
         { info_tbl: [(c6vUn,
                       label: f_s6v8h_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vUn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6vUo; else goto c6vUp;
       c6vUo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vUp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6v8k_entry() //  [R1]
         { info_tbl: [(c6vUK,
                       label: sat_s6v8k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vUK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vUL; else goto c6vUM;
       c6vUL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vUM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8l_entry() //  [R1]
         { info_tbl: [(c6vUN,
                       label: sat_s6v8l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vUN: // global
           _s6v8l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vUO; else goto c6vUP;
       c6vUP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vUR; else goto c6vUQ;
       c6vUR: // global
           HpAlloc = 24;
           goto c6vUO;
       c6vUO: // global
           R1 = _s6v8l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vUQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8l::P64;
           _s6v8h::P64 = P64[_s6v8l::P64 + 16];
           _s6v8j::P64 = P64[_s6v8l::P64 + 24];
           I64[Hp - 16] = sat_s6v8k_info;
           P64[Hp] = _s6v8j::P64;
           R2 = Hp - 16;
           R1 = _s6v8h::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8m_entry() //  [R1]
         { info_tbl: [(c6vUS,
                       label: sat_s6v8m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vUS: // global
           _s6v8m::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vUT; else goto c6vUU;
       c6vUU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vUW; else goto c6vUV;
       c6vUW: // global
           HpAlloc = 32;
           goto c6vUT;
       c6vUT: // global
           R1 = _s6v8m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vUV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8m::P64;
           _s6v8h::P64 = P64[_s6v8m::P64 + 16];
           _s6v8j::P64 = P64[_s6v8m::P64 + 24];
           I64[Hp - 24] = sat_s6v8l_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = _s6v8j::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8n_entry() //  [R1, R2]
         { info_tbl: [(c6vUX,
                       label: sat_s6v8n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vUX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vV1; else goto c6vV0;
       c6vV1: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vV0: // global
           _s6v8h::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v8m_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v8q_entry() //  [R1]
         { info_tbl: [(c6vVp,
                       label: sat_s6v8q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vVp: // global
           _s6v8q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vVq; else goto c6vVr;
       c6vVr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vVt; else goto c6vVs;
       c6vVt: // global
           HpAlloc = 24;
           goto c6vVq;
       c6vVq: // global
           R1 = _s6v8q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vVs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8q::P64;
           _s6v8o::P64 = P64[_s6v8q::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v8o::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8r_entry() //  [R1]
         { info_tbl: [(c6vVu,
                       label: sat_s6v8r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vVu: // global
           _s6v8r::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vVv; else goto c6vVw;
       c6vVw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vVy; else goto c6vVx;
       c6vVy: // global
           HpAlloc = 24;
           goto c6vVv;
       c6vVv: // global
           R1 = _s6v8r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vVx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8r::P64;
           _s6v8h::P64 = P64[_s6v8r::P64 + 16];
           _s6v8o::P64 = P64[_s6v8r::P64 + 24];
           I64[Hp - 16] = sat_s6v8q_info;
           P64[Hp] = _s6v8o::P64;
           R2 = Hp - 16;
           R1 = _s6v8h::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8s_entry() //  [R1]
         { info_tbl: [(c6vVz,
                       label: sat_s6v8s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vVz: // global
           _s6v8s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vVA; else goto c6vVB;
       c6vVB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vVD; else goto c6vVC;
       c6vVD: // global
           HpAlloc = 32;
           goto c6vVA;
       c6vVA: // global
           R1 = _s6v8s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vVC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8s::P64;
           _s6v8h::P64 = P64[_s6v8s::P64 + 16];
           _s6v8o::P64 = P64[_s6v8s::P64 + 24];
           I64[Hp - 24] = sat_s6v8r_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = _s6v8o::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8t_entry() //  [R1]
         { info_tbl: [(c6vVE,
                       label: sat_s6v8t_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vVE: // global
           _s6v8t::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vVF; else goto c6vVG;
       c6vVG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vVI; else goto c6vVH;
       c6vVI: // global
           HpAlloc = 32;
           goto c6vVF;
       c6vVF: // global
           R1 = _s6v8t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vVH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8t::P64;
           _s6v8h::P64 = P64[_s6v8t::P64 + 16];
           _s6v8o::P64 = P64[_s6v8t::P64 + 24];
           I64[Hp - 24] = sat_s6v8s_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = _s6v8o::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8u_entry() //  [R1, R2]
         { info_tbl: [(c6vVK,
                       label: sat_s6v8u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vVK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6vVO; else goto c6vVN;
       c6vVO: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vVN: // global
           _s6v8h::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6v8t_info;
           P64[Hp - 32] = _s6v8h::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec5_entry() //  [R2, R3, R4]
         { info_tbl: [(c6vVS,
                       label: Data.Semigroup.Internal.$w$cshowsPrec5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vVS: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6vVW; else goto c6vVV;
       c6vVW: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vVV: // global
           I64[Hp - 40] = f_s6v8h_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6vUj::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6vVQ; else goto c6vVR;
       c6vVQ: // global
           I64[Hp - 8] = sat_s6v8n_info;
           P64[Hp] = _c6vUj::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6vVR: // global
           I64[Hp - 8] = sat_s6v8u_info;
           P64[Hp] = _c6vUj::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.320886598 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowSum_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6vW4,
                       label: Data.Semigroup.Internal.$fShowSum_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vW4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6vW5; else goto c6vW6;
       c6vW5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vW6: // global
           I64[Sp - 24] = block_c6vW1_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6vWa; else goto c6vW2;
       u6vWa: // global
           call _c6vW1(R1) args: 0, res: 0, upd: 0;
       c6vW2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vW1() //  [R1]
         { info_tbl: [(c6vW1,
                       label: block_c6vW1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vW1: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.322746796 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshow_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshow_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshow_info;
         const 0;
 },
 sat_s6v8C_entry() //  [R1]
         { info_tbl: [(c6vWn,
                       label: sat_s6v8C_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vWn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6vWo; else goto c6vWp;
       c6vWo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vWp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6v8D_entry() //  [R1]
         { info_tbl: [(c6vWq,
                       label: sat_s6v8D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vWq: // global
           _s6v8D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6vWr; else goto c6vWs;
       c6vWs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vWu; else goto c6vWt;
       c6vWu: // global
           HpAlloc = 32;
           goto c6vWr;
       c6vWr: // global
           R1 = _s6v8D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vWt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8D::P64;
           _s6v8A::P64 = P64[_s6v8D::P64 + 16];
           _s6v8B::P64 = P64[_s6v8D::P64 + 24];
           I64[Hp - 24] = sat_s6v8C_info;
           P64[Hp - 8] = _s6v8A::P64;
           P64[Hp] = _s6v8B::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowSum_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6vWv,
                       label: Data.Semigroup.Internal.$fShowSum_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vWv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vWz; else goto c6vWy;
       c6vWz: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vWy: // global
           I64[Hp - 24] = sat_s6v8D_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.324570418 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshowList_info;
 },
 sat_s6v8I_entry() //  [R1, R2]
         { info_tbl: [(c6vWJ,
                       label: sat_s6v8I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vWJ: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowSum_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c6vWM,
                       label: Data.Semigroup.Internal.$fShowSum_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vWM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vWQ; else goto c6vWP;
       c6vWQ: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vWP: // global
           I64[Hp - 8] = sat_s6v8I_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.326131238 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_closure" {
     Data.Semigroup.Internal.$fShowSum_closure:
         const Data.Semigroup.Internal.$fShowSum_info;
         const 0;
 },
 sat_s6v8M_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vX0,
                       label: sat_s6v8M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vX0: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowSum_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v8L_entry() //  [R1, R2]
         { info_tbl: [(c6vX8,
                       label: sat_s6v8L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vX8: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowSum_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v8K_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vXg,
                       label: sat_s6v8K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vXg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowSum_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowSum_entry() //  [R2]
         { info_tbl: [(c6vXk,
                       label: Data.Semigroup.Internal.$fShowSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vXk: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6vXo; else goto c6vXn;
       c6vXo: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vXn: // global
           I64[Hp - 72] = sat_s6v8M_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v8L_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v8K_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.327572389 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadSum5_bytes" {
     Data.Semigroup.Internal.$fReadSum5_bytes:
         I8[] [83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.32838185 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum4_closure" {
     Data.Semigroup.Internal.$fReadSum4_closure:
         const Data.Semigroup.Internal.$fReadSum4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadSum4_entry() //  [R1]
         { info_tbl: [(c6vXv,
                       label: Data.Semigroup.Internal.$fReadSum4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vXv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vXw; else goto c6vXx;
       c6vXw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vXx: // global
           (_c6vXs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6vXs::I64 == 0) goto c6vXu; else goto c6vXt;
       c6vXu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6vXt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6vXs::I64;
           R2 = Data.Semigroup.Internal.$fReadSum5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.329358207 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_lexeme_closure" {
     Data.Semigroup.Internal.$fReadSum_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadSum4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.33001353 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadSum3_bytes" {
     Data.Semigroup.Internal.$fReadSum3_bytes:
         I8[] [103,101,116,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.331748436 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum2_closure" {
     Data.Semigroup.Internal.$fReadSum2_closure:
         const Data.Semigroup.Internal.$fReadSum2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadSum2_entry() //  [R1]
         { info_tbl: [(c6vXE,
                       label: Data.Semigroup.Internal.$fReadSum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vXE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vXF; else goto c6vXG;
       c6vXF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vXG: // global
           (_c6vXB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6vXB::I64 == 0) goto c6vXD; else goto c6vXC;
       c6vXD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6vXC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6vXB::I64;
           R2 = Data.Semigroup.Internal.$fReadSum3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.334565165 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum1_closure" {
     Data.Semigroup.Internal.$fReadSum1_closure:
         const Data.Semigroup.Internal.$fReadSum1_info;
         const 0;
 },
 lvl12_s6v8O_entry() //  [R1]
         { info_tbl: [(c6vXP,
                       label: lvl12_s6v8O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vXP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6vXQ; else goto c6vXR;
       c6vXQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vXR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6v8P_entry() //  [R1]
         { info_tbl: [(c6vXX,
                       label: ds_s6v8P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vXX: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v90_entry() //  [R1]
         { info_tbl: [(c6vYy,
                       label: sat_s6v90_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vYy: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v93_entry() //  [R1, R2]
         { info_tbl: [(c6vYE,
                       label: sat_s6v93_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vYE: // global
           _s6v8Y::P64 = R2;
           _s6v93::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6vYF; else goto c6vYG;
       c6vYG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vYI; else goto c6vYH;
       c6vYI: // global
           HpAlloc = 24;
           goto c6vYF;
       c6vYF: // global
           R2 = _s6v8Y::P64;
           R1 = _s6v93::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vYH: // global
           _s6v8S::P64 = P64[_s6v93::P64 + 7];
           I64[Hp - 16] = sat_s6v90_info;
           P64[Hp - 8] = _s6v8S::P64;
           P64[Hp] = _s6v8Y::P64;
           I64[Sp - 8] = block_c6vYB_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6vYB() //  [R1]
         { info_tbl: [(c6vYB,
                       label: block_c6vYB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vYB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vYL; else goto c6vYK;
       c6vYL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vYK: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v94_entry() //  [R1, R2]
         { info_tbl: [(c6vYM,
                       label: sat_s6v94_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vYM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vYQ; else goto c6vYP;
       c6vYQ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vYP: // global
           _s6v8P::P64 = P64[R1 + 7];
           _s6v8S::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6v93_info;
           P64[Hp] = _s6v8S::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6v8P::P64;
           R2 = Data.Semigroup.Internal.$fReadSum2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v97_entry() //  [R1, R2]
         { info_tbl: [(c6vYU,
                       label: sat_s6v97_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vYU: // global
           _s6v8W::P64 = R2;
           _s6v97::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6vYV; else goto c6vYW;
       c6vYW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vYY; else goto c6vYX;
       c6vYY: // global
           HpAlloc = 24;
           goto c6vYV;
       c6vYV: // global
           R2 = _s6v8W::P64;
           R1 = _s6v97::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vYX: // global
           _s6v8P::P64 = P64[_s6v97::P64 + 7];
           _s6v8S::P64 = P64[_s6v97::P64 + 15];
           I64[Hp - 16] = sat_s6v94_info;
           P64[Hp - 8] = _s6v8P::P64;
           P64[Hp] = _s6v8S::P64;
           I64[Sp - 8] = block_c6vYR_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6vYR() //  [R1]
         { info_tbl: [(c6vYR,
                       label: block_c6vYR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vYR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vZ1; else goto c6vZ0;
       c6vZ1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vZ0: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9a_entry() //  [R1, R2, R3]
         { info_tbl: [(c6vZ2,
                       label: sat_s6v9a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vZ2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6vZ3; else goto c6vZ4;
       c6vZ3: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6vZ4: // global
           I64[Sp - 24] = block_c6vY5_info;
           _s6v8P::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6v8P::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6vZh; else goto c6vY6;
       u6vZh: // global
           call _c6vY5(R1) args: 0, res: 0, upd: 0;
       c6vY6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6vY5() //  [R1]
         { info_tbl: [(c6vY5,
                       label: block_c6vY5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vY5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6vZ7; else goto c6vZ6;
       c6vZ7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vZ6: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6vZ9; else goto c6vZd;
       c6vZ9: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6vZd: // global
           I64[Hp - 16] = sat_s6v97_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6vZa_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadSum_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6vZa() //  [R1]
         { info_tbl: [(c6vZa,
                       label: block_c6vZa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vZa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6vZg; else goto c6vZf;
       c6vZg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6vZf: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum1_entry() //  [R2]
         { info_tbl: [(c6vZi,
                       label: Data.Semigroup.Internal.$fReadSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vZi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6vZm; else goto c6vZl;
       c6vZm: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vZl: // global
           I64[Hp - 48] = lvl12_s6v8O_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6v8P_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6v9a_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.338905343 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadsPrec_info;
         const 0;
 },
 ds_s6v9c_entry() //  [R1]
         { info_tbl: [(c6vZv,
                       label: ds_s6v9c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vZv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vZw; else goto c6vZx;
       c6vZw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vZx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9e_entry() //  [R1]
         { info_tbl: [(c6vZH,
                       label: sat_s6v9e_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vZH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6vZI; else goto c6vZJ;
       c6vZI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6vZJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9f_entry() //  [R1, R2]
         { info_tbl: [(c6vZK,
                       label: sat_s6v9f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vZK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6vZO; else goto c6vZN;
       c6vZO: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vZN: // global
           _s6v9c::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v9e_info;
           P64[Hp - 8] = _s6v9c::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6vZP,
                       label: Data.Semigroup.Internal.$fReadSum_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6vZP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6vZT; else goto c6vZS;
       c6vZT: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6vZS: // global
           I64[Hp - 32] = ds_s6v9c_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6v9f_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.340800009 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadListPrec_info;
         const 0;
 },
 sat_s6v9h_entry() //  [R1]
         { info_tbl: [(c6w02,
                       label: sat_s6v9h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w02: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6w05,
                       label: Data.Semigroup.Internal.$fReadSum_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w05: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6w09; else goto c6w08;
       c6w09: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w08: // global
           I64[Hp - 16] = sat_s6v9h_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.342185451 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadList_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadList_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadList_info;
         const 0;
 },
 sat_s6v9j_entry() //  [R1]
         { info_tbl: [(c6w0m,
                       label: sat_s6v9j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w0m: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9k_entry() //  [R1]
         { info_tbl: [(c6w0p,
                       label: sat_s6v9k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w0p: // global
           _s6v9k::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6w0q; else goto c6w0r;
       c6w0r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6w0t; else goto c6w0s;
       c6w0t: // global
           HpAlloc = 24;
           goto c6w0q;
       c6w0q: // global
           R1 = _s6v9k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w0s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v9k::P64;
           _s6v9i::P64 = P64[_s6v9k::P64 + 16];
           I64[Hp - 16] = sat_s6v9j_info;
           P64[Hp] = _s6v9i::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadList_entry() //  [R2]
         { info_tbl: [(c6w0u,
                       label: Data.Semigroup.Internal.$fReadSum_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w0u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6w0y; else goto c6w0x;
       c6w0y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w0x: // global
           I64[Hp - 16] = sat_s6v9k_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.344146231 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_closure" {
     Data.Semigroup.Internal.$fReadSum_closure:
         const Data.Semigroup.Internal.$fReadSum_info;
         const 0;
 },
 sat_s6v9p_entry() //  [R1]
         { info_tbl: [(c6w0H,
                       label: sat_s6v9p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w0H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w0I; else goto c6w0J;
       c6w0I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w0J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9o_entry() //  [R1]
         { info_tbl: [(c6w0O,
                       label: sat_s6v9o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w0O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w0P; else goto c6w0Q;
       c6w0P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w0Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9n_entry() //  [R1]
         { info_tbl: [(c6w0V,
                       label: sat_s6v9n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w0V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w0W; else goto c6w0X;
       c6w0W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w0X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9m_entry() //  [R1]
         { info_tbl: [(c6w12,
                       label: sat_s6v9m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w12: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w13; else goto c6w14;
       c6w13: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w14: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadSum_entry() //  [R2]
         { info_tbl: [(c6w16,
                       label: Data.Semigroup.Internal.$fReadSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w16: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6w1a; else goto c6w19;
       c6w1a: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w19: // global
           I64[Hp - 128] = sat_s6v9p_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v9o_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v9n_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v9m_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.346689479 UTC

[section ""data" . Data.Semigroup.Internal.$fEqSum_closure" {
     Data.Semigroup.Internal.$fEqSum_closure:
         const Data.Semigroup.Internal.$fEqSum_info;
 },
 sat_s6v9s_entry() //  [R1]
         { info_tbl: [(c6w1j,
                       label: sat_s6v9s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w1j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w1k; else goto c6w1l;
       c6w1k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w1l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9r_entry() //  [R1]
         { info_tbl: [(c6w1q,
                       label: sat_s6v9r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w1q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w1r; else goto c6w1s;
       c6w1r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w1s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqSum_entry() //  [R2]
         { info_tbl: [(c6w1u,
                       label: Data.Semigroup.Internal.$fEqSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w1u: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6w1y; else goto c6w1x;
       c6w1y: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w1x: // global
           I64[Hp - 64] = sat_s6v9s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v9r_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.348295665 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdSum_$cp1Ord_info;
 },
 sat_s6v9u_entry() //  [R1]
         { info_tbl: [(c6w1H,
                       label: sat_s6v9u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w1H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w1I; else goto c6w1J;
       c6w1I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w1J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdSum_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6w1K,
                       label: Data.Semigroup.Internal.$fOrdSum_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w1K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6w1O; else goto c6w1N;
       c6w1O: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w1N: // global
           I64[Hp - 16] = sat_s6v9u_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqSum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.350447191 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdSum_closure" {
     Data.Semigroup.Internal.$fOrdSum_closure:
         const Data.Semigroup.Internal.$fOrdSum_info;
 },
 sat_s6v9D_entry() //  [R1]
         { info_tbl: [(c6w1X,
                       label: sat_s6v9D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w1X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w1Y; else goto c6w1Z;
       c6w1Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w1Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9C_entry() //  [R1]
         { info_tbl: [(c6w24,
                       label: sat_s6v9C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w24: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w25; else goto c6w26;
       c6w25: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w26: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9B_entry() //  [R1]
         { info_tbl: [(c6w2b,
                       label: sat_s6v9B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w2b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w2c; else goto c6w2d;
       c6w2c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w2d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9A_entry() //  [R1]
         { info_tbl: [(c6w2i,
                       label: sat_s6v9A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w2j; else goto c6w2k;
       c6w2j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w2k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9z_entry() //  [R1]
         { info_tbl: [(c6w2p,
                       label: sat_s6v9z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w2p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w2q; else goto c6w2r;
       c6w2q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w2r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9y_entry() //  [R1]
         { info_tbl: [(c6w2w,
                       label: sat_s6v9y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w2w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w2x; else goto c6w2y;
       c6w2x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w2y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9x_entry() //  [R1]
         { info_tbl: [(c6w2D,
                       label: sat_s6v9x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w2D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w2E; else goto c6w2F;
       c6w2E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w2F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9w_entry() //  [R1]
         { info_tbl: [(c6w2K,
                       label: sat_s6v9w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w2K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w2L; else goto c6w2M;
       c6w2L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w2M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdSum_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdSum_entry() //  [R2]
         { info_tbl: [(c6w2O,
                       label: Data.Semigroup.Internal.$fOrdSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w2O: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6w2S; else goto c6w2R;
       c6w2S: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w2R: // global
           I64[Hp - 256] = sat_s6v9D_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v9C_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v9B_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v9A_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v9z_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v9y_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v9x_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v9w_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.353361233 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny1_closure" {
     Data.Semigroup.Internal.$fGenericAny1_closure:
         const Data.Semigroup.Internal.$fGenericAny1_info;
 },
 Data.Semigroup.Internal.$fGenericAny1_entry() //  [R2]
         { info_tbl: [(c6w2X,
                       label: Data.Semigroup.Internal.$fGenericAny1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w2X: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.354202 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny2_closure" {
     Data.Semigroup.Internal.$fGenericAny2_closure:
         const Data.Semigroup.Internal.$fGenericAny2_info;
 },
 Data.Semigroup.Internal.$fGenericAny2_entry() //  [R2]
         { info_tbl: [(c6w34,
                       label: Data.Semigroup.Internal.$fGenericAny2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w34: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.354936529 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny_closure" {
     Data.Semigroup.Internal.$fGenericAny_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAny2_closure+1;
         const Data.Semigroup.Internal.$fGenericAny1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.355597314 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedAny_closure" {
     Data.Semigroup.Internal.$fBoundedAny_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.356224664 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAny4_bytes" {
     Data.Semigroup.Internal.$fShowAny4_bytes:
         I8[] [65,110,121,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.356991584 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny3_closure" {
     Data.Semigroup.Internal.$fShowAny3_closure:
         const Data.Semigroup.Internal.$fShowAny3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny3_entry() //  [R1]
         { info_tbl: [(c6w3d,
                       label: Data.Semigroup.Internal.$fShowAny3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w3d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w3e; else goto c6w3f;
       c6w3e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w3f: // global
           (_c6w3a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6w3a::I64 == 0) goto c6w3c; else goto c6w3b;
       c6w3c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6w3b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6w3a::I64;
           R2 = Data.Semigroup.Internal.$fShowAny4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.358098873 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAny2_bytes" {
     Data.Semigroup.Internal.$fShowAny2_bytes:
         I8[] [103,101,116,65,110,121,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.361951236 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec2_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec2_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec2_info;
         const 0;
 },
 sat_s6v9L_entry() //  [R1]
         { info_tbl: [(c6w3E,
                       label: sat_s6v9L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w3E: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9M_entry() //  [R1]
         { info_tbl: [(c6w3N,
                       label: sat_s6v9M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w3N: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9N_entry() //  [R1]
         { info_tbl: [(c6w3U,
                       label: sat_s6v9N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w3U: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6w3V; else goto c6w3W;
       c6w3V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w3W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6w3v_info;
           _s6v9I::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6v9I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6w43; else goto c6w3w;
       u6w43: // global
           call _c6w3v(R1) args: 0, res: 0, upd: 0;
       c6w3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6w3v() //  [R1]
         { info_tbl: [(c6w3v,
                       label: block_c6w3v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w3v: // global
           _s6v9I::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6w3R; else goto c6w3S;
       c6w3R: // global
           Hp = Hp + 24;
           _s6v9K::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6w42; else goto c6w3Y;
       c6w3Y: // global
           I64[Hp - 16] = sat_s6v9L_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6w3S: // global
           Hp = Hp + 24;
           _s6v9K::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6w42; else goto c6w41;
       c6w42: // global
           HpAlloc = 24;
           R1 = _s6v9K::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6w41: // global
           I64[Hp - 16] = sat_s6v9M_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9O_entry() //  [R1]
         { info_tbl: [(c6w44,
                       label: sat_s6v9O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w44: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6w48; else goto c6w47;
       c6w48: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w47: // global
           _s6v9H::P64 = P64[R1 + 16];
           _s6v9I::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6v9N_info;
           P64[Hp - 8] = _s6v9H::P64;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9R_entry() //  [R1]
         { info_tbl: [(c6w4w,
                       label: sat_s6v9R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w4w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6w4A; else goto c6w4z;
       c6w4A: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w4z: // global
           _s6v9I::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9T_entry() //  [R1]
         { info_tbl: [(c6w4I,
                       label: sat_s6v9T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w4I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6w4M; else goto c6w4L;
       c6w4M: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w4L: // global
           _s6v9I::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9U_entry() //  [R1]
         { info_tbl: [(c6w4R,
                       label: sat_s6v9U_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w4R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6w4S; else goto c6w4T;
       c6w4S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w4T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6w4m_info;
           _s6v9I::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6v9I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6w50; else goto c6w4n;
       u6w50: // global
           call _c6w4m(R1) args: 0, res: 0, upd: 0;
       c6w4n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6w4m() //  [R1]
         { info_tbl: [(c6w4m,
                       label: block_c6w4m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w4m: // global
           _s6v9I::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6w4O; else goto c6w4P;
       c6w4O: // global
           Hp = Hp + 24;
           _s6v9P::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6w4Z; else goto c6w4V;
       c6w4V: // global
           I64[Hp - 16] = sat_s6v9R_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6w4P: // global
           Hp = Hp + 24;
           _s6v9P::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6w4Z; else goto c6w4Y;
       c6w4Z: // global
           HpAlloc = 24;
           R1 = _s6v9P::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6w4Y: // global
           I64[Hp - 16] = sat_s6v9T_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9V_entry() //  [R1]
         { info_tbl: [(c6w51,
                       label: sat_s6v9V_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w51: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6w55; else goto c6w54;
       c6w55: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w54: // global
           _s6v9H::P64 = P64[R1 + 16];
           _s6v9I::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6v9U_info;
           P64[Hp - 8] = _s6v9H::P64;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9W_entry() //  [R1]
         { info_tbl: [(c6w56,
                       label: sat_s6v9W_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w56: // global
           _s6v9W::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6w57; else goto c6w58;
       c6w58: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6w5a; else goto c6w59;
       c6w5a: // global
           HpAlloc = 32;
           goto c6w57;
       c6w57: // global
           R1 = _s6v9W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w59: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v9W::P64;
           _s6v9H::P64 = P64[_s6v9W::P64 + 16];
           _s6v9I::P64 = P64[_s6v9W::P64 + 24];
           I64[Hp - 24] = sat_s6v9V_info;
           P64[Hp - 8] = _s6v9H::P64;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(c6w5e,
                       label: Data.Semigroup.Internal.$w$cshowsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w5e: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6w5i; else goto c6w5h;
       c6w5i: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6w5h: // global
           if (%MO_S_Lt_W64(R2, 11)) goto c6w5c; else goto c6w5d;
       c6w5c: // global
           I64[Hp - 48] = sat_s6v9O_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _c6w3n::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c6w3n::P64;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6w5d: // global
           I64[Hp - 48] = sat_s6v9W_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.366394378 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6w5r,
                       label: Data.Semigroup.Internal.$fShowAny_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w5r: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6w5s; else goto c6w5t;
       c6w5s: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6w5t: // global
           I64[Sp - 24] = block_c6w5o_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6w5x; else goto c6w5p;
       u6w5x: // global
           call _c6w5o(R1) args: 0, res: 0, upd: 0;
       c6w5p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6w5o() //  [R1]
         { info_tbl: [(c6w5o,
                       label: block_c6w5o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w5o: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.367655933 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll6_closure" {
     Data.Semigroup.Internal.$fShowAll6_closure:
         const Data.Semigroup.Internal.$fShowAll6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll6_entry() //  [R1]
         { info_tbl: [(c6w5E,
                       label: Data.Semigroup.Internal.$fShowAll6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w5E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w5F; else goto c6w5G;
       c6w5F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w5G: // global
           (_c6w5B::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6w5B::I64 == 0) goto c6w5D; else goto c6w5C;
       c6w5D: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6w5C: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6w5B::I64;
           R3 = Data.Semigroup.Internal.$fReadAll4_closure;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.368775465 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll5_closure" {
     Data.Semigroup.Internal.$fShowAll5_closure:
         const Data.Semigroup.Internal.$fShowAll5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll5_entry() //  [R1]
         { info_tbl: [(c6w5N,
                       label: Data.Semigroup.Internal.$fShowAll5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w5N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w5O; else goto c6w5P;
       c6w5O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w5P: // global
           (_c6w5K::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6w5K::I64 == 0) goto c6w5M; else goto c6w5L;
       c6w5M: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6w5L: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6w5K::I64;
           R3 = Data.Semigroup.Internal.$fReadAll4_closure;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.370297409 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshow_info;
         const 0;
 },
 sat_s6va4_entry() //  [R1]
         { info_tbl: [(c6w69,
                       label: sat_s6va4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w69: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6w6a; else goto c6w6b;
       c6w6a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w6b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6w62_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6w6i; else goto c6w63;
       u6w6i: // global
           call _c6w62(R1) args: 0, res: 0, upd: 0;
       c6w63: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6w62() //  [R1]
         { info_tbl: [(c6w62,
                       label: block_c6w62_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w62: // global
           if (R1 & 7 == 1) goto c6w66; else goto c6w67;
       c6w66: // global
           R1 = Data.Semigroup.Internal.$fShowAll6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6w67: // global
           R1 = Data.Semigroup.Internal.$fShowAll5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6va5_entry() //  [R1]
         { info_tbl: [(c6w6j,
                       label: sat_s6va5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w6j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6w6n; else goto c6w6m;
       c6w6n: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w6m: // global
           _s6va2::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s6va4_info;
           P64[Hp] = _s6va2::P64;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAny_$cshow_entry() //  [R2]
         { info_tbl: [(c6w6o,
                       label: Data.Semigroup.Internal.$fShowAny_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w6o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6w6s; else goto c6w6r;
       c6w6s: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w6r: // global
           I64[Hp - 16] = sat_s6va5_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.372830289 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny1_closure" {
     Data.Semigroup.Internal.$fShowAny1_closure:
         const Data.Semigroup.Internal.$fShowAny1_info;
         const 0;
 },
 sat_s6va9_entry() //  [R1]
         { info_tbl: [(c6w6O,
                       label: sat_s6va9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w6O: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaa_entry() //  [R1]
         { info_tbl: [(c6w6X,
                       label: sat_s6vaa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w6X: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vab_entry() //  [R1]
         { info_tbl: [(c6w74,
                       label: sat_s6vab_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w74: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6w75; else goto c6w76;
       c6w75: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w76: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6w6F_info;
           _s6va7::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6va7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6w7d; else goto c6w6G;
       u6w7d: // global
           call _c6w6F(R1) args: 0, res: 0, upd: 0;
       c6w6G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6w6F() //  [R1]
         { info_tbl: [(c6w6F,
                       label: block_c6w6F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w6F: // global
           _s6va7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6w71; else goto c6w72;
       c6w71: // global
           Hp = Hp + 24;
           _s6va8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6w7c; else goto c6w78;
       c6w78: // global
           I64[Hp - 16] = sat_s6va9_info;
           P64[Hp] = _s6va7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6w72: // global
           Hp = Hp + 24;
           _s6va8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6w7c; else goto c6w7b;
       c6w7c: // global
           HpAlloc = 24;
           R1 = _s6va8::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6w7b: // global
           I64[Hp - 16] = sat_s6vaa_info;
           P64[Hp] = _s6va7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vac_entry() //  [R1]
         { info_tbl: [(c6w7e,
                       label: sat_s6vac_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w7e: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6w7i; else goto c6w7h;
       c6w7i: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w7h: // global
           _s6va6::P64 = P64[R1 + 16];
           _s6va7::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vab_info;
           P64[Hp - 8] = _s6va6::P64;
           P64[Hp] = _s6va7::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAny1_entry() //  [R2, R3]
         { info_tbl: [(c6w7j,
                       label: Data.Semigroup.Internal.$fShowAny1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w7j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6w7n; else goto c6w7m;
       c6w7n: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6w7m: // global
           I64[Hp - 24] = sat_s6vac_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.375364575 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshowList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c6w7s,
                       label: Data.Semigroup.Internal.$fShowAny_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w7s: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fShowAny1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.376099316 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_closure" {
     Data.Semigroup.Internal.$fShowAny_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure+3;
         const Data.Semigroup.Internal.$fShowAny_$cshow_closure+1;
         const Data.Semigroup.Internal.$fShowAny_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.37670968 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAny6_bytes" {
     Data.Semigroup.Internal.$fReadAny6_bytes:
         I8[] [65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.377490446 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny5_closure" {
     Data.Semigroup.Internal.$fReadAny5_closure:
         const Data.Semigroup.Internal.$fReadAny5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny5_entry() //  [R1]
         { info_tbl: [(c6w7B,
                       label: Data.Semigroup.Internal.$fReadAny5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w7B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w7C; else goto c6w7D;
       c6w7C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w7D: // global
           (_c6w7y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6w7y::I64 == 0) goto c6w7A; else goto c6w7z;
       c6w7A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6w7z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6w7y::I64;
           R2 = Data.Semigroup.Internal.$fReadAny6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.378488848 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAny_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAny5_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.379071363 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAny4_bytes" {
     Data.Semigroup.Internal.$fReadAny4_bytes:
         I8[] [103,101,116,65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.379841328 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny3_closure" {
     Data.Semigroup.Internal.$fReadAny3_closure:
         const Data.Semigroup.Internal.$fReadAny3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny3_entry() //  [R1]
         { info_tbl: [(c6w7K,
                       label: Data.Semigroup.Internal.$fReadAny3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w7K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w7L; else goto c6w7M;
       c6w7L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w7M: // global
           (_c6w7H::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6w7H::I64 == 0) goto c6w7J; else goto c6w7I;
       c6w7J: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6w7I: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6w7H::I64;
           R2 = Data.Semigroup.Internal.$fReadAny4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.380901927 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll7_closure" {
     Data.Semigroup.Internal.$fReadAll7_closure:
         const Data.Semigroup.Internal.$fReadAll7_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll7_entry() //  [R3]
         { info_tbl: [(c6w7R,
                       label: Data.Semigroup.Internal.$fReadAll7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w7R: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadBool2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.38288149 UTC

[section ""data" . Data.Semigroup.Internal.$w$creadPrec1_closure" {
     Data.Semigroup.Internal.$w$creadPrec1_closure:
         const Data.Semigroup.Internal.$w$creadPrec1_info;
         const 0;
 },
 sat_s6vao_entry() //  [R1]
         { info_tbl: [(c6w8m,
                       label: sat_s6vao_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w8m: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6var_entry() //  [R1, R2]
         { info_tbl: [(c6w8s,
                       label: sat_s6var_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w8s: // global
           _s6vam::P64 = R2;
           _s6var::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6w8t; else goto c6w8u;
       c6w8u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6w8w; else goto c6w8v;
       c6w8w: // global
           HpAlloc = 24;
           goto c6w8t;
       c6w8t: // global
           R2 = _s6vam::P64;
           R1 = _s6var::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w8v: // global
           _s6vai::P64 = P64[_s6var::P64 + 7];
           I64[Hp - 16] = sat_s6vao_info;
           P64[Hp - 8] = _s6vai::P64;
           P64[Hp] = _s6vam::P64;
           I64[Sp - 8] = block_c6w8p_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6w8p() //  [R1]
         { info_tbl: [(c6w8p,
                       label: block_c6w8p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w8p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6w8z; else goto c6w8y;
       c6w8z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6w8y: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6w94_srtd" {
     u6w94_srtd:
         const S6vn0_srt+128;
         const 45;
         const 32985348833281;
 },
 sat_s6vas_entry() //  [R1, R2]
         { info_tbl: [(c6w8A,
                       label: sat_s6vas_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w8A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6w8E; else goto c6w8D;
       c6w8E: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w8D: // global
           _s6vai::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s6var_info;
           P64[Hp] = _s6vai::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = Data.Semigroup.Internal.$fReadAll7_closure+2;
           R2 = Data.Semigroup.Internal.$fReadAny3_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6w95_srtd" {
     u6w95_srtd:
         const S6vn0_srt+128;
         const 45;
         const 32985348833285;
 },
 sat_s6vav_entry() //  [R1, R2]
         { info_tbl: [(c6w8I,
                       label: sat_s6vav_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w8I: // global
           _s6vak::P64 = R2;
           _s6vav::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6w8J; else goto c6w8K;
       c6w8K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6w8M; else goto c6w8L;
       c6w8M: // global
           HpAlloc = 16;
           goto c6w8J;
       c6w8J: // global
           R2 = _s6vak::P64;
           R1 = _s6vav::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w8L: // global
           _s6vai::P64 = P64[_s6vav::P64 + 7];
           I64[Hp - 8] = sat_s6vas_info;
           P64[Hp] = _s6vai::P64;
           I64[Sp - 8] = block_c6w8F_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6w8F() //  [R1]
         { info_tbl: [(c6w8F,
                       label: block_c6w8F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w8F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6w8P; else goto c6w8O;
       c6w8P: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6w8O: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6w96_srtd" {
     u6w96_srtd:
         const S6vn0_srt+128;
         const 47;
         const 138538465099781;
 },
 Data.Semigroup.Internal.$w$creadPrec1_entry() //  [R2, R3]
         { info_tbl: [(c6w8T,
                       label: Data.Semigroup.Internal.$w$creadPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w8T: // global
           _s6vai::P64 = R3;
           _s6vah::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c6w8U; else goto c6w8V;
       c6w8V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6w8X; else goto c6w8W;
       c6w8X: // global
           HpAlloc = 16;
           goto c6w8U;
       c6w8U: // global
           R3 = _s6vai::P64;
           R2 = _s6vah::I64;
           R1 = Data.Semigroup.Internal.$w$creadPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6w8W: // global
           if (%MO_S_Gt_W64(_s6vah::I64, 11)) goto c6w8R; else goto c6w8S;
       c6w8R: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6w8S: // global
           I64[Hp - 8] = sat_s6vav_info;
           P64[Hp] = _s6vai::P64;
           I64[Sp - 8] = block_c6w8Y_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAny_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6w8Y() //  [R1]
         { info_tbl: [(c6w8Y,
                       label: block_c6w8Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w8Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6w93; else goto c6w92;
       c6w93: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6w92: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.38648024 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny2_closure" {
     Data.Semigroup.Internal.$fReadAny2_closure:
         const Data.Semigroup.Internal.$fReadAny2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny2_entry() //  [R2, R3]
         { info_tbl: [(c6w9e,
                       label: Data.Semigroup.Internal.$fReadAny2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w9e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w9f; else goto c6w9g;
       c6w9f: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAny2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6w9g: // global
           I64[Sp - 16] = block_c6w9b_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6w9k; else goto c6w9c;
       u6w9k: // global
           call _c6w9b(R1) args: 0, res: 0, upd: 0;
       c6w9c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6w9b() //  [R1]
         { info_tbl: [(c6w9b,
                       label: block_c6w9b_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w9b: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$creadPrec1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.388772225 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny1_closure" {
     Data.Semigroup.Internal.$fReadAny1_closure:
         const Data.Semigroup.Internal.$fReadAny1_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny1_entry() //  [R2, R3]
         { info_tbl: [(c6w9p,
                       label: Data.Semigroup.Internal.$fReadAny1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w9p: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAny2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.389877977 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_info;
         const 0;
 },
 sat_s6vaD_entry() //  [R1]
         { info_tbl: [(c6w9A,
                       label: sat_s6vaD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w9A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w9B; else goto c6w9C;
       c6w9B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w9C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAny2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAny_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6w9D,
                       label: Data.Semigroup.Internal.$fReadAny_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w9D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6w9H; else goto c6w9G;
       c6w9H: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6w9G: // global
           I64[Hp - 16] = sat_s6vaD_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.391199842 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c6w9O,
                       label: Data.Semigroup.Internal.$fReadAny_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w9O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w9P; else goto c6w9Q;
       c6w9P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w9Q: // global
           (_c6w9L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6w9L::I64 == 0) goto c6w9N; else goto c6w9M;
       c6w9N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6w9M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6w9L::I64;
           R2 = Data.Semigroup.Internal.$fReadAny1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.392347261 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny7_closure" {
     Data.Semigroup.Internal.$fReadAny7_closure:
         const Data.Semigroup.Internal.$fReadAny7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny7_entry() //  [R1]
         { info_tbl: [(c6w9X,
                       label: Data.Semigroup.Internal.$fReadAny7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6w9X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6w9Y; else goto c6w9Z;
       c6w9Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6w9Z: // global
           (_c6w9U::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6w9U::I64 == 0) goto c6w9W; else goto c6w9V;
       c6w9W: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6w9V: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6w9U::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.393432442 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny_$creadList_entry() //  [R2]
         { info_tbl: [(c6wa4,
                       label: Data.Semigroup.Internal.$fReadAny_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wa4: // global
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAny7_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.394198799 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_closure" {
     Data.Semigroup.Internal.$fReadAny_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure+1;
         const Data.Semigroup.Internal.$fReadAny_$creadList_closure+1;
         const Data.Semigroup.Internal.$fReadAny1_closure+2;
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.394849616 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAny_closure" {
     Data.Semigroup.Internal.$fEqAny_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.$fEqBool_$c==_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.395464637 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAny_closure" {
     Data.Semigroup.Internal.$fOrdAny_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Semigroup.Internal.$fEqAny_closure+1;
         const GHC.Classes.$fOrdBool_$ccompare_closure+2;
         const GHC.Classes.$fOrdBool_$c<_closure+2;
         const GHC.Classes.$fOrdBool_$c<=_closure+2;
         const GHC.Classes.$fOrdBool_$c>_closure+2;
         const GHC.Classes.$fOrdBool_$c>=_closure+2;
         const GHC.Classes.$fOrdBool_$cmax_closure+2;
         const GHC.Classes.$fOrdBool_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.396216643 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll1_closure" {
     Data.Semigroup.Internal.$fGenericAll1_closure:
         const Data.Semigroup.Internal.$fGenericAll1_info;
 },
 Data.Semigroup.Internal.$fGenericAll1_entry() //  [R2]
         { info_tbl: [(c6wab,
                       label: Data.Semigroup.Internal.$fGenericAll1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wab: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.397063199 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll2_closure" {
     Data.Semigroup.Internal.$fGenericAll2_closure:
         const Data.Semigroup.Internal.$fGenericAll2_info;
 },
 Data.Semigroup.Internal.$fGenericAll2_entry() //  [R2]
         { info_tbl: [(c6wai,
                       label: Data.Semigroup.Internal.$fGenericAll2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wai: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.397834241 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll_closure" {
     Data.Semigroup.Internal.$fGenericAll_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAll2_closure+1;
         const Data.Semigroup.Internal.$fGenericAll1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.398465339 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedAll_closure" {
     Data.Semigroup.Internal.$fBoundedAll_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.399110209 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAll4_bytes" {
     Data.Semigroup.Internal.$fShowAll4_bytes:
         I8[] [65,108,108,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.399916804 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll3_closure" {
     Data.Semigroup.Internal.$fShowAll3_closure:
         const Data.Semigroup.Internal.$fShowAll3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll3_entry() //  [R1]
         { info_tbl: [(c6war,
                       label: Data.Semigroup.Internal.$fShowAll3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6war: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6was; else goto c6wat;
       c6was: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wat: // global
           (_c6wao::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wao::I64 == 0) goto c6waq; else goto c6wap;
       c6waq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wap: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wao::I64;
           R2 = Data.Semigroup.Internal.$fShowAll4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.4008323 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAll2_bytes" {
     Data.Semigroup.Internal.$fShowAll2_bytes:
         I8[] [103,101,116,65,108,108,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.403690301 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec_info;
         const 0;
 },
 sat_s6vaL_entry() //  [R1]
         { info_tbl: [(c6waS,
                       label: sat_s6vaL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6waS: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaM_entry() //  [R1]
         { info_tbl: [(c6wb1,
                       label: sat_s6vaM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wb1: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaN_entry() //  [R1]
         { info_tbl: [(c6wb8,
                       label: sat_s6vaN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wb8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wb9; else goto c6wba;
       c6wb9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wba: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6waJ_info;
           _s6vaI::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6vaI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wbh; else goto c6waK;
       u6wbh: // global
           call _c6waJ(R1) args: 0, res: 0, upd: 0;
       c6waK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6waJ() //  [R1]
         { info_tbl: [(c6waJ,
                       label: block_c6waJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6waJ: // global
           _s6vaI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6wb5; else goto c6wb6;
       c6wb5: // global
           Hp = Hp + 24;
           _s6vaK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6wbg; else goto c6wbc;
       c6wbc: // global
           I64[Hp - 16] = sat_s6vaL_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6wb6: // global
           Hp = Hp + 24;
           _s6vaK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6wbg; else goto c6wbf;
       c6wbg: // global
           HpAlloc = 24;
           R1 = _s6vaK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6wbf: // global
           I64[Hp - 16] = sat_s6vaM_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vaO_entry() //  [R1]
         { info_tbl: [(c6wbi,
                       label: sat_s6vaO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wbi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wbm; else goto c6wbl;
       c6wbm: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wbl: // global
           _s6vaH::P64 = P64[R1 + 16];
           _s6vaI::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vaN_info;
           P64[Hp - 8] = _s6vaH::P64;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaR_entry() //  [R1]
         { info_tbl: [(c6wbK,
                       label: sat_s6vaR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wbK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wbO; else goto c6wbN;
       c6wbO: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wbN: // global
           _s6vaI::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaT_entry() //  [R1]
         { info_tbl: [(c6wbW,
                       label: sat_s6vaT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wbW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wc0; else goto c6wbZ;
       c6wc0: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wbZ: // global
           _s6vaI::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaU_entry() //  [R1]
         { info_tbl: [(c6wc5,
                       label: sat_s6vaU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wc5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wc6; else goto c6wc7;
       c6wc6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wc7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6wbA_info;
           _s6vaI::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6vaI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wce; else goto c6wbB;
       u6wce: // global
           call _c6wbA(R1) args: 0, res: 0, upd: 0;
       c6wbB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6wbA() //  [R1]
         { info_tbl: [(c6wbA,
                       label: block_c6wbA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wbA: // global
           _s6vaI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6wc2; else goto c6wc3;
       c6wc2: // global
           Hp = Hp + 24;
           _s6vaP::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6wcd; else goto c6wc9;
       c6wc9: // global
           I64[Hp - 16] = sat_s6vaR_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6wc3: // global
           Hp = Hp + 24;
           _s6vaP::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6wcd; else goto c6wcc;
       c6wcd: // global
           HpAlloc = 24;
           R1 = _s6vaP::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6wcc: // global
           I64[Hp - 16] = sat_s6vaT_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vaV_entry() //  [R1]
         { info_tbl: [(c6wcf,
                       label: sat_s6vaV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wcf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wcj; else goto c6wci;
       c6wcj: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wci: // global
           _s6vaH::P64 = P64[R1 + 16];
           _s6vaI::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vaU_info;
           P64[Hp - 8] = _s6vaH::P64;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaW_entry() //  [R1]
         { info_tbl: [(c6wck,
                       label: sat_s6vaW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wck: // global
           _s6vaW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6wcl; else goto c6wcm;
       c6wcm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wco; else goto c6wcn;
       c6wco: // global
           HpAlloc = 32;
           goto c6wcl;
       c6wcl: // global
           R1 = _s6vaW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wcn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vaW::P64;
           _s6vaH::P64 = P64[_s6vaW::P64 + 16];
           _s6vaI::P64 = P64[_s6vaW::P64 + 24];
           I64[Hp - 24] = sat_s6vaV_info;
           P64[Hp - 8] = _s6vaH::P64;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6wcs,
                       label: Data.Semigroup.Internal.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wcs: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6wcw; else goto c6wcv;
       c6wcw: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wcv: // global
           if (%MO_S_Lt_W64(R2, 11)) goto c6wcq; else goto c6wcr;
       c6wcq: // global
           I64[Hp - 48] = sat_s6vaO_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _c6waB::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c6waB::P64;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6wcr: // global
           I64[Hp - 48] = sat_s6vaW_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.40823849 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6wcF,
                       label: Data.Semigroup.Internal.$fShowAll_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wcF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wcG; else goto c6wcH;
       c6wcG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wcH: // global
           I64[Sp - 24] = block_c6wcC_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6wcL; else goto c6wcD;
       u6wcL: // global
           call _c6wcC(R1) args: 0, res: 0, upd: 0;
       c6wcD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wcC() //  [R1]
         { info_tbl: [(c6wcC,
                       label: block_c6wcC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wcC: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.409909029 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshow_info;
         const 0;
 },
 sat_s6vb4_entry() //  [R1]
         { info_tbl: [(c6wd5,
                       label: sat_s6vb4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wd5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wd6; else goto c6wd7;
       c6wd6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wd7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6wcY_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6wde; else goto c6wcZ;
       u6wde: // global
           call _c6wcY(R1) args: 0, res: 0, upd: 0;
       c6wcZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6wcY() //  [R1]
         { info_tbl: [(c6wcY,
                       label: block_c6wcY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wcY: // global
           if (R1 & 7 == 1) goto c6wd2; else goto c6wd3;
       c6wd2: // global
           R1 = Data.Semigroup.Internal.$fShowAll6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6wd3: // global
           R1 = Data.Semigroup.Internal.$fShowAll5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vb5_entry() //  [R1]
         { info_tbl: [(c6wdf,
                       label: sat_s6vb5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wdf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wdj; else goto c6wdi;
       c6wdj: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wdi: // global
           _s6vb2::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s6vb4_info;
           P64[Hp] = _s6vb2::P64;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAll_$cshow_entry() //  [R2]
         { info_tbl: [(c6wdk,
                       label: Data.Semigroup.Internal.$fShowAll_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wdk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wdo; else goto c6wdn;
       c6wdo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wdn: // global
           I64[Hp - 16] = sat_s6vb5_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.41248239 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll1_closure" {
     Data.Semigroup.Internal.$fShowAll1_closure:
         const Data.Semigroup.Internal.$fShowAll1_info;
         const 0;
 },
 sat_s6vb9_entry() //  [R1]
         { info_tbl: [(c6wdK,
                       label: sat_s6vb9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wdK: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vba_entry() //  [R1]
         { info_tbl: [(c6wdT,
                       label: sat_s6vba_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wdT: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vbb_entry() //  [R1]
         { info_tbl: [(c6we0,
                       label: sat_s6vbb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6we0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6we1; else goto c6we2;
       c6we1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6we2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6wdB_info;
           _s6vb7::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6vb7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6we9; else goto c6wdC;
       u6we9: // global
           call _c6wdB(R1) args: 0, res: 0, upd: 0;
       c6wdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6wdB() //  [R1]
         { info_tbl: [(c6wdB,
                       label: block_c6wdB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wdB: // global
           _s6vb7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6wdX; else goto c6wdY;
       c6wdX: // global
           Hp = Hp + 24;
           _s6vb8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6we8; else goto c6we4;
       c6we4: // global
           I64[Hp - 16] = sat_s6vb9_info;
           P64[Hp] = _s6vb7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6wdY: // global
           Hp = Hp + 24;
           _s6vb8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6we8; else goto c6we7;
       c6we8: // global
           HpAlloc = 24;
           R1 = _s6vb8::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6we7: // global
           I64[Hp - 16] = sat_s6vba_info;
           P64[Hp] = _s6vb7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbc_entry() //  [R1]
         { info_tbl: [(c6wea,
                       label: sat_s6vbc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wea: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wee; else goto c6wed;
       c6wee: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wed: // global
           _s6vb6::P64 = P64[R1 + 16];
           _s6vb7::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vbb_info;
           P64[Hp - 8] = _s6vb6::P64;
           P64[Hp] = _s6vb7::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAll1_entry() //  [R2, R3]
         { info_tbl: [(c6wef,
                       label: Data.Semigroup.Internal.$fShowAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wef: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wej; else goto c6wei;
       c6wej: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wei: // global
           I64[Hp - 24] = sat_s6vbc_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.414953401 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshowList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c6weo,
                       label: Data.Semigroup.Internal.$fShowAll_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6weo: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fShowAll1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.416774623 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_closure" {
     Data.Semigroup.Internal.$fShowAll_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure+3;
         const Data.Semigroup.Internal.$fShowAll_$cshow_closure+1;
         const Data.Semigroup.Internal.$fShowAll_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.417840369 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll13_bytes" {
     Data.Semigroup.Internal.$fReadAll13_bytes:
         I8[] [65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.418595179 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll12_closure" {
     Data.Semigroup.Internal.$fReadAll12_closure:
         const Data.Semigroup.Internal.$fReadAll12_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll12_entry() //  [R1]
         { info_tbl: [(c6wex,
                       label: Data.Semigroup.Internal.$fReadAll12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wex: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wey; else goto c6wez;
       c6wey: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wez: // global
           (_c6weu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6weu::I64 == 0) goto c6wew; else goto c6wev;
       c6wew: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wev: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6weu::I64;
           R2 = Data.Semigroup.Internal.$fReadAll13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.419534139 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_lexeme1_closure" {
     Data.Semigroup.Internal.$fReadAll_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAll12_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.420109061 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll9_bytes" {
     Data.Semigroup.Internal.$fReadAll9_bytes:
         I8[] [103,101,116,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.420856019 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll8_closure" {
     Data.Semigroup.Internal.$fReadAll8_closure:
         const Data.Semigroup.Internal.$fReadAll8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll8_entry() //  [R1]
         { info_tbl: [(c6weG,
                       label: Data.Semigroup.Internal.$fReadAll8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6weG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6weH; else goto c6weI;
       c6weH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6weI: // global
           (_c6weD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6weD::I64 == 0) goto c6weF; else goto c6weE;
       c6weF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6weE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6weD::I64;
           R2 = Data.Semigroup.Internal.$fReadAll9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.422975568 UTC

[section ""data" . Data.Semigroup.Internal.$w$creadPrec_closure" {
     Data.Semigroup.Internal.$w$creadPrec_closure:
         const Data.Semigroup.Internal.$w$creadPrec_info;
         const 0;
 },
 sat_s6vbm_entry() //  [R1]
         { info_tbl: [(c6wfb,
                       label: sat_s6vbm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wfb: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vbp_entry() //  [R1, R2]
         { info_tbl: [(c6wfh,
                       label: sat_s6vbp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wfh: // global
           _s6vbk::P64 = R2;
           _s6vbp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6wfi; else goto c6wfj;
       c6wfj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wfl; else goto c6wfk;
       c6wfl: // global
           HpAlloc = 24;
           goto c6wfi;
       c6wfi: // global
           R2 = _s6vbk::P64;
           R1 = _s6vbp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wfk: // global
           _s6vbg::P64 = P64[_s6vbp::P64 + 7];
           I64[Hp - 16] = sat_s6vbm_info;
           P64[Hp - 8] = _s6vbg::P64;
           P64[Hp] = _s6vbk::P64;
           I64[Sp - 8] = block_c6wfe_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wfe() //  [R1]
         { info_tbl: [(c6wfe,
                       label: block_c6wfe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wfe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wfo; else goto c6wfn;
       c6wfo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wfn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6wfT_srtd" {
     u6wfT_srtd:
         const S6vn0_srt+128;
         const 59;
         const 288245769314500609;
 },
 sat_s6vbq_entry() //  [R1, R2]
         { info_tbl: [(c6wfp,
                       label: sat_s6vbq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wfp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wft; else goto c6wfs;
       c6wft: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wfs: // global
           _s6vbg::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s6vbp_info;
           P64[Hp] = _s6vbg::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = Data.Semigroup.Internal.$fReadAll7_closure+2;
           R2 = Data.Semigroup.Internal.$fReadAll8_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6wfU_srtd" {
     u6wfU_srtd:
         const S6vn0_srt+128;
         const 59;
         const 288245769314500613;
 },
 sat_s6vbt_entry() //  [R1, R2]
         { info_tbl: [(c6wfx,
                       label: sat_s6vbt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wfx: // global
           _s6vbi::P64 = R2;
           _s6vbt::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6wfy; else goto c6wfz;
       c6wfz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wfB; else goto c6wfA;
       c6wfB: // global
           HpAlloc = 16;
           goto c6wfy;
       c6wfy: // global
           R2 = _s6vbi::P64;
           R1 = _s6vbt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wfA: // global
           _s6vbg::P64 = P64[_s6vbt::P64 + 7];
           I64[Hp - 8] = sat_s6vbq_info;
           P64[Hp] = _s6vbg::P64;
           I64[Sp - 8] = block_c6wfu_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wfu() //  [R1]
         { info_tbl: [(c6wfu,
                       label: block_c6wfu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wfu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wfE; else goto c6wfD;
       c6wfE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wfD: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6wfV_srtd" {
     u6wfV_srtd:
         const S6vn0_srt+128;
         const 61;
         const 2017628026224771077;
 },
 Data.Semigroup.Internal.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(c6wfI,
                       label: Data.Semigroup.Internal.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wfI: // global
           _s6vbg::P64 = R3;
           _s6vbf::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c6wfJ; else goto c6wfK;
       c6wfK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wfM; else goto c6wfL;
       c6wfM: // global
           HpAlloc = 16;
           goto c6wfJ;
       c6wfJ: // global
           R3 = _s6vbg::P64;
           R2 = _s6vbf::I64;
           R1 = Data.Semigroup.Internal.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wfL: // global
           if (%MO_S_Gt_W64(_s6vbf::I64, 11)) goto c6wfG; else goto c6wfH;
       c6wfG: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6wfH: // global
           I64[Hp - 8] = sat_s6vbt_info;
           P64[Hp] = _s6vbg::P64;
           I64[Sp - 8] = block_c6wfN_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wfN() //  [R1]
         { info_tbl: [(c6wfN,
                       label: block_c6wfN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wfN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wfS; else goto c6wfR;
       c6wfS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wfR: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.426684791 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll2_closure" {
     Data.Semigroup.Internal.$fReadAll2_closure:
         const Data.Semigroup.Internal.$fReadAll2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll2_entry() //  [R2, R3]
         { info_tbl: [(c6wg3,
                       label: Data.Semigroup.Internal.$fReadAll2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wg3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wg4; else goto c6wg5;
       c6wg4: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAll2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wg5: // global
           I64[Sp - 16] = block_c6wg0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6wg9; else goto c6wg1;
       u6wg9: // global
           call _c6wg0(R1) args: 0, res: 0, upd: 0;
       c6wg1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wg0() //  [R1]
         { info_tbl: [(c6wg0,
                       label: block_c6wg0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wg0: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$creadPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.427862952 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll1_closure" {
     Data.Semigroup.Internal.$fReadAll1_closure:
         const Data.Semigroup.Internal.$fReadAll1_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll1_entry() //  [R2, R3]
         { info_tbl: [(c6wge,
                       label: Data.Semigroup.Internal.$fReadAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wge: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAll2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.428937168 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_info;
         const 0;
 },
 sat_s6vbB_entry() //  [R1]
         { info_tbl: [(c6wgp,
                       label: sat_s6vbB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wgp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wgq; else goto c6wgr;
       c6wgq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wgr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAll_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6wgs,
                       label: Data.Semigroup.Internal.$fReadAll_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wgs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wgw; else goto c6wgv;
       c6wgw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wgv: // global
           I64[Hp - 16] = sat_s6vbB_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.430368933 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c6wgD,
                       label: Data.Semigroup.Internal.$fReadAll_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wgD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wgE; else goto c6wgF;
       c6wgE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wgF: // global
           (_c6wgA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wgA::I64 == 0) goto c6wgC; else goto c6wgB;
       c6wgC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wgB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wgA::I64;
           R2 = Data.Semigroup.Internal.$fReadAll1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.431447258 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll14_closure" {
     Data.Semigroup.Internal.$fReadAll14_closure:
         const Data.Semigroup.Internal.$fReadAll14_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll14_entry() //  [R1]
         { info_tbl: [(c6wgM,
                       label: Data.Semigroup.Internal.$fReadAll14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wgM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wgN; else goto c6wgO;
       c6wgN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wgO: // global
           (_c6wgJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wgJ::I64 == 0) goto c6wgL; else goto c6wgK;
       c6wgL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wgK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wgJ::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.432532166 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll_$creadList_entry() //  [R2]
         { info_tbl: [(c6wgT,
                       label: Data.Semigroup.Internal.$fReadAll_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wgT: // global
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAll14_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.433340073 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_closure" {
     Data.Semigroup.Internal.$fReadAll_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure+1;
         const Data.Semigroup.Internal.$fReadAll_$creadList_closure+1;
         const Data.Semigroup.Internal.$fReadAll1_closure+2;
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.43397685 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAll_closure" {
     Data.Semigroup.Internal.$fEqAll_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.$fEqBool_$c==_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.434587609 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAll_closure" {
     Data.Semigroup.Internal.$fOrdAll_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Semigroup.Internal.$fEqAll_closure+1;
         const GHC.Classes.$fOrdBool_$ccompare_closure+2;
         const GHC.Classes.$fOrdBool_$c<_closure+2;
         const GHC.Classes.$fOrdBool_$c<=_closure+2;
         const GHC.Classes.$fOrdBool_$c>_closure+2;
         const GHC.Classes.$fOrdBool_$c>=_closure+2;
         const GHC.Classes.$fOrdBool_$cmax_closure+2;
         const GHC.Classes.$fOrdBool_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.435383129 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo1_closure" {
     Data.Semigroup.Internal.$fGenericEndo1_closure:
         const Data.Semigroup.Internal.$fGenericEndo1_info;
 },
 Data.Semigroup.Internal.$fGenericEndo1_entry() //  [R2]
         { info_tbl: [(c6wh0,
                       label: Data.Semigroup.Internal.$fGenericEndo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wh0: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.436235432 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo2_closure" {
     Data.Semigroup.Internal.$fGenericEndo2_closure:
         const Data.Semigroup.Internal.$fGenericEndo2_info;
 },
 Data.Semigroup.Internal.$fGenericEndo2_entry() //  [R2]
         { info_tbl: [(c6wh7,
                       label: Data.Semigroup.Internal.$fGenericEndo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wh7: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.436970803 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo_closure" {
     Data.Semigroup.Internal.$fGenericEndo_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericEndo2_closure+1;
         const Data.Semigroup.Internal.$fGenericEndo1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.437747793 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual1_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual1_closure:
         const Data.Semigroup.Internal.$fGeneric1Dual1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Dual1_entry() //  [R2]
         { info_tbl: [(c6whe,
                       label: Data.Semigroup.Internal.$fGeneric1Dual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6whe: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.438606504 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual2_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual2_closure:
         const Data.Semigroup.Internal.$fGeneric1Dual2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Dual2_entry() //  [R2]
         { info_tbl: [(c6whl,
                       label: Data.Semigroup.Internal.$fGeneric1Dual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6whl: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.439378111 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Dual2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Dual1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.440143407 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual1_closure" {
     Data.Semigroup.Internal.$fGenericDual1_closure:
         const Data.Semigroup.Internal.$fGenericDual1_info;
 },
 Data.Semigroup.Internal.$fGenericDual1_entry() //  [R2]
         { info_tbl: [(c6whs,
                       label: Data.Semigroup.Internal.$fGenericDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6whs: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.441022519 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual2_closure" {
     Data.Semigroup.Internal.$fGenericDual2_closure:
         const Data.Semigroup.Internal.$fGenericDual2_info;
 },
 Data.Semigroup.Internal.$fGenericDual2_entry() //  [R2]
         { info_tbl: [(c6whz,
                       label: Data.Semigroup.Internal.$fGenericDual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6whz: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.442048494 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual_closure" {
     Data.Semigroup.Internal.$fGenericDual_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericDual2_closure+1;
         const Data.Semigroup.Internal.$fGenericDual1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.443989015 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedDual_closure" {
     Data.Semigroup.Internal.$fBoundedDual_closure:
         const Data.Semigroup.Internal.$fBoundedDual_info;
 },
 sat_s6vbK_entry() //  [R1]
         { info_tbl: [(c6whK,
                       label: sat_s6vbK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6whK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6whL; else goto c6whM;
       c6whL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6whM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbJ_entry() //  [R1]
         { info_tbl: [(c6whR,
                       label: sat_s6vbJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6whR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6whS; else goto c6whT;
       c6whS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6whT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedDual_entry() //  [R2]
         { info_tbl: [(c6whV,
                       label: Data.Semigroup.Internal.$fBoundedDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6whV: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6whZ; else goto c6whY;
       c6whZ: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6whY: // global
           I64[Hp - 64] = sat_s6vbK_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6vbJ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.445333011 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowDual2_bytes" {
     Data.Semigroup.Internal.$fShowDual2_bytes:
         I8[] [68,117,97,108,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.445917839 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowDual1_bytes" {
     Data.Semigroup.Internal.$fShowDual1_bytes:
         I8[] [103,101,116,68,117,97,108,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.448225623 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec3_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec3_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec3_info;
 },
 f_s6vbO_entry() //  [R1]
         { info_tbl: [(c6wi8,
                       label: f_s6vbO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wi8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wi9; else goto c6wia;
       c6wi9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vbR_entry() //  [R1]
         { info_tbl: [(c6wiv,
                       label: sat_s6vbR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wiv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wiw; else goto c6wix;
       c6wiw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wix: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbS_entry() //  [R1]
         { info_tbl: [(c6wiy,
                       label: sat_s6vbS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wiy: // global
           _s6vbS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6wiz; else goto c6wiA;
       c6wiA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wiC; else goto c6wiB;
       c6wiC: // global
           HpAlloc = 24;
           goto c6wiz;
       c6wiz: // global
           R1 = _s6vbS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wiB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbS::P64;
           _s6vbO::P64 = P64[_s6vbS::P64 + 16];
           _s6vbQ::P64 = P64[_s6vbS::P64 + 24];
           I64[Hp - 16] = sat_s6vbR_info;
           P64[Hp] = _s6vbQ::P64;
           R2 = Hp - 16;
           R1 = _s6vbO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbT_entry() //  [R1]
         { info_tbl: [(c6wiD,
                       label: sat_s6vbT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wiD: // global
           _s6vbT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6wiE; else goto c6wiF;
       c6wiF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wiH; else goto c6wiG;
       c6wiH: // global
           HpAlloc = 32;
           goto c6wiE;
       c6wiE: // global
           R1 = _s6vbT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wiG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbT::P64;
           _s6vbO::P64 = P64[_s6vbT::P64 + 16];
           _s6vbQ::P64 = P64[_s6vbT::P64 + 24];
           I64[Hp - 24] = sat_s6vbS_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = _s6vbQ::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbU_entry() //  [R1, R2]
         { info_tbl: [(c6wiI,
                       label: sat_s6vbU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wiI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wiM; else goto c6wiL;
       c6wiM: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wiL: // global
           _s6vbO::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6vbT_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vbX_entry() //  [R1]
         { info_tbl: [(c6wja,
                       label: sat_s6vbX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wja: // global
           _s6vbX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6wjb; else goto c6wjc;
       c6wjc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wje; else goto c6wjd;
       c6wje: // global
           HpAlloc = 24;
           goto c6wjb;
       c6wjb: // global
           R1 = _s6vbX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wjd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbX::P64;
           _s6vbV::P64 = P64[_s6vbX::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6vbV::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbY_entry() //  [R1]
         { info_tbl: [(c6wjf,
                       label: sat_s6vbY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wjf: // global
           _s6vbY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6wjg; else goto c6wjh;
       c6wjh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wjj; else goto c6wji;
       c6wjj: // global
           HpAlloc = 24;
           goto c6wjg;
       c6wjg: // global
           R1 = _s6vbY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wji: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbY::P64;
           _s6vbO::P64 = P64[_s6vbY::P64 + 16];
           _s6vbV::P64 = P64[_s6vbY::P64 + 24];
           I64[Hp - 16] = sat_s6vbX_info;
           P64[Hp] = _s6vbV::P64;
           R2 = Hp - 16;
           R1 = _s6vbO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbZ_entry() //  [R1]
         { info_tbl: [(c6wjk,
                       label: sat_s6vbZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wjk: // global
           _s6vbZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6wjl; else goto c6wjm;
       c6wjm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wjo; else goto c6wjn;
       c6wjo: // global
           HpAlloc = 32;
           goto c6wjl;
       c6wjl: // global
           R1 = _s6vbZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wjn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbZ::P64;
           _s6vbO::P64 = P64[_s6vbZ::P64 + 16];
           _s6vbV::P64 = P64[_s6vbZ::P64 + 24];
           I64[Hp - 24] = sat_s6vbY_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = _s6vbV::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vc0_entry() //  [R1]
         { info_tbl: [(c6wjp,
                       label: sat_s6vc0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wjp: // global
           _s6vc0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6wjq; else goto c6wjr;
       c6wjr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wjt; else goto c6wjs;
       c6wjt: // global
           HpAlloc = 32;
           goto c6wjq;
       c6wjq: // global
           R1 = _s6vc0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wjs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vc0::P64;
           _s6vbO::P64 = P64[_s6vc0::P64 + 16];
           _s6vbV::P64 = P64[_s6vc0::P64 + 24];
           I64[Hp - 24] = sat_s6vbZ_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = _s6vbV::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vc1_entry() //  [R1, R2]
         { info_tbl: [(c6wjv,
                       label: sat_s6vc1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wjv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6wjz; else goto c6wjy;
       c6wjz: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wjy: // global
           _s6vbO::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6vc0_info;
           P64[Hp - 32] = _s6vbO::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec3_entry() //  [R2, R3, R4]
         { info_tbl: [(c6wjD,
                       label: Data.Semigroup.Internal.$w$cshowsPrec3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wjD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6wjH; else goto c6wjG;
       c6wjH: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wjG: // global
           I64[Hp - 40] = f_s6vbO_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6wi4::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6wjB; else goto c6wjC;
       c6wjB: // global
           I64[Hp - 8] = sat_s6vbU_info;
           P64[Hp] = _c6wi4::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6wjC: // global
           I64[Hp - 8] = sat_s6vc1_info;
           P64[Hp] = _c6wi4::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.452610215 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowDual_$cshowsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c6wjP,
                       label: Data.Semigroup.Internal.$fShowDual_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wjP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wjQ; else goto c6wjR;
       c6wjQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wjR: // global
           I64[Sp - 24] = block_c6wjM_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6wjV; else goto c6wjN;
       u6wjV: // global
           call _c6wjM(R1) args: 0, res: 0, upd: 0;
       c6wjN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wjM() //  [R1]
         { info_tbl: [(c6wjM,
                       label: block_c6wjM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wjM: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec3_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.454202633 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshow_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshow_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshow_info;
         const 0;
 },
 sat_s6vc9_entry() //  [R1]
         { info_tbl: [(c6wk8,
                       label: sat_s6vc9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wk8: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6wk9; else goto c6wka;
       c6wk9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wka: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6vca_entry() //  [R1]
         { info_tbl: [(c6wkb,
                       label: sat_s6vca_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wkb: // global
           _s6vca::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6wkc; else goto c6wkd;
       c6wkd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wkf; else goto c6wke;
       c6wkf: // global
           HpAlloc = 32;
           goto c6wkc;
       c6wkc: // global
           R1 = _s6vca::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wke: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vca::P64;
           _s6vc7::P64 = P64[_s6vca::P64 + 16];
           _s6vc8::P64 = P64[_s6vca::P64 + 24];
           I64[Hp - 24] = sat_s6vc9_info;
           P64[Hp - 8] = _s6vc7::P64;
           P64[Hp] = _s6vc8::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowDual_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6wkg,
                       label: Data.Semigroup.Internal.$fShowDual_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wkg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wkk; else goto c6wkj;
       c6wkk: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wkj: // global
           I64[Hp - 24] = sat_s6vca_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.456028724 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshowList_info;
 },
 sat_s6vcf_entry() //  [R1, R2]
         { info_tbl: [(c6wku,
                       label: sat_s6vcf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wku: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec3_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowDual_$cshowList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6wkx,
                       label: Data.Semigroup.Internal.$fShowDual_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wkx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wkB; else goto c6wkA;
       c6wkB: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wkA: // global
           I64[Hp - 8] = sat_s6vcf_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.457602242 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_closure" {
     Data.Semigroup.Internal.$fShowDual_closure:
         const Data.Semigroup.Internal.$fShowDual_info;
         const 0;
 },
 sat_s6vcj_entry() //  [R1, R2, R3]
         { info_tbl: [(c6wkL,
                       label: sat_s6vcj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wkL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowDual_$cshowList_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vci_entry() //  [R1, R2]
         { info_tbl: [(c6wkT,
                       label: sat_s6vci_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wkT: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowDual_$cshow_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vch_entry() //  [R1, R2, R3]
         { info_tbl: [(c6wl1,
                       label: sat_s6vch_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wl1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowDual_$cshowsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowDual_entry() //  [R2]
         { info_tbl: [(c6wl5,
                       label: Data.Semigroup.Internal.$fShowDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wl5: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6wl9; else goto c6wl8;
       c6wl9: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wl8: // global
           I64[Hp - 72] = sat_s6vcj_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6vci_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6vch_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.459016354 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadDual5_bytes" {
     Data.Semigroup.Internal.$fReadDual5_bytes:
         I8[] [68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.459747282 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual4_closure" {
     Data.Semigroup.Internal.$fReadDual4_closure:
         const Data.Semigroup.Internal.$fReadDual4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadDual4_entry() //  [R1]
         { info_tbl: [(c6wlg,
                       label: Data.Semigroup.Internal.$fReadDual4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wlg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wlh; else goto c6wli;
       c6wlh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wli: // global
           (_c6wld::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wld::I64 == 0) goto c6wlf; else goto c6wle;
       c6wlf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wle: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wld::I64;
           R2 = Data.Semigroup.Internal.$fReadDual5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.460714508 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_lexeme_closure" {
     Data.Semigroup.Internal.$fReadDual_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadDual4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.461329751 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadDual3_bytes" {
     Data.Semigroup.Internal.$fReadDual3_bytes:
         I8[] [103,101,116,68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.462085392 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual2_closure" {
     Data.Semigroup.Internal.$fReadDual2_closure:
         const Data.Semigroup.Internal.$fReadDual2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadDual2_entry() //  [R1]
         { info_tbl: [(c6wlp,
                       label: Data.Semigroup.Internal.$fReadDual2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wlp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wlq; else goto c6wlr;
       c6wlq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wlr: // global
           (_c6wlm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wlm::I64 == 0) goto c6wlo; else goto c6wln;
       c6wlo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wln: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wlm::I64;
           R2 = Data.Semigroup.Internal.$fReadDual3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.464657032 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual1_closure" {
     Data.Semigroup.Internal.$fReadDual1_closure:
         const Data.Semigroup.Internal.$fReadDual1_info;
         const 0;
 },
 lvl12_s6vcl_entry() //  [R1]
         { info_tbl: [(c6wlA,
                       label: lvl12_s6vcl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wlA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wlB; else goto c6wlC;
       c6wlB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wlC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6vcm_entry() //  [R1]
         { info_tbl: [(c6wlI,
                       label: ds_s6vcm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wlI: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vcx_entry() //  [R1]
         { info_tbl: [(c6wmj,
                       label: sat_s6vcx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wmj: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vcA_entry() //  [R1, R2]
         { info_tbl: [(c6wmp,
                       label: sat_s6vcA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wmp: // global
           _s6vcv::P64 = R2;
           _s6vcA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6wmq; else goto c6wmr;
       c6wmr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wmt; else goto c6wms;
       c6wmt: // global
           HpAlloc = 24;
           goto c6wmq;
       c6wmq: // global
           R2 = _s6vcv::P64;
           R1 = _s6vcA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wms: // global
           _s6vcp::P64 = P64[_s6vcA::P64 + 7];
           I64[Hp - 16] = sat_s6vcx_info;
           P64[Hp - 8] = _s6vcp::P64;
           P64[Hp] = _s6vcv::P64;
           I64[Sp - 8] = block_c6wmm_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wmm() //  [R1]
         { info_tbl: [(c6wmm,
                       label: block_c6wmm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wmm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wmw; else goto c6wmv;
       c6wmw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wmv: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6wn8_srtd" {
     u6wn8_srtd:
         const S6vn0_srt+128;
         const 70;
         const 6597069766657;
         const 32;
 },
 sat_s6vcB_entry() //  [R1, R2]
         { info_tbl: [(c6wmx,
                       label: sat_s6vcB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wmx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wmB; else goto c6wmA;
       c6wmB: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wmA: // global
           _s6vcm::P64 = P64[R1 + 7];
           _s6vcp::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6vcA_info;
           P64[Hp] = _s6vcp::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6vcm::P64;
           R2 = Data.Semigroup.Internal.$fReadDual2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6wn9_srtd" {
     u6wn9_srtd:
         const S6vn0_srt+128;
         const 70;
         const 6597069766661;
         const 32;
 },
 sat_s6vcE_entry() //  [R1, R2]
         { info_tbl: [(c6wmF,
                       label: sat_s6vcE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wmF: // global
           _s6vct::P64 = R2;
           _s6vcE::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6wmG; else goto c6wmH;
       c6wmH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wmJ; else goto c6wmI;
       c6wmJ: // global
           HpAlloc = 24;
           goto c6wmG;
       c6wmG: // global
           R2 = _s6vct::P64;
           R1 = _s6vcE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wmI: // global
           _s6vcm::P64 = P64[_s6vcE::P64 + 7];
           _s6vcp::P64 = P64[_s6vcE::P64 + 15];
           I64[Hp - 16] = sat_s6vcB_info;
           P64[Hp - 8] = _s6vcm::P64;
           P64[Hp] = _s6vcp::P64;
           I64[Sp - 8] = block_c6wmC_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wmC() //  [R1]
         { info_tbl: [(c6wmC,
                       label: block_c6wmC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wmC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wmM; else goto c6wmL;
       c6wmM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wmL: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6wna_srtd" {
     u6wna_srtd:
         const S6vn0_srt+128;
         const 71;
         const 6597069766661;
         const 96;
 },
 sat_s6vcH_entry() //  [R1, R2, R3]
         { info_tbl: [(c6wmN,
                       label: sat_s6vcH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wmN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wmO; else goto c6wmP;
       c6wmO: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wmP: // global
           I64[Sp - 24] = block_c6wlQ_info;
           _s6vcm::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6vcm::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6wn2; else goto c6wlR;
       u6wn2: // global
           call _c6wlQ(R1) args: 0, res: 0, upd: 0;
       c6wlR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u6wnb_srtd" {
     u6wnb_srtd:
         const S6vn0_srt+128;
         const 71;
         const 6597069766661;
         const 96;
 },
 _c6wlQ() //  [R1]
         { info_tbl: [(c6wlQ,
                       label: block_c6wlQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wlQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wmS; else goto c6wmR;
       c6wmS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wmR: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6wmU; else goto c6wmY;
       c6wmU: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6wmY: // global
           I64[Hp - 16] = sat_s6vcE_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6wmV_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadDual_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wmV() //  [R1]
         { info_tbl: [(c6wmV,
                       label: block_c6wmV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wmV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wn1; else goto c6wn0;
       c6wn1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wn0: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6wnc_srtd" {
     u6wnc_srtd:
         const S6vn0_srt+128;
         const 72;
         const 7696581394437;
         const 224;
 },
 Data.Semigroup.Internal.$fReadDual1_entry() //  [R2]
         { info_tbl: [(c6wn3,
                       label: Data.Semigroup.Internal.$fReadDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wn3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6wn7; else goto c6wn6;
       c6wn7: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wn6: // global
           I64[Hp - 48] = lvl12_s6vcl_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6vcm_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6vcH_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.469829594 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadsPrec_info;
         const 0;
 },
 ds_s6vcJ_entry() //  [R1]
         { info_tbl: [(c6wnl,
                       label: ds_s6vcJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wnl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wnm; else goto c6wnn;
       c6wnm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wnn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcL_entry() //  [R1]
         { info_tbl: [(c6wnx,
                       label: sat_s6vcL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wnx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wny; else goto c6wnz;
       c6wny: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wnz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcM_entry() //  [R1, R2]
         { info_tbl: [(c6wnA,
                       label: sat_s6vcM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wnA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wnE; else goto c6wnD;
       c6wnE: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wnD: // global
           _s6vcJ::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6vcL_info;
           P64[Hp - 8] = _s6vcJ::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6wnF,
                       label: Data.Semigroup.Internal.$fReadDual_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wnF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6wnJ; else goto c6wnI;
       c6wnJ: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wnI: // global
           I64[Hp - 32] = ds_s6vcJ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6vcM_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.474569589 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadListPrec_info;
         const 0;
 },
 sat_s6vcO_entry() //  [R1]
         { info_tbl: [(c6wnS,
                       label: sat_s6vcO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wnS: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6wnV,
                       label: Data.Semigroup.Internal.$fReadDual_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wnV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wnZ; else goto c6wnY;
       c6wnZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wnY: // global
           I64[Hp - 16] = sat_s6vcO_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.476789731 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadList_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadList_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadList_info;
         const 0;
 },
 sat_s6vcQ_entry() //  [R1]
         { info_tbl: [(c6woc,
                       label: sat_s6vcQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6woc: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vcR_entry() //  [R1]
         { info_tbl: [(c6wof,
                       label: sat_s6vcR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wof: // global
           _s6vcR::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6wog; else goto c6woh;
       c6woh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6woj; else goto c6woi;
       c6woj: // global
           HpAlloc = 24;
           goto c6wog;
       c6wog: // global
           R1 = _s6vcR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6woi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vcR::P64;
           _s6vcP::P64 = P64[_s6vcR::P64 + 16];
           I64[Hp - 16] = sat_s6vcQ_info;
           P64[Hp] = _s6vcP::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadList_entry() //  [R2]
         { info_tbl: [(c6wok,
                       label: Data.Semigroup.Internal.$fReadDual_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wok: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6woo; else goto c6won;
       c6woo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6won: // global
           I64[Hp - 16] = sat_s6vcR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.480194116 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_closure" {
     Data.Semigroup.Internal.$fReadDual_closure:
         const Data.Semigroup.Internal.$fReadDual_info;
         const 0;
 },
 sat_s6vcW_entry() //  [R1]
         { info_tbl: [(c6wox,
                       label: sat_s6vcW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wox: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6woy; else goto c6woz;
       c6woy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6woz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcV_entry() //  [R1]
         { info_tbl: [(c6woE,
                       label: sat_s6vcV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6woE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6woF; else goto c6woG;
       c6woF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6woG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcU_entry() //  [R1]
         { info_tbl: [(c6woL,
                       label: sat_s6vcU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6woL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6woM; else goto c6woN;
       c6woM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6woN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcT_entry() //  [R1]
         { info_tbl: [(c6woS,
                       label: sat_s6vcT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6woS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6woT; else goto c6woU;
       c6woT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6woU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadDual_entry() //  [R2]
         { info_tbl: [(c6woW,
                       label: Data.Semigroup.Internal.$fReadDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6woW: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6wp0; else goto c6woZ;
       c6wp0: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6woZ: // global
           I64[Hp - 128] = sat_s6vcW_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6vcV_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6vcU_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6vcT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.484067472 UTC

[section ""data" . Data.Semigroup.Internal.$fEqDual_closure" {
     Data.Semigroup.Internal.$fEqDual_closure:
         const Data.Semigroup.Internal.$fEqDual_info;
 },
 sat_s6vcZ_entry() //  [R1]
         { info_tbl: [(c6wp9,
                       label: sat_s6vcZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wp9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wpa; else goto c6wpb;
       c6wpa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wpb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcY_entry() //  [R1]
         { info_tbl: [(c6wpg,
                       label: sat_s6vcY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wpg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wph; else goto c6wpi;
       c6wph: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wpi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqDual_entry() //  [R2]
         { info_tbl: [(c6wpk,
                       label: Data.Semigroup.Internal.$fEqDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wpk: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6wpo; else goto c6wpn;
       c6wpo: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wpn: // global
           I64[Hp - 64] = sat_s6vcZ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6vcY_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.486820756 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdDual_$cp1Ord_info;
 },
 sat_s6vd1_entry() //  [R1]
         { info_tbl: [(c6wpx,
                       label: sat_s6vd1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wpx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wpy; else goto c6wpz;
       c6wpy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wpz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdDual_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6wpA,
                       label: Data.Semigroup.Internal.$fOrdDual_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wpA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wpE; else goto c6wpD;
       c6wpE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wpD: // global
           I64[Hp - 16] = sat_s6vd1_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqDual_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.490377846 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdDual_closure" {
     Data.Semigroup.Internal.$fOrdDual_closure:
         const Data.Semigroup.Internal.$fOrdDual_info;
 },
 sat_s6vda_entry() //  [R1]
         { info_tbl: [(c6wpN,
                       label: sat_s6vda_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wpN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wpO; else goto c6wpP;
       c6wpO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wpP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd9_entry() //  [R1]
         { info_tbl: [(c6wpU,
                       label: sat_s6vd9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wpU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wpV; else goto c6wpW;
       c6wpV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wpW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd8_entry() //  [R1]
         { info_tbl: [(c6wq1,
                       label: sat_s6vd8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wq1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wq2; else goto c6wq3;
       c6wq2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wq3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd7_entry() //  [R1]
         { info_tbl: [(c6wq8,
                       label: sat_s6vd7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wq8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wq9; else goto c6wqa;
       c6wq9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wqa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd6_entry() //  [R1]
         { info_tbl: [(c6wqf,
                       label: sat_s6vd6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wqf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wqg; else goto c6wqh;
       c6wqg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wqh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd5_entry() //  [R1]
         { info_tbl: [(c6wqm,
                       label: sat_s6vd5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wqm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wqn; else goto c6wqo;
       c6wqn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wqo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd4_entry() //  [R1]
         { info_tbl: [(c6wqt,
                       label: sat_s6vd4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wqt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wqu; else goto c6wqv;
       c6wqu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wqv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd3_entry() //  [R1]
         { info_tbl: [(c6wqA,
                       label: sat_s6vd3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wqA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wqB; else goto c6wqC;
       c6wqB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wqC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdDual_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdDual_entry() //  [R2]
         { info_tbl: [(c6wqE,
                       label: Data.Semigroup.Internal.$fOrdDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wqE: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6wqI; else goto c6wqH;
       c6wqI: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wqH: // global
           I64[Hp - 256] = sat_s6vda_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6vd9_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6vd8_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6vd7_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6vd6_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6vd5_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6vd4_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6vd3_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.495693505 UTC

[section ""data" . Data.Semigroup.Internal.getDual_closure" {
     Data.Semigroup.Internal.getDual_closure:
         const Data.Semigroup.Internal.getDual_info;
 },
 Data.Semigroup.Internal.getDual_entry() //  [R2]
         { info_tbl: [(c6wqN,
                       label: Data.Semigroup.Internal.getDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wqN: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Dual2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.496849997 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadDual_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadDual_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadDual_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6wqU,
                       label: Data.Semigroup.Internal.$fMonadDual_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wqU: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.498204243 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadDual_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadDual_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadDual_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6wr1,
                       label: Data.Semigroup.Internal.$fMonadDual_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wr1: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeDual_$c*>_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.49955726 UTC

[section ""data" . lvl_r6v16_closure" {
     lvl_r6v16_closure:
         const lvl_r6v16_info;
         const 0;
 },
 lvl_r6v16_entry() //  [R2]
         { info_tbl: [(c6wr8,
                       label: lvl_r6v16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wr8: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.500694057 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_closure" {
     Data.Semigroup.Internal.$fMonadDual_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeDual_closure+1;
         const Data.Semigroup.Internal.$fMonadDual_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadDual_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl_r6v16_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.501872705 UTC

[section ""data" . Data.Semigroup.Internal.appEndo1_closure" {
     Data.Semigroup.Internal.appEndo1_closure:
         const Data.Semigroup.Internal.appEndo1_info;
 },
 Data.Semigroup.Internal.appEndo1_entry() //  [R2]
         { info_tbl: [(c6wrf,
                       label: Data.Semigroup.Internal.appEndo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wrf: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.503038381 UTC

[section ""data" . Data.Semigroup.Internal.appEndo_closure" {
     Data.Semigroup.Internal.appEndo_closure:
         const Data.Semigroup.Internal.appEndo_info;
 },
 Data.Semigroup.Internal.appEndo_entry() //  [R2]
         { info_tbl: [(c6wrm,
                       label: Data.Semigroup.Internal.appEndo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wrm: // global
           R2 = R2;
           call Data.Semigroup.Internal.appEndo1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.504420555 UTC

[section ""data" . Data.Semigroup.Internal.getAll1_closure" {
     Data.Semigroup.Internal.getAll1_closure:
         const Data.Semigroup.Internal.getAll1_info;
 },
 Data.Semigroup.Internal.getAll1_entry() //  [R2]
         { info_tbl: [(c6wrt,
                       label: Data.Semigroup.Internal.getAll1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wrt: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.505728247 UTC

[section ""data" . Data.Semigroup.Internal.getAll_closure" {
     Data.Semigroup.Internal.getAll_closure:
         const Data.Semigroup.Internal.getAll_info;
 },
 Data.Semigroup.Internal.getAll_entry() //  [R2]
         { info_tbl: [(c6wrA,
                       label: Data.Semigroup.Internal.getAll_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wrA: // global
           R2 = R2;
           call Data.Semigroup.Internal.getAll1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.506993131 UTC

[section ""data" . Data.Semigroup.Internal.getAny1_closure" {
     Data.Semigroup.Internal.getAny1_closure:
         const Data.Semigroup.Internal.getAny1_info;
 },
 Data.Semigroup.Internal.getAny1_entry() //  [R2]
         { info_tbl: [(c6wrH,
                       label: Data.Semigroup.Internal.getAny1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wrH: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.508342473 UTC

[section ""data" . Data.Semigroup.Internal.getAny_closure" {
     Data.Semigroup.Internal.getAny_closure:
         const Data.Semigroup.Internal.getAny_info;
 },
 Data.Semigroup.Internal.getAny_entry() //  [R2]
         { info_tbl: [(c6wrO,
                       label: Data.Semigroup.Internal.getAny_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wrO: // global
           R2 = R2;
           call Data.Semigroup.Internal.getAny1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.509852094 UTC

[section ""data" . Data.Semigroup.Internal.getSum_closure" {
     Data.Semigroup.Internal.getSum_closure:
         const Data.Semigroup.Internal.getSum_info;
 },
 Data.Semigroup.Internal.getSum_entry() //  [R2]
         { info_tbl: [(c6wrV,
                       label: Data.Semigroup.Internal.getSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wrV: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Sum2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.511225584 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadSum_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadSum_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadSum_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6ws2,
                       label: Data.Semigroup.Internal.$fMonadSum_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ws2: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.512660599 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadSum_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadSum_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadSum_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6ws9,
                       label: Data.Semigroup.Internal.$fMonadSum_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ws9: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeSum_$c*>_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.514009781 UTC

[section ""data" . lvl1_r6v17_closure" {
     lvl1_r6v17_closure:
         const lvl1_r6v17_info;
         const 0;
 },
 lvl1_r6v17_entry() //  [R2]
         { info_tbl: [(c6wsg,
                       label: lvl1_r6v17_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wsg: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.515291949 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_closure" {
     Data.Semigroup.Internal.$fMonadSum_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeSum_closure+1;
         const Data.Semigroup.Internal.$fMonadSum_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadSum_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl1_r6v17_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.516501873 UTC

[section ""data" . Data.Semigroup.Internal.getProduct_closure" {
     Data.Semigroup.Internal.getProduct_closure:
         const Data.Semigroup.Internal.getProduct_info;
 },
 Data.Semigroup.Internal.getProduct_entry() //  [R2]
         { info_tbl: [(c6wsn,
                       label: Data.Semigroup.Internal.getProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wsn: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Product2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.518600258 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadProduct_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadProduct_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6wsu,
                       label: Data.Semigroup.Internal.$fMonadProduct_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wsu: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.51944251 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadProduct_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadProduct_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadProduct_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6wsB,
                       label: Data.Semigroup.Internal.$fMonadProduct_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wsB: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeProduct_$c*>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.520277784 UTC

[section ""data" . lvl2_r6v18_closure" {
     lvl2_r6v18_closure:
         const lvl2_r6v18_info;
         const 0;
 },
 lvl2_r6v18_entry() //  [R2]
         { info_tbl: [(c6wsI,
                       label: lvl2_r6v18_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wsI: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.521018239 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_closure" {
     Data.Semigroup.Internal.$fMonadProduct_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeProduct_closure+1;
         const Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadProduct_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl2_r6v18_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.521807265 UTC

[section ""data" . Data.Semigroup.Internal.getAlt_closure" {
     Data.Semigroup.Internal.getAlt_closure:
         const Data.Semigroup.Internal.getAlt_info;
 },
 Data.Semigroup.Internal.getAlt_entry() //  [R2]
         { info_tbl: [(c6wsP,
                       label: Data.Semigroup.Internal.getAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wsP: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Alt2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.522482904 UTC

[section ""cstring" . lvl3_r6v19_bytes" {
     lvl3_r6v19_bytes:
         I8[] [115,116,105,109,101,115,73,100,101,109,112,111,116,101,110,116,58,32,112,111,115,105,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114,32,101,120,112,101,99,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.523340733 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotent1_closure" {
     Data.Semigroup.Internal.stimesIdempotent1_closure:
         const Data.Semigroup.Internal.stimesIdempotent1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesIdempotent1_entry() //  [R1]
         { info_tbl: [(c6wt0,
                       label: Data.Semigroup.Internal.stimesIdempotent1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wt0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wt1; else goto c6wt2;
       c6wt1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wt2: // global
           (_c6wsV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wsV::I64 == 0) goto c6wsX; else goto c6wsW;
       c6wsX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wsW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wsV::I64;
           I64[Sp - 24] = block_c6wsY_info;
           R2 = lvl3_r6v19_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wsY() //  [R1]
         { info_tbl: [(c6wsY,
                       label: block_c6wsY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wsY: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.525061338 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotent_closure" {
     Data.Semigroup.Internal.stimesIdempotent_closure:
         const Data.Semigroup.Internal.stimesIdempotent_info;
         const 0;
 },
 sat_s6vdu_entry() //  [R1]
         { info_tbl: [(c6wtk,
                       label: sat_s6vdu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wtk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wtl; else goto c6wtm;
       c6wtl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wtm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6wti_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wti() //  [R1]
         { info_tbl: [(c6wti,
                       label: block_c6wti_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wti: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesIdempotent_entry() //  [R2, R3, R4]
         { info_tbl: [(c6wtq,
                       label: Data.Semigroup.Internal.stimesIdempotent_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wtq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wts; else goto c6wtt;
       c6wts: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotent_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wtt: // global
           I64[Sp - 24] = block_c6wta_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wta() //  [R1]
         { info_tbl: [(c6wta,
                       label: block_c6wta_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wta: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wtw; else goto c6wtv;
       c6wtw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wtv: // global
           I64[Hp - 16] = sat_s6vdu_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6wtr_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wtr() //  [R1]
         { info_tbl: [(c6wtr,
                       label: block_c6wtr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wtr: // global
           _s6vdp::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c6wtA_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s6vdp::P64;
           Sp = Sp - 8;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6wtA() //  [R1]
         { info_tbl: [(c6wtA,
                       label: block_c6wtA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wtA: // global
           if (R1 & 7 == 1) goto c6wtH; else goto c6wtL;
       c6wtH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wtL: // global
           R1 = Data.Semigroup.Internal.stimesIdempotent1_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.526900343 UTC

[section ""cstring" . lvl4_r6v1a_bytes" {
     lvl4_r6v1a_bytes:
         I8[] [115,116,105,109,101,115,73,100,101,109,112,111,116,101,110,116,77,111,110,111,105,100,58,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.527726981 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotentMonoid1_closure" {
     Data.Semigroup.Internal.stimesIdempotentMonoid1_closure:
         const Data.Semigroup.Internal.stimesIdempotentMonoid1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesIdempotentMonoid1_entry() //  [R1]
         { info_tbl: [(c6wtV,
                       label: Data.Semigroup.Internal.stimesIdempotentMonoid1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wtV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wtW; else goto c6wtX;
       c6wtW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wtX: // global
           (_c6wtQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wtQ::I64 == 0) goto c6wtS; else goto c6wtR;
       c6wtS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wtR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wtQ::I64;
           I64[Sp - 24] = block_c6wtT_info;
           R2 = lvl4_r6v1a_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wtT() //  [R1]
         { info_tbl: [(c6wtT,
                       label: block_c6wtT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wtT: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.529460391 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotentMonoid_closure" {
     Data.Semigroup.Internal.stimesIdempotentMonoid_closure:
         const Data.Semigroup.Internal.stimesIdempotentMonoid_info;
         const 0;
 },
 sat_s6vdE_entry() //  [R1]
         { info_tbl: [(c6wuf,
                       label: sat_s6vdE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wuf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wug; else goto c6wuh;
       c6wug: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wuh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6wud_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wud() //  [R1]
         { info_tbl: [(c6wud,
                       label: block_c6wud_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wud: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesIdempotentMonoid_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(c6wul,
                       label: Data.Semigroup.Internal.stimesIdempotentMonoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wul: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c6wun; else goto c6wuo;
       c6wun: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wuo: // global
           I64[Sp - 32] = block_c6wu5_info;
           R2 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wu5() //  [R1]
         { info_tbl: [(c6wu5,
                       label: block_c6wu5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wu5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wur; else goto c6wuq;
       c6wur: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wuq: // global
           I64[Hp - 16] = sat_s6vdE_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6wum_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wum() //  [R1]
         { info_tbl: [(c6wum,
                       label: block_c6wum_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wum: // global
           _c6wu9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6wuv_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = _c6wu9::P64;
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6wuv() //  [R1]
         { info_tbl: [(c6wuv,
                       label: block_c6wuv_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wuv: // global
           _c6wuL::P64 = R1 & 7;
           if (_c6wuL::P64 < 3) goto u6wuM; else goto c6wuK;
       u6wuM: // global
           if (_c6wuL::P64 < 2) goto c6wuC; else goto c6wuG;
       c6wuC: // global
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid1_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wuG: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
       c6wuK: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.531859403 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_go_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_go_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_go_info;
 },
 Data.Semigroup.Internal.$fSemigroupAny_go_entry() //  [R2, R3]
         { info_tbl: [(c6wuY,
                       label: Data.Semigroup.Internal.$fSemigroupAny_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wuY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wuZ; else goto u6wvk;
       c6wuZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAny_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6wvk: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6wuO() args: 0, res: 0, upd: 0;
     }
 },
 _c6wuO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wuO: // global
           I64[Sp - 8] = block_c6wuR_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6wvm; else goto c6wuS;
       u6wvm: // global
           call _c6wuR(R1) args: 0, res: 0, upd: 0;
       c6wuS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wuR() //  [R1]
         { info_tbl: [(c6wuR,
                       label: block_c6wuR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wuR: // global
           _s6vdG::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6wuV; else goto c6wuW;
       c6wuV: // global
           R1 = _s6vdG::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6wuW: // global
           I64[Sp] = block_c6wv6_info;
           _s6vdJ::P64 = P64[R1 + 6];
           _s6vdK::P64 = P64[R1 + 14];
           R1 = _s6vdG::P64;
           P64[Sp + 8] = _s6vdK::P64;
           P64[Sp + 16] = _s6vdJ::P64;
           if (R1 & 7 != 0) goto u6wvn; else goto c6wv8;
       u6wvn: // global
           call _c6wv6(R1) args: 0, res: 0, upd: 0;
       c6wv8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wv6() //  [R1]
         { info_tbl: [(c6wv6,
                       label: block_c6wv6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wv6: // global
           if (R1 & 7 == 1) goto c6wve; else goto c6wvi;
       c6wve: // global
           _s6vdH::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6vdH::P64;
           Sp = Sp + 8;
           call _c6wuO() args: 0, res: 0, upd: 0;
       c6wvi: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.533621034 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAny_$csconcat_entry() //  [R2]
         { info_tbl: [(c6wvx,
                       label: Data.Semigroup.Internal.$fSemigroupAny_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wvx: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6wvy; else goto c6wvz;
       c6wvy: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wvz: // global
           I64[Sp - 8] = block_c6wvu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6wvD; else goto c6wvv;
       u6wvD: // global
           call _c6wvu(R1) args: 0, res: 0, upd: 0;
       c6wvv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wvu() //  [R1]
         { info_tbl: [(c6wvu,
                       label: block_c6wvu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wvu: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupAny_go_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.53508867 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAny_go_closure" {
     Data.Semigroup.Internal.$fMonoidAny_go_closure:
         const Data.Semigroup.Internal.$fMonoidAny_go_info;
 },
 Data.Semigroup.Internal.$fMonoidAny_go_entry() //  [R2]
         { info_tbl: [(c6wvP,
                       label: Data.Semigroup.Internal.$fMonoidAny_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wvP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wvQ; else goto u6wwb;
       c6wvQ: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAny_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6wwb: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6wvF() args: 0, res: 0, upd: 0;
     }
 },
 _c6wvF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wvF: // global
           _s6vdQ::P64 = P64[Sp];
           I64[Sp] = block_c6wvI_info;
           R1 = _s6vdQ::P64;
           if (R1 & 7 != 0) goto u6wwd; else goto c6wvJ;
       u6wwd: // global
           call _c6wvI(R1) args: 0, res: 0, upd: 0;
       c6wvJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wvI() //  [R1]
         { info_tbl: [(c6wvI,
                       label: block_c6wvI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wvI: // global
           if (R1 & 7 == 1) goto c6wvM; else goto c6wvN;
       c6wvM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6wvN: // global
           I64[Sp - 8] = block_c6wvX_info;
           _s6vdT::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6vdT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6wwe; else goto c6wvZ;
       u6wwe: // global
           call _c6wvX(R1) args: 0, res: 0, upd: 0;
       c6wvZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wvX() //  [R1]
         { info_tbl: [(c6wvX,
                       label: block_c6wvX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wvX: // global
           if (R1 & 7 == 1) goto c6ww5; else goto c6ww9;
       c6ww5: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6wvF() args: 0, res: 0, upd: 0;
       c6ww9: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.536662019 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Classes.||_closure+2;
         const Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAny_closure" {
     Data.Semigroup.Internal.$fMonoidAny_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupAny_closure+1;
         const GHC.Types.False_closure+1;
         const GHC.Classes.||_closure+2;
         const Data.Semigroup.Internal.$fMonoidAny_go_closure+1;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupAny_$cstimes_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(c6wwl,
                       label: Data.Semigroup.Internal.$fSemigroupAny_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wwl: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidAny_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.538086058 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_go_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_go_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_go_info;
 },
 Data.Semigroup.Internal.$fSemigroupAll_go_entry() //  [R2, R3]
         { info_tbl: [(c6wwz,
                       label: Data.Semigroup.Internal.$fSemigroupAll_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wwz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wwA; else goto u6wwV;
       c6wwA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAll_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6wwV: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6wwp() args: 0, res: 0, upd: 0;
     }
 },
 _c6wwp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wwp: // global
           I64[Sp - 8] = block_c6wws_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6wwX; else goto c6wwt;
       u6wwX: // global
           call _c6wws(R1) args: 0, res: 0, upd: 0;
       c6wwt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wws() //  [R1]
         { info_tbl: [(c6wws,
                       label: block_c6wws_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wws: // global
           _s6vdW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6www; else goto c6wwx;
       c6www: // global
           R1 = _s6vdW::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6wwx: // global
           I64[Sp] = block_c6wwH_info;
           _s6vdZ::P64 = P64[R1 + 6];
           _s6ve0::P64 = P64[R1 + 14];
           R1 = _s6vdW::P64;
           P64[Sp + 8] = _s6ve0::P64;
           P64[Sp + 16] = _s6vdZ::P64;
           if (R1 & 7 != 0) goto u6wwY; else goto c6wwJ;
       u6wwY: // global
           call _c6wwH(R1) args: 0, res: 0, upd: 0;
       c6wwJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wwH() //  [R1]
         { info_tbl: [(c6wwH,
                       label: block_c6wwH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wwH: // global
           if (R1 & 7 == 1) goto c6wwP; else goto c6wwT;
       c6wwP: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6wwT: // global
           _s6vdX::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6vdX::P64;
           Sp = Sp + 8;
           call _c6wwp() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.539826376 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAll_$csconcat_entry() //  [R2]
         { info_tbl: [(c6wx8,
                       label: Data.Semigroup.Internal.$fSemigroupAll_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wx8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6wx9; else goto c6wxa;
       c6wx9: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wxa: // global
           I64[Sp - 8] = block_c6wx5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6wxe; else goto c6wx6;
       u6wxe: // global
           call _c6wx5(R1) args: 0, res: 0, upd: 0;
       c6wx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wx5() //  [R1]
         { info_tbl: [(c6wx5,
                       label: block_c6wx5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wx5: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupAll_go_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.541456932 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAll_go_closure" {
     Data.Semigroup.Internal.$fMonoidAll_go_closure:
         const Data.Semigroup.Internal.$fMonoidAll_go_info;
 },
 Data.Semigroup.Internal.$fMonoidAll_go_entry() //  [R2]
         { info_tbl: [(c6wxq,
                       label: Data.Semigroup.Internal.$fMonoidAll_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wxq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wxr; else goto u6wxM;
       c6wxr: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAll_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6wxM: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6wxg() args: 0, res: 0, upd: 0;
     }
 },
 _c6wxg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wxg: // global
           _s6ve6::P64 = P64[Sp];
           I64[Sp] = block_c6wxj_info;
           R1 = _s6ve6::P64;
           if (R1 & 7 != 0) goto u6wxO; else goto c6wxk;
       u6wxO: // global
           call _c6wxj(R1) args: 0, res: 0, upd: 0;
       c6wxk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wxj() //  [R1]
         { info_tbl: [(c6wxj,
                       label: block_c6wxj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wxj: // global
           if (R1 & 7 == 1) goto c6wxn; else goto c6wxo;
       c6wxn: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6wxo: // global
           I64[Sp - 8] = block_c6wxy_info;
           _s6ve9::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6ve9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6wxP; else goto c6wxA;
       u6wxP: // global
           call _c6wxy(R1) args: 0, res: 0, upd: 0;
       c6wxA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wxy() //  [R1]
         { info_tbl: [(c6wxy,
                       label: block_c6wxy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wxy: // global
           if (R1 & 7 == 1) goto c6wxG; else goto c6wxK;
       c6wxG: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6wxK: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6wxg() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.543133831 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Classes.&&_closure+2;
         const Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAll_closure" {
     Data.Semigroup.Internal.$fMonoidAll_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupAll_closure+1;
         const GHC.Types.True_closure+2;
         const GHC.Classes.&&_closure+2;
         const Data.Semigroup.Internal.$fMonoidAll_go_closure+1;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupAll_$cstimes_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(c6wxW,
                       label: Data.Semigroup.Internal.$fSemigroupAll_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wxW: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidAll_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.545064239 UTC

[section ""cstring" . lvl5_r6v1b_bytes" {
     lvl5_r6v1b_bytes:
         I8[] [115,116,105,109,101,115,77,111,110,111,105,100,58,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.545928741 UTC

[section ""data" . lvl6_r6v1c_closure" {
     lvl6_r6v1c_closure:
         const lvl6_r6v1c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r6v1c_entry() //  [R1]
         { info_tbl: [(c6wy7,
                       label: lvl6_r6v1c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wy7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wy8; else goto c6wy9;
       c6wy8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wy9: // global
           (_c6wy2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wy2::I64 == 0) goto c6wy4; else goto c6wy3;
       c6wy4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wy3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wy2::I64;
           I64[Sp - 24] = block_c6wy5_info;
           R2 = lvl5_r6v1b_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wy5() //  [R1]
         { info_tbl: [(c6wy5,
                       label: block_c6wy5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wy5: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.547001918 UTC

[section ""data" . sat_s6ved_closure" {
     sat_s6ved_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.547599176 UTC

[section ""data" . sat_s6vee_closure" {
     sat_s6vee_closure:
         const :_con_info;
         const sat_s6ved_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.548361958 UTC

[section ""data" . lvl7_r6v1d_closure" {
     lvl7_r6v1d_closure:
         const lvl7_r6v1d_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r6v1d_entry() //  [R1]
         { info_tbl: [(c6wyj,
                       label: lvl7_r6v1d_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wyj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wyk; else goto c6wyl;
       c6wyk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wyl: // global
           (_c6wyg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wyg::I64 == 0) goto c6wyi; else goto c6wyh;
       c6wyi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wyh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wyg::I64;
           R3 = sat_s6vee_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.552823373 UTC

[section ""data" . Data.Semigroup.Internal.stimesMonoid_closure" {
     Data.Semigroup.Internal.stimesMonoid_closure:
         const Data.Semigroup.Internal.stimesMonoid_info;
         const 0;
 },
 sat_s6vem_entry() //  [R1]
         { info_tbl: [(c6wzN,
                       label: sat_s6vem_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wzN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wzO; else goto c6wzP;
       c6wzO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wzP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6wzL_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wzL() //  [R1]
         { info_tbl: [(c6wzL,
                       label: block_c6wzL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wzL: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s6veo_entry() //  [R1]
         { info_tbl: [(c6wzV,
                       label: $dNum_s6veo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wzV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wzW; else goto c6wzX;
       c6wzW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wzX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_s6vep_entry() //  [R1]
         { info_tbl: [(c6wA0,
                       label: lvl12_s6vep_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wA0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wA1; else goto c6wA2;
       c6wA1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wA2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl7_r6v1d_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6vev_entry() //  [R1]
         { info_tbl: [(c6wA5,
                       label: lvl13_s6vev_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wA5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wA6; else goto c6wA7;
       c6wA6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wA7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6veM_entry() //  [R1]
         { info_tbl: [(c6wAa,
                       label: sat_s6veM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wAa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wAb; else goto c6wAc;
       c6wAb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wAc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veL_entry() //  [R1]
         { info_tbl: [(c6wAf,
                       label: sat_s6veL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wAf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wAg; else goto c6wAh;
       c6wAg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wAh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6ver::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6ver::P64;
           P64[Sp - 24] = _s6ver::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veI_entry() //  [R1]
         { info_tbl: [(c6wAk,
                       label: sat_s6veI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wAk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wAl; else goto c6wAm;
       c6wAl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wAm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veH_entry() //  [R1]
         { info_tbl: [(c6wAp,
                       label: sat_s6veH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wAp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wAq; else goto c6wAr;
       c6wAq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wAr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veG_entry() //  [R1]
         { info_tbl: [(c6wAv,
                       label: sat_s6veG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wAv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wAw; else goto c6wAx;
       c6wAw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wAx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6veB::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6veB::P64;
           P64[Sp - 24] = _s6veB::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veK_entry() //  [R1]
         { info_tbl: [(c6wAA,
                       label: sat_s6veK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wAA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wAB; else goto c6wAC;
       c6wAB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wAC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veJ_entry() //  [R1]
         { info_tbl: [(c6wAG,
                       label: sat_s6veJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wAG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wAH; else goto c6wAI;
       c6wAH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wAI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6veB::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6veB::P64;
           P64[Sp - 24] = _s6veB::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veS_entry() //  [R1]
         { info_tbl: [(c6wAL,
                       label: sat_s6veS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wAL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wAM; else goto c6wAN;
       c6wAM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wAN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veR_entry() //  [R1]
         { info_tbl: [(c6wAR,
                       label: sat_s6veR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wAR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wAS; else goto c6wAT;
       c6wAS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wAT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6veO::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6veO::P64;
           P64[Sp - 24] = _s6veO::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesMonoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6wAU,
                       label: Data.Semigroup.Internal.stimesMonoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wAU: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c6wAV; else goto c6wAW;
       c6wAV: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMonoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wAW: // global
           I64[Sp - 40] = block_c6wyq_info;
           _s6vef::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s6vef::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wyq() //  [R1]
         { info_tbl: [(c6wyq,
                       label: block_c6wyq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wyq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wAZ; else goto c6wAY;
       c6wAZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wAY: // global
           I64[Hp - 16] = sat_s6vem_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c6wyw_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wyw() //  [R1]
         { info_tbl: [(c6wyw,
                       label: block_c6wyw_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wyw: // global
           I64[Sp] = block_c6wyA_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6wyA() //  [R1]
         { info_tbl: [(c6wyA,
                       label: block_c6wyA_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wyA: // global
           _c6wBU::P64 = R1 & 7;
           if (_c6wBU::P64 < 3) goto u6wBZ; else goto c6wB8;
       u6wBZ: // global
           if (_c6wBU::P64 < 2) goto c6wB4; else goto c6wB7;
       c6wB4: // global
           R1 = lvl6_r6v1c_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wB7: // global
           R2 = P64[Sp + 32];
           Sp = Sp + 56;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
       c6wB8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6wBb; else goto c6wBa;
       c6wBb: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wBa: // global
           I64[Hp - 40] = $dNum_s6veo_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = lvl12_s6vep_info;
           _c6wyG::P64 = Hp - 40;
           P64[Hp] = _c6wyG::P64;
           P64[Sp] = P64[Sp + 40];
           P64[Sp + 16] = P64[Sp + 48];
           P64[Sp + 40] = Hp - 16;
           P64[Sp + 48] = _c6wyG::P64;
           call _c6wzz() args: 0, res: 0, upd: 0;
     }
 },
 _c6wzz() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wzz: // global
           I64[Sp - 8] = block_c6wzB_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wzB() //  [R1]
         { info_tbl: [(c6wzB,
                       label: block_c6wzB_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wzB: // global
           _s6veO::P64 = P64[Sp + 24];
           _s6veP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6wBP; else goto c6wBQ;
       c6wBP: // global
           I64[Sp + 8] = block_c6wyP_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s6veP::P64;
           P64[Sp + 24] = _s6veO::P64;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c6wBQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6wBT; else goto c6wBS;
       c6wBT: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wBS: // global
           I64[Hp - 64] = sat_s6veS_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s6veP::P64;
           I64[Hp - 24] = sat_s6veR_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6veO::P64;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c6wzz() args: 0, res: 0, upd: 0;
     }
 },
 _c6wyP() //  [R1]
         { info_tbl: [(c6wyP,
                       label: block_c6wyP_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wyP: // global
           I64[Sp] = block_c6wyT_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wyT() //  [R1]
         { info_tbl: [(c6wyT,
                       label: block_c6wyT_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wyT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wBg; else goto c6wBf;
       c6wBg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wBf: // global
           I64[Hp - 16] = lvl13_s6vev_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp - 8] = block_c6wyZ_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c6wyX::P64 = Hp - 16;
           P64[Sp - 16] = _c6wyX::P64;
           P64[Sp] = R1;
           P64[Sp + 48] = _c6wyX::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6wyZ() //  [R1]
         { info_tbl: [(c6wyZ,
                       label: block_c6wyZ_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wyZ: // global
           _s6ver::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6wBi; else goto c6wBK;
       c6wBi: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6wBl; else goto c6wBk;
       c6wBl: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wBk: // global
           I64[Hp - 64] = sat_s6veM_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s6veL_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6ver::P64;
           P64[Sp] = _s6ver::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 24] = Hp - 24;
           call _c6wzc() args: 0, res: 0, upd: 0;
       c6wBK: // global
           R1 = _s6ver::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6wzc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wzc: // global
           I64[Sp - 8] = block_c6wze_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wze() //  [R1]
         { info_tbl: [(c6wze,
                       label: block_c6wze_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wze: // global
           _s6veC::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6wBt; else goto c6wBD;
       c6wBt: // global
           I64[Sp] = block_c6wzi_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s6veC::P64;
           P64[Sp - 8] = P64[Sp + 64];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c6wBD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6wBG; else goto c6wBF;
       c6wBG: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wBF: // global
           I64[Hp - 64] = sat_s6veK_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s6veC::P64;
           I64[Hp - 24] = sat_s6veJ_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6wzc() args: 0, res: 0, upd: 0;
     }
 },
 _c6wzi() //  [R1]
         { info_tbl: [(c6wzi,
                       label: block_c6wzi_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wzi: // global
           _s6veg::P64 = P64[Sp + 48];
           _s6veB::P64 = P64[Sp + 32];
           _s6veD::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6wBv; else goto c6wBC;
       c6wBv: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c6wBy; else goto c6wBx;
       c6wBy: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wBx: // global
           I64[Hp - 104] = sat_s6veI_info;
           P64[Hp - 88] = _s6veg::P64;
           P64[Hp - 80] = _s6veB::P64;
           P64[Hp - 72] = _s6veD::P64;
           I64[Hp - 64] = sat_s6veH_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s6veG_info;
           P64[Hp - 8] = _s6veg::P64;
           P64[Hp] = _s6veB::P64;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c6wzc() args: 0, res: 0, upd: 0;
       c6wBC: // global
           R2 = _s6veg::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s6veB::P64;
           P64[Sp + 64] = _s6veD::P64;
           Sp = Sp + 48;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.561386712 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat_closure" {
     Data.Semigroup.Internal.$w$csconcat_closure:
         const Data.Semigroup.Internal.$w$csconcat_info;
 },
 go_s6veW_entry() //  [R1, R2, R3]
         { info_tbl: [(c6wCq,
                       label: go_s6veW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wCq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wCr; else goto c6wCs;
       c6wCr: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wCs: // global
           I64[Sp - 32] = block_c6wCj_info;
           _s6veW::P64 = R1;
           _s6veT::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6veT::P64;
           P64[Sp - 16] = _s6veW::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wCC; else goto c6wCk;
       u6wCC: // global
           call _c6wCj(R1) args: 0, res: 0, upd: 0;
       c6wCk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wCj() //  [R1]
         { info_tbl: [(c6wCj,
                       label: block_c6wCj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wCj: // global
           _s6veX::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6wCn; else goto c6wCo;
       c6wCn: // global
           R1 = _s6veX::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wCo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6wCA; else goto c6wCz;
       c6wCA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wCz: // global
           _s6vf0::P64 = P64[R1 + 6];
           _s6vf1::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6vf0::P64;
           P64[Hp] = _s6vf1::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6veX::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c6wCD,
                       label: Data.Semigroup.Internal.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wCD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wCH; else goto c6wCG;
       c6wCH: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wCG: // global
           I64[Hp - 8] = go_s6veW_info;
           P64[Hp] = R2;
           _s6veU::P64 = R3;
           R3 = R4;
           R2 = _s6veU::P64;
           R1 = Hp - 6;
           call go_s6veW_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.563291809 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c6wCP,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wCP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wCQ; else goto c6wCR;
       c6wCQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wCR: // global
           I64[Sp - 16] = block_c6wCM_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6wCV; else goto c6wCN;
       u6wCV: // global
           call _c6wCM(R1) args: 0, res: 0, upd: 0;
       c6wCN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wCM() //  [R1]
         { info_tbl: [(c6wCM,
                       label: block_c6wCM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wCM: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.565052227 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_info;
 },
 z_s6vfa_entry() //  [R1]
         { info_tbl: [(c6wD4,
                       label: z_s6vfa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wD4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wD5; else goto c6wD6;
       c6wD5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wD6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s6vfb_entry() //  [R1, R2]
         { info_tbl: [(c6wDj,
                       label: go_s6vfb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wDj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wDk; else goto c6wDl;
       c6wDk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wDl: // global
           I64[Sp - 32] = block_c6wDc_info;
           _s6vfb::P64 = R1;
           _s6vf8::P64 = P64[R1 + 7];
           _s6vfa::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6vf8::P64;
           P64[Sp - 16] = _s6vfa::P64;
           P64[Sp - 8] = _s6vfb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wDv; else goto c6wDd;
       u6wDv: // global
           call _c6wDc(R1) args: 0, res: 0, upd: 0;
       c6wDd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wDc() //  [R1]
         { info_tbl: [(c6wDc,
                       label: block_c6wDc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wDc: // global
           if (R1 & 7 == 1) goto c6wDg; else goto c6wDh;
       c6wDg: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wDh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wDt; else goto c6wDs;
       c6wDt: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wDs: // global
           _s6vfe::P64 = P64[R1 + 6];
           _s6vff::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6vff::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6vfe::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c6wDw,
                       label: Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wDw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6wDA; else goto c6wDz;
       c6wDA: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wDz: // global
           I64[Hp - 40] = z_s6vfa_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6vfb_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s6vfb_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.568247188 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_info;
         const 0;
 },
 sat_s6vfk_entry() //  [R1, R2]
         { info_tbl: [(c6wDK,
                       label: sat_s6vfk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wDK: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vfj_entry() //  [R1, R2]
         { info_tbl: [(c6wDS,
                       label: sat_s6vfj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wDS: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vfi_entry() //  [R1]
         { info_tbl: [(c6wDZ,
                       label: sat_s6vfi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wDZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wE0; else goto c6wE1;
       c6wE0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wE1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupAlt_entry() //  [R2]
         { info_tbl: [(c6wE3,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wE3: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6wE7; else goto c6wE6;
       c6wE7: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wE6: // global
           I64[Hp - 80] = sat_s6vfk_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6vfj_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6vfi_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAlt_closure" {
     Data.Semigroup.Internal.$fMonoidAlt_closure:
         const Data.Semigroup.Internal.$fMonoidAlt_info;
         const 0;
 },
 sat_s6vfp_entry() //  [R1, R2]
         { info_tbl: [(c6wEh,
                       label: sat_s6vfp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wEh: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vfo_entry() //  [R1]
         { info_tbl: [(c6wEo,
                       label: sat_s6vfo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wEo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wEp; else goto c6wEq;
       c6wEp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wEq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vfn_entry() //  [R1]
         { info_tbl: [(c6wEv,
                       label: sat_s6vfn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wEv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wEw; else goto c6wEx;
       c6wEw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wEx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vfm_entry() //  [R1]
         { info_tbl: [(c6wEC,
                       label: sat_s6vfm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wEC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wED; else goto c6wEE;
       c6wED: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wEE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupAlt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidAlt_entry() //  [R2]
         { info_tbl: [(c6wEG,
                       label: Data.Semigroup.Internal.$fMonoidAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wEG: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c6wEK; else goto c6wEJ;
       c6wEK: // global
           HpAlloc = 128;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wEJ: // global
           I64[Hp - 120] = sat_s6vfp_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6vfo_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6vfn_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6vfm_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 119;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_info;
         const 0;
 },
 sat_s6vfs_entry() //  [R1]
         { info_tbl: [(c6wET,
                       label: sat_s6vfs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wET: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wEU; else goto c6wEV;
       c6wEU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wEV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidAlt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c6wEW,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wEW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wF0; else goto c6wEZ;
       c6wF0: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wEZ: // global
           I64[Hp - 16] = sat_s6vfs_info;
           P64[Hp] = R2;
           _s6vfr::P64 = R3;
           R3 = Hp - 16;
           R2 = _s6vfr::P64;
           R1 = Data.Semigroup.Internal.stimesMonoid_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.572289436 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo1_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo1_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo1_info;
 },
 g_s6vfy_entry() //  [R1]
         { info_tbl: [(c6wFf,
                       label: g_s6vfy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wFf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wFg; else goto c6wFh;
       c6wFg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wFh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupEndo1_entry(R3,
                                                               R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vfB_entry() //  [R1, R2]
         { info_tbl: [(c6wFo,
                       label: sat_s6vfB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wFo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wFs; else goto c6wFr;
       c6wFs: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wFr: // global
           _s6vft::P64 = P64[R1 + 7];
           _s6vfy::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s6vfy::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _s6vft::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fSemigroupEndo1_entry() //  [R2, R3]
         { info_tbl: [(c6wFx,
                       label: Data.Semigroup.Internal.$fSemigroupEndo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wFx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wFy; else goto c6wFz;
       c6wFy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupEndo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wFz: // global
           I64[Sp - 16] = block_c6wF5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6wFF; else goto c6wF6;
       u6wFF: // global
           call _c6wF5(R1) args: 0, res: 0, upd: 0;
       c6wF6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wF5() //  [R1]
         { info_tbl: [(c6wF5,
                       label: block_c6wF5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wF5: // global
           _s6vft::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6wFu; else goto c6wFv;
       c6wFu: // global
           R1 = _s6vft::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wFv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6wFE; else goto c6wFD;
       c6wFE: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wFD: // global
           _s6vfw::P64 = P64[R1 + 6];
           _s6vfx::P64 = P64[R1 + 14];
           I64[Hp - 48] = g_s6vfy_info;
           P64[Hp - 32] = _s6vfw::P64;
           P64[Hp - 24] = _s6vfx::P64;
           I64[Hp - 16] = sat_s6vfB_info;
           P64[Hp - 8] = _s6vft::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.575565282 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_entry() //  [R2]
         { info_tbl: [(c6wFN,
                       label: Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wFN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6wFO; else goto c6wFP;
       c6wFO: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wFP: // global
           I64[Sp - 8] = block_c6wFK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6wFT; else goto c6wFL;
       u6wFT: // global
           call _c6wFK(R1) args: 0, res: 0, upd: 0;
       c6wFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wFK() //  [R1]
         { info_tbl: [(c6wFK,
                       label: block_c6wFK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wFK: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupEndo1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.5770664 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidEndo1_closure" {
     Data.Semigroup.Internal.$fMonoidEndo1_closure:
         const Data.Semigroup.Internal.$fMonoidEndo1_info;
 },
 sat_s6vfL_entry() //  [R1]
         { info_tbl: [(c6wG8,
                       label: sat_s6vfL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wG8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wG9; else goto c6wGa;
       c6wG9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wGa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidEndo1_entry(R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidEndo1_entry() //  [R2, R3]
         { info_tbl: [(c6wGf,
                       label: Data.Semigroup.Internal.$fMonoidEndo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wGf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wGg; else goto c6wGh;
       c6wGg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidEndo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wGh: // global
           I64[Sp - 16] = block_c6wFY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6wGn; else goto c6wFZ;
       u6wGn: // global
           call _c6wFY(R1) args: 0, res: 0, upd: 0;
       c6wFZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wFY() //  [R1]
         { info_tbl: [(c6wFY,
                       label: block_c6wFY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wFY: // global
           _s6vfH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6wGc; else goto c6wGd;
       c6wGc: // global
           R1 = _s6vfH::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wGd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wGm; else goto c6wGl;
       c6wGm: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wGl: // global
           _s6vfJ::P64 = P64[R1 + 6];
           _s6vfK::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s6vfL_info;
           P64[Hp - 8] = _s6vfH::P64;
           P64[Hp] = _s6vfK::P64;
           R2 = Hp - 24;
           R1 = _s6vfJ::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.578696471 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.._closure+3;
         const Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidEndo_closure" {
     Data.Semigroup.Internal.$fMonoidEndo_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupEndo_closure+1;
         const GHC.Base.id_closure+1;
         const GHC.Base.._closure+3;
         const Data.Semigroup.Internal.$fMonoidEndo1_closure+2;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c6wGs,
                       label: Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wGs: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidEndo_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesMonoid_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.579651222 UTC

[section ""cstring" . lvl8_r6v1e_bytes" {
     lvl8_r6v1e_bytes:
         I8[] [115,116,105,109,101,115,58,32,112,111,115,105,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114,32,101,120,112,101,99,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.580468009 UTC

[section ""data" . lvl9_r6v1f_closure" {
     lvl9_r6v1f_closure:
         const lvl9_r6v1f_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r6v1f_entry() //  [R1]
         { info_tbl: [(c6wGD,
                       label: lvl9_r6v1f_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wGD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wGE; else goto c6wGF;
       c6wGE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wGF: // global
           (_c6wGy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wGy::I64 == 0) goto c6wGA; else goto c6wGz;
       c6wGA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wGz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wGy::I64;
           I64[Sp - 24] = block_c6wGB_info;
           R2 = lvl8_r6v1e_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wGB() //  [R1]
         { info_tbl: [(c6wGB,
                       label: block_c6wGB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wGB: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.585080075 UTC

[section ""data" . Data.Semigroup.Internal.stimesDefault_closure" {
     Data.Semigroup.Internal.stimesDefault_closure:
         const Data.Semigroup.Internal.stimesDefault_info;
         const 0;
 },
 sat_s6vfV_entry() //  [R1]
         { info_tbl: [(c6wI8,
                       label: sat_s6vfV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wI8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wI9; else goto c6wIa;
       c6wI9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wIa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6wI6_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wI6() //  [R1]
         { info_tbl: [(c6wI6,
                       label: block_c6wI6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wI6: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s6vfX_entry() //  [R1]
         { info_tbl: [(c6wIg,
                       label: $dNum_s6vfX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wIg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wIh; else goto c6wIi;
       c6wIh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wIi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_s6vfY_entry() //  [R1]
         { info_tbl: [(c6wIl,
                       label: lvl12_s6vfY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wIl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wIm; else goto c6wIn;
       c6wIm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wIn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl7_r6v1d_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6vg4_entry() //  [R1]
         { info_tbl: [(c6wIq,
                       label: lvl13_s6vg4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wIq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wIr; else goto c6wIs;
       c6wIr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wIs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6vgl_entry() //  [R1]
         { info_tbl: [(c6wIv,
                       label: sat_s6vgl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wIv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wIw; else goto c6wIx;
       c6wIw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wIx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgk_entry() //  [R1]
         { info_tbl: [(c6wIA,
                       label: sat_s6vgk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wIA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wIB; else goto c6wIC;
       c6wIB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wIC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vg0::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vg0::P64;
           P64[Sp - 24] = _s6vg0::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgh_entry() //  [R1]
         { info_tbl: [(c6wIF,
                       label: sat_s6vgh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wIF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wIG; else goto c6wIH;
       c6wIG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wIH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgg_entry() //  [R1]
         { info_tbl: [(c6wIK,
                       label: sat_s6vgg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wIK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wIL; else goto c6wIM;
       c6wIL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wIM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgf_entry() //  [R1]
         { info_tbl: [(c6wIQ,
                       label: sat_s6vgf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wIQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wIR; else goto c6wIS;
       c6wIR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wIS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vga::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vga::P64;
           P64[Sp - 24] = _s6vga::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgj_entry() //  [R1]
         { info_tbl: [(c6wIV,
                       label: sat_s6vgj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wIV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wIW; else goto c6wIX;
       c6wIW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wIX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgi_entry() //  [R1]
         { info_tbl: [(c6wJ1,
                       label: sat_s6vgi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wJ1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wJ2; else goto c6wJ3;
       c6wJ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wJ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vga::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vga::P64;
           P64[Sp - 24] = _s6vga::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgr_entry() //  [R1]
         { info_tbl: [(c6wJ6,
                       label: sat_s6vgr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wJ6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wJ7; else goto c6wJ8;
       c6wJ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wJ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgq_entry() //  [R1]
         { info_tbl: [(c6wJc,
                       label: sat_s6vgq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wJc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wJd; else goto c6wJe;
       c6wJd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wJe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vgn::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vgn::P64;
           P64[Sp - 24] = _s6vgn::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesDefault_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6wJf,
                       label: Data.Semigroup.Internal.stimesDefault_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wJf: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c6wJg; else goto c6wJh;
       c6wJg: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wJh: // global
           I64[Sp - 40] = block_c6wGN_info;
           _s6vfO::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s6vfO::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wGN() //  [R1]
         { info_tbl: [(c6wGN,
                       label: block_c6wGN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wGN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wJk; else goto c6wJj;
       c6wJk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wJj: // global
           I64[Hp - 16] = sat_s6vfV_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c6wGT_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wGT() //  [R1]
         { info_tbl: [(c6wGT,
                       label: block_c6wGT_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wGT: // global
           I64[Sp] = block_c6wGX_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6wGX() //  [R1]
         { info_tbl: [(c6wGX,
                       label: block_c6wGX_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wGX: // global
           if (R1 & 7 == 1) goto c6wJn; else goto c6wKc;
       c6wJn: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6wJq; else goto c6wJp;
       c6wJq: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wJp: // global
           I64[Hp - 40] = $dNum_s6vfX_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = lvl12_s6vfY_info;
           _c6wH1::P64 = Hp - 40;
           P64[Hp] = _c6wH1::P64;
           P64[Sp] = P64[Sp + 40];
           P64[Sp + 16] = P64[Sp + 48];
           P64[Sp + 40] = Hp - 16;
           P64[Sp + 48] = _c6wH1::P64;
           call _c6wHU() args: 0, res: 0, upd: 0;
       c6wKc: // global
           R1 = lvl9_r6v1f_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6wHU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wHU: // global
           I64[Sp - 8] = block_c6wHW_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wHW() //  [R1]
         { info_tbl: [(c6wHW,
                       label: block_c6wHW_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wHW: // global
           _s6vgn::P64 = P64[Sp + 24];
           _s6vgo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6wK4; else goto c6wK5;
       c6wK4: // global
           I64[Sp + 8] = block_c6wHa_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s6vgo::P64;
           P64[Sp + 24] = _s6vgn::P64;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c6wK5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6wK8; else goto c6wK7;
       c6wK8: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wK7: // global
           I64[Hp - 64] = sat_s6vgr_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s6vgo::P64;
           I64[Hp - 24] = sat_s6vgq_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6vgn::P64;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c6wHU() args: 0, res: 0, upd: 0;
     }
 },
 _c6wHa() //  [R1]
         { info_tbl: [(c6wHa,
                       label: block_c6wHa_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wHa: // global
           I64[Sp] = block_c6wHe_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wHe() //  [R1]
         { info_tbl: [(c6wHe,
                       label: block_c6wHe_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wHe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wJv; else goto c6wJu;
       c6wJv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wJu: // global
           I64[Hp - 16] = lvl13_s6vg4_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp - 8] = block_c6wHk_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c6wHi::P64 = Hp - 16;
           P64[Sp - 16] = _c6wHi::P64;
           P64[Sp] = R1;
           P64[Sp + 48] = _c6wHi::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6wHk() //  [R1]
         { info_tbl: [(c6wHk,
                       label: block_c6wHk_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wHk: // global
           _s6vg0::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6wJx; else goto c6wJZ;
       c6wJx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6wJA; else goto c6wJz;
       c6wJA: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wJz: // global
           I64[Hp - 64] = sat_s6vgl_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s6vgk_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6vg0::P64;
           P64[Sp] = _s6vg0::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 24] = Hp - 24;
           call _c6wHx() args: 0, res: 0, upd: 0;
       c6wJZ: // global
           R1 = _s6vg0::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6wHx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wHx: // global
           I64[Sp - 8] = block_c6wHz_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wHz() //  [R1]
         { info_tbl: [(c6wHz,
                       label: block_c6wHz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wHz: // global
           _s6vgb::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6wJI; else goto c6wJS;
       c6wJI: // global
           I64[Sp] = block_c6wHD_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s6vgb::P64;
           P64[Sp - 8] = P64[Sp + 64];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c6wJS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6wJV; else goto c6wJU;
       c6wJV: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wJU: // global
           I64[Hp - 64] = sat_s6vgj_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s6vgb::P64;
           I64[Hp - 24] = sat_s6vgi_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6wHx() args: 0, res: 0, upd: 0;
     }
 },
 _c6wHD() //  [R1]
         { info_tbl: [(c6wHD,
                       label: block_c6wHD_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wHD: // global
           _s6vfP::P64 = P64[Sp + 48];
           _s6vga::P64 = P64[Sp + 32];
           _s6vgc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6wJK; else goto c6wJR;
       c6wJK: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c6wJN; else goto c6wJM;
       c6wJN: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wJM: // global
           I64[Hp - 104] = sat_s6vgh_info;
           P64[Hp - 88] = _s6vfP::P64;
           P64[Hp - 80] = _s6vga::P64;
           P64[Hp - 72] = _s6vgc::P64;
           I64[Hp - 64] = sat_s6vgg_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s6vgf_info;
           P64[Hp - 8] = _s6vfP::P64;
           P64[Hp] = _s6vga::P64;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c6wHx() args: 0, res: 0, upd: 0;
       c6wJR: // global
           R2 = _s6vfP::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s6vga::P64;
           P64[Sp + 64] = _s6vgc::P64;
           Sp = Sp + 48;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.59254331 UTC

[section ""cstring" . lvl10_r6v1g_bytes" {
     lvl10_r6v1g_bytes:
         I8[] [115,116,105,109,101,115,58,32,77,97,121,98,101,44,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.593466233 UTC

[section ""data" . Data.Semigroup.Internal.stimesMaybe1_closure" {
     Data.Semigroup.Internal.stimesMaybe1_closure:
         const Data.Semigroup.Internal.stimesMaybe1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesMaybe1_entry() //  [R1]
         { info_tbl: [(c6wKA,
                       label: Data.Semigroup.Internal.stimesMaybe1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wKA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wKB; else goto c6wKC;
       c6wKB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wKC: // global
           (_c6wKv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wKv::I64 == 0) goto c6wKx; else goto c6wKw;
       c6wKx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wKw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wKv::I64;
           I64[Sp - 24] = block_c6wKy_info;
           R2 = lvl10_r6v1g_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wKy() //  [R1]
         { info_tbl: [(c6wKy,
                       label: block_c6wKy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wKy: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.59567846 UTC

[section ""data" . Data.Semigroup.Internal.stimesMaybe_closure" {
     Data.Semigroup.Internal.stimesMaybe_closure:
         const Data.Semigroup.Internal.stimesMaybe_info;
         const 0;
 },
 sat_s6vgC_entry() //  [R1]
         { info_tbl: [(c6wL0,
                       label: sat_s6vgC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wL0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wL1; else goto c6wL2;
       c6wL1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wL2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6wKY_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wKY() //  [R1]
         { info_tbl: [(c6wKY,
                       label: block_c6wKY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wKY: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6vgE_entry() //  [R1]
         { info_tbl: [(c6wLk,
                       label: sat_s6vgE_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wLk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6wLl; else goto c6wLm;
       c6wLl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wLm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesMaybe_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6wLr,
                       label: Data.Semigroup.Internal.stimesMaybe_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wLr: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c6wLs; else goto c6wLt;
       c6wLs: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMaybe_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wLt: // global
           I64[Sp - 32] = block_c6wKK_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wLT; else goto c6wKL;
       u6wLT: // global
           call _c6wKK(R1) args: 0, res: 0, upd: 0;
       c6wKL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wKK() //  [R1]
         { info_tbl: [(c6wKK,
                       label: block_c6wKK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wKK: // global
           if (R1 & 7 == 1) goto u6wLP; else goto c6wLp;
       u6wLP: // global
           Sp = Sp + 32;
           call _c6wLH() args: 0, res: 0, upd: 0;
       c6wLp: // global
           I64[Sp - 8] = block_c6wKQ_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wKQ() //  [R1]
         { info_tbl: [(c6wKQ,
                       label: block_c6wKQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wKQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wLz; else goto c6wLy;
       c6wLz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wLy: // global
           I64[Hp - 16] = sat_s6vgC_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6wL6_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wL6() //  [R1]
         { info_tbl: [(c6wL6,
                       label: block_c6wL6_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wL6: // global
           _c6wKU::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6wLa_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = _c6wKU::P64;
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6wLa() //  [R1]
         { info_tbl: [(c6wLa,
                       label: block_c6wLa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wLa: // global
           _c6wLN::P64 = R1 & 7;
           if (_c6wLN::P64 < 3) goto u6wLO; else goto c6wLJ;
       u6wLO: // global
           if (_c6wLN::P64 < 2) goto c6wLE; else goto u6wLQ;
       c6wLE: // global
           R1 = Data.Semigroup.Internal.stimesMaybe1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u6wLQ: // global
           Sp = Sp + 40;
           call _c6wLH() args: 0, res: 0, upd: 0;
       c6wLJ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c6wLM; else goto c6wLL;
       c6wLM: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wLL: // global
           I64[Hp - 56] = sat_s6vgE_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6wLH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wLH: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.598524413 UTC

[section ""cstring" . lvl11_r6v1h_bytes" {
     lvl11_r6v1h_bytes:
         I8[] [115,116,105,109,101,115,58,32,91,93,44,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.599368784 UTC

[section ""data" . Data.Semigroup.Internal.stimesList1_closure" {
     Data.Semigroup.Internal.stimesList1_closure:
         const Data.Semigroup.Internal.stimesList1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesList1_entry() //  [R1]
         { info_tbl: [(c6wM2,
                       label: Data.Semigroup.Internal.stimesList1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wM2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wM3; else goto c6wM4;
       c6wM3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wM4: // global
           (_c6wLX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wLX::I64 == 0) goto c6wLZ; else goto c6wLY;
       c6wLZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wLY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wLX::I64;
           I64[Sp - 24] = block_c6wM0_info;
           R2 = lvl11_r6v1h_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6wM0() //  [R1]
         { info_tbl: [(c6wM0,
                       label: block_c6wM0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wM0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.603665033 UTC

[section ""data" . Data.Semigroup.Internal.stimesList_closure" {
     Data.Semigroup.Internal.stimesList_closure:
         const Data.Semigroup.Internal.stimesList_info;
         const 0;
 },
 $dNum_s6vgK_entry() //  [R1]
         { info_tbl: [(c6wMk,
                       label: $dNum_s6vgK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wMk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wMl; else goto c6wMm;
       c6wMl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wMm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vgM_entry() //  [R1]
         { info_tbl: [(c6wMv,
                       label: sat_s6vgM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wMv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wMw; else goto c6wMx;
       c6wMw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wMx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl12_s6vgO_entry() //  [R1]
         { info_tbl: [(c6wMG,
                       label: lvl12_s6vgO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wMG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wMH; else goto c6wMI;
       c6wMH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wMI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6vgP_entry() //  [R1]
         { info_tbl: [(c6wMN,
                       label: lvl13_s6vgP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wMN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wMO; else goto c6wMP;
       c6wMO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wMP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6vgU_entry() //  [R1]
         { info_tbl: [(c6wNb,
                       label: sat_s6vgU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wNb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6wNc; else goto c6wNd;
       c6wNc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wNd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgV_entry() //  [R1]
         { info_tbl: [(c6wNe,
                       label: sat_s6vgV_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wNe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6wNi; else goto c6wNh;
       c6wNi: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wNh: // global
           _s6vgK::P64 = P64[R1 + 16];
           _s6vgO::P64 = P64[R1 + 24];
           _s6vgR::P64 = P64[R1 + 32];
           _s6vgS::P64 = P64[R1 + 40];
           I64[Hp - 32] = sat_s6vgU_info;
           P64[Hp - 16] = _s6vgK::P64;
           P64[Hp - 8] = _s6vgO::P64;
           P64[Hp] = _s6vgS::P64;
           R2 = Hp - 32;
           R1 = _s6vgR::P64;
           call rep_s6vgR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 rep_s6vgR_entry() //  [R1, R2]
         { info_tbl: [(c6wNn,
                       label: rep_s6vgR_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wNn: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c6wNo; else goto c6wNp;
       c6wNo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wNp: // global
           I64[Sp - 48] = block_c6wMZ_info;
           _s6vgS::P64 = R2;
           R2 = P64[R1 + 39];
           I64[Sp - 72] = stg_ap_pp_info;
           P64[Sp - 64] = _s6vgS::P64;
           P64[Sp - 56] = P64[R1 + 31];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s6vgS::P64;
           Sp = Sp - 72;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6wMZ() //  [R1]
         { info_tbl: [(c6wMZ,
                       label: block_c6wMZ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wMZ: // global
           if (R1 & 7 == 1) goto c6wNk; else goto c6wNl;
       c6wNk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6wNs; else goto c6wNr;
       c6wNs: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wNr: // global
           I64[Hp - 40] = sat_s6vgV_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 40;
           R2 = P64[Sp + 8];
           Sp = Sp + 48;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6wNl: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.stimesList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6wNw,
                       label: Data.Semigroup.Internal.stimesList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wNw: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c6wNx; else goto c6wNy;
       c6wNx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wNy: // global
           I64[Sp - 24] = block_c6wMc_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wMc() //  [R1]
         { info_tbl: [(c6wMc,
                       label: block_c6wMc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wMc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wNB; else goto c6wNA;
       c6wNB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wNA: // global
           I64[Hp - 16] = $dNum_s6vgK_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6wMn_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wMn() //  [R1]
         { info_tbl: [(c6wMn,
                       label: block_c6wMn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wMn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wNE; else goto c6wND;
       c6wNE: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wND: // global
           I64[Hp - 16] = sat_s6vgM_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c6wMy_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6wMy() //  [R1]
         { info_tbl: [(c6wMy,
                       label: block_c6wMy_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wMy: // global
           if (R1 & 7 == 1) goto c6wNG; else goto c6wNQ;
       c6wNG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6wNJ; else goto c6wNI;
       c6wNJ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wNI: // global
           I64[Hp - 40] = lvl12_s6vgO_info;
           _c6wMg::P64 = P64[Sp + 16];
           P64[Hp - 24] = _c6wMg::P64;
           I64[Hp - 16] = lvl13_s6vgP_info;
           P64[Hp] = _c6wMg::P64;
           I64[Sp - 8] = block_c6wMQ_info;
           R2 = P64[Sp + 8];
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = Hp - 40;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c6wNQ: // global
           R1 = Data.Semigroup.Internal.stimesList1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6wMQ() //  [R1]
         { info_tbl: [(c6wMQ,
                       label: block_c6wMQ_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wMQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6wNM; else goto c6wNL;
       c6wNM: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wNL: // global
           I64[Hp - 40] = rep_s6vgR_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 39;
           Sp = Sp + 48;
           call rep_s6vgR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.607786925 UTC

[section ""cstring" . Data.Semigroup.Internal.$trModule4_bytes" {
     Data.Semigroup.Internal.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.608385261 UTC

[section ""data" . Data.Semigroup.Internal.$trModule3_closure" {
     Data.Semigroup.Internal.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.608973159 UTC

[section ""cstring" . Data.Semigroup.Internal.$trModule2_bytes" {
     Data.Semigroup.Internal.$trModule2_bytes:
         I8[] [68,97,116,97,46,83,101,109,105,103,114,111,117,112,46,73,110,116,101,114,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.609583671 UTC

[section ""data" . Data.Semigroup.Internal.$trModule1_closure" {
     Data.Semigroup.Internal.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.610167731 UTC

[section ""data" . Data.Semigroup.Internal.$trModule_closure" {
     Data.Semigroup.Internal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Semigroup.Internal.$trModule3_closure+1;
         const Data.Semigroup.Internal.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.610759587 UTC

[section ""data" . $krep_r6v1i_closure" {
     $krep_r6v1i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.611390916 UTC

[section ""data" . $krep1_r6v1j_closure" {
     $krep1_r6v1j_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.611982363 UTC

[section ""data" . $krep2_r6v1k_closure" {
     $krep2_r6v1k_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep1_r6v1j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.612626362 UTC

[section ""data" . $krep3_r6v1l_closure" {
     $krep3_r6v1l_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.613236028 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt1_closure" {
     Data.Semigroup.Internal.$tcAlt1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r6v1l_closure+4;
         const $krep3_r6v1l_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.61402385 UTC

[section ""data" . $krep4_r6v1m_closure" {
     $krep4_r6v1m_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.614625759 UTC

[section ""data" . $krep5_r6v1n_closure" {
     $krep5_r6v1n_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.615254562 UTC

[section ""data" . $krep6_r6v1o_closure" {
     $krep6_r6v1o_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_r6v1m_closure+2;
         const $krep5_r6v1n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.615872248 UTC

[section ""data" . Data.Semigroup.Internal.$tcDual1_closure" {
     Data.Semigroup.Internal.$tcDual1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadDual5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.616489946 UTC

[section ""data" . Data.Semigroup.Internal.$tcDual_closure" {
     Data.Semigroup.Internal.$tcDual_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcDual1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 14711416616195557841;
         const 10971851269997195248;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.617156427 UTC

[section ""data" . $krep7_r6v1p_closure" {
     $krep7_r6v1p_closure:
         const :_con_info;
         const $krep1_r6v1j_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.617843125 UTC

[section ""data" . $krep8_r6v1q_closure" {
     $krep8_r6v1q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcDual_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.618395378 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual1_closure" {
     Data.Semigroup.Internal.$tc'Dual1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep8_r6v1q_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.618993439 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Dual3_bytes" {
     Data.Semigroup.Internal.$tc'Dual3_bytes:
         I8[] [39,68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.619578691 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual2_closure" {
     Data.Semigroup.Internal.$tc'Dual2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Dual3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.620196511 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual_closure" {
     Data.Semigroup.Internal.$tc'Dual_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Dual2_closure+1;
         const Data.Semigroup.Internal.$tc'Dual1_closure+4;
         const 15885009659242865261;
         const 15931193389986079612;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.620842461 UTC

[section ""cstring" . Data.Semigroup.Internal.$tcEndo2_bytes" {
     Data.Semigroup.Internal.$tcEndo2_bytes:
         I8[] [69,110,100,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.621500405 UTC

[section ""data" . Data.Semigroup.Internal.$tcEndo1_closure" {
     Data.Semigroup.Internal.$tcEndo1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tcEndo2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.622118541 UTC

[section ""data" . Data.Semigroup.Internal.$tcEndo_closure" {
     Data.Semigroup.Internal.$tcEndo_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcEndo1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16820921632006328603;
         const 4981834339379479823;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.622807173 UTC

[section ""data" . $krep9_r6v1r_closure" {
     $krep9_r6v1r_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcEndo_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.623437468 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo1_closure" {
     Data.Semigroup.Internal.$tc'Endo1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6v1k_closure+4;
         const $krep9_r6v1r_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.624965969 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Endo3_bytes" {
     Data.Semigroup.Internal.$tc'Endo3_bytes:
         I8[] [39,69,110,100,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.625821312 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo2_closure" {
     Data.Semigroup.Internal.$tc'Endo2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Endo3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.626389835 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo_closure" {
     Data.Semigroup.Internal.$tc'Endo_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Endo2_closure+1;
         const Data.Semigroup.Internal.$tc'Endo1_closure+4;
         const 156297185665537802;
         const 8988325904501215692;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.627006827 UTC

[section ""data" . Data.Semigroup.Internal.$tcAll1_closure" {
     Data.Semigroup.Internal.$tcAll1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAll13_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.62759281 UTC

[section ""data" . Data.Semigroup.Internal.$tcAll_closure" {
     Data.Semigroup.Internal.$tcAll_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAll1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14149274874874504208;
         const 8164254778609961234;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.628219978 UTC

[section ""data" . $krep10_r6v1s_closure" {
     $krep10_r6v1s_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAll_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.628832672 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All1_closure" {
     Data.Semigroup.Internal.$tc'All1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r6v1i_closure+1;
         const $krep10_r6v1s_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.629478597 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'All3_bytes" {
     Data.Semigroup.Internal.$tc'All3_bytes:
         I8[] [39,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.630049536 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All2_closure" {
     Data.Semigroup.Internal.$tc'All2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'All3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.630632044 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All_closure" {
     Data.Semigroup.Internal.$tc'All_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'All2_closure+1;
         const Data.Semigroup.Internal.$tc'All1_closure+4;
         const 1168494541548489787;
         const 10689931498683547374;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.631288702 UTC

[section ""data" . Data.Semigroup.Internal.$tcAny1_closure" {
     Data.Semigroup.Internal.$tcAny1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAny6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.63186674 UTC

[section ""data" . Data.Semigroup.Internal.$tcAny_closure" {
     Data.Semigroup.Internal.$tcAny_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAny1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11600287624241135668;
         const 17600231731807245316;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.632488892 UTC

[section ""data" . $krep11_r6v1t_closure" {
     $krep11_r6v1t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAny_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.633105114 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any1_closure" {
     Data.Semigroup.Internal.$tc'Any1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r6v1i_closure+1;
         const $krep11_r6v1t_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.633695305 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Any3_bytes" {
     Data.Semigroup.Internal.$tc'Any3_bytes:
         I8[] [39,65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.634313587 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any2_closure" {
     Data.Semigroup.Internal.$tc'Any2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Any3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.634866853 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any_closure" {
     Data.Semigroup.Internal.$tc'Any_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Any2_closure+1;
         const Data.Semigroup.Internal.$tc'Any1_closure+4;
         const 16164188984560189013;
         const 110490866064676064;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.635507834 UTC

[section ""data" . Data.Semigroup.Internal.$tcSum1_closure" {
     Data.Semigroup.Internal.$tcSum1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadSum5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.636101298 UTC

[section ""data" . Data.Semigroup.Internal.$tcSum_closure" {
     Data.Semigroup.Internal.$tcSum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcSum1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 7521450980204740829;
         const 14029043805042477297;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.636719223 UTC

[section ""data" . $krep12_r6v1u_closure" {
     $krep12_r6v1u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcSum_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.637732859 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum1_closure" {
     Data.Semigroup.Internal.$tc'Sum1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep12_r6v1u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.638332474 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Sum3_bytes" {
     Data.Semigroup.Internal.$tc'Sum3_bytes:
         I8[] [39,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.638883957 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum2_closure" {
     Data.Semigroup.Internal.$tc'Sum2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Sum3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.639477935 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum_closure" {
     Data.Semigroup.Internal.$tc'Sum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Sum2_closure+1;
         const Data.Semigroup.Internal.$tc'Sum1_closure+4;
         const 7144872330799658717;
         const 13465414667749873698;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.640080019 UTC

[section ""data" . Data.Semigroup.Internal.$tcProduct1_closure" {
     Data.Semigroup.Internal.$tcProduct1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadProduct5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.64066834 UTC

[section ""data" . Data.Semigroup.Internal.$tcProduct_closure" {
     Data.Semigroup.Internal.$tcProduct_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcProduct1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12271745360620305859;
         const 5747185732973757022;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.641329601 UTC

[section ""data" . $krep13_r6v1v_closure" {
     $krep13_r6v1v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcProduct_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.64193665 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product1_closure" {
     Data.Semigroup.Internal.$tc'Product1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep13_r6v1v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.642519962 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Product3_bytes" {
     Data.Semigroup.Internal.$tc'Product3_bytes:
         I8[] [39,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.643117414 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product2_closure" {
     Data.Semigroup.Internal.$tc'Product2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Product3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.643695855 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product_closure" {
     Data.Semigroup.Internal.$tc'Product_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Product2_closure+1;
         const Data.Semigroup.Internal.$tc'Product1_closure+4;
         const 3191278115598904989;
         const 12638872580785847167;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.644367754 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt2_closure" {
     Data.Semigroup.Internal.$tcAlt2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAlt5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.644982881 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt_closure" {
     Data.Semigroup.Internal.$tcAlt_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAlt2_closure+1;
         const Data.Semigroup.Internal.$tcAlt1_closure+4;
         const 7601313288863504805;
         const 2369500163797891218;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.646104975 UTC

[section ""data" . $krep14_r6v1w_closure" {
     $krep14_r6v1w_closure:
         const :_con_info;
         const $krep5_r6v1n_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.646755775 UTC

[section ""data" . $krep15_r6v1x_closure" {
     $krep15_r6v1x_closure:
         const :_con_info;
         const $krep4_r6v1m_closure+2;
         const $krep14_r6v1w_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.647360931 UTC

[section ""data" . $krep16_r6v1y_closure" {
     $krep16_r6v1y_closure:
         const :_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep15_r6v1x_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.648681303 UTC

[section ""data" . $krep17_r6v1z_closure" {
     $krep17_r6v1z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAlt_closure+1;
         const $krep16_r6v1y_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.649346781 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt1_closure" {
     Data.Semigroup.Internal.$tc'Alt1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r6v1o_closure+3;
         const $krep17_r6v1z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.64994185 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Alt3_bytes" {
     Data.Semigroup.Internal.$tc'Alt3_bytes:
         I8[] [39,65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.650474587 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt2_closure" {
     Data.Semigroup.Internal.$tc'Alt2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Alt3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.651041595 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt_closure" {
     Data.Semigroup.Internal.$tc'Alt_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Alt2_closure+1;
         const Data.Semigroup.Internal.$tc'Alt1_closure+4;
         const 1436877498177162483;
         const 16937142347825669760;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.651663094 UTC

[section ""relreadonly" . S6vn0_srt" {
     S6vn0_srt:
         const Data.Semigroup.Internal.$fMonoidSum1_closure;
         const Data.Semigroup.Internal.$fMonoidSum2_closure;
         const Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const GHC.Real.^_closure;
         const Data.Semigroup.Internal.$fSemigroupProduct_closure;
         const sat_s6v3C_closure;
         const Data.Semigroup.Internal.$fMonoidProduct1_closure;
         const Data.Semigroup.Internal.$fMonoidProduct2_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const Data.Semigroup.Internal.$fShowAlt_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAlt_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Semigroup.Internal.$fReadAll3_closure;
         const GHC.Read.readField_closure;
         const Data.Semigroup.Internal.$fReadAlt2_closure;
         const Data.Semigroup.Internal.$fReadAll_lexeme_closure;
         const Data.Semigroup.Internal.$fReadAlt_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Semigroup.Internal.$fReadAlt1_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadList_closure;
         const Data.Semigroup.Internal.$fReadAlt_closure;
         const Data.Semigroup.Internal.$fShowProduct_$cshow_closure;
         const Data.Semigroup.Internal.$fShowProduct_closure;
         const Data.Semigroup.Internal.$fReadProduct2_closure;
         const Data.Semigroup.Internal.$fReadProduct_lexeme_closure;
         const Data.Semigroup.Internal.$fReadProduct1_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadList_closure;
         const Data.Semigroup.Internal.$fReadProduct_closure;
         const Data.Semigroup.Internal.$fShowSum_$cshow_closure;
         const Data.Semigroup.Internal.$fShowSum_closure;
         const Data.Semigroup.Internal.$fReadSum2_closure;
         const Data.Semigroup.Internal.$fReadSum_lexeme_closure;
         const Data.Semigroup.Internal.$fReadSum1_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadList_closure;
         const Data.Semigroup.Internal.$fReadSum_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const GHC.Show.$fShowBool2_closure;
         const GHC.Show.$fShowBool4_closure;
         const Data.Semigroup.Internal.$fShowAny3_closure;
         const Data.Semigroup.Internal.$w$cshowsPrec2_closure;
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll5_closure;
         const Data.Semigroup.Internal.$fShowAll6_closure;
         const Data.Semigroup.Internal.$fShowAny_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAny1_closure;
         const GHC.Read.$fReadBool2_closure;
         const GHC.Read.list3_closure;
         const Data.Semigroup.Internal.$fReadAll3_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Semigroup.Internal.$fReadAll7_closure;
         const Data.Semigroup.Internal.$fReadAny3_closure;
         const Data.Semigroup.Internal.$w$creadPrec1_closure;
         const Data.Semigroup.Internal.$fReadAny_lexeme_closure;
         const Data.Semigroup.Internal.$fReadAny2_closure;
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadAny1_closure;
         const GHC.Read.list_closure;
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAny7_closure;
         const Data.Semigroup.Internal.$fShowAll3_closure;
         const Data.Semigroup.Internal.$w$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAll1_closure;
         const Data.Semigroup.Internal.$fReadAll8_closure;
         const Data.Semigroup.Internal.$w$creadPrec_closure;
         const Data.Semigroup.Internal.$fReadAll_lexeme1_closure;
         const Data.Semigroup.Internal.$fReadAll2_closure;
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadAll1_closure;
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAll14_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const Data.Semigroup.Internal.$fShowDual_$cshow_closure;
         const Data.Semigroup.Internal.$fShowDual_closure;
         const Data.Semigroup.Internal.$fReadDual2_closure;
         const Data.Semigroup.Internal.$fReadDual_lexeme_closure;
         const Data.Semigroup.Internal.$fReadDual1_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadList_closure;
         const Data.Semigroup.Internal.$fReadDual_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Semigroup.Internal.$fMonoidSum1_closure;
         const Data.Semigroup.Internal.stimesIdempotent_closure;
         const Data.Semigroup.Internal.stimesIdempotent1_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid1_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Semigroup.Internal.$fMonoidAll_closure;
         const sat_s6vee_closure;
         const lvl7_r6v1d_closure;
         const Data.Semigroup.Internal.$fMonoidProduct1_closure;
         const GHC.Real.even_closure;
         const Data.Semigroup.Internal.stimesMonoid_closure;
         const lvl6_r6v1c_closure;
         const Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure;
         const Data.Semigroup.Internal.$fSemigroupAlt_closure;
         const Data.Semigroup.Internal.$fMonoidAlt_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const lvl9_r6v1f_closure;
         const Data.Semigroup.Internal.stimesMaybe_closure;
         const Data.Semigroup.Internal.stimesMaybe1_closure;
         const Data.Semigroup.Internal.stimesList_closure;
         const Data.Semigroup.Internal.stimesList1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.652919411 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:01:43.654286919 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat1_closure" {
     Data.Semigroup.Internal.$w$csconcat1_closure:
         const Data.Semigroup.Internal.$w$csconcat1_info;
 },
 go_s6v1E_entry() //  [R1, R2, R3]
         { info_tbl: [(c6wO8,
                       label: go_s6v1E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wO8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wO9; else goto c6wOa;
       c6wO9: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wOa: // global
           I64[Sp - 32] = block_c6wO1_info;
           _s6v1E::P64 = R1;
           _s6v1B::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6v1B::P64;
           P64[Sp - 16] = _s6v1E::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wOk; else goto c6wO2;
       u6wOk: // global
           call _c6wO1(R1) args: 0, res: 0, upd: 0;
       c6wO2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wO1() //  [R1]
         { info_tbl: [(c6wO1,
                       label: block_c6wO1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wO1: // global
           if (R1 & 7 == 1) goto c6wO5; else goto c6wO6;
       c6wO5: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wO6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6wOi; else goto c6wOh;
       c6wOi: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wOh: // global
           _s6v1I::P64 = P64[R1 + 6];
           _s6v1J::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6v1I::P64;
           P64[Hp] = _s6v1J::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6wOl,
                       label: Data.Semigroup.Internal.$w$csconcat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wOl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wOp; else goto c6wOo;
       c6wOp: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wOo: // global
           I64[Hp - 8] = go_s6v1E_info;
           P64[Hp] = R2;
           _s6v1C::P64 = R3;
           R3 = R4;
           R2 = _s6v1C::P64;
           R1 = Hp - 6;
           call go_s6v1E_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.656169407 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupDual_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupDual_$csconcat_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c6wOx,
                       label: Data.Semigroup.Internal.$fSemigroupDual_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wOx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wOy; else goto c6wOz;
       c6wOy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wOz: // global
           I64[Sp - 16] = block_c6wOu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6wOD; else goto c6wOv;
       u6wOD: // global
           call _c6wOu(R1) args: 0, res: 0, upd: 0;
       c6wOv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wOu() //  [R1]
         { info_tbl: [(c6wOu,
                       label: block_c6wOu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wOu: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.658119863 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupDual_closure" {
     Data.Semigroup.Internal.$fSemigroupDual_closure:
         const Data.Semigroup.Internal.$fSemigroupDual_info;
 },
 sat_s6v1Y_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6wON,
                       label: sat_s6v1Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wON: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wOO; else goto c6wOP;
       c6wOO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wOP: // global
           _s6v1V::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s6v1V::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Base.stimes_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6v1U_entry() //  [R1, R2]
         { info_tbl: [(c6wOV,
                       label: sat_s6v1U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wOV: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupDual_$csconcat_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v1T_entry() //  [R1, R2, R3]
         { info_tbl: [(c6wP3,
                       label: sat_s6v1T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wP3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wP4; else goto c6wP5;
       c6wP4: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wP5: // global
           _s6v1R::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = _s6v1R::P64;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fSemigroupDual_entry() //  [R2]
         { info_tbl: [(c6wP7,
                       label: Data.Semigroup.Internal.$fSemigroupDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wP7: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6wPb; else goto c6wPa;
       c6wPb: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wPa: // global
           I64[Hp - 72] = sat_s6v1Y_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v1U_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v1T_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 69;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.659987034 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_info;
 },
 sat_s6v20_entry() //  [R1]
         { info_tbl: [(c6wPk,
                       label: sat_s6v20_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wPk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wPl; else goto c6wPm;
       c6wPl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wPm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(c6wPn,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wPn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wPr; else goto c6wPq;
       c6wPr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wPq: // global
           I64[Hp - 16] = sat_s6v20_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fSemigroupDual_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.661229963 UTC

[section ""data" . $cmappend_r6v15_closure" {
     $cmappend_r6v15_closure:
         const $cmappend_r6v15_info;
 },
 $cmappend_r6v15_entry() //  [R2, R3, R4]
         { info_tbl: [(c6wPy,
                       label: $cmappend_r6v15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wPy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6wPz; else goto c6wPA;
       c6wPz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cmappend_r6v15_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wPA: // global
           I64[Sp - 24] = block_c6wPw_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6wPw() //  [R1]
         { info_tbl: [(c6wPw,
                       label: block_c6wPw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wPw: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _s6v22::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6v22::P64;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.662433044 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cmappend_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cmappend_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cmappend_info;
 },
 Data.Semigroup.Internal.$fMonoidDual_$cmappend_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c6wPI,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cmappend_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wPI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cmappend_r6v15_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.664043021 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cmconcat_info;
 },
 lvl12_s6v27_entry() //  [R1]
         { info_tbl: [(c6wPT,
                       label: lvl12_s6v27_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wPT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wPU; else goto c6wPV;
       c6wPU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wPV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s6v28_entry() //  [R1]
         { info_tbl: [(c6wQ0,
                       label: z_s6v28_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wQ0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wQ1; else goto c6wQ2;
       c6wQ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wQ2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s6v29_entry() //  [R1, R2]
         { info_tbl: [(c6wQf,
                       label: go_s6v29_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wQf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wQg; else goto c6wQh;
       c6wQg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wQh: // global
           I64[Sp - 32] = block_c6wQ8_info;
           _s6v29::P64 = R1;
           _s6v27::P64 = P64[R1 + 7];
           _s6v28::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6v27::P64;
           P64[Sp - 16] = _s6v28::P64;
           P64[Sp - 8] = _s6v29::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wQr; else goto c6wQ9;
       u6wQr: // global
           call _c6wQ8(R1) args: 0, res: 0, upd: 0;
       c6wQ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wQ8() //  [R1]
         { info_tbl: [(c6wQ8,
                       label: block_c6wQ8_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wQ8: // global
           if (R1 & 7 == 1) goto c6wQc; else goto c6wQd;
       c6wQc: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wQd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wQp; else goto c6wQo;
       c6wQp: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wQo: // global
           _s6v2c::P64 = P64[R1 + 6];
           _s6v2d::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6v2d::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = _s6v2c::P64;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c6wQs,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wQs: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6wQw; else goto c6wQv;
       c6wQw: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wQv: // global
           I64[Hp - 64] = lvl12_s6v27_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = z_s6v28_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6v29_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s6v29_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.666764736 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_closure" {
     Data.Semigroup.Internal.$fMonoidDual_closure:
         const Data.Semigroup.Internal.$fMonoidDual_info;
 },
 sat_s6v2j_entry() //  [R1, R2]
         { info_tbl: [(c6wQG,
                       label: sat_s6v2j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wQG: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fMonoidDual_$cmconcat_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2i_entry() //  [R1, R2, R3]
         { info_tbl: [(c6wQO,
                       label: sat_s6v2i_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wQO: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fMonoidDual_$cmappend_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2h_entry() //  [R1]
         { info_tbl: [(c6wQV,
                       label: sat_s6v2h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wQV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wQW; else goto c6wQX;
       c6wQW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wQX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v2g_entry() //  [R1]
         { info_tbl: [(c6wR2,
                       label: sat_s6v2g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wR2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wR3; else goto c6wR4;
       c6wR3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wR4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_entry() //  [R2]
         { info_tbl: [(c6wR6,
                       label: Data.Semigroup.Internal.$fMonoidDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wR6: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6wRa; else goto c6wR9;
       c6wRa: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wR9: // global
           I64[Hp - 112] = sat_s6v2j_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s6v2i_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v2h_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v2g_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 94;
           P64[Hp] = Hp - 111;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.668539163 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual2_closure" {
     Data.Semigroup.Internal.$fFunctorDual2_closure:
         const Data.Semigroup.Internal.$fFunctorDual2_info;
 },
 Data.Semigroup.Internal.$fFunctorDual2_entry() //  [R2]
         { info_tbl: [(c6wRf,
                       label: Data.Semigroup.Internal.$fFunctorDual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wRf: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.669334148 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual1_closure" {
     Data.Semigroup.Internal.$fFunctorDual1_closure:
         const Data.Semigroup.Internal.$fFunctorDual1_info;
 },
 Data.Semigroup.Internal.$fFunctorDual1_entry() //  [R2]
         { info_tbl: [(c6wRm,
                       label: Data.Semigroup.Internal.$fFunctorDual1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wRm: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.670071863 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual_closure" {
     Data.Semigroup.Internal.$fFunctorDual_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.670850725 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual3_closure" {
     Data.Semigroup.Internal.$fApplicativeDual3_closure:
         const Data.Semigroup.Internal.$fApplicativeDual3_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual3_entry() //  [R2]
         { info_tbl: [(c6wRt,
                       label: Data.Semigroup.Internal.$fApplicativeDual3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wRt: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.671665164 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual4_closure" {
     Data.Semigroup.Internal.$fApplicativeDual4_closure:
         const Data.Semigroup.Internal.$fApplicativeDual4_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual4_entry() //  [R2]
         { info_tbl: [(c6wRA,
                       label: Data.Semigroup.Internal.$fApplicativeDual4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wRA: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.6725539 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual2_closure" {
     Data.Semigroup.Internal.$fApplicativeDual2_closure:
         const Data.Semigroup.Internal.$fApplicativeDual2_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual2_entry() //  [R2, R3]
         { info_tbl: [(c6wRH,
                       label: Data.Semigroup.Internal.$fApplicativeDual2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wRH: // global
           _s6v2p::P64 = R2;
           R2 = R3;
           R1 = _s6v2p::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.673738686 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeDual_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual_$c*>_entry() //  [R3]
         { info_tbl: [(c6wRO,
                       label: Data.Semigroup.Internal.$fApplicativeDual_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wRO: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.675336021 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual1_closure" {
     Data.Semigroup.Internal.$fApplicativeDual1_closure:
         const Data.Semigroup.Internal.$fApplicativeDual1_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual1_entry() //  [R2]
         { info_tbl: [(c6wRV,
                       label: Data.Semigroup.Internal.$fApplicativeDual1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wRV: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.676028345 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual_closure" {
     Data.Semigroup.Internal.$fApplicativeDual_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorDual_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.677139674 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum1_closure" {
     Data.Semigroup.Internal.$fSemigroupSum1_closure:
         const Data.Semigroup.Internal.$fSemigroupSum1_info;
 },
 sat_s6v2z_entry() //  [R1]
         { info_tbl: [(c6wSa,
                       label: sat_s6v2z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wSa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wSb; else goto c6wSc;
       c6wSb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wSc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6v2A_entry() //  [R1]
         { info_tbl: [(c6wSd,
                       label: sat_s6v2A_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wSd: // global
           _s6v2A::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c6wSe; else goto c6wSf;
       c6wSf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wSh; else goto c6wSg;
       c6wSh: // global
           HpAlloc = 32;
           goto c6wSe;
       c6wSe: // global
           R1 = _s6v2A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wSg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v2A::P64;
           _s6v2v::P64 = P64[_s6v2A::P64 + 16];
           _s6v2w::P64 = P64[_s6v2A::P64 + 24];
           _s6v2x::P64 = P64[_s6v2A::P64 + 32];
           I64[Hp - 24] = sat_s6v2z_info;
           P64[Hp - 8] = _s6v2w::P64;
           P64[Hp] = _s6v2x::P64;
           R2 = _s6v2v::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupSum1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c6wSi,
                       label: Data.Semigroup.Internal.$fSemigroupSum1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wSi: // global
           _s6v2y::P64 = R5;
           _s6v2x::P64 = R4;
           _s6v2w::P64 = R3;
           _s6v2v::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c6wSj; else goto c6wSk;
       c6wSk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6wSm; else goto c6wSl;
       c6wSm: // global
           HpAlloc = 40;
           goto c6wSj;
       c6wSj: // global
           R5 = _s6v2y::P64;
           R4 = _s6v2x::P64;
           R3 = _s6v2w::P64;
           R2 = _s6v2v::P64;
           R1 = Data.Semigroup.Internal.$fSemigroupSum1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wSl: // global
           I64[Hp - 32] = sat_s6v2A_info;
           P64[Hp - 16] = _s6v2v::P64;
           P64[Hp - 8] = _s6v2w::P64;
           P64[Hp] = _s6v2x::P64;
           R2 = _s6v2v::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s6v2y::P64;
           Sp = Sp - 24;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.679454313 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat3_closure" {
     Data.Semigroup.Internal.$w$csconcat3_closure:
         const Data.Semigroup.Internal.$w$csconcat3_info;
 },
 go_s6v2E_entry() //  [R1, R2, R3]
         { info_tbl: [(c6wSD,
                       label: go_s6v2E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wSD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wSE; else goto c6wSF;
       c6wSE: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wSF: // global
           I64[Sp - 32] = block_c6wSw_info;
           _s6v2E::P64 = R1;
           _s6v2B::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6v2B::P64;
           P64[Sp - 16] = _s6v2E::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wSP; else goto c6wSx;
       u6wSP: // global
           call _c6wSw(R1) args: 0, res: 0, upd: 0;
       c6wSx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wSw() //  [R1]
         { info_tbl: [(c6wSw,
                       label: block_c6wSw_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wSw: // global
           _s6v2F::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6wSA; else goto c6wSB;
       c6wSA: // global
           R1 = _s6v2F::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wSB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6wSN; else goto c6wSM;
       c6wSN: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wSM: // global
           _s6v2I::P64 = P64[R1 + 6];
           _s6v2J::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6v2I::P64;
           P64[Hp] = _s6v2J::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v2F::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat3_entry() //  [R2, R3, R4]
         { info_tbl: [(c6wSQ,
                       label: Data.Semigroup.Internal.$w$csconcat3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wSQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wSU; else goto c6wST;
       c6wSU: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wST: // global
           I64[Hp - 8] = go_s6v2E_info;
           P64[Hp] = R2;
           _s6v2C::P64 = R3;
           R3 = R4;
           R2 = _s6v2C::P64;
           R1 = Hp - 6;
           call go_s6v2E_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.681402056 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupSum_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupSum_$csconcat_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c6wT2,
                       label: Data.Semigroup.Internal.$fSemigroupSum_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wT2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wT3; else goto c6wT4;
       c6wT3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wT4: // global
           I64[Sp - 16] = block_c6wSZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6wT8; else goto c6wT0;
       u6wT8: // global
           call _c6wSZ(R1) args: 0, res: 0, upd: 0;
       c6wT0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wSZ() //  [R1]
         { info_tbl: [(c6wSZ,
                       label: block_c6wSZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wSZ: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat3_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.682997053 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum_closure" {
     Data.Semigroup.Internal.$fSemigroupSum_closure:
         const Data.Semigroup.Internal.$fSemigroupSum_info;
 },
 sat_s6v2T_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6wTi,
                       label: sat_s6v2T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wTi: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Semigroup.Internal.$fSemigroupSum1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2S_entry() //  [R1, R2]
         { info_tbl: [(c6wTq,
                       label: sat_s6v2S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wTq: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupSum_$csconcat_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2R_entry() //  [R1]
         { info_tbl: [(c6wTx,
                       label: sat_s6v2R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wTx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wTy; else goto c6wTz;
       c6wTy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wTz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupSum_entry() //  [R2]
         { info_tbl: [(c6wTB,
                       label: Data.Semigroup.Internal.$fSemigroupSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wTB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6wTF; else goto c6wTE;
       c6wTF: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wTE: // global
           I64[Hp - 80] = sat_s6v2T_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v2S_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6v2R_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 77;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.684651719 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum1_closure" {
     Data.Semigroup.Internal.$fMonoidSum1_closure:
         const Data.Semigroup.Internal.$fMonoidSum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidSum1_entry() //  [R1]
         { info_tbl: [(c6wTM,
                       label: Data.Semigroup.Internal.$fMonoidSum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wTM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wTN; else goto c6wTO;
       c6wTN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wTO: // global
           (_c6wTJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wTJ::I64 == 0) goto c6wTL; else goto c6wTK;
       c6wTL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wTK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wTJ::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.68604359 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum2_closure" {
     Data.Semigroup.Internal.$fMonoidSum2_closure:
         const Data.Semigroup.Internal.$fMonoidSum2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidSum2_entry() //  [R2]
         { info_tbl: [(c6wTT,
                       label: Data.Semigroup.Internal.$fMonoidSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wTT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wTU; else goto c6wTV;
       c6wTU: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wTV: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.687611805 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidSum_$cmconcat_info;
         const 0;
 },
 z_s6v2W_entry() //  [R1]
         { info_tbl: [(c6wU4,
                       label: z_s6v2W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wU4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wU5; else goto c6wU6;
       c6wU5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wU6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s6v2X_entry() //  [R1, R2]
         { info_tbl: [(c6wUj,
                       label: go_s6v2X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wUj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wUk; else goto c6wUl;
       c6wUk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wUl: // global
           I64[Sp - 32] = block_c6wUc_info;
           _s6v2X::P64 = R1;
           _s6v2V::P64 = P64[R1 + 7];
           _s6v2W::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6v2V::P64;
           P64[Sp - 16] = _s6v2W::P64;
           P64[Sp - 8] = _s6v2X::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wUv; else goto c6wUd;
       u6wUv: // global
           call _c6wUc(R1) args: 0, res: 0, upd: 0;
       c6wUd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wUc() //  [R1]
         { info_tbl: [(c6wUc,
                       label: block_c6wUc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wUc: // global
           if (R1 & 7 == 1) goto c6wUg; else goto c6wUh;
       c6wUg: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wUh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wUt; else goto c6wUs;
       c6wUt: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wUs: // global
           _s6v30::P64 = P64[R1 + 6];
           _s6v31::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6v31::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v30::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidSum_$cmconcat_entry() //  [R2]
         { info_tbl: [(c6wUw,
                       label: Data.Semigroup.Internal.$fMonoidSum_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wUw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6wUA; else goto c6wUz;
       c6wUA: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wUz: // global
           I64[Hp - 40] = z_s6v2W_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6v2X_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.690056462 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum_closure" {
     Data.Semigroup.Internal.$fMonoidSum_closure:
         const Data.Semigroup.Internal.$fMonoidSum_info;
         const 0;
 },
 sat_s6v37_entry() //  [R1]
         { info_tbl: [(c6wUJ,
                       label: sat_s6v37_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wUJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wUK; else goto c6wUL;
       c6wUK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wUL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_$cmconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v36_entry() //  [R1]
         { info_tbl: [(c6wUQ,
                       label: sat_s6v36_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wUQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wUR; else goto c6wUS;
       c6wUR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wUS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v35_entry() //  [R1]
         { info_tbl: [(c6wUX,
                       label: sat_s6v35_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wUX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wUY; else goto c6wUZ;
       c6wUY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wUZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v34_entry() //  [R1]
         { info_tbl: [(c6wV4,
                       label: sat_s6v34_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wV4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wV5; else goto c6wV6;
       c6wV5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wV6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidSum_entry() //  [R2]
         { info_tbl: [(c6wV8,
                       label: Data.Semigroup.Internal.$fMonoidSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wV8: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6wVc; else goto c6wVb;
       c6wVc: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wVb: // global
           I64[Hp - 128] = sat_s6v37_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v36_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v35_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v34_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.691914022 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorSum_closure" {
     Data.Semigroup.Internal.$fFunctorSum_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.692582 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum3_closure" {
     Data.Semigroup.Internal.$fApplicativeSum3_closure:
         const Data.Semigroup.Internal.$fApplicativeSum3_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum3_entry() //  [R2]
         { info_tbl: [(c6wVh,
                       label: Data.Semigroup.Internal.$fApplicativeSum3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wVh: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.693413391 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum2_closure" {
     Data.Semigroup.Internal.$fApplicativeSum2_closure:
         const Data.Semigroup.Internal.$fApplicativeSum2_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum2_entry() //  [R2, R3]
         { info_tbl: [(c6wVo,
                       label: Data.Semigroup.Internal.$fApplicativeSum2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wVo: // global
           _s6v39::P64 = R2;
           R2 = R3;
           R1 = _s6v39::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.694280736 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeSum_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum_$c*>_entry() //  [R3]
         { info_tbl: [(c6wVv,
                       label: Data.Semigroup.Internal.$fApplicativeSum_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wVv: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.695079634 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum1_closure" {
     Data.Semigroup.Internal.$fApplicativeSum1_closure:
         const Data.Semigroup.Internal.$fApplicativeSum1_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum1_entry() //  [R2]
         { info_tbl: [(c6wVC,
                       label: Data.Semigroup.Internal.$fApplicativeSum1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wVC: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.695829636 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum_closure" {
     Data.Semigroup.Internal.$fApplicativeSum_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorSum_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeSum3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeSum2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeSum1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.697053018 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat2_closure" {
     Data.Semigroup.Internal.$w$csconcat2_closure:
         const Data.Semigroup.Internal.$w$csconcat2_info;
 },
 go_s6v3i_entry() //  [R1, R2, R3]
         { info_tbl: [(c6wVV,
                       label: go_s6v3i_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wVV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wVW; else goto c6wVX;
       c6wVW: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wVX: // global
           I64[Sp - 32] = block_c6wVO_info;
           _s6v3i::P64 = R1;
           _s6v3f::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6v3f::P64;
           P64[Sp - 16] = _s6v3i::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wW7; else goto c6wVP;
       u6wW7: // global
           call _c6wVO(R1) args: 0, res: 0, upd: 0;
       c6wVP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wVO() //  [R1]
         { info_tbl: [(c6wVO,
                       label: block_c6wVO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wVO: // global
           _s6v3j::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6wVS; else goto c6wVT;
       c6wVS: // global
           R1 = _s6v3j::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wVT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6wW5; else goto c6wW4;
       c6wW5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wW4: // global
           _s6v3m::P64 = P64[R1 + 6];
           _s6v3n::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6v3m::P64;
           P64[Hp] = _s6v3n::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v3j::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat2_entry() //  [R2, R3, R4]
         { info_tbl: [(c6wW8,
                       label: Data.Semigroup.Internal.$w$csconcat2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wW8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6wWc; else goto c6wWb;
       c6wWc: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wWb: // global
           I64[Hp - 8] = go_s6v3i_info;
           P64[Hp] = R2;
           _s6v3g::P64 = R3;
           R3 = R4;
           R2 = _s6v3g::P64;
           R1 = Hp - 6;
           call go_s6v3i_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.699327905 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c6wWk,
                       label: Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wWk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wWl; else goto c6wWm;
       c6wWl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6wWm: // global
           I64[Sp - 16] = block_c6wWh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6wWq; else goto c6wWi;
       u6wWq: // global
           call _c6wWh(R1) args: 0, res: 0, upd: 0;
       c6wWi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wWh() //  [R1]
         { info_tbl: [(c6wWh,
                       label: block_c6wWh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wWh: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat2_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.701022974 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupProduct_closure" {
     Data.Semigroup.Internal.$fSemigroupProduct_closure:
         const Data.Semigroup.Internal.$fSemigroupProduct_info;
         const 0;
 },
 sat_s6v3A_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6wWA,
                       label: sat_s6v3A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wWA: // global
           R5 = R3;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v3w_entry() //  [R1, R2]
         { info_tbl: [(c6wWI,
                       label: sat_s6v3w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wWI: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v3v_entry() //  [R1]
         { info_tbl: [(c6wWP,
                       label: sat_s6v3v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wWP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wWQ; else goto c6wWR;
       c6wWQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wWR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupProduct_entry() //  [R2]
         { info_tbl: [(c6wWT,
                       label: Data.Semigroup.Internal.$fSemigroupProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wWT: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6wWX; else goto c6wWW;
       c6wWX: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wWW: // global
           I64[Hp - 80] = sat_s6v3A_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v3w_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6v3v_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 77;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.703634714 UTC

[section ""data" . sat_s6v3B_closure" {
     sat_s6v3B_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.704230472 UTC

[section ""data" . sat_s6v3C_closure" {
     sat_s6v3C_closure:
         const :_con_info;
         const sat_s6v3B_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.704982316 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct1_closure" {
     Data.Semigroup.Internal.$fMonoidProduct1_closure:
         const Data.Semigroup.Internal.$fMonoidProduct1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidProduct1_entry() //  [R1]
         { info_tbl: [(c6wX4,
                       label: Data.Semigroup.Internal.$fMonoidProduct1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wX4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wX5; else goto c6wX6;
       c6wX5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wX6: // global
           (_c6wX1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6wX1::I64 == 0) goto c6wX3; else goto c6wX2;
       c6wX3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6wX2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6wX1::I64;
           R3 = sat_s6v3C_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.706073756 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct2_closure" {
     Data.Semigroup.Internal.$fMonoidProduct2_closure:
         const Data.Semigroup.Internal.$fMonoidProduct2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidProduct2_entry() //  [R2]
         { info_tbl: [(c6wXb,
                       label: Data.Semigroup.Internal.$fMonoidProduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wXb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wXc; else goto c6wXd;
       c6wXc: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wXd: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.707572802 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_info;
         const 0;
 },
 z_s6v3F_entry() //  [R1]
         { info_tbl: [(c6wXm,
                       label: z_s6v3F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wXm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wXn; else goto c6wXo;
       c6wXn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wXo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s6v3G_entry() //  [R1, R2]
         { info_tbl: [(c6wXB,
                       label: go_s6v3G_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wXB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6wXC; else goto c6wXD;
       c6wXC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wXD: // global
           I64[Sp - 32] = block_c6wXu_info;
           _s6v3G::P64 = R1;
           _s6v3E::P64 = P64[R1 + 7];
           _s6v3F::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6v3E::P64;
           P64[Sp - 16] = _s6v3F::P64;
           P64[Sp - 8] = _s6v3G::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6wXN; else goto c6wXv;
       u6wXN: // global
           call _c6wXu(R1) args: 0, res: 0, upd: 0;
       c6wXv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6wXu() //  [R1]
         { info_tbl: [(c6wXu,
                       label: block_c6wXu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wXu: // global
           if (R1 & 7 == 1) goto c6wXy; else goto c6wXz;
       c6wXy: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6wXz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6wXL; else goto c6wXK;
       c6wXL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6wXK: // global
           _s6v3J::P64 = P64[R1 + 6];
           _s6v3K::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6v3K::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v3J::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_entry() //  [R2]
         { info_tbl: [(c6wXO,
                       label: Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wXO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6wXS; else goto c6wXR;
       c6wXS: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wXR: // global
           I64[Hp - 40] = z_s6v3F_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6v3G_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.710041584 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct_closure" {
     Data.Semigroup.Internal.$fMonoidProduct_closure:
         const Data.Semigroup.Internal.$fMonoidProduct_info;
         const 0;
 },
 sat_s6v3Q_entry() //  [R1]
         { info_tbl: [(c6wY1,
                       label: sat_s6v3Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wY1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wY2; else goto c6wY3;
       c6wY2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wY3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3P_entry() //  [R1]
         { info_tbl: [(c6wY8,
                       label: sat_s6v3P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wY8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wY9; else goto c6wYa;
       c6wY9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wYa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3O_entry() //  [R1]
         { info_tbl: [(c6wYf,
                       label: sat_s6v3O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wYf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wYg; else goto c6wYh;
       c6wYg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wYh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3N_entry() //  [R1]
         { info_tbl: [(c6wYm,
                       label: sat_s6v3N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wYn; else goto c6wYo;
       c6wYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidProduct_entry() //  [R2]
         { info_tbl: [(c6wYq,
                       label: Data.Semigroup.Internal.$fMonoidProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wYq: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6wYu; else goto c6wYt;
       c6wYu: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wYt: // global
           I64[Hp - 128] = sat_s6v3Q_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v3P_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v3O_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v3N_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.711849743 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorProduct_closure" {
     Data.Semigroup.Internal.$fFunctorProduct_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.712580818 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct3_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct3_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct3_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct3_entry() //  [R2]
         { info_tbl: [(c6wYz,
                       label: Data.Semigroup.Internal.$fApplicativeProduct3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wYz: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.713659502 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct2_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct2_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct2_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct2_entry() //  [R2, R3]
         { info_tbl: [(c6wYG,
                       label: Data.Semigroup.Internal.$fApplicativeProduct2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wYG: // global
           _s6v3S::P64 = R2;
           R2 = R3;
           R1 = _s6v3S::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.714494425 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct_$c*>_entry() //  [R3]
         { info_tbl: [(c6wYN,
                       label: Data.Semigroup.Internal.$fApplicativeProduct_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wYN: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.71526371 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct1_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct1_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct1_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct1_entry() //  [R2]
         { info_tbl: [(c6wYU,
                       label: Data.Semigroup.Internal.$fApplicativeProduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wYU: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.715991292 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorProduct_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeProduct3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeProduct2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeProduct1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.717043198 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorAlt_closure" {
     Data.Semigroup.Internal.$fFunctorAlt_closure:
         const Data.Semigroup.Internal.$fFunctorAlt_info;
 },
 sat_s6v40_entry() //  [R1]
         { info_tbl: [(c6wZ5,
                       label: sat_s6v40_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wZ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wZ6; else goto c6wZ7;
       c6wZ6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wZ7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3Z_entry() //  [R1]
         { info_tbl: [(c6wZc,
                       label: sat_s6v3Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wZc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wZd; else goto c6wZe;
       c6wZd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wZe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fFunctorAlt_entry() //  [R2]
         { info_tbl: [(c6wZg,
                       label: Data.Semigroup.Internal.$fFunctorAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wZg: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6wZk; else goto c6wZj;
       c6wZk: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fFunctorAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wZj: // global
           I64[Hp - 64] = sat_s6v40_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v3Z_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.718754546 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure" {
     Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure:
         const Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_info;
 },
 sat_s6v42_entry() //  [R1]
         { info_tbl: [(c6wZt,
                       label: sat_s6v42_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wZt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wZu; else goto c6wZv;
       c6wZu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wZv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_entry() //  [R2]
         { info_tbl: [(c6wZw,
                       label: Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wZw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6wZA; else goto c6wZz;
       c6wZA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6wZz: // global
           I64[Hp - 16] = sat_s6v42_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fFunctorAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.720671349 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeAlt_closure" {
     Data.Semigroup.Internal.$fApplicativeAlt_closure:
         const Data.Semigroup.Internal.$fApplicativeAlt_info;
 },
 sat_s6v49_entry() //  [R1]
         { info_tbl: [(c6wZJ,
                       label: sat_s6v49_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wZJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wZK; else goto c6wZL;
       c6wZK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wZL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v48_entry() //  [R1]
         { info_tbl: [(c6wZQ,
                       label: sat_s6v48_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wZQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wZR; else goto c6wZS;
       c6wZR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wZS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v47_entry() //  [R1]
         { info_tbl: [(c6wZX,
                       label: sat_s6v47_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6wZX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6wZY; else goto c6wZZ;
       c6wZY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6wZZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v46_entry() //  [R1]
         { info_tbl: [(c6x04,
                       label: sat_s6v46_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x04: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x05; else goto c6x06;
       c6x05: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x06: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v45_entry() //  [R1]
         { info_tbl: [(c6x0b,
                       label: sat_s6v45_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x0b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x0c; else goto c6x0d;
       c6x0c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x0d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v44_entry() //  [R1]
         { info_tbl: [(c6x0i,
                       label: sat_s6v44_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x0i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x0j; else goto c6x0k;
       c6x0j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x0k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fApplicativeAlt_entry() //  [R2]
         { info_tbl: [(c6x0m,
                       label: Data.Semigroup.Internal.$fApplicativeAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x0m: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c6x0q; else goto c6x0p;
       c6x0q: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fApplicativeAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x0p: // global
           I64[Hp - 192] = sat_s6v49_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6v48_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s6v47_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6v46_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s6v45_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6v44_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 120;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 168;
           P64[Hp] = Hp - 192;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.723286345 UTC

[section ""data" . Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure" {
     Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure:
         const Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_info;
 },
 sat_s6v4b_entry() //  [R1]
         { info_tbl: [(c6x0z,
                       label: sat_s6v4b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x0z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x0A; else goto c6x0B;
       c6x0A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x0B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(c6x0C,
                       label: Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x0C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6x0G; else goto c6x0F;
       c6x0G: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x0F: // global
           I64[Hp - 16] = sat_s6v4b_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.725119676 UTC

[section ""data" . Data.Semigroup.Internal.$fAlternativeAlt_closure" {
     Data.Semigroup.Internal.$fAlternativeAlt_closure:
         const Data.Semigroup.Internal.$fAlternativeAlt_info;
 },
 sat_s6v4h_entry() //  [R1]
         { info_tbl: [(c6x0P,
                       label: sat_s6v4h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x0P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x0Q; else goto c6x0R;
       c6x0Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x0R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.many_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4g_entry() //  [R1]
         { info_tbl: [(c6x0W,
                       label: sat_s6v4g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x0W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x0X; else goto c6x0Y;
       c6x0X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x0Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.some_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4f_entry() //  [R1]
         { info_tbl: [(c6x13,
                       label: sat_s6v4f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x13: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x14; else goto c6x15;
       c6x14: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x15: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4e_entry() //  [R1]
         { info_tbl: [(c6x1a,
                       label: sat_s6v4e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x1a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x1b; else goto c6x1c;
       c6x1b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x1c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4d_entry() //  [R1]
         { info_tbl: [(c6x1h,
                       label: sat_s6v4d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x1h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x1i; else goto c6x1j;
       c6x1i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x1j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fAlternativeAlt_entry() //  [R2]
         { info_tbl: [(c6x1l,
                       label: Data.Semigroup.Internal.$fAlternativeAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x1l: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c6x1p; else goto c6x1o;
       c6x1p: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fAlternativeAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x1o: // global
           I64[Hp - 160] = sat_s6v4h_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4g_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4f_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4e_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v4d_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.727532245 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_info;
 },
 sat_s6v4j_entry() //  [R1]
         { info_tbl: [(c6x1y,
                       label: sat_s6v4j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x1y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x1z; else goto c6x1A;
       c6x1z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x1A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_entry() //  [R2]
         { info_tbl: [(c6x1B,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x1B: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6x1F; else goto c6x1E;
       c6x1F: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x1E: // global
           I64[Hp - 16] = sat_s6v4j_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fAlternativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.728901618 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure" {
     Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure:
         const Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_info;
 },
 sat_s6v4l_entry() //  [R1]
         { info_tbl: [(c6x1O,
                       label: sat_s6v4l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x1O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x1P; else goto c6x1Q;
       c6x1P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x1Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_entry() //  [R2]
         { info_tbl: [(c6x1R,
                       label: Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x1R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6x1V; else goto c6x1U;
       c6x1V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x1U: // global
           I64[Hp - 16] = sat_s6v4l_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.732019311 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadAlt_closure" {
     Data.Semigroup.Internal.$fMonadAlt_closure:
         const Data.Semigroup.Internal.$fMonadAlt_info;
 },
 sat_s6v4r_entry() //  [R1]
         { info_tbl: [(c6x24,
                       label: sat_s6v4r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x24: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x25; else goto c6x26;
       c6x25: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x26: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fail_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4q_entry() //  [R1]
         { info_tbl: [(c6x2b,
                       label: sat_s6v4q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x2b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x2c; else goto c6x2d;
       c6x2c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x2d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4p_entry() //  [R1]
         { info_tbl: [(c6x2i,
                       label: sat_s6v4p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x2j; else goto c6x2k;
       c6x2j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x2k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4o_entry() //  [R1]
         { info_tbl: [(c6x2p,
                       label: sat_s6v4o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x2p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x2q; else goto c6x2r;
       c6x2q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x2r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4n_entry() //  [R1]
         { info_tbl: [(c6x2w,
                       label: sat_s6v4n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x2w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x2x; else goto c6x2y;
       c6x2x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x2y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadAlt_entry() //  [R2]
         { info_tbl: [(c6x2A,
                       label: Data.Semigroup.Internal.$fMonadAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x2A: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c6x2E; else goto c6x2D;
       c6x2E: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x2D: // global
           I64[Hp - 160] = sat_s6v4r_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4q_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4p_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4o_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v4n_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.734366809 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_info;
 },
 sat_s6v4t_entry() //  [R1]
         { info_tbl: [(c6x2N,
                       label: sat_s6v4t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x2N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x2O; else goto c6x2P;
       c6x2O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x2P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_entry() //  [R2]
         { info_tbl: [(c6x2Q,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x2Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6x2U; else goto c6x2T;
       c6x2U: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x2T: // global
           I64[Hp - 16] = sat_s6v4t_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.736004208 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_info;
 },
 sat_s6v4y_entry() //  [R1]
         { info_tbl: [(c6x33,
                       label: sat_s6v4y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x33: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x34; else goto c6x35;
       c6x34: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x35: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mplus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4x_entry() //  [R1]
         { info_tbl: [(c6x3a,
                       label: sat_s6v4x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x3a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x3b; else goto c6x3c;
       c6x3b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x3c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4w_entry() //  [R1]
         { info_tbl: [(c6x3h,
                       label: sat_s6v4w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x3h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x3i; else goto c6x3j;
       c6x3i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x3j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4v_entry() //  [R1]
         { info_tbl: [(c6x3o,
                       label: sat_s6v4v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x3o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x3p; else goto c6x3q;
       c6x3p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x3q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_entry() //  [R2]
         { info_tbl: [(c6x3s,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x3s: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6x3w; else goto c6x3v;
       c6x3w: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x3v: // global
           I64[Hp - 128] = sat_s6v4y_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v4x_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v4w_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v4v_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.738881622 UTC

[section ""data" . Data.Semigroup.Internal.$fEnumAlt_closure" {
     Data.Semigroup.Internal.$fEnumAlt_closure:
         const Data.Semigroup.Internal.$fEnumAlt_info;
 },
 sat_s6v4H_entry() //  [R1]
         { info_tbl: [(c6x3F,
                       label: sat_s6v4H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x3F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x3G; else goto c6x3H;
       c6x3G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x3H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4G_entry() //  [R1]
         { info_tbl: [(c6x3M,
                       label: sat_s6v4G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x3M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x3N; else goto c6x3O;
       c6x3N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x3O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4F_entry() //  [R1]
         { info_tbl: [(c6x3T,
                       label: sat_s6v4F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x3T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x3U; else goto c6x3V;
       c6x3U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x3V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4E_entry() //  [R1]
         { info_tbl: [(c6x40,
                       label: sat_s6v4E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x40: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x41; else goto c6x42;
       c6x41: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x42: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4D_entry() //  [R1]
         { info_tbl: [(c6x47,
                       label: sat_s6v4D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x47: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x48; else goto c6x49;
       c6x48: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x49: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4C_entry() //  [R1]
         { info_tbl: [(c6x4e,
                       label: sat_s6v4C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x4e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x4f; else goto c6x4g;
       c6x4f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x4g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4B_entry() //  [R1]
         { info_tbl: [(c6x4l,
                       label: sat_s6v4B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x4l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x4m; else goto c6x4n;
       c6x4m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x4n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4A_entry() //  [R1]
         { info_tbl: [(c6x4s,
                       label: sat_s6v4A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x4s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x4t; else goto c6x4u;
       c6x4t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x4u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEnumAlt_entry() //  [R2]
         { info_tbl: [(c6x4w,
                       label: Data.Semigroup.Internal.$fEnumAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x4w: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6x4A; else goto c6x4z;
       c6x4A: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEnumAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x4z: // global
           I64[Hp - 256] = sat_s6v4H_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v4G_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v4F_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v4E_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v4D_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4C_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4B_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4A_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.742799912 UTC

[section ""data" . Data.Semigroup.Internal.$fNumAlt_closure" {
     Data.Semigroup.Internal.$fNumAlt_closure:
         const Data.Semigroup.Internal.$fNumAlt_info;
 },
 sat_s6v4P_entry() //  [R1]
         { info_tbl: [(c6x4J,
                       label: sat_s6v4P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x4J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x4K; else goto c6x4L;
       c6x4K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x4L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4O_entry() //  [R1]
         { info_tbl: [(c6x4Q,
                       label: sat_s6v4O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x4Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x4R; else goto c6x4S;
       c6x4R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x4S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4N_entry() //  [R1]
         { info_tbl: [(c6x4X,
                       label: sat_s6v4N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x4X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x4Y; else goto c6x4Z;
       c6x4Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x4Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4M_entry() //  [R1]
         { info_tbl: [(c6x54,
                       label: sat_s6v4M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x54: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x55; else goto c6x56;
       c6x55: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x56: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4L_entry() //  [R1]
         { info_tbl: [(c6x5b,
                       label: sat_s6v4L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x5b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x5c; else goto c6x5d;
       c6x5c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x5d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4K_entry() //  [R1]
         { info_tbl: [(c6x5i,
                       label: sat_s6v4K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x5i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x5j; else goto c6x5k;
       c6x5j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x5k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4J_entry() //  [R1]
         { info_tbl: [(c6x5p,
                       label: sat_s6v4J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x5p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x5q; else goto c6x5r;
       c6x5q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x5r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumAlt_entry() //  [R2]
         { info_tbl: [(c6x5t,
                       label: Data.Semigroup.Internal.$fNumAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x5t: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6x5x; else goto c6x5w;
       c6x5x: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x5w: // global
           I64[Hp - 224] = sat_s6v4P_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6v4O_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6v4N_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6v4M_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6v4L_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v4K_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v4J_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.745683234 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAlt_closure" {
     Data.Semigroup.Internal.$fEqAlt_closure:
         const Data.Semigroup.Internal.$fEqAlt_info;
 },
 sat_s6v4S_entry() //  [R1]
         { info_tbl: [(c6x5G,
                       label: sat_s6v4S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x5G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x5H; else goto c6x5I;
       c6x5H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x5I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4R_entry() //  [R1]
         { info_tbl: [(c6x5N,
                       label: sat_s6v4R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x5N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x5O; else goto c6x5P;
       c6x5O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x5P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqAlt_entry() //  [R2]
         { info_tbl: [(c6x5R,
                       label: Data.Semigroup.Internal.$fEqAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x5R: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6x5V; else goto c6x5U;
       c6x5V: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x5U: // global
           I64[Hp - 64] = sat_s6v4S_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v4R_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.747272772 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_info;
 },
 sat_s6v4U_entry() //  [R1]
         { info_tbl: [(c6x64,
                       label: sat_s6v4U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x64: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x65; else goto c6x66;
       c6x65: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x66: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6x67,
                       label: Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x67: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6x6b; else goto c6x6a;
       c6x6b: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x6a: // global
           I64[Hp - 16] = sat_s6v4U_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.749393893 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAlt_closure" {
     Data.Semigroup.Internal.$fOrdAlt_closure:
         const Data.Semigroup.Internal.$fOrdAlt_info;
 },
 sat_s6v53_entry() //  [R1]
         { info_tbl: [(c6x6k,
                       label: sat_s6v53_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x6k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x6l; else goto c6x6m;
       c6x6l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x6m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v52_entry() //  [R1]
         { info_tbl: [(c6x6r,
                       label: sat_s6v52_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x6r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x6s; else goto c6x6t;
       c6x6s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x6t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v51_entry() //  [R1]
         { info_tbl: [(c6x6y,
                       label: sat_s6v51_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x6y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x6z; else goto c6x6A;
       c6x6z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x6A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v50_entry() //  [R1]
         { info_tbl: [(c6x6F,
                       label: sat_s6v50_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x6F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x6G; else goto c6x6H;
       c6x6G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x6H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4Z_entry() //  [R1]
         { info_tbl: [(c6x6M,
                       label: sat_s6v4Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x6M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x6N; else goto c6x6O;
       c6x6N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x6O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4Y_entry() //  [R1]
         { info_tbl: [(c6x6T,
                       label: sat_s6v4Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x6T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x6U; else goto c6x6V;
       c6x6U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x6V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4X_entry() //  [R1]
         { info_tbl: [(c6x70,
                       label: sat_s6v4X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x70: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x71; else goto c6x72;
       c6x71: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x72: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4W_entry() //  [R1]
         { info_tbl: [(c6x77,
                       label: sat_s6v4W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x78; else goto c6x79;
       c6x78: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x79: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdAlt_entry() //  [R2]
         { info_tbl: [(c6x7b,
                       label: Data.Semigroup.Internal.$fOrdAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x7b: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6x7f; else goto c6x7e;
       c6x7f: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x7e: // global
           I64[Hp - 256] = sat_s6v53_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v52_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v51_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v50_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v4Z_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4Y_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4X_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4W_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.752182523 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt1_closure" {
     Data.Semigroup.Internal.$fShowAlt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.752794831 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAlt3_bytes" {
     Data.Semigroup.Internal.$fShowAlt3_bytes:
         I8[] [65,108,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.753523442 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAlt2_bytes" {
     Data.Semigroup.Internal.$fShowAlt2_bytes:
         I8[] [103,101,116,65,108,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.75414371 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll5_bytes" {
     Data.Semigroup.Internal.$fReadAll5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.7565249 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec1_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec1_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec1_info;
 },
 f1_s6v57_entry() //  [R1]
         { info_tbl: [(c6x7o,
                       label: f1_s6v57_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x7o: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6x7p; else goto c6x7q;
       c6x7p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x7q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6v5a_entry() //  [R1]
         { info_tbl: [(c6x7L,
                       label: sat_s6v5a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x7L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x7M; else goto c6x7N;
       c6x7M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x7N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5b_entry() //  [R1]
         { info_tbl: [(c6x7O,
                       label: sat_s6v5b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x7O: // global
           _s6v5b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6x7P; else goto c6x7Q;
       c6x7Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6x7S; else goto c6x7R;
       c6x7S: // global
           HpAlloc = 24;
           goto c6x7P;
       c6x7P: // global
           R1 = _s6v5b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x7R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5b::P64;
           _s6v57::P64 = P64[_s6v5b::P64 + 16];
           _s6v59::P64 = P64[_s6v5b::P64 + 24];
           I64[Hp - 16] = sat_s6v5a_info;
           P64[Hp] = _s6v59::P64;
           R2 = Hp - 16;
           R1 = _s6v57::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5c_entry() //  [R1]
         { info_tbl: [(c6x7T,
                       label: sat_s6v5c_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x7T: // global
           _s6v5c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6x7U; else goto c6x7V;
       c6x7V: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6x7X; else goto c6x7W;
       c6x7X: // global
           HpAlloc = 32;
           goto c6x7U;
       c6x7U: // global
           R1 = _s6v5c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x7W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5c::P64;
           _s6v57::P64 = P64[_s6v5c::P64 + 16];
           _s6v59::P64 = P64[_s6v5c::P64 + 24];
           I64[Hp - 24] = sat_s6v5b_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = _s6v59::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5d_entry() //  [R1, R2]
         { info_tbl: [(c6x7Y,
                       label: sat_s6v5d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x7Y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6x82; else goto c6x81;
       c6x82: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x81: // global
           _s6v57::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v5c_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5g_entry() //  [R1]
         { info_tbl: [(c6x8q,
                       label: sat_s6v5g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x8q: // global
           _s6v5g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6x8r; else goto c6x8s;
       c6x8s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6x8u; else goto c6x8t;
       c6x8u: // global
           HpAlloc = 24;
           goto c6x8r;
       c6x8r: // global
           R1 = _s6v5g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x8t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5g::P64;
           _s6v5e::P64 = P64[_s6v5g::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v5e::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5h_entry() //  [R1]
         { info_tbl: [(c6x8v,
                       label: sat_s6v5h_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x8v: // global
           _s6v5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6x8w; else goto c6x8x;
       c6x8x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6x8z; else goto c6x8y;
       c6x8z: // global
           HpAlloc = 24;
           goto c6x8w;
       c6x8w: // global
           R1 = _s6v5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x8y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5h::P64;
           _s6v57::P64 = P64[_s6v5h::P64 + 16];
           _s6v5e::P64 = P64[_s6v5h::P64 + 24];
           I64[Hp - 16] = sat_s6v5g_info;
           P64[Hp] = _s6v5e::P64;
           R2 = Hp - 16;
           R1 = _s6v57::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5i_entry() //  [R1]
         { info_tbl: [(c6x8A,
                       label: sat_s6v5i_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x8A: // global
           _s6v5i::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6x8B; else goto c6x8C;
       c6x8C: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6x8E; else goto c6x8D;
       c6x8E: // global
           HpAlloc = 32;
           goto c6x8B;
       c6x8B: // global
           R1 = _s6v5i::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x8D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5i::P64;
           _s6v57::P64 = P64[_s6v5i::P64 + 16];
           _s6v5e::P64 = P64[_s6v5i::P64 + 24];
           I64[Hp - 24] = sat_s6v5h_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = _s6v5e::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5j_entry() //  [R1]
         { info_tbl: [(c6x8F,
                       label: sat_s6v5j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x8F: // global
           _s6v5j::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6x8G; else goto c6x8H;
       c6x8H: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6x8J; else goto c6x8I;
       c6x8J: // global
           HpAlloc = 32;
           goto c6x8G;
       c6x8G: // global
           R1 = _s6v5j::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x8I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5j::P64;
           _s6v57::P64 = P64[_s6v5j::P64 + 16];
           _s6v5e::P64 = P64[_s6v5j::P64 + 24];
           I64[Hp - 24] = sat_s6v5i_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = _s6v5e::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5k_entry() //  [R1, R2]
         { info_tbl: [(c6x8L,
                       label: sat_s6v5k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x8L: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6x8P; else goto c6x8O;
       c6x8P: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6x8O: // global
           _s6v57::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6v5j_info;
           P64[Hp - 32] = _s6v57::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6x8T,
                       label: Data.Semigroup.Internal.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x8T: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6x8X; else goto c6x8W;
       c6x8X: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6x8W: // global
           I64[Hp - 40] = f1_s6v57_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6x7k::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6x8R; else goto c6x8S;
       c6x8R: // global
           I64[Hp - 8] = sat_s6v5d_info;
           P64[Hp] = _c6x7k::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6x8S: // global
           I64[Hp - 8] = sat_s6v5k_info;
           P64[Hp] = _c6x7k::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.762020689 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6x95,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x95: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6x96; else goto c6x97;
       c6x96: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6x97: // global
           I64[Sp - 24] = block_c6x92_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6x9b; else goto c6x93;
       u6x9b: // global
           call _c6x92(R1) args: 0, res: 0, upd: 0;
       c6x93: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6x92() //  [R1]
         { info_tbl: [(c6x92,
                       label: block_c6x92_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x92: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.763264083 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll4_closure" {
     Data.Semigroup.Internal.$fReadAll4_closure:
         const Data.Semigroup.Internal.$fReadAll4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll4_entry() //  [R1]
         { info_tbl: [(c6x9i,
                       label: Data.Semigroup.Internal.$fReadAll4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x9i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6x9j; else goto c6x9k;
       c6x9j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x9k: // global
           (_c6x9f::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6x9f::I64 == 0) goto c6x9h; else goto c6x9g;
       c6x9h: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6x9g: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6x9f::I64;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.764665984 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshow_info;
         const 0;
 },
 sat_s6v5s_entry() //  [R1]
         { info_tbl: [(c6x9x,
                       label: sat_s6v5s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x9x: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6x9y; else goto c6x9z;
       c6x9y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x9z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6v5t_entry() //  [R1]
         { info_tbl: [(c6x9A,
                       label: sat_s6v5t_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x9A: // global
           _s6v5t::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6x9B; else goto c6x9C;
       c6x9C: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6x9E; else goto c6x9D;
       c6x9E: // global
           HpAlloc = 32;
           goto c6x9B;
       c6x9B: // global
           R1 = _s6v5t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6x9D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5t::P64;
           _s6v5q::P64 = P64[_s6v5t::P64 + 16];
           _s6v5r::P64 = P64[_s6v5t::P64 + 24];
           I64[Hp - 24] = sat_s6v5s_info;
           P64[Hp - 8] = _s6v5q::P64;
           P64[Hp] = _s6v5r::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6x9F,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x9F: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6x9J; else goto c6x9I;
       c6x9J: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6x9I: // global
           I64[Hp - 24] = sat_s6v5t_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.766656514 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshowList_info;
 },
 sat_s6v5y_entry() //  [R1, R2]
         { info_tbl: [(c6x9T,
                       label: sat_s6v5y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x9T: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c6x9W,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6x9W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xa0; else goto c6x9Z;
       c6xa0: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6x9Z: // global
           I64[Hp - 8] = sat_s6v5y_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.768217037 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_closure" {
     Data.Semigroup.Internal.$fShowAlt_closure:
         const Data.Semigroup.Internal.$fShowAlt_info;
         const 0;
 },
 sat_s6v5C_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xaa,
                       label: sat_s6v5C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xaa: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowAlt_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5B_entry() //  [R1, R2]
         { info_tbl: [(c6xai,
                       label: sat_s6v5B_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xai: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowAlt_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5A_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xaq,
                       label: sat_s6v5A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xaq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_entry() //  [R2]
         { info_tbl: [(c6xau,
                       label: Data.Semigroup.Internal.$fShowAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xau: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6xay; else goto c6xax;
       c6xay: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xax: // global
           I64[Hp - 72] = sat_s6v5C_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v5B_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v5A_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.769675359 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAlt5_bytes" {
     Data.Semigroup.Internal.$fReadAlt5_bytes:
         I8[] [65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.770432956 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt4_closure" {
     Data.Semigroup.Internal.$fReadAlt4_closure:
         const Data.Semigroup.Internal.$fReadAlt4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAlt4_entry() //  [R1]
         { info_tbl: [(c6xaF,
                       label: Data.Semigroup.Internal.$fReadAlt4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xaF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xaG; else goto c6xaH;
       c6xaG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xaH: // global
           (_c6xaC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xaC::I64 == 0) goto c6xaE; else goto c6xaD;
       c6xaE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xaD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xaC::I64;
           R2 = Data.Semigroup.Internal.$fReadAlt5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.771351907 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAlt_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAlt4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.771936334 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll11_bytes" {
     Data.Semigroup.Internal.$fReadAll11_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.772683762 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll10_closure" {
     Data.Semigroup.Internal.$fReadAll10_closure:
         const Data.Semigroup.Internal.$fReadAll10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll10_entry() //  [R1]
         { info_tbl: [(c6xaO,
                       label: Data.Semigroup.Internal.$fReadAll10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xaO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xaP; else goto c6xaQ;
       c6xaP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xaQ: // global
           (_c6xaL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xaL::I64 == 0) goto c6xaN; else goto c6xaM;
       c6xaN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xaM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xaL::I64;
           R2 = Data.Semigroup.Internal.$fReadAll11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.773683167 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAll_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Semigroup.Internal.$fReadAll10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.774296944 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAlt3_bytes" {
     Data.Semigroup.Internal.$fReadAlt3_bytes:
         I8[] [103,101,116,65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.775021094 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt2_closure" {
     Data.Semigroup.Internal.$fReadAlt2_closure:
         const Data.Semigroup.Internal.$fReadAlt2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAlt2_entry() //  [R1]
         { info_tbl: [(c6xaX,
                       label: Data.Semigroup.Internal.$fReadAlt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xaX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xaY; else goto c6xaZ;
       c6xaY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xaZ: // global
           (_c6xaU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xaU::I64 == 0) goto c6xaW; else goto c6xaV;
       c6xaW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xaV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xaU::I64;
           R2 = Data.Semigroup.Internal.$fReadAlt3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.775960115 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll6_closure" {
     Data.Semigroup.Internal.$fReadAll6_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.776556149 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll3_closure" {
     Data.Semigroup.Internal.$fReadAll3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.778932542 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt1_closure" {
     Data.Semigroup.Internal.$fReadAlt1_closure:
         const Data.Semigroup.Internal.$fReadAlt1_info;
         const 0;
 },
 lvl12_s6v5E_entry() //  [R1]
         { info_tbl: [(c6xb8,
                       label: lvl12_s6v5E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xb8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6xb9; else goto c6xba;
       c6xb9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xba: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6v5F_entry() //  [R1]
         { info_tbl: [(c6xbg,
                       label: ds_s6v5F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xbg: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5Q_entry() //  [R1]
         { info_tbl: [(c6xbR,
                       label: sat_s6v5Q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xbR: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5T_entry() //  [R1, R2]
         { info_tbl: [(c6xbX,
                       label: sat_s6v5T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xbX: // global
           _s6v5O::P64 = R2;
           _s6v5T::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xbY; else goto c6xbZ;
       c6xbZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xc1; else goto c6xc0;
       c6xc1: // global
           HpAlloc = 24;
           goto c6xbY;
       c6xbY: // global
           R2 = _s6v5O::P64;
           R1 = _s6v5T::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xc0: // global
           _s6v5I::P64 = P64[_s6v5T::P64 + 7];
           I64[Hp - 16] = sat_s6v5Q_info;
           P64[Hp - 8] = _s6v5I::P64;
           P64[Hp] = _s6v5O::P64;
           I64[Sp - 8] = block_c6xbU_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xbU() //  [R1]
         { info_tbl: [(c6xbU,
                       label: block_c6xbU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xbU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xc4; else goto c6xc3;
       c6xc4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xc3: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5U_entry() //  [R1, R2]
         { info_tbl: [(c6xc5,
                       label: sat_s6v5U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xc5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xc9; else goto c6xc8;
       c6xc9: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xc8: // global
           _s6v5F::P64 = P64[R1 + 7];
           _s6v5I::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6v5T_info;
           P64[Hp] = _s6v5I::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6v5F::P64;
           R2 = Data.Semigroup.Internal.$fReadAlt2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5X_entry() //  [R1, R2]
         { info_tbl: [(c6xcd,
                       label: sat_s6v5X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xcd: // global
           _s6v5M::P64 = R2;
           _s6v5X::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xce; else goto c6xcf;
       c6xcf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xch; else goto c6xcg;
       c6xch: // global
           HpAlloc = 24;
           goto c6xce;
       c6xce: // global
           R2 = _s6v5M::P64;
           R1 = _s6v5X::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xcg: // global
           _s6v5F::P64 = P64[_s6v5X::P64 + 7];
           _s6v5I::P64 = P64[_s6v5X::P64 + 15];
           I64[Hp - 16] = sat_s6v5U_info;
           P64[Hp - 8] = _s6v5F::P64;
           P64[Hp] = _s6v5I::P64;
           I64[Sp - 8] = block_c6xca_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xca() //  [R1]
         { info_tbl: [(c6xca,
                       label: block_c6xca_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xca: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xck; else goto c6xcj;
       c6xck: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xcj: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v60_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xcl,
                       label: sat_s6v60_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xcl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xcm; else goto c6xcn;
       c6xcm: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xcn: // global
           I64[Sp - 24] = block_c6xbo_info;
           _s6v5F::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6v5F::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xcA; else goto c6xbp;
       u6xcA: // global
           call _c6xbo(R1) args: 0, res: 0, upd: 0;
       c6xbp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xbo() //  [R1]
         { info_tbl: [(c6xbo,
                       label: block_c6xbo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xbo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xcq; else goto c6xcp;
       c6xcq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xcp: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6xcs; else goto c6xcw;
       c6xcs: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6xcw: // global
           I64[Hp - 16] = sat_s6v5X_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6xct_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAlt_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xct() //  [R1]
         { info_tbl: [(c6xct,
                       label: block_c6xct_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xct: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xcz; else goto c6xcy;
       c6xcz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xcy: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt1_entry() //  [R2]
         { info_tbl: [(c6xcB,
                       label: Data.Semigroup.Internal.$fReadAlt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xcB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6xcF; else goto c6xcE;
       c6xcF: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xcE: // global
           I64[Hp - 48] = lvl12_s6v5E_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6v5F_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6v60_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.783575205 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadsPrec_info;
         const 0;
 },
 ds_s6v62_entry() //  [R1]
         { info_tbl: [(c6xcO,
                       label: ds_s6v62_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xcO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xcP; else goto c6xcQ;
       c6xcP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xcQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v64_entry() //  [R1]
         { info_tbl: [(c6xd0,
                       label: sat_s6v64_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xd0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xd1; else goto c6xd2;
       c6xd1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xd2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v65_entry() //  [R1, R2]
         { info_tbl: [(c6xd3,
                       label: sat_s6v65_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xd3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xd7; else goto c6xd6;
       c6xd7: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xd6: // global
           _s6v62::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v64_info;
           P64[Hp - 8] = _s6v62::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6xd8,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xd8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6xdc; else goto c6xdb;
       c6xdc: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xdb: // global
           I64[Hp - 32] = ds_s6v62_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6v65_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.786701722 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadListPrec_info;
         const 0;
 },
 sat_s6v67_entry() //  [R1]
         { info_tbl: [(c6xdl,
                       label: sat_s6v67_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xdl: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6xdo,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xdo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xds; else goto c6xdr;
       c6xds: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xdr: // global
           I64[Hp - 16] = sat_s6v67_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.788133826 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadList_info;
         const 0;
 },
 sat_s6v69_entry() //  [R1]
         { info_tbl: [(c6xdF,
                       label: sat_s6v69_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xdF: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v6a_entry() //  [R1]
         { info_tbl: [(c6xdI,
                       label: sat_s6v6a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xdI: // global
           _s6v6a::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6xdJ; else goto c6xdK;
       c6xdK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xdM; else goto c6xdL;
       c6xdM: // global
           HpAlloc = 24;
           goto c6xdJ;
       c6xdJ: // global
           R1 = _s6v6a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xdL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6a::P64;
           _s6v68::P64 = P64[_s6v6a::P64 + 16];
           I64[Hp - 16] = sat_s6v69_info;
           P64[Hp] = _s6v68::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadList_entry() //  [R2]
         { info_tbl: [(c6xdN,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xdN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xdR; else goto c6xdQ;
       c6xdR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xdQ: // global
           I64[Hp - 16] = sat_s6v6a_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.790145369 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_closure" {
     Data.Semigroup.Internal.$fReadAlt_closure:
         const Data.Semigroup.Internal.$fReadAlt_info;
         const 0;
 },
 sat_s6v6f_entry() //  [R1]
         { info_tbl: [(c6xe0,
                       label: sat_s6v6f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xe0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xe1; else goto c6xe2;
       c6xe1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xe2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6e_entry() //  [R1]
         { info_tbl: [(c6xe7,
                       label: sat_s6v6e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xe7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xe8; else goto c6xe9;
       c6xe8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xe9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6d_entry() //  [R1]
         { info_tbl: [(c6xee,
                       label: sat_s6v6d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xee: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xef; else goto c6xeg;
       c6xef: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xeg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6c_entry() //  [R1]
         { info_tbl: [(c6xel,
                       label: sat_s6v6c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xel: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xem; else goto c6xen;
       c6xem: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xen: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_entry() //  [R2]
         { info_tbl: [(c6xep,
                       label: Data.Semigroup.Internal.$fReadAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xep: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6xet; else goto c6xes;
       c6xet: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xes: // global
           I64[Hp - 128] = sat_s6v6f_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v6e_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v6d_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v6c_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.792078794 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt1_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt1_closure:
         const Data.Semigroup.Internal.$fGeneric1Alt1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Alt1_entry() //  [R2]
         { info_tbl: [(c6xey,
                       label: Data.Semigroup.Internal.$fGeneric1Alt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xey: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.792931969 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt2_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt2_closure:
         const Data.Semigroup.Internal.$fGeneric1Alt2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Alt2_entry() //  [R2]
         { info_tbl: [(c6xeF,
                       label: Data.Semigroup.Internal.$fGeneric1Alt2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xeF: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.793722294 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Alt2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Alt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.794474788 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt1_closure" {
     Data.Semigroup.Internal.$fGenericAlt1_closure:
         const Data.Semigroup.Internal.$fGenericAlt1_info;
 },
 Data.Semigroup.Internal.$fGenericAlt1_entry() //  [R2]
         { info_tbl: [(c6xeM,
                       label: Data.Semigroup.Internal.$fGenericAlt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xeM: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.79533111 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt2_closure" {
     Data.Semigroup.Internal.$fGenericAlt2_closure:
         const Data.Semigroup.Internal.$fGenericAlt2_info;
 },
 Data.Semigroup.Internal.$fGenericAlt2_entry() //  [R2]
         { info_tbl: [(c6xeT,
                       label: Data.Semigroup.Internal.$fGenericAlt2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xeT: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.796044144 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt_closure" {
     Data.Semigroup.Internal.$fGenericAlt_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAlt2_closure+1;
         const Data.Semigroup.Internal.$fGenericAlt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.797581184 UTC

[section ""data" . Data.Semigroup.Internal.$fNumProduct_closure" {
     Data.Semigroup.Internal.$fNumProduct_closure:
         const Data.Semigroup.Internal.$fNumProduct_info;
 },
 sat_s6v6r_entry() //  [R1]
         { info_tbl: [(c6xf4,
                       label: sat_s6v6r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xf4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xf5; else goto c6xf6;
       c6xf5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xf6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6q_entry() //  [R1]
         { info_tbl: [(c6xfb,
                       label: sat_s6v6q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xfb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xfc; else goto c6xfd;
       c6xfc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xfd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6p_entry() //  [R1]
         { info_tbl: [(c6xfi,
                       label: sat_s6v6p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xfi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xfj; else goto c6xfk;
       c6xfj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xfk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6o_entry() //  [R1]
         { info_tbl: [(c6xfp,
                       label: sat_s6v6o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xfp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xfq; else goto c6xfr;
       c6xfq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xfr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6n_entry() //  [R1]
         { info_tbl: [(c6xfw,
                       label: sat_s6v6n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xfw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xfx; else goto c6xfy;
       c6xfx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xfy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6m_entry() //  [R1]
         { info_tbl: [(c6xfD,
                       label: sat_s6v6m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xfD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xfE; else goto c6xfF;
       c6xfE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xfF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6l_entry() //  [R1]
         { info_tbl: [(c6xfK,
                       label: sat_s6v6l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xfK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xfL; else goto c6xfM;
       c6xfL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xfM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumProduct_entry() //  [R2]
         { info_tbl: [(c6xfO,
                       label: Data.Semigroup.Internal.$fNumProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xfO: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6xfS; else goto c6xfR;
       c6xfS: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xfR: // global
           I64[Hp - 224] = sat_s6v6r_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6v6q_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6v6p_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6v6o_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6v6n_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v6m_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v6l_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.800122933 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product1_closure" {
     Data.Semigroup.Internal.$fGeneric1Product1_closure:
         const Data.Semigroup.Internal.$fGeneric1Product1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Product1_entry() //  [R2]
         { info_tbl: [(c6xfX,
                       label: Data.Semigroup.Internal.$fGeneric1Product1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xfX: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.800957123 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product2_closure" {
     Data.Semigroup.Internal.$fGeneric1Product2_closure:
         const Data.Semigroup.Internal.$fGeneric1Product2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Product2_entry() //  [R2]
         { info_tbl: [(c6xg4,
                       label: Data.Semigroup.Internal.$fGeneric1Product2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xg4: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.801994729 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product_closure" {
     Data.Semigroup.Internal.$fGeneric1Product_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Product2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Product1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.80277942 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct1_closure" {
     Data.Semigroup.Internal.$fGenericProduct1_closure:
         const Data.Semigroup.Internal.$fGenericProduct1_info;
 },
 Data.Semigroup.Internal.$fGenericProduct1_entry() //  [R2]
         { info_tbl: [(c6xgb,
                       label: Data.Semigroup.Internal.$fGenericProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xgb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.803585812 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct2_closure" {
     Data.Semigroup.Internal.$fGenericProduct2_closure:
         const Data.Semigroup.Internal.$fGenericProduct2_info;
 },
 Data.Semigroup.Internal.$fGenericProduct2_entry() //  [R2]
         { info_tbl: [(c6xgi,
                       label: Data.Semigroup.Internal.$fGenericProduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xgi: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.804295645 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct_closure" {
     Data.Semigroup.Internal.$fGenericProduct_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericProduct2_closure+1;
         const Data.Semigroup.Internal.$fGenericProduct1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.805367082 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedProduct_closure" {
     Data.Semigroup.Internal.$fBoundedProduct_closure:
         const Data.Semigroup.Internal.$fBoundedProduct_info;
 },
 sat_s6v6y_entry() //  [R1]
         { info_tbl: [(c6xgt,
                       label: sat_s6v6y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xgt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xgu; else goto c6xgv;
       c6xgu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xgv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6x_entry() //  [R1]
         { info_tbl: [(c6xgA,
                       label: sat_s6v6x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xgA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xgB; else goto c6xgC;
       c6xgB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xgC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedProduct_entry() //  [R2]
         { info_tbl: [(c6xgE,
                       label: Data.Semigroup.Internal.$fBoundedProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xgE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6xgI; else goto c6xgH;
       c6xgI: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xgH: // global
           I64[Hp - 64] = sat_s6v6y_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v6x_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.806681747 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowProduct2_bytes" {
     Data.Semigroup.Internal.$fShowProduct2_bytes:
         I8[] [80,114,111,100,117,99,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.807236312 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowProduct1_bytes" {
     Data.Semigroup.Internal.$fShowProduct1_bytes:
         I8[] [103,101,116,80,114,111,100,117,99,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.809607112 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec4_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec4_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec4_info;
 },
 f_s6v6C_entry() //  [R1]
         { info_tbl: [(c6xgR,
                       label: f_s6v6C_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xgR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6xgS; else goto c6xgT;
       c6xgS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xgT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6v6F_entry() //  [R1]
         { info_tbl: [(c6xhe,
                       label: sat_s6v6F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xhe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xhf; else goto c6xhg;
       c6xhf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xhg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6G_entry() //  [R1]
         { info_tbl: [(c6xhh,
                       label: sat_s6v6G_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xhh: // global
           _s6v6G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xhi; else goto c6xhj;
       c6xhj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xhl; else goto c6xhk;
       c6xhl: // global
           HpAlloc = 24;
           goto c6xhi;
       c6xhi: // global
           R1 = _s6v6G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xhk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6G::P64;
           _s6v6C::P64 = P64[_s6v6G::P64 + 16];
           _s6v6E::P64 = P64[_s6v6G::P64 + 24];
           I64[Hp - 16] = sat_s6v6F_info;
           P64[Hp] = _s6v6E::P64;
           R2 = Hp - 16;
           R1 = _s6v6C::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6H_entry() //  [R1]
         { info_tbl: [(c6xhm,
                       label: sat_s6v6H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xhm: // global
           _s6v6H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xhn; else goto c6xho;
       c6xho: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xhq; else goto c6xhp;
       c6xhq: // global
           HpAlloc = 32;
           goto c6xhn;
       c6xhn: // global
           R1 = _s6v6H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xhp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6H::P64;
           _s6v6C::P64 = P64[_s6v6H::P64 + 16];
           _s6v6E::P64 = P64[_s6v6H::P64 + 24];
           I64[Hp - 24] = sat_s6v6G_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = _s6v6E::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6I_entry() //  [R1, R2]
         { info_tbl: [(c6xhr,
                       label: sat_s6v6I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xhr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xhv; else goto c6xhu;
       c6xhv: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xhu: // global
           _s6v6C::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v6H_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v6L_entry() //  [R1]
         { info_tbl: [(c6xhT,
                       label: sat_s6v6L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xhT: // global
           _s6v6L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xhU; else goto c6xhV;
       c6xhV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xhX; else goto c6xhW;
       c6xhX: // global
           HpAlloc = 24;
           goto c6xhU;
       c6xhU: // global
           R1 = _s6v6L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xhW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6L::P64;
           _s6v6J::P64 = P64[_s6v6L::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v6J::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6M_entry() //  [R1]
         { info_tbl: [(c6xhY,
                       label: sat_s6v6M_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xhY: // global
           _s6v6M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xhZ; else goto c6xi0;
       c6xi0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xi2; else goto c6xi1;
       c6xi2: // global
           HpAlloc = 24;
           goto c6xhZ;
       c6xhZ: // global
           R1 = _s6v6M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xi1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6M::P64;
           _s6v6C::P64 = P64[_s6v6M::P64 + 16];
           _s6v6J::P64 = P64[_s6v6M::P64 + 24];
           I64[Hp - 16] = sat_s6v6L_info;
           P64[Hp] = _s6v6J::P64;
           R2 = Hp - 16;
           R1 = _s6v6C::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6N_entry() //  [R1]
         { info_tbl: [(c6xi3,
                       label: sat_s6v6N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xi3: // global
           _s6v6N::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xi4; else goto c6xi5;
       c6xi5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xi7; else goto c6xi6;
       c6xi7: // global
           HpAlloc = 32;
           goto c6xi4;
       c6xi4: // global
           R1 = _s6v6N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xi6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6N::P64;
           _s6v6C::P64 = P64[_s6v6N::P64 + 16];
           _s6v6J::P64 = P64[_s6v6N::P64 + 24];
           I64[Hp - 24] = sat_s6v6M_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = _s6v6J::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6O_entry() //  [R1]
         { info_tbl: [(c6xi8,
                       label: sat_s6v6O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xi8: // global
           _s6v6O::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xi9; else goto c6xia;
       c6xia: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xic; else goto c6xib;
       c6xic: // global
           HpAlloc = 32;
           goto c6xi9;
       c6xi9: // global
           R1 = _s6v6O::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xib: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6O::P64;
           _s6v6C::P64 = P64[_s6v6O::P64 + 16];
           _s6v6J::P64 = P64[_s6v6O::P64 + 24];
           I64[Hp - 24] = sat_s6v6N_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = _s6v6J::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6P_entry() //  [R1, R2]
         { info_tbl: [(c6xie,
                       label: sat_s6v6P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xie: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6xii; else goto c6xih;
       c6xii: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xih: // global
           _s6v6C::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6v6O_info;
           P64[Hp - 32] = _s6v6C::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec4_entry() //  [R2, R3, R4]
         { info_tbl: [(c6xim,
                       label: Data.Semigroup.Internal.$w$cshowsPrec4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xim: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6xiq; else goto c6xip;
       c6xiq: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xip: // global
           I64[Hp - 40] = f_s6v6C_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6xgN::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6xik; else goto c6xil;
       c6xik: // global
           I64[Hp - 8] = sat_s6v6I_info;
           P64[Hp] = _c6xgN::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6xil: // global
           I64[Hp - 8] = sat_s6v6P_info;
           P64[Hp] = _c6xgN::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.815431284 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c6xiy,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xiy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xiz; else goto c6xiA;
       c6xiz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xiA: // global
           I64[Sp - 24] = block_c6xiv_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xiE; else goto c6xiw;
       u6xiE: // global
           call _c6xiv(R1) args: 0, res: 0, upd: 0;
       c6xiw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xiv() //  [R1]
         { info_tbl: [(c6xiv,
                       label: block_c6xiv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xiv: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.816975827 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshow_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshow_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshow_info;
         const 0;
 },
 sat_s6v6X_entry() //  [R1]
         { info_tbl: [(c6xiR,
                       label: sat_s6v6X_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xiR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6xiS; else goto c6xiT;
       c6xiS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xiT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6v6Y_entry() //  [R1]
         { info_tbl: [(c6xiU,
                       label: sat_s6v6Y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xiU: // global
           _s6v6Y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xiV; else goto c6xiW;
       c6xiW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xiY; else goto c6xiX;
       c6xiY: // global
           HpAlloc = 32;
           goto c6xiV;
       c6xiV: // global
           R1 = _s6v6Y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xiX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6Y::P64;
           _s6v6V::P64 = P64[_s6v6Y::P64 + 16];
           _s6v6W::P64 = P64[_s6v6Y::P64 + 24];
           I64[Hp - 24] = sat_s6v6X_info;
           P64[Hp - 8] = _s6v6V::P64;
           P64[Hp] = _s6v6W::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6xiZ,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xiZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xj3; else goto c6xj2;
       c6xj3: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xj2: // global
           I64[Hp - 24] = sat_s6v6Y_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.818859629 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshowList_info;
 },
 sat_s6v73_entry() //  [R1, R2]
         { info_tbl: [(c6xjd,
                       label: sat_s6v73_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xjd: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_$cshowList_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c6xjg,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xjg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xjk; else goto c6xjj;
       c6xjk: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xjj: // global
           I64[Hp - 8] = sat_s6v73_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.820456834 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_closure" {
     Data.Semigroup.Internal.$fShowProduct_closure:
         const Data.Semigroup.Internal.$fShowProduct_info;
         const 0;
 },
 sat_s6v77_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xju,
                       label: sat_s6v77_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xju: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowProduct_$cshowList_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v76_entry() //  [R1, R2]
         { info_tbl: [(c6xjC,
                       label: sat_s6v76_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xjC: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowProduct_$cshow_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v75_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xjK,
                       label: sat_s6v75_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xjK: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_entry() //  [R2]
         { info_tbl: [(c6xjO,
                       label: Data.Semigroup.Internal.$fShowProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xjO: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6xjS; else goto c6xjR;
       c6xjS: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xjR: // global
           I64[Hp - 72] = sat_s6v77_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v76_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v75_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.821926147 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadProduct5_bytes" {
     Data.Semigroup.Internal.$fReadProduct5_bytes:
         I8[] [80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.822662148 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct4_closure" {
     Data.Semigroup.Internal.$fReadProduct4_closure:
         const Data.Semigroup.Internal.$fReadProduct4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadProduct4_entry() //  [R1]
         { info_tbl: [(c6xjZ,
                       label: Data.Semigroup.Internal.$fReadProduct4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xjZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xk0; else goto c6xk1;
       c6xk0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xk1: // global
           (_c6xjW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xjW::I64 == 0) goto c6xjY; else goto c6xjX;
       c6xjY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xjX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xjW::I64;
           R2 = Data.Semigroup.Internal.$fReadProduct5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.823591528 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_lexeme_closure" {
     Data.Semigroup.Internal.$fReadProduct_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadProduct4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.824165538 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadProduct3_bytes" {
     Data.Semigroup.Internal.$fReadProduct3_bytes:
         I8[] [103,101,116,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.824945704 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct2_closure" {
     Data.Semigroup.Internal.$fReadProduct2_closure:
         const Data.Semigroup.Internal.$fReadProduct2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadProduct2_entry() //  [R1]
         { info_tbl: [(c6xk8,
                       label: Data.Semigroup.Internal.$fReadProduct2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xk8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xk9; else goto c6xka;
       c6xk9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xka: // global
           (_c6xk5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xk5::I64 == 0) goto c6xk7; else goto c6xk6;
       c6xk7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xk6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xk5::I64;
           R2 = Data.Semigroup.Internal.$fReadProduct3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.827768927 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct1_closure" {
     Data.Semigroup.Internal.$fReadProduct1_closure:
         const Data.Semigroup.Internal.$fReadProduct1_info;
         const 0;
 },
 lvl12_s6v79_entry() //  [R1]
         { info_tbl: [(c6xkj,
                       label: lvl12_s6v79_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xkj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6xkk; else goto c6xkl;
       c6xkk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xkl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6v7a_entry() //  [R1]
         { info_tbl: [(c6xkr,
                       label: ds_s6v7a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xkr: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7l_entry() //  [R1]
         { info_tbl: [(c6xl2,
                       label: sat_s6v7l_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xl2: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7o_entry() //  [R1, R2]
         { info_tbl: [(c6xl8,
                       label: sat_s6v7o_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xl8: // global
           _s6v7j::P64 = R2;
           _s6v7o::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xl9; else goto c6xla;
       c6xla: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xlc; else goto c6xlb;
       c6xlc: // global
           HpAlloc = 24;
           goto c6xl9;
       c6xl9: // global
           R2 = _s6v7j::P64;
           R1 = _s6v7o::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xlb: // global
           _s6v7d::P64 = P64[_s6v7o::P64 + 7];
           I64[Hp - 16] = sat_s6v7l_info;
           P64[Hp - 8] = _s6v7d::P64;
           P64[Hp] = _s6v7j::P64;
           I64[Sp - 8] = block_c6xl5_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xl5() //  [R1]
         { info_tbl: [(c6xl5,
                       label: block_c6xl5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xl5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xlf; else goto c6xle;
       c6xlf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xle: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7p_entry() //  [R1, R2]
         { info_tbl: [(c6xlg,
                       label: sat_s6v7p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xlg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xlk; else goto c6xlj;
       c6xlk: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xlj: // global
           _s6v7a::P64 = P64[R1 + 7];
           _s6v7d::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6v7o_info;
           P64[Hp] = _s6v7d::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6v7a::P64;
           R2 = Data.Semigroup.Internal.$fReadProduct2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7s_entry() //  [R1, R2]
         { info_tbl: [(c6xlo,
                       label: sat_s6v7s_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xlo: // global
           _s6v7h::P64 = R2;
           _s6v7s::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xlp; else goto c6xlq;
       c6xlq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xls; else goto c6xlr;
       c6xls: // global
           HpAlloc = 24;
           goto c6xlp;
       c6xlp: // global
           R2 = _s6v7h::P64;
           R1 = _s6v7s::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xlr: // global
           _s6v7a::P64 = P64[_s6v7s::P64 + 7];
           _s6v7d::P64 = P64[_s6v7s::P64 + 15];
           I64[Hp - 16] = sat_s6v7p_info;
           P64[Hp - 8] = _s6v7a::P64;
           P64[Hp] = _s6v7d::P64;
           I64[Sp - 8] = block_c6xll_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xll() //  [R1]
         { info_tbl: [(c6xll,
                       label: block_c6xll_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xll: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xlv; else goto c6xlu;
       c6xlv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xlu: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7v_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xlw,
                       label: sat_s6v7v_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xlw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xlx; else goto c6xly;
       c6xlx: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xly: // global
           I64[Sp - 24] = block_c6xkz_info;
           _s6v7a::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6v7a::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xlL; else goto c6xkA;
       u6xlL: // global
           call _c6xkz(R1) args: 0, res: 0, upd: 0;
       c6xkA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xkz() //  [R1]
         { info_tbl: [(c6xkz,
                       label: block_c6xkz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xkz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xlB; else goto c6xlA;
       c6xlB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xlA: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6xlD; else goto c6xlH;
       c6xlD: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6xlH: // global
           I64[Hp - 16] = sat_s6v7s_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6xlE_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadProduct_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xlE() //  [R1]
         { info_tbl: [(c6xlE,
                       label: block_c6xlE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xlE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xlK; else goto c6xlJ;
       c6xlK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xlJ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct1_entry() //  [R2]
         { info_tbl: [(c6xlM,
                       label: Data.Semigroup.Internal.$fReadProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xlM: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6xlQ; else goto c6xlP;
       c6xlQ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xlP: // global
           I64[Hp - 48] = lvl12_s6v79_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6v7a_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6v7v_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.832251508 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadsPrec_info;
         const 0;
 },
 ds_s6v7x_entry() //  [R1]
         { info_tbl: [(c6xlZ,
                       label: ds_s6v7x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xlZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xm0; else goto c6xm1;
       c6xm0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xm1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7z_entry() //  [R1]
         { info_tbl: [(c6xmb,
                       label: sat_s6v7z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xmb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xmc; else goto c6xmd;
       c6xmc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xmd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7A_entry() //  [R1, R2]
         { info_tbl: [(c6xme,
                       label: sat_s6v7A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xme: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xmi; else goto c6xmh;
       c6xmi: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xmh: // global
           _s6v7x::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v7z_info;
           P64[Hp - 8] = _s6v7x::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6xmj,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xmj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6xmn; else goto c6xmm;
       c6xmn: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xmm: // global
           I64[Hp - 32] = ds_s6v7x_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6v7A_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.834189955 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadListPrec_info;
         const 0;
 },
 sat_s6v7C_entry() //  [R1]
         { info_tbl: [(c6xmw,
                       label: sat_s6v7C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xmw: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6xmz,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xmz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xmD; else goto c6xmC;
       c6xmD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xmC: // global
           I64[Hp - 16] = sat_s6v7C_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.835599066 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadList_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadList_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadList_info;
         const 0;
 },
 sat_s6v7E_entry() //  [R1]
         { info_tbl: [(c6xmQ,
                       label: sat_s6v7E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xmQ: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7F_entry() //  [R1]
         { info_tbl: [(c6xmT,
                       label: sat_s6v7F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xmT: // global
           _s6v7F::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6xmU; else goto c6xmV;
       c6xmV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xmX; else goto c6xmW;
       c6xmX: // global
           HpAlloc = 24;
           goto c6xmU;
       c6xmU: // global
           R1 = _s6v7F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xmW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v7F::P64;
           _s6v7D::P64 = P64[_s6v7F::P64 + 16];
           I64[Hp - 16] = sat_s6v7E_info;
           P64[Hp] = _s6v7D::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadList_entry() //  [R2]
         { info_tbl: [(c6xmY,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xmY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xn2; else goto c6xn1;
       c6xn2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xn1: // global
           I64[Hp - 16] = sat_s6v7F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.837888531 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_closure" {
     Data.Semigroup.Internal.$fReadProduct_closure:
         const Data.Semigroup.Internal.$fReadProduct_info;
         const 0;
 },
 sat_s6v7K_entry() //  [R1]
         { info_tbl: [(c6xnb,
                       label: sat_s6v7K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xnb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xnc; else goto c6xnd;
       c6xnc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xnd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7J_entry() //  [R1]
         { info_tbl: [(c6xni,
                       label: sat_s6v7J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xni: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xnj; else goto c6xnk;
       c6xnj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xnk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7I_entry() //  [R1]
         { info_tbl: [(c6xnp,
                       label: sat_s6v7I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xnp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xnq; else goto c6xnr;
       c6xnq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xnr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7H_entry() //  [R1]
         { info_tbl: [(c6xnw,
                       label: sat_s6v7H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xnw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xnx; else goto c6xny;
       c6xnx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xny: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_entry() //  [R2]
         { info_tbl: [(c6xnA,
                       label: Data.Semigroup.Internal.$fReadProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xnA: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6xnE; else goto c6xnD;
       c6xnE: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xnD: // global
           I64[Hp - 128] = sat_s6v7K_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v7J_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v7I_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v7H_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.841288334 UTC

[section ""data" . Data.Semigroup.Internal.$fEqProduct_closure" {
     Data.Semigroup.Internal.$fEqProduct_closure:
         const Data.Semigroup.Internal.$fEqProduct_info;
 },
 sat_s6v7N_entry() //  [R1]
         { info_tbl: [(c6xnN,
                       label: sat_s6v7N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xnN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xnO; else goto c6xnP;
       c6xnO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xnP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7M_entry() //  [R1]
         { info_tbl: [(c6xnU,
                       label: sat_s6v7M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xnU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xnV; else goto c6xnW;
       c6xnV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xnW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqProduct_entry() //  [R2]
         { info_tbl: [(c6xnY,
                       label: Data.Semigroup.Internal.$fEqProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xnY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6xo2; else goto c6xo1;
       c6xo2: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xo1: // global
           I64[Hp - 64] = sat_s6v7N_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v7M_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.842855249 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_info;
 },
 sat_s6v7P_entry() //  [R1]
         { info_tbl: [(c6xob,
                       label: sat_s6v7P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xob: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xoc; else goto c6xod;
       c6xoc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xod: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6xoe,
                       label: Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xoe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xoi; else goto c6xoh;
       c6xoi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xoh: // global
           I64[Hp - 16] = sat_s6v7P_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqProduct_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.844929391 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdProduct_closure" {
     Data.Semigroup.Internal.$fOrdProduct_closure:
         const Data.Semigroup.Internal.$fOrdProduct_info;
 },
 sat_s6v7Y_entry() //  [R1]
         { info_tbl: [(c6xor,
                       label: sat_s6v7Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xor: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xos; else goto c6xot;
       c6xos: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xot: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7X_entry() //  [R1]
         { info_tbl: [(c6xoy,
                       label: sat_s6v7X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xoy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xoz; else goto c6xoA;
       c6xoz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xoA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7W_entry() //  [R1]
         { info_tbl: [(c6xoF,
                       label: sat_s6v7W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xoF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xoG; else goto c6xoH;
       c6xoG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xoH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7V_entry() //  [R1]
         { info_tbl: [(c6xoM,
                       label: sat_s6v7V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xoM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xoN; else goto c6xoO;
       c6xoN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xoO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7U_entry() //  [R1]
         { info_tbl: [(c6xoT,
                       label: sat_s6v7U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xoT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xoU; else goto c6xoV;
       c6xoU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xoV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7T_entry() //  [R1]
         { info_tbl: [(c6xp0,
                       label: sat_s6v7T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xp0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xp1; else goto c6xp2;
       c6xp1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xp2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7S_entry() //  [R1]
         { info_tbl: [(c6xp7,
                       label: sat_s6v7S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xp7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xp8; else goto c6xp9;
       c6xp8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xp9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7R_entry() //  [R1]
         { info_tbl: [(c6xpe,
                       label: sat_s6v7R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xpe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xpf; else goto c6xpg;
       c6xpf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xpg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdProduct_entry() //  [R2]
         { info_tbl: [(c6xpi,
                       label: Data.Semigroup.Internal.$fOrdProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xpi: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6xpm; else goto c6xpl;
       c6xpm: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xpl: // global
           I64[Hp - 256] = sat_s6v7Y_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v7X_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v7W_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v7V_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v7U_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v7T_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v7S_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v7R_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.848642091 UTC

[section ""data" . Data.Semigroup.Internal.$fNumSum_closure" {
     Data.Semigroup.Internal.$fNumSum_closure:
         const Data.Semigroup.Internal.$fNumSum_info;
 },
 sat_s6v86_entry() //  [R1]
         { info_tbl: [(c6xpv,
                       label: sat_s6v86_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xpv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xpw; else goto c6xpx;
       c6xpw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xpx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v85_entry() //  [R1]
         { info_tbl: [(c6xpC,
                       label: sat_s6v85_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xpC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xpD; else goto c6xpE;
       c6xpD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xpE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v84_entry() //  [R1]
         { info_tbl: [(c6xpJ,
                       label: sat_s6v84_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xpJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xpK; else goto c6xpL;
       c6xpK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xpL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v83_entry() //  [R1]
         { info_tbl: [(c6xpQ,
                       label: sat_s6v83_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xpQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xpR; else goto c6xpS;
       c6xpR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xpS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v82_entry() //  [R1]
         { info_tbl: [(c6xpX,
                       label: sat_s6v82_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xpX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xpY; else goto c6xpZ;
       c6xpY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xpZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v81_entry() //  [R1]
         { info_tbl: [(c6xq4,
                       label: sat_s6v81_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xq4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xq5; else goto c6xq6;
       c6xq5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xq6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v80_entry() //  [R1]
         { info_tbl: [(c6xqb,
                       label: sat_s6v80_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xqb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xqc; else goto c6xqd;
       c6xqc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xqd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumSum_entry() //  [R2]
         { info_tbl: [(c6xqf,
                       label: Data.Semigroup.Internal.$fNumSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xqf: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6xqj; else goto c6xqi;
       c6xqj: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xqi: // global
           I64[Hp - 224] = sat_s6v86_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6v85_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6v84_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6v83_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6v82_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v81_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v80_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.851369658 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum1_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum1_closure:
         const Data.Semigroup.Internal.$fGeneric1Sum1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Sum1_entry() //  [R2]
         { info_tbl: [(c6xqo,
                       label: Data.Semigroup.Internal.$fGeneric1Sum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xqo: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.852203242 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum2_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum2_closure:
         const Data.Semigroup.Internal.$fGeneric1Sum2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Sum2_entry() //  [R2]
         { info_tbl: [(c6xqv,
                       label: Data.Semigroup.Internal.$fGeneric1Sum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xqv: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.852939364 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Sum2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Sum1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.853700808 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum1_closure" {
     Data.Semigroup.Internal.$fGenericSum1_closure:
         const Data.Semigroup.Internal.$fGenericSum1_info;
 },
 Data.Semigroup.Internal.$fGenericSum1_entry() //  [R2]
         { info_tbl: [(c6xqC,
                       label: Data.Semigroup.Internal.$fGenericSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xqC: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.854528799 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum2_closure" {
     Data.Semigroup.Internal.$fGenericSum2_closure:
         const Data.Semigroup.Internal.$fGenericSum2_info;
 },
 Data.Semigroup.Internal.$fGenericSum2_entry() //  [R2]
         { info_tbl: [(c6xqJ,
                       label: Data.Semigroup.Internal.$fGenericSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xqJ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.85525588 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum_closure" {
     Data.Semigroup.Internal.$fGenericSum_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericSum2_closure+1;
         const Data.Semigroup.Internal.$fGenericSum1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.856297585 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedSum_closure" {
     Data.Semigroup.Internal.$fBoundedSum_closure:
         const Data.Semigroup.Internal.$fBoundedSum_info;
 },
 sat_s6v8d_entry() //  [R1]
         { info_tbl: [(c6xqU,
                       label: sat_s6v8d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xqU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xqV; else goto c6xqW;
       c6xqV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xqW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8c_entry() //  [R1]
         { info_tbl: [(c6xr1,
                       label: sat_s6v8c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xr1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xr2; else goto c6xr3;
       c6xr2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xr3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedSum_entry() //  [R2]
         { info_tbl: [(c6xr5,
                       label: Data.Semigroup.Internal.$fBoundedSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xr5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6xr9; else goto c6xr8;
       c6xr9: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xr8: // global
           I64[Hp - 64] = sat_s6v8d_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v8c_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.85763837 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowSum2_bytes" {
     Data.Semigroup.Internal.$fShowSum2_bytes:
         I8[] [83,117,109,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.85818578 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowSum1_bytes" {
     Data.Semigroup.Internal.$fShowSum1_bytes:
         I8[] [103,101,116,83,117,109,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.860498254 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec5_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec5_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec5_info;
 },
 f_s6v8h_entry() //  [R1]
         { info_tbl: [(c6xri,
                       label: f_s6v8h_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xri: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6xrj; else goto c6xrk;
       c6xrj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xrk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6v8k_entry() //  [R1]
         { info_tbl: [(c6xrF,
                       label: sat_s6v8k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xrF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xrG; else goto c6xrH;
       c6xrG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xrH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8l_entry() //  [R1]
         { info_tbl: [(c6xrI,
                       label: sat_s6v8l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xrI: // global
           _s6v8l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xrJ; else goto c6xrK;
       c6xrK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xrM; else goto c6xrL;
       c6xrM: // global
           HpAlloc = 24;
           goto c6xrJ;
       c6xrJ: // global
           R1 = _s6v8l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xrL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8l::P64;
           _s6v8h::P64 = P64[_s6v8l::P64 + 16];
           _s6v8j::P64 = P64[_s6v8l::P64 + 24];
           I64[Hp - 16] = sat_s6v8k_info;
           P64[Hp] = _s6v8j::P64;
           R2 = Hp - 16;
           R1 = _s6v8h::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8m_entry() //  [R1]
         { info_tbl: [(c6xrN,
                       label: sat_s6v8m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xrN: // global
           _s6v8m::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xrO; else goto c6xrP;
       c6xrP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xrR; else goto c6xrQ;
       c6xrR: // global
           HpAlloc = 32;
           goto c6xrO;
       c6xrO: // global
           R1 = _s6v8m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xrQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8m::P64;
           _s6v8h::P64 = P64[_s6v8m::P64 + 16];
           _s6v8j::P64 = P64[_s6v8m::P64 + 24];
           I64[Hp - 24] = sat_s6v8l_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = _s6v8j::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8n_entry() //  [R1, R2]
         { info_tbl: [(c6xrS,
                       label: sat_s6v8n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xrS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xrW; else goto c6xrV;
       c6xrW: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xrV: // global
           _s6v8h::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v8m_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v8q_entry() //  [R1]
         { info_tbl: [(c6xsk,
                       label: sat_s6v8q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xsk: // global
           _s6v8q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xsl; else goto c6xsm;
       c6xsm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xso; else goto c6xsn;
       c6xso: // global
           HpAlloc = 24;
           goto c6xsl;
       c6xsl: // global
           R1 = _s6v8q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xsn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8q::P64;
           _s6v8o::P64 = P64[_s6v8q::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v8o::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8r_entry() //  [R1]
         { info_tbl: [(c6xsp,
                       label: sat_s6v8r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xsp: // global
           _s6v8r::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xsq; else goto c6xsr;
       c6xsr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xst; else goto c6xss;
       c6xst: // global
           HpAlloc = 24;
           goto c6xsq;
       c6xsq: // global
           R1 = _s6v8r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xss: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8r::P64;
           _s6v8h::P64 = P64[_s6v8r::P64 + 16];
           _s6v8o::P64 = P64[_s6v8r::P64 + 24];
           I64[Hp - 16] = sat_s6v8q_info;
           P64[Hp] = _s6v8o::P64;
           R2 = Hp - 16;
           R1 = _s6v8h::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8s_entry() //  [R1]
         { info_tbl: [(c6xsu,
                       label: sat_s6v8s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xsu: // global
           _s6v8s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xsv; else goto c6xsw;
       c6xsw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xsy; else goto c6xsx;
       c6xsy: // global
           HpAlloc = 32;
           goto c6xsv;
       c6xsv: // global
           R1 = _s6v8s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xsx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8s::P64;
           _s6v8h::P64 = P64[_s6v8s::P64 + 16];
           _s6v8o::P64 = P64[_s6v8s::P64 + 24];
           I64[Hp - 24] = sat_s6v8r_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = _s6v8o::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8t_entry() //  [R1]
         { info_tbl: [(c6xsz,
                       label: sat_s6v8t_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xsz: // global
           _s6v8t::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xsA; else goto c6xsB;
       c6xsB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xsD; else goto c6xsC;
       c6xsD: // global
           HpAlloc = 32;
           goto c6xsA;
       c6xsA: // global
           R1 = _s6v8t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xsC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8t::P64;
           _s6v8h::P64 = P64[_s6v8t::P64 + 16];
           _s6v8o::P64 = P64[_s6v8t::P64 + 24];
           I64[Hp - 24] = sat_s6v8s_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = _s6v8o::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8u_entry() //  [R1, R2]
         { info_tbl: [(c6xsF,
                       label: sat_s6v8u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xsF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6xsJ; else goto c6xsI;
       c6xsJ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xsI: // global
           _s6v8h::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6v8t_info;
           P64[Hp - 32] = _s6v8h::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec5_entry() //  [R2, R3, R4]
         { info_tbl: [(c6xsN,
                       label: Data.Semigroup.Internal.$w$cshowsPrec5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xsN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6xsR; else goto c6xsQ;
       c6xsR: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xsQ: // global
           I64[Hp - 40] = f_s6v8h_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6xre::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6xsL; else goto c6xsM;
       c6xsL: // global
           I64[Hp - 8] = sat_s6v8n_info;
           P64[Hp] = _c6xre::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6xsM: // global
           I64[Hp - 8] = sat_s6v8u_info;
           P64[Hp] = _c6xre::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.865214023 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowSum_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6xsZ,
                       label: Data.Semigroup.Internal.$fShowSum_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xsZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xt0; else goto c6xt1;
       c6xt0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xt1: // global
           I64[Sp - 24] = block_c6xsW_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xt5; else goto c6xsX;
       u6xt5: // global
           call _c6xsW(R1) args: 0, res: 0, upd: 0;
       c6xsX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xsW() //  [R1]
         { info_tbl: [(c6xsW,
                       label: block_c6xsW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xsW: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.866877583 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshow_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshow_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshow_info;
         const 0;
 },
 sat_s6v8C_entry() //  [R1]
         { info_tbl: [(c6xti,
                       label: sat_s6v8C_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xti: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6xtj; else goto c6xtk;
       c6xtj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xtk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6v8D_entry() //  [R1]
         { info_tbl: [(c6xtl,
                       label: sat_s6v8D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xtl: // global
           _s6v8D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xtm; else goto c6xtn;
       c6xtn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xtp; else goto c6xto;
       c6xtp: // global
           HpAlloc = 32;
           goto c6xtm;
       c6xtm: // global
           R1 = _s6v8D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xto: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8D::P64;
           _s6v8A::P64 = P64[_s6v8D::P64 + 16];
           _s6v8B::P64 = P64[_s6v8D::P64 + 24];
           I64[Hp - 24] = sat_s6v8C_info;
           P64[Hp - 8] = _s6v8A::P64;
           P64[Hp] = _s6v8B::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowSum_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6xtq,
                       label: Data.Semigroup.Internal.$fShowSum_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xtq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xtu; else goto c6xtt;
       c6xtu: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xtt: // global
           I64[Hp - 24] = sat_s6v8D_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.869833452 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshowList_info;
 },
 sat_s6v8I_entry() //  [R1, R2]
         { info_tbl: [(c6xtE,
                       label: sat_s6v8I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xtE: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowSum_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c6xtH,
                       label: Data.Semigroup.Internal.$fShowSum_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xtH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xtL; else goto c6xtK;
       c6xtL: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xtK: // global
           I64[Hp - 8] = sat_s6v8I_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.871398458 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_closure" {
     Data.Semigroup.Internal.$fShowSum_closure:
         const Data.Semigroup.Internal.$fShowSum_info;
         const 0;
 },
 sat_s6v8M_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xtV,
                       label: sat_s6v8M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xtV: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowSum_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v8L_entry() //  [R1, R2]
         { info_tbl: [(c6xu3,
                       label: sat_s6v8L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xu3: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowSum_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v8K_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xub,
                       label: sat_s6v8K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xub: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowSum_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowSum_entry() //  [R2]
         { info_tbl: [(c6xuf,
                       label: Data.Semigroup.Internal.$fShowSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xuf: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6xuj; else goto c6xui;
       c6xuj: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xui: // global
           I64[Hp - 72] = sat_s6v8M_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v8L_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v8K_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.872860988 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadSum5_bytes" {
     Data.Semigroup.Internal.$fReadSum5_bytes:
         I8[] [83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.873679393 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum4_closure" {
     Data.Semigroup.Internal.$fReadSum4_closure:
         const Data.Semigroup.Internal.$fReadSum4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadSum4_entry() //  [R1]
         { info_tbl: [(c6xuq,
                       label: Data.Semigroup.Internal.$fReadSum4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xuq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xur; else goto c6xus;
       c6xur: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xus: // global
           (_c6xun::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xun::I64 == 0) goto c6xup; else goto c6xuo;
       c6xup: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xuo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xun::I64;
           R2 = Data.Semigroup.Internal.$fReadSum5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.874645273 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_lexeme_closure" {
     Data.Semigroup.Internal.$fReadSum_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadSum4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.875245364 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadSum3_bytes" {
     Data.Semigroup.Internal.$fReadSum3_bytes:
         I8[] [103,101,116,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.875952565 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum2_closure" {
     Data.Semigroup.Internal.$fReadSum2_closure:
         const Data.Semigroup.Internal.$fReadSum2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadSum2_entry() //  [R1]
         { info_tbl: [(c6xuz,
                       label: Data.Semigroup.Internal.$fReadSum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xuz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xuA; else goto c6xuB;
       c6xuA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xuB: // global
           (_c6xuw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xuw::I64 == 0) goto c6xuy; else goto c6xux;
       c6xuy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xux: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xuw::I64;
           R2 = Data.Semigroup.Internal.$fReadSum3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.878846869 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum1_closure" {
     Data.Semigroup.Internal.$fReadSum1_closure:
         const Data.Semigroup.Internal.$fReadSum1_info;
         const 0;
 },
 lvl12_s6v8O_entry() //  [R1]
         { info_tbl: [(c6xuK,
                       label: lvl12_s6v8O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xuK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6xuL; else goto c6xuM;
       c6xuL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xuM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6v8P_entry() //  [R1]
         { info_tbl: [(c6xuS,
                       label: ds_s6v8P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xuS: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v90_entry() //  [R1]
         { info_tbl: [(c6xvt,
                       label: sat_s6v90_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xvt: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v93_entry() //  [R1, R2]
         { info_tbl: [(c6xvz,
                       label: sat_s6v93_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xvz: // global
           _s6v8Y::P64 = R2;
           _s6v93::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xvA; else goto c6xvB;
       c6xvB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xvD; else goto c6xvC;
       c6xvD: // global
           HpAlloc = 24;
           goto c6xvA;
       c6xvA: // global
           R2 = _s6v8Y::P64;
           R1 = _s6v93::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xvC: // global
           _s6v8S::P64 = P64[_s6v93::P64 + 7];
           I64[Hp - 16] = sat_s6v90_info;
           P64[Hp - 8] = _s6v8S::P64;
           P64[Hp] = _s6v8Y::P64;
           I64[Sp - 8] = block_c6xvw_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xvw() //  [R1]
         { info_tbl: [(c6xvw,
                       label: block_c6xvw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xvw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xvG; else goto c6xvF;
       c6xvG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xvF: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v94_entry() //  [R1, R2]
         { info_tbl: [(c6xvH,
                       label: sat_s6v94_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xvH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xvL; else goto c6xvK;
       c6xvL: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xvK: // global
           _s6v8P::P64 = P64[R1 + 7];
           _s6v8S::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6v93_info;
           P64[Hp] = _s6v8S::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6v8P::P64;
           R2 = Data.Semigroup.Internal.$fReadSum2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v97_entry() //  [R1, R2]
         { info_tbl: [(c6xvP,
                       label: sat_s6v97_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xvP: // global
           _s6v8W::P64 = R2;
           _s6v97::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xvQ; else goto c6xvR;
       c6xvR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xvT; else goto c6xvS;
       c6xvT: // global
           HpAlloc = 24;
           goto c6xvQ;
       c6xvQ: // global
           R2 = _s6v8W::P64;
           R1 = _s6v97::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xvS: // global
           _s6v8P::P64 = P64[_s6v97::P64 + 7];
           _s6v8S::P64 = P64[_s6v97::P64 + 15];
           I64[Hp - 16] = sat_s6v94_info;
           P64[Hp - 8] = _s6v8P::P64;
           P64[Hp] = _s6v8S::P64;
           I64[Sp - 8] = block_c6xvM_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xvM() //  [R1]
         { info_tbl: [(c6xvM,
                       label: block_c6xvM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xvM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xvW; else goto c6xvV;
       c6xvW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xvV: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9a_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xvX,
                       label: sat_s6v9a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xvX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xvY; else goto c6xvZ;
       c6xvY: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xvZ: // global
           I64[Sp - 24] = block_c6xv0_info;
           _s6v8P::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6v8P::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xwc; else goto c6xv1;
       u6xwc: // global
           call _c6xv0(R1) args: 0, res: 0, upd: 0;
       c6xv1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xv0() //  [R1]
         { info_tbl: [(c6xv0,
                       label: block_c6xv0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xv0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xw2; else goto c6xw1;
       c6xw2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xw1: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6xw4; else goto c6xw8;
       c6xw4: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6xw8: // global
           I64[Hp - 16] = sat_s6v97_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6xw5_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadSum_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xw5() //  [R1]
         { info_tbl: [(c6xw5,
                       label: block_c6xw5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xw5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xwb; else goto c6xwa;
       c6xwb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xwa: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum1_entry() //  [R2]
         { info_tbl: [(c6xwd,
                       label: Data.Semigroup.Internal.$fReadSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xwd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6xwh; else goto c6xwg;
       c6xwh: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xwg: // global
           I64[Hp - 48] = lvl12_s6v8O_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6v8P_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6v9a_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.883267559 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadsPrec_info;
         const 0;
 },
 ds_s6v9c_entry() //  [R1]
         { info_tbl: [(c6xwq,
                       label: ds_s6v9c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xwq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xwr; else goto c6xws;
       c6xwr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xws: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9e_entry() //  [R1]
         { info_tbl: [(c6xwC,
                       label: sat_s6v9e_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xwC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xwD; else goto c6xwE;
       c6xwD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xwE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9f_entry() //  [R1, R2]
         { info_tbl: [(c6xwF,
                       label: sat_s6v9f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xwF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xwJ; else goto c6xwI;
       c6xwJ: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xwI: // global
           _s6v9c::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v9e_info;
           P64[Hp - 8] = _s6v9c::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6xwK,
                       label: Data.Semigroup.Internal.$fReadSum_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xwK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6xwO; else goto c6xwN;
       c6xwO: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xwN: // global
           I64[Hp - 32] = ds_s6v9c_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6v9f_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.885172132 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadListPrec_info;
         const 0;
 },
 sat_s6v9h_entry() //  [R1]
         { info_tbl: [(c6xwX,
                       label: sat_s6v9h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xwX: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6xx0,
                       label: Data.Semigroup.Internal.$fReadSum_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xx0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xx4; else goto c6xx3;
       c6xx4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xx3: // global
           I64[Hp - 16] = sat_s6v9h_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.886653868 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadList_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadList_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadList_info;
         const 0;
 },
 sat_s6v9j_entry() //  [R1]
         { info_tbl: [(c6xxh,
                       label: sat_s6v9j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xxh: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9k_entry() //  [R1]
         { info_tbl: [(c6xxk,
                       label: sat_s6v9k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xxk: // global
           _s6v9k::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6xxl; else goto c6xxm;
       c6xxm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xxo; else goto c6xxn;
       c6xxo: // global
           HpAlloc = 24;
           goto c6xxl;
       c6xxl: // global
           R1 = _s6v9k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xxn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v9k::P64;
           _s6v9i::P64 = P64[_s6v9k::P64 + 16];
           I64[Hp - 16] = sat_s6v9j_info;
           P64[Hp] = _s6v9i::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadList_entry() //  [R2]
         { info_tbl: [(c6xxp,
                       label: Data.Semigroup.Internal.$fReadSum_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xxp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xxt; else goto c6xxs;
       c6xxt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xxs: // global
           I64[Hp - 16] = sat_s6v9k_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.888656141 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_closure" {
     Data.Semigroup.Internal.$fReadSum_closure:
         const Data.Semigroup.Internal.$fReadSum_info;
         const 0;
 },
 sat_s6v9p_entry() //  [R1]
         { info_tbl: [(c6xxC,
                       label: sat_s6v9p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xxC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xxD; else goto c6xxE;
       c6xxD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xxE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9o_entry() //  [R1]
         { info_tbl: [(c6xxJ,
                       label: sat_s6v9o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xxJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xxK; else goto c6xxL;
       c6xxK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xxL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9n_entry() //  [R1]
         { info_tbl: [(c6xxQ,
                       label: sat_s6v9n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xxQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xxR; else goto c6xxS;
       c6xxR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xxS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9m_entry() //  [R1]
         { info_tbl: [(c6xxX,
                       label: sat_s6v9m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xxX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xxY; else goto c6xxZ;
       c6xxY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xxZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadSum_entry() //  [R2]
         { info_tbl: [(c6xy1,
                       label: Data.Semigroup.Internal.$fReadSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xy1: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6xy5; else goto c6xy4;
       c6xy5: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xy4: // global
           I64[Hp - 128] = sat_s6v9p_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v9o_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v9n_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v9m_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.891120529 UTC

[section ""data" . Data.Semigroup.Internal.$fEqSum_closure" {
     Data.Semigroup.Internal.$fEqSum_closure:
         const Data.Semigroup.Internal.$fEqSum_info;
 },
 sat_s6v9s_entry() //  [R1]
         { info_tbl: [(c6xye,
                       label: sat_s6v9s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xye: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xyf; else goto c6xyg;
       c6xyf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xyg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9r_entry() //  [R1]
         { info_tbl: [(c6xyl,
                       label: sat_s6v9r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xyl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xym; else goto c6xyn;
       c6xym: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xyn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqSum_entry() //  [R2]
         { info_tbl: [(c6xyp,
                       label: Data.Semigroup.Internal.$fEqSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xyp: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6xyt; else goto c6xys;
       c6xyt: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xys: // global
           I64[Hp - 64] = sat_s6v9s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v9r_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.892780645 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdSum_$cp1Ord_info;
 },
 sat_s6v9u_entry() //  [R1]
         { info_tbl: [(c6xyC,
                       label: sat_s6v9u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xyC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xyD; else goto c6xyE;
       c6xyD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xyE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdSum_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6xyF,
                       label: Data.Semigroup.Internal.$fOrdSum_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xyF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xyJ; else goto c6xyI;
       c6xyJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xyI: // global
           I64[Hp - 16] = sat_s6v9u_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqSum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.894919314 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdSum_closure" {
     Data.Semigroup.Internal.$fOrdSum_closure:
         const Data.Semigroup.Internal.$fOrdSum_info;
 },
 sat_s6v9D_entry() //  [R1]
         { info_tbl: [(c6xyS,
                       label: sat_s6v9D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xyS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xyT; else goto c6xyU;
       c6xyT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xyU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9C_entry() //  [R1]
         { info_tbl: [(c6xyZ,
                       label: sat_s6v9C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xyZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xz0; else goto c6xz1;
       c6xz0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xz1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9B_entry() //  [R1]
         { info_tbl: [(c6xz6,
                       label: sat_s6v9B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xz6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xz7; else goto c6xz8;
       c6xz7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xz8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9A_entry() //  [R1]
         { info_tbl: [(c6xzd,
                       label: sat_s6v9A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xzd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xze; else goto c6xzf;
       c6xze: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xzf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9z_entry() //  [R1]
         { info_tbl: [(c6xzk,
                       label: sat_s6v9z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xzk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xzl; else goto c6xzm;
       c6xzl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xzm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9y_entry() //  [R1]
         { info_tbl: [(c6xzr,
                       label: sat_s6v9y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xzr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xzs; else goto c6xzt;
       c6xzs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xzt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9x_entry() //  [R1]
         { info_tbl: [(c6xzy,
                       label: sat_s6v9x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xzy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xzz; else goto c6xzA;
       c6xzz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xzA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9w_entry() //  [R1]
         { info_tbl: [(c6xzF,
                       label: sat_s6v9w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xzF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xzG; else goto c6xzH;
       c6xzG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xzH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdSum_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdSum_entry() //  [R2]
         { info_tbl: [(c6xzJ,
                       label: Data.Semigroup.Internal.$fOrdSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xzJ: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6xzN; else goto c6xzM;
       c6xzN: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xzM: // global
           I64[Hp - 256] = sat_s6v9D_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v9C_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v9B_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v9A_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v9z_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v9y_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v9x_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v9w_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.898818791 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny1_closure" {
     Data.Semigroup.Internal.$fGenericAny1_closure:
         const Data.Semigroup.Internal.$fGenericAny1_info;
 },
 Data.Semigroup.Internal.$fGenericAny1_entry() //  [R2]
         { info_tbl: [(c6xzS,
                       label: Data.Semigroup.Internal.$fGenericAny1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xzS: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.899689045 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny2_closure" {
     Data.Semigroup.Internal.$fGenericAny2_closure:
         const Data.Semigroup.Internal.$fGenericAny2_info;
 },
 Data.Semigroup.Internal.$fGenericAny2_entry() //  [R2]
         { info_tbl: [(c6xzZ,
                       label: Data.Semigroup.Internal.$fGenericAny2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xzZ: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.900394777 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny_closure" {
     Data.Semigroup.Internal.$fGenericAny_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAny2_closure+1;
         const Data.Semigroup.Internal.$fGenericAny1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.900973126 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedAny_closure" {
     Data.Semigroup.Internal.$fBoundedAny_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.901615753 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAny4_bytes" {
     Data.Semigroup.Internal.$fShowAny4_bytes:
         I8[] [65,110,121,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.902404914 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny3_closure" {
     Data.Semigroup.Internal.$fShowAny3_closure:
         const Data.Semigroup.Internal.$fShowAny3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny3_entry() //  [R1]
         { info_tbl: [(c6xA8,
                       label: Data.Semigroup.Internal.$fShowAny3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xA8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xA9; else goto c6xAa;
       c6xA9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xAa: // global
           (_c6xA5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xA5::I64 == 0) goto c6xA7; else goto c6xA6;
       c6xA7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xA6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xA5::I64;
           R2 = Data.Semigroup.Internal.$fShowAny4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.903295147 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAny2_bytes" {
     Data.Semigroup.Internal.$fShowAny2_bytes:
         I8[] [103,101,116,65,110,121,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.906020399 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec2_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec2_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec2_info;
         const 0;
 },
 sat_s6v9L_entry() //  [R1]
         { info_tbl: [(c6xAz,
                       label: sat_s6v9L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xAz: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9M_entry() //  [R1]
         { info_tbl: [(c6xAI,
                       label: sat_s6v9M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xAI: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9N_entry() //  [R1]
         { info_tbl: [(c6xAP,
                       label: sat_s6v9N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xAP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6xAQ; else goto c6xAR;
       c6xAQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xAR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6xAq_info;
           _s6v9I::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6v9I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6xAY; else goto c6xAr;
       u6xAY: // global
           call _c6xAq(R1) args: 0, res: 0, upd: 0;
       c6xAr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6xAq() //  [R1]
         { info_tbl: [(c6xAq,
                       label: block_c6xAq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xAq: // global
           _s6v9I::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6xAM; else goto c6xAN;
       c6xAM: // global
           Hp = Hp + 24;
           _s6v9K::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xAX; else goto c6xAT;
       c6xAT: // global
           I64[Hp - 16] = sat_s6v9L_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6xAN: // global
           Hp = Hp + 24;
           _s6v9K::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xAX; else goto c6xAW;
       c6xAX: // global
           HpAlloc = 24;
           R1 = _s6v9K::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6xAW: // global
           I64[Hp - 16] = sat_s6v9M_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9O_entry() //  [R1]
         { info_tbl: [(c6xAZ,
                       label: sat_s6v9O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xAZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xB3; else goto c6xB2;
       c6xB3: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xB2: // global
           _s6v9H::P64 = P64[R1 + 16];
           _s6v9I::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6v9N_info;
           P64[Hp - 8] = _s6v9H::P64;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9R_entry() //  [R1]
         { info_tbl: [(c6xBr,
                       label: sat_s6v9R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xBr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xBv; else goto c6xBu;
       c6xBv: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xBu: // global
           _s6v9I::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9T_entry() //  [R1]
         { info_tbl: [(c6xBD,
                       label: sat_s6v9T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xBD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xBH; else goto c6xBG;
       c6xBH: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xBG: // global
           _s6v9I::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9U_entry() //  [R1]
         { info_tbl: [(c6xBM,
                       label: sat_s6v9U_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xBM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6xBN; else goto c6xBO;
       c6xBN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xBO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6xBh_info;
           _s6v9I::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6v9I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6xBV; else goto c6xBi;
       u6xBV: // global
           call _c6xBh(R1) args: 0, res: 0, upd: 0;
       c6xBi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6xBh() //  [R1]
         { info_tbl: [(c6xBh,
                       label: block_c6xBh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xBh: // global
           _s6v9I::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6xBJ; else goto c6xBK;
       c6xBJ: // global
           Hp = Hp + 24;
           _s6v9P::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xBU; else goto c6xBQ;
       c6xBQ: // global
           I64[Hp - 16] = sat_s6v9R_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6xBK: // global
           Hp = Hp + 24;
           _s6v9P::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xBU; else goto c6xBT;
       c6xBU: // global
           HpAlloc = 24;
           R1 = _s6v9P::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6xBT: // global
           I64[Hp - 16] = sat_s6v9T_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9V_entry() //  [R1]
         { info_tbl: [(c6xBW,
                       label: sat_s6v9V_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xBW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xC0; else goto c6xBZ;
       c6xC0: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xBZ: // global
           _s6v9H::P64 = P64[R1 + 16];
           _s6v9I::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6v9U_info;
           P64[Hp - 8] = _s6v9H::P64;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9W_entry() //  [R1]
         { info_tbl: [(c6xC1,
                       label: sat_s6v9W_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xC1: // global
           _s6v9W::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xC2; else goto c6xC3;
       c6xC3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xC5; else goto c6xC4;
       c6xC5: // global
           HpAlloc = 32;
           goto c6xC2;
       c6xC2: // global
           R1 = _s6v9W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xC4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v9W::P64;
           _s6v9H::P64 = P64[_s6v9W::P64 + 16];
           _s6v9I::P64 = P64[_s6v9W::P64 + 24];
           I64[Hp - 24] = sat_s6v9V_info;
           P64[Hp - 8] = _s6v9H::P64;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(c6xC9,
                       label: Data.Semigroup.Internal.$w$cshowsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xC9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6xCd; else goto c6xCc;
       c6xCd: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xCc: // global
           if (%MO_S_Lt_W64(R2, 11)) goto c6xC7; else goto c6xC8;
       c6xC7: // global
           I64[Hp - 48] = sat_s6v9O_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _c6xAi::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c6xAi::P64;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6xC8: // global
           I64[Hp - 48] = sat_s6v9W_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.910429474 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6xCm,
                       label: Data.Semigroup.Internal.$fShowAny_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xCm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xCn; else goto c6xCo;
       c6xCn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xCo: // global
           I64[Sp - 24] = block_c6xCj_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xCs; else goto c6xCk;
       u6xCs: // global
           call _c6xCj(R1) args: 0, res: 0, upd: 0;
       c6xCk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xCj() //  [R1]
         { info_tbl: [(c6xCj,
                       label: block_c6xCj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xCj: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.911669173 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll6_closure" {
     Data.Semigroup.Internal.$fShowAll6_closure:
         const Data.Semigroup.Internal.$fShowAll6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll6_entry() //  [R1]
         { info_tbl: [(c6xCz,
                       label: Data.Semigroup.Internal.$fShowAll6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xCz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xCA; else goto c6xCB;
       c6xCA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xCB: // global
           (_c6xCw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xCw::I64 == 0) goto c6xCy; else goto c6xCx;
       c6xCy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xCx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xCw::I64;
           R3 = Data.Semigroup.Internal.$fReadAll4_closure;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.912795278 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll5_closure" {
     Data.Semigroup.Internal.$fShowAll5_closure:
         const Data.Semigroup.Internal.$fShowAll5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll5_entry() //  [R1]
         { info_tbl: [(c6xCI,
                       label: Data.Semigroup.Internal.$fShowAll5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xCI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xCJ; else goto c6xCK;
       c6xCJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xCK: // global
           (_c6xCF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xCF::I64 == 0) goto c6xCH; else goto c6xCG;
       c6xCH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xCG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xCF::I64;
           R3 = Data.Semigroup.Internal.$fReadAll4_closure;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.914298417 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshow_info;
         const 0;
 },
 sat_s6va4_entry() //  [R1]
         { info_tbl: [(c6xD4,
                       label: sat_s6va4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xD4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xD5; else goto c6xD6;
       c6xD5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xD6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6xCX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xDd; else goto c6xCY;
       u6xDd: // global
           call _c6xCX(R1) args: 0, res: 0, upd: 0;
       c6xCY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6xCX() //  [R1]
         { info_tbl: [(c6xCX,
                       label: block_c6xCX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xCX: // global
           if (R1 & 7 == 1) goto c6xD1; else goto c6xD2;
       c6xD1: // global
           R1 = Data.Semigroup.Internal.$fShowAll6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6xD2: // global
           R1 = Data.Semigroup.Internal.$fShowAll5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6va5_entry() //  [R1]
         { info_tbl: [(c6xDe,
                       label: sat_s6va5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xDe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xDi; else goto c6xDh;
       c6xDi: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xDh: // global
           _s6va2::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s6va4_info;
           P64[Hp] = _s6va2::P64;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAny_$cshow_entry() //  [R2]
         { info_tbl: [(c6xDj,
                       label: Data.Semigroup.Internal.$fShowAny_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xDj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xDn; else goto c6xDm;
       c6xDn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xDm: // global
           I64[Hp - 16] = sat_s6va5_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.916827439 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny1_closure" {
     Data.Semigroup.Internal.$fShowAny1_closure:
         const Data.Semigroup.Internal.$fShowAny1_info;
         const 0;
 },
 sat_s6va9_entry() //  [R1]
         { info_tbl: [(c6xDJ,
                       label: sat_s6va9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xDJ: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaa_entry() //  [R1]
         { info_tbl: [(c6xDS,
                       label: sat_s6vaa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xDS: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vab_entry() //  [R1]
         { info_tbl: [(c6xDZ,
                       label: sat_s6vab_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xDZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6xE0; else goto c6xE1;
       c6xE0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xE1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6xDA_info;
           _s6va7::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6va7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6xE8; else goto c6xDB;
       u6xE8: // global
           call _c6xDA(R1) args: 0, res: 0, upd: 0;
       c6xDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6xDA() //  [R1]
         { info_tbl: [(c6xDA,
                       label: block_c6xDA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xDA: // global
           _s6va7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6xDW; else goto c6xDX;
       c6xDW: // global
           Hp = Hp + 24;
           _s6va8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xE7; else goto c6xE3;
       c6xE3: // global
           I64[Hp - 16] = sat_s6va9_info;
           P64[Hp] = _s6va7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6xDX: // global
           Hp = Hp + 24;
           _s6va8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xE7; else goto c6xE6;
       c6xE7: // global
           HpAlloc = 24;
           R1 = _s6va8::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6xE6: // global
           I64[Hp - 16] = sat_s6vaa_info;
           P64[Hp] = _s6va7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vac_entry() //  [R1]
         { info_tbl: [(c6xE9,
                       label: sat_s6vac_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xE9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xEd; else goto c6xEc;
       c6xEd: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xEc: // global
           _s6va6::P64 = P64[R1 + 16];
           _s6va7::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vab_info;
           P64[Hp - 8] = _s6va6::P64;
           P64[Hp] = _s6va7::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAny1_entry() //  [R2, R3]
         { info_tbl: [(c6xEe,
                       label: Data.Semigroup.Internal.$fShowAny1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xEe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xEi; else goto c6xEh;
       c6xEi: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xEh: // global
           I64[Hp - 24] = sat_s6vac_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.919454654 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshowList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c6xEn,
                       label: Data.Semigroup.Internal.$fShowAny_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xEn: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fShowAny1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.920274623 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_closure" {
     Data.Semigroup.Internal.$fShowAny_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure+3;
         const Data.Semigroup.Internal.$fShowAny_$cshow_closure+1;
         const Data.Semigroup.Internal.$fShowAny_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.92097311 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAny6_bytes" {
     Data.Semigroup.Internal.$fReadAny6_bytes:
         I8[] [65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.922859188 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny5_closure" {
     Data.Semigroup.Internal.$fReadAny5_closure:
         const Data.Semigroup.Internal.$fReadAny5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny5_entry() //  [R1]
         { info_tbl: [(c6xEw,
                       label: Data.Semigroup.Internal.$fReadAny5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xEw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xEx; else goto c6xEy;
       c6xEx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xEy: // global
           (_c6xEt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xEt::I64 == 0) goto c6xEv; else goto c6xEu;
       c6xEv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xEu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xEt::I64;
           R2 = Data.Semigroup.Internal.$fReadAny6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.923807341 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAny_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAny5_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.924384736 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAny4_bytes" {
     Data.Semigroup.Internal.$fReadAny4_bytes:
         I8[] [103,101,116,65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.925122212 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny3_closure" {
     Data.Semigroup.Internal.$fReadAny3_closure:
         const Data.Semigroup.Internal.$fReadAny3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny3_entry() //  [R1]
         { info_tbl: [(c6xEF,
                       label: Data.Semigroup.Internal.$fReadAny3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xEF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xEG; else goto c6xEH;
       c6xEG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xEH: // global
           (_c6xEC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xEC::I64 == 0) goto c6xEE; else goto c6xED;
       c6xEE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xED: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xEC::I64;
           R2 = Data.Semigroup.Internal.$fReadAny4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.926196137 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll7_closure" {
     Data.Semigroup.Internal.$fReadAll7_closure:
         const Data.Semigroup.Internal.$fReadAll7_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll7_entry() //  [R3]
         { info_tbl: [(c6xEM,
                       label: Data.Semigroup.Internal.$fReadAll7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xEM: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadBool2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.928129359 UTC

[section ""data" . Data.Semigroup.Internal.$w$creadPrec1_closure" {
     Data.Semigroup.Internal.$w$creadPrec1_closure:
         const Data.Semigroup.Internal.$w$creadPrec1_info;
         const 0;
 },
 sat_s6vao_entry() //  [R1]
         { info_tbl: [(c6xFh,
                       label: sat_s6vao_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xFh: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6var_entry() //  [R1, R2]
         { info_tbl: [(c6xFn,
                       label: sat_s6var_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xFn: // global
           _s6vam::P64 = R2;
           _s6var::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xFo; else goto c6xFp;
       c6xFp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xFr; else goto c6xFq;
       c6xFr: // global
           HpAlloc = 24;
           goto c6xFo;
       c6xFo: // global
           R2 = _s6vam::P64;
           R1 = _s6var::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xFq: // global
           _s6vai::P64 = P64[_s6var::P64 + 7];
           I64[Hp - 16] = sat_s6vao_info;
           P64[Hp - 8] = _s6vai::P64;
           P64[Hp] = _s6vam::P64;
           I64[Sp - 8] = block_c6xFk_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xFk() //  [R1]
         { info_tbl: [(c6xFk,
                       label: block_c6xFk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xFk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xFu; else goto c6xFt;
       c6xFu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xFt: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6xFZ_srtd" {
     u6xFZ_srtd:
         const S6vn0_srt+128;
         const 45;
         const 32985348833281;
 },
 sat_s6vas_entry() //  [R1, R2]
         { info_tbl: [(c6xFv,
                       label: sat_s6vas_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xFv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xFz; else goto c6xFy;
       c6xFz: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xFy: // global
           _s6vai::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s6var_info;
           P64[Hp] = _s6vai::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = Data.Semigroup.Internal.$fReadAll7_closure+2;
           R2 = Data.Semigroup.Internal.$fReadAny3_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6xG0_srtd" {
     u6xG0_srtd:
         const S6vn0_srt+128;
         const 45;
         const 32985348833285;
 },
 sat_s6vav_entry() //  [R1, R2]
         { info_tbl: [(c6xFD,
                       label: sat_s6vav_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xFD: // global
           _s6vak::P64 = R2;
           _s6vav::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xFE; else goto c6xFF;
       c6xFF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xFH; else goto c6xFG;
       c6xFH: // global
           HpAlloc = 16;
           goto c6xFE;
       c6xFE: // global
           R2 = _s6vak::P64;
           R1 = _s6vav::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xFG: // global
           _s6vai::P64 = P64[_s6vav::P64 + 7];
           I64[Hp - 8] = sat_s6vas_info;
           P64[Hp] = _s6vai::P64;
           I64[Sp - 8] = block_c6xFA_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xFA() //  [R1]
         { info_tbl: [(c6xFA,
                       label: block_c6xFA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xFA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xFK; else goto c6xFJ;
       c6xFK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xFJ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6xG1_srtd" {
     u6xG1_srtd:
         const S6vn0_srt+128;
         const 47;
         const 138538465099781;
 },
 Data.Semigroup.Internal.$w$creadPrec1_entry() //  [R2, R3]
         { info_tbl: [(c6xFO,
                       label: Data.Semigroup.Internal.$w$creadPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xFO: // global
           _s6vai::P64 = R3;
           _s6vah::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xFP; else goto c6xFQ;
       c6xFQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xFS; else goto c6xFR;
       c6xFS: // global
           HpAlloc = 16;
           goto c6xFP;
       c6xFP: // global
           R3 = _s6vai::P64;
           R2 = _s6vah::I64;
           R1 = Data.Semigroup.Internal.$w$creadPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xFR: // global
           if (%MO_S_Gt_W64(_s6vah::I64, 11)) goto c6xFM; else goto c6xFN;
       c6xFM: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6xFN: // global
           I64[Hp - 8] = sat_s6vav_info;
           P64[Hp] = _s6vai::P64;
           I64[Sp - 8] = block_c6xFT_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAny_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xFT() //  [R1]
         { info_tbl: [(c6xFT,
                       label: block_c6xFT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xFT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xFY; else goto c6xFX;
       c6xFY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xFX: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.931424042 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny2_closure" {
     Data.Semigroup.Internal.$fReadAny2_closure:
         const Data.Semigroup.Internal.$fReadAny2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny2_entry() //  [R2, R3]
         { info_tbl: [(c6xG9,
                       label: Data.Semigroup.Internal.$fReadAny2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xG9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xGa; else goto c6xGb;
       c6xGa: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAny2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xGb: // global
           I64[Sp - 16] = block_c6xG6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6xGf; else goto c6xG7;
       u6xGf: // global
           call _c6xG6(R1) args: 0, res: 0, upd: 0;
       c6xG7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xG6() //  [R1]
         { info_tbl: [(c6xG6,
                       label: block_c6xG6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xG6: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$creadPrec1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.932626932 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny1_closure" {
     Data.Semigroup.Internal.$fReadAny1_closure:
         const Data.Semigroup.Internal.$fReadAny1_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny1_entry() //  [R2, R3]
         { info_tbl: [(c6xGk,
                       label: Data.Semigroup.Internal.$fReadAny1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xGk: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAny2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.933843704 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_info;
         const 0;
 },
 sat_s6vaD_entry() //  [R1]
         { info_tbl: [(c6xGv,
                       label: sat_s6vaD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xGv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xGw; else goto c6xGx;
       c6xGw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xGx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAny2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAny_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6xGy,
                       label: Data.Semigroup.Internal.$fReadAny_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xGy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xGC; else goto c6xGB;
       c6xGC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xGB: // global
           I64[Hp - 16] = sat_s6vaD_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.93516599 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c6xGJ,
                       label: Data.Semigroup.Internal.$fReadAny_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xGJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xGK; else goto c6xGL;
       c6xGK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xGL: // global
           (_c6xGG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xGG::I64 == 0) goto c6xGI; else goto c6xGH;
       c6xGI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xGH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xGG::I64;
           R2 = Data.Semigroup.Internal.$fReadAny1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.936256049 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny7_closure" {
     Data.Semigroup.Internal.$fReadAny7_closure:
         const Data.Semigroup.Internal.$fReadAny7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny7_entry() //  [R1]
         { info_tbl: [(c6xGS,
                       label: Data.Semigroup.Internal.$fReadAny7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xGS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xGT; else goto c6xGU;
       c6xGT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xGU: // global
           (_c6xGP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xGP::I64 == 0) goto c6xGR; else goto c6xGQ;
       c6xGR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xGQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xGP::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.937304476 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny_$creadList_entry() //  [R2]
         { info_tbl: [(c6xGZ,
                       label: Data.Semigroup.Internal.$fReadAny_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xGZ: // global
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAny7_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.938064722 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_closure" {
     Data.Semigroup.Internal.$fReadAny_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure+1;
         const Data.Semigroup.Internal.$fReadAny_$creadList_closure+1;
         const Data.Semigroup.Internal.$fReadAny1_closure+2;
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.938694343 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAny_closure" {
     Data.Semigroup.Internal.$fEqAny_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.$fEqBool_$c==_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.93934096 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAny_closure" {
     Data.Semigroup.Internal.$fOrdAny_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Semigroup.Internal.$fEqAny_closure+1;
         const GHC.Classes.$fOrdBool_$ccompare_closure+2;
         const GHC.Classes.$fOrdBool_$c<_closure+2;
         const GHC.Classes.$fOrdBool_$c<=_closure+2;
         const GHC.Classes.$fOrdBool_$c>_closure+2;
         const GHC.Classes.$fOrdBool_$c>=_closure+2;
         const GHC.Classes.$fOrdBool_$cmax_closure+2;
         const GHC.Classes.$fOrdBool_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.940068298 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll1_closure" {
     Data.Semigroup.Internal.$fGenericAll1_closure:
         const Data.Semigroup.Internal.$fGenericAll1_info;
 },
 Data.Semigroup.Internal.$fGenericAll1_entry() //  [R2]
         { info_tbl: [(c6xH6,
                       label: Data.Semigroup.Internal.$fGenericAll1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xH6: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.940913409 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll2_closure" {
     Data.Semigroup.Internal.$fGenericAll2_closure:
         const Data.Semigroup.Internal.$fGenericAll2_info;
 },
 Data.Semigroup.Internal.$fGenericAll2_entry() //  [R2]
         { info_tbl: [(c6xHd,
                       label: Data.Semigroup.Internal.$fGenericAll2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xHd: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.941702376 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll_closure" {
     Data.Semigroup.Internal.$fGenericAll_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAll2_closure+1;
         const Data.Semigroup.Internal.$fGenericAll1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.942297729 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedAll_closure" {
     Data.Semigroup.Internal.$fBoundedAll_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.942948736 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAll4_bytes" {
     Data.Semigroup.Internal.$fShowAll4_bytes:
         I8[] [65,108,108,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.943707765 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll3_closure" {
     Data.Semigroup.Internal.$fShowAll3_closure:
         const Data.Semigroup.Internal.$fShowAll3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll3_entry() //  [R1]
         { info_tbl: [(c6xHm,
                       label: Data.Semigroup.Internal.$fShowAll3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xHm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xHn; else goto c6xHo;
       c6xHn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xHo: // global
           (_c6xHj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xHj::I64 == 0) goto c6xHl; else goto c6xHk;
       c6xHl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xHk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xHj::I64;
           R2 = Data.Semigroup.Internal.$fShowAll4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.944676398 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAll2_bytes" {
     Data.Semigroup.Internal.$fShowAll2_bytes:
         I8[] [103,101,116,65,108,108,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.947497227 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec_info;
         const 0;
 },
 sat_s6vaL_entry() //  [R1]
         { info_tbl: [(c6xHN,
                       label: sat_s6vaL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xHN: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaM_entry() //  [R1]
         { info_tbl: [(c6xHW,
                       label: sat_s6vaM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xHW: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaN_entry() //  [R1]
         { info_tbl: [(c6xI3,
                       label: sat_s6vaN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xI3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6xI4; else goto c6xI5;
       c6xI4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xI5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6xHE_info;
           _s6vaI::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6vaI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6xIc; else goto c6xHF;
       u6xIc: // global
           call _c6xHE(R1) args: 0, res: 0, upd: 0;
       c6xHF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6xHE() //  [R1]
         { info_tbl: [(c6xHE,
                       label: block_c6xHE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xHE: // global
           _s6vaI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6xI0; else goto c6xI1;
       c6xI0: // global
           Hp = Hp + 24;
           _s6vaK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xIb; else goto c6xI7;
       c6xI7: // global
           I64[Hp - 16] = sat_s6vaL_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6xI1: // global
           Hp = Hp + 24;
           _s6vaK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xIb; else goto c6xIa;
       c6xIb: // global
           HpAlloc = 24;
           R1 = _s6vaK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6xIa: // global
           I64[Hp - 16] = sat_s6vaM_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vaO_entry() //  [R1]
         { info_tbl: [(c6xId,
                       label: sat_s6vaO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xId: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xIh; else goto c6xIg;
       c6xIh: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xIg: // global
           _s6vaH::P64 = P64[R1 + 16];
           _s6vaI::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vaN_info;
           P64[Hp - 8] = _s6vaH::P64;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaR_entry() //  [R1]
         { info_tbl: [(c6xIF,
                       label: sat_s6vaR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xIF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xIJ; else goto c6xII;
       c6xIJ: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xII: // global
           _s6vaI::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaT_entry() //  [R1]
         { info_tbl: [(c6xIR,
                       label: sat_s6vaT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xIR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xIV; else goto c6xIU;
       c6xIV: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xIU: // global
           _s6vaI::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaU_entry() //  [R1]
         { info_tbl: [(c6xJ0,
                       label: sat_s6vaU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xJ0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6xJ1; else goto c6xJ2;
       c6xJ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xJ2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6xIv_info;
           _s6vaI::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6vaI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6xJ9; else goto c6xIw;
       u6xJ9: // global
           call _c6xIv(R1) args: 0, res: 0, upd: 0;
       c6xIw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6xIv() //  [R1]
         { info_tbl: [(c6xIv,
                       label: block_c6xIv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xIv: // global
           _s6vaI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6xIX; else goto c6xIY;
       c6xIX: // global
           Hp = Hp + 24;
           _s6vaP::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xJ8; else goto c6xJ4;
       c6xJ4: // global
           I64[Hp - 16] = sat_s6vaR_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6xIY: // global
           Hp = Hp + 24;
           _s6vaP::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xJ8; else goto c6xJ7;
       c6xJ8: // global
           HpAlloc = 24;
           R1 = _s6vaP::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6xJ7: // global
           I64[Hp - 16] = sat_s6vaT_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vaV_entry() //  [R1]
         { info_tbl: [(c6xJa,
                       label: sat_s6vaV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xJa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xJe; else goto c6xJd;
       c6xJe: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xJd: // global
           _s6vaH::P64 = P64[R1 + 16];
           _s6vaI::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vaU_info;
           P64[Hp - 8] = _s6vaH::P64;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaW_entry() //  [R1]
         { info_tbl: [(c6xJf,
                       label: sat_s6vaW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xJf: // global
           _s6vaW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xJg; else goto c6xJh;
       c6xJh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xJj; else goto c6xJi;
       c6xJj: // global
           HpAlloc = 32;
           goto c6xJg;
       c6xJg: // global
           R1 = _s6vaW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xJi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vaW::P64;
           _s6vaH::P64 = P64[_s6vaW::P64 + 16];
           _s6vaI::P64 = P64[_s6vaW::P64 + 24];
           I64[Hp - 24] = sat_s6vaV_info;
           P64[Hp - 8] = _s6vaH::P64;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6xJn,
                       label: Data.Semigroup.Internal.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xJn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6xJr; else goto c6xJq;
       c6xJr: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xJq: // global
           if (%MO_S_Lt_W64(R2, 11)) goto c6xJl; else goto c6xJm;
       c6xJl: // global
           I64[Hp - 48] = sat_s6vaO_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _c6xHw::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c6xHw::P64;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6xJm: // global
           I64[Hp - 48] = sat_s6vaW_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.953607251 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6xJA,
                       label: Data.Semigroup.Internal.$fShowAll_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xJA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xJB; else goto c6xJC;
       c6xJB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xJC: // global
           I64[Sp - 24] = block_c6xJx_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xJG; else goto c6xJy;
       u6xJG: // global
           call _c6xJx(R1) args: 0, res: 0, upd: 0;
       c6xJy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xJx() //  [R1]
         { info_tbl: [(c6xJx,
                       label: block_c6xJx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xJx: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.95537298 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshow_info;
         const 0;
 },
 sat_s6vb4_entry() //  [R1]
         { info_tbl: [(c6xK0,
                       label: sat_s6vb4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xK0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xK1; else goto c6xK2;
       c6xK1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xK2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6xJT_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xK9; else goto c6xJU;
       u6xK9: // global
           call _c6xJT(R1) args: 0, res: 0, upd: 0;
       c6xJU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6xJT() //  [R1]
         { info_tbl: [(c6xJT,
                       label: block_c6xJT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xJT: // global
           if (R1 & 7 == 1) goto c6xJX; else goto c6xJY;
       c6xJX: // global
           R1 = Data.Semigroup.Internal.$fShowAll6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6xJY: // global
           R1 = Data.Semigroup.Internal.$fShowAll5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vb5_entry() //  [R1]
         { info_tbl: [(c6xKa,
                       label: sat_s6vb5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xKa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xKe; else goto c6xKd;
       c6xKe: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xKd: // global
           _s6vb2::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s6vb4_info;
           P64[Hp] = _s6vb2::P64;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAll_$cshow_entry() //  [R2]
         { info_tbl: [(c6xKf,
                       label: Data.Semigroup.Internal.$fShowAll_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xKf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xKj; else goto c6xKi;
       c6xKj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xKi: // global
           I64[Hp - 16] = sat_s6vb5_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.958151548 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll1_closure" {
     Data.Semigroup.Internal.$fShowAll1_closure:
         const Data.Semigroup.Internal.$fShowAll1_info;
         const 0;
 },
 sat_s6vb9_entry() //  [R1]
         { info_tbl: [(c6xKF,
                       label: sat_s6vb9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xKF: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vba_entry() //  [R1]
         { info_tbl: [(c6xKO,
                       label: sat_s6vba_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xKO: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vbb_entry() //  [R1]
         { info_tbl: [(c6xKV,
                       label: sat_s6vbb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xKV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6xKW; else goto c6xKX;
       c6xKW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xKX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6xKw_info;
           _s6vb7::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6vb7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6xL4; else goto c6xKx;
       u6xL4: // global
           call _c6xKw(R1) args: 0, res: 0, upd: 0;
       c6xKx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6xKw() //  [R1]
         { info_tbl: [(c6xKw,
                       label: block_c6xKw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xKw: // global
           _s6vb7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6xKS; else goto c6xKT;
       c6xKS: // global
           Hp = Hp + 24;
           _s6vb8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xL3; else goto c6xKZ;
       c6xKZ: // global
           I64[Hp - 16] = sat_s6vb9_info;
           P64[Hp] = _s6vb7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6xKT: // global
           Hp = Hp + 24;
           _s6vb8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6xL3; else goto c6xL2;
       c6xL3: // global
           HpAlloc = 24;
           R1 = _s6vb8::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6xL2: // global
           I64[Hp - 16] = sat_s6vba_info;
           P64[Hp] = _s6vb7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbc_entry() //  [R1]
         { info_tbl: [(c6xL5,
                       label: sat_s6vbc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xL5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xL9; else goto c6xL8;
       c6xL9: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xL8: // global
           _s6vb6::P64 = P64[R1 + 16];
           _s6vb7::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vbb_info;
           P64[Hp - 8] = _s6vb6::P64;
           P64[Hp] = _s6vb7::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAll1_entry() //  [R2, R3]
         { info_tbl: [(c6xLa,
                       label: Data.Semigroup.Internal.$fShowAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xLa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xLe; else goto c6xLd;
       c6xLe: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xLd: // global
           I64[Hp - 24] = sat_s6vbc_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.96053592 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshowList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c6xLj,
                       label: Data.Semigroup.Internal.$fShowAll_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xLj: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fShowAll1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.961567321 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_closure" {
     Data.Semigroup.Internal.$fShowAll_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure+3;
         const Data.Semigroup.Internal.$fShowAll_$cshow_closure+1;
         const Data.Semigroup.Internal.$fShowAll_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.962166884 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll13_bytes" {
     Data.Semigroup.Internal.$fReadAll13_bytes:
         I8[] [65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.962950293 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll12_closure" {
     Data.Semigroup.Internal.$fReadAll12_closure:
         const Data.Semigroup.Internal.$fReadAll12_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll12_entry() //  [R1]
         { info_tbl: [(c6xLs,
                       label: Data.Semigroup.Internal.$fReadAll12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xLs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xLt; else goto c6xLu;
       c6xLt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xLu: // global
           (_c6xLp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xLp::I64 == 0) goto c6xLr; else goto c6xLq;
       c6xLr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xLq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xLp::I64;
           R2 = Data.Semigroup.Internal.$fReadAll13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.963840499 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_lexeme1_closure" {
     Data.Semigroup.Internal.$fReadAll_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAll12_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.964475692 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll9_bytes" {
     Data.Semigroup.Internal.$fReadAll9_bytes:
         I8[] [103,101,116,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.965199195 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll8_closure" {
     Data.Semigroup.Internal.$fReadAll8_closure:
         const Data.Semigroup.Internal.$fReadAll8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll8_entry() //  [R1]
         { info_tbl: [(c6xLB,
                       label: Data.Semigroup.Internal.$fReadAll8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xLB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xLC; else goto c6xLD;
       c6xLC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xLD: // global
           (_c6xLy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xLy::I64 == 0) goto c6xLA; else goto c6xLz;
       c6xLA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xLz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xLy::I64;
           R2 = Data.Semigroup.Internal.$fReadAll9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.967334355 UTC

[section ""data" . Data.Semigroup.Internal.$w$creadPrec_closure" {
     Data.Semigroup.Internal.$w$creadPrec_closure:
         const Data.Semigroup.Internal.$w$creadPrec_info;
         const 0;
 },
 sat_s6vbm_entry() //  [R1]
         { info_tbl: [(c6xM6,
                       label: sat_s6vbm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xM6: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vbp_entry() //  [R1, R2]
         { info_tbl: [(c6xMc,
                       label: sat_s6vbp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xMc: // global
           _s6vbk::P64 = R2;
           _s6vbp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xMd; else goto c6xMe;
       c6xMe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xMg; else goto c6xMf;
       c6xMg: // global
           HpAlloc = 24;
           goto c6xMd;
       c6xMd: // global
           R2 = _s6vbk::P64;
           R1 = _s6vbp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xMf: // global
           _s6vbg::P64 = P64[_s6vbp::P64 + 7];
           I64[Hp - 16] = sat_s6vbm_info;
           P64[Hp - 8] = _s6vbg::P64;
           P64[Hp] = _s6vbk::P64;
           I64[Sp - 8] = block_c6xM9_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xM9() //  [R1]
         { info_tbl: [(c6xM9,
                       label: block_c6xM9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xM9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xMj; else goto c6xMi;
       c6xMj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xMi: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6xMO_srtd" {
     u6xMO_srtd:
         const S6vn0_srt+128;
         const 59;
         const 288245769314500609;
 },
 sat_s6vbq_entry() //  [R1, R2]
         { info_tbl: [(c6xMk,
                       label: sat_s6vbq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xMk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xMo; else goto c6xMn;
       c6xMo: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xMn: // global
           _s6vbg::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s6vbp_info;
           P64[Hp] = _s6vbg::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = Data.Semigroup.Internal.$fReadAll7_closure+2;
           R2 = Data.Semigroup.Internal.$fReadAll8_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6xMP_srtd" {
     u6xMP_srtd:
         const S6vn0_srt+128;
         const 59;
         const 288245769314500613;
 },
 sat_s6vbt_entry() //  [R1, R2]
         { info_tbl: [(c6xMs,
                       label: sat_s6vbt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xMs: // global
           _s6vbi::P64 = R2;
           _s6vbt::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xMt; else goto c6xMu;
       c6xMu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xMw; else goto c6xMv;
       c6xMw: // global
           HpAlloc = 16;
           goto c6xMt;
       c6xMt: // global
           R2 = _s6vbi::P64;
           R1 = _s6vbt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xMv: // global
           _s6vbg::P64 = P64[_s6vbt::P64 + 7];
           I64[Hp - 8] = sat_s6vbq_info;
           P64[Hp] = _s6vbg::P64;
           I64[Sp - 8] = block_c6xMp_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xMp() //  [R1]
         { info_tbl: [(c6xMp,
                       label: block_c6xMp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xMp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xMz; else goto c6xMy;
       c6xMz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xMy: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6xMQ_srtd" {
     u6xMQ_srtd:
         const S6vn0_srt+128;
         const 61;
         const 2017628026224771077;
 },
 Data.Semigroup.Internal.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(c6xMD,
                       label: Data.Semigroup.Internal.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xMD: // global
           _s6vbg::P64 = R3;
           _s6vbf::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xME; else goto c6xMF;
       c6xMF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xMH; else goto c6xMG;
       c6xMH: // global
           HpAlloc = 16;
           goto c6xME;
       c6xME: // global
           R3 = _s6vbg::P64;
           R2 = _s6vbf::I64;
           R1 = Data.Semigroup.Internal.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xMG: // global
           if (%MO_S_Gt_W64(_s6vbf::I64, 11)) goto c6xMB; else goto c6xMC;
       c6xMB: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6xMC: // global
           I64[Hp - 8] = sat_s6vbt_info;
           P64[Hp] = _s6vbg::P64;
           I64[Sp - 8] = block_c6xMI_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xMI() //  [R1]
         { info_tbl: [(c6xMI,
                       label: block_c6xMI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xMI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xMN; else goto c6xMM;
       c6xMN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xMM: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.970655287 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll2_closure" {
     Data.Semigroup.Internal.$fReadAll2_closure:
         const Data.Semigroup.Internal.$fReadAll2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll2_entry() //  [R2, R3]
         { info_tbl: [(c6xMY,
                       label: Data.Semigroup.Internal.$fReadAll2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xMY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xMZ; else goto c6xN0;
       c6xMZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAll2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xN0: // global
           I64[Sp - 16] = block_c6xMV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6xN4; else goto c6xMW;
       u6xN4: // global
           call _c6xMV(R1) args: 0, res: 0, upd: 0;
       c6xMW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xMV() //  [R1]
         { info_tbl: [(c6xMV,
                       label: block_c6xMV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xMV: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$creadPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.971871239 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll1_closure" {
     Data.Semigroup.Internal.$fReadAll1_closure:
         const Data.Semigroup.Internal.$fReadAll1_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll1_entry() //  [R2, R3]
         { info_tbl: [(c6xN9,
                       label: Data.Semigroup.Internal.$fReadAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xN9: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAll2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.972968506 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_info;
         const 0;
 },
 sat_s6vbB_entry() //  [R1]
         { info_tbl: [(c6xNk,
                       label: sat_s6vbB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xNk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xNl; else goto c6xNm;
       c6xNl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xNm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAll_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6xNn,
                       label: Data.Semigroup.Internal.$fReadAll_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xNn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xNr; else goto c6xNq;
       c6xNr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xNq: // global
           I64[Hp - 16] = sat_s6vbB_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.974385722 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c6xNy,
                       label: Data.Semigroup.Internal.$fReadAll_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xNy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xNz; else goto c6xNA;
       c6xNz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xNA: // global
           (_c6xNv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xNv::I64 == 0) goto c6xNx; else goto c6xNw;
       c6xNx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xNw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xNv::I64;
           R2 = Data.Semigroup.Internal.$fReadAll1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.975503732 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll14_closure" {
     Data.Semigroup.Internal.$fReadAll14_closure:
         const Data.Semigroup.Internal.$fReadAll14_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll14_entry() //  [R1]
         { info_tbl: [(c6xNH,
                       label: Data.Semigroup.Internal.$fReadAll14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xNH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xNI; else goto c6xNJ;
       c6xNI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xNJ: // global
           (_c6xNE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xNE::I64 == 0) goto c6xNG; else goto c6xNF;
       c6xNG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xNF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xNE::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.977633497 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll_$creadList_entry() //  [R2]
         { info_tbl: [(c6xNO,
                       label: Data.Semigroup.Internal.$fReadAll_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xNO: // global
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAll14_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.978389847 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_closure" {
     Data.Semigroup.Internal.$fReadAll_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure+1;
         const Data.Semigroup.Internal.$fReadAll_$creadList_closure+1;
         const Data.Semigroup.Internal.$fReadAll1_closure+2;
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.979021606 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAll_closure" {
     Data.Semigroup.Internal.$fEqAll_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.$fEqBool_$c==_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.979620341 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAll_closure" {
     Data.Semigroup.Internal.$fOrdAll_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Semigroup.Internal.$fEqAll_closure+1;
         const GHC.Classes.$fOrdBool_$ccompare_closure+2;
         const GHC.Classes.$fOrdBool_$c<_closure+2;
         const GHC.Classes.$fOrdBool_$c<=_closure+2;
         const GHC.Classes.$fOrdBool_$c>_closure+2;
         const GHC.Classes.$fOrdBool_$c>=_closure+2;
         const GHC.Classes.$fOrdBool_$cmax_closure+2;
         const GHC.Classes.$fOrdBool_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.980367557 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo1_closure" {
     Data.Semigroup.Internal.$fGenericEndo1_closure:
         const Data.Semigroup.Internal.$fGenericEndo1_info;
 },
 Data.Semigroup.Internal.$fGenericEndo1_entry() //  [R2]
         { info_tbl: [(c6xNV,
                       label: Data.Semigroup.Internal.$fGenericEndo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xNV: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.981173539 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo2_closure" {
     Data.Semigroup.Internal.$fGenericEndo2_closure:
         const Data.Semigroup.Internal.$fGenericEndo2_info;
 },
 Data.Semigroup.Internal.$fGenericEndo2_entry() //  [R2]
         { info_tbl: [(c6xO2,
                       label: Data.Semigroup.Internal.$fGenericEndo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xO2: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.982294094 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo_closure" {
     Data.Semigroup.Internal.$fGenericEndo_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericEndo2_closure+1;
         const Data.Semigroup.Internal.$fGenericEndo1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.983210013 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual1_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual1_closure:
         const Data.Semigroup.Internal.$fGeneric1Dual1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Dual1_entry() //  [R2]
         { info_tbl: [(c6xO9,
                       label: Data.Semigroup.Internal.$fGeneric1Dual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xO9: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.984324905 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual2_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual2_closure:
         const Data.Semigroup.Internal.$fGeneric1Dual2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Dual2_entry() //  [R2]
         { info_tbl: [(c6xOg,
                       label: Data.Semigroup.Internal.$fGeneric1Dual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xOg: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.985349443 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Dual2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Dual1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.98626499 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual1_closure" {
     Data.Semigroup.Internal.$fGenericDual1_closure:
         const Data.Semigroup.Internal.$fGenericDual1_info;
 },
 Data.Semigroup.Internal.$fGenericDual1_entry() //  [R2]
         { info_tbl: [(c6xOn,
                       label: Data.Semigroup.Internal.$fGenericDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xOn: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.987322951 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual2_closure" {
     Data.Semigroup.Internal.$fGenericDual2_closure:
         const Data.Semigroup.Internal.$fGenericDual2_info;
 },
 Data.Semigroup.Internal.$fGenericDual2_entry() //  [R2]
         { info_tbl: [(c6xOu,
                       label: Data.Semigroup.Internal.$fGenericDual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xOu: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.988278804 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual_closure" {
     Data.Semigroup.Internal.$fGenericDual_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericDual2_closure+1;
         const Data.Semigroup.Internal.$fGenericDual1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.989592239 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedDual_closure" {
     Data.Semigroup.Internal.$fBoundedDual_closure:
         const Data.Semigroup.Internal.$fBoundedDual_info;
 },
 sat_s6vbK_entry() //  [R1]
         { info_tbl: [(c6xOF,
                       label: sat_s6vbK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xOF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xOG; else goto c6xOH;
       c6xOG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xOH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbJ_entry() //  [R1]
         { info_tbl: [(c6xOM,
                       label: sat_s6vbJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xOM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xON; else goto c6xOO;
       c6xON: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xOO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedDual_entry() //  [R2]
         { info_tbl: [(c6xOQ,
                       label: Data.Semigroup.Internal.$fBoundedDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xOQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6xOU; else goto c6xOT;
       c6xOU: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xOT: // global
           I64[Hp - 64] = sat_s6vbK_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6vbJ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.99133206 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowDual2_bytes" {
     Data.Semigroup.Internal.$fShowDual2_bytes:
         I8[] [68,117,97,108,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.99207876 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowDual1_bytes" {
     Data.Semigroup.Internal.$fShowDual1_bytes:
         I8[] [103,101,116,68,117,97,108,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.994800508 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec3_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec3_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec3_info;
 },
 f_s6vbO_entry() //  [R1]
         { info_tbl: [(c6xP3,
                       label: f_s6vbO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xP3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6xP4; else goto c6xP5;
       c6xP4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xP5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vbR_entry() //  [R1]
         { info_tbl: [(c6xPq,
                       label: sat_s6vbR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xPq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xPr; else goto c6xPs;
       c6xPr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xPs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbS_entry() //  [R1]
         { info_tbl: [(c6xPt,
                       label: sat_s6vbS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xPt: // global
           _s6vbS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xPu; else goto c6xPv;
       c6xPv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xPx; else goto c6xPw;
       c6xPx: // global
           HpAlloc = 24;
           goto c6xPu;
       c6xPu: // global
           R1 = _s6vbS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xPw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbS::P64;
           _s6vbO::P64 = P64[_s6vbS::P64 + 16];
           _s6vbQ::P64 = P64[_s6vbS::P64 + 24];
           I64[Hp - 16] = sat_s6vbR_info;
           P64[Hp] = _s6vbQ::P64;
           R2 = Hp - 16;
           R1 = _s6vbO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbT_entry() //  [R1]
         { info_tbl: [(c6xPy,
                       label: sat_s6vbT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xPy: // global
           _s6vbT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xPz; else goto c6xPA;
       c6xPA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xPC; else goto c6xPB;
       c6xPC: // global
           HpAlloc = 32;
           goto c6xPz;
       c6xPz: // global
           R1 = _s6vbT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xPB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbT::P64;
           _s6vbO::P64 = P64[_s6vbT::P64 + 16];
           _s6vbQ::P64 = P64[_s6vbT::P64 + 24];
           I64[Hp - 24] = sat_s6vbS_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = _s6vbQ::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbU_entry() //  [R1, R2]
         { info_tbl: [(c6xPD,
                       label: sat_s6vbU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xPD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xPH; else goto c6xPG;
       c6xPH: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xPG: // global
           _s6vbO::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6vbT_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vbX_entry() //  [R1]
         { info_tbl: [(c6xQ5,
                       label: sat_s6vbX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xQ5: // global
           _s6vbX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xQ6; else goto c6xQ7;
       c6xQ7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xQ9; else goto c6xQ8;
       c6xQ9: // global
           HpAlloc = 24;
           goto c6xQ6;
       c6xQ6: // global
           R1 = _s6vbX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xQ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbX::P64;
           _s6vbV::P64 = P64[_s6vbX::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6vbV::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbY_entry() //  [R1]
         { info_tbl: [(c6xQa,
                       label: sat_s6vbY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xQa: // global
           _s6vbY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xQb; else goto c6xQc;
       c6xQc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xQe; else goto c6xQd;
       c6xQe: // global
           HpAlloc = 24;
           goto c6xQb;
       c6xQb: // global
           R1 = _s6vbY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xQd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbY::P64;
           _s6vbO::P64 = P64[_s6vbY::P64 + 16];
           _s6vbV::P64 = P64[_s6vbY::P64 + 24];
           I64[Hp - 16] = sat_s6vbX_info;
           P64[Hp] = _s6vbV::P64;
           R2 = Hp - 16;
           R1 = _s6vbO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbZ_entry() //  [R1]
         { info_tbl: [(c6xQf,
                       label: sat_s6vbZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xQf: // global
           _s6vbZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xQg; else goto c6xQh;
       c6xQh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xQj; else goto c6xQi;
       c6xQj: // global
           HpAlloc = 32;
           goto c6xQg;
       c6xQg: // global
           R1 = _s6vbZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xQi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbZ::P64;
           _s6vbO::P64 = P64[_s6vbZ::P64 + 16];
           _s6vbV::P64 = P64[_s6vbZ::P64 + 24];
           I64[Hp - 24] = sat_s6vbY_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = _s6vbV::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vc0_entry() //  [R1]
         { info_tbl: [(c6xQk,
                       label: sat_s6vc0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xQk: // global
           _s6vc0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xQl; else goto c6xQm;
       c6xQm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xQo; else goto c6xQn;
       c6xQo: // global
           HpAlloc = 32;
           goto c6xQl;
       c6xQl: // global
           R1 = _s6vc0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xQn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vc0::P64;
           _s6vbO::P64 = P64[_s6vc0::P64 + 16];
           _s6vbV::P64 = P64[_s6vc0::P64 + 24];
           I64[Hp - 24] = sat_s6vbZ_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = _s6vbV::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vc1_entry() //  [R1, R2]
         { info_tbl: [(c6xQq,
                       label: sat_s6vc1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xQq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6xQu; else goto c6xQt;
       c6xQu: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xQt: // global
           _s6vbO::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6vc0_info;
           P64[Hp - 32] = _s6vbO::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec3_entry() //  [R2, R3, R4]
         { info_tbl: [(c6xQy,
                       label: Data.Semigroup.Internal.$w$cshowsPrec3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xQy: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6xQC; else goto c6xQB;
       c6xQC: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xQB: // global
           I64[Hp - 40] = f_s6vbO_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6xOZ::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6xQw; else goto c6xQx;
       c6xQw: // global
           I64[Hp - 8] = sat_s6vbU_info;
           P64[Hp] = _c6xOZ::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6xQx: // global
           I64[Hp - 8] = sat_s6vc1_info;
           P64[Hp] = _c6xOZ::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:43.999984699 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowDual_$cshowsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c6xQK,
                       label: Data.Semigroup.Internal.$fShowDual_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xQK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xQL; else goto c6xQM;
       c6xQL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xQM: // global
           I64[Sp - 24] = block_c6xQH_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xQQ; else goto c6xQI;
       u6xQQ: // global
           call _c6xQH(R1) args: 0, res: 0, upd: 0;
       c6xQI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6xQH() //  [R1]
         { info_tbl: [(c6xQH,
                       label: block_c6xQH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xQH: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec3_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.001477287 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshow_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshow_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshow_info;
         const 0;
 },
 sat_s6vc9_entry() //  [R1]
         { info_tbl: [(c6xR3,
                       label: sat_s6vc9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xR3: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6xR4; else goto c6xR5;
       c6xR4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xR5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6vca_entry() //  [R1]
         { info_tbl: [(c6xR6,
                       label: sat_s6vca_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xR6: // global
           _s6vca::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6xR7; else goto c6xR8;
       c6xR8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xRa; else goto c6xR9;
       c6xRa: // global
           HpAlloc = 32;
           goto c6xR7;
       c6xR7: // global
           R1 = _s6vca::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xR9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vca::P64;
           _s6vc7::P64 = P64[_s6vca::P64 + 16];
           _s6vc8::P64 = P64[_s6vca::P64 + 24];
           I64[Hp - 24] = sat_s6vc9_info;
           P64[Hp - 8] = _s6vc7::P64;
           P64[Hp] = _s6vc8::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowDual_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6xRb,
                       label: Data.Semigroup.Internal.$fShowDual_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xRb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xRf; else goto c6xRe;
       c6xRf: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xRe: // global
           I64[Hp - 24] = sat_s6vca_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.003360822 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshowList_info;
 },
 sat_s6vcf_entry() //  [R1, R2]
         { info_tbl: [(c6xRp,
                       label: sat_s6vcf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xRp: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec3_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowDual_$cshowList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6xRs,
                       label: Data.Semigroup.Internal.$fShowDual_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xRs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xRw; else goto c6xRv;
       c6xRw: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xRv: // global
           I64[Hp - 8] = sat_s6vcf_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.004923575 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_closure" {
     Data.Semigroup.Internal.$fShowDual_closure:
         const Data.Semigroup.Internal.$fShowDual_info;
         const 0;
 },
 sat_s6vcj_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xRG,
                       label: sat_s6vcj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xRG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowDual_$cshowList_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vci_entry() //  [R1, R2]
         { info_tbl: [(c6xRO,
                       label: sat_s6vci_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xRO: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowDual_$cshow_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vch_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xRW,
                       label: sat_s6vch_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xRW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowDual_$cshowsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowDual_entry() //  [R2]
         { info_tbl: [(c6xS0,
                       label: Data.Semigroup.Internal.$fShowDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xS0: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6xS4; else goto c6xS3;
       c6xS4: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xS3: // global
           I64[Hp - 72] = sat_s6vcj_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6vci_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6vch_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.007310734 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadDual5_bytes" {
     Data.Semigroup.Internal.$fReadDual5_bytes:
         I8[] [68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.008054928 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual4_closure" {
     Data.Semigroup.Internal.$fReadDual4_closure:
         const Data.Semigroup.Internal.$fReadDual4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadDual4_entry() //  [R1]
         { info_tbl: [(c6xSb,
                       label: Data.Semigroup.Internal.$fReadDual4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xSb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xSc; else goto c6xSd;
       c6xSc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xSd: // global
           (_c6xS8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xS8::I64 == 0) goto c6xSa; else goto c6xS9;
       c6xSa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xS9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xS8::I64;
           R2 = Data.Semigroup.Internal.$fReadDual5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.008929214 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_lexeme_closure" {
     Data.Semigroup.Internal.$fReadDual_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadDual4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.00976175 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadDual3_bytes" {
     Data.Semigroup.Internal.$fReadDual3_bytes:
         I8[] [103,101,116,68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.010397658 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual2_closure" {
     Data.Semigroup.Internal.$fReadDual2_closure:
         const Data.Semigroup.Internal.$fReadDual2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadDual2_entry() //  [R1]
         { info_tbl: [(c6xSk,
                       label: Data.Semigroup.Internal.$fReadDual2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xSk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xSl; else goto c6xSm;
       c6xSl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xSm: // global
           (_c6xSh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xSh::I64 == 0) goto c6xSj; else goto c6xSi;
       c6xSj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xSi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xSh::I64;
           R2 = Data.Semigroup.Internal.$fReadDual3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.012946934 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual1_closure" {
     Data.Semigroup.Internal.$fReadDual1_closure:
         const Data.Semigroup.Internal.$fReadDual1_info;
         const 0;
 },
 lvl12_s6vcl_entry() //  [R1]
         { info_tbl: [(c6xSv,
                       label: lvl12_s6vcl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xSv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6xSw; else goto c6xSx;
       c6xSw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xSx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6vcm_entry() //  [R1]
         { info_tbl: [(c6xSD,
                       label: ds_s6vcm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xSD: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vcx_entry() //  [R1]
         { info_tbl: [(c6xTe,
                       label: sat_s6vcx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xTe: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vcA_entry() //  [R1, R2]
         { info_tbl: [(c6xTk,
                       label: sat_s6vcA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xTk: // global
           _s6vcv::P64 = R2;
           _s6vcA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xTl; else goto c6xTm;
       c6xTm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xTo; else goto c6xTn;
       c6xTo: // global
           HpAlloc = 24;
           goto c6xTl;
       c6xTl: // global
           R2 = _s6vcv::P64;
           R1 = _s6vcA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xTn: // global
           _s6vcp::P64 = P64[_s6vcA::P64 + 7];
           I64[Hp - 16] = sat_s6vcx_info;
           P64[Hp - 8] = _s6vcp::P64;
           P64[Hp] = _s6vcv::P64;
           I64[Sp - 8] = block_c6xTh_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xTh() //  [R1]
         { info_tbl: [(c6xTh,
                       label: block_c6xTh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xTh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xTr; else goto c6xTq;
       c6xTr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xTq: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6xU3_srtd" {
     u6xU3_srtd:
         const S6vn0_srt+128;
         const 70;
         const 6597069766657;
         const 32;
 },
 sat_s6vcB_entry() //  [R1, R2]
         { info_tbl: [(c6xTs,
                       label: sat_s6vcB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xTs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xTw; else goto c6xTv;
       c6xTw: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xTv: // global
           _s6vcm::P64 = P64[R1 + 7];
           _s6vcp::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6vcA_info;
           P64[Hp] = _s6vcp::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6vcm::P64;
           R2 = Data.Semigroup.Internal.$fReadDual2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6xU4_srtd" {
     u6xU4_srtd:
         const S6vn0_srt+128;
         const 70;
         const 6597069766661;
         const 32;
 },
 sat_s6vcE_entry() //  [R1, R2]
         { info_tbl: [(c6xTA,
                       label: sat_s6vcE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xTA: // global
           _s6vct::P64 = R2;
           _s6vcE::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6xTB; else goto c6xTC;
       c6xTC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xTE; else goto c6xTD;
       c6xTE: // global
           HpAlloc = 24;
           goto c6xTB;
       c6xTB: // global
           R2 = _s6vct::P64;
           R1 = _s6vcE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xTD: // global
           _s6vcm::P64 = P64[_s6vcE::P64 + 7];
           _s6vcp::P64 = P64[_s6vcE::P64 + 15];
           I64[Hp - 16] = sat_s6vcB_info;
           P64[Hp - 8] = _s6vcm::P64;
           P64[Hp] = _s6vcp::P64;
           I64[Sp - 8] = block_c6xTx_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xTx() //  [R1]
         { info_tbl: [(c6xTx,
                       label: block_c6xTx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xTx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xTH; else goto c6xTG;
       c6xTH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xTG: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6xU5_srtd" {
     u6xU5_srtd:
         const S6vn0_srt+128;
         const 71;
         const 6597069766661;
         const 96;
 },
 sat_s6vcH_entry() //  [R1, R2, R3]
         { info_tbl: [(c6xTI,
                       label: sat_s6vcH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xTI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xTJ; else goto c6xTK;
       c6xTJ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6xTK: // global
           I64[Sp - 24] = block_c6xSL_info;
           _s6vcm::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6vcm::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6xTX; else goto c6xSM;
       u6xTX: // global
           call _c6xSL(R1) args: 0, res: 0, upd: 0;
       c6xSM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u6xU6_srtd" {
     u6xU6_srtd:
         const S6vn0_srt+128;
         const 71;
         const 6597069766661;
         const 96;
 },
 _c6xSL() //  [R1]
         { info_tbl: [(c6xSL,
                       label: block_c6xSL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xSL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xTN; else goto c6xTM;
       c6xTN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xTM: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6xTP; else goto c6xTT;
       c6xTP: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6xTT: // global
           I64[Hp - 16] = sat_s6vcE_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6xTQ_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadDual_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6xTQ() //  [R1]
         { info_tbl: [(c6xTQ,
                       label: block_c6xTQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xTQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6xTW; else goto c6xTV;
       c6xTW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6xTV: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6xU7_srtd" {
     u6xU7_srtd:
         const S6vn0_srt+128;
         const 72;
         const 7696581394437;
         const 224;
 },
 Data.Semigroup.Internal.$fReadDual1_entry() //  [R2]
         { info_tbl: [(c6xTY,
                       label: Data.Semigroup.Internal.$fReadDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xTY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6xU2; else goto c6xU1;
       c6xU2: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xU1: // global
           I64[Hp - 48] = lvl12_s6vcl_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6vcm_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6vcH_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.01750911 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadsPrec_info;
         const 0;
 },
 ds_s6vcJ_entry() //  [R1]
         { info_tbl: [(c6xUg,
                       label: ds_s6vcJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xUg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xUh; else goto c6xUi;
       c6xUh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xUi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcL_entry() //  [R1]
         { info_tbl: [(c6xUs,
                       label: sat_s6vcL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xUs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xUt; else goto c6xUu;
       c6xUt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xUu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcM_entry() //  [R1, R2]
         { info_tbl: [(c6xUv,
                       label: sat_s6vcM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xUv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6xUz; else goto c6xUy;
       c6xUz: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xUy: // global
           _s6vcJ::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6vcL_info;
           P64[Hp - 8] = _s6vcJ::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6xUA,
                       label: Data.Semigroup.Internal.$fReadDual_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xUA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6xUE; else goto c6xUD;
       c6xUE: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xUD: // global
           I64[Hp - 32] = ds_s6vcJ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6vcM_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.01934424 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadListPrec_info;
         const 0;
 },
 sat_s6vcO_entry() //  [R1]
         { info_tbl: [(c6xUN,
                       label: sat_s6vcO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xUN: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6xUQ,
                       label: Data.Semigroup.Internal.$fReadDual_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xUQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xUU; else goto c6xUT;
       c6xUU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xUT: // global
           I64[Hp - 16] = sat_s6vcO_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.020701954 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadList_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadList_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadList_info;
         const 0;
 },
 sat_s6vcQ_entry() //  [R1]
         { info_tbl: [(c6xV7,
                       label: sat_s6vcQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xV7: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vcR_entry() //  [R1]
         { info_tbl: [(c6xVa,
                       label: sat_s6vcR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xVa: // global
           _s6vcR::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6xVb; else goto c6xVc;
       c6xVc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xVe; else goto c6xVd;
       c6xVe: // global
           HpAlloc = 24;
           goto c6xVb;
       c6xVb: // global
           R1 = _s6vcR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xVd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vcR::P64;
           _s6vcP::P64 = P64[_s6vcR::P64 + 16];
           I64[Hp - 16] = sat_s6vcQ_info;
           P64[Hp] = _s6vcP::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadList_entry() //  [R2]
         { info_tbl: [(c6xVf,
                       label: Data.Semigroup.Internal.$fReadDual_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xVf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xVj; else goto c6xVi;
       c6xVj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xVi: // global
           I64[Hp - 16] = sat_s6vcR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.022690634 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_closure" {
     Data.Semigroup.Internal.$fReadDual_closure:
         const Data.Semigroup.Internal.$fReadDual_info;
         const 0;
 },
 sat_s6vcW_entry() //  [R1]
         { info_tbl: [(c6xVs,
                       label: sat_s6vcW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xVs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xVt; else goto c6xVu;
       c6xVt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xVu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcV_entry() //  [R1]
         { info_tbl: [(c6xVz,
                       label: sat_s6vcV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xVz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xVA; else goto c6xVB;
       c6xVA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xVB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcU_entry() //  [R1]
         { info_tbl: [(c6xVG,
                       label: sat_s6vcU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xVG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xVH; else goto c6xVI;
       c6xVH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xVI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcT_entry() //  [R1]
         { info_tbl: [(c6xVN,
                       label: sat_s6vcT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xVN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xVO; else goto c6xVP;
       c6xVO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xVP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadDual_entry() //  [R2]
         { info_tbl: [(c6xVR,
                       label: Data.Semigroup.Internal.$fReadDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xVR: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6xVV; else goto c6xVU;
       c6xVV: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xVU: // global
           I64[Hp - 128] = sat_s6vcW_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6vcV_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6vcU_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6vcT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.02489685 UTC

[section ""data" . Data.Semigroup.Internal.$fEqDual_closure" {
     Data.Semigroup.Internal.$fEqDual_closure:
         const Data.Semigroup.Internal.$fEqDual_info;
 },
 sat_s6vcZ_entry() //  [R1]
         { info_tbl: [(c6xW4,
                       label: sat_s6vcZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xW4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xW5; else goto c6xW6;
       c6xW5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xW6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcY_entry() //  [R1]
         { info_tbl: [(c6xWb,
                       label: sat_s6vcY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xWb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xWc; else goto c6xWd;
       c6xWc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xWd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqDual_entry() //  [R2]
         { info_tbl: [(c6xWf,
                       label: Data.Semigroup.Internal.$fEqDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xWf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6xWj; else goto c6xWi;
       c6xWj: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xWi: // global
           I64[Hp - 64] = sat_s6vcZ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6vcY_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.0266208 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdDual_$cp1Ord_info;
 },
 sat_s6vd1_entry() //  [R1]
         { info_tbl: [(c6xWs,
                       label: sat_s6vd1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xWs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xWt; else goto c6xWu;
       c6xWt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xWu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdDual_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6xWv,
                       label: Data.Semigroup.Internal.$fOrdDual_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xWv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6xWz; else goto c6xWy;
       c6xWz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xWy: // global
           I64[Hp - 16] = sat_s6vd1_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqDual_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.028655 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdDual_closure" {
     Data.Semigroup.Internal.$fOrdDual_closure:
         const Data.Semigroup.Internal.$fOrdDual_info;
 },
 sat_s6vda_entry() //  [R1]
         { info_tbl: [(c6xWI,
                       label: sat_s6vda_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xWI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xWJ; else goto c6xWK;
       c6xWJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xWK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd9_entry() //  [R1]
         { info_tbl: [(c6xWP,
                       label: sat_s6vd9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xWP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xWQ; else goto c6xWR;
       c6xWQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xWR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd8_entry() //  [R1]
         { info_tbl: [(c6xWW,
                       label: sat_s6vd8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xWW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xWX; else goto c6xWY;
       c6xWX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xWY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd7_entry() //  [R1]
         { info_tbl: [(c6xX3,
                       label: sat_s6vd7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xX3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xX4; else goto c6xX5;
       c6xX4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xX5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd6_entry() //  [R1]
         { info_tbl: [(c6xXa,
                       label: sat_s6vd6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xXa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xXb; else goto c6xXc;
       c6xXb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xXc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd5_entry() //  [R1]
         { info_tbl: [(c6xXh,
                       label: sat_s6vd5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xXh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xXi; else goto c6xXj;
       c6xXi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xXj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd4_entry() //  [R1]
         { info_tbl: [(c6xXo,
                       label: sat_s6vd4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xXo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xXp; else goto c6xXq;
       c6xXp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xXq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd3_entry() //  [R1]
         { info_tbl: [(c6xXv,
                       label: sat_s6vd3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xXv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6xXw; else goto c6xXx;
       c6xXw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xXx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdDual_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdDual_entry() //  [R2]
         { info_tbl: [(c6xXz,
                       label: Data.Semigroup.Internal.$fOrdDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xXz: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6xXD; else goto c6xXC;
       c6xXD: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6xXC: // global
           I64[Hp - 256] = sat_s6vda_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6vd9_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6vd8_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6vd7_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6vd6_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6vd5_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6vd4_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6vd3_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.031531885 UTC

[section ""data" . Data.Semigroup.Internal.getDual_closure" {
     Data.Semigroup.Internal.getDual_closure:
         const Data.Semigroup.Internal.getDual_info;
 },
 Data.Semigroup.Internal.getDual_entry() //  [R2]
         { info_tbl: [(c6xXI,
                       label: Data.Semigroup.Internal.getDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xXI: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Dual2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.032525711 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadDual_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadDual_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadDual_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6xXP,
                       label: Data.Semigroup.Internal.$fMonadDual_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xXP: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.033839025 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadDual_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadDual_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadDual_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6xXW,
                       label: Data.Semigroup.Internal.$fMonadDual_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xXW: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeDual_$c*>_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.036311797 UTC

[section ""data" . lvl_r6v16_closure" {
     lvl_r6v16_closure:
         const lvl_r6v16_info;
         const 0;
 },
 lvl_r6v16_entry() //  [R2]
         { info_tbl: [(c6xY3,
                       label: lvl_r6v16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xY3: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.037676929 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_closure" {
     Data.Semigroup.Internal.$fMonadDual_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeDual_closure+1;
         const Data.Semigroup.Internal.$fMonadDual_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadDual_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl_r6v16_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.038697145 UTC

[section ""data" . Data.Semigroup.Internal.appEndo1_closure" {
     Data.Semigroup.Internal.appEndo1_closure:
         const Data.Semigroup.Internal.appEndo1_info;
 },
 Data.Semigroup.Internal.appEndo1_entry() //  [R2]
         { info_tbl: [(c6xYa,
                       label: Data.Semigroup.Internal.appEndo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xYa: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.039784079 UTC

[section ""data" . Data.Semigroup.Internal.appEndo_closure" {
     Data.Semigroup.Internal.appEndo_closure:
         const Data.Semigroup.Internal.appEndo_info;
 },
 Data.Semigroup.Internal.appEndo_entry() //  [R2]
         { info_tbl: [(c6xYh,
                       label: Data.Semigroup.Internal.appEndo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xYh: // global
           R2 = R2;
           call Data.Semigroup.Internal.appEndo1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.040979567 UTC

[section ""data" . Data.Semigroup.Internal.getAll1_closure" {
     Data.Semigroup.Internal.getAll1_closure:
         const Data.Semigroup.Internal.getAll1_info;
 },
 Data.Semigroup.Internal.getAll1_entry() //  [R2]
         { info_tbl: [(c6xYo,
                       label: Data.Semigroup.Internal.getAll1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xYo: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.042155838 UTC

[section ""data" . Data.Semigroup.Internal.getAll_closure" {
     Data.Semigroup.Internal.getAll_closure:
         const Data.Semigroup.Internal.getAll_info;
 },
 Data.Semigroup.Internal.getAll_entry() //  [R2]
         { info_tbl: [(c6xYv,
                       label: Data.Semigroup.Internal.getAll_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xYv: // global
           R2 = R2;
           call Data.Semigroup.Internal.getAll1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.043279815 UTC

[section ""data" . Data.Semigroup.Internal.getAny1_closure" {
     Data.Semigroup.Internal.getAny1_closure:
         const Data.Semigroup.Internal.getAny1_info;
 },
 Data.Semigroup.Internal.getAny1_entry() //  [R2]
         { info_tbl: [(c6xYC,
                       label: Data.Semigroup.Internal.getAny1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xYC: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.044453236 UTC

[section ""data" . Data.Semigroup.Internal.getAny_closure" {
     Data.Semigroup.Internal.getAny_closure:
         const Data.Semigroup.Internal.getAny_info;
 },
 Data.Semigroup.Internal.getAny_entry() //  [R2]
         { info_tbl: [(c6xYJ,
                       label: Data.Semigroup.Internal.getAny_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xYJ: // global
           R2 = R2;
           call Data.Semigroup.Internal.getAny1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.045600851 UTC

[section ""data" . Data.Semigroup.Internal.getSum_closure" {
     Data.Semigroup.Internal.getSum_closure:
         const Data.Semigroup.Internal.getSum_info;
 },
 Data.Semigroup.Internal.getSum_entry() //  [R2]
         { info_tbl: [(c6xYQ,
                       label: Data.Semigroup.Internal.getSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xYQ: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Sum2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.046766864 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadSum_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadSum_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadSum_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6xYX,
                       label: Data.Semigroup.Internal.$fMonadSum_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xYX: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.047895185 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadSum_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadSum_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadSum_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6xZ4,
                       label: Data.Semigroup.Internal.$fMonadSum_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xZ4: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeSum_$c*>_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.04899134 UTC

[section ""data" . lvl1_r6v17_closure" {
     lvl1_r6v17_closure:
         const lvl1_r6v17_info;
         const 0;
 },
 lvl1_r6v17_entry() //  [R2]
         { info_tbl: [(c6xZb,
                       label: lvl1_r6v17_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xZb: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.050002556 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_closure" {
     Data.Semigroup.Internal.$fMonadSum_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeSum_closure+1;
         const Data.Semigroup.Internal.$fMonadSum_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadSum_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl1_r6v17_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.050982086 UTC

[section ""data" . Data.Semigroup.Internal.getProduct_closure" {
     Data.Semigroup.Internal.getProduct_closure:
         const Data.Semigroup.Internal.getProduct_info;
 },
 Data.Semigroup.Internal.getProduct_entry() //  [R2]
         { info_tbl: [(c6xZi,
                       label: Data.Semigroup.Internal.getProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xZi: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Product2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.052198252 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadProduct_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadProduct_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6xZp,
                       label: Data.Semigroup.Internal.$fMonadProduct_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xZp: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.053357048 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadProduct_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadProduct_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadProduct_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6xZw,
                       label: Data.Semigroup.Internal.$fMonadProduct_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xZw: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeProduct_$c*>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.054478325 UTC

[section ""data" . lvl2_r6v18_closure" {
     lvl2_r6v18_closure:
         const lvl2_r6v18_info;
         const 0;
 },
 lvl2_r6v18_entry() //  [R2]
         { info_tbl: [(c6xZD,
                       label: lvl2_r6v18_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xZD: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.055505146 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_closure" {
     Data.Semigroup.Internal.$fMonadProduct_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeProduct_closure+1;
         const Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadProduct_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl2_r6v18_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.056525624 UTC

[section ""data" . Data.Semigroup.Internal.getAlt_closure" {
     Data.Semigroup.Internal.getAlt_closure:
         const Data.Semigroup.Internal.getAlt_info;
 },
 Data.Semigroup.Internal.getAlt_entry() //  [R2]
         { info_tbl: [(c6xZK,
                       label: Data.Semigroup.Internal.getAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xZK: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Alt2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.057777594 UTC

[section ""cstring" . lvl3_r6v19_bytes" {
     lvl3_r6v19_bytes:
         I8[] [115,116,105,109,101,115,73,100,101,109,112,111,116,101,110,116,58,32,112,111,115,105,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114,32,101,120,112,101,99,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.058867988 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotent1_closure" {
     Data.Semigroup.Internal.stimesIdempotent1_closure:
         const Data.Semigroup.Internal.stimesIdempotent1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesIdempotent1_entry() //  [R1]
         { info_tbl: [(c6xZV,
                       label: Data.Semigroup.Internal.stimesIdempotent1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xZV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6xZW; else goto c6xZX;
       c6xZW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6xZX: // global
           (_c6xZQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6xZQ::I64 == 0) goto c6xZS; else goto c6xZR;
       c6xZS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6xZR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6xZQ::I64;
           I64[Sp - 24] = block_c6xZT_info;
           R2 = lvl3_r6v19_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6xZT() //  [R1]
         { info_tbl: [(c6xZT,
                       label: block_c6xZT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6xZT: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.061108086 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotent_closure" {
     Data.Semigroup.Internal.stimesIdempotent_closure:
         const Data.Semigroup.Internal.stimesIdempotent_info;
         const 0;
 },
 sat_s6vdu_entry() //  [R1]
         { info_tbl: [(c6y0f,
                       label: sat_s6vdu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y0f: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6y0g; else goto c6y0h;
       c6y0g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y0h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6y0d_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6y0d() //  [R1]
         { info_tbl: [(c6y0d,
                       label: block_c6y0d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y0d: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesIdempotent_entry() //  [R2, R3, R4]
         { info_tbl: [(c6y0l,
                       label: Data.Semigroup.Internal.stimesIdempotent_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y0l: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y0n; else goto c6y0o;
       c6y0n: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotent_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6y0o: // global
           I64[Sp - 24] = block_c6y05_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6y05() //  [R1]
         { info_tbl: [(c6y05,
                       label: block_c6y05_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y05: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6y0r; else goto c6y0q;
       c6y0r: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6y0q: // global
           I64[Hp - 16] = sat_s6vdu_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6y0m_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6y0m() //  [R1]
         { info_tbl: [(c6y0m,
                       label: block_c6y0m_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y0m: // global
           _s6vdp::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c6y0v_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s6vdp::P64;
           Sp = Sp - 8;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6y0v() //  [R1]
         { info_tbl: [(c6y0v,
                       label: block_c6y0v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y0v: // global
           if (R1 & 7 == 1) goto c6y0C; else goto c6y0G;
       c6y0C: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6y0G: // global
           R1 = Data.Semigroup.Internal.stimesIdempotent1_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.063786047 UTC

[section ""cstring" . lvl4_r6v1a_bytes" {
     lvl4_r6v1a_bytes:
         I8[] [115,116,105,109,101,115,73,100,101,109,112,111,116,101,110,116,77,111,110,111,105,100,58,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.064884755 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotentMonoid1_closure" {
     Data.Semigroup.Internal.stimesIdempotentMonoid1_closure:
         const Data.Semigroup.Internal.stimesIdempotentMonoid1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesIdempotentMonoid1_entry() //  [R1]
         { info_tbl: [(c6y0Q,
                       label: Data.Semigroup.Internal.stimesIdempotentMonoid1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y0Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6y0R; else goto c6y0S;
       c6y0R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y0S: // global
           (_c6y0L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6y0L::I64 == 0) goto c6y0N; else goto c6y0M;
       c6y0N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6y0M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6y0L::I64;
           I64[Sp - 24] = block_c6y0O_info;
           R2 = lvl4_r6v1a_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6y0O() //  [R1]
         { info_tbl: [(c6y0O,
                       label: block_c6y0O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y0O: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.067353329 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotentMonoid_closure" {
     Data.Semigroup.Internal.stimesIdempotentMonoid_closure:
         const Data.Semigroup.Internal.stimesIdempotentMonoid_info;
         const 0;
 },
 sat_s6vdE_entry() //  [R1]
         { info_tbl: [(c6y1a,
                       label: sat_s6vdE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y1a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6y1b; else goto c6y1c;
       c6y1b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y1c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6y18_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6y18() //  [R1]
         { info_tbl: [(c6y18,
                       label: block_c6y18_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y18: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesIdempotentMonoid_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(c6y1g,
                       label: Data.Semigroup.Internal.stimesIdempotentMonoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y1g: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c6y1i; else goto c6y1j;
       c6y1i: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6y1j: // global
           I64[Sp - 32] = block_c6y10_info;
           R2 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6y10() //  [R1]
         { info_tbl: [(c6y10,
                       label: block_c6y10_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y10: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6y1m; else goto c6y1l;
       c6y1m: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6y1l: // global
           I64[Hp - 16] = sat_s6vdE_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6y1h_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6y1h() //  [R1]
         { info_tbl: [(c6y1h,
                       label: block_c6y1h_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y1h: // global
           _c6y14::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6y1q_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = _c6y14::P64;
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6y1q() //  [R1]
         { info_tbl: [(c6y1q,
                       label: block_c6y1q_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y1q: // global
           _c6y1G::P64 = R1 & 7;
           if (_c6y1G::P64 < 3) goto u6y1H; else goto c6y1F;
       u6y1H: // global
           if (_c6y1G::P64 < 2) goto c6y1x; else goto c6y1B;
       c6y1x: // global
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid1_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6y1B: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
       c6y1F: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.07215058 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_go_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_go_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_go_info;
 },
 Data.Semigroup.Internal.$fSemigroupAny_go_entry() //  [R2, R3]
         { info_tbl: [(c6y1T,
                       label: Data.Semigroup.Internal.$fSemigroupAny_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y1T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6y1U; else goto u6y2f;
       c6y1U: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAny_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6y2f: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6y1J() args: 0, res: 0, upd: 0;
     }
 },
 _c6y1J() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y1J: // global
           I64[Sp - 8] = block_c6y1M_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6y2h; else goto c6y1N;
       u6y2h: // global
           call _c6y1M(R1) args: 0, res: 0, upd: 0;
       c6y1N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y1M() //  [R1]
         { info_tbl: [(c6y1M,
                       label: block_c6y1M_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y1M: // global
           _s6vdG::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6y1Q; else goto c6y1R;
       c6y1Q: // global
           R1 = _s6vdG::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6y1R: // global
           I64[Sp] = block_c6y21_info;
           _s6vdJ::P64 = P64[R1 + 6];
           _s6vdK::P64 = P64[R1 + 14];
           R1 = _s6vdG::P64;
           P64[Sp + 8] = _s6vdK::P64;
           P64[Sp + 16] = _s6vdJ::P64;
           if (R1 & 7 != 0) goto u6y2i; else goto c6y23;
       u6y2i: // global
           call _c6y21(R1) args: 0, res: 0, upd: 0;
       c6y23: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y21() //  [R1]
         { info_tbl: [(c6y21,
                       label: block_c6y21_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y21: // global
           if (R1 & 7 == 1) goto c6y29; else goto c6y2d;
       c6y29: // global
           _s6vdH::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6vdH::P64;
           Sp = Sp + 8;
           call _c6y1J() args: 0, res: 0, upd: 0;
       c6y2d: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.074562368 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAny_$csconcat_entry() //  [R2]
         { info_tbl: [(c6y2s,
                       label: Data.Semigroup.Internal.$fSemigroupAny_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y2s: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6y2t; else goto c6y2u;
       c6y2t: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6y2u: // global
           I64[Sp - 8] = block_c6y2p_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6y2y; else goto c6y2q;
       u6y2y: // global
           call _c6y2p(R1) args: 0, res: 0, upd: 0;
       c6y2q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y2p() //  [R1]
         { info_tbl: [(c6y2p,
                       label: block_c6y2p_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y2p: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupAny_go_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.076501679 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAny_go_closure" {
     Data.Semigroup.Internal.$fMonoidAny_go_closure:
         const Data.Semigroup.Internal.$fMonoidAny_go_info;
 },
 Data.Semigroup.Internal.$fMonoidAny_go_entry() //  [R2]
         { info_tbl: [(c6y2K,
                       label: Data.Semigroup.Internal.$fMonoidAny_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y2K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6y2L; else goto u6y36;
       c6y2L: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAny_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6y36: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6y2A() args: 0, res: 0, upd: 0;
     }
 },
 _c6y2A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y2A: // global
           _s6vdQ::P64 = P64[Sp];
           I64[Sp] = block_c6y2D_info;
           R1 = _s6vdQ::P64;
           if (R1 & 7 != 0) goto u6y38; else goto c6y2E;
       u6y38: // global
           call _c6y2D(R1) args: 0, res: 0, upd: 0;
       c6y2E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y2D() //  [R1]
         { info_tbl: [(c6y2D,
                       label: block_c6y2D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y2D: // global
           if (R1 & 7 == 1) goto c6y2H; else goto c6y2I;
       c6y2H: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6y2I: // global
           I64[Sp - 8] = block_c6y2S_info;
           _s6vdT::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6vdT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6y39; else goto c6y2U;
       u6y39: // global
           call _c6y2S(R1) args: 0, res: 0, upd: 0;
       c6y2U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y2S() //  [R1]
         { info_tbl: [(c6y2S,
                       label: block_c6y2S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y2S: // global
           if (R1 & 7 == 1) goto c6y30; else goto c6y34;
       c6y30: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6y2A() args: 0, res: 0, upd: 0;
       c6y34: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.079329401 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Classes.||_closure+2;
         const Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAny_closure" {
     Data.Semigroup.Internal.$fMonoidAny_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupAny_closure+1;
         const GHC.Types.False_closure+1;
         const GHC.Classes.||_closure+2;
         const Data.Semigroup.Internal.$fMonoidAny_go_closure+1;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupAny_$cstimes_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(c6y3g,
                       label: Data.Semigroup.Internal.$fSemigroupAny_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y3g: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidAny_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.081321428 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_go_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_go_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_go_info;
 },
 Data.Semigroup.Internal.$fSemigroupAll_go_entry() //  [R2, R3]
         { info_tbl: [(c6y3u,
                       label: Data.Semigroup.Internal.$fSemigroupAll_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y3u: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6y3v; else goto u6y3Q;
       c6y3v: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAll_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6y3Q: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6y3k() args: 0, res: 0, upd: 0;
     }
 },
 _c6y3k() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y3k: // global
           I64[Sp - 8] = block_c6y3n_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6y3S; else goto c6y3o;
       u6y3S: // global
           call _c6y3n(R1) args: 0, res: 0, upd: 0;
       c6y3o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y3n() //  [R1]
         { info_tbl: [(c6y3n,
                       label: block_c6y3n_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y3n: // global
           _s6vdW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6y3r; else goto c6y3s;
       c6y3r: // global
           R1 = _s6vdW::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6y3s: // global
           I64[Sp] = block_c6y3C_info;
           _s6vdZ::P64 = P64[R1 + 6];
           _s6ve0::P64 = P64[R1 + 14];
           R1 = _s6vdW::P64;
           P64[Sp + 8] = _s6ve0::P64;
           P64[Sp + 16] = _s6vdZ::P64;
           if (R1 & 7 != 0) goto u6y3T; else goto c6y3E;
       u6y3T: // global
           call _c6y3C(R1) args: 0, res: 0, upd: 0;
       c6y3E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y3C() //  [R1]
         { info_tbl: [(c6y3C,
                       label: block_c6y3C_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y3C: // global
           if (R1 & 7 == 1) goto c6y3K; else goto c6y3O;
       c6y3K: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6y3O: // global
           _s6vdX::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6vdX::P64;
           Sp = Sp + 8;
           call _c6y3k() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.083695816 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAll_$csconcat_entry() //  [R2]
         { info_tbl: [(c6y43,
                       label: Data.Semigroup.Internal.$fSemigroupAll_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y43: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6y44; else goto c6y45;
       c6y44: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6y45: // global
           I64[Sp - 8] = block_c6y40_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6y49; else goto c6y41;
       u6y49: // global
           call _c6y40(R1) args: 0, res: 0, upd: 0;
       c6y41: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y40() //  [R1]
         { info_tbl: [(c6y40,
                       label: block_c6y40_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y40: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupAll_go_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.085686124 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAll_go_closure" {
     Data.Semigroup.Internal.$fMonoidAll_go_closure:
         const Data.Semigroup.Internal.$fMonoidAll_go_info;
 },
 Data.Semigroup.Internal.$fMonoidAll_go_entry() //  [R2]
         { info_tbl: [(c6y4l,
                       label: Data.Semigroup.Internal.$fMonoidAll_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y4l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6y4m; else goto u6y4H;
       c6y4m: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAll_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6y4H: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6y4b() args: 0, res: 0, upd: 0;
     }
 },
 _c6y4b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y4b: // global
           _s6ve6::P64 = P64[Sp];
           I64[Sp] = block_c6y4e_info;
           R1 = _s6ve6::P64;
           if (R1 & 7 != 0) goto u6y4J; else goto c6y4f;
       u6y4J: // global
           call _c6y4e(R1) args: 0, res: 0, upd: 0;
       c6y4f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y4e() //  [R1]
         { info_tbl: [(c6y4e,
                       label: block_c6y4e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y4e: // global
           if (R1 & 7 == 1) goto c6y4i; else goto c6y4j;
       c6y4i: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6y4j: // global
           I64[Sp - 8] = block_c6y4t_info;
           _s6ve9::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6ve9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6y4K; else goto c6y4v;
       u6y4K: // global
           call _c6y4t(R1) args: 0, res: 0, upd: 0;
       c6y4v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y4t() //  [R1]
         { info_tbl: [(c6y4t,
                       label: block_c6y4t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y4t: // global
           if (R1 & 7 == 1) goto c6y4B; else goto c6y4F;
       c6y4B: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6y4F: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6y4b() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.087881136 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Classes.&&_closure+2;
         const Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAll_closure" {
     Data.Semigroup.Internal.$fMonoidAll_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupAll_closure+1;
         const GHC.Types.True_closure+2;
         const GHC.Classes.&&_closure+2;
         const Data.Semigroup.Internal.$fMonoidAll_go_closure+1;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupAll_$cstimes_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(c6y4R,
                       label: Data.Semigroup.Internal.$fSemigroupAll_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y4R: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidAll_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.089172346 UTC

[section ""cstring" . lvl5_r6v1b_bytes" {
     lvl5_r6v1b_bytes:
         I8[] [115,116,105,109,101,115,77,111,110,111,105,100,58,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.090033179 UTC

[section ""data" . lvl6_r6v1c_closure" {
     lvl6_r6v1c_closure:
         const lvl6_r6v1c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r6v1c_entry() //  [R1]
         { info_tbl: [(c6y52,
                       label: lvl6_r6v1c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y52: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6y53; else goto c6y54;
       c6y53: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y54: // global
           (_c6y4X::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6y4X::I64 == 0) goto c6y4Z; else goto c6y4Y;
       c6y4Z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6y4Y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6y4X::I64;
           I64[Sp - 24] = block_c6y50_info;
           R2 = lvl5_r6v1b_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6y50() //  [R1]
         { info_tbl: [(c6y50,
                       label: block_c6y50_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y50: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.091063186 UTC

[section ""data" . sat_s6ved_closure" {
     sat_s6ved_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.091655645 UTC

[section ""data" . sat_s6vee_closure" {
     sat_s6vee_closure:
         const :_con_info;
         const sat_s6ved_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.092429796 UTC

[section ""data" . lvl7_r6v1d_closure" {
     lvl7_r6v1d_closure:
         const lvl7_r6v1d_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r6v1d_entry() //  [R1]
         { info_tbl: [(c6y5e,
                       label: lvl7_r6v1d_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y5e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6y5f; else goto c6y5g;
       c6y5f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y5g: // global
           (_c6y5b::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6y5b::I64 == 0) goto c6y5d; else goto c6y5c;
       c6y5d: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6y5c: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6y5b::I64;
           R3 = sat_s6vee_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.097162333 UTC

[section ""data" . Data.Semigroup.Internal.stimesMonoid_closure" {
     Data.Semigroup.Internal.stimesMonoid_closure:
         const Data.Semigroup.Internal.stimesMonoid_info;
         const 0;
 },
 sat_s6vem_entry() //  [R1]
         { info_tbl: [(c6y6I,
                       label: sat_s6vem_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y6I: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6y6J; else goto c6y6K;
       c6y6J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y6K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6y6G_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6y6G() //  [R1]
         { info_tbl: [(c6y6G,
                       label: block_c6y6G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y6G: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s6veo_entry() //  [R1]
         { info_tbl: [(c6y6Q,
                       label: $dNum_s6veo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y6Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6y6R; else goto c6y6S;
       c6y6R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y6S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_s6vep_entry() //  [R1]
         { info_tbl: [(c6y6V,
                       label: lvl12_s6vep_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y6V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6y6W; else goto c6y6X;
       c6y6W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y6X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl7_r6v1d_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6vev_entry() //  [R1]
         { info_tbl: [(c6y70,
                       label: lvl13_s6vev_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y70: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6y71; else goto c6y72;
       c6y71: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y72: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6veM_entry() //  [R1]
         { info_tbl: [(c6y75,
                       label: sat_s6veM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y75: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y76; else goto c6y77;
       c6y76: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y77: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veL_entry() //  [R1]
         { info_tbl: [(c6y7a,
                       label: sat_s6veL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y7a: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y7b; else goto c6y7c;
       c6y7b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y7c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6ver::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6ver::P64;
           P64[Sp - 24] = _s6ver::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veI_entry() //  [R1]
         { info_tbl: [(c6y7f,
                       label: sat_s6veI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y7f: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y7g; else goto c6y7h;
       c6y7g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y7h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veH_entry() //  [R1]
         { info_tbl: [(c6y7k,
                       label: sat_s6veH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y7k: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y7l; else goto c6y7m;
       c6y7l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y7m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veG_entry() //  [R1]
         { info_tbl: [(c6y7q,
                       label: sat_s6veG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y7q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y7r; else goto c6y7s;
       c6y7r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y7s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6veB::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6veB::P64;
           P64[Sp - 24] = _s6veB::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veK_entry() //  [R1]
         { info_tbl: [(c6y7v,
                       label: sat_s6veK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y7v: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y7w; else goto c6y7x;
       c6y7w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y7x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veJ_entry() //  [R1]
         { info_tbl: [(c6y7B,
                       label: sat_s6veJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y7B: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y7C; else goto c6y7D;
       c6y7C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y7D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6veB::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6veB::P64;
           P64[Sp - 24] = _s6veB::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veS_entry() //  [R1]
         { info_tbl: [(c6y7G,
                       label: sat_s6veS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y7G: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y7H; else goto c6y7I;
       c6y7H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y7I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veR_entry() //  [R1]
         { info_tbl: [(c6y7M,
                       label: sat_s6veR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y7M: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6y7N; else goto c6y7O;
       c6y7N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6y7O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6veO::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6veO::P64;
           P64[Sp - 24] = _s6veO::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesMonoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6y7P,
                       label: Data.Semigroup.Internal.stimesMonoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y7P: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c6y7Q; else goto c6y7R;
       c6y7Q: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMonoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6y7R: // global
           I64[Sp - 40] = block_c6y5l_info;
           _s6vef::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s6vef::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6y5l() //  [R1]
         { info_tbl: [(c6y5l,
                       label: block_c6y5l_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y5l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6y7U; else goto c6y7T;
       c6y7U: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6y7T: // global
           I64[Hp - 16] = sat_s6vem_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c6y5r_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6y5r() //  [R1]
         { info_tbl: [(c6y5r,
                       label: block_c6y5r_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y5r: // global
           I64[Sp] = block_c6y5v_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6y5v() //  [R1]
         { info_tbl: [(c6y5v,
                       label: block_c6y5v_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y5v: // global
           _c6y8P::P64 = R1 & 7;
           if (_c6y8P::P64 < 3) goto u6y8U; else goto c6y83;
       u6y8U: // global
           if (_c6y8P::P64 < 2) goto c6y7Z; else goto c6y82;
       c6y7Z: // global
           R1 = lvl6_r6v1c_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6y82: // global
           R2 = P64[Sp + 32];
           Sp = Sp + 56;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
       c6y83: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6y86; else goto c6y85;
       c6y86: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6y85: // global
           I64[Hp - 40] = $dNum_s6veo_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = lvl12_s6vep_info;
           _c6y5B::P64 = Hp - 40;
           P64[Hp] = _c6y5B::P64;
           P64[Sp] = P64[Sp + 40];
           P64[Sp + 16] = P64[Sp + 48];
           P64[Sp + 40] = Hp - 16;
           P64[Sp + 48] = _c6y5B::P64;
           call _c6y6u() args: 0, res: 0, upd: 0;
     }
 },
 _c6y6u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y6u: // global
           I64[Sp - 8] = block_c6y6w_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6y6w() //  [R1]
         { info_tbl: [(c6y6w,
                       label: block_c6y6w_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y6w: // global
           _s6veO::P64 = P64[Sp + 24];
           _s6veP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6y8K; else goto c6y8L;
       c6y8K: // global
           I64[Sp + 8] = block_c6y5K_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s6veP::P64;
           P64[Sp + 24] = _s6veO::P64;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c6y8L: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6y8O; else goto c6y8N;
       c6y8O: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6y8N: // global
           I64[Hp - 64] = sat_s6veS_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s6veP::P64;
           I64[Hp - 24] = sat_s6veR_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6veO::P64;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c6y6u() args: 0, res: 0, upd: 0;
     }
 },
 _c6y5K() //  [R1]
         { info_tbl: [(c6y5K,
                       label: block_c6y5K_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y5K: // global
           I64[Sp] = block_c6y5O_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6y5O() //  [R1]
         { info_tbl: [(c6y5O,
                       label: block_c6y5O_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y5O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6y8b; else goto c6y8a;
       c6y8b: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6y8a: // global
           I64[Hp - 16] = lvl13_s6vev_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp - 8] = block_c6y5U_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c6y5S::P64 = Hp - 16;
           P64[Sp - 16] = _c6y5S::P64;
           P64[Sp] = R1;
           P64[Sp + 48] = _c6y5S::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6y5U() //  [R1]
         { info_tbl: [(c6y5U,
                       label: block_c6y5U_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y5U: // global
           _s6ver::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6y8d; else goto c6y8F;
       c6y8d: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6y8g; else goto c6y8f;
       c6y8g: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6y8f: // global
           I64[Hp - 64] = sat_s6veM_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s6veL_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6ver::P64;
           P64[Sp] = _s6ver::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 24] = Hp - 24;
           call _c6y67() args: 0, res: 0, upd: 0;
       c6y8F: // global
           R1 = _s6ver::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6y67() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y67: // global
           I64[Sp - 8] = block_c6y69_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6y69() //  [R1]
         { info_tbl: [(c6y69,
                       label: block_c6y69_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y69: // global
           _s6veC::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6y8o; else goto c6y8y;
       c6y8o: // global
           I64[Sp] = block_c6y6d_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s6veC::P64;
           P64[Sp - 8] = P64[Sp + 64];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c6y8y: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6y8B; else goto c6y8A;
       c6y8B: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6y8A: // global
           I64[Hp - 64] = sat_s6veK_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s6veC::P64;
           I64[Hp - 24] = sat_s6veJ_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6y67() args: 0, res: 0, upd: 0;
     }
 },
 _c6y6d() //  [R1]
         { info_tbl: [(c6y6d,
                       label: block_c6y6d_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y6d: // global
           _s6veg::P64 = P64[Sp + 48];
           _s6veB::P64 = P64[Sp + 32];
           _s6veD::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6y8q; else goto c6y8x;
       c6y8q: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c6y8t; else goto c6y8s;
       c6y8t: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6y8s: // global
           I64[Hp - 104] = sat_s6veI_info;
           P64[Hp - 88] = _s6veg::P64;
           P64[Hp - 80] = _s6veB::P64;
           P64[Hp - 72] = _s6veD::P64;
           I64[Hp - 64] = sat_s6veH_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s6veG_info;
           P64[Hp - 8] = _s6veg::P64;
           P64[Hp] = _s6veB::P64;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c6y67() args: 0, res: 0, upd: 0;
       c6y8x: // global
           R2 = _s6veg::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s6veB::P64;
           P64[Sp + 64] = _s6veD::P64;
           Sp = Sp + 48;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.107013061 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat_closure" {
     Data.Semigroup.Internal.$w$csconcat_closure:
         const Data.Semigroup.Internal.$w$csconcat_info;
 },
 go_s6veW_entry() //  [R1, R2, R3]
         { info_tbl: [(c6y9l,
                       label: go_s6veW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y9l: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6y9m; else goto c6y9n;
       c6y9m: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6y9n: // global
           I64[Sp - 32] = block_c6y9e_info;
           _s6veW::P64 = R1;
           _s6veT::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6veT::P64;
           P64[Sp - 16] = _s6veW::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6y9x; else goto c6y9f;
       u6y9x: // global
           call _c6y9e(R1) args: 0, res: 0, upd: 0;
       c6y9f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y9e() //  [R1]
         { info_tbl: [(c6y9e,
                       label: block_c6y9e_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y9e: // global
           _s6veX::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6y9i; else goto c6y9j;
       c6y9i: // global
           R1 = _s6veX::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6y9j: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6y9v; else goto c6y9u;
       c6y9v: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6y9u: // global
           _s6vf0::P64 = P64[R1 + 6];
           _s6vf1::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6vf0::P64;
           P64[Hp] = _s6vf1::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6veX::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c6y9y,
                       label: Data.Semigroup.Internal.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y9y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6y9C; else goto c6y9B;
       c6y9C: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6y9B: // global
           I64[Hp - 8] = go_s6veW_info;
           P64[Hp] = R2;
           _s6veU::P64 = R3;
           R3 = R4;
           R2 = _s6veU::P64;
           R1 = Hp - 6;
           call go_s6veW_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.108884973 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c6y9K,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y9K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6y9L; else goto c6y9M;
       c6y9L: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6y9M: // global
           I64[Sp - 16] = block_c6y9H_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6y9Q; else goto c6y9I;
       u6y9Q: // global
           call _c6y9H(R1) args: 0, res: 0, upd: 0;
       c6y9I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6y9H() //  [R1]
         { info_tbl: [(c6y9H,
                       label: block_c6y9H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y9H: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.11066525 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_info;
 },
 z_s6vfa_entry() //  [R1]
         { info_tbl: [(c6y9Z,
                       label: z_s6vfa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6y9Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ya0; else goto c6ya1;
       c6ya0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ya1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s6vfb_entry() //  [R1, R2]
         { info_tbl: [(c6yae,
                       label: go_s6vfb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yae: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yaf; else goto c6yag;
       c6yaf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yag: // global
           I64[Sp - 32] = block_c6ya7_info;
           _s6vfb::P64 = R1;
           _s6vf8::P64 = P64[R1 + 7];
           _s6vfa::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6vf8::P64;
           P64[Sp - 16] = _s6vfa::P64;
           P64[Sp - 8] = _s6vfb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6yaq; else goto c6ya8;
       u6yaq: // global
           call _c6ya7(R1) args: 0, res: 0, upd: 0;
       c6ya8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ya7() //  [R1]
         { info_tbl: [(c6ya7,
                       label: block_c6ya7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ya7: // global
           if (R1 & 7 == 1) goto c6yab; else goto c6yac;
       c6yab: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6yac: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yao; else goto c6yan;
       c6yao: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yan: // global
           _s6vfe::P64 = P64[R1 + 6];
           _s6vff::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6vff::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6vfe::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c6yar,
                       label: Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yar: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6yav; else goto c6yau;
       c6yav: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yau: // global
           I64[Hp - 40] = z_s6vfa_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6vfb_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s6vfb_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.113746107 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_info;
         const 0;
 },
 sat_s6vfk_entry() //  [R1, R2]
         { info_tbl: [(c6yaF,
                       label: sat_s6vfk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yaF: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vfj_entry() //  [R1, R2]
         { info_tbl: [(c6yaN,
                       label: sat_s6vfj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yaN: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vfi_entry() //  [R1]
         { info_tbl: [(c6yaU,
                       label: sat_s6vfi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yaU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yaV; else goto c6yaW;
       c6yaV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yaW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupAlt_entry() //  [R2]
         { info_tbl: [(c6yaY,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yaY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6yb2; else goto c6yb1;
       c6yb2: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yb1: // global
           I64[Hp - 80] = sat_s6vfk_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6vfj_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6vfi_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAlt_closure" {
     Data.Semigroup.Internal.$fMonoidAlt_closure:
         const Data.Semigroup.Internal.$fMonoidAlt_info;
         const 0;
 },
 sat_s6vfp_entry() //  [R1, R2]
         { info_tbl: [(c6ybc,
                       label: sat_s6vfp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ybc: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vfo_entry() //  [R1]
         { info_tbl: [(c6ybj,
                       label: sat_s6vfo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ybj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ybk; else goto c6ybl;
       c6ybk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ybl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vfn_entry() //  [R1]
         { info_tbl: [(c6ybq,
                       label: sat_s6vfn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ybq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ybr; else goto c6ybs;
       c6ybr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ybs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vfm_entry() //  [R1]
         { info_tbl: [(c6ybx,
                       label: sat_s6vfm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ybx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yby; else goto c6ybz;
       c6yby: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ybz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupAlt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidAlt_entry() //  [R2]
         { info_tbl: [(c6ybB,
                       label: Data.Semigroup.Internal.$fMonoidAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ybB: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c6ybF; else goto c6ybE;
       c6ybF: // global
           HpAlloc = 128;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ybE: // global
           I64[Hp - 120] = sat_s6vfp_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6vfo_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6vfn_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6vfm_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 119;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_info;
         const 0;
 },
 sat_s6vfs_entry() //  [R1]
         { info_tbl: [(c6ybO,
                       label: sat_s6vfs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ybO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ybP; else goto c6ybQ;
       c6ybP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ybQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidAlt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c6ybR,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ybR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ybV; else goto c6ybU;
       c6ybV: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ybU: // global
           I64[Hp - 16] = sat_s6vfs_info;
           P64[Hp] = R2;
           _s6vfr::P64 = R3;
           R3 = Hp - 16;
           R2 = _s6vfr::P64;
           R1 = Data.Semigroup.Internal.stimesMonoid_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.117542275 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo1_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo1_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo1_info;
 },
 g_s6vfy_entry() //  [R1]
         { info_tbl: [(c6yca,
                       label: g_s6vfy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yca: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ycb; else goto c6ycc;
       c6ycb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ycc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupEndo1_entry(R3,
                                                               R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vfB_entry() //  [R1, R2]
         { info_tbl: [(c6ycj,
                       label: sat_s6vfB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ycj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6ycn; else goto c6ycm;
       c6ycn: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ycm: // global
           _s6vft::P64 = P64[R1 + 7];
           _s6vfy::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s6vfy::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _s6vft::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fSemigroupEndo1_entry() //  [R2, R3]
         { info_tbl: [(c6ycs,
                       label: Data.Semigroup.Internal.$fSemigroupEndo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ycs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yct; else goto c6ycu;
       c6yct: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupEndo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ycu: // global
           I64[Sp - 16] = block_c6yc0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6ycA; else goto c6yc1;
       u6ycA: // global
           call _c6yc0(R1) args: 0, res: 0, upd: 0;
       c6yc1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6yc0() //  [R1]
         { info_tbl: [(c6yc0,
                       label: block_c6yc0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yc0: // global
           _s6vft::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6ycp; else goto c6ycq;
       c6ycp: // global
           R1 = _s6vft::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6ycq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6ycz; else goto c6ycy;
       c6ycz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ycy: // global
           _s6vfw::P64 = P64[R1 + 6];
           _s6vfx::P64 = P64[R1 + 14];
           I64[Hp - 48] = g_s6vfy_info;
           P64[Hp - 32] = _s6vfw::P64;
           P64[Hp - 24] = _s6vfx::P64;
           I64[Hp - 16] = sat_s6vfB_info;
           P64[Hp - 8] = _s6vft::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.119455433 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_entry() //  [R2]
         { info_tbl: [(c6ycI,
                       label: Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ycI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6ycJ; else goto c6ycK;
       c6ycJ: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ycK: // global
           I64[Sp - 8] = block_c6ycF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6ycO; else goto c6ycG;
       u6ycO: // global
           call _c6ycF(R1) args: 0, res: 0, upd: 0;
       c6ycG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ycF() //  [R1]
         { info_tbl: [(c6ycF,
                       label: block_c6ycF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ycF: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupEndo1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.12090603 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidEndo1_closure" {
     Data.Semigroup.Internal.$fMonoidEndo1_closure:
         const Data.Semigroup.Internal.$fMonoidEndo1_info;
 },
 sat_s6vfL_entry() //  [R1]
         { info_tbl: [(c6yd3,
                       label: sat_s6vfL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yd3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yd4; else goto c6yd5;
       c6yd4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yd5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidEndo1_entry(R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidEndo1_entry() //  [R2, R3]
         { info_tbl: [(c6yda,
                       label: Data.Semigroup.Internal.$fMonoidEndo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yda: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ydb; else goto c6ydc;
       c6ydb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidEndo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ydc: // global
           I64[Sp - 16] = block_c6ycT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6ydi; else goto c6ycU;
       u6ydi: // global
           call _c6ycT(R1) args: 0, res: 0, upd: 0;
       c6ycU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ycT() //  [R1]
         { info_tbl: [(c6ycT,
                       label: block_c6ycT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ycT: // global
           _s6vfH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6yd7; else goto c6yd8;
       c6yd7: // global
           R1 = _s6vfH::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6yd8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6ydh; else goto c6ydg;
       c6ydh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ydg: // global
           _s6vfJ::P64 = P64[R1 + 6];
           _s6vfK::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s6vfL_info;
           P64[Hp - 8] = _s6vfH::P64;
           P64[Hp] = _s6vfK::P64;
           R2 = Hp - 24;
           R1 = _s6vfJ::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.122475884 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.._closure+3;
         const Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidEndo_closure" {
     Data.Semigroup.Internal.$fMonoidEndo_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupEndo_closure+1;
         const GHC.Base.id_closure+1;
         const GHC.Base.._closure+3;
         const Data.Semigroup.Internal.$fMonoidEndo1_closure+2;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c6ydn,
                       label: Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ydn: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidEndo_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesMonoid_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.123408016 UTC

[section ""cstring" . lvl8_r6v1e_bytes" {
     lvl8_r6v1e_bytes:
         I8[] [115,116,105,109,101,115,58,32,112,111,115,105,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114,32,101,120,112,101,99,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.124201464 UTC

[section ""data" . lvl9_r6v1f_closure" {
     lvl9_r6v1f_closure:
         const lvl9_r6v1f_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r6v1f_entry() //  [R1]
         { info_tbl: [(c6ydy,
                       label: lvl9_r6v1f_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ydy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6ydz; else goto c6ydA;
       c6ydz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ydA: // global
           (_c6ydt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6ydt::I64 == 0) goto c6ydv; else goto c6ydu;
       c6ydv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6ydu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6ydt::I64;
           I64[Sp - 24] = block_c6ydw_info;
           R2 = lvl8_r6v1e_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6ydw() //  [R1]
         { info_tbl: [(c6ydw,
                       label: block_c6ydw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ydw: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.128709888 UTC

[section ""data" . Data.Semigroup.Internal.stimesDefault_closure" {
     Data.Semigroup.Internal.stimesDefault_closure:
         const Data.Semigroup.Internal.stimesDefault_info;
         const 0;
 },
 sat_s6vfV_entry() //  [R1]
         { info_tbl: [(c6yf3,
                       label: sat_s6vfV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yf3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yf4; else goto c6yf5;
       c6yf4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yf5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6yf1_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6yf1() //  [R1]
         { info_tbl: [(c6yf1,
                       label: block_c6yf1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yf1: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s6vfX_entry() //  [R1]
         { info_tbl: [(c6yfb,
                       label: $dNum_s6vfX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yfb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yfc; else goto c6yfd;
       c6yfc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yfd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_s6vfY_entry() //  [R1]
         { info_tbl: [(c6yfg,
                       label: lvl12_s6vfY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yfg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yfh; else goto c6yfi;
       c6yfh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yfi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl7_r6v1d_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6vg4_entry() //  [R1]
         { info_tbl: [(c6yfl,
                       label: lvl13_s6vg4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yfl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yfm; else goto c6yfn;
       c6yfm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yfn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6vgl_entry() //  [R1]
         { info_tbl: [(c6yfq,
                       label: sat_s6vgl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yfq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yfr; else goto c6yfs;
       c6yfr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yfs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgk_entry() //  [R1]
         { info_tbl: [(c6yfv,
                       label: sat_s6vgk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yfv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yfw; else goto c6yfx;
       c6yfw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yfx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vg0::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vg0::P64;
           P64[Sp - 24] = _s6vg0::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgh_entry() //  [R1]
         { info_tbl: [(c6yfA,
                       label: sat_s6vgh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yfA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yfB; else goto c6yfC;
       c6yfB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yfC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgg_entry() //  [R1]
         { info_tbl: [(c6yfF,
                       label: sat_s6vgg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yfF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yfG; else goto c6yfH;
       c6yfG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yfH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgf_entry() //  [R1]
         { info_tbl: [(c6yfL,
                       label: sat_s6vgf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yfL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yfM; else goto c6yfN;
       c6yfM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yfN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vga::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vga::P64;
           P64[Sp - 24] = _s6vga::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgj_entry() //  [R1]
         { info_tbl: [(c6yfQ,
                       label: sat_s6vgj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yfQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yfR; else goto c6yfS;
       c6yfR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yfS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgi_entry() //  [R1]
         { info_tbl: [(c6yfW,
                       label: sat_s6vgi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yfW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yfX; else goto c6yfY;
       c6yfX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yfY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vga::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vga::P64;
           P64[Sp - 24] = _s6vga::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgr_entry() //  [R1]
         { info_tbl: [(c6yg1,
                       label: sat_s6vgr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yg1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yg2; else goto c6yg3;
       c6yg2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yg3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgq_entry() //  [R1]
         { info_tbl: [(c6yg7,
                       label: sat_s6vgq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yg7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yg8; else goto c6yg9;
       c6yg8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yg9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vgn::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vgn::P64;
           P64[Sp - 24] = _s6vgn::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesDefault_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6yga,
                       label: Data.Semigroup.Internal.stimesDefault_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yga: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c6ygb; else goto c6ygc;
       c6ygb: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ygc: // global
           I64[Sp - 40] = block_c6ydI_info;
           _s6vfO::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s6vfO::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ydI() //  [R1]
         { info_tbl: [(c6ydI,
                       label: block_c6ydI_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ydI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ygf; else goto c6yge;
       c6ygf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yge: // global
           I64[Hp - 16] = sat_s6vfV_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c6ydO_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ydO() //  [R1]
         { info_tbl: [(c6ydO,
                       label: block_c6ydO_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ydO: // global
           I64[Sp] = block_c6ydS_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6ydS() //  [R1]
         { info_tbl: [(c6ydS,
                       label: block_c6ydS_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ydS: // global
           if (R1 & 7 == 1) goto c6ygi; else goto c6yh7;
       c6ygi: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6ygl; else goto c6ygk;
       c6ygl: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ygk: // global
           I64[Hp - 40] = $dNum_s6vfX_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = lvl12_s6vfY_info;
           _c6ydW::P64 = Hp - 40;
           P64[Hp] = _c6ydW::P64;
           P64[Sp] = P64[Sp + 40];
           P64[Sp + 16] = P64[Sp + 48];
           P64[Sp + 40] = Hp - 16;
           P64[Sp + 48] = _c6ydW::P64;
           call _c6yeP() args: 0, res: 0, upd: 0;
       c6yh7: // global
           R1 = lvl9_r6v1f_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6yeP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yeP: // global
           I64[Sp - 8] = block_c6yeR_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6yeR() //  [R1]
         { info_tbl: [(c6yeR,
                       label: block_c6yeR_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yeR: // global
           _s6vgn::P64 = P64[Sp + 24];
           _s6vgo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6ygZ; else goto c6yh0;
       c6ygZ: // global
           I64[Sp + 8] = block_c6ye5_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s6vgo::P64;
           P64[Sp + 24] = _s6vgn::P64;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c6yh0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6yh3; else goto c6yh2;
       c6yh3: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yh2: // global
           I64[Hp - 64] = sat_s6vgr_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s6vgo::P64;
           I64[Hp - 24] = sat_s6vgq_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6vgn::P64;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c6yeP() args: 0, res: 0, upd: 0;
     }
 },
 _c6ye5() //  [R1]
         { info_tbl: [(c6ye5,
                       label: block_c6ye5_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ye5: // global
           I64[Sp] = block_c6ye9_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ye9() //  [R1]
         { info_tbl: [(c6ye9,
                       label: block_c6ye9_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ye9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ygq; else goto c6ygp;
       c6ygq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ygp: // global
           I64[Hp - 16] = lvl13_s6vg4_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp - 8] = block_c6yef_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c6yed::P64 = Hp - 16;
           P64[Sp - 16] = _c6yed::P64;
           P64[Sp] = R1;
           P64[Sp + 48] = _c6yed::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6yef() //  [R1]
         { info_tbl: [(c6yef,
                       label: block_c6yef_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yef: // global
           _s6vg0::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6ygs; else goto c6ygU;
       c6ygs: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6ygv; else goto c6ygu;
       c6ygv: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ygu: // global
           I64[Hp - 64] = sat_s6vgl_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s6vgk_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6vg0::P64;
           P64[Sp] = _s6vg0::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 24] = Hp - 24;
           call _c6yes() args: 0, res: 0, upd: 0;
       c6ygU: // global
           R1 = _s6vg0::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6yes() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yes: // global
           I64[Sp - 8] = block_c6yeu_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6yeu() //  [R1]
         { info_tbl: [(c6yeu,
                       label: block_c6yeu_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yeu: // global
           _s6vgb::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6ygD; else goto c6ygN;
       c6ygD: // global
           I64[Sp] = block_c6yey_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s6vgb::P64;
           P64[Sp - 8] = P64[Sp + 64];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c6ygN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6ygQ; else goto c6ygP;
       c6ygQ: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ygP: // global
           I64[Hp - 64] = sat_s6vgj_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s6vgb::P64;
           I64[Hp - 24] = sat_s6vgi_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6yes() args: 0, res: 0, upd: 0;
     }
 },
 _c6yey() //  [R1]
         { info_tbl: [(c6yey,
                       label: block_c6yey_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yey: // global
           _s6vfP::P64 = P64[Sp + 48];
           _s6vga::P64 = P64[Sp + 32];
           _s6vgc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6ygF; else goto c6ygM;
       c6ygF: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c6ygI; else goto c6ygH;
       c6ygI: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ygH: // global
           I64[Hp - 104] = sat_s6vgh_info;
           P64[Hp - 88] = _s6vfP::P64;
           P64[Hp - 80] = _s6vga::P64;
           P64[Hp - 72] = _s6vgc::P64;
           I64[Hp - 64] = sat_s6vgg_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s6vgf_info;
           P64[Hp - 8] = _s6vfP::P64;
           P64[Hp] = _s6vga::P64;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c6yes() args: 0, res: 0, upd: 0;
       c6ygM: // global
           R2 = _s6vfP::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s6vga::P64;
           P64[Sp + 64] = _s6vgc::P64;
           Sp = Sp + 48;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.141567174 UTC

[section ""cstring" . lvl10_r6v1g_bytes" {
     lvl10_r6v1g_bytes:
         I8[] [115,116,105,109,101,115,58,32,77,97,121,98,101,44,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.142830833 UTC

[section ""data" . Data.Semigroup.Internal.stimesMaybe1_closure" {
     Data.Semigroup.Internal.stimesMaybe1_closure:
         const Data.Semigroup.Internal.stimesMaybe1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesMaybe1_entry() //  [R1]
         { info_tbl: [(c6yhv,
                       label: Data.Semigroup.Internal.stimesMaybe1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yhv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6yhw; else goto c6yhx;
       c6yhw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yhx: // global
           (_c6yhq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6yhq::I64 == 0) goto c6yhs; else goto c6yhr;
       c6yhs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6yhr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6yhq::I64;
           I64[Sp - 24] = block_c6yht_info;
           R2 = lvl10_r6v1g_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6yht() //  [R1]
         { info_tbl: [(c6yht,
                       label: block_c6yht_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yht: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.145869814 UTC

[section ""data" . Data.Semigroup.Internal.stimesMaybe_closure" {
     Data.Semigroup.Internal.stimesMaybe_closure:
         const Data.Semigroup.Internal.stimesMaybe_info;
         const 0;
 },
 sat_s6vgC_entry() //  [R1]
         { info_tbl: [(c6yhV,
                       label: sat_s6vgC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yhV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yhW; else goto c6yhX;
       c6yhW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yhX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6yhT_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6yhT() //  [R1]
         { info_tbl: [(c6yhT,
                       label: block_c6yhT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yhT: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6vgE_entry() //  [R1]
         { info_tbl: [(c6yif,
                       label: sat_s6vgE_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yif: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6yig; else goto c6yih;
       c6yig: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yih: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesMaybe_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6yim,
                       label: Data.Semigroup.Internal.stimesMaybe_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yim: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c6yin; else goto c6yio;
       c6yin: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMaybe_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yio: // global
           I64[Sp - 32] = block_c6yhF_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6yiO; else goto c6yhG;
       u6yiO: // global
           call _c6yhF(R1) args: 0, res: 0, upd: 0;
       c6yhG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6yhF() //  [R1]
         { info_tbl: [(c6yhF,
                       label: block_c6yhF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yhF: // global
           if (R1 & 7 == 1) goto u6yiK; else goto c6yik;
       u6yiK: // global
           Sp = Sp + 32;
           call _c6yiC() args: 0, res: 0, upd: 0;
       c6yik: // global
           I64[Sp - 8] = block_c6yhL_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6yhL() //  [R1]
         { info_tbl: [(c6yhL,
                       label: block_c6yhL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yhL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yiu; else goto c6yit;
       c6yiu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yit: // global
           I64[Hp - 16] = sat_s6vgC_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6yi1_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6yi1() //  [R1]
         { info_tbl: [(c6yi1,
                       label: block_c6yi1_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yi1: // global
           _c6yhP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6yi5_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = _c6yhP::P64;
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6yi5() //  [R1]
         { info_tbl: [(c6yi5,
                       label: block_c6yi5_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yi5: // global
           _c6yiI::P64 = R1 & 7;
           if (_c6yiI::P64 < 3) goto u6yiJ; else goto c6yiE;
       u6yiJ: // global
           if (_c6yiI::P64 < 2) goto c6yiz; else goto u6yiL;
       c6yiz: // global
           R1 = Data.Semigroup.Internal.stimesMaybe1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u6yiL: // global
           Sp = Sp + 40;
           call _c6yiC() args: 0, res: 0, upd: 0;
       c6yiE: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c6yiH; else goto c6yiG;
       c6yiH: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yiG: // global
           I64[Hp - 56] = sat_s6vgE_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6yiC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yiC: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.150085914 UTC

[section ""cstring" . lvl11_r6v1h_bytes" {
     lvl11_r6v1h_bytes:
         I8[] [115,116,105,109,101,115,58,32,91,93,44,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.151217585 UTC

[section ""data" . Data.Semigroup.Internal.stimesList1_closure" {
     Data.Semigroup.Internal.stimesList1_closure:
         const Data.Semigroup.Internal.stimesList1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesList1_entry() //  [R1]
         { info_tbl: [(c6yiX,
                       label: Data.Semigroup.Internal.stimesList1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yiX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6yiY; else goto c6yiZ;
       c6yiY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yiZ: // global
           (_c6yiS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6yiS::I64 == 0) goto c6yiU; else goto c6yiT;
       c6yiU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6yiT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6yiS::I64;
           I64[Sp - 24] = block_c6yiV_info;
           R2 = lvl11_r6v1h_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6yiV() //  [R1]
         { info_tbl: [(c6yiV,
                       label: block_c6yiV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yiV: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.155137687 UTC

[section ""data" . Data.Semigroup.Internal.stimesList_closure" {
     Data.Semigroup.Internal.stimesList_closure:
         const Data.Semigroup.Internal.stimesList_info;
         const 0;
 },
 $dNum_s6vgK_entry() //  [R1]
         { info_tbl: [(c6yjf,
                       label: $dNum_s6vgK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yjf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yjg; else goto c6yjh;
       c6yjg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yjh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vgM_entry() //  [R1]
         { info_tbl: [(c6yjq,
                       label: sat_s6vgM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yjq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yjr; else goto c6yjs;
       c6yjr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yjs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl12_s6vgO_entry() //  [R1]
         { info_tbl: [(c6yjB,
                       label: lvl12_s6vgO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yjB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yjC; else goto c6yjD;
       c6yjC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yjD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6vgP_entry() //  [R1]
         { info_tbl: [(c6yjI,
                       label: lvl13_s6vgP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yjI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yjJ; else goto c6yjK;
       c6yjJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yjK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6vgU_entry() //  [R1]
         { info_tbl: [(c6yk6,
                       label: sat_s6vgU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yk6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yk7; else goto c6yk8;
       c6yk7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yk8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgV_entry() //  [R1]
         { info_tbl: [(c6yk9,
                       label: sat_s6vgV_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yk9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6ykd; else goto c6ykc;
       c6ykd: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ykc: // global
           _s6vgK::P64 = P64[R1 + 16];
           _s6vgO::P64 = P64[R1 + 24];
           _s6vgR::P64 = P64[R1 + 32];
           _s6vgS::P64 = P64[R1 + 40];
           I64[Hp - 32] = sat_s6vgU_info;
           P64[Hp - 16] = _s6vgK::P64;
           P64[Hp - 8] = _s6vgO::P64;
           P64[Hp] = _s6vgS::P64;
           R2 = Hp - 32;
           R1 = _s6vgR::P64;
           call rep_s6vgR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 rep_s6vgR_entry() //  [R1, R2]
         { info_tbl: [(c6yki,
                       label: rep_s6vgR_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yki: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c6ykj; else goto c6ykk;
       c6ykj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ykk: // global
           I64[Sp - 48] = block_c6yjU_info;
           _s6vgS::P64 = R2;
           R2 = P64[R1 + 39];
           I64[Sp - 72] = stg_ap_pp_info;
           P64[Sp - 64] = _s6vgS::P64;
           P64[Sp - 56] = P64[R1 + 31];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s6vgS::P64;
           Sp = Sp - 72;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6yjU() //  [R1]
         { info_tbl: [(c6yjU,
                       label: block_c6yjU_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yjU: // global
           if (R1 & 7 == 1) goto c6ykf; else goto c6ykg;
       c6ykf: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6ykn; else goto c6ykm;
       c6ykn: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ykm: // global
           I64[Hp - 40] = sat_s6vgV_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 40;
           R2 = P64[Sp + 8];
           Sp = Sp + 48;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6ykg: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.stimesList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6ykr,
                       label: Data.Semigroup.Internal.stimesList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ykr: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c6yks; else goto c6ykt;
       c6yks: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ykt: // global
           I64[Sp - 24] = block_c6yj7_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6yj7() //  [R1]
         { info_tbl: [(c6yj7,
                       label: block_c6yj7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yj7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ykw; else goto c6ykv;
       c6ykw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ykv: // global
           I64[Hp - 16] = $dNum_s6vgK_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6yji_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6yji() //  [R1]
         { info_tbl: [(c6yji,
                       label: block_c6yji_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yji: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ykz; else goto c6yky;
       c6ykz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yky: // global
           I64[Hp - 16] = sat_s6vgM_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c6yjt_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6yjt() //  [R1]
         { info_tbl: [(c6yjt,
                       label: block_c6yjt_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yjt: // global
           if (R1 & 7 == 1) goto c6ykB; else goto c6ykL;
       c6ykB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6ykE; else goto c6ykD;
       c6ykE: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ykD: // global
           I64[Hp - 40] = lvl12_s6vgO_info;
           _c6yjb::P64 = P64[Sp + 16];
           P64[Hp - 24] = _c6yjb::P64;
           I64[Hp - 16] = lvl13_s6vgP_info;
           P64[Hp] = _c6yjb::P64;
           I64[Sp - 8] = block_c6yjL_info;
           R2 = P64[Sp + 8];
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = Hp - 40;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c6ykL: // global
           R1 = Data.Semigroup.Internal.stimesList1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6yjL() //  [R1]
         { info_tbl: [(c6yjL,
                       label: block_c6yjL_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yjL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6ykH; else goto c6ykG;
       c6ykH: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ykG: // global
           I64[Hp - 40] = rep_s6vgR_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 39;
           Sp = Sp + 48;
           call rep_s6vgR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.161341227 UTC

[section ""cstring" . Data.Semigroup.Internal.$trModule4_bytes" {
     Data.Semigroup.Internal.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.162178588 UTC

[section ""data" . Data.Semigroup.Internal.$trModule3_closure" {
     Data.Semigroup.Internal.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.162999445 UTC

[section ""cstring" . Data.Semigroup.Internal.$trModule2_bytes" {
     Data.Semigroup.Internal.$trModule2_bytes:
         I8[] [68,97,116,97,46,83,101,109,105,103,114,111,117,112,46,73,110,116,101,114,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.163895814 UTC

[section ""data" . Data.Semigroup.Internal.$trModule1_closure" {
     Data.Semigroup.Internal.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.164806998 UTC

[section ""data" . Data.Semigroup.Internal.$trModule_closure" {
     Data.Semigroup.Internal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Semigroup.Internal.$trModule3_closure+1;
         const Data.Semigroup.Internal.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.165745209 UTC

[section ""data" . $krep_r6v1i_closure" {
     $krep_r6v1i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.166630257 UTC

[section ""data" . $krep1_r6v1j_closure" {
     $krep1_r6v1j_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.168858867 UTC

[section ""data" . $krep2_r6v1k_closure" {
     $krep2_r6v1k_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep1_r6v1j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.16982854 UTC

[section ""data" . $krep3_r6v1l_closure" {
     $krep3_r6v1l_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.170645853 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt1_closure" {
     Data.Semigroup.Internal.$tcAlt1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r6v1l_closure+4;
         const $krep3_r6v1l_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.171513294 UTC

[section ""data" . $krep4_r6v1m_closure" {
     $krep4_r6v1m_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.172310445 UTC

[section ""data" . $krep5_r6v1n_closure" {
     $krep5_r6v1n_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.173124797 UTC

[section ""data" . $krep6_r6v1o_closure" {
     $krep6_r6v1o_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_r6v1m_closure+2;
         const $krep5_r6v1n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.174079518 UTC

[section ""data" . Data.Semigroup.Internal.$tcDual1_closure" {
     Data.Semigroup.Internal.$tcDual1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadDual5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.174948659 UTC

[section ""data" . Data.Semigroup.Internal.$tcDual_closure" {
     Data.Semigroup.Internal.$tcDual_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcDual1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 14711416616195557841;
         const 10971851269997195248;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.175882813 UTC

[section ""data" . $krep7_r6v1p_closure" {
     $krep7_r6v1p_closure:
         const :_con_info;
         const $krep1_r6v1j_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.176758078 UTC

[section ""data" . $krep8_r6v1q_closure" {
     $krep8_r6v1q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcDual_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.17766832 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual1_closure" {
     Data.Semigroup.Internal.$tc'Dual1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep8_r6v1q_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.178463021 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Dual3_bytes" {
     Data.Semigroup.Internal.$tc'Dual3_bytes:
         I8[] [39,68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.179275098 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual2_closure" {
     Data.Semigroup.Internal.$tc'Dual2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Dual3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.180159588 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual_closure" {
     Data.Semigroup.Internal.$tc'Dual_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Dual2_closure+1;
         const Data.Semigroup.Internal.$tc'Dual1_closure+4;
         const 15885009659242865261;
         const 15931193389986079612;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.181014826 UTC

[section ""cstring" . Data.Semigroup.Internal.$tcEndo2_bytes" {
     Data.Semigroup.Internal.$tcEndo2_bytes:
         I8[] [69,110,100,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.181712575 UTC

[section ""data" . Data.Semigroup.Internal.$tcEndo1_closure" {
     Data.Semigroup.Internal.$tcEndo1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tcEndo2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.182275094 UTC

[section ""data" . Data.Semigroup.Internal.$tcEndo_closure" {
     Data.Semigroup.Internal.$tcEndo_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcEndo1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16820921632006328603;
         const 4981834339379479823;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.182865934 UTC

[section ""data" . $krep9_r6v1r_closure" {
     $krep9_r6v1r_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcEndo_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.183445991 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo1_closure" {
     Data.Semigroup.Internal.$tc'Endo1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6v1k_closure+4;
         const $krep9_r6v1r_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.184062654 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Endo3_bytes" {
     Data.Semigroup.Internal.$tc'Endo3_bytes:
         I8[] [39,69,110,100,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.184660597 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo2_closure" {
     Data.Semigroup.Internal.$tc'Endo2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Endo3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.185223141 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo_closure" {
     Data.Semigroup.Internal.$tc'Endo_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Endo2_closure+1;
         const Data.Semigroup.Internal.$tc'Endo1_closure+4;
         const 156297185665537802;
         const 8988325904501215692;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.185901731 UTC

[section ""data" . Data.Semigroup.Internal.$tcAll1_closure" {
     Data.Semigroup.Internal.$tcAll1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAll13_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.186492724 UTC

[section ""data" . Data.Semigroup.Internal.$tcAll_closure" {
     Data.Semigroup.Internal.$tcAll_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAll1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14149274874874504208;
         const 8164254778609961234;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.187112043 UTC

[section ""data" . $krep10_r6v1s_closure" {
     $krep10_r6v1s_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAll_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.187789957 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All1_closure" {
     Data.Semigroup.Internal.$tc'All1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r6v1i_closure+1;
         const $krep10_r6v1s_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.188391871 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'All3_bytes" {
     Data.Semigroup.Internal.$tc'All3_bytes:
         I8[] [39,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.188976662 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All2_closure" {
     Data.Semigroup.Internal.$tc'All2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'All3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.189571432 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All_closure" {
     Data.Semigroup.Internal.$tc'All_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'All2_closure+1;
         const Data.Semigroup.Internal.$tc'All1_closure+4;
         const 1168494541548489787;
         const 10689931498683547374;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.190219765 UTC

[section ""data" . Data.Semigroup.Internal.$tcAny1_closure" {
     Data.Semigroup.Internal.$tcAny1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAny6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.190784757 UTC

[section ""data" . Data.Semigroup.Internal.$tcAny_closure" {
     Data.Semigroup.Internal.$tcAny_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAny1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11600287624241135668;
         const 17600231731807245316;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.19143091 UTC

[section ""data" . $krep11_r6v1t_closure" {
     $krep11_r6v1t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAny_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.192067155 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any1_closure" {
     Data.Semigroup.Internal.$tc'Any1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r6v1i_closure+1;
         const $krep11_r6v1t_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.193432888 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Any3_bytes" {
     Data.Semigroup.Internal.$tc'Any3_bytes:
         I8[] [39,65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.193965166 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any2_closure" {
     Data.Semigroup.Internal.$tc'Any2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Any3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.19453233 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any_closure" {
     Data.Semigroup.Internal.$tc'Any_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Any2_closure+1;
         const Data.Semigroup.Internal.$tc'Any1_closure+4;
         const 16164188984560189013;
         const 110490866064676064;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.1951428 UTC

[section ""data" . Data.Semigroup.Internal.$tcSum1_closure" {
     Data.Semigroup.Internal.$tcSum1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadSum5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.195676451 UTC

[section ""data" . Data.Semigroup.Internal.$tcSum_closure" {
     Data.Semigroup.Internal.$tcSum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcSum1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 7521450980204740829;
         const 14029043805042477297;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.196277815 UTC

[section ""data" . $krep12_r6v1u_closure" {
     $krep12_r6v1u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcSum_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.196848765 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum1_closure" {
     Data.Semigroup.Internal.$tc'Sum1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep12_r6v1u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.198171728 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Sum3_bytes" {
     Data.Semigroup.Internal.$tc'Sum3_bytes:
         I8[] [39,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.198707646 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum2_closure" {
     Data.Semigroup.Internal.$tc'Sum2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Sum3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.199278954 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum_closure" {
     Data.Semigroup.Internal.$tc'Sum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Sum2_closure+1;
         const Data.Semigroup.Internal.$tc'Sum1_closure+4;
         const 7144872330799658717;
         const 13465414667749873698;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.19986718 UTC

[section ""data" . Data.Semigroup.Internal.$tcProduct1_closure" {
     Data.Semigroup.Internal.$tcProduct1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadProduct5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.200404774 UTC

[section ""data" . Data.Semigroup.Internal.$tcProduct_closure" {
     Data.Semigroup.Internal.$tcProduct_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcProduct1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12271745360620305859;
         const 5747185732973757022;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.200984593 UTC

[section ""data" . $krep13_r6v1v_closure" {
     $krep13_r6v1v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcProduct_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.201611185 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product1_closure" {
     Data.Semigroup.Internal.$tc'Product1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep13_r6v1v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.202190906 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Product3_bytes" {
     Data.Semigroup.Internal.$tc'Product3_bytes:
         I8[] [39,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.20274082 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product2_closure" {
     Data.Semigroup.Internal.$tc'Product2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Product3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.203324224 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product_closure" {
     Data.Semigroup.Internal.$tc'Product_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Product2_closure+1;
         const Data.Semigroup.Internal.$tc'Product1_closure+4;
         const 3191278115598904989;
         const 12638872580785847167;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.203906023 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt2_closure" {
     Data.Semigroup.Internal.$tcAlt2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAlt5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.204477627 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt_closure" {
     Data.Semigroup.Internal.$tcAlt_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAlt2_closure+1;
         const Data.Semigroup.Internal.$tcAlt1_closure+4;
         const 7601313288863504805;
         const 2369500163797891218;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.205096688 UTC

[section ""data" . $krep14_r6v1w_closure" {
     $krep14_r6v1w_closure:
         const :_con_info;
         const $krep5_r6v1n_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.205699893 UTC

[section ""data" . $krep15_r6v1x_closure" {
     $krep15_r6v1x_closure:
         const :_con_info;
         const $krep4_r6v1m_closure+2;
         const $krep14_r6v1w_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.206268711 UTC

[section ""data" . $krep16_r6v1y_closure" {
     $krep16_r6v1y_closure:
         const :_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep15_r6v1x_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.206883786 UTC

[section ""data" . $krep17_r6v1z_closure" {
     $krep17_r6v1z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAlt_closure+1;
         const $krep16_r6v1y_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.207452921 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt1_closure" {
     Data.Semigroup.Internal.$tc'Alt1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r6v1o_closure+3;
         const $krep17_r6v1z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.208041884 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Alt3_bytes" {
     Data.Semigroup.Internal.$tc'Alt3_bytes:
         I8[] [39,65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.208592226 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt2_closure" {
     Data.Semigroup.Internal.$tc'Alt2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Alt3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.209170926 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt_closure" {
     Data.Semigroup.Internal.$tc'Alt_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Alt2_closure+1;
         const Data.Semigroup.Internal.$tc'Alt1_closure+4;
         const 1436877498177162483;
         const 16937142347825669760;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.209825275 UTC

[section ""relreadonly" . S6vn0_srt" {
     S6vn0_srt:
         const Data.Semigroup.Internal.$fMonoidSum1_closure;
         const Data.Semigroup.Internal.$fMonoidSum2_closure;
         const Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const GHC.Real.^_closure;
         const Data.Semigroup.Internal.$fSemigroupProduct_closure;
         const sat_s6v3C_closure;
         const Data.Semigroup.Internal.$fMonoidProduct1_closure;
         const Data.Semigroup.Internal.$fMonoidProduct2_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const Data.Semigroup.Internal.$fShowAlt_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAlt_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Semigroup.Internal.$fReadAll3_closure;
         const GHC.Read.readField_closure;
         const Data.Semigroup.Internal.$fReadAlt2_closure;
         const Data.Semigroup.Internal.$fReadAll_lexeme_closure;
         const Data.Semigroup.Internal.$fReadAlt_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Semigroup.Internal.$fReadAlt1_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadList_closure;
         const Data.Semigroup.Internal.$fReadAlt_closure;
         const Data.Semigroup.Internal.$fShowProduct_$cshow_closure;
         const Data.Semigroup.Internal.$fShowProduct_closure;
         const Data.Semigroup.Internal.$fReadProduct2_closure;
         const Data.Semigroup.Internal.$fReadProduct_lexeme_closure;
         const Data.Semigroup.Internal.$fReadProduct1_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadList_closure;
         const Data.Semigroup.Internal.$fReadProduct_closure;
         const Data.Semigroup.Internal.$fShowSum_$cshow_closure;
         const Data.Semigroup.Internal.$fShowSum_closure;
         const Data.Semigroup.Internal.$fReadSum2_closure;
         const Data.Semigroup.Internal.$fReadSum_lexeme_closure;
         const Data.Semigroup.Internal.$fReadSum1_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadList_closure;
         const Data.Semigroup.Internal.$fReadSum_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const GHC.Show.$fShowBool2_closure;
         const GHC.Show.$fShowBool4_closure;
         const Data.Semigroup.Internal.$fShowAny3_closure;
         const Data.Semigroup.Internal.$w$cshowsPrec2_closure;
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll5_closure;
         const Data.Semigroup.Internal.$fShowAll6_closure;
         const Data.Semigroup.Internal.$fShowAny_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAny1_closure;
         const GHC.Read.$fReadBool2_closure;
         const GHC.Read.list3_closure;
         const Data.Semigroup.Internal.$fReadAll3_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Semigroup.Internal.$fReadAll7_closure;
         const Data.Semigroup.Internal.$fReadAny3_closure;
         const Data.Semigroup.Internal.$w$creadPrec1_closure;
         const Data.Semigroup.Internal.$fReadAny_lexeme_closure;
         const Data.Semigroup.Internal.$fReadAny2_closure;
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadAny1_closure;
         const GHC.Read.list_closure;
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAny7_closure;
         const Data.Semigroup.Internal.$fShowAll3_closure;
         const Data.Semigroup.Internal.$w$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAll1_closure;
         const Data.Semigroup.Internal.$fReadAll8_closure;
         const Data.Semigroup.Internal.$w$creadPrec_closure;
         const Data.Semigroup.Internal.$fReadAll_lexeme1_closure;
         const Data.Semigroup.Internal.$fReadAll2_closure;
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadAll1_closure;
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAll14_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const Data.Semigroup.Internal.$fShowDual_$cshow_closure;
         const Data.Semigroup.Internal.$fShowDual_closure;
         const Data.Semigroup.Internal.$fReadDual2_closure;
         const Data.Semigroup.Internal.$fReadDual_lexeme_closure;
         const Data.Semigroup.Internal.$fReadDual1_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadList_closure;
         const Data.Semigroup.Internal.$fReadDual_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Semigroup.Internal.$fMonoidSum1_closure;
         const Data.Semigroup.Internal.stimesIdempotent_closure;
         const Data.Semigroup.Internal.stimesIdempotent1_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid1_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Semigroup.Internal.$fMonoidAll_closure;
         const sat_s6vee_closure;
         const lvl7_r6v1d_closure;
         const Data.Semigroup.Internal.$fMonoidProduct1_closure;
         const GHC.Real.even_closure;
         const Data.Semigroup.Internal.stimesMonoid_closure;
         const lvl6_r6v1c_closure;
         const Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure;
         const Data.Semigroup.Internal.$fSemigroupAlt_closure;
         const Data.Semigroup.Internal.$fMonoidAlt_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const lvl9_r6v1f_closure;
         const Data.Semigroup.Internal.stimesMaybe_closure;
         const Data.Semigroup.Internal.stimesMaybe1_closure;
         const Data.Semigroup.Internal.stimesList_closure;
         const Data.Semigroup.Internal.stimesList1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.211348793 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:01:44.213439604 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat1_closure" {
     Data.Semigroup.Internal.$w$csconcat1_closure:
         const Data.Semigroup.Internal.$w$csconcat1_info;
 },
 go_s6v1E_entry() //  [R1, R2, R3]
         { info_tbl: [(c6yl3,
                       label: go_s6v1E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yl3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yl4; else goto c6yl5;
       c6yl4: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yl5: // global
           I64[Sp - 32] = block_c6ykW_info;
           _s6v1E::P64 = R1;
           _s6v1B::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6v1B::P64;
           P64[Sp - 16] = _s6v1E::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6ylf; else goto c6ykX;
       u6ylf: // global
           call _c6ykW(R1) args: 0, res: 0, upd: 0;
       c6ykX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ykW() //  [R1]
         { info_tbl: [(c6ykW,
                       label: block_c6ykW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ykW: // global
           if (R1 & 7 == 1) goto c6yl0; else goto c6yl1;
       c6yl0: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6yl1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6yld; else goto c6ylc;
       c6yld: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ylc: // global
           _s6v1I::P64 = P64[R1 + 6];
           _s6v1J::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6v1I::P64;
           P64[Hp] = _s6v1J::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6ylg,
                       label: Data.Semigroup.Internal.$w$csconcat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ylg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6ylk; else goto c6ylj;
       c6ylk: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ylj: // global
           I64[Hp - 8] = go_s6v1E_info;
           P64[Hp] = R2;
           _s6v1C::P64 = R3;
           R3 = R4;
           R2 = _s6v1C::P64;
           R1 = Hp - 6;
           call go_s6v1E_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.223082697 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupDual_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupDual_$csconcat_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c6ylI,
                       label: Data.Semigroup.Internal.$fSemigroupDual_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ylI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ylJ; else goto c6ylK;
       c6ylJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ylK: // global
           I64[Sp - 16] = block_c6ylF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6ylO; else goto c6ylG;
       u6ylO: // global
           call _c6ylF(R1) args: 0, res: 0, upd: 0;
       c6ylG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ylF() //  [R1]
         { info_tbl: [(c6ylF,
                       label: block_c6ylF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ylF: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.228997333 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupDual_closure" {
     Data.Semigroup.Internal.$fSemigroupDual_closure:
         const Data.Semigroup.Internal.$fSemigroupDual_info;
 },
 sat_s6v1Y_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6ym7,
                       label: sat_s6v1Y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ym7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6ym8; else goto c6ym9;
       c6ym8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ym9: // global
           _s6v1V::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s6v1V::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Base.stimes_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6v1U_entry() //  [R1, R2]
         { info_tbl: [(c6ymf,
                       label: sat_s6v1U_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ymf: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupDual_$csconcat_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v1T_entry() //  [R1, R2, R3]
         { info_tbl: [(c6ymn,
                       label: sat_s6v1T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ymn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6ymo; else goto c6ymp;
       c6ymo: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ymp: // global
           _s6v1R::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = _s6v1R::P64;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fSemigroupDual_entry() //  [R2]
         { info_tbl: [(c6ymr,
                       label: Data.Semigroup.Internal.$fSemigroupDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ymr: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6ymv; else goto c6ymu;
       c6ymv: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ymu: // global
           I64[Hp - 72] = sat_s6v1Y_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v1U_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v1T_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 69;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.243711585 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_info;
 },
 sat_s6v20_entry() //  [R1]
         { info_tbl: [(c6ymX,
                       label: sat_s6v20_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ymX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ymY; else goto c6ymZ;
       c6ymY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ymZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(c6yn0,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yn0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yn4; else goto c6yn3;
       c6yn4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yn3: // global
           I64[Hp - 16] = sat_s6v20_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fSemigroupDual_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.252569313 UTC

[section ""data" . $cmappend_r6v15_closure" {
     $cmappend_r6v15_closure:
         const $cmappend_r6v15_info;
 },
 $cmappend_r6v15_entry() //  [R2, R3, R4]
         { info_tbl: [(c6ynj,
                       label: $cmappend_r6v15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ynj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6ynk; else goto c6ynl;
       c6ynk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cmappend_r6v15_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ynl: // global
           I64[Sp - 24] = block_c6ynh_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6ynh() //  [R1]
         { info_tbl: [(c6ynh,
                       label: block_c6ynh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ynh: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _s6v22::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6v22::P64;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.259328766 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cmappend_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cmappend_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cmappend_info;
 },
 Data.Semigroup.Internal.$fMonoidDual_$cmappend_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c6ynC,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cmappend_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ynC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cmappend_r6v15_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.263825819 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cmconcat_info;
 },
 lvl12_s6v27_entry() //  [R1]
         { info_tbl: [(c6ynR,
                       label: lvl12_s6v27_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ynR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ynS; else goto c6ynT;
       c6ynS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ynT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s6v28_entry() //  [R1]
         { info_tbl: [(c6ynY,
                       label: z_s6v28_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ynY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ynZ; else goto c6yo0;
       c6ynZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yo0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s6v29_entry() //  [R1, R2]
         { info_tbl: [(c6yod,
                       label: go_s6v29_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yod: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yoe; else goto c6yof;
       c6yoe: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yof: // global
           I64[Sp - 32] = block_c6yo6_info;
           _s6v29::P64 = R1;
           _s6v27::P64 = P64[R1 + 7];
           _s6v28::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6v27::P64;
           P64[Sp - 16] = _s6v28::P64;
           P64[Sp - 8] = _s6v29::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6yop; else goto c6yo7;
       u6yop: // global
           call _c6yo6(R1) args: 0, res: 0, upd: 0;
       c6yo7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6yo6() //  [R1]
         { info_tbl: [(c6yo6,
                       label: block_c6yo6_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yo6: // global
           if (R1 & 7 == 1) goto c6yoa; else goto c6yob;
       c6yoa: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6yob: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yon; else goto c6yom;
       c6yon: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yom: // global
           _s6v2c::P64 = P64[R1 + 6];
           _s6v2d::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6v2d::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = _s6v2c::P64;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c6yoq,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yoq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6you; else goto c6yot;
       c6you: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yot: // global
           I64[Hp - 64] = lvl12_s6v27_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = z_s6v28_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6v29_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s6v29_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.277731232 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_closure" {
     Data.Semigroup.Internal.$fMonoidDual_closure:
         const Data.Semigroup.Internal.$fMonoidDual_info;
 },
 sat_s6v2j_entry() //  [R1, R2]
         { info_tbl: [(c6yp4,
                       label: sat_s6v2j_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yp4: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fMonoidDual_$cmconcat_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2i_entry() //  [R1, R2, R3]
         { info_tbl: [(c6ypc,
                       label: sat_s6v2i_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ypc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fMonoidDual_$cmappend_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2h_entry() //  [R1]
         { info_tbl: [(c6ypj,
                       label: sat_s6v2h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ypj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ypk; else goto c6ypl;
       c6ypk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ypl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v2g_entry() //  [R1]
         { info_tbl: [(c6ypq,
                       label: sat_s6v2g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ypq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ypr; else goto c6yps;
       c6ypr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yps: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_entry() //  [R2]
         { info_tbl: [(c6ypu,
                       label: Data.Semigroup.Internal.$fMonoidDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ypu: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6ypy; else goto c6ypx;
       c6ypy: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ypx: // global
           I64[Hp - 112] = sat_s6v2j_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s6v2i_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v2h_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v2g_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 94;
           P64[Hp] = Hp - 111;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.28886225 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual2_closure" {
     Data.Semigroup.Internal.$fFunctorDual2_closure:
         const Data.Semigroup.Internal.$fFunctorDual2_info;
 },
 Data.Semigroup.Internal.$fFunctorDual2_entry() //  [R2]
         { info_tbl: [(c6yq0,
                       label: Data.Semigroup.Internal.$fFunctorDual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yq0: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.292384824 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual1_closure" {
     Data.Semigroup.Internal.$fFunctorDual1_closure:
         const Data.Semigroup.Internal.$fFunctorDual1_info;
 },
 Data.Semigroup.Internal.$fFunctorDual1_entry() //  [R2]
         { info_tbl: [(c6yqb,
                       label: Data.Semigroup.Internal.$fFunctorDual1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yqb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.295906097 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual_closure" {
     Data.Semigroup.Internal.$fFunctorDual_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.298439602 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual3_closure" {
     Data.Semigroup.Internal.$fApplicativeDual3_closure:
         const Data.Semigroup.Internal.$fApplicativeDual3_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual3_entry() //  [R2]
         { info_tbl: [(c6yqn,
                       label: Data.Semigroup.Internal.$fApplicativeDual3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yqn: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.301828745 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual4_closure" {
     Data.Semigroup.Internal.$fApplicativeDual4_closure:
         const Data.Semigroup.Internal.$fApplicativeDual4_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual4_entry() //  [R2]
         { info_tbl: [(c6yqy,
                       label: Data.Semigroup.Internal.$fApplicativeDual4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yqy: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.305210312 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual2_closure" {
     Data.Semigroup.Internal.$fApplicativeDual2_closure:
         const Data.Semigroup.Internal.$fApplicativeDual2_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual2_entry() //  [R2, R3]
         { info_tbl: [(c6yqJ,
                       label: Data.Semigroup.Internal.$fApplicativeDual2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yqJ: // global
           _s6v2p::P64 = R2;
           R2 = R3;
           R1 = _s6v2p::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.308672053 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeDual_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual_$c*>_entry() //  [R3]
         { info_tbl: [(c6yqU,
                       label: Data.Semigroup.Internal.$fApplicativeDual_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yqU: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.31250481 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual1_closure" {
     Data.Semigroup.Internal.$fApplicativeDual1_closure:
         const Data.Semigroup.Internal.$fApplicativeDual1_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual1_entry() //  [R2]
         { info_tbl: [(c6yr5,
                       label: Data.Semigroup.Internal.$fApplicativeDual1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yr5: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.315952271 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual_closure" {
     Data.Semigroup.Internal.$fApplicativeDual_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorDual_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.318537207 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum1_closure" {
     Data.Semigroup.Internal.$fSemigroupSum1_closure:
         const Data.Semigroup.Internal.$fSemigroupSum1_info;
 },
 sat_s6v2z_entry() //  [R1]
         { info_tbl: [(c6yrp,
                       label: sat_s6v2z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yrp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yrq; else goto c6yrr;
       c6yrq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yrr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6v2A_entry() //  [R1]
         { info_tbl: [(c6yrs,
                       label: sat_s6v2A_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yrs: // global
           _s6v2A::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c6yrt; else goto c6yru;
       c6yru: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yrw; else goto c6yrv;
       c6yrw: // global
           HpAlloc = 32;
           goto c6yrt;
       c6yrt: // global
           R1 = _s6v2A::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yrv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v2A::P64;
           _s6v2v::P64 = P64[_s6v2A::P64 + 16];
           _s6v2w::P64 = P64[_s6v2A::P64 + 24];
           _s6v2x::P64 = P64[_s6v2A::P64 + 32];
           I64[Hp - 24] = sat_s6v2z_info;
           P64[Hp - 8] = _s6v2w::P64;
           P64[Hp] = _s6v2x::P64;
           R2 = _s6v2v::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupSum1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c6yrx,
                       label: Data.Semigroup.Internal.$fSemigroupSum1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yrx: // global
           _s6v2y::P64 = R5;
           _s6v2x::P64 = R4;
           _s6v2w::P64 = R3;
           _s6v2v::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c6yry; else goto c6yrz;
       c6yrz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6yrB; else goto c6yrA;
       c6yrB: // global
           HpAlloc = 40;
           goto c6yry;
       c6yry: // global
           R5 = _s6v2y::P64;
           R4 = _s6v2x::P64;
           R3 = _s6v2w::P64;
           R2 = _s6v2v::P64;
           R1 = Data.Semigroup.Internal.$fSemigroupSum1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yrA: // global
           I64[Hp - 32] = sat_s6v2A_info;
           P64[Hp - 16] = _s6v2v::P64;
           P64[Hp - 8] = _s6v2w::P64;
           P64[Hp] = _s6v2x::P64;
           R2 = _s6v2v::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s6v2y::P64;
           Sp = Sp - 24;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.328578347 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat3_closure" {
     Data.Semigroup.Internal.$w$csconcat3_closure:
         const Data.Semigroup.Internal.$w$csconcat3_info;
 },
 go_s6v2E_entry() //  [R1, R2, R3]
         { info_tbl: [(c6ys8,
                       label: go_s6v2E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ys8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6ys9; else goto c6ysa;
       c6ys9: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ysa: // global
           I64[Sp - 32] = block_c6ys1_info;
           _s6v2E::P64 = R1;
           _s6v2B::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6v2B::P64;
           P64[Sp - 16] = _s6v2E::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6ysk; else goto c6ys2;
       u6ysk: // global
           call _c6ys1(R1) args: 0, res: 0, upd: 0;
       c6ys2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ys1() //  [R1]
         { info_tbl: [(c6ys1,
                       label: block_c6ys1_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ys1: // global
           _s6v2F::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6ys5; else goto c6ys6;
       c6ys5: // global
           R1 = _s6v2F::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6ys6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6ysi; else goto c6ysh;
       c6ysi: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ysh: // global
           _s6v2I::P64 = P64[R1 + 6];
           _s6v2J::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6v2I::P64;
           P64[Hp] = _s6v2J::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v2F::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat3_entry() //  [R2, R3, R4]
         { info_tbl: [(c6ysl,
                       label: Data.Semigroup.Internal.$w$csconcat3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ysl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6ysp; else goto c6yso;
       c6ysp: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yso: // global
           I64[Hp - 8] = go_s6v2E_info;
           P64[Hp] = R2;
           _s6v2C::P64 = R3;
           R3 = R4;
           R2 = _s6v2C::P64;
           R1 = Hp - 6;
           call go_s6v2E_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.337610222 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupSum_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupSum_$csconcat_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c6ysN,
                       label: Data.Semigroup.Internal.$fSemigroupSum_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ysN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ysO; else goto c6ysP;
       c6ysO: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ysP: // global
           I64[Sp - 16] = block_c6ysK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6ysT; else goto c6ysL;
       u6ysT: // global
           call _c6ysK(R1) args: 0, res: 0, upd: 0;
       c6ysL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ysK() //  [R1]
         { info_tbl: [(c6ysK,
                       label: block_c6ysK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ysK: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat3_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.344435623 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum_closure" {
     Data.Semigroup.Internal.$fSemigroupSum_closure:
         const Data.Semigroup.Internal.$fSemigroupSum_info;
 },
 sat_s6v2T_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6ytc,
                       label: sat_s6v2T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ytc: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Semigroup.Internal.$fSemigroupSum1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2S_entry() //  [R1, R2]
         { info_tbl: [(c6ytk,
                       label: sat_s6v2S_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ytk: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupSum_$csconcat_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v2R_entry() //  [R1]
         { info_tbl: [(c6ytr,
                       label: sat_s6v2R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ytr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yts; else goto c6ytt;
       c6yts: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ytt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupSum_entry() //  [R2]
         { info_tbl: [(c6ytv,
                       label: Data.Semigroup.Internal.$fSemigroupSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ytv: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6ytz; else goto c6yty;
       c6ytz: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yty: // global
           I64[Hp - 80] = sat_s6v2T_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v2S_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6v2R_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 77;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.354087902 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum1_closure" {
     Data.Semigroup.Internal.$fMonoidSum1_closure:
         const Data.Semigroup.Internal.$fMonoidSum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidSum1_entry() //  [R1]
         { info_tbl: [(c6ytY,
                       label: Data.Semigroup.Internal.$fMonoidSum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ytY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ytZ; else goto c6yu0;
       c6ytZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yu0: // global
           (_c6ytV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6ytV::I64 == 0) goto c6ytX; else goto c6ytW;
       c6ytX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6ytW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6ytV::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.35836057 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum2_closure" {
     Data.Semigroup.Internal.$fMonoidSum2_closure:
         const Data.Semigroup.Internal.$fMonoidSum2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidSum2_entry() //  [R2]
         { info_tbl: [(c6yuc,
                       label: Data.Semigroup.Internal.$fMonoidSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yuc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yud; else goto c6yue;
       c6yud: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yue: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.363020222 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidSum_$cmconcat_info;
         const 0;
 },
 z_s6v2W_entry() //  [R1]
         { info_tbl: [(c6yus,
                       label: z_s6v2W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yus: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yut; else goto c6yuu;
       c6yut: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yuu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s6v2X_entry() //  [R1, R2]
         { info_tbl: [(c6yuH,
                       label: go_s6v2X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yuH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yuI; else goto c6yuJ;
       c6yuI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yuJ: // global
           I64[Sp - 32] = block_c6yuA_info;
           _s6v2X::P64 = R1;
           _s6v2V::P64 = P64[R1 + 7];
           _s6v2W::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6v2V::P64;
           P64[Sp - 16] = _s6v2W::P64;
           P64[Sp - 8] = _s6v2X::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6yuT; else goto c6yuB;
       u6yuT: // global
           call _c6yuA(R1) args: 0, res: 0, upd: 0;
       c6yuB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6yuA() //  [R1]
         { info_tbl: [(c6yuA,
                       label: block_c6yuA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yuA: // global
           if (R1 & 7 == 1) goto c6yuE; else goto c6yuF;
       c6yuE: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6yuF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yuR; else goto c6yuQ;
       c6yuR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yuQ: // global
           _s6v30::P64 = P64[R1 + 6];
           _s6v31::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6v31::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v30::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidSum_$cmconcat_entry() //  [R2]
         { info_tbl: [(c6yuU,
                       label: Data.Semigroup.Internal.$fMonoidSum_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yuU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6yuY; else goto c6yuX;
       c6yuY: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yuX: // global
           I64[Hp - 40] = z_s6v2W_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6v2X_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.375350762 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum_closure" {
     Data.Semigroup.Internal.$fMonoidSum_closure:
         const Data.Semigroup.Internal.$fMonoidSum_info;
         const 0;
 },
 sat_s6v37_entry() //  [R1]
         { info_tbl: [(c6yvt,
                       label: sat_s6v37_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yvt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yvu; else goto c6yvv;
       c6yvu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yvv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_$cmconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v36_entry() //  [R1]
         { info_tbl: [(c6yvA,
                       label: sat_s6v36_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yvA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yvB; else goto c6yvC;
       c6yvB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yvC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v35_entry() //  [R1]
         { info_tbl: [(c6yvH,
                       label: sat_s6v35_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yvH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yvI; else goto c6yvJ;
       c6yvI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yvJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v34_entry() //  [R1]
         { info_tbl: [(c6yvO,
                       label: sat_s6v34_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yvO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yvP; else goto c6yvQ;
       c6yvP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yvQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidSum_entry() //  [R2]
         { info_tbl: [(c6yvS,
                       label: Data.Semigroup.Internal.$fMonoidSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yvS: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6yvW; else goto c6yvV;
       c6yvW: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yvV: // global
           I64[Hp - 128] = sat_s6v37_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v36_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v35_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v34_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.387218178 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorSum_closure" {
     Data.Semigroup.Internal.$fFunctorSum_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.389423413 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum3_closure" {
     Data.Semigroup.Internal.$fApplicativeSum3_closure:
         const Data.Semigroup.Internal.$fApplicativeSum3_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum3_entry() //  [R2]
         { info_tbl: [(c6ywr,
                       label: Data.Semigroup.Internal.$fApplicativeSum3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ywr: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.393579728 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum2_closure" {
     Data.Semigroup.Internal.$fApplicativeSum2_closure:
         const Data.Semigroup.Internal.$fApplicativeSum2_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum2_entry() //  [R2, R3]
         { info_tbl: [(c6ywC,
                       label: Data.Semigroup.Internal.$fApplicativeSum2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ywC: // global
           _s6v39::P64 = R2;
           R2 = R3;
           R1 = _s6v39::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.39710612 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeSum_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum_$c*>_entry() //  [R3]
         { info_tbl: [(c6ywN,
                       label: Data.Semigroup.Internal.$fApplicativeSum_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ywN: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.400666687 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum1_closure" {
     Data.Semigroup.Internal.$fApplicativeSum1_closure:
         const Data.Semigroup.Internal.$fApplicativeSum1_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum1_entry() //  [R2]
         { info_tbl: [(c6ywY,
                       label: Data.Semigroup.Internal.$fApplicativeSum1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ywY: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.403897598 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum_closure" {
     Data.Semigroup.Internal.$fApplicativeSum_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorSum_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeSum3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeSum2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeSum1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.406580796 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat2_closure" {
     Data.Semigroup.Internal.$w$csconcat2_closure:
         const Data.Semigroup.Internal.$w$csconcat2_info;
 },
 go_s6v3i_entry() //  [R1, R2, R3]
         { info_tbl: [(c6yxm,
                       label: go_s6v3i_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yxm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yxn; else goto c6yxo;
       c6yxn: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yxo: // global
           I64[Sp - 32] = block_c6yxf_info;
           _s6v3i::P64 = R1;
           _s6v3f::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6v3f::P64;
           P64[Sp - 16] = _s6v3i::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6yxy; else goto c6yxg;
       u6yxy: // global
           call _c6yxf(R1) args: 0, res: 0, upd: 0;
       c6yxg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6yxf() //  [R1]
         { info_tbl: [(c6yxf,
                       label: block_c6yxf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yxf: // global
           _s6v3j::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6yxj; else goto c6yxk;
       c6yxj: // global
           R1 = _s6v3j::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6yxk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6yxw; else goto c6yxv;
       c6yxw: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yxv: // global
           _s6v3m::P64 = P64[R1 + 6];
           _s6v3n::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6v3m::P64;
           P64[Hp] = _s6v3n::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v3j::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat2_entry() //  [R2, R3, R4]
         { info_tbl: [(c6yxz,
                       label: Data.Semigroup.Internal.$w$csconcat2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yxz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6yxD; else goto c6yxC;
       c6yxD: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yxC: // global
           I64[Hp - 8] = go_s6v3i_info;
           P64[Hp] = R2;
           _s6v3g::P64 = R3;
           R3 = R4;
           R2 = _s6v3g::P64;
           R1 = Hp - 6;
           call go_s6v3i_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.415955363 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c6yy1,
                       label: Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yy1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yy2; else goto c6yy3;
       c6yy2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yy3: // global
           I64[Sp - 16] = block_c6yxY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6yy7; else goto c6yxZ;
       u6yy7: // global
           call _c6yxY(R1) args: 0, res: 0, upd: 0;
       c6yxZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6yxY() //  [R1]
         { info_tbl: [(c6yxY,
                       label: block_c6yxY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yxY: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat2_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.422746219 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupProduct_closure" {
     Data.Semigroup.Internal.$fSemigroupProduct_closure:
         const Data.Semigroup.Internal.$fSemigroupProduct_info;
         const 0;
 },
 sat_s6v3A_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6yyq,
                       label: sat_s6v3A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yyq: // global
           R5 = R3;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v3w_entry() //  [R1, R2]
         { info_tbl: [(c6yyy,
                       label: sat_s6v3w_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yyy: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v3v_entry() //  [R1]
         { info_tbl: [(c6yyF,
                       label: sat_s6v3v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yyF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yyG; else goto c6yyH;
       c6yyG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yyH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupProduct_entry() //  [R2]
         { info_tbl: [(c6yyJ,
                       label: Data.Semigroup.Internal.$fSemigroupProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yyJ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6yyN; else goto c6yyM;
       c6yyN: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yyM: // global
           I64[Hp - 80] = sat_s6v3A_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v3w_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6v3v_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 77;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.43222379 UTC

[section ""data" . sat_s6v3B_closure" {
     sat_s6v3B_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.434053602 UTC

[section ""data" . sat_s6v3C_closure" {
     sat_s6v3C_closure:
         const :_con_info;
         const sat_s6v3B_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.436187703 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct1_closure" {
     Data.Semigroup.Internal.$fMonoidProduct1_closure:
         const Data.Semigroup.Internal.$fMonoidProduct1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidProduct1_entry() //  [R1]
         { info_tbl: [(c6yze,
                       label: Data.Semigroup.Internal.$fMonoidProduct1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yze: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yzf; else goto c6yzg;
       c6yzf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yzg: // global
           (_c6yzb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6yzb::I64 == 0) goto c6yzd; else goto c6yzc;
       c6yzd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6yzc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6yzb::I64;
           R3 = sat_s6v3C_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.441273772 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct2_closure" {
     Data.Semigroup.Internal.$fMonoidProduct2_closure:
         const Data.Semigroup.Internal.$fMonoidProduct2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidProduct2_entry() //  [R2]
         { info_tbl: [(c6yzs,
                       label: Data.Semigroup.Internal.$fMonoidProduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yzs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yzt; else goto c6yzu;
       c6yzt: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yzu: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.44620124 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_info;
         const 0;
 },
 z_s6v3F_entry() //  [R1]
         { info_tbl: [(c6yzI,
                       label: z_s6v3F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yzI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yzJ; else goto c6yzK;
       c6yzJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yzK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s6v3G_entry() //  [R1, R2]
         { info_tbl: [(c6yzX,
                       label: go_s6v3G_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yzX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yzY; else goto c6yzZ;
       c6yzY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yzZ: // global
           I64[Sp - 32] = block_c6yzQ_info;
           _s6v3G::P64 = R1;
           _s6v3E::P64 = P64[R1 + 7];
           _s6v3F::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6v3E::P64;
           P64[Sp - 16] = _s6v3F::P64;
           P64[Sp - 8] = _s6v3G::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6yA9; else goto c6yzR;
       u6yA9: // global
           call _c6yzQ(R1) args: 0, res: 0, upd: 0;
       c6yzR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6yzQ() //  [R1]
         { info_tbl: [(c6yzQ,
                       label: block_c6yzQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yzQ: // global
           if (R1 & 7 == 1) goto c6yzU; else goto c6yzV;
       c6yzU: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6yzV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yA7; else goto c6yA6;
       c6yA7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yA6: // global
           _s6v3J::P64 = P64[R1 + 6];
           _s6v3K::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6v3K::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6v3J::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_entry() //  [R2]
         { info_tbl: [(c6yAa,
                       label: Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yAa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6yAe; else goto c6yAd;
       c6yAe: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yAd: // global
           I64[Hp - 40] = z_s6v3F_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6v3G_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.457061139 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct_closure" {
     Data.Semigroup.Internal.$fMonoidProduct_closure:
         const Data.Semigroup.Internal.$fMonoidProduct_info;
         const 0;
 },
 sat_s6v3Q_entry() //  [R1]
         { info_tbl: [(c6yAJ,
                       label: sat_s6v3Q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yAJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yAK; else goto c6yAL;
       c6yAK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yAL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3P_entry() //  [R1]
         { info_tbl: [(c6yAQ,
                       label: sat_s6v3P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yAQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yAR; else goto c6yAS;
       c6yAR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yAS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3O_entry() //  [R1]
         { info_tbl: [(c6yAX,
                       label: sat_s6v3O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yAX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yAY; else goto c6yAZ;
       c6yAY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yAZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3N_entry() //  [R1]
         { info_tbl: [(c6yB4,
                       label: sat_s6v3N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yB4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yB5; else goto c6yB6;
       c6yB5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yB6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidProduct_entry() //  [R2]
         { info_tbl: [(c6yB8,
                       label: Data.Semigroup.Internal.$fMonoidProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yB8: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6yBc; else goto c6yBb;
       c6yBc: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yBb: // global
           I64[Hp - 128] = sat_s6v3Q_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v3P_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v3O_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v3N_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.46986858 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorProduct_closure" {
     Data.Semigroup.Internal.$fFunctorProduct_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.471849537 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct3_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct3_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct3_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct3_entry() //  [R2]
         { info_tbl: [(c6yBH,
                       label: Data.Semigroup.Internal.$fApplicativeProduct3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yBH: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.475393363 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct2_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct2_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct2_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct2_entry() //  [R2, R3]
         { info_tbl: [(c6yBS,
                       label: Data.Semigroup.Internal.$fApplicativeProduct2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yBS: // global
           _s6v3S::P64 = R2;
           R2 = R3;
           R1 = _s6v3S::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.478916293 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct_$c*>_entry() //  [R3]
         { info_tbl: [(c6yC3,
                       label: Data.Semigroup.Internal.$fApplicativeProduct_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yC3: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.482273126 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct1_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct1_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct1_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct1_entry() //  [R2]
         { info_tbl: [(c6yCe,
                       label: Data.Semigroup.Internal.$fApplicativeProduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yCe: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.485569839 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorProduct_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeProduct3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeProduct2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeProduct1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.488572439 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorAlt_closure" {
     Data.Semigroup.Internal.$fFunctorAlt_closure:
         const Data.Semigroup.Internal.$fFunctorAlt_info;
 },
 sat_s6v40_entry() //  [R1]
         { info_tbl: [(c6yCu,
                       label: sat_s6v40_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yCu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yCv; else goto c6yCw;
       c6yCv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yCw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v3Z_entry() //  [R1]
         { info_tbl: [(c6yCB,
                       label: sat_s6v3Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yCB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yCC; else goto c6yCD;
       c6yCC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yCD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fFunctorAlt_entry() //  [R2]
         { info_tbl: [(c6yCF,
                       label: Data.Semigroup.Internal.$fFunctorAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yCF: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6yCJ; else goto c6yCI;
       c6yCJ: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fFunctorAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yCI: // global
           I64[Hp - 64] = sat_s6v40_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v3Z_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.4963639 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure" {
     Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure:
         const Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_info;
 },
 sat_s6v42_entry() //  [R1]
         { info_tbl: [(c6yD7,
                       label: sat_s6v42_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yD7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yD8; else goto c6yD9;
       c6yD8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yD9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_entry() //  [R2]
         { info_tbl: [(c6yDa,
                       label: Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yDa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yDe; else goto c6yDd;
       c6yDe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yDd: // global
           I64[Hp - 16] = sat_s6v42_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fFunctorAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.502854756 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeAlt_closure" {
     Data.Semigroup.Internal.$fApplicativeAlt_closure:
         const Data.Semigroup.Internal.$fApplicativeAlt_info;
 },
 sat_s6v49_entry() //  [R1]
         { info_tbl: [(c6yDv,
                       label: sat_s6v49_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yDv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yDw; else goto c6yDx;
       c6yDw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yDx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v48_entry() //  [R1]
         { info_tbl: [(c6yDC,
                       label: sat_s6v48_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yDC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yDD; else goto c6yDE;
       c6yDD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yDE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v47_entry() //  [R1]
         { info_tbl: [(c6yDJ,
                       label: sat_s6v47_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yDJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yDK; else goto c6yDL;
       c6yDK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yDL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v46_entry() //  [R1]
         { info_tbl: [(c6yDQ,
                       label: sat_s6v46_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yDQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yDR; else goto c6yDS;
       c6yDR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yDS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v45_entry() //  [R1]
         { info_tbl: [(c6yDX,
                       label: sat_s6v45_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yDX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yDY; else goto c6yDZ;
       c6yDY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yDZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v44_entry() //  [R1]
         { info_tbl: [(c6yE4,
                       label: sat_s6v44_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yE4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yE5; else goto c6yE6;
       c6yE5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yE6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fApplicativeAlt_entry() //  [R2]
         { info_tbl: [(c6yE8,
                       label: Data.Semigroup.Internal.$fApplicativeAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yE8: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c6yEc; else goto c6yEb;
       c6yEc: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fApplicativeAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yEb: // global
           I64[Hp - 192] = sat_s6v49_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6v48_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s6v47_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6v46_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s6v45_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6v44_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 120;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 168;
           P64[Hp] = Hp - 192;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.519492837 UTC

[section ""data" . Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure" {
     Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure:
         const Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_info;
 },
 sat_s6v4b_entry() //  [R1]
         { info_tbl: [(c6yEU,
                       label: sat_s6v4b_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yEU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yEV; else goto c6yEW;
       c6yEV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yEW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(c6yEX,
                       label: Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yEX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yF1; else goto c6yF0;
       c6yF1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yF0: // global
           I64[Hp - 16] = sat_s6v4b_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.525670947 UTC

[section ""data" . Data.Semigroup.Internal.$fAlternativeAlt_closure" {
     Data.Semigroup.Internal.$fAlternativeAlt_closure:
         const Data.Semigroup.Internal.$fAlternativeAlt_info;
 },
 sat_s6v4h_entry() //  [R1]
         { info_tbl: [(c6yFi,
                       label: sat_s6v4h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yFi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yFj; else goto c6yFk;
       c6yFj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yFk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.many_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4g_entry() //  [R1]
         { info_tbl: [(c6yFp,
                       label: sat_s6v4g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yFp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yFq; else goto c6yFr;
       c6yFq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yFr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.some_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4f_entry() //  [R1]
         { info_tbl: [(c6yFw,
                       label: sat_s6v4f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yFw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yFx; else goto c6yFy;
       c6yFx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yFy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4e_entry() //  [R1]
         { info_tbl: [(c6yFD,
                       label: sat_s6v4e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yFD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yFE; else goto c6yFF;
       c6yFE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yFF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4d_entry() //  [R1]
         { info_tbl: [(c6yFK,
                       label: sat_s6v4d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yFK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yFL; else goto c6yFM;
       c6yFL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yFM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fAlternativeAlt_entry() //  [R2]
         { info_tbl: [(c6yFO,
                       label: Data.Semigroup.Internal.$fAlternativeAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yFO: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c6yFS; else goto c6yFR;
       c6yFS: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fAlternativeAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yFR: // global
           I64[Hp - 160] = sat_s6v4h_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4g_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4f_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4e_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v4d_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.539847556 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_info;
 },
 sat_s6v4j_entry() //  [R1]
         { info_tbl: [(c6yGv,
                       label: sat_s6v4j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yGv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yGw; else goto c6yGx;
       c6yGw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yGx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_entry() //  [R2]
         { info_tbl: [(c6yGy,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yGy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yGC; else goto c6yGB;
       c6yGC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yGB: // global
           I64[Hp - 16] = sat_s6v4j_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fAlternativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.546020611 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure" {
     Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure:
         const Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_info;
 },
 sat_s6v4l_entry() //  [R1]
         { info_tbl: [(c6yGT,
                       label: sat_s6v4l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yGT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yGU; else goto c6yGV;
       c6yGU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yGV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_entry() //  [R2]
         { info_tbl: [(c6yGW,
                       label: Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yGW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yH0; else goto c6yGZ;
       c6yH0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yGZ: // global
           I64[Hp - 16] = sat_s6v4l_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.552343618 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadAlt_closure" {
     Data.Semigroup.Internal.$fMonadAlt_closure:
         const Data.Semigroup.Internal.$fMonadAlt_info;
 },
 sat_s6v4r_entry() //  [R1]
         { info_tbl: [(c6yHh,
                       label: sat_s6v4r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yHh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yHi; else goto c6yHj;
       c6yHi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yHj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fail_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4q_entry() //  [R1]
         { info_tbl: [(c6yHo,
                       label: sat_s6v4q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yHo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yHp; else goto c6yHq;
       c6yHp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yHq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4p_entry() //  [R1]
         { info_tbl: [(c6yHv,
                       label: sat_s6v4p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yHv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yHw; else goto c6yHx;
       c6yHw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yHx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4o_entry() //  [R1]
         { info_tbl: [(c6yHC,
                       label: sat_s6v4o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yHC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yHD; else goto c6yHE;
       c6yHD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yHE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4n_entry() //  [R1]
         { info_tbl: [(c6yHJ,
                       label: sat_s6v4n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yHJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yHK; else goto c6yHL;
       c6yHK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yHL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadAlt_entry() //  [R2]
         { info_tbl: [(c6yHN,
                       label: Data.Semigroup.Internal.$fMonadAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yHN: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c6yHR; else goto c6yHQ;
       c6yHR: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yHQ: // global
           I64[Hp - 160] = sat_s6v4r_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4q_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4p_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4o_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6v4n_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.567169148 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_info;
 },
 sat_s6v4t_entry() //  [R1]
         { info_tbl: [(c6yIu,
                       label: sat_s6v4t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yIu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yIv; else goto c6yIw;
       c6yIv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yIw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_entry() //  [R2]
         { info_tbl: [(c6yIx,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yIx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yIB; else goto c6yIA;
       c6yIB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yIA: // global
           I64[Hp - 16] = sat_s6v4t_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.573120576 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_info;
 },
 sat_s6v4y_entry() //  [R1]
         { info_tbl: [(c6yIS,
                       label: sat_s6v4y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yIS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yIT; else goto c6yIU;
       c6yIT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yIU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mplus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4x_entry() //  [R1]
         { info_tbl: [(c6yIZ,
                       label: sat_s6v4x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yIZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yJ0; else goto c6yJ1;
       c6yJ0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yJ1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4w_entry() //  [R1]
         { info_tbl: [(c6yJ6,
                       label: sat_s6v4w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yJ7; else goto c6yJ8;
       c6yJ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yJ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4v_entry() //  [R1]
         { info_tbl: [(c6yJd,
                       label: sat_s6v4v_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yJd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yJe; else goto c6yJf;
       c6yJe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yJf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_entry() //  [R2]
         { info_tbl: [(c6yJh,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yJh: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6yJl; else goto c6yJk;
       c6yJl: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yJk: // global
           I64[Hp - 128] = sat_s6v4y_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v4x_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v4w_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v4v_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.586522039 UTC

[section ""data" . Data.Semigroup.Internal.$fEnumAlt_closure" {
     Data.Semigroup.Internal.$fEnumAlt_closure:
         const Data.Semigroup.Internal.$fEnumAlt_info;
 },
 sat_s6v4H_entry() //  [R1]
         { info_tbl: [(c6yJT,
                       label: sat_s6v4H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yJT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yJU; else goto c6yJV;
       c6yJU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yJV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4G_entry() //  [R1]
         { info_tbl: [(c6yK0,
                       label: sat_s6v4G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yK0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yK1; else goto c6yK2;
       c6yK1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yK2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4F_entry() //  [R1]
         { info_tbl: [(c6yK7,
                       label: sat_s6v4F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yK7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yK8; else goto c6yK9;
       c6yK8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yK9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4E_entry() //  [R1]
         { info_tbl: [(c6yKe,
                       label: sat_s6v4E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yKe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yKf; else goto c6yKg;
       c6yKf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yKg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4D_entry() //  [R1]
         { info_tbl: [(c6yKl,
                       label: sat_s6v4D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yKl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yKm; else goto c6yKn;
       c6yKm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yKn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4C_entry() //  [R1]
         { info_tbl: [(c6yKs,
                       label: sat_s6v4C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yKs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yKt; else goto c6yKu;
       c6yKt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yKu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4B_entry() //  [R1]
         { info_tbl: [(c6yKz,
                       label: sat_s6v4B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yKz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yKA; else goto c6yKB;
       c6yKA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yKB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4A_entry() //  [R1]
         { info_tbl: [(c6yKG,
                       label: sat_s6v4A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yKG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yKH; else goto c6yKI;
       c6yKH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yKI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEnumAlt_entry() //  [R2]
         { info_tbl: [(c6yKK,
                       label: Data.Semigroup.Internal.$fEnumAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yKK: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6yKO; else goto c6yKN;
       c6yKO: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEnumAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yKN: // global
           I64[Hp - 256] = sat_s6v4H_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v4G_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v4F_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v4E_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v4D_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4C_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4B_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4A_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.606480866 UTC

[section ""data" . Data.Semigroup.Internal.$fNumAlt_closure" {
     Data.Semigroup.Internal.$fNumAlt_closure:
         const Data.Semigroup.Internal.$fNumAlt_info;
 },
 sat_s6v4P_entry() //  [R1]
         { info_tbl: [(c6yLG,
                       label: sat_s6v4P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yLG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yLH; else goto c6yLI;
       c6yLH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yLI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4O_entry() //  [R1]
         { info_tbl: [(c6yLN,
                       label: sat_s6v4O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yLN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yLO; else goto c6yLP;
       c6yLO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yLP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4N_entry() //  [R1]
         { info_tbl: [(c6yLU,
                       label: sat_s6v4N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yLU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yLV; else goto c6yLW;
       c6yLV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yLW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4M_entry() //  [R1]
         { info_tbl: [(c6yM1,
                       label: sat_s6v4M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yM1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yM2; else goto c6yM3;
       c6yM2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yM3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4L_entry() //  [R1]
         { info_tbl: [(c6yM8,
                       label: sat_s6v4L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yM8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yM9; else goto c6yMa;
       c6yM9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yMa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4K_entry() //  [R1]
         { info_tbl: [(c6yMf,
                       label: sat_s6v4K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yMf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yMg; else goto c6yMh;
       c6yMg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yMh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4J_entry() //  [R1]
         { info_tbl: [(c6yMm,
                       label: sat_s6v4J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yMm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yMn; else goto c6yMo;
       c6yMn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yMo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumAlt_entry() //  [R2]
         { info_tbl: [(c6yMq,
                       label: Data.Semigroup.Internal.$fNumAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yMq: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6yMu; else goto c6yMt;
       c6yMu: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yMt: // global
           I64[Hp - 224] = sat_s6v4P_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6v4O_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6v4N_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6v4M_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6v4L_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v4K_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v4J_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.624679069 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAlt_closure" {
     Data.Semigroup.Internal.$fEqAlt_closure:
         const Data.Semigroup.Internal.$fEqAlt_info;
 },
 sat_s6v4S_entry() //  [R1]
         { info_tbl: [(c6yNh,
                       label: sat_s6v4S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yNh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yNi; else goto c6yNj;
       c6yNi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yNj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4R_entry() //  [R1]
         { info_tbl: [(c6yNo,
                       label: sat_s6v4R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yNo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yNp; else goto c6yNq;
       c6yNp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yNq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqAlt_entry() //  [R2]
         { info_tbl: [(c6yNs,
                       label: Data.Semigroup.Internal.$fEqAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yNs: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6yNw; else goto c6yNv;
       c6yNw: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yNv: // global
           I64[Hp - 64] = sat_s6v4S_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v4R_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.633529188 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_info;
 },
 sat_s6v4U_entry() //  [R1]
         { info_tbl: [(c6yNU,
                       label: sat_s6v4U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yNU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yNV; else goto c6yNW;
       c6yNV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yNW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6yNX,
                       label: Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yNX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yO1; else goto c6yO0;
       c6yO1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yO0: // global
           I64[Hp - 16] = sat_s6v4U_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.640032549 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAlt_closure" {
     Data.Semigroup.Internal.$fOrdAlt_closure:
         const Data.Semigroup.Internal.$fOrdAlt_info;
 },
 sat_s6v53_entry() //  [R1]
         { info_tbl: [(c6yOi,
                       label: sat_s6v53_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yOi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yOj; else goto c6yOk;
       c6yOj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yOk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v52_entry() //  [R1]
         { info_tbl: [(c6yOp,
                       label: sat_s6v52_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yOp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yOq; else goto c6yOr;
       c6yOq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yOr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v51_entry() //  [R1]
         { info_tbl: [(c6yOw,
                       label: sat_s6v51_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yOw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yOx; else goto c6yOy;
       c6yOx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yOy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v50_entry() //  [R1]
         { info_tbl: [(c6yOD,
                       label: sat_s6v50_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yOD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yOE; else goto c6yOF;
       c6yOE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yOF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4Z_entry() //  [R1]
         { info_tbl: [(c6yOK,
                       label: sat_s6v4Z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yOK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yOL; else goto c6yOM;
       c6yOL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yOM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4Y_entry() //  [R1]
         { info_tbl: [(c6yOR,
                       label: sat_s6v4Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yOR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yOS; else goto c6yOT;
       c6yOS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yOT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4X_entry() //  [R1]
         { info_tbl: [(c6yOY,
                       label: sat_s6v4X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yOY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yOZ; else goto c6yP0;
       c6yOZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yP0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v4W_entry() //  [R1]
         { info_tbl: [(c6yP5,
                       label: sat_s6v4W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yP5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yP6; else goto c6yP7;
       c6yP6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yP7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdAlt_entry() //  [R2]
         { info_tbl: [(c6yP9,
                       label: Data.Semigroup.Internal.$fOrdAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yP9: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6yPd; else goto c6yPc;
       c6yPd: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yPc: // global
           I64[Hp - 256] = sat_s6v53_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v52_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v51_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v50_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v4Z_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v4Y_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v4X_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v4W_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.659944024 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt1_closure" {
     Data.Semigroup.Internal.$fShowAlt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.661694462 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAlt3_bytes" {
     Data.Semigroup.Internal.$fShowAlt3_bytes:
         I8[] [65,108,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.663323624 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAlt2_bytes" {
     Data.Semigroup.Internal.$fShowAlt2_bytes:
         I8[] [103,101,116,65,108,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.664958674 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll5_bytes" {
     Data.Semigroup.Internal.$fReadAll5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.668835214 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec1_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec1_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec1_info;
 },
 f1_s6v57_entry() //  [R1]
         { info_tbl: [(c6yQ9,
                       label: f1_s6v57_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yQ9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6yQa; else goto c6yQb;
       c6yQa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yQb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6v5a_entry() //  [R1]
         { info_tbl: [(c6yQw,
                       label: sat_s6v5a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yQw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yQx; else goto c6yQy;
       c6yQx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yQy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5b_entry() //  [R1]
         { info_tbl: [(c6yQz,
                       label: sat_s6v5b_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yQz: // global
           _s6v5b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6yQA; else goto c6yQB;
       c6yQB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yQD; else goto c6yQC;
       c6yQD: // global
           HpAlloc = 24;
           goto c6yQA;
       c6yQA: // global
           R1 = _s6v5b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yQC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5b::P64;
           _s6v57::P64 = P64[_s6v5b::P64 + 16];
           _s6v59::P64 = P64[_s6v5b::P64 + 24];
           I64[Hp - 16] = sat_s6v5a_info;
           P64[Hp] = _s6v59::P64;
           R2 = Hp - 16;
           R1 = _s6v57::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5c_entry() //  [R1]
         { info_tbl: [(c6yQE,
                       label: sat_s6v5c_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yQE: // global
           _s6v5c::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6yQF; else goto c6yQG;
       c6yQG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yQI; else goto c6yQH;
       c6yQI: // global
           HpAlloc = 32;
           goto c6yQF;
       c6yQF: // global
           R1 = _s6v5c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yQH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5c::P64;
           _s6v57::P64 = P64[_s6v5c::P64 + 16];
           _s6v59::P64 = P64[_s6v5c::P64 + 24];
           I64[Hp - 24] = sat_s6v5b_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = _s6v59::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5d_entry() //  [R1, R2]
         { info_tbl: [(c6yQJ,
                       label: sat_s6v5d_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yQJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yQN; else goto c6yQM;
       c6yQN: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yQM: // global
           _s6v57::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v5c_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5g_entry() //  [R1]
         { info_tbl: [(c6yRb,
                       label: sat_s6v5g_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yRb: // global
           _s6v5g::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6yRc; else goto c6yRd;
       c6yRd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yRf; else goto c6yRe;
       c6yRf: // global
           HpAlloc = 24;
           goto c6yRc;
       c6yRc: // global
           R1 = _s6v5g::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yRe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5g::P64;
           _s6v5e::P64 = P64[_s6v5g::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v5e::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5h_entry() //  [R1]
         { info_tbl: [(c6yRg,
                       label: sat_s6v5h_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yRg: // global
           _s6v5h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6yRh; else goto c6yRi;
       c6yRi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yRk; else goto c6yRj;
       c6yRk: // global
           HpAlloc = 24;
           goto c6yRh;
       c6yRh: // global
           R1 = _s6v5h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yRj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5h::P64;
           _s6v57::P64 = P64[_s6v5h::P64 + 16];
           _s6v5e::P64 = P64[_s6v5h::P64 + 24];
           I64[Hp - 16] = sat_s6v5g_info;
           P64[Hp] = _s6v5e::P64;
           R2 = Hp - 16;
           R1 = _s6v57::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5i_entry() //  [R1]
         { info_tbl: [(c6yRl,
                       label: sat_s6v5i_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yRl: // global
           _s6v5i::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6yRm; else goto c6yRn;
       c6yRn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yRp; else goto c6yRo;
       c6yRp: // global
           HpAlloc = 32;
           goto c6yRm;
       c6yRm: // global
           R1 = _s6v5i::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yRo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5i::P64;
           _s6v57::P64 = P64[_s6v5i::P64 + 16];
           _s6v5e::P64 = P64[_s6v5i::P64 + 24];
           I64[Hp - 24] = sat_s6v5h_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = _s6v5e::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5j_entry() //  [R1]
         { info_tbl: [(c6yRq,
                       label: sat_s6v5j_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yRq: // global
           _s6v5j::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6yRr; else goto c6yRs;
       c6yRs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yRu; else goto c6yRt;
       c6yRu: // global
           HpAlloc = 32;
           goto c6yRr;
       c6yRr: // global
           R1 = _s6v5j::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yRt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5j::P64;
           _s6v57::P64 = P64[_s6v5j::P64 + 16];
           _s6v5e::P64 = P64[_s6v5j::P64 + 24];
           I64[Hp - 24] = sat_s6v5i_info;
           P64[Hp - 8] = _s6v57::P64;
           P64[Hp] = _s6v5e::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v5k_entry() //  [R1, R2]
         { info_tbl: [(c6yRw,
                       label: sat_s6v5k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yRw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6yRA; else goto c6yRz;
       c6yRA: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yRz: // global
           _s6v57::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6v5j_info;
           P64[Hp - 32] = _s6v57::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6yRE,
                       label: Data.Semigroup.Internal.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yRE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6yRI; else goto c6yRH;
       c6yRI: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yRH: // global
           I64[Hp - 40] = f1_s6v57_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6yQ5::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6yRC; else goto c6yRD;
       c6yRC: // global
           I64[Hp - 8] = sat_s6v5d_info;
           P64[Hp] = _c6yQ5::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6yRD: // global
           I64[Hp - 8] = sat_s6v5k_info;
           P64[Hp] = _c6yQ5::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.695420277 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6ySB,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ySB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6ySC; else goto c6ySD;
       c6ySC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ySD: // global
           I64[Sp - 24] = block_c6ySy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6ySH; else goto c6ySz;
       u6ySH: // global
           call _c6ySy(R1) args: 0, res: 0, upd: 0;
       c6ySz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ySy() //  [R1]
         { info_tbl: [(c6ySy,
                       label: block_c6ySy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ySy: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.701437325 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll4_closure" {
     Data.Semigroup.Internal.$fReadAll4_closure:
         const Data.Semigroup.Internal.$fReadAll4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll4_entry() //  [R1]
         { info_tbl: [(c6ySX,
                       label: Data.Semigroup.Internal.$fReadAll4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ySX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ySY; else goto c6ySZ;
       c6ySY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ySZ: // global
           (_c6ySU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6ySU::I64 == 0) goto c6ySW; else goto c6ySV;
       c6ySW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6ySV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6ySU::I64;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.706612229 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshow_info;
         const 0;
 },
 sat_s6v5s_entry() //  [R1]
         { info_tbl: [(c6yTj,
                       label: sat_s6v5s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yTj: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6yTk; else goto c6yTl;
       c6yTk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yTl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6v5t_entry() //  [R1]
         { info_tbl: [(c6yTm,
                       label: sat_s6v5t_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yTm: // global
           _s6v5t::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6yTn; else goto c6yTo;
       c6yTo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yTq; else goto c6yTp;
       c6yTq: // global
           HpAlloc = 32;
           goto c6yTn;
       c6yTn: // global
           R1 = _s6v5t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yTp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v5t::P64;
           _s6v5q::P64 = P64[_s6v5t::P64 + 16];
           _s6v5r::P64 = P64[_s6v5t::P64 + 24];
           I64[Hp - 24] = sat_s6v5s_info;
           P64[Hp - 8] = _s6v5q::P64;
           P64[Hp] = _s6v5r::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6yTr,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yTr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yTv; else goto c6yTu;
       c6yTv: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yTu: // global
           I64[Hp - 24] = sat_s6v5t_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.715523491 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshowList_info;
 },
 sat_s6v5y_entry() //  [R1, R2]
         { info_tbl: [(c6yTS,
                       label: sat_s6v5y_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yTS: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c6yTV,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yTV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6yTZ; else goto c6yTY;
       c6yTZ: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yTY: // global
           I64[Hp - 8] = sat_s6v5y_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.721643715 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_closure" {
     Data.Semigroup.Internal.$fShowAlt_closure:
         const Data.Semigroup.Internal.$fShowAlt_info;
         const 0;
 },
 sat_s6v5C_entry() //  [R1, R2, R3]
         { info_tbl: [(c6yUg,
                       label: sat_s6v5C_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yUg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowAlt_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5B_entry() //  [R1, R2]
         { info_tbl: [(c6yUo,
                       label: sat_s6v5B_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yUo: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowAlt_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5A_entry() //  [R1, R2, R3]
         { info_tbl: [(c6yUw,
                       label: sat_s6v5A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yUw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_entry() //  [R2]
         { info_tbl: [(c6yUA,
                       label: Data.Semigroup.Internal.$fShowAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yUA: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6yUE; else goto c6yUD;
       c6yUE: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yUD: // global
           I64[Hp - 72] = sat_s6v5C_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v5B_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v5A_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.731004997 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAlt5_bytes" {
     Data.Semigroup.Internal.$fReadAlt5_bytes:
         I8[] [65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.733030407 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt4_closure" {
     Data.Semigroup.Internal.$fReadAlt4_closure:
         const Data.Semigroup.Internal.$fReadAlt4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAlt4_entry() //  [R1]
         { info_tbl: [(c6yV3,
                       label: Data.Semigroup.Internal.$fReadAlt4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yV3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yV4; else goto c6yV5;
       c6yV4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yV5: // global
           (_c6yV0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6yV0::I64 == 0) goto c6yV2; else goto c6yV1;
       c6yV2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6yV1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6yV0::I64;
           R2 = Data.Semigroup.Internal.$fReadAlt5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.737386435 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAlt_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAlt4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.739211586 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll11_bytes" {
     Data.Semigroup.Internal.$fReadAll11_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.741197528 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll10_closure" {
     Data.Semigroup.Internal.$fReadAll10_closure:
         const Data.Semigroup.Internal.$fReadAll10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll10_entry() //  [R1]
         { info_tbl: [(c6yVl,
                       label: Data.Semigroup.Internal.$fReadAll10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yVl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yVm; else goto c6yVn;
       c6yVm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yVn: // global
           (_c6yVi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6yVi::I64 == 0) goto c6yVk; else goto c6yVj;
       c6yVk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6yVj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6yVi::I64;
           R2 = Data.Semigroup.Internal.$fReadAll11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.745867657 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAll_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Semigroup.Internal.$fReadAll10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.747696651 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAlt3_bytes" {
     Data.Semigroup.Internal.$fReadAlt3_bytes:
         I8[] [103,101,116,65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.750249231 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt2_closure" {
     Data.Semigroup.Internal.$fReadAlt2_closure:
         const Data.Semigroup.Internal.$fReadAlt2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAlt2_entry() //  [R1]
         { info_tbl: [(c6yVD,
                       label: Data.Semigroup.Internal.$fReadAlt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yVD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yVE; else goto c6yVF;
       c6yVE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yVF: // global
           (_c6yVA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6yVA::I64 == 0) goto c6yVC; else goto c6yVB;
       c6yVC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6yVB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6yVA::I64;
           R2 = Data.Semigroup.Internal.$fReadAlt3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.754201387 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll6_closure" {
     Data.Semigroup.Internal.$fReadAll6_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.755994825 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll3_closure" {
     Data.Semigroup.Internal.$fReadAll3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.759521567 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt1_closure" {
     Data.Semigroup.Internal.$fReadAlt1_closure:
         const Data.Semigroup.Internal.$fReadAlt1_info;
         const 0;
 },
 lvl12_s6v5E_entry() //  [R1]
         { info_tbl: [(c6yVX,
                       label: lvl12_s6v5E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yVX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6yVY; else goto c6yVZ;
       c6yVY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yVZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6v5F_entry() //  [R1]
         { info_tbl: [(c6yW5,
                       label: ds_s6v5F_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yW5: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5Q_entry() //  [R1]
         { info_tbl: [(c6yWG,
                       label: sat_s6v5Q_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yWG: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5T_entry() //  [R1, R2]
         { info_tbl: [(c6yWM,
                       label: sat_s6v5T_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yWM: // global
           _s6v5O::P64 = R2;
           _s6v5T::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6yWN; else goto c6yWO;
       c6yWO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yWQ; else goto c6yWP;
       c6yWQ: // global
           HpAlloc = 24;
           goto c6yWN;
       c6yWN: // global
           R2 = _s6v5O::P64;
           R1 = _s6v5T::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yWP: // global
           _s6v5I::P64 = P64[_s6v5T::P64 + 7];
           I64[Hp - 16] = sat_s6v5Q_info;
           P64[Hp - 8] = _s6v5I::P64;
           P64[Hp] = _s6v5O::P64;
           I64[Sp - 8] = block_c6yWJ_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6yWJ() //  [R1]
         { info_tbl: [(c6yWJ,
                       label: block_c6yWJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yWJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6yWT; else goto c6yWS;
       c6yWT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yWS: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5U_entry() //  [R1, R2]
         { info_tbl: [(c6yWU,
                       label: sat_s6v5U_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yWU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6yWY; else goto c6yWX;
       c6yWY: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yWX: // global
           _s6v5F::P64 = P64[R1 + 7];
           _s6v5I::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6v5T_info;
           P64[Hp] = _s6v5I::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6v5F::P64;
           R2 = Data.Semigroup.Internal.$fReadAlt2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v5X_entry() //  [R1, R2]
         { info_tbl: [(c6yX2,
                       label: sat_s6v5X_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yX2: // global
           _s6v5M::P64 = R2;
           _s6v5X::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6yX3; else goto c6yX4;
       c6yX4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yX6; else goto c6yX5;
       c6yX6: // global
           HpAlloc = 24;
           goto c6yX3;
       c6yX3: // global
           R2 = _s6v5M::P64;
           R1 = _s6v5X::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yX5: // global
           _s6v5F::P64 = P64[_s6v5X::P64 + 7];
           _s6v5I::P64 = P64[_s6v5X::P64 + 15];
           I64[Hp - 16] = sat_s6v5U_info;
           P64[Hp - 8] = _s6v5F::P64;
           P64[Hp] = _s6v5I::P64;
           I64[Sp - 8] = block_c6yWZ_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6yWZ() //  [R1]
         { info_tbl: [(c6yWZ,
                       label: block_c6yWZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yWZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6yX9; else goto c6yX8;
       c6yX9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yX8: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v60_entry() //  [R1, R2, R3]
         { info_tbl: [(c6yXa,
                       label: sat_s6v60_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yXa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6yXb; else goto c6yXc;
       c6yXb: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6yXc: // global
           I64[Sp - 24] = block_c6yWd_info;
           _s6v5F::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6v5F::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6yXp; else goto c6yWe;
       u6yXp: // global
           call _c6yWd(R1) args: 0, res: 0, upd: 0;
       c6yWe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6yWd() //  [R1]
         { info_tbl: [(c6yWd,
                       label: block_c6yWd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yWd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yXf; else goto c6yXe;
       c6yXf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yXe: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6yXh; else goto c6yXl;
       c6yXh: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6yXl: // global
           I64[Hp - 16] = sat_s6v5X_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6yXi_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAlt_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6yXi() //  [R1]
         { info_tbl: [(c6yXi,
                       label: block_c6yXi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yXi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6yXo; else goto c6yXn;
       c6yXo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6yXn: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt1_entry() //  [R2]
         { info_tbl: [(c6yXq,
                       label: Data.Semigroup.Internal.$fReadAlt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yXq: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6yXu; else goto c6yXt;
       c6yXu: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yXt: // global
           I64[Hp - 48] = lvl12_s6v5E_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6v5F_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6v60_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.786844729 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadsPrec_info;
         const 0;
 },
 ds_s6v62_entry() //  [R1]
         { info_tbl: [(c6yYr,
                       label: ds_s6v62_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yYr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yYs; else goto c6yYt;
       c6yYs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yYt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v64_entry() //  [R1]
         { info_tbl: [(c6yYD,
                       label: sat_s6v64_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yYD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6yYE; else goto c6yYF;
       c6yYE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yYF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v65_entry() //  [R1, R2]
         { info_tbl: [(c6yYG,
                       label: sat_s6v65_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yYG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6yYK; else goto c6yYJ;
       c6yYK: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yYJ: // global
           _s6v62::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v64_info;
           P64[Hp - 8] = _s6v62::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6yYL,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yYL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6yYP; else goto c6yYO;
       c6yYP: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yYO: // global
           I64[Hp - 32] = ds_s6v62_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6v65_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.799700901 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadListPrec_info;
         const 0;
 },
 sat_s6v67_entry() //  [R1]
         { info_tbl: [(c6yZf,
                       label: sat_s6v67_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yZf: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6yZi,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yZi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yZm; else goto c6yZl;
       c6yZm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yZl: // global
           I64[Hp - 16] = sat_s6v67_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.80785675 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadList_info;
         const 0;
 },
 sat_s6v69_entry() //  [R1]
         { info_tbl: [(c6yZG,
                       label: sat_s6v69_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yZG: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v6a_entry() //  [R1]
         { info_tbl: [(c6yZJ,
                       label: sat_s6v6a_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yZJ: // global
           _s6v6a::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6yZK; else goto c6yZL;
       c6yZL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yZN; else goto c6yZM;
       c6yZN: // global
           HpAlloc = 24;
           goto c6yZK;
       c6yZK: // global
           R1 = _s6v6a::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6yZM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6a::P64;
           _s6v68::P64 = P64[_s6v6a::P64 + 16];
           I64[Hp - 16] = sat_s6v69_info;
           P64[Hp] = _s6v68::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadList_entry() //  [R2]
         { info_tbl: [(c6yZO,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6yZO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6yZS; else goto c6yZR;
       c6yZS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6yZR: // global
           I64[Hp - 16] = sat_s6v6a_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.818586288 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_closure" {
     Data.Semigroup.Internal.$fReadAlt_closure:
         const Data.Semigroup.Internal.$fReadAlt_info;
         const 0;
 },
 sat_s6v6f_entry() //  [R1]
         { info_tbl: [(c6z0c,
                       label: sat_s6v6f_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z0c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z0d; else goto c6z0e;
       c6z0d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z0e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6e_entry() //  [R1]
         { info_tbl: [(c6z0j,
                       label: sat_s6v6e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z0j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z0k; else goto c6z0l;
       c6z0k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z0l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6d_entry() //  [R1]
         { info_tbl: [(c6z0q,
                       label: sat_s6v6d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z0q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z0r; else goto c6z0s;
       c6z0r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z0s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6c_entry() //  [R1]
         { info_tbl: [(c6z0x,
                       label: sat_s6v6c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z0x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z0y; else goto c6z0z;
       c6z0y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z0z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_entry() //  [R2]
         { info_tbl: [(c6z0B,
                       label: Data.Semigroup.Internal.$fReadAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z0B: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6z0F; else goto c6z0E;
       c6z0F: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6z0E: // global
           I64[Hp - 128] = sat_s6v6f_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v6e_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v6d_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v6c_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.831304999 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt1_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt1_closure:
         const Data.Semigroup.Internal.$fGeneric1Alt1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Alt1_entry() //  [R2]
         { info_tbl: [(c6z19,
                       label: Data.Semigroup.Internal.$fGeneric1Alt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z19: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.834585222 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt2_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt2_closure:
         const Data.Semigroup.Internal.$fGeneric1Alt2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Alt2_entry() //  [R2]
         { info_tbl: [(c6z1k,
                       label: Data.Semigroup.Internal.$fGeneric1Alt2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z1k: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.838018284 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Alt2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Alt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.839878414 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt1_closure" {
     Data.Semigroup.Internal.$fGenericAlt1_closure:
         const Data.Semigroup.Internal.$fGenericAlt1_info;
 },
 Data.Semigroup.Internal.$fGenericAlt1_entry() //  [R2]
         { info_tbl: [(c6z1w,
                       label: Data.Semigroup.Internal.$fGenericAlt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z1w: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.843197761 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt2_closure" {
     Data.Semigroup.Internal.$fGenericAlt2_closure:
         const Data.Semigroup.Internal.$fGenericAlt2_info;
 },
 Data.Semigroup.Internal.$fGenericAlt2_entry() //  [R2]
         { info_tbl: [(c6z1H,
                       label: Data.Semigroup.Internal.$fGenericAlt2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z1H: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.84649064 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt_closure" {
     Data.Semigroup.Internal.$fGenericAlt_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAlt2_closure+1;
         const Data.Semigroup.Internal.$fGenericAlt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.84936327 UTC

[section ""data" . Data.Semigroup.Internal.$fNumProduct_closure" {
     Data.Semigroup.Internal.$fNumProduct_closure:
         const Data.Semigroup.Internal.$fNumProduct_info;
 },
 sat_s6v6r_entry() //  [R1]
         { info_tbl: [(c6z1X,
                       label: sat_s6v6r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z1X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z1Y; else goto c6z1Z;
       c6z1Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z1Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6q_entry() //  [R1]
         { info_tbl: [(c6z24,
                       label: sat_s6v6q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z24: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z25; else goto c6z26;
       c6z25: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z26: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6p_entry() //  [R1]
         { info_tbl: [(c6z2b,
                       label: sat_s6v6p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z2b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z2c; else goto c6z2d;
       c6z2c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z2d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6o_entry() //  [R1]
         { info_tbl: [(c6z2i,
                       label: sat_s6v6o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z2j; else goto c6z2k;
       c6z2j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z2k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6n_entry() //  [R1]
         { info_tbl: [(c6z2p,
                       label: sat_s6v6n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z2p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z2q; else goto c6z2r;
       c6z2q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z2r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6m_entry() //  [R1]
         { info_tbl: [(c6z2w,
                       label: sat_s6v6m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z2w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z2x; else goto c6z2y;
       c6z2x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z2y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6l_entry() //  [R1]
         { info_tbl: [(c6z2D,
                       label: sat_s6v6l_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z2D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z2E; else goto c6z2F;
       c6z2E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z2F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumProduct_entry() //  [R2]
         { info_tbl: [(c6z2H,
                       label: Data.Semigroup.Internal.$fNumProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z2H: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6z2L; else goto c6z2K;
       c6z2L: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6z2K: // global
           I64[Hp - 224] = sat_s6v6r_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6v6q_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6v6p_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6v6o_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6v6n_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v6m_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v6l_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.867382679 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product1_closure" {
     Data.Semigroup.Internal.$fGeneric1Product1_closure:
         const Data.Semigroup.Internal.$fGeneric1Product1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Product1_entry() //  [R2]
         { info_tbl: [(c6z3u,
                       label: Data.Semigroup.Internal.$fGeneric1Product1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z3u: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.871296733 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product2_closure" {
     Data.Semigroup.Internal.$fGeneric1Product2_closure:
         const Data.Semigroup.Internal.$fGeneric1Product2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Product2_entry() //  [R2]
         { info_tbl: [(c6z3F,
                       label: Data.Semigroup.Internal.$fGeneric1Product2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z3F: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.874692519 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product_closure" {
     Data.Semigroup.Internal.$fGeneric1Product_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Product2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Product1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.877094094 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct1_closure" {
     Data.Semigroup.Internal.$fGenericProduct1_closure:
         const Data.Semigroup.Internal.$fGenericProduct1_info;
 },
 Data.Semigroup.Internal.$fGenericProduct1_entry() //  [R2]
         { info_tbl: [(c6z3R,
                       label: Data.Semigroup.Internal.$fGenericProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z3R: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.880510526 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct2_closure" {
     Data.Semigroup.Internal.$fGenericProduct2_closure:
         const Data.Semigroup.Internal.$fGenericProduct2_info;
 },
 Data.Semigroup.Internal.$fGenericProduct2_entry() //  [R2]
         { info_tbl: [(c6z42,
                       label: Data.Semigroup.Internal.$fGenericProduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z42: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.883763327 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct_closure" {
     Data.Semigroup.Internal.$fGenericProduct_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericProduct2_closure+1;
         const Data.Semigroup.Internal.$fGenericProduct1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.886448786 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedProduct_closure" {
     Data.Semigroup.Internal.$fBoundedProduct_closure:
         const Data.Semigroup.Internal.$fBoundedProduct_info;
 },
 sat_s6v6y_entry() //  [R1]
         { info_tbl: [(c6z4i,
                       label: sat_s6v6y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z4i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z4j; else goto c6z4k;
       c6z4j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z4k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6x_entry() //  [R1]
         { info_tbl: [(c6z4p,
                       label: sat_s6v6x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z4p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z4q; else goto c6z4r;
       c6z4q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z4r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedProduct_entry() //  [R2]
         { info_tbl: [(c6z4t,
                       label: Data.Semigroup.Internal.$fBoundedProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z4t: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6z4x; else goto c6z4w;
       c6z4x: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6z4w: // global
           I64[Hp - 64] = sat_s6v6y_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v6x_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.893955697 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowProduct2_bytes" {
     Data.Semigroup.Internal.$fShowProduct2_bytes:
         I8[] [80,114,111,100,117,99,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.895806697 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowProduct1_bytes" {
     Data.Semigroup.Internal.$fShowProduct1_bytes:
         I8[] [103,101,116,80,114,111,100,117,99,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.899981095 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec4_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec4_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec4_info;
 },
 f_s6v6C_entry() //  [R1]
         { info_tbl: [(c6z4X,
                       label: f_s6v6C_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z4X: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6z4Y; else goto c6z4Z;
       c6z4Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z4Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6v6F_entry() //  [R1]
         { info_tbl: [(c6z5k,
                       label: sat_s6v6F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z5k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z5l; else goto c6z5m;
       c6z5l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z5m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6G_entry() //  [R1]
         { info_tbl: [(c6z5n,
                       label: sat_s6v6G_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z5n: // global
           _s6v6G::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6z5o; else goto c6z5p;
       c6z5p: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6z5r; else goto c6z5q;
       c6z5r: // global
           HpAlloc = 24;
           goto c6z5o;
       c6z5o: // global
           R1 = _s6v6G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z5q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6G::P64;
           _s6v6C::P64 = P64[_s6v6G::P64 + 16];
           _s6v6E::P64 = P64[_s6v6G::P64 + 24];
           I64[Hp - 16] = sat_s6v6F_info;
           P64[Hp] = _s6v6E::P64;
           R2 = Hp - 16;
           R1 = _s6v6C::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6H_entry() //  [R1]
         { info_tbl: [(c6z5s,
                       label: sat_s6v6H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z5s: // global
           _s6v6H::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6z5t; else goto c6z5u;
       c6z5u: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6z5w; else goto c6z5v;
       c6z5w: // global
           HpAlloc = 32;
           goto c6z5t;
       c6z5t: // global
           R1 = _s6v6H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z5v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6H::P64;
           _s6v6C::P64 = P64[_s6v6H::P64 + 16];
           _s6v6E::P64 = P64[_s6v6H::P64 + 24];
           I64[Hp - 24] = sat_s6v6G_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = _s6v6E::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6I_entry() //  [R1, R2]
         { info_tbl: [(c6z5x,
                       label: sat_s6v6I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z5x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6z5B; else goto c6z5A;
       c6z5B: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6z5A: // global
           _s6v6C::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v6H_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v6L_entry() //  [R1]
         { info_tbl: [(c6z5Z,
                       label: sat_s6v6L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z5Z: // global
           _s6v6L::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6z60; else goto c6z61;
       c6z61: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6z63; else goto c6z62;
       c6z63: // global
           HpAlloc = 24;
           goto c6z60;
       c6z60: // global
           R1 = _s6v6L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z62: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6L::P64;
           _s6v6J::P64 = P64[_s6v6L::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v6J::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6M_entry() //  [R1]
         { info_tbl: [(c6z64,
                       label: sat_s6v6M_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z64: // global
           _s6v6M::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6z65; else goto c6z66;
       c6z66: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6z68; else goto c6z67;
       c6z68: // global
           HpAlloc = 24;
           goto c6z65;
       c6z65: // global
           R1 = _s6v6M::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z67: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6M::P64;
           _s6v6C::P64 = P64[_s6v6M::P64 + 16];
           _s6v6J::P64 = P64[_s6v6M::P64 + 24];
           I64[Hp - 16] = sat_s6v6L_info;
           P64[Hp] = _s6v6J::P64;
           R2 = Hp - 16;
           R1 = _s6v6C::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6N_entry() //  [R1]
         { info_tbl: [(c6z69,
                       label: sat_s6v6N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z69: // global
           _s6v6N::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6z6a; else goto c6z6b;
       c6z6b: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6z6d; else goto c6z6c;
       c6z6d: // global
           HpAlloc = 32;
           goto c6z6a;
       c6z6a: // global
           R1 = _s6v6N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z6c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6N::P64;
           _s6v6C::P64 = P64[_s6v6N::P64 + 16];
           _s6v6J::P64 = P64[_s6v6N::P64 + 24];
           I64[Hp - 24] = sat_s6v6M_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = _s6v6J::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6O_entry() //  [R1]
         { info_tbl: [(c6z6e,
                       label: sat_s6v6O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z6e: // global
           _s6v6O::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6z6f; else goto c6z6g;
       c6z6g: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6z6i; else goto c6z6h;
       c6z6i: // global
           HpAlloc = 32;
           goto c6z6f;
       c6z6f: // global
           R1 = _s6v6O::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z6h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6O::P64;
           _s6v6C::P64 = P64[_s6v6O::P64 + 16];
           _s6v6J::P64 = P64[_s6v6O::P64 + 24];
           I64[Hp - 24] = sat_s6v6N_info;
           P64[Hp - 8] = _s6v6C::P64;
           P64[Hp] = _s6v6J::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v6P_entry() //  [R1, R2]
         { info_tbl: [(c6z6k,
                       label: sat_s6v6P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z6k: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6z6o; else goto c6z6n;
       c6z6o: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6z6n: // global
           _s6v6C::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6v6O_info;
           P64[Hp - 32] = _s6v6C::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec4_entry() //  [R2, R3, R4]
         { info_tbl: [(c6z6s,
                       label: Data.Semigroup.Internal.$w$cshowsPrec4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z6s: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6z6w; else goto c6z6v;
       c6z6w: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6z6v: // global
           I64[Hp - 40] = f_s6v6C_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6z4T::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6z6q; else goto c6z6r;
       c6z6q: // global
           I64[Hp - 8] = sat_s6v6I_info;
           P64[Hp] = _c6z4T::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6z6r: // global
           I64[Hp - 8] = sat_s6v6P_info;
           P64[Hp] = _c6z4T::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.926559282 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c6z7p,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z7p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6z7q; else goto c6z7r;
       c6z7q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6z7r: // global
           I64[Sp - 24] = block_c6z7m_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6z7v; else goto c6z7n;
       u6z7v: // global
           call _c6z7m(R1) args: 0, res: 0, upd: 0;
       c6z7n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6z7m() //  [R1]
         { info_tbl: [(c6z7m,
                       label: block_c6z7m_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z7m: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.932717472 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshow_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshow_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshow_info;
         const 0;
 },
 sat_s6v6X_entry() //  [R1]
         { info_tbl: [(c6z7R,
                       label: sat_s6v6X_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z7R: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6z7S; else goto c6z7T;
       c6z7S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z7T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6v6Y_entry() //  [R1]
         { info_tbl: [(c6z7U,
                       label: sat_s6v6Y_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z7U: // global
           _s6v6Y::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6z7V; else goto c6z7W;
       c6z7W: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6z7Y; else goto c6z7X;
       c6z7Y: // global
           HpAlloc = 32;
           goto c6z7V;
       c6z7V: // global
           R1 = _s6v6Y::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z7X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v6Y::P64;
           _s6v6V::P64 = P64[_s6v6Y::P64 + 16];
           _s6v6W::P64 = P64[_s6v6Y::P64 + 24];
           I64[Hp - 24] = sat_s6v6X_info;
           P64[Hp - 8] = _s6v6V::P64;
           P64[Hp] = _s6v6W::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6z7Z,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z7Z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6z83; else goto c6z82;
       c6z83: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6z82: // global
           I64[Hp - 24] = sat_s6v6Y_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.941018051 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshowList_info;
 },
 sat_s6v73_entry() //  [R1, R2]
         { info_tbl: [(c6z8q,
                       label: sat_s6v73_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z8q: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_$cshowList_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c6z8t,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z8t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6z8x; else goto c6z8w;
       c6z8x: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6z8w: // global
           I64[Hp - 8] = sat_s6v73_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.947882292 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_closure" {
     Data.Semigroup.Internal.$fShowProduct_closure:
         const Data.Semigroup.Internal.$fShowProduct_info;
         const 0;
 },
 sat_s6v77_entry() //  [R1, R2, R3]
         { info_tbl: [(c6z8O,
                       label: sat_s6v77_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z8O: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowProduct_$cshowList_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v76_entry() //  [R1, R2]
         { info_tbl: [(c6z8W,
                       label: sat_s6v76_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z8W: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowProduct_$cshow_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v75_entry() //  [R1, R2, R3]
         { info_tbl: [(c6z94,
                       label: sat_s6v75_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z94: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_entry() //  [R2]
         { info_tbl: [(c6z98,
                       label: Data.Semigroup.Internal.$fShowProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z98: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6z9c; else goto c6z9b;
       c6z9c: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6z9b: // global
           I64[Hp - 72] = sat_s6v77_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v76_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v75_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.956354034 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadProduct5_bytes" {
     Data.Semigroup.Internal.$fReadProduct5_bytes:
         I8[] [80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.9586338 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct4_closure" {
     Data.Semigroup.Internal.$fReadProduct4_closure:
         const Data.Semigroup.Internal.$fReadProduct4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadProduct4_entry() //  [R1]
         { info_tbl: [(c6z9B,
                       label: Data.Semigroup.Internal.$fReadProduct4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z9B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z9C; else goto c6z9D;
       c6z9C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z9D: // global
           (_c6z9y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6z9y::I64 == 0) goto c6z9A; else goto c6z9z;
       c6z9A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6z9z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6z9y::I64;
           R2 = Data.Semigroup.Internal.$fReadProduct5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.962684971 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_lexeme_closure" {
     Data.Semigroup.Internal.$fReadProduct_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadProduct4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.964429849 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadProduct3_bytes" {
     Data.Semigroup.Internal.$fReadProduct3_bytes:
         I8[] [103,101,116,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.966350358 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct2_closure" {
     Data.Semigroup.Internal.$fReadProduct2_closure:
         const Data.Semigroup.Internal.$fReadProduct2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadProduct2_entry() //  [R1]
         { info_tbl: [(c6z9T,
                       label: Data.Semigroup.Internal.$fReadProduct2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6z9T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6z9U; else goto c6z9V;
       c6z9U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6z9V: // global
           (_c6z9Q::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6z9Q::I64 == 0) goto c6z9S; else goto c6z9R;
       c6z9S: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6z9R: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6z9Q::I64;
           R2 = Data.Semigroup.Internal.$fReadProduct3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.972696762 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct1_closure" {
     Data.Semigroup.Internal.$fReadProduct1_closure:
         const Data.Semigroup.Internal.$fReadProduct1_info;
         const 0;
 },
 lvl12_s6v79_entry() //  [R1]
         { info_tbl: [(c6zab,
                       label: lvl12_s6v79_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zab: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6zac; else goto c6zad;
       c6zac: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zad: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6v7a_entry() //  [R1]
         { info_tbl: [(c6zaj,
                       label: ds_s6v7a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zaj: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7l_entry() //  [R1]
         { info_tbl: [(c6zaU,
                       label: sat_s6v7l_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zaU: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7o_entry() //  [R1, R2]
         { info_tbl: [(c6zb0,
                       label: sat_s6v7o_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zb0: // global
           _s6v7j::P64 = R2;
           _s6v7o::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6zb1; else goto c6zb2;
       c6zb2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zb4; else goto c6zb3;
       c6zb4: // global
           HpAlloc = 24;
           goto c6zb1;
       c6zb1: // global
           R2 = _s6v7j::P64;
           R1 = _s6v7o::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zb3: // global
           _s6v7d::P64 = P64[_s6v7o::P64 + 7];
           I64[Hp - 16] = sat_s6v7l_info;
           P64[Hp - 8] = _s6v7d::P64;
           P64[Hp] = _s6v7j::P64;
           I64[Sp - 8] = block_c6zaX_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zaX() //  [R1]
         { info_tbl: [(c6zaX,
                       label: block_c6zaX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zaX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zb7; else goto c6zb6;
       c6zb7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zb6: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7p_entry() //  [R1, R2]
         { info_tbl: [(c6zb8,
                       label: sat_s6v7p_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zb8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zbc; else goto c6zbb;
       c6zbc: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zbb: // global
           _s6v7a::P64 = P64[R1 + 7];
           _s6v7d::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6v7o_info;
           P64[Hp] = _s6v7d::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6v7a::P64;
           R2 = Data.Semigroup.Internal.$fReadProduct2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7s_entry() //  [R1, R2]
         { info_tbl: [(c6zbg,
                       label: sat_s6v7s_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zbg: // global
           _s6v7h::P64 = R2;
           _s6v7s::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6zbh; else goto c6zbi;
       c6zbi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zbk; else goto c6zbj;
       c6zbk: // global
           HpAlloc = 24;
           goto c6zbh;
       c6zbh: // global
           R2 = _s6v7h::P64;
           R1 = _s6v7s::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zbj: // global
           _s6v7a::P64 = P64[_s6v7s::P64 + 7];
           _s6v7d::P64 = P64[_s6v7s::P64 + 15];
           I64[Hp - 16] = sat_s6v7p_info;
           P64[Hp - 8] = _s6v7a::P64;
           P64[Hp] = _s6v7d::P64;
           I64[Sp - 8] = block_c6zbd_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zbd() //  [R1]
         { info_tbl: [(c6zbd,
                       label: block_c6zbd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zbd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zbn; else goto c6zbm;
       c6zbn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zbm: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7v_entry() //  [R1, R2, R3]
         { info_tbl: [(c6zbo,
                       label: sat_s6v7v_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zbo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6zbp; else goto c6zbq;
       c6zbp: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zbq: // global
           I64[Sp - 24] = block_c6zar_info;
           _s6v7a::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6v7a::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6zbD; else goto c6zas;
       u6zbD: // global
           call _c6zar(R1) args: 0, res: 0, upd: 0;
       c6zas: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6zar() //  [R1]
         { info_tbl: [(c6zar,
                       label: block_c6zar_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zar: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zbt; else goto c6zbs;
       c6zbt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zbs: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6zbv; else goto c6zbz;
       c6zbv: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6zbz: // global
           I64[Hp - 16] = sat_s6v7s_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6zbw_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadProduct_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zbw() //  [R1]
         { info_tbl: [(c6zbw,
                       label: block_c6zbw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zbw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zbC; else goto c6zbB;
       c6zbC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zbB: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct1_entry() //  [R2]
         { info_tbl: [(c6zbE,
                       label: Data.Semigroup.Internal.$fReadProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zbE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6zbI; else goto c6zbH;
       c6zbI: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zbH: // global
           I64[Hp - 48] = lvl12_s6v79_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6v7a_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6v7v_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:44.999322127 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadsPrec_info;
         const 0;
 },
 ds_s6v7x_entry() //  [R1]
         { info_tbl: [(c6zcF,
                       label: ds_s6v7x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zcF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zcG; else goto c6zcH;
       c6zcG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zcH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7z_entry() //  [R1]
         { info_tbl: [(c6zcR,
                       label: sat_s6v7z_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zcR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zcS; else goto c6zcT;
       c6zcS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zcT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7A_entry() //  [R1, R2]
         { info_tbl: [(c6zcU,
                       label: sat_s6v7A_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zcU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zcY; else goto c6zcX;
       c6zcY: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zcX: // global
           _s6v7x::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v7z_info;
           P64[Hp - 8] = _s6v7x::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6zcZ,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zcZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6zd3; else goto c6zd2;
       c6zd3: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zd2: // global
           I64[Hp - 32] = ds_s6v7x_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6v7A_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.008587771 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadListPrec_info;
         const 0;
 },
 sat_s6v7C_entry() //  [R1]
         { info_tbl: [(c6zdt,
                       label: sat_s6v7C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zdt: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6zdw,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zdw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zdA; else goto c6zdz;
       c6zdA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zdz: // global
           I64[Hp - 16] = sat_s6v7C_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.014487611 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadList_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadList_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadList_info;
         const 0;
 },
 sat_s6v7E_entry() //  [R1]
         { info_tbl: [(c6zdU,
                       label: sat_s6v7E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zdU: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v7F_entry() //  [R1]
         { info_tbl: [(c6zdX,
                       label: sat_s6v7F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zdX: // global
           _s6v7F::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6zdY; else goto c6zdZ;
       c6zdZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ze1; else goto c6ze0;
       c6ze1: // global
           HpAlloc = 24;
           goto c6zdY;
       c6zdY: // global
           R1 = _s6v7F::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ze0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v7F::P64;
           _s6v7D::P64 = P64[_s6v7F::P64 + 16];
           I64[Hp - 16] = sat_s6v7E_info;
           P64[Hp] = _s6v7D::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadList_entry() //  [R2]
         { info_tbl: [(c6ze2,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ze2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ze6; else goto c6ze5;
       c6ze6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ze5: // global
           I64[Hp - 16] = sat_s6v7F_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.023153793 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_closure" {
     Data.Semigroup.Internal.$fReadProduct_closure:
         const Data.Semigroup.Internal.$fReadProduct_info;
         const 0;
 },
 sat_s6v7K_entry() //  [R1]
         { info_tbl: [(c6zeq,
                       label: sat_s6v7K_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zeq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zer; else goto c6zes;
       c6zer: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zes: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7J_entry() //  [R1]
         { info_tbl: [(c6zex,
                       label: sat_s6v7J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zex: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zey; else goto c6zez;
       c6zey: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zez: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7I_entry() //  [R1]
         { info_tbl: [(c6zeE,
                       label: sat_s6v7I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zeE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zeF; else goto c6zeG;
       c6zeF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zeG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7H_entry() //  [R1]
         { info_tbl: [(c6zeL,
                       label: sat_s6v7H_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zeL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zeM; else goto c6zeN;
       c6zeM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zeN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_entry() //  [R2]
         { info_tbl: [(c6zeP,
                       label: Data.Semigroup.Internal.$fReadProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zeP: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6zeT; else goto c6zeS;
       c6zeT: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zeS: // global
           I64[Hp - 128] = sat_s6v7K_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v7J_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v7I_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v7H_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.034844513 UTC

[section ""data" . Data.Semigroup.Internal.$fEqProduct_closure" {
     Data.Semigroup.Internal.$fEqProduct_closure:
         const Data.Semigroup.Internal.$fEqProduct_info;
 },
 sat_s6v7N_entry() //  [R1]
         { info_tbl: [(c6zfr,
                       label: sat_s6v7N_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zfr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zfs; else goto c6zft;
       c6zfs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zft: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7M_entry() //  [R1]
         { info_tbl: [(c6zfy,
                       label: sat_s6v7M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zfy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zfz; else goto c6zfA;
       c6zfz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zfA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqProduct_entry() //  [R2]
         { info_tbl: [(c6zfC,
                       label: Data.Semigroup.Internal.$fEqProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zfC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6zfG; else goto c6zfF;
       c6zfG: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zfF: // global
           I64[Hp - 64] = sat_s6v7N_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v7M_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.043895541 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_info;
 },
 sat_s6v7P_entry() //  [R1]
         { info_tbl: [(c6zg4,
                       label: sat_s6v7P_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zg4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zg5; else goto c6zg6;
       c6zg5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zg6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6zg7,
                       label: Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zg7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zgb; else goto c6zga;
       c6zgb: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zga: // global
           I64[Hp - 16] = sat_s6v7P_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqProduct_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.051668661 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdProduct_closure" {
     Data.Semigroup.Internal.$fOrdProduct_closure:
         const Data.Semigroup.Internal.$fOrdProduct_info;
 },
 sat_s6v7Y_entry() //  [R1]
         { info_tbl: [(c6zgs,
                       label: sat_s6v7Y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zgs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zgt; else goto c6zgu;
       c6zgt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zgu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7X_entry() //  [R1]
         { info_tbl: [(c6zgz,
                       label: sat_s6v7X_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zgz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zgA; else goto c6zgB;
       c6zgA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zgB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7W_entry() //  [R1]
         { info_tbl: [(c6zgG,
                       label: sat_s6v7W_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zgG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zgH; else goto c6zgI;
       c6zgH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zgI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7V_entry() //  [R1]
         { info_tbl: [(c6zgN,
                       label: sat_s6v7V_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zgN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zgO; else goto c6zgP;
       c6zgO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zgP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7U_entry() //  [R1]
         { info_tbl: [(c6zgU,
                       label: sat_s6v7U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zgU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zgV; else goto c6zgW;
       c6zgV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zgW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7T_entry() //  [R1]
         { info_tbl: [(c6zh1,
                       label: sat_s6v7T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zh1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zh2; else goto c6zh3;
       c6zh2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zh3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7S_entry() //  [R1]
         { info_tbl: [(c6zh8,
                       label: sat_s6v7S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zh8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zh9; else goto c6zha;
       c6zh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zha: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v7R_entry() //  [R1]
         { info_tbl: [(c6zhf,
                       label: sat_s6v7R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zhf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zhg; else goto c6zhh;
       c6zhg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zhh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdProduct_entry() //  [R2]
         { info_tbl: [(c6zhj,
                       label: Data.Semigroup.Internal.$fOrdProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zhj: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6zhn; else goto c6zhm;
       c6zhn: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zhm: // global
           I64[Hp - 256] = sat_s6v7Y_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v7X_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v7W_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v7V_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v7U_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v7T_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v7S_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v7R_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.073057709 UTC

[section ""data" . Data.Semigroup.Internal.$fNumSum_closure" {
     Data.Semigroup.Internal.$fNumSum_closure:
         const Data.Semigroup.Internal.$fNumSum_info;
 },
 sat_s6v86_entry() //  [R1]
         { info_tbl: [(c6zif,
                       label: sat_s6v86_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zif: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zig; else goto c6zih;
       c6zig: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zih: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v85_entry() //  [R1]
         { info_tbl: [(c6zim,
                       label: sat_s6v85_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zim: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zin; else goto c6zio;
       c6zin: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zio: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v84_entry() //  [R1]
         { info_tbl: [(c6zit,
                       label: sat_s6v84_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zit: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ziu; else goto c6ziv;
       c6ziu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ziv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v83_entry() //  [R1]
         { info_tbl: [(c6ziA,
                       label: sat_s6v83_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ziA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ziB; else goto c6ziC;
       c6ziB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ziC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v82_entry() //  [R1]
         { info_tbl: [(c6ziH,
                       label: sat_s6v82_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ziH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ziI; else goto c6ziJ;
       c6ziI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ziJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v81_entry() //  [R1]
         { info_tbl: [(c6ziO,
                       label: sat_s6v81_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ziO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ziP; else goto c6ziQ;
       c6ziP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ziQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v80_entry() //  [R1]
         { info_tbl: [(c6ziV,
                       label: sat_s6v80_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ziV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ziW; else goto c6ziX;
       c6ziW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ziX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumSum_entry() //  [R2]
         { info_tbl: [(c6ziZ,
                       label: Data.Semigroup.Internal.$fNumSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ziZ: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6zj3; else goto c6zj2;
       c6zj3: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zj2: // global
           I64[Hp - 224] = sat_s6v86_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6v85_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6v84_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6v83_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6v82_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v81_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v80_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.091157807 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum1_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum1_closure:
         const Data.Semigroup.Internal.$fGeneric1Sum1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Sum1_entry() //  [R2]
         { info_tbl: [(c6zjM,
                       label: Data.Semigroup.Internal.$fGeneric1Sum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zjM: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.094713928 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum2_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum2_closure:
         const Data.Semigroup.Internal.$fGeneric1Sum2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Sum2_entry() //  [R2]
         { info_tbl: [(c6zjX,
                       label: Data.Semigroup.Internal.$fGeneric1Sum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zjX: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.098688161 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Sum2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Sum1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.100462358 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum1_closure" {
     Data.Semigroup.Internal.$fGenericSum1_closure:
         const Data.Semigroup.Internal.$fGenericSum1_info;
 },
 Data.Semigroup.Internal.$fGenericSum1_entry() //  [R2]
         { info_tbl: [(c6zk9,
                       label: Data.Semigroup.Internal.$fGenericSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zk9: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.103906548 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum2_closure" {
     Data.Semigroup.Internal.$fGenericSum2_closure:
         const Data.Semigroup.Internal.$fGenericSum2_info;
 },
 Data.Semigroup.Internal.$fGenericSum2_entry() //  [R2]
         { info_tbl: [(c6zkk,
                       label: Data.Semigroup.Internal.$fGenericSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zkk: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.107057542 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum_closure" {
     Data.Semigroup.Internal.$fGenericSum_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericSum2_closure+1;
         const Data.Semigroup.Internal.$fGenericSum1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.109270343 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedSum_closure" {
     Data.Semigroup.Internal.$fBoundedSum_closure:
         const Data.Semigroup.Internal.$fBoundedSum_info;
 },
 sat_s6v8d_entry() //  [R1]
         { info_tbl: [(c6zkA,
                       label: sat_s6v8d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zkA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zkB; else goto c6zkC;
       c6zkB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zkC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8c_entry() //  [R1]
         { info_tbl: [(c6zkH,
                       label: sat_s6v8c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zkH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zkI; else goto c6zkJ;
       c6zkI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zkJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedSum_entry() //  [R2]
         { info_tbl: [(c6zkL,
                       label: Data.Semigroup.Internal.$fBoundedSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zkL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6zkP; else goto c6zkO;
       c6zkP: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zkO: // global
           I64[Hp - 64] = sat_s6v8d_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v8c_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.116630876 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowSum2_bytes" {
     Data.Semigroup.Internal.$fShowSum2_bytes:
         I8[] [83,117,109,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.118907069 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowSum1_bytes" {
     Data.Semigroup.Internal.$fShowSum1_bytes:
         I8[] [103,101,116,83,117,109,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.122973656 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec5_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec5_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec5_info;
 },
 f_s6v8h_entry() //  [R1]
         { info_tbl: [(c6zlf,
                       label: f_s6v8h_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zlf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6zlg; else goto c6zlh;
       c6zlg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zlh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6v8k_entry() //  [R1]
         { info_tbl: [(c6zlC,
                       label: sat_s6v8k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zlC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zlD; else goto c6zlE;
       c6zlD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zlE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8l_entry() //  [R1]
         { info_tbl: [(c6zlF,
                       label: sat_s6v8l_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zlF: // global
           _s6v8l::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zlG; else goto c6zlH;
       c6zlH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zlJ; else goto c6zlI;
       c6zlJ: // global
           HpAlloc = 24;
           goto c6zlG;
       c6zlG: // global
           R1 = _s6v8l::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zlI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8l::P64;
           _s6v8h::P64 = P64[_s6v8l::P64 + 16];
           _s6v8j::P64 = P64[_s6v8l::P64 + 24];
           I64[Hp - 16] = sat_s6v8k_info;
           P64[Hp] = _s6v8j::P64;
           R2 = Hp - 16;
           R1 = _s6v8h::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8m_entry() //  [R1]
         { info_tbl: [(c6zlK,
                       label: sat_s6v8m_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zlK: // global
           _s6v8m::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zlL; else goto c6zlM;
       c6zlM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zlO; else goto c6zlN;
       c6zlO: // global
           HpAlloc = 32;
           goto c6zlL;
       c6zlL: // global
           R1 = _s6v8m::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zlN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8m::P64;
           _s6v8h::P64 = P64[_s6v8m::P64 + 16];
           _s6v8j::P64 = P64[_s6v8m::P64 + 24];
           I64[Hp - 24] = sat_s6v8l_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = _s6v8j::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8n_entry() //  [R1, R2]
         { info_tbl: [(c6zlP,
                       label: sat_s6v8n_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zlP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zlT; else goto c6zlS;
       c6zlT: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zlS: // global
           _s6v8h::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v8m_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v8q_entry() //  [R1]
         { info_tbl: [(c6zmh,
                       label: sat_s6v8q_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zmh: // global
           _s6v8q::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zmi; else goto c6zmj;
       c6zmj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zml; else goto c6zmk;
       c6zml: // global
           HpAlloc = 24;
           goto c6zmi;
       c6zmi: // global
           R1 = _s6v8q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zmk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8q::P64;
           _s6v8o::P64 = P64[_s6v8q::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v8o::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8r_entry() //  [R1]
         { info_tbl: [(c6zmm,
                       label: sat_s6v8r_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zmm: // global
           _s6v8r::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zmn; else goto c6zmo;
       c6zmo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zmq; else goto c6zmp;
       c6zmq: // global
           HpAlloc = 24;
           goto c6zmn;
       c6zmn: // global
           R1 = _s6v8r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zmp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8r::P64;
           _s6v8h::P64 = P64[_s6v8r::P64 + 16];
           _s6v8o::P64 = P64[_s6v8r::P64 + 24];
           I64[Hp - 16] = sat_s6v8q_info;
           P64[Hp] = _s6v8o::P64;
           R2 = Hp - 16;
           R1 = _s6v8h::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8s_entry() //  [R1]
         { info_tbl: [(c6zmr,
                       label: sat_s6v8s_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zmr: // global
           _s6v8s::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zms; else goto c6zmt;
       c6zmt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zmv; else goto c6zmu;
       c6zmv: // global
           HpAlloc = 32;
           goto c6zms;
       c6zms: // global
           R1 = _s6v8s::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zmu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8s::P64;
           _s6v8h::P64 = P64[_s6v8s::P64 + 16];
           _s6v8o::P64 = P64[_s6v8s::P64 + 24];
           I64[Hp - 24] = sat_s6v8r_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = _s6v8o::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8t_entry() //  [R1]
         { info_tbl: [(c6zmw,
                       label: sat_s6v8t_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zmw: // global
           _s6v8t::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zmx; else goto c6zmy;
       c6zmy: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zmA; else goto c6zmz;
       c6zmA: // global
           HpAlloc = 32;
           goto c6zmx;
       c6zmx: // global
           R1 = _s6v8t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zmz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8t::P64;
           _s6v8h::P64 = P64[_s6v8t::P64 + 16];
           _s6v8o::P64 = P64[_s6v8t::P64 + 24];
           I64[Hp - 24] = sat_s6v8s_info;
           P64[Hp - 8] = _s6v8h::P64;
           P64[Hp] = _s6v8o::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v8u_entry() //  [R1, R2]
         { info_tbl: [(c6zmC,
                       label: sat_s6v8u_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zmC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6zmG; else goto c6zmF;
       c6zmG: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zmF: // global
           _s6v8h::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6v8t_info;
           P64[Hp - 32] = _s6v8h::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec5_entry() //  [R2, R3, R4]
         { info_tbl: [(c6zmK,
                       label: Data.Semigroup.Internal.$w$cshowsPrec5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zmK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6zmO; else goto c6zmN;
       c6zmO: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zmN: // global
           I64[Hp - 40] = f_s6v8h_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6zlb::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6zmI; else goto c6zmJ;
       c6zmI: // global
           I64[Hp - 8] = sat_s6v8n_info;
           P64[Hp] = _c6zlb::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6zmJ: // global
           I64[Hp - 8] = sat_s6v8u_info;
           P64[Hp] = _c6zlb::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.149831778 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowSum_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6znH,
                       label: Data.Semigroup.Internal.$fShowSum_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6znH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6znI; else goto c6znJ;
       c6znI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6znJ: // global
           I64[Sp - 24] = block_c6znE_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6znN; else goto c6znF;
       u6znN: // global
           call _c6znE(R1) args: 0, res: 0, upd: 0;
       c6znF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6znE() //  [R1]
         { info_tbl: [(c6znE,
                       label: block_c6znE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6znE: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.155772643 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshow_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshow_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshow_info;
         const 0;
 },
 sat_s6v8C_entry() //  [R1]
         { info_tbl: [(c6zo9,
                       label: sat_s6v8C_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zo9: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6zoa; else goto c6zob;
       c6zoa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zob: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6v8D_entry() //  [R1]
         { info_tbl: [(c6zoc,
                       label: sat_s6v8D_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zoc: // global
           _s6v8D::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zod; else goto c6zoe;
       c6zoe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zog; else goto c6zof;
       c6zog: // global
           HpAlloc = 32;
           goto c6zod;
       c6zod: // global
           R1 = _s6v8D::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zof: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v8D::P64;
           _s6v8A::P64 = P64[_s6v8D::P64 + 16];
           _s6v8B::P64 = P64[_s6v8D::P64 + 24];
           I64[Hp - 24] = sat_s6v8C_info;
           P64[Hp - 8] = _s6v8A::P64;
           P64[Hp] = _s6v8B::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowSum_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6zoh,
                       label: Data.Semigroup.Internal.$fShowSum_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zoh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zol; else goto c6zok;
       c6zol: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zok: // global
           I64[Hp - 24] = sat_s6v8D_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.164406249 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshowList_info;
 },
 sat_s6v8I_entry() //  [R1, R2]
         { info_tbl: [(c6zoI,
                       label: sat_s6v8I_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zoI: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowSum_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c6zoL,
                       label: Data.Semigroup.Internal.$fShowSum_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zoL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zoP; else goto c6zoO;
       c6zoP: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zoO: // global
           I64[Hp - 8] = sat_s6v8I_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.170720681 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_closure" {
     Data.Semigroup.Internal.$fShowSum_closure:
         const Data.Semigroup.Internal.$fShowSum_info;
         const 0;
 },
 sat_s6v8M_entry() //  [R1, R2, R3]
         { info_tbl: [(c6zp6,
                       label: sat_s6v8M_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zp6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowSum_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v8L_entry() //  [R1, R2]
         { info_tbl: [(c6zpe,
                       label: sat_s6v8L_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zpe: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowSum_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v8K_entry() //  [R1, R2, R3]
         { info_tbl: [(c6zpm,
                       label: sat_s6v8K_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zpm: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowSum_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowSum_entry() //  [R2]
         { info_tbl: [(c6zpq,
                       label: Data.Semigroup.Internal.$fShowSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zpq: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6zpu; else goto c6zpt;
       c6zpu: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zpt: // global
           I64[Hp - 72] = sat_s6v8M_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v8L_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v8K_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.179522672 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadSum5_bytes" {
     Data.Semigroup.Internal.$fReadSum5_bytes:
         I8[] [83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.181523862 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum4_closure" {
     Data.Semigroup.Internal.$fReadSum4_closure:
         const Data.Semigroup.Internal.$fReadSum4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadSum4_entry() //  [R1]
         { info_tbl: [(c6zpT,
                       label: Data.Semigroup.Internal.$fReadSum4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zpT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zpU; else goto c6zpV;
       c6zpU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zpV: // global
           (_c6zpQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zpQ::I64 == 0) goto c6zpS; else goto c6zpR;
       c6zpS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zpR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zpQ::I64;
           R2 = Data.Semigroup.Internal.$fReadSum5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.185656089 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_lexeme_closure" {
     Data.Semigroup.Internal.$fReadSum_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadSum4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.187378656 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadSum3_bytes" {
     Data.Semigroup.Internal.$fReadSum3_bytes:
         I8[] [103,101,116,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.189330699 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum2_closure" {
     Data.Semigroup.Internal.$fReadSum2_closure:
         const Data.Semigroup.Internal.$fReadSum2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadSum2_entry() //  [R1]
         { info_tbl: [(c6zqb,
                       label: Data.Semigroup.Internal.$fReadSum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zqb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zqc; else goto c6zqd;
       c6zqc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zqd: // global
           (_c6zq8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zq8::I64 == 0) goto c6zqa; else goto c6zq9;
       c6zqa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zq9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zq8::I64;
           R2 = Data.Semigroup.Internal.$fReadSum3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.195674162 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum1_closure" {
     Data.Semigroup.Internal.$fReadSum1_closure:
         const Data.Semigroup.Internal.$fReadSum1_info;
         const 0;
 },
 lvl12_s6v8O_entry() //  [R1]
         { info_tbl: [(c6zqt,
                       label: lvl12_s6v8O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zqt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6zqu; else goto c6zqv;
       c6zqu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zqv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6v8P_entry() //  [R1]
         { info_tbl: [(c6zqB,
                       label: ds_s6v8P_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zqB: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v90_entry() //  [R1]
         { info_tbl: [(c6zrc,
                       label: sat_s6v90_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zrc: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v93_entry() //  [R1, R2]
         { info_tbl: [(c6zri,
                       label: sat_s6v93_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zri: // global
           _s6v8Y::P64 = R2;
           _s6v93::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6zrj; else goto c6zrk;
       c6zrk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zrm; else goto c6zrl;
       c6zrm: // global
           HpAlloc = 24;
           goto c6zrj;
       c6zrj: // global
           R2 = _s6v8Y::P64;
           R1 = _s6v93::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zrl: // global
           _s6v8S::P64 = P64[_s6v93::P64 + 7];
           I64[Hp - 16] = sat_s6v90_info;
           P64[Hp - 8] = _s6v8S::P64;
           P64[Hp] = _s6v8Y::P64;
           I64[Sp - 8] = block_c6zrf_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zrf() //  [R1]
         { info_tbl: [(c6zrf,
                       label: block_c6zrf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zrf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zrp; else goto c6zro;
       c6zrp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zro: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v94_entry() //  [R1, R2]
         { info_tbl: [(c6zrq,
                       label: sat_s6v94_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zrq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zru; else goto c6zrt;
       c6zru: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zrt: // global
           _s6v8P::P64 = P64[R1 + 7];
           _s6v8S::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6v93_info;
           P64[Hp] = _s6v8S::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6v8P::P64;
           R2 = Data.Semigroup.Internal.$fReadSum2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v97_entry() //  [R1, R2]
         { info_tbl: [(c6zry,
                       label: sat_s6v97_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zry: // global
           _s6v8W::P64 = R2;
           _s6v97::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6zrz; else goto c6zrA;
       c6zrA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zrC; else goto c6zrB;
       c6zrC: // global
           HpAlloc = 24;
           goto c6zrz;
       c6zrz: // global
           R2 = _s6v8W::P64;
           R1 = _s6v97::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zrB: // global
           _s6v8P::P64 = P64[_s6v97::P64 + 7];
           _s6v8S::P64 = P64[_s6v97::P64 + 15];
           I64[Hp - 16] = sat_s6v94_info;
           P64[Hp - 8] = _s6v8P::P64;
           P64[Hp] = _s6v8S::P64;
           I64[Sp - 8] = block_c6zrv_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zrv() //  [R1]
         { info_tbl: [(c6zrv,
                       label: block_c6zrv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zrv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zrF; else goto c6zrE;
       c6zrF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zrE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9a_entry() //  [R1, R2, R3]
         { info_tbl: [(c6zrG,
                       label: sat_s6v9a_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zrG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6zrH; else goto c6zrI;
       c6zrH: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zrI: // global
           I64[Sp - 24] = block_c6zqJ_info;
           _s6v8P::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6v8P::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6zrV; else goto c6zqK;
       u6zrV: // global
           call _c6zqJ(R1) args: 0, res: 0, upd: 0;
       c6zqK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6zqJ() //  [R1]
         { info_tbl: [(c6zqJ,
                       label: block_c6zqJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zqJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zrL; else goto c6zrK;
       c6zrL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zrK: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6zrN; else goto c6zrR;
       c6zrN: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6zrR: // global
           I64[Hp - 16] = sat_s6v97_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6zrO_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadSum_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zrO() //  [R1]
         { info_tbl: [(c6zrO,
                       label: block_c6zrO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zrO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zrU; else goto c6zrT;
       c6zrU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zrT: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum1_entry() //  [R2]
         { info_tbl: [(c6zrW,
                       label: Data.Semigroup.Internal.$fReadSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zrW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6zs0; else goto c6zrZ;
       c6zs0: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zrZ: // global
           I64[Hp - 48] = lvl12_s6v8O_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6v8P_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6v9a_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.222627931 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadsPrec_info;
         const 0;
 },
 ds_s6v9c_entry() //  [R1]
         { info_tbl: [(c6zsX,
                       label: ds_s6v9c_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zsX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zsY; else goto c6zsZ;
       c6zsY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zsZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9e_entry() //  [R1]
         { info_tbl: [(c6zt9,
                       label: sat_s6v9e_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zt9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zta; else goto c6ztb;
       c6zta: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ztb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9f_entry() //  [R1, R2]
         { info_tbl: [(c6ztc,
                       label: sat_s6v9f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ztc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6ztg; else goto c6ztf;
       c6ztg: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ztf: // global
           _s6v9c::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6v9e_info;
           P64[Hp - 8] = _s6v9c::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6zth,
                       label: Data.Semigroup.Internal.$fReadSum_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zth: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6ztl; else goto c6ztk;
       c6ztl: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ztk: // global
           I64[Hp - 32] = ds_s6v9c_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6v9f_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.23237192 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadListPrec_info;
         const 0;
 },
 sat_s6v9h_entry() //  [R1]
         { info_tbl: [(c6ztL,
                       label: sat_s6v9h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ztL: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6ztO,
                       label: Data.Semigroup.Internal.$fReadSum_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ztO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ztS; else goto c6ztR;
       c6ztS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6ztR: // global
           I64[Hp - 16] = sat_s6v9h_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.238478561 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadList_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadList_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadList_info;
         const 0;
 },
 sat_s6v9j_entry() //  [R1]
         { info_tbl: [(c6zuc,
                       label: sat_s6v9j_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zuc: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9k_entry() //  [R1]
         { info_tbl: [(c6zuf,
                       label: sat_s6v9k_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zuf: // global
           _s6v9k::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6zug; else goto c6zuh;
       c6zuh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zuj; else goto c6zui;
       c6zuj: // global
           HpAlloc = 24;
           goto c6zug;
       c6zug: // global
           R1 = _s6v9k::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zui: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v9k::P64;
           _s6v9i::P64 = P64[_s6v9k::P64 + 16];
           I64[Hp - 16] = sat_s6v9j_info;
           P64[Hp] = _s6v9i::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadList_entry() //  [R2]
         { info_tbl: [(c6zuk,
                       label: Data.Semigroup.Internal.$fReadSum_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zuk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zuo; else goto c6zun;
       c6zuo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zun: // global
           I64[Hp - 16] = sat_s6v9k_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.247124898 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_closure" {
     Data.Semigroup.Internal.$fReadSum_closure:
         const Data.Semigroup.Internal.$fReadSum_info;
         const 0;
 },
 sat_s6v9p_entry() //  [R1]
         { info_tbl: [(c6zuI,
                       label: sat_s6v9p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zuI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zuJ; else goto c6zuK;
       c6zuJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zuK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9o_entry() //  [R1]
         { info_tbl: [(c6zuP,
                       label: sat_s6v9o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zuP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zuQ; else goto c6zuR;
       c6zuQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zuR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9n_entry() //  [R1]
         { info_tbl: [(c6zuW,
                       label: sat_s6v9n_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zuW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zuX; else goto c6zuY;
       c6zuX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zuY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9m_entry() //  [R1]
         { info_tbl: [(c6zv3,
                       label: sat_s6v9m_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zv3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zv4; else goto c6zv5;
       c6zv4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zv5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadSum_entry() //  [R2]
         { info_tbl: [(c6zv7,
                       label: Data.Semigroup.Internal.$fReadSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zv7: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6zvb; else goto c6zva;
       c6zvb: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zva: // global
           I64[Hp - 128] = sat_s6v9p_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6v9o_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6v9n_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6v9m_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.259153781 UTC

[section ""data" . Data.Semigroup.Internal.$fEqSum_closure" {
     Data.Semigroup.Internal.$fEqSum_closure:
         const Data.Semigroup.Internal.$fEqSum_info;
 },
 sat_s6v9s_entry() //  [R1]
         { info_tbl: [(c6zvJ,
                       label: sat_s6v9s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zvJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zvK; else goto c6zvL;
       c6zvK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zvL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9r_entry() //  [R1]
         { info_tbl: [(c6zvQ,
                       label: sat_s6v9r_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zvQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zvR; else goto c6zvS;
       c6zvR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zvS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqSum_entry() //  [R2]
         { info_tbl: [(c6zvU,
                       label: Data.Semigroup.Internal.$fEqSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zvU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6zvY; else goto c6zvX;
       c6zvY: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zvX: // global
           I64[Hp - 64] = sat_s6v9s_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6v9r_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.26788757 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdSum_$cp1Ord_info;
 },
 sat_s6v9u_entry() //  [R1]
         { info_tbl: [(c6zwm,
                       label: sat_s6v9u_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zwm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zwn; else goto c6zwo;
       c6zwn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zwo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdSum_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6zwp,
                       label: Data.Semigroup.Internal.$fOrdSum_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zwp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zwt; else goto c6zws;
       c6zwt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zws: // global
           I64[Hp - 16] = sat_s6v9u_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqSum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.275396378 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdSum_closure" {
     Data.Semigroup.Internal.$fOrdSum_closure:
         const Data.Semigroup.Internal.$fOrdSum_info;
 },
 sat_s6v9D_entry() //  [R1]
         { info_tbl: [(c6zwK,
                       label: sat_s6v9D_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zwK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zwL; else goto c6zwM;
       c6zwL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zwM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9C_entry() //  [R1]
         { info_tbl: [(c6zwR,
                       label: sat_s6v9C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zwR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zwS; else goto c6zwT;
       c6zwS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zwT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9B_entry() //  [R1]
         { info_tbl: [(c6zwY,
                       label: sat_s6v9B_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zwY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zwZ; else goto c6zx0;
       c6zwZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zx0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9A_entry() //  [R1]
         { info_tbl: [(c6zx5,
                       label: sat_s6v9A_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zx5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zx6; else goto c6zx7;
       c6zx6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zx7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9z_entry() //  [R1]
         { info_tbl: [(c6zxc,
                       label: sat_s6v9z_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zxc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zxd; else goto c6zxe;
       c6zxd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zxe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9y_entry() //  [R1]
         { info_tbl: [(c6zxj,
                       label: sat_s6v9y_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zxj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zxk; else goto c6zxl;
       c6zxk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zxl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9x_entry() //  [R1]
         { info_tbl: [(c6zxq,
                       label: sat_s6v9x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zxq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zxr; else goto c6zxs;
       c6zxr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zxs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9w_entry() //  [R1]
         { info_tbl: [(c6zxx,
                       label: sat_s6v9w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zxx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zxy; else goto c6zxz;
       c6zxy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zxz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdSum_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdSum_entry() //  [R2]
         { info_tbl: [(c6zxB,
                       label: Data.Semigroup.Internal.$fOrdSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zxB: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6zxF; else goto c6zxE;
       c6zxF: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zxE: // global
           I64[Hp - 256] = sat_s6v9D_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6v9C_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6v9B_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6v9A_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6v9z_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6v9y_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6v9x_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6v9w_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.295444412 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny1_closure" {
     Data.Semigroup.Internal.$fGenericAny1_closure:
         const Data.Semigroup.Internal.$fGenericAny1_info;
 },
 Data.Semigroup.Internal.$fGenericAny1_entry() //  [R2]
         { info_tbl: [(c6zyt,
                       label: Data.Semigroup.Internal.$fGenericAny1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zyt: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.298829793 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny2_closure" {
     Data.Semigroup.Internal.$fGenericAny2_closure:
         const Data.Semigroup.Internal.$fGenericAny2_info;
 },
 Data.Semigroup.Internal.$fGenericAny2_entry() //  [R2]
         { info_tbl: [(c6zyE,
                       label: Data.Semigroup.Internal.$fGenericAny2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zyE: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.302375085 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny_closure" {
     Data.Semigroup.Internal.$fGenericAny_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAny2_closure+1;
         const Data.Semigroup.Internal.$fGenericAny1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.304097003 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedAny_closure" {
     Data.Semigroup.Internal.$fBoundedAny_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.305879862 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAny4_bytes" {
     Data.Semigroup.Internal.$fShowAny4_bytes:
         I8[] [65,110,121,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.30779076 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny3_closure" {
     Data.Semigroup.Internal.$fShowAny3_closure:
         const Data.Semigroup.Internal.$fShowAny3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny3_entry() //  [R1]
         { info_tbl: [(c6zyW,
                       label: Data.Semigroup.Internal.$fShowAny3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zyW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zyX; else goto c6zyY;
       c6zyX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zyY: // global
           (_c6zyT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zyT::I64 == 0) goto c6zyV; else goto c6zyU;
       c6zyV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zyU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zyT::I64;
           R2 = Data.Semigroup.Internal.$fShowAny4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.311893239 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAny2_bytes" {
     Data.Semigroup.Internal.$fShowAny2_bytes:
         I8[] [103,101,116,65,110,121,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.31657321 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec2_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec2_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec2_info;
         const 0;
 },
 sat_s6v9L_entry() //  [R1]
         { info_tbl: [(c6zzv,
                       label: sat_s6v9L_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zzv: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9M_entry() //  [R1]
         { info_tbl: [(c6zzE,
                       label: sat_s6v9M_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zzE: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9N_entry() //  [R1]
         { info_tbl: [(c6zzL,
                       label: sat_s6v9N_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zzL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6zzM; else goto c6zzN;
       c6zzM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zzN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6zzm_info;
           _s6v9I::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6v9I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6zzU; else goto c6zzn;
       u6zzU: // global
           call _c6zzm(R1) args: 0, res: 0, upd: 0;
       c6zzn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6zzm() //  [R1]
         { info_tbl: [(c6zzm,
                       label: block_c6zzm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zzm: // global
           _s6v9I::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6zzI; else goto c6zzJ;
       c6zzI: // global
           Hp = Hp + 24;
           _s6v9K::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zzT; else goto c6zzP;
       c6zzP: // global
           I64[Hp - 16] = sat_s6v9L_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6zzJ: // global
           Hp = Hp + 24;
           _s6v9K::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zzT; else goto c6zzS;
       c6zzT: // global
           HpAlloc = 24;
           R1 = _s6v9K::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6zzS: // global
           I64[Hp - 16] = sat_s6v9M_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9O_entry() //  [R1]
         { info_tbl: [(c6zzV,
                       label: sat_s6v9O_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zzV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zzZ; else goto c6zzY;
       c6zzZ: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zzY: // global
           _s6v9H::P64 = P64[R1 + 16];
           _s6v9I::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6v9N_info;
           P64[Hp - 8] = _s6v9H::P64;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9R_entry() //  [R1]
         { info_tbl: [(c6zAn,
                       label: sat_s6v9R_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zAn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zAr; else goto c6zAq;
       c6zAr: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zAq: // global
           _s6v9I::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9T_entry() //  [R1]
         { info_tbl: [(c6zAz,
                       label: sat_s6v9T_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zAz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zAD; else goto c6zAC;
       c6zAD: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zAC: // global
           _s6v9I::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9U_entry() //  [R1]
         { info_tbl: [(c6zAI,
                       label: sat_s6v9U_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zAI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6zAJ; else goto c6zAK;
       c6zAJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zAK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6zAd_info;
           _s6v9I::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6v9I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6zAR; else goto c6zAe;
       u6zAR: // global
           call _c6zAd(R1) args: 0, res: 0, upd: 0;
       c6zAe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6zAd() //  [R1]
         { info_tbl: [(c6zAd,
                       label: block_c6zAd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zAd: // global
           _s6v9I::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6zAF; else goto c6zAG;
       c6zAF: // global
           Hp = Hp + 24;
           _s6v9P::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zAQ; else goto c6zAM;
       c6zAM: // global
           I64[Hp - 16] = sat_s6v9R_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6zAG: // global
           Hp = Hp + 24;
           _s6v9P::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zAQ; else goto c6zAP;
       c6zAQ: // global
           HpAlloc = 24;
           R1 = _s6v9P::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6zAP: // global
           I64[Hp - 16] = sat_s6v9T_info;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6v9V_entry() //  [R1]
         { info_tbl: [(c6zAS,
                       label: sat_s6v9V_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zAS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zAW; else goto c6zAV;
       c6zAW: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zAV: // global
           _s6v9H::P64 = P64[R1 + 16];
           _s6v9I::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6v9U_info;
           P64[Hp - 8] = _s6v9H::P64;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6v9W_entry() //  [R1]
         { info_tbl: [(c6zAX,
                       label: sat_s6v9W_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zAX: // global
           _s6v9W::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zAY; else goto c6zAZ;
       c6zAZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zB1; else goto c6zB0;
       c6zB1: // global
           HpAlloc = 32;
           goto c6zAY;
       c6zAY: // global
           R1 = _s6v9W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zB0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6v9W::P64;
           _s6v9H::P64 = P64[_s6v9W::P64 + 16];
           _s6v9I::P64 = P64[_s6v9W::P64 + 24];
           I64[Hp - 24] = sat_s6v9V_info;
           P64[Hp - 8] = _s6v9H::P64;
           P64[Hp] = _s6v9I::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(c6zB5,
                       label: Data.Semigroup.Internal.$w$cshowsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zB5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6zB9; else goto c6zB8;
       c6zB9: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zB8: // global
           if (%MO_S_Lt_W64(R2, 11)) goto c6zB3; else goto c6zB4;
       c6zB3: // global
           I64[Hp - 48] = sat_s6v9O_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _c6zze::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c6zze::P64;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6zB4: // global
           I64[Hp - 48] = sat_s6v9W_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.344714503 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6zC4,
                       label: Data.Semigroup.Internal.$fShowAny_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zC4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6zC5; else goto c6zC6;
       c6zC5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zC6: // global
           I64[Sp - 24] = block_c6zC1_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6zCa; else goto c6zC2;
       u6zCa: // global
           call _c6zC1(R1) args: 0, res: 0, upd: 0;
       c6zC2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6zC1() //  [R1]
         { info_tbl: [(c6zC1,
                       label: block_c6zC1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zC1: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.350522004 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll6_closure" {
     Data.Semigroup.Internal.$fShowAll6_closure:
         const Data.Semigroup.Internal.$fShowAll6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll6_entry() //  [R1]
         { info_tbl: [(c6zCq,
                       label: Data.Semigroup.Internal.$fShowAll6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zCq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zCr; else goto c6zCs;
       c6zCr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zCs: // global
           (_c6zCn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zCn::I64 == 0) goto c6zCp; else goto c6zCo;
       c6zCp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zCo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zCn::I64;
           R3 = Data.Semigroup.Internal.$fReadAll4_closure;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.355113548 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll5_closure" {
     Data.Semigroup.Internal.$fShowAll5_closure:
         const Data.Semigroup.Internal.$fShowAll5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll5_entry() //  [R1]
         { info_tbl: [(c6zCG,
                       label: Data.Semigroup.Internal.$fShowAll5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zCG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zCH; else goto c6zCI;
       c6zCH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zCI: // global
           (_c6zCD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zCD::I64 == 0) goto c6zCF; else goto c6zCE;
       c6zCF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zCE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zCD::I64;
           R3 = Data.Semigroup.Internal.$fReadAll4_closure;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.359778643 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshow_info;
         const 0;
 },
 sat_s6va4_entry() //  [R1]
         { info_tbl: [(c6zD9,
                       label: sat_s6va4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zD9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6zDa; else goto c6zDb;
       c6zDa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zDb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6zD2_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6zDi; else goto c6zD3;
       u6zDi: // global
           call _c6zD2(R1) args: 0, res: 0, upd: 0;
       c6zD3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6zD2() //  [R1]
         { info_tbl: [(c6zD2,
                       label: block_c6zD2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zD2: // global
           if (R1 & 7 == 1) goto c6zD6; else goto c6zD7;
       c6zD6: // global
           R1 = Data.Semigroup.Internal.$fShowAll6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6zD7: // global
           R1 = Data.Semigroup.Internal.$fShowAll5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6va5_entry() //  [R1]
         { info_tbl: [(c6zDj,
                       label: sat_s6va5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zDj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zDn; else goto c6zDm;
       c6zDn: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zDm: // global
           _s6va2::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s6va4_info;
           P64[Hp] = _s6va2::P64;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAny_$cshow_entry() //  [R2]
         { info_tbl: [(c6zDo,
                       label: Data.Semigroup.Internal.$fShowAny_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zDo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zDs; else goto c6zDr;
       c6zDs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zDr: // global
           I64[Hp - 16] = sat_s6va5_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.371198132 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny1_closure" {
     Data.Semigroup.Internal.$fShowAny1_closure:
         const Data.Semigroup.Internal.$fShowAny1_info;
         const 0;
 },
 sat_s6va9_entry() //  [R1]
         { info_tbl: [(c6zE7,
                       label: sat_s6va9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zE7: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaa_entry() //  [R1]
         { info_tbl: [(c6zEg,
                       label: sat_s6vaa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zEg: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vab_entry() //  [R1]
         { info_tbl: [(c6zEn,
                       label: sat_s6vab_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zEn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6zEo; else goto c6zEp;
       c6zEo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zEp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6zDY_info;
           _s6va7::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6va7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6zEw; else goto c6zDZ;
       u6zEw: // global
           call _c6zDY(R1) args: 0, res: 0, upd: 0;
       c6zDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6zDY() //  [R1]
         { info_tbl: [(c6zDY,
                       label: block_c6zDY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zDY: // global
           _s6va7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6zEk; else goto c6zEl;
       c6zEk: // global
           Hp = Hp + 24;
           _s6va8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zEv; else goto c6zEr;
       c6zEr: // global
           I64[Hp - 16] = sat_s6va9_info;
           P64[Hp] = _s6va7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6zEl: // global
           Hp = Hp + 24;
           _s6va8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zEv; else goto c6zEu;
       c6zEv: // global
           HpAlloc = 24;
           R1 = _s6va8::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6zEu: // global
           I64[Hp - 16] = sat_s6vaa_info;
           P64[Hp] = _s6va7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vac_entry() //  [R1]
         { info_tbl: [(c6zEx,
                       label: sat_s6vac_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zEx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zEB; else goto c6zEA;
       c6zEB: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zEA: // global
           _s6va6::P64 = P64[R1 + 16];
           _s6va7::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vab_info;
           P64[Hp - 8] = _s6va6::P64;
           P64[Hp] = _s6va7::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAny1_entry() //  [R2, R3]
         { info_tbl: [(c6zEC,
                       label: Data.Semigroup.Internal.$fShowAny1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zEC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zEG; else goto c6zEF;
       c6zEG: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zEF: // global
           I64[Hp - 24] = sat_s6vac_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.385290317 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshowList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c6zF8,
                       label: Data.Semigroup.Internal.$fShowAny_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zF8: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fShowAny1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.389355461 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_closure" {
     Data.Semigroup.Internal.$fShowAny_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure+3;
         const Data.Semigroup.Internal.$fShowAny_$cshow_closure+1;
         const Data.Semigroup.Internal.$fShowAny_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.39126468 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAny6_bytes" {
     Data.Semigroup.Internal.$fReadAny6_bytes:
         I8[] [65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.393258932 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny5_closure" {
     Data.Semigroup.Internal.$fReadAny5_closure:
         const Data.Semigroup.Internal.$fReadAny5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny5_entry() //  [R1]
         { info_tbl: [(c6zFn,
                       label: Data.Semigroup.Internal.$fReadAny5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zFn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zFo; else goto c6zFp;
       c6zFo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zFp: // global
           (_c6zFk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zFk::I64 == 0) goto c6zFm; else goto c6zFl;
       c6zFm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zFl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zFk::I64;
           R2 = Data.Semigroup.Internal.$fReadAny6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.397198467 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAny_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAny5_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.399216515 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAny4_bytes" {
     Data.Semigroup.Internal.$fReadAny4_bytes:
         I8[] [103,101,116,65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.401147437 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny3_closure" {
     Data.Semigroup.Internal.$fReadAny3_closure:
         const Data.Semigroup.Internal.$fReadAny3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny3_entry() //  [R1]
         { info_tbl: [(c6zFF,
                       label: Data.Semigroup.Internal.$fReadAny3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zFF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zFG; else goto c6zFH;
       c6zFG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zFH: // global
           (_c6zFC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zFC::I64 == 0) goto c6zFE; else goto c6zFD;
       c6zFE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zFD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zFC::I64;
           R2 = Data.Semigroup.Internal.$fReadAny4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.405171819 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll7_closure" {
     Data.Semigroup.Internal.$fReadAll7_closure:
         const Data.Semigroup.Internal.$fReadAll7_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll7_entry() //  [R3]
         { info_tbl: [(c6zFT,
                       label: Data.Semigroup.Internal.$fReadAll7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zFT: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadBool2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.410854383 UTC

[section ""data" . Data.Semigroup.Internal.$w$creadPrec1_closure" {
     Data.Semigroup.Internal.$w$creadPrec1_closure:
         const Data.Semigroup.Internal.$w$creadPrec1_info;
         const 0;
 },
 sat_s6vao_entry() //  [R1]
         { info_tbl: [(c6zGs,
                       label: sat_s6vao_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zGs: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6var_entry() //  [R1, R2]
         { info_tbl: [(c6zGy,
                       label: sat_s6var_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zGy: // global
           _s6vam::P64 = R2;
           _s6var::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6zGz; else goto c6zGA;
       c6zGA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zGC; else goto c6zGB;
       c6zGC: // global
           HpAlloc = 24;
           goto c6zGz;
       c6zGz: // global
           R2 = _s6vam::P64;
           R1 = _s6var::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zGB: // global
           _s6vai::P64 = P64[_s6var::P64 + 7];
           I64[Hp - 16] = sat_s6vao_info;
           P64[Hp - 8] = _s6vai::P64;
           P64[Hp] = _s6vam::P64;
           I64[Sp - 8] = block_c6zGv_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zGv() //  [R1]
         { info_tbl: [(c6zGv,
                       label: block_c6zGv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zGv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zGF; else goto c6zGE;
       c6zGF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zGE: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6zHa_srtd" {
     u6zHa_srtd:
         const S6vn0_srt+128;
         const 45;
         const 32985348833281;
 },
 sat_s6vas_entry() //  [R1, R2]
         { info_tbl: [(c6zGG,
                       label: sat_s6vas_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zGG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zGK; else goto c6zGJ;
       c6zGK: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zGJ: // global
           _s6vai::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s6var_info;
           P64[Hp] = _s6vai::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = Data.Semigroup.Internal.$fReadAll7_closure+2;
           R2 = Data.Semigroup.Internal.$fReadAny3_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6zHb_srtd" {
     u6zHb_srtd:
         const S6vn0_srt+128;
         const 45;
         const 32985348833285;
 },
 sat_s6vav_entry() //  [R1, R2]
         { info_tbl: [(c6zGO,
                       label: sat_s6vav_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zGO: // global
           _s6vak::P64 = R2;
           _s6vav::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6zGP; else goto c6zGQ;
       c6zGQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zGS; else goto c6zGR;
       c6zGS: // global
           HpAlloc = 16;
           goto c6zGP;
       c6zGP: // global
           R2 = _s6vak::P64;
           R1 = _s6vav::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zGR: // global
           _s6vai::P64 = P64[_s6vav::P64 + 7];
           I64[Hp - 8] = sat_s6vas_info;
           P64[Hp] = _s6vai::P64;
           I64[Sp - 8] = block_c6zGL_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zGL() //  [R1]
         { info_tbl: [(c6zGL,
                       label: block_c6zGL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zGL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zGV; else goto c6zGU;
       c6zGV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zGU: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6zHc_srtd" {
     u6zHc_srtd:
         const S6vn0_srt+128;
         const 47;
         const 138538465099781;
 },
 Data.Semigroup.Internal.$w$creadPrec1_entry() //  [R2, R3]
         { info_tbl: [(c6zGZ,
                       label: Data.Semigroup.Internal.$w$creadPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zGZ: // global
           _s6vai::P64 = R3;
           _s6vah::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c6zH0; else goto c6zH1;
       c6zH1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zH3; else goto c6zH2;
       c6zH3: // global
           HpAlloc = 16;
           goto c6zH0;
       c6zH0: // global
           R3 = _s6vai::P64;
           R2 = _s6vah::I64;
           R1 = Data.Semigroup.Internal.$w$creadPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zH2: // global
           if (%MO_S_Gt_W64(_s6vah::I64, 11)) goto c6zGX; else goto c6zGY;
       c6zGX: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6zGY: // global
           I64[Hp - 8] = sat_s6vav_info;
           P64[Hp] = _s6vai::P64;
           I64[Sp - 8] = block_c6zH4_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAny_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zH4() //  [R1]
         { info_tbl: [(c6zH4,
                       label: block_c6zH4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zH4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zH9; else goto c6zH8;
       c6zH9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zH8: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.431484702 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny2_closure" {
     Data.Semigroup.Internal.$fReadAny2_closure:
         const Data.Semigroup.Internal.$fReadAny2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny2_entry() //  [R2, R3]
         { info_tbl: [(c6zHT,
                       label: Data.Semigroup.Internal.$fReadAny2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zHT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zHU; else goto c6zHV;
       c6zHU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAny2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zHV: // global
           I64[Sp - 16] = block_c6zHQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6zHZ; else goto c6zHR;
       u6zHZ: // global
           call _c6zHQ(R1) args: 0, res: 0, upd: 0;
       c6zHR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6zHQ() //  [R1]
         { info_tbl: [(c6zHQ,
                       label: block_c6zHQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zHQ: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$creadPrec1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.437970159 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny1_closure" {
     Data.Semigroup.Internal.$fReadAny1_closure:
         const Data.Semigroup.Internal.$fReadAny1_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny1_entry() //  [R2, R3]
         { info_tbl: [(c6zId,
                       label: Data.Semigroup.Internal.$fReadAny1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zId: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAny2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.441835468 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_info;
         const 0;
 },
 sat_s6vaD_entry() //  [R1]
         { info_tbl: [(c6zIs,
                       label: sat_s6vaD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zIs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zIt; else goto c6zIu;
       c6zIt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zIu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAny2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAny_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6zIv,
                       label: Data.Semigroup.Internal.$fReadAny_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zIv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zIz; else goto c6zIy;
       c6zIz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zIy: // global
           I64[Hp - 16] = sat_s6vaD_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.447609144 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c6zIO,
                       label: Data.Semigroup.Internal.$fReadAny_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zIO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zIP; else goto c6zIQ;
       c6zIP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zIQ: // global
           (_c6zIL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zIL::I64 == 0) goto c6zIN; else goto c6zIM;
       c6zIN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zIM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zIL::I64;
           R2 = Data.Semigroup.Internal.$fReadAny1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.451891797 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny7_closure" {
     Data.Semigroup.Internal.$fReadAny7_closure:
         const Data.Semigroup.Internal.$fReadAny7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny7_entry() //  [R1]
         { info_tbl: [(c6zJ4,
                       label: Data.Semigroup.Internal.$fReadAny7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zJ4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zJ5; else goto c6zJ6;
       c6zJ5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zJ6: // global
           (_c6zJ1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zJ1::I64 == 0) goto c6zJ3; else goto c6zJ2;
       c6zJ3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zJ2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zJ1::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.461506803 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny_$creadList_entry() //  [R2]
         { info_tbl: [(c6zJi,
                       label: Data.Semigroup.Internal.$fReadAny_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zJi: // global
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAny7_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.465750904 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_closure" {
     Data.Semigroup.Internal.$fReadAny_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure+1;
         const Data.Semigroup.Internal.$fReadAny_$creadList_closure+1;
         const Data.Semigroup.Internal.$fReadAny1_closure+2;
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.468338165 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAny_closure" {
     Data.Semigroup.Internal.$fEqAny_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.$fEqBool_$c==_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.47122687 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAny_closure" {
     Data.Semigroup.Internal.$fOrdAny_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Semigroup.Internal.$fEqAny_closure+1;
         const GHC.Classes.$fOrdBool_$ccompare_closure+2;
         const GHC.Classes.$fOrdBool_$c<_closure+2;
         const GHC.Classes.$fOrdBool_$c<=_closure+2;
         const GHC.Classes.$fOrdBool_$c>_closure+2;
         const GHC.Classes.$fOrdBool_$c>=_closure+2;
         const GHC.Classes.$fOrdBool_$cmax_closure+2;
         const GHC.Classes.$fOrdBool_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.474074128 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll1_closure" {
     Data.Semigroup.Internal.$fGenericAll1_closure:
         const Data.Semigroup.Internal.$fGenericAll1_info;
 },
 Data.Semigroup.Internal.$fGenericAll1_entry() //  [R2]
         { info_tbl: [(c6zJw,
                       label: Data.Semigroup.Internal.$fGenericAll1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zJw: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.478723457 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll2_closure" {
     Data.Semigroup.Internal.$fGenericAll2_closure:
         const Data.Semigroup.Internal.$fGenericAll2_info;
 },
 Data.Semigroup.Internal.$fGenericAll2_entry() //  [R2]
         { info_tbl: [(c6zJH,
                       label: Data.Semigroup.Internal.$fGenericAll2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zJH: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.483289107 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll_closure" {
     Data.Semigroup.Internal.$fGenericAll_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAll2_closure+1;
         const Data.Semigroup.Internal.$fGenericAll1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.486006456 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedAll_closure" {
     Data.Semigroup.Internal.$fBoundedAll_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.488194731 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAll4_bytes" {
     Data.Semigroup.Internal.$fShowAll4_bytes:
         I8[] [65,108,108,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.490937112 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll3_closure" {
     Data.Semigroup.Internal.$fShowAll3_closure:
         const Data.Semigroup.Internal.$fShowAll3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll3_entry() //  [R1]
         { info_tbl: [(c6zJZ,
                       label: Data.Semigroup.Internal.$fShowAll3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zJZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zK0; else goto c6zK1;
       c6zK0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zK1: // global
           (_c6zJW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zJW::I64 == 0) goto c6zJY; else goto c6zJX;
       c6zJY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zJX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zJW::I64;
           R2 = Data.Semigroup.Internal.$fShowAll4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.495056089 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAll2_bytes" {
     Data.Semigroup.Internal.$fShowAll2_bytes:
         I8[] [103,101,116,65,108,108,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.498874862 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec_info;
         const 0;
 },
 sat_s6vaL_entry() //  [R1]
         { info_tbl: [(c6zKy,
                       label: sat_s6vaL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zKy: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaM_entry() //  [R1]
         { info_tbl: [(c6zKH,
                       label: sat_s6vaM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zKH: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaN_entry() //  [R1]
         { info_tbl: [(c6zKO,
                       label: sat_s6vaN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zKO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6zKP; else goto c6zKQ;
       c6zKP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zKQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6zKp_info;
           _s6vaI::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6vaI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6zKX; else goto c6zKq;
       u6zKX: // global
           call _c6zKp(R1) args: 0, res: 0, upd: 0;
       c6zKq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6zKp() //  [R1]
         { info_tbl: [(c6zKp,
                       label: block_c6zKp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zKp: // global
           _s6vaI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6zKL; else goto c6zKM;
       c6zKL: // global
           Hp = Hp + 24;
           _s6vaK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zKW; else goto c6zKS;
       c6zKS: // global
           I64[Hp - 16] = sat_s6vaL_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6zKM: // global
           Hp = Hp + 24;
           _s6vaK::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zKW; else goto c6zKV;
       c6zKW: // global
           HpAlloc = 24;
           R1 = _s6vaK::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6zKV: // global
           I64[Hp - 16] = sat_s6vaM_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vaO_entry() //  [R1]
         { info_tbl: [(c6zKY,
                       label: sat_s6vaO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zKY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zL2; else goto c6zL1;
       c6zL2: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zL1: // global
           _s6vaH::P64 = P64[R1 + 16];
           _s6vaI::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vaN_info;
           P64[Hp - 8] = _s6vaH::P64;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaR_entry() //  [R1]
         { info_tbl: [(c6zLq,
                       label: sat_s6vaR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zLq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zLu; else goto c6zLt;
       c6zLu: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zLt: // global
           _s6vaI::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaT_entry() //  [R1]
         { info_tbl: [(c6zLC,
                       label: sat_s6vaT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zLC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zLG; else goto c6zLF;
       c6zLG: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zLF: // global
           _s6vaI::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaU_entry() //  [R1]
         { info_tbl: [(c6zLL,
                       label: sat_s6vaU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zLL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6zLM; else goto c6zLN;
       c6zLM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zLN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6zLg_info;
           _s6vaI::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6vaI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6zLU; else goto c6zLh;
       u6zLU: // global
           call _c6zLg(R1) args: 0, res: 0, upd: 0;
       c6zLh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6zLg() //  [R1]
         { info_tbl: [(c6zLg,
                       label: block_c6zLg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zLg: // global
           _s6vaI::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6zLI; else goto c6zLJ;
       c6zLI: // global
           Hp = Hp + 24;
           _s6vaP::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zLT; else goto c6zLP;
       c6zLP: // global
           I64[Hp - 16] = sat_s6vaR_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6zLJ: // global
           Hp = Hp + 24;
           _s6vaP::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zLT; else goto c6zLS;
       c6zLT: // global
           HpAlloc = 24;
           R1 = _s6vaP::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6zLS: // global
           I64[Hp - 16] = sat_s6vaT_info;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vaV_entry() //  [R1]
         { info_tbl: [(c6zLV,
                       label: sat_s6vaV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zLV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zLZ; else goto c6zLY;
       c6zLZ: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zLY: // global
           _s6vaH::P64 = P64[R1 + 16];
           _s6vaI::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vaU_info;
           P64[Hp - 8] = _s6vaH::P64;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vaW_entry() //  [R1]
         { info_tbl: [(c6zM0,
                       label: sat_s6vaW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zM0: // global
           _s6vaW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zM1; else goto c6zM2;
       c6zM2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zM4; else goto c6zM3;
       c6zM4: // global
           HpAlloc = 32;
           goto c6zM1;
       c6zM1: // global
           R1 = _s6vaW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zM3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vaW::P64;
           _s6vaH::P64 = P64[_s6vaW::P64 + 16];
           _s6vaI::P64 = P64[_s6vaW::P64 + 24];
           I64[Hp - 24] = sat_s6vaV_info;
           P64[Hp - 8] = _s6vaH::P64;
           P64[Hp] = _s6vaI::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6zM8,
                       label: Data.Semigroup.Internal.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zM8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6zMc; else goto c6zMb;
       c6zMc: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zMb: // global
           if (%MO_S_Lt_W64(R2, 11)) goto c6zM6; else goto c6zM7;
       c6zM6: // global
           I64[Hp - 48] = sat_s6vaO_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _c6zKh::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c6zKh::P64;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6zM7: // global
           I64[Hp - 48] = sat_s6vaW_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.526557787 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6zN7,
                       label: Data.Semigroup.Internal.$fShowAll_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zN7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6zN8; else goto c6zN9;
       c6zN8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zN9: // global
           I64[Sp - 24] = block_c6zN4_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6zNd; else goto c6zN5;
       u6zNd: // global
           call _c6zN4(R1) args: 0, res: 0, upd: 0;
       c6zN5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6zN4() //  [R1]
         { info_tbl: [(c6zN4,
                       label: block_c6zN4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zN4: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.5334316 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshow_info;
         const 0;
 },
 sat_s6vb4_entry() //  [R1]
         { info_tbl: [(c6zNG,
                       label: sat_s6vb4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zNG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6zNH; else goto c6zNI;
       c6zNH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zNI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6zNz_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6zNP; else goto c6zNA;
       u6zNP: // global
           call _c6zNz(R1) args: 0, res: 0, upd: 0;
       c6zNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6zNz() //  [R1]
         { info_tbl: [(c6zNz,
                       label: block_c6zNz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zNz: // global
           if (R1 & 7 == 1) goto c6zND; else goto c6zNE;
       c6zND: // global
           R1 = Data.Semigroup.Internal.$fShowAll6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6zNE: // global
           R1 = Data.Semigroup.Internal.$fShowAll5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vb5_entry() //  [R1]
         { info_tbl: [(c6zNQ,
                       label: sat_s6vb5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zNQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zNU; else goto c6zNT;
       c6zNU: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zNT: // global
           _s6vb2::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s6vb4_info;
           P64[Hp] = _s6vb2::P64;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAll_$cshow_entry() //  [R2]
         { info_tbl: [(c6zNV,
                       label: Data.Semigroup.Internal.$fShowAll_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zNV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zNZ; else goto c6zNY;
       c6zNZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zNY: // global
           I64[Hp - 16] = sat_s6vb5_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.544763427 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll1_closure" {
     Data.Semigroup.Internal.$fShowAll1_closure:
         const Data.Semigroup.Internal.$fShowAll1_info;
         const 0;
 },
 sat_s6vb9_entry() //  [R1]
         { info_tbl: [(c6zOE,
                       label: sat_s6vb9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zOE: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vba_entry() //  [R1]
         { info_tbl: [(c6zON,
                       label: sat_s6vba_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zON: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vbb_entry() //  [R1]
         { info_tbl: [(c6zOU,
                       label: sat_s6vbb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zOU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6zOV; else goto c6zOW;
       c6zOV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zOW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6zOv_info;
           _s6vb7::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6vb7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6zP3; else goto c6zOw;
       u6zP3: // global
           call _c6zOv(R1) args: 0, res: 0, upd: 0;
       c6zOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6zOv() //  [R1]
         { info_tbl: [(c6zOv,
                       label: block_c6zOv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zOv: // global
           _s6vb7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6zOR; else goto c6zOS;
       c6zOR: // global
           Hp = Hp + 24;
           _s6vb8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zP2; else goto c6zOY;
       c6zOY: // global
           I64[Hp - 16] = sat_s6vb9_info;
           P64[Hp] = _s6vb7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6zOS: // global
           Hp = Hp + 24;
           _s6vb8::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6zP2; else goto c6zP1;
       c6zP2: // global
           HpAlloc = 24;
           R1 = _s6vb8::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6zP1: // global
           I64[Hp - 16] = sat_s6vba_info;
           P64[Hp] = _s6vb7::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbc_entry() //  [R1]
         { info_tbl: [(c6zP4,
                       label: sat_s6vbc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zP4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zP8; else goto c6zP7;
       c6zP8: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zP7: // global
           _s6vb6::P64 = P64[R1 + 16];
           _s6vb7::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6vbb_info;
           P64[Hp - 8] = _s6vb6::P64;
           P64[Hp] = _s6vb7::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAll1_entry() //  [R2, R3]
         { info_tbl: [(c6zP9,
                       label: Data.Semigroup.Internal.$fShowAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zP9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zPd; else goto c6zPc;
       c6zPd: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zPc: // global
           I64[Hp - 24] = sat_s6vbc_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.558605699 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshowList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c6zPF,
                       label: Data.Semigroup.Internal.$fShowAll_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zPF: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fShowAll1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.562754849 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_closure" {
     Data.Semigroup.Internal.$fShowAll_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure+3;
         const Data.Semigroup.Internal.$fShowAll_$cshow_closure+1;
         const Data.Semigroup.Internal.$fShowAll_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.564610172 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll13_bytes" {
     Data.Semigroup.Internal.$fReadAll13_bytes:
         I8[] [65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.566661521 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll12_closure" {
     Data.Semigroup.Internal.$fReadAll12_closure:
         const Data.Semigroup.Internal.$fReadAll12_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll12_entry() //  [R1]
         { info_tbl: [(c6zPU,
                       label: Data.Semigroup.Internal.$fReadAll12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zPU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zPV; else goto c6zPW;
       c6zPV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zPW: // global
           (_c6zPR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zPR::I64 == 0) goto c6zPT; else goto c6zPS;
       c6zPT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zPS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zPR::I64;
           R2 = Data.Semigroup.Internal.$fReadAll13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.571046718 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_lexeme1_closure" {
     Data.Semigroup.Internal.$fReadAll_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAll12_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.572791038 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll9_bytes" {
     Data.Semigroup.Internal.$fReadAll9_bytes:
         I8[] [103,101,116,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.57467747 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll8_closure" {
     Data.Semigroup.Internal.$fReadAll8_closure:
         const Data.Semigroup.Internal.$fReadAll8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll8_entry() //  [R1]
         { info_tbl: [(c6zQc,
                       label: Data.Semigroup.Internal.$fReadAll8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zQc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zQd; else goto c6zQe;
       c6zQd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zQe: // global
           (_c6zQ9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zQ9::I64 == 0) goto c6zQb; else goto c6zQa;
       c6zQb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zQa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zQ9::I64;
           R2 = Data.Semigroup.Internal.$fReadAll9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.580183508 UTC

[section ""data" . Data.Semigroup.Internal.$w$creadPrec_closure" {
     Data.Semigroup.Internal.$w$creadPrec_closure:
         const Data.Semigroup.Internal.$w$creadPrec_info;
         const 0;
 },
 sat_s6vbm_entry() //  [R1]
         { info_tbl: [(c6zQO,
                       label: sat_s6vbm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zQO: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vbp_entry() //  [R1, R2]
         { info_tbl: [(c6zQU,
                       label: sat_s6vbp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zQU: // global
           _s6vbk::P64 = R2;
           _s6vbp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6zQV; else goto c6zQW;
       c6zQW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zQY; else goto c6zQX;
       c6zQY: // global
           HpAlloc = 24;
           goto c6zQV;
       c6zQV: // global
           R2 = _s6vbk::P64;
           R1 = _s6vbp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zQX: // global
           _s6vbg::P64 = P64[_s6vbp::P64 + 7];
           I64[Hp - 16] = sat_s6vbm_info;
           P64[Hp - 8] = _s6vbg::P64;
           P64[Hp] = _s6vbk::P64;
           I64[Sp - 8] = block_c6zQR_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zQR() //  [R1]
         { info_tbl: [(c6zQR,
                       label: block_c6zQR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zQR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zR1; else goto c6zR0;
       c6zR1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zR0: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6zRw_srtd" {
     u6zRw_srtd:
         const S6vn0_srt+128;
         const 59;
         const 288245769314500609;
 },
 sat_s6vbq_entry() //  [R1, R2]
         { info_tbl: [(c6zR2,
                       label: sat_s6vbq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zR2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zR6; else goto c6zR5;
       c6zR6: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zR5: // global
           _s6vbg::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s6vbp_info;
           P64[Hp] = _s6vbg::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = Data.Semigroup.Internal.$fReadAll7_closure+2;
           R2 = Data.Semigroup.Internal.$fReadAll8_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6zRx_srtd" {
     u6zRx_srtd:
         const S6vn0_srt+128;
         const 59;
         const 288245769314500613;
 },
 sat_s6vbt_entry() //  [R1, R2]
         { info_tbl: [(c6zRa,
                       label: sat_s6vbt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zRa: // global
           _s6vbi::P64 = R2;
           _s6vbt::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6zRb; else goto c6zRc;
       c6zRc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zRe; else goto c6zRd;
       c6zRe: // global
           HpAlloc = 16;
           goto c6zRb;
       c6zRb: // global
           R2 = _s6vbi::P64;
           R1 = _s6vbt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zRd: // global
           _s6vbg::P64 = P64[_s6vbt::P64 + 7];
           I64[Hp - 8] = sat_s6vbq_info;
           P64[Hp] = _s6vbg::P64;
           I64[Sp - 8] = block_c6zR7_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zR7() //  [R1]
         { info_tbl: [(c6zR7,
                       label: block_c6zR7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zR7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zRh; else goto c6zRg;
       c6zRh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zRg: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6zRy_srtd" {
     u6zRy_srtd:
         const S6vn0_srt+128;
         const 61;
         const 2017628026224771077;
 },
 Data.Semigroup.Internal.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(c6zRl,
                       label: Data.Semigroup.Internal.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zRl: // global
           _s6vbg::P64 = R3;
           _s6vbf::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c6zRm; else goto c6zRn;
       c6zRn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zRp; else goto c6zRo;
       c6zRp: // global
           HpAlloc = 16;
           goto c6zRm;
       c6zRm: // global
           R3 = _s6vbg::P64;
           R2 = _s6vbf::I64;
           R1 = Data.Semigroup.Internal.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zRo: // global
           if (%MO_S_Gt_W64(_s6vbf::I64, 11)) goto c6zRj; else goto c6zRk;
       c6zRj: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6zRk: // global
           I64[Hp - 8] = sat_s6vbt_info;
           P64[Hp] = _s6vbg::P64;
           I64[Sp - 8] = block_c6zRq_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6zRq() //  [R1]
         { info_tbl: [(c6zRq,
                       label: block_c6zRq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zRq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zRv; else goto c6zRu;
       c6zRv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6zRu: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.601128901 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll2_closure" {
     Data.Semigroup.Internal.$fReadAll2_closure:
         const Data.Semigroup.Internal.$fReadAll2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll2_entry() //  [R2, R3]
         { info_tbl: [(c6zSf,
                       label: Data.Semigroup.Internal.$fReadAll2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zSf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zSg; else goto c6zSh;
       c6zSg: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAll2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zSh: // global
           I64[Sp - 16] = block_c6zSc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6zSl; else goto c6zSd;
       u6zSl: // global
           call _c6zSc(R1) args: 0, res: 0, upd: 0;
       c6zSd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6zSc() //  [R1]
         { info_tbl: [(c6zSc,
                       label: block_c6zSc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zSc: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$creadPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.609926773 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll1_closure" {
     Data.Semigroup.Internal.$fReadAll1_closure:
         const Data.Semigroup.Internal.$fReadAll1_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll1_entry() //  [R2, R3]
         { info_tbl: [(c6zSz,
                       label: Data.Semigroup.Internal.$fReadAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zSz: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAll2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.614713752 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_info;
         const 0;
 },
 sat_s6vbB_entry() //  [R1]
         { info_tbl: [(c6zSO,
                       label: sat_s6vbB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zSO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zSP; else goto c6zSQ;
       c6zSP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zSQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAll_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6zSR,
                       label: Data.Semigroup.Internal.$fReadAll_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zSR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zSV; else goto c6zSU;
       c6zSV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zSU: // global
           I64[Hp - 16] = sat_s6vbB_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.621612042 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c6zTa,
                       label: Data.Semigroup.Internal.$fReadAll_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zTa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zTb; else goto c6zTc;
       c6zTb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zTc: // global
           (_c6zT7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zT7::I64 == 0) goto c6zT9; else goto c6zT8;
       c6zT9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zT8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zT7::I64;
           R2 = Data.Semigroup.Internal.$fReadAll1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.626138042 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll14_closure" {
     Data.Semigroup.Internal.$fReadAll14_closure:
         const Data.Semigroup.Internal.$fReadAll14_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll14_entry() //  [R1]
         { info_tbl: [(c6zTq,
                       label: Data.Semigroup.Internal.$fReadAll14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zTq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zTr; else goto c6zTs;
       c6zTr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zTs: // global
           (_c6zTn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6zTn::I64 == 0) goto c6zTp; else goto c6zTo;
       c6zTp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6zTo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6zTn::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.630984541 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll_$creadList_entry() //  [R2]
         { info_tbl: [(c6zTE,
                       label: Data.Semigroup.Internal.$fReadAll_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zTE: // global
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAll14_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.634801939 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_closure" {
     Data.Semigroup.Internal.$fReadAll_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure+1;
         const Data.Semigroup.Internal.$fReadAll_$creadList_closure+1;
         const Data.Semigroup.Internal.$fReadAll1_closure+2;
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.637324092 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAll_closure" {
     Data.Semigroup.Internal.$fEqAll_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.$fEqBool_$c==_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.639253825 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAll_closure" {
     Data.Semigroup.Internal.$fOrdAll_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Semigroup.Internal.$fEqAll_closure+1;
         const GHC.Classes.$fOrdBool_$ccompare_closure+2;
         const GHC.Classes.$fOrdBool_$c<_closure+2;
         const GHC.Classes.$fOrdBool_$c<=_closure+2;
         const GHC.Classes.$fOrdBool_$c>_closure+2;
         const GHC.Classes.$fOrdBool_$c>=_closure+2;
         const GHC.Classes.$fOrdBool_$cmax_closure+2;
         const GHC.Classes.$fOrdBool_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.641456487 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo1_closure" {
     Data.Semigroup.Internal.$fGenericEndo1_closure:
         const Data.Semigroup.Internal.$fGenericEndo1_info;
 },
 Data.Semigroup.Internal.$fGenericEndo1_entry() //  [R2]
         { info_tbl: [(c6zTS,
                       label: Data.Semigroup.Internal.$fGenericEndo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zTS: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.644965554 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo2_closure" {
     Data.Semigroup.Internal.$fGenericEndo2_closure:
         const Data.Semigroup.Internal.$fGenericEndo2_info;
 },
 Data.Semigroup.Internal.$fGenericEndo2_entry() //  [R2]
         { info_tbl: [(c6zU3,
                       label: Data.Semigroup.Internal.$fGenericEndo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zU3: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.648608454 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo_closure" {
     Data.Semigroup.Internal.$fGenericEndo_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericEndo2_closure+1;
         const Data.Semigroup.Internal.$fGenericEndo1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.650638428 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual1_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual1_closure:
         const Data.Semigroup.Internal.$fGeneric1Dual1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Dual1_entry() //  [R2]
         { info_tbl: [(c6zUf,
                       label: Data.Semigroup.Internal.$fGeneric1Dual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zUf: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.654195247 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual2_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual2_closure:
         const Data.Semigroup.Internal.$fGeneric1Dual2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Dual2_entry() //  [R2]
         { info_tbl: [(c6zUq,
                       label: Data.Semigroup.Internal.$fGeneric1Dual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zUq: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.657571936 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Dual2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Dual1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.659993423 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual1_closure" {
     Data.Semigroup.Internal.$fGenericDual1_closure:
         const Data.Semigroup.Internal.$fGenericDual1_info;
 },
 Data.Semigroup.Internal.$fGenericDual1_entry() //  [R2]
         { info_tbl: [(c6zUC,
                       label: Data.Semigroup.Internal.$fGenericDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zUC: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.663837848 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual2_closure" {
     Data.Semigroup.Internal.$fGenericDual2_closure:
         const Data.Semigroup.Internal.$fGenericDual2_info;
 },
 Data.Semigroup.Internal.$fGenericDual2_entry() //  [R2]
         { info_tbl: [(c6zUN,
                       label: Data.Semigroup.Internal.$fGenericDual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zUN: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.667084155 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual_closure" {
     Data.Semigroup.Internal.$fGenericDual_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericDual2_closure+1;
         const Data.Semigroup.Internal.$fGenericDual1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.669232478 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedDual_closure" {
     Data.Semigroup.Internal.$fBoundedDual_closure:
         const Data.Semigroup.Internal.$fBoundedDual_info;
 },
 sat_s6vbK_entry() //  [R1]
         { info_tbl: [(c6zV3,
                       label: sat_s6vbK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zV3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zV4; else goto c6zV5;
       c6zV4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zV5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbJ_entry() //  [R1]
         { info_tbl: [(c6zVa,
                       label: sat_s6vbJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zVa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zVb; else goto c6zVc;
       c6zVb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zVc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedDual_entry() //  [R2]
         { info_tbl: [(c6zVe,
                       label: Data.Semigroup.Internal.$fBoundedDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zVe: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6zVi; else goto c6zVh;
       c6zVi: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zVh: // global
           I64[Hp - 64] = sat_s6vbK_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6vbJ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.677031129 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowDual2_bytes" {
     Data.Semigroup.Internal.$fShowDual2_bytes:
         I8[] [68,117,97,108,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.678826765 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowDual1_bytes" {
     Data.Semigroup.Internal.$fShowDual1_bytes:
         I8[] [103,101,116,68,117,97,108,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.683514216 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec3_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec3_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec3_info;
 },
 f_s6vbO_entry() //  [R1]
         { info_tbl: [(c6zVI,
                       label: f_s6vbO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zVI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6zVJ; else goto c6zVK;
       c6zVJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zVK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vbR_entry() //  [R1]
         { info_tbl: [(c6zW5,
                       label: sat_s6vbR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zW5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6zW6; else goto c6zW7;
       c6zW6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zW7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbS_entry() //  [R1]
         { info_tbl: [(c6zW8,
                       label: sat_s6vbS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zW8: // global
           _s6vbS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zW9; else goto c6zWa;
       c6zWa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zWc; else goto c6zWb;
       c6zWc: // global
           HpAlloc = 24;
           goto c6zW9;
       c6zW9: // global
           R1 = _s6vbS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zWb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbS::P64;
           _s6vbO::P64 = P64[_s6vbS::P64 + 16];
           _s6vbQ::P64 = P64[_s6vbS::P64 + 24];
           I64[Hp - 16] = sat_s6vbR_info;
           P64[Hp] = _s6vbQ::P64;
           R2 = Hp - 16;
           R1 = _s6vbO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbT_entry() //  [R1]
         { info_tbl: [(c6zWd,
                       label: sat_s6vbT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zWd: // global
           _s6vbT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zWe; else goto c6zWf;
       c6zWf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zWh; else goto c6zWg;
       c6zWh: // global
           HpAlloc = 32;
           goto c6zWe;
       c6zWe: // global
           R1 = _s6vbT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zWg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbT::P64;
           _s6vbO::P64 = P64[_s6vbT::P64 + 16];
           _s6vbQ::P64 = P64[_s6vbT::P64 + 24];
           I64[Hp - 24] = sat_s6vbS_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = _s6vbQ::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbU_entry() //  [R1, R2]
         { info_tbl: [(c6zWi,
                       label: sat_s6vbU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zWi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zWm; else goto c6zWl;
       c6zWm: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zWl: // global
           _s6vbO::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6vbT_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vbX_entry() //  [R1]
         { info_tbl: [(c6zWK,
                       label: sat_s6vbX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zWK: // global
           _s6vbX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zWL; else goto c6zWM;
       c6zWM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zWO; else goto c6zWN;
       c6zWO: // global
           HpAlloc = 24;
           goto c6zWL;
       c6zWL: // global
           R1 = _s6vbX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zWN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbX::P64;
           _s6vbV::P64 = P64[_s6vbX::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6vbV::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbY_entry() //  [R1]
         { info_tbl: [(c6zWP,
                       label: sat_s6vbY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zWP: // global
           _s6vbY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zWQ; else goto c6zWR;
       c6zWR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6zWT; else goto c6zWS;
       c6zWT: // global
           HpAlloc = 24;
           goto c6zWQ;
       c6zWQ: // global
           R1 = _s6vbY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zWS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbY::P64;
           _s6vbO::P64 = P64[_s6vbY::P64 + 16];
           _s6vbV::P64 = P64[_s6vbY::P64 + 24];
           I64[Hp - 16] = sat_s6vbX_info;
           P64[Hp] = _s6vbV::P64;
           R2 = Hp - 16;
           R1 = _s6vbO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vbZ_entry() //  [R1]
         { info_tbl: [(c6zWU,
                       label: sat_s6vbZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zWU: // global
           _s6vbZ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zWV; else goto c6zWW;
       c6zWW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zWY; else goto c6zWX;
       c6zWY: // global
           HpAlloc = 32;
           goto c6zWV;
       c6zWV: // global
           R1 = _s6vbZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zWX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vbZ::P64;
           _s6vbO::P64 = P64[_s6vbZ::P64 + 16];
           _s6vbV::P64 = P64[_s6vbZ::P64 + 24];
           I64[Hp - 24] = sat_s6vbY_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = _s6vbV::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vc0_entry() //  [R1]
         { info_tbl: [(c6zWZ,
                       label: sat_s6vc0_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zWZ: // global
           _s6vc0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zX0; else goto c6zX1;
       c6zX1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zX3; else goto c6zX2;
       c6zX3: // global
           HpAlloc = 32;
           goto c6zX0;
       c6zX0: // global
           R1 = _s6vc0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zX2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vc0::P64;
           _s6vbO::P64 = P64[_s6vc0::P64 + 16];
           _s6vbV::P64 = P64[_s6vc0::P64 + 24];
           I64[Hp - 24] = sat_s6vbZ_info;
           P64[Hp - 8] = _s6vbO::P64;
           P64[Hp] = _s6vbV::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vc1_entry() //  [R1, R2]
         { info_tbl: [(c6zX5,
                       label: sat_s6vc1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zX5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6zX9; else goto c6zX8;
       c6zX9: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zX8: // global
           _s6vbO::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6vc0_info;
           P64[Hp - 32] = _s6vbO::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec3_entry() //  [R2, R3, R4]
         { info_tbl: [(c6zXd,
                       label: Data.Semigroup.Internal.$w$cshowsPrec3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zXd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6zXh; else goto c6zXg;
       c6zXh: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zXg: // global
           I64[Hp - 40] = f_s6vbO_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6zVE::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6zXb; else goto c6zXc;
       c6zXb: // global
           I64[Hp - 8] = sat_s6vbU_info;
           P64[Hp] = _c6zVE::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6zXc: // global
           I64[Hp - 8] = sat_s6vc1_info;
           P64[Hp] = _c6zVE::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.710032621 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowDual_$cshowsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c6zYa,
                       label: Data.Semigroup.Internal.$fShowDual_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zYa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6zYb; else goto c6zYc;
       c6zYb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zYc: // global
           I64[Sp - 24] = block_c6zY7_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6zYg; else goto c6zY8;
       u6zYg: // global
           call _c6zY7(R1) args: 0, res: 0, upd: 0;
       c6zY8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6zY7() //  [R1]
         { info_tbl: [(c6zY7,
                       label: block_c6zY7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zY7: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec3_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.716491649 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshow_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshow_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshow_info;
         const 0;
 },
 sat_s6vc9_entry() //  [R1]
         { info_tbl: [(c6zYC,
                       label: sat_s6vc9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zYC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6zYD; else goto c6zYE;
       c6zYD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zYE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6vca_entry() //  [R1]
         { info_tbl: [(c6zYF,
                       label: sat_s6vca_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zYF: // global
           _s6vca::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6zYG; else goto c6zYH;
       c6zYH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zYJ; else goto c6zYI;
       c6zYJ: // global
           HpAlloc = 32;
           goto c6zYG;
       c6zYG: // global
           R1 = _s6vca::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6zYI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vca::P64;
           _s6vc7::P64 = P64[_s6vca::P64 + 16];
           _s6vc8::P64 = P64[_s6vca::P64 + 24];
           I64[Hp - 24] = sat_s6vc9_info;
           P64[Hp - 8] = _s6vc7::P64;
           P64[Hp] = _s6vc8::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowDual_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6zYK,
                       label: Data.Semigroup.Internal.$fShowDual_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zYK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6zYO; else goto c6zYN;
       c6zYO: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zYN: // global
           I64[Hp - 24] = sat_s6vca_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.725233457 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshowList_info;
 },
 sat_s6vcf_entry() //  [R1, R2]
         { info_tbl: [(c6zZb,
                       label: sat_s6vcf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zZb: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec3_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowDual_$cshowList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6zZe,
                       label: Data.Semigroup.Internal.$fShowDual_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zZe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6zZi; else goto c6zZh;
       c6zZi: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6zZh: // global
           I64[Hp - 8] = sat_s6vcf_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.732203362 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_closure" {
     Data.Semigroup.Internal.$fShowDual_closure:
         const Data.Semigroup.Internal.$fShowDual_info;
         const 0;
 },
 sat_s6vcj_entry() //  [R1, R2, R3]
         { info_tbl: [(c6zZz,
                       label: sat_s6vcj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zZz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowDual_$cshowList_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vci_entry() //  [R1, R2]
         { info_tbl: [(c6zZH,
                       label: sat_s6vci_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zZH: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowDual_$cshow_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vch_entry() //  [R1, R2, R3]
         { info_tbl: [(c6zZP,
                       label: sat_s6vch_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zZP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowDual_$cshowsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowDual_entry() //  [R2]
         { info_tbl: [(c6zZT,
                       label: Data.Semigroup.Internal.$fShowDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6zZT: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6zZX; else goto c6zZW;
       c6zZX: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6zZW: // global
           I64[Hp - 72] = sat_s6vcj_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6vci_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6vch_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.74123116 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadDual5_bytes" {
     Data.Semigroup.Internal.$fReadDual5_bytes:
         I8[] [68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.743197159 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual4_closure" {
     Data.Semigroup.Internal.$fReadDual4_closure:
         const Data.Semigroup.Internal.$fReadDual4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadDual4_entry() //  [R1]
         { info_tbl: [(c6A0m,
                       label: Data.Semigroup.Internal.$fReadDual4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A0m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A0n; else goto c6A0o;
       c6A0n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A0o: // global
           (_c6A0j::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6A0j::I64 == 0) goto c6A0l; else goto c6A0k;
       c6A0l: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6A0k: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6A0j::I64;
           R2 = Data.Semigroup.Internal.$fReadDual5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.747397428 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_lexeme_closure" {
     Data.Semigroup.Internal.$fReadDual_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadDual4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.749139217 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadDual3_bytes" {
     Data.Semigroup.Internal.$fReadDual3_bytes:
         I8[] [103,101,116,68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.75116931 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual2_closure" {
     Data.Semigroup.Internal.$fReadDual2_closure:
         const Data.Semigroup.Internal.$fReadDual2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadDual2_entry() //  [R1]
         { info_tbl: [(c6A0E,
                       label: Data.Semigroup.Internal.$fReadDual2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A0E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A0F; else goto c6A0G;
       c6A0F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A0G: // global
           (_c6A0B::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6A0B::I64 == 0) goto c6A0D; else goto c6A0C;
       c6A0D: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6A0C: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6A0B::I64;
           R2 = Data.Semigroup.Internal.$fReadDual3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.760289386 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual1_closure" {
     Data.Semigroup.Internal.$fReadDual1_closure:
         const Data.Semigroup.Internal.$fReadDual1_info;
         const 0;
 },
 lvl12_s6vcl_entry() //  [R1]
         { info_tbl: [(c6A0W,
                       label: lvl12_s6vcl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A0W: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6A0X; else goto c6A0Y;
       c6A0X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A0Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6vcm_entry() //  [R1]
         { info_tbl: [(c6A14,
                       label: ds_s6vcm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A14: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vcx_entry() //  [R1]
         { info_tbl: [(c6A1F,
                       label: sat_s6vcx_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A1F: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vcA_entry() //  [R1, R2]
         { info_tbl: [(c6A1L,
                       label: sat_s6vcA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A1L: // global
           _s6vcv::P64 = R2;
           _s6vcA::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6A1M; else goto c6A1N;
       c6A1N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6A1P; else goto c6A1O;
       c6A1P: // global
           HpAlloc = 24;
           goto c6A1M;
       c6A1M: // global
           R2 = _s6vcv::P64;
           R1 = _s6vcA::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A1O: // global
           _s6vcp::P64 = P64[_s6vcA::P64 + 7];
           I64[Hp - 16] = sat_s6vcx_info;
           P64[Hp - 8] = _s6vcp::P64;
           P64[Hp] = _s6vcv::P64;
           I64[Sp - 8] = block_c6A1I_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6A1I() //  [R1]
         { info_tbl: [(c6A1I,
                       label: block_c6A1I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A1I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6A1S; else goto c6A1R;
       c6A1S: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6A1R: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6A2u_srtd" {
     u6A2u_srtd:
         const S6vn0_srt+128;
         const 70;
         const 6597069766657;
         const 32;
 },
 sat_s6vcB_entry() //  [R1, R2]
         { info_tbl: [(c6A1T,
                       label: sat_s6vcB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A1T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6A1X; else goto c6A1W;
       c6A1X: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A1W: // global
           _s6vcm::P64 = P64[R1 + 7];
           _s6vcp::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6vcA_info;
           P64[Hp] = _s6vcp::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6vcm::P64;
           R2 = Data.Semigroup.Internal.$fReadDual2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6A2v_srtd" {
     u6A2v_srtd:
         const S6vn0_srt+128;
         const 70;
         const 6597069766661;
         const 32;
 },
 sat_s6vcE_entry() //  [R1, R2]
         { info_tbl: [(c6A21,
                       label: sat_s6vcE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A21: // global
           _s6vct::P64 = R2;
           _s6vcE::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6A22; else goto c6A23;
       c6A23: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6A25; else goto c6A24;
       c6A25: // global
           HpAlloc = 24;
           goto c6A22;
       c6A22: // global
           R2 = _s6vct::P64;
           R1 = _s6vcE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A24: // global
           _s6vcm::P64 = P64[_s6vcE::P64 + 7];
           _s6vcp::P64 = P64[_s6vcE::P64 + 15];
           I64[Hp - 16] = sat_s6vcB_info;
           P64[Hp - 8] = _s6vcm::P64;
           P64[Hp] = _s6vcp::P64;
           I64[Sp - 8] = block_c6A1Y_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6A1Y() //  [R1]
         { info_tbl: [(c6A1Y,
                       label: block_c6A1Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A1Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6A28; else goto c6A27;
       c6A28: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6A27: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6A2w_srtd" {
     u6A2w_srtd:
         const S6vn0_srt+128;
         const 71;
         const 6597069766661;
         const 96;
 },
 sat_s6vcH_entry() //  [R1, R2, R3]
         { info_tbl: [(c6A29,
                       label: sat_s6vcH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A29: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6A2a; else goto c6A2b;
       c6A2a: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6A2b: // global
           I64[Sp - 24] = block_c6A1c_info;
           _s6vcm::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6vcm::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6A2o; else goto c6A1d;
       u6A2o: // global
           call _c6A1c(R1) args: 0, res: 0, upd: 0;
       c6A1d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u6A2x_srtd" {
     u6A2x_srtd:
         const S6vn0_srt+128;
         const 71;
         const 6597069766661;
         const 96;
 },
 _c6A1c() //  [R1]
         { info_tbl: [(c6A1c,
                       label: block_c6A1c_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A1c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6A2e; else goto c6A2d;
       c6A2e: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6A2d: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6A2g; else goto c6A2k;
       c6A2g: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6A2k: // global
           I64[Hp - 16] = sat_s6vcE_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6A2h_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadDual_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6A2h() //  [R1]
         { info_tbl: [(c6A2h,
                       label: block_c6A2h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A2h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6A2n; else goto c6A2m;
       c6A2n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6A2m: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6A2y_srtd" {
     u6A2y_srtd:
         const S6vn0_srt+128;
         const 72;
         const 7696581394437;
         const 224;
 },
 Data.Semigroup.Internal.$fReadDual1_entry() //  [R2]
         { info_tbl: [(c6A2p,
                       label: Data.Semigroup.Internal.$fReadDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A2p: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6A2t; else goto c6A2s;
       c6A2t: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A2s: // global
           I64[Hp - 48] = lvl12_s6vcl_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6vcm_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6vcH_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.792783385 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadsPrec_info;
         const 0;
 },
 ds_s6vcJ_entry() //  [R1]
         { info_tbl: [(c6A3A,
                       label: ds_s6vcJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A3A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A3B; else goto c6A3C;
       c6A3B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A3C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcL_entry() //  [R1]
         { info_tbl: [(c6A3M,
                       label: sat_s6vcL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A3M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A3N; else goto c6A3O;
       c6A3N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A3O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcM_entry() //  [R1, R2]
         { info_tbl: [(c6A3P,
                       label: sat_s6vcM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A3P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6A3T; else goto c6A3S;
       c6A3T: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A3S: // global
           _s6vcJ::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6vcL_info;
           P64[Hp - 8] = _s6vcJ::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6A3U,
                       label: Data.Semigroup.Internal.$fReadDual_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A3U: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6A3Y; else goto c6A3X;
       c6A3Y: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A3X: // global
           I64[Hp - 32] = ds_s6vcJ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6vcM_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.803140238 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadListPrec_info;
         const 0;
 },
 sat_s6vcO_entry() //  [R1]
         { info_tbl: [(c6A4o,
                       label: sat_s6vcO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A4o: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6A4r,
                       label: Data.Semigroup.Internal.$fReadDual_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A4r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6A4v; else goto c6A4u;
       c6A4v: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A4u: // global
           I64[Hp - 16] = sat_s6vcO_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.809349102 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadList_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadList_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadList_info;
         const 0;
 },
 sat_s6vcQ_entry() //  [R1]
         { info_tbl: [(c6A4P,
                       label: sat_s6vcQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A4P: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vcR_entry() //  [R1]
         { info_tbl: [(c6A4S,
                       label: sat_s6vcR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A4S: // global
           _s6vcR::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6A4T; else goto c6A4U;
       c6A4U: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6A4W; else goto c6A4V;
       c6A4W: // global
           HpAlloc = 24;
           goto c6A4T;
       c6A4T: // global
           R1 = _s6vcR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A4V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6vcR::P64;
           _s6vcP::P64 = P64[_s6vcR::P64 + 16];
           I64[Hp - 16] = sat_s6vcQ_info;
           P64[Hp] = _s6vcP::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadList_entry() //  [R2]
         { info_tbl: [(c6A4X,
                       label: Data.Semigroup.Internal.$fReadDual_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A4X: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6A51; else goto c6A50;
       c6A51: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A50: // global
           I64[Hp - 16] = sat_s6vcR_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.817928725 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_closure" {
     Data.Semigroup.Internal.$fReadDual_closure:
         const Data.Semigroup.Internal.$fReadDual_info;
         const 0;
 },
 sat_s6vcW_entry() //  [R1]
         { info_tbl: [(c6A5l,
                       label: sat_s6vcW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A5l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A5m; else goto c6A5n;
       c6A5m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A5n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcV_entry() //  [R1]
         { info_tbl: [(c6A5s,
                       label: sat_s6vcV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A5s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A5t; else goto c6A5u;
       c6A5t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A5u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcU_entry() //  [R1]
         { info_tbl: [(c6A5z,
                       label: sat_s6vcU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A5z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A5A; else goto c6A5B;
       c6A5A: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A5B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcT_entry() //  [R1]
         { info_tbl: [(c6A5G,
                       label: sat_s6vcT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A5G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A5H; else goto c6A5I;
       c6A5H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A5I: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadDual_entry() //  [R2]
         { info_tbl: [(c6A5K,
                       label: Data.Semigroup.Internal.$fReadDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A5K: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6A5O; else goto c6A5N;
       c6A5O: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A5N: // global
           I64[Hp - 128] = sat_s6vcW_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6vcV_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6vcU_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6vcT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.830848281 UTC

[section ""data" . Data.Semigroup.Internal.$fEqDual_closure" {
     Data.Semigroup.Internal.$fEqDual_closure:
         const Data.Semigroup.Internal.$fEqDual_info;
 },
 sat_s6vcZ_entry() //  [R1]
         { info_tbl: [(c6A6m,
                       label: sat_s6vcZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A6m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A6n; else goto c6A6o;
       c6A6n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A6o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vcY_entry() //  [R1]
         { info_tbl: [(c6A6t,
                       label: sat_s6vcY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A6t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A6u; else goto c6A6v;
       c6A6u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A6v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqDual_entry() //  [R2]
         { info_tbl: [(c6A6x,
                       label: Data.Semigroup.Internal.$fEqDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A6x: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6A6B; else goto c6A6A;
       c6A6B: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A6A: // global
           I64[Hp - 64] = sat_s6vcZ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6vcY_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.838734206 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdDual_$cp1Ord_info;
 },
 sat_s6vd1_entry() //  [R1]
         { info_tbl: [(c6A6Z,
                       label: sat_s6vd1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A6Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A70; else goto c6A71;
       c6A70: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A71: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdDual_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6A72,
                       label: Data.Semigroup.Internal.$fOrdDual_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A72: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6A76; else goto c6A75;
       c6A76: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A75: // global
           I64[Hp - 16] = sat_s6vd1_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqDual_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.845274204 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdDual_closure" {
     Data.Semigroup.Internal.$fOrdDual_closure:
         const Data.Semigroup.Internal.$fOrdDual_info;
 },
 sat_s6vda_entry() //  [R1]
         { info_tbl: [(c6A7n,
                       label: sat_s6vda_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A7n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A7o; else goto c6A7p;
       c6A7o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A7p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd9_entry() //  [R1]
         { info_tbl: [(c6A7u,
                       label: sat_s6vd9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A7u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A7v; else goto c6A7w;
       c6A7v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A7w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd8_entry() //  [R1]
         { info_tbl: [(c6A7B,
                       label: sat_s6vd8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A7B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A7C; else goto c6A7D;
       c6A7C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A7D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd7_entry() //  [R1]
         { info_tbl: [(c6A7I,
                       label: sat_s6vd7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A7I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A7J; else goto c6A7K;
       c6A7J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A7K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd6_entry() //  [R1]
         { info_tbl: [(c6A7P,
                       label: sat_s6vd6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A7P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A7Q; else goto c6A7R;
       c6A7Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A7R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd5_entry() //  [R1]
         { info_tbl: [(c6A7W,
                       label: sat_s6vd5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A7W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A7X; else goto c6A7Y;
       c6A7X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A7Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd4_entry() //  [R1]
         { info_tbl: [(c6A83,
                       label: sat_s6vd4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A83: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A84; else goto c6A85;
       c6A84: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A85: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vd3_entry() //  [R1]
         { info_tbl: [(c6A8a,
                       label: sat_s6vd3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A8a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6A8b; else goto c6A8c;
       c6A8b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6A8c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdDual_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdDual_entry() //  [R2]
         { info_tbl: [(c6A8e,
                       label: Data.Semigroup.Internal.$fOrdDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A8e: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6A8i; else goto c6A8h;
       c6A8i: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6A8h: // global
           I64[Hp - 256] = sat_s6vda_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6vd9_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6vd8_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6vd7_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6vd6_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6vd5_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6vd4_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6vd3_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.864939115 UTC

[section ""data" . Data.Semigroup.Internal.getDual_closure" {
     Data.Semigroup.Internal.getDual_closure:
         const Data.Semigroup.Internal.getDual_info;
 },
 Data.Semigroup.Internal.getDual_entry() //  [R2]
         { info_tbl: [(c6A96,
                       label: Data.Semigroup.Internal.getDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A96: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Dual2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.868668351 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadDual_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadDual_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadDual_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6A9h,
                       label: Data.Semigroup.Internal.$fMonadDual_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A9h: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.872331472 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadDual_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadDual_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadDual_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6A9s,
                       label: Data.Semigroup.Internal.$fMonadDual_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A9s: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeDual_$c*>_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.876702047 UTC

[section ""data" . lvl_r6v16_closure" {
     lvl_r6v16_closure:
         const lvl_r6v16_info;
         const 0;
 },
 lvl_r6v16_entry() //  [R2]
         { info_tbl: [(c6A9D,
                       label: lvl_r6v16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A9D: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.879838607 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_closure" {
     Data.Semigroup.Internal.$fMonadDual_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeDual_closure+1;
         const Data.Semigroup.Internal.$fMonadDual_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadDual_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl_r6v16_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.881965609 UTC

[section ""data" . Data.Semigroup.Internal.appEndo1_closure" {
     Data.Semigroup.Internal.appEndo1_closure:
         const Data.Semigroup.Internal.appEndo1_info;
 },
 Data.Semigroup.Internal.appEndo1_entry() //  [R2]
         { info_tbl: [(c6A9P,
                       label: Data.Semigroup.Internal.appEndo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6A9P: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.885205036 UTC

[section ""data" . Data.Semigroup.Internal.appEndo_closure" {
     Data.Semigroup.Internal.appEndo_closure:
         const Data.Semigroup.Internal.appEndo_info;
 },
 Data.Semigroup.Internal.appEndo_entry() //  [R2]
         { info_tbl: [(c6Aa0,
                       label: Data.Semigroup.Internal.appEndo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aa0: // global
           R2 = R2;
           call Data.Semigroup.Internal.appEndo1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.888842841 UTC

[section ""data" . Data.Semigroup.Internal.getAll1_closure" {
     Data.Semigroup.Internal.getAll1_closure:
         const Data.Semigroup.Internal.getAll1_info;
 },
 Data.Semigroup.Internal.getAll1_entry() //  [R2]
         { info_tbl: [(c6Aab,
                       label: Data.Semigroup.Internal.getAll1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aab: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.892330135 UTC

[section ""data" . Data.Semigroup.Internal.getAll_closure" {
     Data.Semigroup.Internal.getAll_closure:
         const Data.Semigroup.Internal.getAll_info;
 },
 Data.Semigroup.Internal.getAll_entry() //  [R2]
         { info_tbl: [(c6Aao,
                       label: Data.Semigroup.Internal.getAll_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aao: // global
           R2 = R2;
           call Data.Semigroup.Internal.getAll1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.895876958 UTC

[section ""data" . Data.Semigroup.Internal.getAny1_closure" {
     Data.Semigroup.Internal.getAny1_closure:
         const Data.Semigroup.Internal.getAny1_info;
 },
 Data.Semigroup.Internal.getAny1_entry() //  [R2]
         { info_tbl: [(c6Aaz,
                       label: Data.Semigroup.Internal.getAny1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aaz: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.899857772 UTC

[section ""data" . Data.Semigroup.Internal.getAny_closure" {
     Data.Semigroup.Internal.getAny_closure:
         const Data.Semigroup.Internal.getAny_info;
 },
 Data.Semigroup.Internal.getAny_entry() //  [R2]
         { info_tbl: [(c6AaM,
                       label: Data.Semigroup.Internal.getAny_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AaM: // global
           R2 = R2;
           call Data.Semigroup.Internal.getAny1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.903269284 UTC

[section ""data" . Data.Semigroup.Internal.getSum_closure" {
     Data.Semigroup.Internal.getSum_closure:
         const Data.Semigroup.Internal.getSum_info;
 },
 Data.Semigroup.Internal.getSum_entry() //  [R2]
         { info_tbl: [(c6AaX,
                       label: Data.Semigroup.Internal.getSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AaX: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Sum2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.911347294 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadSum_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadSum_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadSum_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6Ab8,
                       label: Data.Semigroup.Internal.$fMonadSum_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ab8: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.91482683 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadSum_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadSum_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadSum_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6Abj,
                       label: Data.Semigroup.Internal.$fMonadSum_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Abj: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeSum_$c*>_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.918254462 UTC

[section ""data" . lvl1_r6v17_closure" {
     lvl1_r6v17_closure:
         const lvl1_r6v17_info;
         const 0;
 },
 lvl1_r6v17_entry() //  [R2]
         { info_tbl: [(c6Abu,
                       label: lvl1_r6v17_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Abu: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.921926987 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_closure" {
     Data.Semigroup.Internal.$fMonadSum_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeSum_closure+1;
         const Data.Semigroup.Internal.$fMonadSum_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadSum_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl1_r6v17_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.924054492 UTC

[section ""data" . Data.Semigroup.Internal.getProduct_closure" {
     Data.Semigroup.Internal.getProduct_closure:
         const Data.Semigroup.Internal.getProduct_info;
 },
 Data.Semigroup.Internal.getProduct_entry() //  [R2]
         { info_tbl: [(c6AbG,
                       label: Data.Semigroup.Internal.getProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AbG: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Product2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.927973913 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadProduct_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadProduct_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6AbR,
                       label: Data.Semigroup.Internal.$fMonadProduct_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AbR: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.931538662 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadProduct_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadProduct_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadProduct_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6Ac2,
                       label: Data.Semigroup.Internal.$fMonadProduct_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ac2: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeProduct_$c*>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.934921028 UTC

[section ""data" . lvl2_r6v18_closure" {
     lvl2_r6v18_closure:
         const lvl2_r6v18_info;
         const 0;
 },
 lvl2_r6v18_entry() //  [R2]
         { info_tbl: [(c6Acd,
                       label: lvl2_r6v18_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Acd: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.938515857 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_closure" {
     Data.Semigroup.Internal.$fMonadProduct_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeProduct_closure+1;
         const Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadProduct_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl2_r6v18_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.940556785 UTC

[section ""data" . Data.Semigroup.Internal.getAlt_closure" {
     Data.Semigroup.Internal.getAlt_closure:
         const Data.Semigroup.Internal.getAlt_info;
 },
 Data.Semigroup.Internal.getAlt_entry() //  [R2]
         { info_tbl: [(c6Acp,
                       label: Data.Semigroup.Internal.getAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Acp: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Alt2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.943864674 UTC

[section ""cstring" . lvl3_r6v19_bytes" {
     lvl3_r6v19_bytes:
         I8[] [115,116,105,109,101,115,73,100,101,109,112,111,116,101,110,116,58,32,112,111,115,105,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114,32,101,120,112,101,99,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.94598672 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotent1_closure" {
     Data.Semigroup.Internal.stimesIdempotent1_closure:
         const Data.Semigroup.Internal.stimesIdempotent1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesIdempotent1_entry() //  [R1]
         { info_tbl: [(c6AcF,
                       label: Data.Semigroup.Internal.stimesIdempotent1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AcF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6AcG; else goto c6AcH;
       c6AcG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AcH: // global
           (_c6AcA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6AcA::I64 == 0) goto c6AcC; else goto c6AcB;
       c6AcC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6AcB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6AcA::I64;
           I64[Sp - 24] = block_c6AcD_info;
           R2 = lvl3_r6v19_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6AcD() //  [R1]
         { info_tbl: [(c6AcD,
                       label: block_c6AcD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AcD: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.953176245 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotent_closure" {
     Data.Semigroup.Internal.stimesIdempotent_closure:
         const Data.Semigroup.Internal.stimesIdempotent_info;
         const 0;
 },
 sat_s6vdu_entry() //  [R1]
         { info_tbl: [(c6Ad9,
                       label: sat_s6vdu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ad9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Ada; else goto c6Adb;
       c6Ada: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Adb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6Ad7_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6Ad7() //  [R1]
         { info_tbl: [(c6Ad7,
                       label: block_c6Ad7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ad7: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesIdempotent_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Adf,
                       label: Data.Semigroup.Internal.stimesIdempotent_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Adf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Adh; else goto c6Adi;
       c6Adh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotent_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Adi: // global
           I64[Sp - 24] = block_c6AcZ_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AcZ() //  [R1]
         { info_tbl: [(c6AcZ,
                       label: block_c6AcZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AcZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Adl; else goto c6Adk;
       c6Adl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Adk: // global
           I64[Hp - 16] = sat_s6vdu_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6Adg_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Adg() //  [R1]
         { info_tbl: [(c6Adg,
                       label: block_c6Adg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Adg: // global
           _s6vdp::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c6Adp_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s6vdp::P64;
           Sp = Sp - 8;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6Adp() //  [R1]
         { info_tbl: [(c6Adp,
                       label: block_c6Adp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Adp: // global
           if (R1 & 7 == 1) goto c6Adw; else goto c6AdA;
       c6Adw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6AdA: // global
           R1 = Data.Semigroup.Internal.stimesIdempotent1_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.966123484 UTC

[section ""cstring" . lvl4_r6v1a_bytes" {
     lvl4_r6v1a_bytes:
         I8[] [115,116,105,109,101,115,73,100,101,109,112,111,116,101,110,116,77,111,110,111,105,100,58,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.968262985 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotentMonoid1_closure" {
     Data.Semigroup.Internal.stimesIdempotentMonoid1_closure:
         const Data.Semigroup.Internal.stimesIdempotentMonoid1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesIdempotentMonoid1_entry() //  [R1]
         { info_tbl: [(c6Ae9,
                       label: Data.Semigroup.Internal.stimesIdempotentMonoid1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ae9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Aea; else goto c6Aeb;
       c6Aea: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Aeb: // global
           (_c6Ae4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Ae4::I64 == 0) goto c6Ae6; else goto c6Ae5;
       c6Ae6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Ae5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Ae4::I64;
           I64[Sp - 24] = block_c6Ae7_info;
           R2 = lvl4_r6v1a_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6Ae7() //  [R1]
         { info_tbl: [(c6Ae7,
                       label: block_c6Ae7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ae7: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.975290732 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotentMonoid_closure" {
     Data.Semigroup.Internal.stimesIdempotentMonoid_closure:
         const Data.Semigroup.Internal.stimesIdempotentMonoid_info;
         const 0;
 },
 sat_s6vdE_entry() //  [R1]
         { info_tbl: [(c6AeD,
                       label: sat_s6vdE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AeD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6AeE; else goto c6AeF;
       c6AeE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AeF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6AeB_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6AeB() //  [R1]
         { info_tbl: [(c6AeB,
                       label: block_c6AeB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AeB: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesIdempotentMonoid_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(c6AeJ,
                       label: Data.Semigroup.Internal.stimesIdempotentMonoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AeJ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c6AeL; else goto c6AeM;
       c6AeL: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6AeM: // global
           I64[Sp - 32] = block_c6Aet_info;
           R2 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Aet() //  [R1]
         { info_tbl: [(c6Aet,
                       label: block_c6Aet_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aet: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6AeP; else goto c6AeO;
       c6AeP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AeO: // global
           I64[Hp - 16] = sat_s6vdE_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6AeK_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AeK() //  [R1]
         { info_tbl: [(c6AeK,
                       label: block_c6AeK_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AeK: // global
           _c6Aex::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6AeT_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = _c6Aex::P64;
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6AeT() //  [R1]
         { info_tbl: [(c6AeT,
                       label: block_c6AeT_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AeT: // global
           _c6Af9::P64 = R1 & 7;
           if (_c6Af9::P64 < 3) goto u6Afa; else goto c6Af8;
       u6Afa: // global
           if (_c6Af9::P64 < 2) goto c6Af0; else goto c6Af4;
       c6Af0: // global
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid1_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6Af4: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
       c6Af8: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.989119864 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_go_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_go_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_go_info;
 },
 Data.Semigroup.Internal.$fSemigroupAny_go_entry() //  [R2, R3]
         { info_tbl: [(c6AfK,
                       label: Data.Semigroup.Internal.$fSemigroupAny_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AfK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6AfL; else goto u6Ag6;
       c6AfL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAny_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6Ag6: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6AfA() args: 0, res: 0, upd: 0;
     }
 },
 _c6AfA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AfA: // global
           I64[Sp - 8] = block_c6AfD_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Ag8; else goto c6AfE;
       u6Ag8: // global
           call _c6AfD(R1) args: 0, res: 0, upd: 0;
       c6AfE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6AfD() //  [R1]
         { info_tbl: [(c6AfD,
                       label: block_c6AfD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AfD: // global
           _s6vdG::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6AfH; else goto c6AfI;
       c6AfH: // global
           R1 = _s6vdG::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6AfI: // global
           I64[Sp] = block_c6AfS_info;
           _s6vdJ::P64 = P64[R1 + 6];
           _s6vdK::P64 = P64[R1 + 14];
           R1 = _s6vdG::P64;
           P64[Sp + 8] = _s6vdK::P64;
           P64[Sp + 16] = _s6vdJ::P64;
           if (R1 & 7 != 0) goto u6Ag9; else goto c6AfU;
       u6Ag9: // global
           call _c6AfS(R1) args: 0, res: 0, upd: 0;
       c6AfU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6AfS() //  [R1]
         { info_tbl: [(c6AfS,
                       label: block_c6AfS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AfS: // global
           if (R1 & 7 == 1) goto c6Ag0; else goto c6Ag4;
       c6Ag0: // global
           _s6vdH::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6vdH::P64;
           Sp = Sp + 8;
           call _c6AfA() args: 0, res: 0, upd: 0;
       c6Ag4: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:45.998919257 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAny_$csconcat_entry() //  [R2]
         { info_tbl: [(c6AgG,
                       label: Data.Semigroup.Internal.$fSemigroupAny_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AgG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6AgH; else goto c6AgI;
       c6AgH: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6AgI: // global
           I64[Sp - 8] = block_c6AgD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6AgM; else goto c6AgE;
       u6AgM: // global
           call _c6AgD(R1) args: 0, res: 0, upd: 0;
       c6AgE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6AgD() //  [R1]
         { info_tbl: [(c6AgD,
                       label: block_c6AgD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AgD: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupAny_go_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.004504966 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAny_go_closure" {
     Data.Semigroup.Internal.$fMonoidAny_go_closure:
         const Data.Semigroup.Internal.$fMonoidAny_go_info;
 },
 Data.Semigroup.Internal.$fMonoidAny_go_entry() //  [R2]
         { info_tbl: [(c6Ah7,
                       label: Data.Semigroup.Internal.$fMonoidAny_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ah7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ah8; else goto u6Aht;
       c6Ah8: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAny_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6Aht: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6AgX() args: 0, res: 0, upd: 0;
     }
 },
 _c6AgX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AgX: // global
           _s6vdQ::P64 = P64[Sp];
           I64[Sp] = block_c6Ah0_info;
           R1 = _s6vdQ::P64;
           if (R1 & 7 != 0) goto u6Ahv; else goto c6Ah1;
       u6Ahv: // global
           call _c6Ah0(R1) args: 0, res: 0, upd: 0;
       c6Ah1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ah0() //  [R1]
         { info_tbl: [(c6Ah0,
                       label: block_c6Ah0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ah0: // global
           if (R1 & 7 == 1) goto c6Ah4; else goto c6Ah5;
       c6Ah4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Ah5: // global
           I64[Sp - 8] = block_c6Ahf_info;
           _s6vdT::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6vdT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Ahw; else goto c6Ahh;
       u6Ahw: // global
           call _c6Ahf(R1) args: 0, res: 0, upd: 0;
       c6Ahh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ahf() //  [R1]
         { info_tbl: [(c6Ahf,
                       label: block_c6Ahf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ahf: // global
           if (R1 & 7 == 1) goto c6Ahn; else goto c6Ahr;
       c6Ahn: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6AgX() args: 0, res: 0, upd: 0;
       c6Ahr: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.012942481 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Classes.||_closure+2;
         const Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAny_closure" {
     Data.Semigroup.Internal.$fMonoidAny_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupAny_closure+1;
         const GHC.Types.False_closure+1;
         const GHC.Classes.||_closure+2;
         const Data.Semigroup.Internal.$fMonoidAny_go_closure+1;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupAny_$cstimes_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(c6AhZ,
                       label: Data.Semigroup.Internal.$fSemigroupAny_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AhZ: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidAny_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.019493802 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_go_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_go_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_go_info;
 },
 Data.Semigroup.Internal.$fSemigroupAll_go_entry() //  [R2, R3]
         { info_tbl: [(c6Aij,
                       label: Data.Semigroup.Internal.$fSemigroupAll_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aij: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Aik; else goto u6AiF;
       c6Aik: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAll_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6AiF: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6Ai9() args: 0, res: 0, upd: 0;
     }
 },
 _c6Ai9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ai9: // global
           I64[Sp - 8] = block_c6Aic_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6AiH; else goto c6Aid;
       u6AiH: // global
           call _c6Aic(R1) args: 0, res: 0, upd: 0;
       c6Aid: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Aic() //  [R1]
         { info_tbl: [(c6Aic,
                       label: block_c6Aic_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aic: // global
           _s6vdW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6Aig; else goto c6Aih;
       c6Aig: // global
           R1 = _s6vdW::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Aih: // global
           I64[Sp] = block_c6Air_info;
           _s6vdZ::P64 = P64[R1 + 6];
           _s6ve0::P64 = P64[R1 + 14];
           R1 = _s6vdW::P64;
           P64[Sp + 8] = _s6ve0::P64;
           P64[Sp + 16] = _s6vdZ::P64;
           if (R1 & 7 != 0) goto u6AiI; else goto c6Ait;
       u6AiI: // global
           call _c6Air(R1) args: 0, res: 0, upd: 0;
       c6Ait: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Air() //  [R1]
         { info_tbl: [(c6Air,
                       label: block_c6Air_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Air: // global
           if (R1 & 7 == 1) goto c6Aiz; else goto c6AiD;
       c6Aiz: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6AiD: // global
           _s6vdX::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6vdX::P64;
           Sp = Sp + 8;
           call _c6Ai9() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.028603933 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAll_$csconcat_entry() //  [R2]
         { info_tbl: [(c6Ajf,
                       label: Data.Semigroup.Internal.$fSemigroupAll_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ajf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Ajg; else goto c6Ajh;
       c6Ajg: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ajh: // global
           I64[Sp - 8] = block_c6Ajc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Ajl; else goto c6Ajd;
       u6Ajl: // global
           call _c6Ajc(R1) args: 0, res: 0, upd: 0;
       c6Ajd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ajc() //  [R1]
         { info_tbl: [(c6Ajc,
                       label: block_c6Ajc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ajc: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupAll_go_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.034552867 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAll_go_closure" {
     Data.Semigroup.Internal.$fMonoidAll_go_closure:
         const Data.Semigroup.Internal.$fMonoidAll_go_info;
 },
 Data.Semigroup.Internal.$fMonoidAll_go_entry() //  [R2]
         { info_tbl: [(c6AjG,
                       label: Data.Semigroup.Internal.$fMonoidAll_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AjG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6AjH; else goto u6Ak2;
       c6AjH: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAll_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6Ak2: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6Ajw() args: 0, res: 0, upd: 0;
     }
 },
 _c6Ajw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ajw: // global
           _s6ve6::P64 = P64[Sp];
           I64[Sp] = block_c6Ajz_info;
           R1 = _s6ve6::P64;
           if (R1 & 7 != 0) goto u6Ak4; else goto c6AjA;
       u6Ak4: // global
           call _c6Ajz(R1) args: 0, res: 0, upd: 0;
       c6AjA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Ajz() //  [R1]
         { info_tbl: [(c6Ajz,
                       label: block_c6Ajz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ajz: // global
           if (R1 & 7 == 1) goto c6AjD; else goto c6AjE;
       c6AjD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6AjE: // global
           I64[Sp - 8] = block_c6AjO_info;
           _s6ve9::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6ve9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Ak5; else goto c6AjQ;
       u6Ak5: // global
           call _c6AjO(R1) args: 0, res: 0, upd: 0;
       c6AjQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6AjO() //  [R1]
         { info_tbl: [(c6AjO,
                       label: block_c6AjO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AjO: // global
           if (R1 & 7 == 1) goto c6AjW; else goto c6Ak0;
       c6AjW: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Ak0: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6Ajw() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.043913072 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Classes.&&_closure+2;
         const Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAll_closure" {
     Data.Semigroup.Internal.$fMonoidAll_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupAll_closure+1;
         const GHC.Types.True_closure+2;
         const GHC.Classes.&&_closure+2;
         const Data.Semigroup.Internal.$fMonoidAll_go_closure+1;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupAll_$cstimes_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(c6Aky,
                       label: Data.Semigroup.Internal.$fSemigroupAll_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aky: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidAll_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.048896622 UTC

[section ""cstring" . lvl5_r6v1b_bytes" {
     lvl5_r6v1b_bytes:
         I8[] [115,116,105,109,101,115,77,111,110,111,105,100,58,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.051206203 UTC

[section ""data" . lvl6_r6v1c_closure" {
     lvl6_r6v1c_closure:
         const lvl6_r6v1c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r6v1c_entry() //  [R1]
         { info_tbl: [(c6AkQ,
                       label: lvl6_r6v1c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AkQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6AkR; else goto c6AkS;
       c6AkR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AkS: // global
           (_c6AkL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6AkL::I64 == 0) goto c6AkN; else goto c6AkM;
       c6AkN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6AkM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6AkL::I64;
           I64[Sp - 24] = block_c6AkO_info;
           R2 = lvl5_r6v1b_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6AkO() //  [R1]
         { info_tbl: [(c6AkO,
                       label: block_c6AkO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AkO: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.058752715 UTC

[section ""data" . sat_s6ved_closure" {
     sat_s6ved_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.060504928 UTC

[section ""data" . sat_s6vee_closure" {
     sat_s6vee_closure:
         const :_con_info;
         const sat_s6ved_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.06257851 UTC

[section ""data" . lvl7_r6v1d_closure" {
     lvl7_r6v1d_closure:
         const lvl7_r6v1d_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r6v1d_entry() //  [R1]
         { info_tbl: [(c6Ale,
                       label: lvl7_r6v1d_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ale: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Alf; else goto c6Alg;
       c6Alf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Alg: // global
           (_c6Alb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Alb::I64 == 0) goto c6Ald; else goto c6Alc;
       c6Ald: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Alc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Alb::I64;
           R3 = sat_s6vee_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.071418992 UTC

[section ""data" . Data.Semigroup.Internal.stimesMonoid_closure" {
     Data.Semigroup.Internal.stimesMonoid_closure:
         const Data.Semigroup.Internal.stimesMonoid_info;
         const 0;
 },
 sat_s6vem_entry() //  [R1]
         { info_tbl: [(c6AmP,
                       label: sat_s6vem_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AmP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6AmQ; else goto c6AmR;
       c6AmQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AmR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6AmN_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6AmN() //  [R1]
         { info_tbl: [(c6AmN,
                       label: block_c6AmN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AmN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s6veo_entry() //  [R1]
         { info_tbl: [(c6AmX,
                       label: $dNum_s6veo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AmX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6AmY; else goto c6AmZ;
       c6AmY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AmZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_s6vep_entry() //  [R1]
         { info_tbl: [(c6An2,
                       label: lvl12_s6vep_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6An2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6An3; else goto c6An4;
       c6An3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6An4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl7_r6v1d_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6vev_entry() //  [R1]
         { info_tbl: [(c6An7,
                       label: lvl13_s6vev_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6An7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6An8; else goto c6An9;
       c6An8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6An9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6veM_entry() //  [R1]
         { info_tbl: [(c6Anc,
                       label: sat_s6veM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Anc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6And; else goto c6Ane;
       c6And: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ane: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veL_entry() //  [R1]
         { info_tbl: [(c6Anh,
                       label: sat_s6veL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Anh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Ani; else goto c6Anj;
       c6Ani: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Anj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6ver::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6ver::P64;
           P64[Sp - 24] = _s6ver::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veI_entry() //  [R1]
         { info_tbl: [(c6Anm,
                       label: sat_s6veI_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Anm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Ann; else goto c6Ano;
       c6Ann: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ano: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veH_entry() //  [R1]
         { info_tbl: [(c6Anr,
                       label: sat_s6veH_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Anr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Ans; else goto c6Ant;
       c6Ans: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ant: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veG_entry() //  [R1]
         { info_tbl: [(c6Anx,
                       label: sat_s6veG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Anx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Any; else goto c6Anz;
       c6Any: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Anz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6veB::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6veB::P64;
           P64[Sp - 24] = _s6veB::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veK_entry() //  [R1]
         { info_tbl: [(c6AnC,
                       label: sat_s6veK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AnC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AnD; else goto c6AnE;
       c6AnD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AnE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veJ_entry() //  [R1]
         { info_tbl: [(c6AnI,
                       label: sat_s6veJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AnI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AnJ; else goto c6AnK;
       c6AnJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AnK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6veB::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6veB::P64;
           P64[Sp - 24] = _s6veB::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veS_entry() //  [R1]
         { info_tbl: [(c6AnN,
                       label: sat_s6veS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AnN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AnO; else goto c6AnP;
       c6AnO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AnP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6veR_entry() //  [R1]
         { info_tbl: [(c6AnT,
                       label: sat_s6veR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AnT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AnU; else goto c6AnV;
       c6AnU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AnV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6veO::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6veO::P64;
           P64[Sp - 24] = _s6veO::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesMonoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6AnW,
                       label: Data.Semigroup.Internal.stimesMonoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AnW: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c6AnX; else goto c6AnY;
       c6AnX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMonoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6AnY: // global
           I64[Sp - 40] = block_c6Als_info;
           _s6vef::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s6vef::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Als() //  [R1]
         { info_tbl: [(c6Als,
                       label: block_c6Als_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Als: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Ao1; else goto c6Ao0;
       c6Ao1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Ao0: // global
           I64[Hp - 16] = sat_s6vem_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c6Aly_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Aly() //  [R1]
         { info_tbl: [(c6Aly,
                       label: block_c6Aly_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aly: // global
           I64[Sp] = block_c6AlC_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6AlC() //  [R1]
         { info_tbl: [(c6AlC,
                       label: block_c6AlC_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AlC: // global
           _c6AoW::P64 = R1 & 7;
           if (_c6AoW::P64 < 3) goto u6Ap1; else goto c6Aoa;
       u6Ap1: // global
           if (_c6AoW::P64 < 2) goto c6Ao6; else goto c6Ao9;
       c6Ao6: // global
           R1 = lvl6_r6v1c_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6Ao9: // global
           R2 = P64[Sp + 32];
           Sp = Sp + 56;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
       c6Aoa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Aod; else goto c6Aoc;
       c6Aod: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Aoc: // global
           I64[Hp - 40] = $dNum_s6veo_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = lvl12_s6vep_info;
           _c6AlI::P64 = Hp - 40;
           P64[Hp] = _c6AlI::P64;
           P64[Sp] = P64[Sp + 40];
           P64[Sp + 16] = P64[Sp + 48];
           P64[Sp + 40] = Hp - 16;
           P64[Sp + 48] = _c6AlI::P64;
           call _c6AmB() args: 0, res: 0, upd: 0;
     }
 },
 _c6AmB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AmB: // global
           I64[Sp - 8] = block_c6AmD_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AmD() //  [R1]
         { info_tbl: [(c6AmD,
                       label: block_c6AmD_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AmD: // global
           _s6veO::P64 = P64[Sp + 24];
           _s6veP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6AoR; else goto c6AoS;
       c6AoR: // global
           I64[Sp + 8] = block_c6AlR_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s6veP::P64;
           P64[Sp + 24] = _s6veO::P64;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c6AoS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6AoV; else goto c6AoU;
       c6AoV: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AoU: // global
           I64[Hp - 64] = sat_s6veS_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s6veP::P64;
           I64[Hp - 24] = sat_s6veR_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6veO::P64;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c6AmB() args: 0, res: 0, upd: 0;
     }
 },
 _c6AlR() //  [R1]
         { info_tbl: [(c6AlR,
                       label: block_c6AlR_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AlR: // global
           I64[Sp] = block_c6AlV_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AlV() //  [R1]
         { info_tbl: [(c6AlV,
                       label: block_c6AlV_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AlV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Aoi; else goto c6Aoh;
       c6Aoi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Aoh: // global
           I64[Hp - 16] = lvl13_s6vev_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp - 8] = block_c6Am1_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c6AlZ::P64 = Hp - 16;
           P64[Sp - 16] = _c6AlZ::P64;
           P64[Sp] = R1;
           P64[Sp + 48] = _c6AlZ::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6Am1() //  [R1]
         { info_tbl: [(c6Am1,
                       label: block_c6Am1_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Am1: // global
           _s6ver::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6Aok; else goto c6AoM;
       c6Aok: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6Aon; else goto c6Aom;
       c6Aon: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Aom: // global
           I64[Hp - 64] = sat_s6veM_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s6veL_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6ver::P64;
           P64[Sp] = _s6ver::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 24] = Hp - 24;
           call _c6Ame() args: 0, res: 0, upd: 0;
       c6AoM: // global
           R1 = _s6ver::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Ame() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ame: // global
           I64[Sp - 8] = block_c6Amg_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Amg() //  [R1]
         { info_tbl: [(c6Amg,
                       label: block_c6Amg_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Amg: // global
           _s6veC::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6Aov; else goto c6AoF;
       c6Aov: // global
           I64[Sp] = block_c6Amk_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s6veC::P64;
           P64[Sp - 8] = P64[Sp + 64];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c6AoF: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6AoI; else goto c6AoH;
       c6AoI: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AoH: // global
           I64[Hp - 64] = sat_s6veK_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s6veC::P64;
           I64[Hp - 24] = sat_s6veJ_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6Ame() args: 0, res: 0, upd: 0;
     }
 },
 _c6Amk() //  [R1]
         { info_tbl: [(c6Amk,
                       label: block_c6Amk_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Amk: // global
           _s6veg::P64 = P64[Sp + 48];
           _s6veB::P64 = P64[Sp + 32];
           _s6veD::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6Aox; else goto c6AoE;
       c6Aox: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c6AoA; else goto c6Aoz;
       c6AoA: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Aoz: // global
           I64[Hp - 104] = sat_s6veI_info;
           P64[Hp - 88] = _s6veg::P64;
           P64[Hp - 80] = _s6veB::P64;
           P64[Hp - 72] = _s6veD::P64;
           I64[Hp - 64] = sat_s6veH_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s6veG_info;
           P64[Hp - 8] = _s6veg::P64;
           P64[Hp] = _s6veB::P64;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c6Ame() args: 0, res: 0, upd: 0;
       c6AoE: // global
           R2 = _s6veg::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s6veB::P64;
           P64[Sp + 64] = _s6veD::P64;
           Sp = Sp + 48;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.126179716 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat_closure" {
     Data.Semigroup.Internal.$w$csconcat_closure:
         const Data.Semigroup.Internal.$w$csconcat_info;
 },
 go_s6veW_entry() //  [R1, R2, R3]
         { info_tbl: [(c6ArM,
                       label: go_s6veW_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ArM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6ArN; else goto c6ArO;
       c6ArN: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ArO: // global
           I64[Sp - 32] = block_c6ArF_info;
           _s6veW::P64 = R1;
           _s6veT::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6veT::P64;
           P64[Sp - 16] = _s6veW::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6ArY; else goto c6ArG;
       u6ArY: // global
           call _c6ArF(R1) args: 0, res: 0, upd: 0;
       c6ArG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6ArF() //  [R1]
         { info_tbl: [(c6ArF,
                       label: block_c6ArF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ArF: // global
           _s6veX::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6ArJ; else goto c6ArK;
       c6ArJ: // global
           R1 = _s6veX::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6ArK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6ArW; else goto c6ArV;
       c6ArW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ArV: // global
           _s6vf0::P64 = P64[R1 + 6];
           _s6vf1::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6vf0::P64;
           P64[Hp] = _s6vf1::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6veX::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c6ArZ,
                       label: Data.Semigroup.Internal.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ArZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6As3; else goto c6As2;
       c6As3: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6As2: // global
           I64[Hp - 8] = go_s6veW_info;
           P64[Hp] = R2;
           _s6veU::P64 = R3;
           R3 = R4;
           R2 = _s6veU::P64;
           R1 = Hp - 6;
           call go_s6veW_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.13491749 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c6Asr,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Asr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ass; else goto c6Ast;
       c6Ass: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ast: // global
           I64[Sp - 16] = block_c6Aso_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Asx; else goto c6Asp;
       u6Asx: // global
           call _c6Aso(R1) args: 0, res: 0, upd: 0;
       c6Asp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Aso() //  [R1]
         { info_tbl: [(c6Aso,
                       label: block_c6Aso_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aso: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.142017875 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_info;
 },
 z_s6vfa_entry() //  [R1]
         { info_tbl: [(c6AsP,
                       label: z_s6vfa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AsP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6AsQ; else goto c6AsR;
       c6AsQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AsR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s6vfb_entry() //  [R1, R2]
         { info_tbl: [(c6At4,
                       label: go_s6vfb_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6At4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6At5; else goto c6At6;
       c6At5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6At6: // global
           I64[Sp - 32] = block_c6AsX_info;
           _s6vfb::P64 = R1;
           _s6vf8::P64 = P64[R1 + 7];
           _s6vfa::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6vf8::P64;
           P64[Sp - 16] = _s6vfa::P64;
           P64[Sp - 8] = _s6vfb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6Atg; else goto c6AsY;
       u6Atg: // global
           call _c6AsX(R1) args: 0, res: 0, upd: 0;
       c6AsY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6AsX() //  [R1]
         { info_tbl: [(c6AsX,
                       label: block_c6AsX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AsX: // global
           if (R1 & 7 == 1) goto c6At1; else goto c6At2;
       c6At1: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6At2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Ate; else goto c6Atd;
       c6Ate: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Atd: // global
           _s6vfe::P64 = P64[R1 + 6];
           _s6vff::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6vff::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6vfe::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c6Ath,
                       label: Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ath: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Atl; else goto c6Atk;
       c6Atl: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Atk: // global
           I64[Hp - 40] = z_s6vfa_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6vfb_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s6vfb_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.153670237 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_info;
         const 0;
 },
 sat_s6vfk_entry() //  [R1, R2]
         { info_tbl: [(c6AtQ,
                       label: sat_s6vfk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AtQ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vfj_entry() //  [R1, R2]
         { info_tbl: [(c6AtY,
                       label: sat_s6vfj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AtY: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vfi_entry() //  [R1]
         { info_tbl: [(c6Au5,
                       label: sat_s6vfi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Au5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Au6; else goto c6Au7;
       c6Au6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Au7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupAlt_entry() //  [R2]
         { info_tbl: [(c6Au9,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Au9: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6Aud; else goto c6Auc;
       c6Aud: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Auc: // global
           I64[Hp - 80] = sat_s6vfk_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6vfj_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6vfi_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAlt_closure" {
     Data.Semigroup.Internal.$fMonoidAlt_closure:
         const Data.Semigroup.Internal.$fMonoidAlt_info;
         const 0;
 },
 sat_s6vfp_entry() //  [R1, R2]
         { info_tbl: [(c6Aun,
                       label: sat_s6vfp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aun: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6vfo_entry() //  [R1]
         { info_tbl: [(c6Auu,
                       label: sat_s6vfo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Auu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Auv; else goto c6Auw;
       c6Auv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Auw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vfn_entry() //  [R1]
         { info_tbl: [(c6AuB,
                       label: sat_s6vfn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AuB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6AuC; else goto c6AuD;
       c6AuC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AuD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vfm_entry() //  [R1]
         { info_tbl: [(c6AuI,
                       label: sat_s6vfm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AuI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6AuJ; else goto c6AuK;
       c6AuJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AuK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupAlt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidAlt_entry() //  [R2]
         { info_tbl: [(c6AuM,
                       label: Data.Semigroup.Internal.$fMonoidAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AuM: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c6AuQ; else goto c6AuP;
       c6AuQ: // global
           HpAlloc = 128;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6AuP: // global
           I64[Hp - 120] = sat_s6vfp_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6vfo_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6vfn_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6vfm_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 119;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_info;
         const 0;
 },
 sat_s6vfs_entry() //  [R1]
         { info_tbl: [(c6AuZ,
                       label: sat_s6vfs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AuZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Av0; else goto c6Av1;
       c6Av0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Av1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidAlt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c6Av2,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Av2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Av6; else goto c6Av5;
       c6Av6: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Av5: // global
           I64[Hp - 16] = sat_s6vfs_info;
           P64[Hp] = R2;
           _s6vfr::P64 = R3;
           R3 = Hp - 16;
           R2 = _s6vfr::P64;
           R1 = Data.Semigroup.Internal.stimesMonoid_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.178878292 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo1_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo1_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo1_info;
 },
 g_s6vfy_entry() //  [R1]
         { info_tbl: [(c6Aw9,
                       label: g_s6vfy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aw9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Awa; else goto c6Awb;
       c6Awa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Awb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupEndo1_entry(R3,
                                                               R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vfB_entry() //  [R1, R2]
         { info_tbl: [(c6Awi,
                       label: sat_s6vfB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Awi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Awm; else goto c6Awl;
       c6Awm: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Awl: // global
           _s6vft::P64 = P64[R1 + 7];
           _s6vfy::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s6vfy::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _s6vft::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fSemigroupEndo1_entry() //  [R2, R3]
         { info_tbl: [(c6Awr,
                       label: Data.Semigroup.Internal.$fSemigroupEndo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Awr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Aws; else goto c6Awt;
       c6Aws: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupEndo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Awt: // global
           I64[Sp - 16] = block_c6AvZ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Awz; else goto c6Aw0;
       u6Awz: // global
           call _c6AvZ(R1) args: 0, res: 0, upd: 0;
       c6Aw0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6AvZ() //  [R1]
         { info_tbl: [(c6AvZ,
                       label: block_c6AvZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AvZ: // global
           _s6vft::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6Awo; else goto c6Awp;
       c6Awo: // global
           R1 = _s6vft::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6Awp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6Awy; else goto c6Awx;
       c6Awy: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Awx: // global
           _s6vfw::P64 = P64[R1 + 6];
           _s6vfx::P64 = P64[R1 + 14];
           I64[Hp - 48] = g_s6vfy_info;
           P64[Hp - 32] = _s6vfw::P64;
           P64[Hp - 24] = _s6vfx::P64;
           I64[Hp - 16] = sat_s6vfB_info;
           P64[Hp - 8] = _s6vft::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.190568163 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_entry() //  [R2]
         { info_tbl: [(c6Ax1,
                       label: Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ax1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Ax2; else goto c6Ax3;
       c6Ax2: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ax3: // global
           I64[Sp - 8] = block_c6AwY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Ax7; else goto c6AwZ;
       u6Ax7: // global
           call _c6AwY(R1) args: 0, res: 0, upd: 0;
       c6AwZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6AwY() //  [R1]
         { info_tbl: [(c6AwY,
                       label: block_c6AwY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AwY: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupEndo1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.196493341 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidEndo1_closure" {
     Data.Semigroup.Internal.$fMonoidEndo1_closure:
         const Data.Semigroup.Internal.$fMonoidEndo1_info;
 },
 sat_s6vfL_entry() //  [R1]
         { info_tbl: [(c6Axv,
                       label: sat_s6vfL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Axv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Axw; else goto c6Axx;
       c6Axw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Axx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidEndo1_entry(R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidEndo1_entry() //  [R2, R3]
         { info_tbl: [(c6AxC,
                       label: Data.Semigroup.Internal.$fMonoidEndo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AxC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6AxD; else goto c6AxE;
       c6AxD: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidEndo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6AxE: // global
           I64[Sp - 16] = block_c6Axl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6AxK; else goto c6Axm;
       u6AxK: // global
           call _c6Axl(R1) args: 0, res: 0, upd: 0;
       c6Axm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Axl() //  [R1]
         { info_tbl: [(c6Axl,
                       label: block_c6Axl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Axl: // global
           _s6vfH::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6Axz; else goto c6AxA;
       c6Axz: // global
           R1 = _s6vfH::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6AxA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6AxJ; else goto c6AxI;
       c6AxJ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AxI: // global
           _s6vfJ::P64 = P64[R1 + 6];
           _s6vfK::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s6vfL_info;
           P64[Hp - 8] = _s6vfH::P64;
           P64[Hp] = _s6vfK::P64;
           R2 = Hp - 24;
           R1 = _s6vfJ::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.204750406 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.._closure+3;
         const Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidEndo_closure" {
     Data.Semigroup.Internal.$fMonoidEndo_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupEndo_closure+1;
         const GHC.Base.id_closure+1;
         const GHC.Base.._closure+3;
         const Data.Semigroup.Internal.$fMonoidEndo1_closure+2;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c6Ay4,
                       label: Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ay4: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidEndo_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesMonoid_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.21209643 UTC

[section ""cstring" . lvl8_r6v1e_bytes" {
     lvl8_r6v1e_bytes:
         I8[] [115,116,105,109,101,115,58,32,112,111,115,105,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114,32,101,120,112,101,99,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.214404239 UTC

[section ""data" . lvl9_r6v1f_closure" {
     lvl9_r6v1f_closure:
         const lvl9_r6v1f_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r6v1f_entry() //  [R1]
         { info_tbl: [(c6Aym,
                       label: lvl9_r6v1f_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Aym: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Ayn; else goto c6Ayo;
       c6Ayn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ayo: // global
           (_c6Ayh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Ayh::I64 == 0) goto c6Ayj; else goto c6Ayi;
       c6Ayj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Ayi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Ayh::I64;
           I64[Sp - 24] = block_c6Ayk_info;
           R2 = lvl8_r6v1e_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6Ayk() //  [R1]
         { info_tbl: [(c6Ayk,
                       label: block_c6Ayk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ayk: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.223649796 UTC

[section ""data" . Data.Semigroup.Internal.stimesDefault_closure" {
     Data.Semigroup.Internal.stimesDefault_closure:
         const Data.Semigroup.Internal.stimesDefault_info;
         const 0;
 },
 sat_s6vfV_entry() //  [R1]
         { info_tbl: [(c6AA1,
                       label: sat_s6vfV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AA1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6AA2; else goto c6AA3;
       c6AA2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AA3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6AzZ_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6AzZ() //  [R1]
         { info_tbl: [(c6AzZ,
                       label: block_c6AzZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AzZ: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s6vfX_entry() //  [R1]
         { info_tbl: [(c6AA9,
                       label: $dNum_s6vfX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AA9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6AAa; else goto c6AAb;
       c6AAa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AAb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_s6vfY_entry() //  [R1]
         { info_tbl: [(c6AAe,
                       label: lvl12_s6vfY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AAe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6AAf; else goto c6AAg;
       c6AAf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AAg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl7_r6v1d_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6vg4_entry() //  [R1]
         { info_tbl: [(c6AAj,
                       label: lvl13_s6vg4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AAj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6AAk; else goto c6AAl;
       c6AAk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AAl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6vgl_entry() //  [R1]
         { info_tbl: [(c6AAo,
                       label: sat_s6vgl_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AAo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AAp; else goto c6AAq;
       c6AAp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AAq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgk_entry() //  [R1]
         { info_tbl: [(c6AAt,
                       label: sat_s6vgk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AAt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AAu; else goto c6AAv;
       c6AAu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AAv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vg0::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vg0::P64;
           P64[Sp - 24] = _s6vg0::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgh_entry() //  [R1]
         { info_tbl: [(c6AAy,
                       label: sat_s6vgh_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AAy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AAz; else goto c6AAA;
       c6AAz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AAA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgg_entry() //  [R1]
         { info_tbl: [(c6AAD,
                       label: sat_s6vgg_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AAD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AAE; else goto c6AAF;
       c6AAE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AAF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgf_entry() //  [R1]
         { info_tbl: [(c6AAJ,
                       label: sat_s6vgf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AAJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AAK; else goto c6AAL;
       c6AAK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AAL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vga::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vga::P64;
           P64[Sp - 24] = _s6vga::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgj_entry() //  [R1]
         { info_tbl: [(c6AAO,
                       label: sat_s6vgj_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AAO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AAP; else goto c6AAQ;
       c6AAP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AAQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgi_entry() //  [R1]
         { info_tbl: [(c6AAU,
                       label: sat_s6vgi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AAU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AAV; else goto c6AAW;
       c6AAV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AAW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vga::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vga::P64;
           P64[Sp - 24] = _s6vga::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgr_entry() //  [R1]
         { info_tbl: [(c6AAZ,
                       label: sat_s6vgr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AAZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AB0; else goto c6AB1;
       c6AB0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AB1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgq_entry() //  [R1]
         { info_tbl: [(c6AB5,
                       label: sat_s6vgq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AB5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AB6; else goto c6AB7;
       c6AB6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AB7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6vgn::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6vgn::P64;
           P64[Sp - 24] = _s6vgn::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesDefault_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6AB8,
                       label: Data.Semigroup.Internal.stimesDefault_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AB8: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c6AB9; else goto c6ABa;
       c6AB9: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6ABa: // global
           I64[Sp - 40] = block_c6AyG_info;
           _s6vfO::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s6vfO::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AyG() //  [R1]
         { info_tbl: [(c6AyG,
                       label: block_c6AyG_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AyG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ABd; else goto c6ABc;
       c6ABd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ABc: // global
           I64[Hp - 16] = sat_s6vfV_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c6AyM_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AyM() //  [R1]
         { info_tbl: [(c6AyM,
                       label: block_c6AyM_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AyM: // global
           I64[Sp] = block_c6AyQ_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6AyQ() //  [R1]
         { info_tbl: [(c6AyQ,
                       label: block_c6AyQ_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AyQ: // global
           if (R1 & 7 == 1) goto c6ABg; else goto c6AC5;
       c6ABg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6ABj; else goto c6ABi;
       c6ABj: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ABi: // global
           I64[Hp - 40] = $dNum_s6vfX_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = lvl12_s6vfY_info;
           _c6AyU::P64 = Hp - 40;
           P64[Hp] = _c6AyU::P64;
           P64[Sp] = P64[Sp + 40];
           P64[Sp + 16] = P64[Sp + 48];
           P64[Sp + 40] = Hp - 16;
           P64[Sp + 48] = _c6AyU::P64;
           call _c6AzN() args: 0, res: 0, upd: 0;
       c6AC5: // global
           R1 = lvl9_r6v1f_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6AzN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AzN: // global
           I64[Sp - 8] = block_c6AzP_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AzP() //  [R1]
         { info_tbl: [(c6AzP,
                       label: block_c6AzP_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AzP: // global
           _s6vgn::P64 = P64[Sp + 24];
           _s6vgo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6ABX; else goto c6ABY;
       c6ABX: // global
           I64[Sp + 8] = block_c6Az3_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s6vgo::P64;
           P64[Sp + 24] = _s6vgn::P64;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c6ABY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6AC1; else goto c6AC0;
       c6AC1: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AC0: // global
           I64[Hp - 64] = sat_s6vgr_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s6vgo::P64;
           I64[Hp - 24] = sat_s6vgq_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6vgn::P64;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c6AzN() args: 0, res: 0, upd: 0;
     }
 },
 _c6Az3() //  [R1]
         { info_tbl: [(c6Az3,
                       label: block_c6Az3_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Az3: // global
           I64[Sp] = block_c6Az7_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Az7() //  [R1]
         { info_tbl: [(c6Az7,
                       label: block_c6Az7_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Az7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6ABo; else goto c6ABn;
       c6ABo: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ABn: // global
           I64[Hp - 16] = lvl13_s6vg4_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp - 8] = block_c6Azd_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c6Azb::P64 = Hp - 16;
           P64[Sp - 16] = _c6Azb::P64;
           P64[Sp] = R1;
           P64[Sp + 48] = _c6Azb::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6Azd() //  [R1]
         { info_tbl: [(c6Azd,
                       label: block_c6Azd_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Azd: // global
           _s6vg0::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6ABq; else goto c6ABS;
       c6ABq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6ABt; else goto c6ABs;
       c6ABt: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ABs: // global
           I64[Hp - 64] = sat_s6vgl_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s6vgk_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6vg0::P64;
           P64[Sp] = _s6vg0::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 24] = Hp - 24;
           call _c6Azq() args: 0, res: 0, upd: 0;
       c6ABS: // global
           R1 = _s6vg0::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Azq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Azq: // global
           I64[Sp - 8] = block_c6Azs_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Azs() //  [R1]
         { info_tbl: [(c6Azs,
                       label: block_c6Azs_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Azs: // global
           _s6vgb::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6ABB; else goto c6ABL;
       c6ABB: // global
           I64[Sp] = block_c6Azw_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s6vgb::P64;
           P64[Sp - 8] = P64[Sp + 64];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c6ABL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6ABO; else goto c6ABN;
       c6ABO: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ABN: // global
           I64[Hp - 64] = sat_s6vgj_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s6vgb::P64;
           I64[Hp - 24] = sat_s6vgi_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6Azq() args: 0, res: 0, upd: 0;
     }
 },
 _c6Azw() //  [R1]
         { info_tbl: [(c6Azw,
                       label: block_c6Azw_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Azw: // global
           _s6vfP::P64 = P64[Sp + 48];
           _s6vga::P64 = P64[Sp + 32];
           _s6vgc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6ABD; else goto c6ABK;
       c6ABD: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c6ABG; else goto c6ABF;
       c6ABG: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6ABF: // global
           I64[Hp - 104] = sat_s6vgh_info;
           P64[Hp - 88] = _s6vfP::P64;
           P64[Hp - 80] = _s6vga::P64;
           P64[Hp - 72] = _s6vgc::P64;
           I64[Hp - 64] = sat_s6vgg_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s6vgf_info;
           P64[Hp - 8] = _s6vfP::P64;
           P64[Hp] = _s6vga::P64;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c6Azq() args: 0, res: 0, upd: 0;
       c6ABK: // global
           R2 = _s6vfP::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s6vga::P64;
           P64[Sp + 64] = _s6vgc::P64;
           Sp = Sp + 48;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.278267454 UTC

[section ""cstring" . lvl10_r6v1g_bytes" {
     lvl10_r6v1g_bytes:
         I8[] [115,116,105,109,101,115,58,32,77,97,121,98,101,44,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.280521268 UTC

[section ""data" . Data.Semigroup.Internal.stimesMaybe1_closure" {
     Data.Semigroup.Internal.stimesMaybe1_closure:
         const Data.Semigroup.Internal.stimesMaybe1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesMaybe1_entry() //  [R1]
         { info_tbl: [(c6AEP,
                       label: Data.Semigroup.Internal.stimesMaybe1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AEP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6AEQ; else goto c6AER;
       c6AEQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AER: // global
           (_c6AEK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6AEK::I64 == 0) goto c6AEM; else goto c6AEL;
       c6AEM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6AEL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6AEK::I64;
           I64[Sp - 24] = block_c6AEN_info;
           R2 = lvl10_r6v1g_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6AEN() //  [R1]
         { info_tbl: [(c6AEN,
                       label: block_c6AEN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AEN: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.287930198 UTC

[section ""data" . Data.Semigroup.Internal.stimesMaybe_closure" {
     Data.Semigroup.Internal.stimesMaybe_closure:
         const Data.Semigroup.Internal.stimesMaybe_info;
         const 0;
 },
 sat_s6vgC_entry() //  [R1]
         { info_tbl: [(c6AFp,
                       label: sat_s6vgC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AFp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6AFq; else goto c6AFr;
       c6AFq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AFr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6AFn_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6AFn() //  [R1]
         { info_tbl: [(c6AFn,
                       label: block_c6AFn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AFn: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6vgE_entry() //  [R1]
         { info_tbl: [(c6AFJ,
                       label: sat_s6vgE_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AFJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6AFK; else goto c6AFL;
       c6AFK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AFL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesMaybe_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6AFQ,
                       label: Data.Semigroup.Internal.stimesMaybe_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AFQ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c6AFR; else goto c6AFS;
       c6AFR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMaybe_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6AFS: // global
           I64[Sp - 32] = block_c6AF9_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6AGi; else goto c6AFa;
       u6AGi: // global
           call _c6AF9(R1) args: 0, res: 0, upd: 0;
       c6AFa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6AF9() //  [R1]
         { info_tbl: [(c6AF9,
                       label: block_c6AF9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AF9: // global
           if (R1 & 7 == 1) goto u6AGe; else goto c6AFO;
       u6AGe: // global
           Sp = Sp + 32;
           call _c6AG6() args: 0, res: 0, upd: 0;
       c6AFO: // global
           I64[Sp - 8] = block_c6AFf_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AFf() //  [R1]
         { info_tbl: [(c6AFf,
                       label: block_c6AFf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AFf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6AFY; else goto c6AFX;
       c6AFY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AFX: // global
           I64[Hp - 16] = sat_s6vgC_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6AFv_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AFv() //  [R1]
         { info_tbl: [(c6AFv,
                       label: block_c6AFv_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AFv: // global
           _c6AFj::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6AFz_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = _c6AFj::P64;
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6AFz() //  [R1]
         { info_tbl: [(c6AFz,
                       label: block_c6AFz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AFz: // global
           _c6AGc::P64 = R1 & 7;
           if (_c6AGc::P64 < 3) goto u6AGd; else goto c6AG8;
       u6AGd: // global
           if (_c6AGc::P64 < 2) goto c6AG3; else goto u6AGf;
       c6AG3: // global
           R1 = Data.Semigroup.Internal.stimesMaybe1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u6AGf: // global
           Sp = Sp + 40;
           call _c6AG6() args: 0, res: 0, upd: 0;
       c6AG8: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c6AGb; else goto c6AGa;
       c6AGb: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AGa: // global
           I64[Hp - 56] = sat_s6vgE_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6AG6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AG6: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.30756869 UTC

[section ""cstring" . lvl11_r6v1h_bytes" {
     lvl11_r6v1h_bytes:
         I8[] [115,116,105,109,101,115,58,32,91,93,44,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.309691799 UTC

[section ""data" . Data.Semigroup.Internal.stimesList1_closure" {
     Data.Semigroup.Internal.stimesList1_closure:
         const Data.Semigroup.Internal.stimesList1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesList1_entry() //  [R1]
         { info_tbl: [(c6AHe,
                       label: Data.Semigroup.Internal.stimesList1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AHe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6AHf; else goto c6AHg;
       c6AHf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AHg: // global
           (_c6AH9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6AH9::I64 == 0) goto c6AHb; else goto c6AHa;
       c6AHb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6AHa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6AH9::I64;
           I64[Sp - 24] = block_c6AHc_info;
           R2 = lvl11_r6v1h_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6AHc() //  [R1]
         { info_tbl: [(c6AHc,
                       label: block_c6AHc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AHc: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.317211678 UTC

[section ""data" . Data.Semigroup.Internal.stimesList_closure" {
     Data.Semigroup.Internal.stimesList_closure:
         const Data.Semigroup.Internal.stimesList_info;
         const 0;
 },
 $dNum_s6vgK_entry() //  [R1]
         { info_tbl: [(c6AHG,
                       label: $dNum_s6vgK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AHG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6AHH; else goto c6AHI;
       c6AHH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AHI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6vgM_entry() //  [R1]
         { info_tbl: [(c6AHR,
                       label: sat_s6vgM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AHR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6AHS; else goto c6AHT;
       c6AHS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AHT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl12_s6vgO_entry() //  [R1]
         { info_tbl: [(c6AI2,
                       label: lvl12_s6vgO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AI2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6AI3; else goto c6AI4;
       c6AI3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AI4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6vgP_entry() //  [R1]
         { info_tbl: [(c6AI9,
                       label: lvl13_s6vgP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AI9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6AIa; else goto c6AIb;
       c6AIa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AIb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6vgU_entry() //  [R1]
         { info_tbl: [(c6AIx,
                       label: sat_s6vgU_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AIx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6AIy; else goto c6AIz;
       c6AIy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AIz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6vgV_entry() //  [R1]
         { info_tbl: [(c6AIA,
                       label: sat_s6vgV_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AIA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6AIE; else goto c6AID;
       c6AIE: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6AID: // global
           _s6vgK::P64 = P64[R1 + 16];
           _s6vgO::P64 = P64[R1 + 24];
           _s6vgR::P64 = P64[R1 + 32];
           _s6vgS::P64 = P64[R1 + 40];
           I64[Hp - 32] = sat_s6vgU_info;
           P64[Hp - 16] = _s6vgK::P64;
           P64[Hp - 8] = _s6vgO::P64;
           P64[Hp] = _s6vgS::P64;
           R2 = Hp - 32;
           R1 = _s6vgR::P64;
           call rep_s6vgR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 rep_s6vgR_entry() //  [R1, R2]
         { info_tbl: [(c6AIJ,
                       label: rep_s6vgR_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AIJ: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c6AIK; else goto c6AIL;
       c6AIK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6AIL: // global
           I64[Sp - 48] = block_c6AIl_info;
           _s6vgS::P64 = R2;
           R2 = P64[R1 + 39];
           I64[Sp - 72] = stg_ap_pp_info;
           P64[Sp - 64] = _s6vgS::P64;
           P64[Sp - 56] = P64[R1 + 31];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s6vgS::P64;
           Sp = Sp - 72;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6AIl() //  [R1]
         { info_tbl: [(c6AIl,
                       label: block_c6AIl_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AIl: // global
           if (R1 & 7 == 1) goto c6AIG; else goto c6AIH;
       c6AIG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6AIO; else goto c6AIN;
       c6AIO: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AIN: // global
           I64[Hp - 40] = sat_s6vgV_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 40;
           R2 = P64[Sp + 8];
           Sp = Sp + 48;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6AIH: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.stimesList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6AIS,
                       label: Data.Semigroup.Internal.stimesList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AIS: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c6AIT; else goto c6AIU;
       c6AIT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6AIU: // global
           I64[Sp - 24] = block_c6AHy_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AHy() //  [R1]
         { info_tbl: [(c6AHy,
                       label: block_c6AHy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AHy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6AIX; else goto c6AIW;
       c6AIX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AIW: // global
           I64[Hp - 16] = $dNum_s6vgK_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6AHJ_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6AHJ() //  [R1]
         { info_tbl: [(c6AHJ,
                       label: block_c6AHJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AHJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6AJ0; else goto c6AIZ;
       c6AJ0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AIZ: // global
           I64[Hp - 16] = sat_s6vgM_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c6AHU_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6AHU() //  [R1]
         { info_tbl: [(c6AHU,
                       label: block_c6AHU_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AHU: // global
           if (R1 & 7 == 1) goto c6AJ2; else goto c6AJc;
       c6AJ2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6AJ5; else goto c6AJ4;
       c6AJ5: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AJ4: // global
           I64[Hp - 40] = lvl12_s6vgO_info;
           _c6AHC::P64 = P64[Sp + 16];
           P64[Hp - 24] = _c6AHC::P64;
           I64[Hp - 16] = lvl13_s6vgP_info;
           P64[Hp] = _c6AHC::P64;
           I64[Sp - 8] = block_c6AIc_info;
           R2 = P64[Sp + 8];
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = Hp - 40;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c6AJc: // global
           R1 = Data.Semigroup.Internal.stimesList1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6AIc() //  [R1]
         { info_tbl: [(c6AIc,
                       label: block_c6AIc_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6AIc: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6AJ8; else goto c6AJ7;
       c6AJ8: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6AJ7: // global
           I64[Hp - 40] = rep_s6vgR_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 39;
           Sp = Sp + 48;
           call rep_s6vgR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.346667265 UTC

[section ""cstring" . Data.Semigroup.Internal.$trModule4_bytes" {
     Data.Semigroup.Internal.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.348523517 UTC

[section ""data" . Data.Semigroup.Internal.$trModule3_closure" {
     Data.Semigroup.Internal.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.350911242 UTC

[section ""cstring" . Data.Semigroup.Internal.$trModule2_bytes" {
     Data.Semigroup.Internal.$trModule2_bytes:
         I8[] [68,97,116,97,46,83,101,109,105,103,114,111,117,112,46,73,110,116,101,114,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.352755144 UTC

[section ""data" . Data.Semigroup.Internal.$trModule1_closure" {
     Data.Semigroup.Internal.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.354506462 UTC

[section ""data" . Data.Semigroup.Internal.$trModule_closure" {
     Data.Semigroup.Internal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Semigroup.Internal.$trModule3_closure+1;
         const Data.Semigroup.Internal.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.35638902 UTC

[section ""data" . $krep_r6v1i_closure" {
     $krep_r6v1i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.358607571 UTC

[section ""data" . $krep1_r6v1j_closure" {
     $krep1_r6v1j_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.360303042 UTC

[section ""data" . $krep2_r6v1k_closure" {
     $krep2_r6v1k_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep1_r6v1j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.36216201 UTC

[section ""data" . $krep3_r6v1l_closure" {
     $krep3_r6v1l_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.363935113 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt1_closure" {
     Data.Semigroup.Internal.$tcAlt1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r6v1l_closure+4;
         const $krep3_r6v1l_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.36601444 UTC

[section ""data" . $krep4_r6v1m_closure" {
     $krep4_r6v1m_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.367695439 UTC

[section ""data" . $krep5_r6v1n_closure" {
     $krep5_r6v1n_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.369489887 UTC

[section ""data" . $krep6_r6v1o_closure" {
     $krep6_r6v1o_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_r6v1m_closure+2;
         const $krep5_r6v1n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.371955119 UTC

[section ""data" . Data.Semigroup.Internal.$tcDual1_closure" {
     Data.Semigroup.Internal.$tcDual1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadDual5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.373789714 UTC

[section ""data" . Data.Semigroup.Internal.$tcDual_closure" {
     Data.Semigroup.Internal.$tcDual_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcDual1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 14711416616195557841;
         const 10971851269997195248;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.375624586 UTC

[section ""data" . $krep7_r6v1p_closure" {
     $krep7_r6v1p_closure:
         const :_con_info;
         const $krep1_r6v1j_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.37740164 UTC

[section ""data" . $krep8_r6v1q_closure" {
     $krep8_r6v1q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcDual_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.379173189 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual1_closure" {
     Data.Semigroup.Internal.$tc'Dual1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep8_r6v1q_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.381065613 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Dual3_bytes" {
     Data.Semigroup.Internal.$tc'Dual3_bytes:
         I8[] [39,68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.383284267 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual2_closure" {
     Data.Semigroup.Internal.$tc'Dual2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Dual3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.385065108 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual_closure" {
     Data.Semigroup.Internal.$tc'Dual_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Dual2_closure+1;
         const Data.Semigroup.Internal.$tc'Dual1_closure+4;
         const 15885009659242865261;
         const 15931193389986079612;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.389996518 UTC

[section ""cstring" . Data.Semigroup.Internal.$tcEndo2_bytes" {
     Data.Semigroup.Internal.$tcEndo2_bytes:
         I8[] [69,110,100,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.392382904 UTC

[section ""data" . Data.Semigroup.Internal.$tcEndo1_closure" {
     Data.Semigroup.Internal.$tcEndo1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tcEndo2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.395338153 UTC

[section ""data" . Data.Semigroup.Internal.$tcEndo_closure" {
     Data.Semigroup.Internal.$tcEndo_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcEndo1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16820921632006328603;
         const 4981834339379479823;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.398728098 UTC

[section ""data" . $krep9_r6v1r_closure" {
     $krep9_r6v1r_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcEndo_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.401087172 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo1_closure" {
     Data.Semigroup.Internal.$tc'Endo1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6v1k_closure+4;
         const $krep9_r6v1r_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.403348758 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Endo3_bytes" {
     Data.Semigroup.Internal.$tc'Endo3_bytes:
         I8[] [39,69,110,100,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.406249393 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo2_closure" {
     Data.Semigroup.Internal.$tc'Endo2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Endo3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.408659079 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo_closure" {
     Data.Semigroup.Internal.$tc'Endo_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Endo2_closure+1;
         const Data.Semigroup.Internal.$tc'Endo1_closure+4;
         const 156297185665537802;
         const 8988325904501215692;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.411391451 UTC

[section ""data" . Data.Semigroup.Internal.$tcAll1_closure" {
     Data.Semigroup.Internal.$tcAll1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAll13_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.413813223 UTC

[section ""data" . Data.Semigroup.Internal.$tcAll_closure" {
     Data.Semigroup.Internal.$tcAll_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAll1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14149274874874504208;
         const 8164254778609961234;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.41645946 UTC

[section ""data" . $krep10_r6v1s_closure" {
     $krep10_r6v1s_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAll_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.418574701 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All1_closure" {
     Data.Semigroup.Internal.$tc'All1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r6v1i_closure+1;
         const $krep10_r6v1s_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.420476158 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'All3_bytes" {
     Data.Semigroup.Internal.$tc'All3_bytes:
         I8[] [39,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.422479845 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All2_closure" {
     Data.Semigroup.Internal.$tc'All2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'All3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.424820287 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All_closure" {
     Data.Semigroup.Internal.$tc'All_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'All2_closure+1;
         const Data.Semigroup.Internal.$tc'All1_closure+4;
         const 1168494541548489787;
         const 10689931498683547374;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.426784258 UTC

[section ""data" . Data.Semigroup.Internal.$tcAny1_closure" {
     Data.Semigroup.Internal.$tcAny1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAny6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.428565378 UTC

[section ""data" . Data.Semigroup.Internal.$tcAny_closure" {
     Data.Semigroup.Internal.$tcAny_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAny1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11600287624241135668;
         const 17600231731807245316;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.430460352 UTC

[section ""data" . $krep11_r6v1t_closure" {
     $krep11_r6v1t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAny_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.43227809 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any1_closure" {
     Data.Semigroup.Internal.$tc'Any1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r6v1i_closure+1;
         const $krep11_r6v1t_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.434354183 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Any3_bytes" {
     Data.Semigroup.Internal.$tc'Any3_bytes:
         I8[] [39,65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.436113974 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any2_closure" {
     Data.Semigroup.Internal.$tc'Any2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Any3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.437951684 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any_closure" {
     Data.Semigroup.Internal.$tc'Any_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Any2_closure+1;
         const Data.Semigroup.Internal.$tc'Any1_closure+4;
         const 16164188984560189013;
         const 110490866064676064;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.439845476 UTC

[section ""data" . Data.Semigroup.Internal.$tcSum1_closure" {
     Data.Semigroup.Internal.$tcSum1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadSum5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.441789636 UTC

[section ""data" . Data.Semigroup.Internal.$tcSum_closure" {
     Data.Semigroup.Internal.$tcSum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcSum1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 7521450980204740829;
         const 14029043805042477297;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.443766833 UTC

[section ""data" . $krep12_r6v1u_closure" {
     $krep12_r6v1u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcSum_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.44661185 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum1_closure" {
     Data.Semigroup.Internal.$tc'Sum1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep12_r6v1u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.448412269 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Sum3_bytes" {
     Data.Semigroup.Internal.$tc'Sum3_bytes:
         I8[] [39,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.450145568 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum2_closure" {
     Data.Semigroup.Internal.$tc'Sum2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Sum3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.451912438 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum_closure" {
     Data.Semigroup.Internal.$tc'Sum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Sum2_closure+1;
         const Data.Semigroup.Internal.$tc'Sum1_closure+4;
         const 7144872330799658717;
         const 13465414667749873698;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.453872531 UTC

[section ""data" . Data.Semigroup.Internal.$tcProduct1_closure" {
     Data.Semigroup.Internal.$tcProduct1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadProduct5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.455602669 UTC

[section ""data" . Data.Semigroup.Internal.$tcProduct_closure" {
     Data.Semigroup.Internal.$tcProduct_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcProduct1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12271745360620305859;
         const 5747185732973757022;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.457912602 UTC

[section ""data" . $krep13_r6v1v_closure" {
     $krep13_r6v1v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcProduct_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.459700211 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product1_closure" {
     Data.Semigroup.Internal.$tc'Product1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep13_r6v1v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.461610365 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Product3_bytes" {
     Data.Semigroup.Internal.$tc'Product3_bytes:
         I8[] [39,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.463404305 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product2_closure" {
     Data.Semigroup.Internal.$tc'Product2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Product3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.465217331 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product_closure" {
     Data.Semigroup.Internal.$tc'Product_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Product2_closure+1;
         const Data.Semigroup.Internal.$tc'Product1_closure+4;
         const 3191278115598904989;
         const 12638872580785847167;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.467756414 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt2_closure" {
     Data.Semigroup.Internal.$tcAlt2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAlt5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.469918993 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt_closure" {
     Data.Semigroup.Internal.$tcAlt_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAlt2_closure+1;
         const Data.Semigroup.Internal.$tcAlt1_closure+4;
         const 7601313288863504805;
         const 2369500163797891218;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.471855186 UTC

[section ""data" . $krep14_r6v1w_closure" {
     $krep14_r6v1w_closure:
         const :_con_info;
         const $krep5_r6v1n_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.473659408 UTC

[section ""data" . $krep15_r6v1x_closure" {
     $krep15_r6v1x_closure:
         const :_con_info;
         const $krep4_r6v1m_closure+2;
         const $krep14_r6v1w_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.475396811 UTC

[section ""data" . $krep16_r6v1y_closure" {
     $krep16_r6v1y_closure:
         const :_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep15_r6v1x_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.477110156 UTC

[section ""data" . $krep17_r6v1z_closure" {
     $krep17_r6v1z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAlt_closure+1;
         const $krep16_r6v1y_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.478916332 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt1_closure" {
     Data.Semigroup.Internal.$tc'Alt1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r6v1o_closure+3;
         const $krep17_r6v1z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.480744752 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Alt3_bytes" {
     Data.Semigroup.Internal.$tc'Alt3_bytes:
         I8[] [39,65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.482957659 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt2_closure" {
     Data.Semigroup.Internal.$tc'Alt2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Alt3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.48478 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt_closure" {
     Data.Semigroup.Internal.$tc'Alt_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Alt2_closure+1;
         const Data.Semigroup.Internal.$tc'Alt1_closure+4;
         const 1436877498177162483;
         const 16937142347825669760;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:46.487175914 UTC

[section ""relreadonly" . S6vn0_srt" {
     S6vn0_srt:
         const Data.Semigroup.Internal.$fMonoidSum1_closure;
         const Data.Semigroup.Internal.$fMonoidSum2_closure;
         const Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const GHC.Real.^_closure;
         const Data.Semigroup.Internal.$fSemigroupProduct_closure;
         const sat_s6v3C_closure;
         const Data.Semigroup.Internal.$fMonoidProduct1_closure;
         const Data.Semigroup.Internal.$fMonoidProduct2_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const Data.Semigroup.Internal.$fShowAlt_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAlt_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Semigroup.Internal.$fReadAll3_closure;
         const GHC.Read.readField_closure;
         const Data.Semigroup.Internal.$fReadAlt2_closure;
         const Data.Semigroup.Internal.$fReadAll_lexeme_closure;
         const Data.Semigroup.Internal.$fReadAlt_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Semigroup.Internal.$fReadAlt1_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadList_closure;
         const Data.Semigroup.Internal.$fReadAlt_closure;
         const Data.Semigroup.Internal.$fShowProduct_$cshow_closure;
         const Data.Semigroup.Internal.$fShowProduct_closure;
         const Data.Semigroup.Internal.$fReadProduct2_closure;
         const Data.Semigroup.Internal.$fReadProduct_lexeme_closure;
         const Data.Semigroup.Internal.$fReadProduct1_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadList_closure;
         const Data.Semigroup.Internal.$fReadProduct_closure;
         const Data.Semigroup.Internal.$fShowSum_$cshow_closure;
         const Data.Semigroup.Internal.$fShowSum_closure;
         const Data.Semigroup.Internal.$fReadSum2_closure;
         const Data.Semigroup.Internal.$fReadSum_lexeme_closure;
         const Data.Semigroup.Internal.$fReadSum1_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadList_closure;
         const Data.Semigroup.Internal.$fReadSum_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const GHC.Show.$fShowBool2_closure;
         const GHC.Show.$fShowBool4_closure;
         const Data.Semigroup.Internal.$fShowAny3_closure;
         const Data.Semigroup.Internal.$w$cshowsPrec2_closure;
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll5_closure;
         const Data.Semigroup.Internal.$fShowAll6_closure;
         const Data.Semigroup.Internal.$fShowAny_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAny1_closure;
         const GHC.Read.$fReadBool2_closure;
         const GHC.Read.list3_closure;
         const Data.Semigroup.Internal.$fReadAll3_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Semigroup.Internal.$fReadAll7_closure;
         const Data.Semigroup.Internal.$fReadAny3_closure;
         const Data.Semigroup.Internal.$w$creadPrec1_closure;
         const Data.Semigroup.Internal.$fReadAny_lexeme_closure;
         const Data.Semigroup.Internal.$fReadAny2_closure;
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadAny1_closure;
         const GHC.Read.list_closure;
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAny7_closure;
         const Data.Semigroup.Internal.$fShowAll3_closure;
         const Data.Semigroup.Internal.$w$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAll1_closure;
         const Data.Semigroup.Internal.$fReadAll8_closure;
         const Data.Semigroup.Internal.$w$creadPrec_closure;
         const Data.Semigroup.Internal.$fReadAll_lexeme1_closure;
         const Data.Semigroup.Internal.$fReadAll2_closure;
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadAll1_closure;
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAll14_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const Data.Semigroup.Internal.$fShowDual_$cshow_closure;
         const Data.Semigroup.Internal.$fShowDual_closure;
         const Data.Semigroup.Internal.$fReadDual2_closure;
         const Data.Semigroup.Internal.$fReadDual_lexeme_closure;
         const Data.Semigroup.Internal.$fReadDual1_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadList_closure;
         const Data.Semigroup.Internal.$fReadDual_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Semigroup.Internal.$fMonoidSum1_closure;
         const Data.Semigroup.Internal.stimesIdempotent_closure;
         const Data.Semigroup.Internal.stimesIdempotent1_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid1_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Semigroup.Internal.$fMonoidAll_closure;
         const sat_s6vee_closure;
         const lvl7_r6v1d_closure;
         const Data.Semigroup.Internal.$fMonoidProduct1_closure;
         const GHC.Real.even_closure;
         const Data.Semigroup.Internal.stimesMonoid_closure;
         const lvl6_r6v1c_closure;
         const Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure;
         const Data.Semigroup.Internal.$fSemigroupAlt_closure;
         const Data.Semigroup.Internal.$fMonoidAlt_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const lvl9_r6v1f_closure;
         const Data.Semigroup.Internal.stimesMaybe_closure;
         const Data.Semigroup.Internal.stimesMaybe1_closure;
         const Data.Semigroup.Internal.stimesList_closure;
         const Data.Semigroup.Internal.stimesList1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.895803376 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:01:53.897632015 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat1_closure" {
     Data.Semigroup.Internal.$w$csconcat1_closure:
         const Data.Semigroup.Internal.$w$csconcat1_info;
 },
 go_s6ALy_entry() //  [R1, R2, R3]
         { info_tbl: [(c6B16,
                       label: go_s6ALy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B16: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6B17; else goto c6B18;
       c6B17: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B18: // global
           I64[Sp - 32] = block_c6B0Z_info;
           _s6ALy::P64 = R1;
           _s6ALv::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6ALv::P64;
           P64[Sp - 16] = _s6ALy::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6B1i; else goto c6B10;
       u6B1i: // global
           call _c6B0Z(R1) args: 0, res: 0, upd: 0;
       c6B10: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6B0Z() //  [R1]
         { info_tbl: [(c6B0Z,
                       label: block_c6B0Z_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B0Z: // global
           if (R1 & 7 == 1) goto c6B13; else goto c6B14;
       c6B13: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6B14: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6B1g; else goto c6B1f;
       c6B1g: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6B1f: // global
           _s6ALC::P64 = P64[R1 + 6];
           _s6ALD::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6ALC::P64;
           P64[Hp] = _s6ALD::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6B1j,
                       label: Data.Semigroup.Internal.$w$csconcat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B1j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6B1n; else goto c6B1m;
       c6B1n: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B1m: // global
           I64[Hp - 8] = go_s6ALy_info;
           P64[Hp] = R2;
           _s6ALw::P64 = R3;
           R3 = R4;
           R2 = _s6ALw::P64;
           R1 = Hp - 6;
           call go_s6ALy_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.906243564 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupDual_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupDual_$csconcat_entry() //  [R2,
                                                                R3]
         { info_tbl: [(c6B1P,
                       label: Data.Semigroup.Internal.$fSemigroupDual_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B1P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6B1Q; else goto c6B1R;
       c6B1Q: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupDual_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B1R: // global
           I64[Sp - 16] = block_c6B1M_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6B1V; else goto c6B1N;
       u6B1V: // global
           call _c6B1M(R1) args: 0, res: 0, upd: 0;
       c6B1N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6B1M() //  [R1]
         { info_tbl: [(c6B1M,
                       label: block_c6B1M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B1M: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.91215245 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupDual_closure" {
     Data.Semigroup.Internal.$fSemigroupDual_closure:
         const Data.Semigroup.Internal.$fSemigroupDual_info;
 },
 sat_s6ALS_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6B2f,
                       label: sat_s6ALS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B2f: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6B2g; else goto c6B2h;
       c6B2g: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B2h: // global
           _s6ALP::P64 = R2;
           R2 = P64[R1 + 5];
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s6ALP::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Base.stimes_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 sat_s6ALO_entry() //  [R1, R2]
         { info_tbl: [(c6B2n,
                       label: sat_s6ALO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B2n: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupDual_$csconcat_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ALN_entry() //  [R1, R2, R3]
         { info_tbl: [(c6B2v,
                       label: sat_s6ALN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B2v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6B2w; else goto c6B2x;
       c6B2w: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B2x: // global
           _s6ALL::P64 = R2;
           R2 = P64[R1 + 6];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = _s6ALL::P64;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fSemigroupDual_entry() //  [R2]
         { info_tbl: [(c6B2z,
                       label: Data.Semigroup.Internal.$fSemigroupDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B2z: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6B2D; else goto c6B2C;
       c6B2D: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6B2C: // global
           I64[Hp - 72] = sat_s6ALS_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6ALO_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6ALN_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 69;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.921679923 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_info;
 },
 sat_s6ALU_entry() //  [R1]
         { info_tbl: [(c6B3b,
                       label: sat_s6ALU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B3b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6B3c; else goto c6B3d;
       c6B3c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6B3d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_entry() //  [R2]
         { info_tbl: [(c6B3e,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B3e: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6B3i; else goto c6B3h;
       c6B3i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6B3h: // global
           I64[Hp - 16] = sat_s6ALU_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fSemigroupDual_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.927167053 UTC

[section ""data" . $cmappend_r6v15_closure" {
     $cmappend_r6v15_closure:
         const $cmappend_r6v15_info;
 },
 $cmappend_r6v15_entry() //  [R2, R3, R4]
         { info_tbl: [(c6B3z,
                       label: $cmappend_r6v15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B3z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6B3A; else goto c6B3B;
       c6B3A: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cmappend_r6v15_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B3B: // global
           I64[Sp - 24] = block_c6B3x_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6B3x() //  [R1]
         { info_tbl: [(c6B3x,
                       label: block_c6B3x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B3x: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _s6ALW::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6ALW::P64;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.93246776 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cmappend_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cmappend_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cmappend_info;
 },
 Data.Semigroup.Internal.$fMonoidDual_$cmappend_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c6B3U,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cmappend_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B3U: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cmappend_r6v15_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.93633549 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidDual_$cmconcat_info;
 },
 lvl12_s6AM1_entry() //  [R1]
         { info_tbl: [(c6B49,
                       label: lvl12_s6AM1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B49: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6B4a; else goto c6B4b;
       c6B4a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6B4b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 z_s6AM2_entry() //  [R1]
         { info_tbl: [(c6B4g,
                       label: z_s6AM2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B4g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6B4h; else goto c6B4i;
       c6B4h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6B4i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s6AM3_entry() //  [R1, R2]
         { info_tbl: [(c6B4v,
                       label: go_s6AM3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B4v: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6B4w; else goto c6B4x;
       c6B4w: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6B4x: // global
           I64[Sp - 32] = block_c6B4o_info;
           _s6AM3::P64 = R1;
           _s6AM1::P64 = P64[R1 + 7];
           _s6AM2::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6AM1::P64;
           P64[Sp - 16] = _s6AM2::P64;
           P64[Sp - 8] = _s6AM3::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6B4H; else goto c6B4p;
       u6B4H: // global
           call _c6B4o(R1) args: 0, res: 0, upd: 0;
       c6B4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6B4o() //  [R1]
         { info_tbl: [(c6B4o,
                       label: block_c6B4o_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B4o: // global
           if (R1 & 7 == 1) goto c6B4s; else goto c6B4t;
       c6B4s: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6B4t: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6B4F; else goto c6B4E;
       c6B4F: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6B4E: // global
           _s6AM6::P64 = P64[R1 + 6];
           _s6AM7::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6AM7::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = Hp - 24;
           P64[Sp + 24] = _s6AM6::P64;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c6B4I,
                       label: Data.Semigroup.Internal.$fMonoidDual_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B4I: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6B4M; else goto c6B4L;
       c6B4M: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B4L: // global
           I64[Hp - 64] = lvl12_s6AM1_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = z_s6AM2_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6AM3_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s6AM3_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.949097967 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidDual_closure" {
     Data.Semigroup.Internal.$fMonoidDual_closure:
         const Data.Semigroup.Internal.$fMonoidDual_info;
 },
 sat_s6AMd_entry() //  [R1, R2]
         { info_tbl: [(c6B5u,
                       label: sat_s6AMd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B5u: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fMonoidDual_$cmconcat_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AMc_entry() //  [R1, R2, R3]
         { info_tbl: [(c6B5C,
                       label: sat_s6AMc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B5C: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fMonoidDual_$cmappend_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AMb_entry() //  [R1]
         { info_tbl: [(c6B5J,
                       label: sat_s6AMb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B5J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6B5K; else goto c6B5L;
       c6B5K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6B5L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AMa_entry() //  [R1]
         { info_tbl: [(c6B5Q,
                       label: sat_s6AMa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B5Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6B5R; else goto c6B5S;
       c6B5R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6B5S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidDual_entry() //  [R2]
         { info_tbl: [(c6B5U,
                       label: Data.Semigroup.Internal.$fMonoidDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B5U: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto c6B5Y; else goto c6B5X;
       c6B5Y: // global
           HpAlloc = 120;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6B5X: // global
           I64[Hp - 112] = sat_s6AMd_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s6AMc_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6AMb_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6AMa_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 94;
           P64[Hp] = Hp - 111;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.959944577 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual2_closure" {
     Data.Semigroup.Internal.$fFunctorDual2_closure:
         const Data.Semigroup.Internal.$fFunctorDual2_info;
 },
 Data.Semigroup.Internal.$fFunctorDual2_entry() //  [R2]
         { info_tbl: [(c6B6x,
                       label: Data.Semigroup.Internal.$fFunctorDual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B6x: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.963086117 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual1_closure" {
     Data.Semigroup.Internal.$fFunctorDual1_closure:
         const Data.Semigroup.Internal.$fFunctorDual1_info;
 },
 Data.Semigroup.Internal.$fFunctorDual1_entry() //  [R2]
         { info_tbl: [(c6B6I,
                       label: Data.Semigroup.Internal.$fFunctorDual1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B6I: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.966631792 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorDual_closure" {
     Data.Semigroup.Internal.$fFunctorDual_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.96846021 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual3_closure" {
     Data.Semigroup.Internal.$fApplicativeDual3_closure:
         const Data.Semigroup.Internal.$fApplicativeDual3_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual3_entry() //  [R2]
         { info_tbl: [(c6B6U,
                       label: Data.Semigroup.Internal.$fApplicativeDual3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B6U: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.971650125 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual4_closure" {
     Data.Semigroup.Internal.$fApplicativeDual4_closure:
         const Data.Semigroup.Internal.$fApplicativeDual4_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual4_entry() //  [R2]
         { info_tbl: [(c6B75,
                       label: Data.Semigroup.Internal.$fApplicativeDual4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B75: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.974982248 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual2_closure" {
     Data.Semigroup.Internal.$fApplicativeDual2_closure:
         const Data.Semigroup.Internal.$fApplicativeDual2_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual2_entry() //  [R2, R3]
         { info_tbl: [(c6B7g,
                       label: Data.Semigroup.Internal.$fApplicativeDual2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B7g: // global
           _s6AMj::P64 = R2;
           R2 = R3;
           R1 = _s6AMj::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.978560232 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeDual_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual_$c*>_entry() //  [R3]
         { info_tbl: [(c6B7r,
                       label: Data.Semigroup.Internal.$fApplicativeDual_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B7r: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.981879024 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual1_closure" {
     Data.Semigroup.Internal.$fApplicativeDual1_closure:
         const Data.Semigroup.Internal.$fApplicativeDual1_info;
 },
 Data.Semigroup.Internal.$fApplicativeDual1_entry() //  [R2]
         { info_tbl: [(c6B7C,
                       label: Data.Semigroup.Internal.$fApplicativeDual1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B7C: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.984952633 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeDual_closure" {
     Data.Semigroup.Internal.$fApplicativeDual_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorDual_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.98722083 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum1_closure" {
     Data.Semigroup.Internal.$fSemigroupSum1_closure:
         const Data.Semigroup.Internal.$fSemigroupSum1_info;
 },
 sat_s6AMt_entry() //  [R1]
         { info_tbl: [(c6B7W,
                       label: sat_s6AMt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B7W: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6B7X; else goto c6B7Y;
       c6B7X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6B7Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Real.toInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6AMu_entry() //  [R1]
         { info_tbl: [(c6B7Z,
                       label: sat_s6AMu_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B7Z: // global
           _s6AMu::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto c6B80; else goto c6B81;
       c6B81: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6B83; else goto c6B82;
       c6B83: // global
           HpAlloc = 32;
           goto c6B80;
       c6B80: // global
           R1 = _s6AMu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6B82: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AMu::P64;
           _s6AMp::P64 = P64[_s6AMu::P64 + 16];
           _s6AMq::P64 = P64[_s6AMu::P64 + 24];
           _s6AMr::P64 = P64[_s6AMu::P64 + 32];
           I64[Hp - 24] = sat_s6AMt_info;
           P64[Hp - 8] = _s6AMq::P64;
           P64[Hp] = _s6AMr::P64;
           R2 = _s6AMp::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupSum1_entry() //  [R2, R3, R4,
                                                      R5]
         { info_tbl: [(c6B84,
                       label: Data.Semigroup.Internal.$fSemigroupSum1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B84: // global
           _s6AMs::P64 = R5;
           _s6AMr::P64 = R4;
           _s6AMq::P64 = R3;
           _s6AMp::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c6B85; else goto c6B86;
       c6B86: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6B88; else goto c6B87;
       c6B88: // global
           HpAlloc = 40;
           goto c6B85;
       c6B85: // global
           R5 = _s6AMs::P64;
           R4 = _s6AMr::P64;
           R3 = _s6AMq::P64;
           R2 = _s6AMp::P64;
           R1 = Data.Semigroup.Internal.$fSemigroupSum1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B87: // global
           I64[Hp - 32] = sat_s6AMu_info;
           P64[Hp - 16] = _s6AMp::P64;
           P64[Hp - 8] = _s6AMq::P64;
           P64[Hp] = _s6AMr::P64;
           R2 = _s6AMp::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s6AMs::P64;
           Sp = Sp - 24;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:53.996143747 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat3_closure" {
     Data.Semigroup.Internal.$w$csconcat3_closure:
         const Data.Semigroup.Internal.$w$csconcat3_info;
 },
 go_s6AMy_entry() //  [R1, R2, R3]
         { info_tbl: [(c6B8M,
                       label: go_s6AMy_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B8M: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6B8N; else goto c6B8O;
       c6B8N: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B8O: // global
           I64[Sp - 32] = block_c6B8F_info;
           _s6AMy::P64 = R1;
           _s6AMv::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6AMv::P64;
           P64[Sp - 16] = _s6AMy::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6B8Y; else goto c6B8G;
       u6B8Y: // global
           call _c6B8F(R1) args: 0, res: 0, upd: 0;
       c6B8G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6B8F() //  [R1]
         { info_tbl: [(c6B8F,
                       label: block_c6B8F_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B8F: // global
           _s6AMz::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6B8J; else goto c6B8K;
       c6B8J: // global
           R1 = _s6AMz::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6B8K: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6B8W; else goto c6B8V;
       c6B8W: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6B8V: // global
           _s6AMC::P64 = P64[R1 + 6];
           _s6AMD::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6AMC::P64;
           P64[Hp] = _s6AMD::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6AMz::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat3_entry() //  [R2, R3, R4]
         { info_tbl: [(c6B8Z,
                       label: Data.Semigroup.Internal.$w$csconcat3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B8Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6B93; else goto c6B92;
       c6B93: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B92: // global
           I64[Hp - 8] = go_s6AMy_info;
           P64[Hp] = R2;
           _s6AMw::P64 = R3;
           R3 = R4;
           R2 = _s6AMw::P64;
           R1 = Hp - 6;
           call go_s6AMy_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.004473755 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupSum_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupSum_$csconcat_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c6B9v,
                       label: Data.Semigroup.Internal.$fSemigroupSum_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B9v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6B9w; else goto c6B9x;
       c6B9w: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupSum_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6B9x: // global
           I64[Sp - 16] = block_c6B9s_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6B9B; else goto c6B9t;
       u6B9B: // global
           call _c6B9s(R1) args: 0, res: 0, upd: 0;
       c6B9t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6B9s() //  [R1]
         { info_tbl: [(c6B9s,
                       label: block_c6B9s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B9s: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat3_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.010002056 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupSum_closure" {
     Data.Semigroup.Internal.$fSemigroupSum_closure:
         const Data.Semigroup.Internal.$fSemigroupSum_info;
 },
 sat_s6AMN_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6B9V,
                       label: sat_s6AMN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6B9V: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call Data.Semigroup.Internal.$fSemigroupSum1_entry(R5,
                                                              R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AMM_entry() //  [R1, R2]
         { info_tbl: [(c6Ba3,
                       label: sat_s6AMM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ba3: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupSum_$csconcat_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AML_entry() //  [R1]
         { info_tbl: [(c6Baa,
                       label: sat_s6AML_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Baa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bab; else goto c6Bac;
       c6Bab: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bac: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupSum_entry() //  [R2]
         { info_tbl: [(c6Bae,
                       label: Data.Semigroup.Internal.$fSemigroupSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bae: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6Bai; else goto c6Bah;
       c6Bai: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bah: // global
           I64[Hp - 80] = sat_s6AMN_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6AMM_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6AML_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 77;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.018722817 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum1_closure" {
     Data.Semigroup.Internal.$fMonoidSum1_closure:
         const Data.Semigroup.Internal.$fMonoidSum1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidSum1_entry() //  [R1]
         { info_tbl: [(c6BaM,
                       label: Data.Semigroup.Internal.$fMonoidSum1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BaM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BaN; else goto c6BaO;
       c6BaN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BaO: // global
           (_c6BaJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6BaJ::I64 == 0) goto c6BaL; else goto c6BaK;
       c6BaL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6BaK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6BaJ::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.022729595 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum2_closure" {
     Data.Semigroup.Internal.$fMonoidSum2_closure:
         const Data.Semigroup.Internal.$fMonoidSum2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidSum2_entry() //  [R2]
         { info_tbl: [(c6Bb3,
                       label: Data.Semigroup.Internal.$fMonoidSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bb3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bb4; else goto c6Bb5;
       c6Bb4: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bb5: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.027046043 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidSum_$cmconcat_info;
         const 0;
 },
 z_s6AMQ_entry() //  [R1]
         { info_tbl: [(c6Bbm,
                       label: z_s6AMQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bbm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Bbn; else goto c6Bbo;
       c6Bbn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bbo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s6AMR_entry() //  [R1, R2]
         { info_tbl: [(c6BbB,
                       label: go_s6AMR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BbB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6BbC; else goto c6BbD;
       c6BbC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BbD: // global
           I64[Sp - 32] = block_c6Bbu_info;
           _s6AMR::P64 = R1;
           _s6AMP::P64 = P64[R1 + 7];
           _s6AMQ::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6AMP::P64;
           P64[Sp - 16] = _s6AMQ::P64;
           P64[Sp - 8] = _s6AMR::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6BbN; else goto c6Bbv;
       u6BbN: // global
           call _c6Bbu(R1) args: 0, res: 0, upd: 0;
       c6Bbv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Bbu() //  [R1]
         { info_tbl: [(c6Bbu,
                       label: block_c6Bbu_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bbu: // global
           if (R1 & 7 == 1) goto c6Bby; else goto c6Bbz;
       c6Bby: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6Bbz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BbL; else goto c6BbK;
       c6BbL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6BbK: // global
           _s6AMU::P64 = P64[R1 + 6];
           _s6AMV::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6AMV::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6AMU::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Num.+_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidSum_$cmconcat_entry() //  [R2]
         { info_tbl: [(c6BbO,
                       label: Data.Semigroup.Internal.$fMonoidSum_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BbO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6BbS; else goto c6BbR;
       c6BbS: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BbR: // global
           I64[Hp - 40] = z_s6AMQ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6AMR_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.037895217 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidSum_closure" {
     Data.Semigroup.Internal.$fMonoidSum_closure:
         const Data.Semigroup.Internal.$fMonoidSum_info;
         const 0;
 },
 sat_s6AN1_entry() //  [R1]
         { info_tbl: [(c6Bcv,
                       label: sat_s6AN1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bcv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bcw; else goto c6Bcx;
       c6Bcw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bcx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum_$cmconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AN0_entry() //  [R1]
         { info_tbl: [(c6BcC,
                       label: sat_s6AN0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BcC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BcD; else goto c6BcE;
       c6BcD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BcE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AMZ_entry() //  [R1]
         { info_tbl: [(c6BcJ,
                       label: sat_s6AMZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BcJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BcK; else goto c6BcL;
       c6BcK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BcL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidSum2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AMY_entry() //  [R1]
         { info_tbl: [(c6BcQ,
                       label: sat_s6AMY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BcQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BcR; else goto c6BcS;
       c6BcR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BcS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupSum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidSum_entry() //  [R2]
         { info_tbl: [(c6BcU,
                       label: Data.Semigroup.Internal.$fMonoidSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BcU: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6BcY; else goto c6BcX;
       c6BcY: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BcX: // global
           I64[Hp - 128] = sat_s6AN1_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6AN0_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6AMZ_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6AMY_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.048692863 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorSum_closure" {
     Data.Semigroup.Internal.$fFunctorSum_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.050627299 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum3_closure" {
     Data.Semigroup.Internal.$fApplicativeSum3_closure:
         const Data.Semigroup.Internal.$fApplicativeSum3_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum3_entry() //  [R2]
         { info_tbl: [(c6BdC,
                       label: Data.Semigroup.Internal.$fApplicativeSum3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BdC: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.054950129 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum2_closure" {
     Data.Semigroup.Internal.$fApplicativeSum2_closure:
         const Data.Semigroup.Internal.$fApplicativeSum2_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum2_entry() //  [R2, R3]
         { info_tbl: [(c6BdN,
                       label: Data.Semigroup.Internal.$fApplicativeSum2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BdN: // global
           _s6AN3::P64 = R2;
           R2 = R3;
           R1 = _s6AN3::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.059521225 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeSum_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum_$c*>_entry() //  [R3]
         { info_tbl: [(c6BdY,
                       label: Data.Semigroup.Internal.$fApplicativeSum_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BdY: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.063362793 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum1_closure" {
     Data.Semigroup.Internal.$fApplicativeSum1_closure:
         const Data.Semigroup.Internal.$fApplicativeSum1_info;
 },
 Data.Semigroup.Internal.$fApplicativeSum1_entry() //  [R2]
         { info_tbl: [(c6Be9,
                       label: Data.Semigroup.Internal.$fApplicativeSum1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Be9: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.066633001 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeSum_closure" {
     Data.Semigroup.Internal.$fApplicativeSum_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorSum_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeSum3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeSum2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeSum_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeSum1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.069064871 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat2_closure" {
     Data.Semigroup.Internal.$w$csconcat2_closure:
         const Data.Semigroup.Internal.$w$csconcat2_info;
 },
 go_s6ANc_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Bex,
                       label: go_s6ANc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bex: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Bey; else goto c6Bez;
       c6Bey: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Bez: // global
           I64[Sp - 32] = block_c6Beq_info;
           _s6ANc::P64 = R1;
           _s6AN9::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6AN9::P64;
           P64[Sp - 16] = _s6ANc::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6BeJ; else goto c6Ber;
       u6BeJ: // global
           call _c6Beq(R1) args: 0, res: 0, upd: 0;
       c6Ber: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Beq() //  [R1]
         { info_tbl: [(c6Beq,
                       label: block_c6Beq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Beq: // global
           _s6ANd::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6Beu; else goto c6Bev;
       c6Beu: // global
           R1 = _s6ANd::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6Bev: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6BeH; else goto c6BeG;
       c6BeH: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6BeG: // global
           _s6ANg::P64 = P64[R1 + 6];
           _s6ANh::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6ANg::P64;
           P64[Hp] = _s6ANh::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6ANd::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat2_entry() //  [R2, R3, R4]
         { info_tbl: [(c6BeK,
                       label: Data.Semigroup.Internal.$w$csconcat2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BeK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BeO; else goto c6BeN;
       c6BeO: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BeN: // global
           I64[Hp - 8] = go_s6ANc_info;
           P64[Hp] = R2;
           _s6ANa::P64 = R3;
           R3 = R4;
           R2 = _s6ANa::P64;
           R1 = Hp - 6;
           call go_s6ANc_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.077769961 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_entry() //  [R2,
                                                                   R3]
         { info_tbl: [(c6Bfg,
                       label: Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bfg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bfh; else goto c6Bfi;
       c6Bfh: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Bfi: // global
           I64[Sp - 16] = block_c6Bfd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Bfm; else goto c6Bfe;
       u6Bfm: // global
           call _c6Bfd(R1) args: 0, res: 0, upd: 0;
       c6Bfe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Bfd() //  [R1]
         { info_tbl: [(c6Bfd,
                       label: block_c6Bfd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bfd: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat2_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.084077669 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupProduct_closure" {
     Data.Semigroup.Internal.$fSemigroupProduct_closure:
         const Data.Semigroup.Internal.$fSemigroupProduct_info;
         const 0;
 },
 sat_s6ANu_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c6BfG,
                       label: sat_s6ANu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BfG: // global
           R5 = R3;
           R4 = R4;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Real.^_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ANq_entry() //  [R1, R2]
         { info_tbl: [(c6BfO,
                       label: sat_s6ANq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BfO: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupProduct_$csconcat_entry(R3,
                                                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ANp_entry() //  [R1]
         { info_tbl: [(c6BfV,
                       label: sat_s6ANp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BfV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BfW; else goto c6BfX;
       c6BfW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BfX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupProduct_entry() //  [R2]
         { info_tbl: [(c6BfZ,
                       label: Data.Semigroup.Internal.$fSemigroupProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BfZ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6Bg3; else goto c6Bg2;
       c6Bg3: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bg2: // global
           I64[Hp - 80] = sat_s6ANu_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6ANq_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6ANp_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 77;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.092755336 UTC

[section ""data" . sat_s6ANv_closure" {
     sat_s6ANv_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.094628297 UTC

[section ""data" . sat_s6ANw_closure" {
     sat_s6ANw_closure:
         const :_con_info;
         const sat_s6ANv_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.096502065 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct1_closure" {
     Data.Semigroup.Internal.$fMonoidProduct1_closure:
         const Data.Semigroup.Internal.$fMonoidProduct1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidProduct1_entry() //  [R1]
         { info_tbl: [(c6Bgz,
                       label: Data.Semigroup.Internal.$fMonoidProduct1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bgz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BgA; else goto c6BgB;
       c6BgA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BgB: // global
           (_c6Bgw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Bgw::I64 == 0) goto c6Bgy; else goto c6Bgx;
       c6Bgy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Bgx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Bgw::I64;
           R3 = sat_s6ANw_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.100547958 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct2_closure" {
     Data.Semigroup.Internal.$fMonoidProduct2_closure:
         const Data.Semigroup.Internal.$fMonoidProduct2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fMonoidProduct2_entry() //  [R2]
         { info_tbl: [(c6BgP,
                       label: Data.Semigroup.Internal.$fMonoidProduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BgP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BgQ; else goto c6BgR;
       c6BgQ: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BgR: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.104820796 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_info;
         const 0;
 },
 z_s6ANz_entry() //  [R1]
         { info_tbl: [(c6Bh7,
                       label: z_s6ANz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bh7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Bh8; else goto c6Bh9;
       c6Bh8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bh9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 go_s6ANA_entry() //  [R1, R2]
         { info_tbl: [(c6Bhm,
                       label: go_s6ANA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bhm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Bhn; else goto c6Bho;
       c6Bhn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bho: // global
           I64[Sp - 32] = block_c6Bhf_info;
           _s6ANA::P64 = R1;
           _s6ANy::P64 = P64[R1 + 7];
           _s6ANz::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6ANy::P64;
           P64[Sp - 16] = _s6ANz::P64;
           P64[Sp - 8] = _s6ANA::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6Bhy; else goto c6Bhg;
       u6Bhy: // global
           call _c6Bhf(R1) args: 0, res: 0, upd: 0;
       c6Bhg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Bhf() //  [R1]
         { info_tbl: [(c6Bhf,
                       label: block_c6Bhf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bhf: // global
           if (R1 & 7 == 1) goto c6Bhj; else goto c6Bhk;
       c6Bhj: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6Bhk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Bhw; else goto c6Bhv;
       c6Bhw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Bhv: // global
           _s6AND::P64 = P64[R1 + 6];
           _s6ANE::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6ANE::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6AND::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Num.*_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_entry() //  [R2]
         { info_tbl: [(c6Bhz,
                       label: Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bhz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6BhD; else goto c6BhC;
       c6BhD: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BhC: // global
           I64[Hp - 40] = z_s6ANz_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6ANA_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.115485004 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidProduct_closure" {
     Data.Semigroup.Internal.$fMonoidProduct_closure:
         const Data.Semigroup.Internal.$fMonoidProduct_info;
         const 0;
 },
 sat_s6ANK_entry() //  [R1]
         { info_tbl: [(c6Big,
                       label: sat_s6ANK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Big: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bih; else goto c6Bii;
       c6Bih: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bii: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ANJ_entry() //  [R1]
         { info_tbl: [(c6Bin,
                       label: sat_s6ANJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bin: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bio; else goto c6Bip;
       c6Bio: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bip: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ANI_entry() //  [R1]
         { info_tbl: [(c6Biu,
                       label: sat_s6ANI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Biu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Biv; else goto c6Biw;
       c6Biv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Biw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidProduct2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ANH_entry() //  [R1]
         { info_tbl: [(c6BiB,
                       label: sat_s6ANH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BiB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BiC; else goto c6BiD;
       c6BiC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BiD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupProduct_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidProduct_entry() //  [R2]
         { info_tbl: [(c6BiF,
                       label: Data.Semigroup.Internal.$fMonoidProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BiF: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6BiJ; else goto c6BiI;
       c6BiJ: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BiI: // global
           I64[Hp - 128] = sat_s6ANK_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6ANJ_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6ANI_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6ANH_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.126432151 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorProduct_closure" {
     Data.Semigroup.Internal.$fFunctorProduct_closure:
         const GHC.Base.C:Functor_con_info;
         const Data.Semigroup.Internal.$fFunctorDual2_closure+1;
         const Data.Semigroup.Internal.$fFunctorDual1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.128322396 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct3_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct3_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct3_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct3_entry() //  [R2]
         { info_tbl: [(c6Bjn,
                       label: Data.Semigroup.Internal.$fApplicativeProduct3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bjn: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.131702647 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct2_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct2_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct2_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct2_entry() //  [R2, R3]
         { info_tbl: [(c6Bjy,
                       label: Data.Semigroup.Internal.$fApplicativeProduct2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bjy: // global
           _s6ANM::P64 = R2;
           R2 = R3;
           R1 = _s6ANM::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.135202854 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct_$c*>_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct_$c*>_entry() //  [R3]
         { info_tbl: [(c6BjJ,
                       label: Data.Semigroup.Internal.$fApplicativeProduct_$c*>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BjJ: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.13868017 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct1_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct1_closure:
         const Data.Semigroup.Internal.$fApplicativeProduct1_info;
 },
 Data.Semigroup.Internal.$fApplicativeProduct1_entry() //  [R2]
         { info_tbl: [(c6BjU,
                       label: Data.Semigroup.Internal.$fApplicativeProduct1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BjU: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.141907944 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeProduct_closure" {
     Data.Semigroup.Internal.$fApplicativeProduct_closure:
         const GHC.Base.C:Applicative_con_info;
         const Data.Semigroup.Internal.$fFunctorProduct_closure+1;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const Data.Semigroup.Internal.$fApplicativeProduct3_closure+1;
         const Data.Semigroup.Internal.$fApplicativeProduct2_closure+2;
         const Data.Semigroup.Internal.$fApplicativeProduct_$c*>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeProduct1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.144077217 UTC

[section ""data" . Data.Semigroup.Internal.$fFunctorAlt_closure" {
     Data.Semigroup.Internal.$fFunctorAlt_closure:
         const Data.Semigroup.Internal.$fFunctorAlt_info;
 },
 sat_s6ANU_entry() //  [R1]
         { info_tbl: [(c6Bka,
                       label: sat_s6ANU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bka: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bkb; else goto c6Bkc;
       c6Bkb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bkc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<$_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ANT_entry() //  [R1]
         { info_tbl: [(c6Bkh,
                       label: sat_s6ANT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bkh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bki; else goto c6Bkj;
       c6Bki: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bkj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fFunctorAlt_entry() //  [R2]
         { info_tbl: [(c6Bkl,
                       label: Data.Semigroup.Internal.$fFunctorAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bkl: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6Bkp; else goto c6Bko;
       c6Bkp: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fFunctorAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bko: // global
           I64[Hp - 64] = sat_s6ANU_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6ANT_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.151873436 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure" {
     Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure:
         const Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_info;
 },
 sat_s6ANW_entry() //  [R1]
         { info_tbl: [(c6BkS,
                       label: sat_s6ANW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BkS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BkT; else goto c6BkU;
       c6BkT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BkU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_entry() //  [R2]
         { info_tbl: [(c6BkV,
                       label: Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BkV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BkZ; else goto c6BkY;
       c6BkZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BkY: // global
           I64[Hp - 16] = sat_s6ANW_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fFunctorAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.158360273 UTC

[section ""data" . Data.Semigroup.Internal.$fApplicativeAlt_closure" {
     Data.Semigroup.Internal.$fApplicativeAlt_closure:
         const Data.Semigroup.Internal.$fApplicativeAlt_info;
 },
 sat_s6AO3_entry() //  [R1]
         { info_tbl: [(c6Bli,
                       label: sat_s6AO3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bli: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Blj; else goto c6Blk;
       c6Blj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Blk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AO2_entry() //  [R1]
         { info_tbl: [(c6Blp,
                       label: sat_s6AO2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Blp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Blq; else goto c6Blr;
       c6Blq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Blr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AO1_entry() //  [R1]
         { info_tbl: [(c6Blw,
                       label: sat_s6AO1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Blw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Blx; else goto c6Bly;
       c6Blx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bly: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AO0_entry() //  [R1]
         { info_tbl: [(c6BlD,
                       label: sat_s6AO0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BlD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BlE; else goto c6BlF;
       c6BlE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BlF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ANZ_entry() //  [R1]
         { info_tbl: [(c6BlK,
                       label: sat_s6ANZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BlK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BlL; else goto c6BlM;
       c6BlL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BlM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ANY_entry() //  [R1]
         { info_tbl: [(c6BlR,
                       label: sat_s6ANY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BlR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BlS; else goto c6BlT;
       c6BlS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BlT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fApplicativeAlt_entry() //  [R2]
         { info_tbl: [(c6BlV,
                       label: Data.Semigroup.Internal.$fApplicativeAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BlV: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto c6BlZ; else goto c6BlY;
       c6BlZ: // global
           HpAlloc = 200;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fApplicativeAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BlY: // global
           I64[Hp - 192] = sat_s6AO3_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s6AO2_info;
           P64[Hp - 152] = R2;
           I64[Hp - 144] = sat_s6AO1_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s6AO0_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s6ANZ_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s6ANY_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = Hp - 96;
           P64[Hp - 24] = Hp - 120;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 168;
           P64[Hp] = Hp - 192;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.175507302 UTC

[section ""data" . Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure" {
     Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure:
         const Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_info;
 },
 sat_s6AO5_entry() //  [R1]
         { info_tbl: [(c6BmU,
                       label: sat_s6AO5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BmU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BmV; else goto c6BmW;
       c6BmV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BmW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_entry() //  [R2]
         { info_tbl: [(c6BmX,
                       label: Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BmX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Bn1; else goto c6Bn0;
       c6Bn1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bn0: // global
           I64[Hp - 16] = sat_s6AO5_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.182075291 UTC

[section ""data" . Data.Semigroup.Internal.$fAlternativeAlt_closure" {
     Data.Semigroup.Internal.$fAlternativeAlt_closure:
         const Data.Semigroup.Internal.$fAlternativeAlt_info;
 },
 sat_s6AOb_entry() //  [R1]
         { info_tbl: [(c6Bnk,
                       label: sat_s6AOb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bnk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bnl; else goto c6Bnm;
       c6Bnl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bnm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.many_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOa_entry() //  [R1]
         { info_tbl: [(c6Bnr,
                       label: sat_s6AOa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bnr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bns; else goto c6Bnt;
       c6Bns: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bnt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.some_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AO9_entry() //  [R1]
         { info_tbl: [(c6Bny,
                       label: sat_s6AO9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bny: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bnz; else goto c6BnA;
       c6Bnz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BnA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AO8_entry() //  [R1]
         { info_tbl: [(c6BnF,
                       label: sat_s6AO8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BnF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BnG; else goto c6BnH;
       c6BnG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BnH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AO7_entry() //  [R1]
         { info_tbl: [(c6BnM,
                       label: sat_s6AO7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BnM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BnN; else goto c6BnO;
       c6BnN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BnO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fAlternativeAlt_entry() //  [R2]
         { info_tbl: [(c6BnQ,
                       label: Data.Semigroup.Internal.$fAlternativeAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BnQ: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c6BnU; else goto c6BnT;
       c6BnU: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fAlternativeAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BnT: // global
           I64[Hp - 160] = sat_s6AOb_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6AOa_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6AO9_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6AO8_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6AO7_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.196188474 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_info;
 },
 sat_s6AOd_entry() //  [R1]
         { info_tbl: [(c6BoI,
                       label: sat_s6AOd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BoI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BoJ; else goto c6BoK;
       c6BoJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BoK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_entry() //  [R2]
         { info_tbl: [(c6BoL,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BoL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BoP; else goto c6BoO;
       c6BoP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BoO: // global
           I64[Hp - 16] = sat_s6AOd_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fAlternativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.202177638 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure" {
     Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure:
         const Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_info;
 },
 sat_s6AOf_entry() //  [R1]
         { info_tbl: [(c6Bp8,
                       label: sat_s6AOf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bp8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bp9; else goto c6Bpa;
       c6Bp9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bpa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_entry() //  [R2]
         { info_tbl: [(c6Bpb,
                       label: Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bpb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Bpf; else goto c6Bpe;
       c6Bpf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bpe: // global
           I64[Hp - 16] = sat_s6AOf_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fApplicativeAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.208428837 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadAlt_closure" {
     Data.Semigroup.Internal.$fMonadAlt_closure:
         const Data.Semigroup.Internal.$fMonadAlt_info;
 },
 sat_s6AOl_entry() //  [R1]
         { info_tbl: [(c6Bpy,
                       label: sat_s6AOl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bpy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bpz; else goto c6BpA;
       c6Bpz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BpA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.fail_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOk_entry() //  [R1]
         { info_tbl: [(c6BpF,
                       label: sat_s6AOk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BpF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BpG; else goto c6BpH;
       c6BpG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BpH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOj_entry() //  [R1]
         { info_tbl: [(c6BpM,
                       label: sat_s6AOj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BpM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BpN; else goto c6BpO;
       c6BpN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BpO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOi_entry() //  [R1]
         { info_tbl: [(c6BpT,
                       label: sat_s6AOi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BpT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BpU; else goto c6BpV;
       c6BpU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BpV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOh_entry() //  [R1]
         { info_tbl: [(c6Bq0,
                       label: sat_s6AOh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bq0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bq1; else goto c6Bq2;
       c6Bq1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bq2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_$cp1Monad_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadAlt_entry() //  [R2]
         { info_tbl: [(c6Bq4,
                       label: Data.Semigroup.Internal.$fMonadAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bq4: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto c6Bq8; else goto c6Bq7;
       c6Bq8: // global
           HpAlloc = 168;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bq7: // global
           I64[Hp - 160] = sat_s6AOl_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6AOk_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6AOj_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6AOi_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6AOh_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.222954209 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_info;
 },
 sat_s6AOn_entry() //  [R1]
         { info_tbl: [(c6BqW,
                       label: sat_s6AOn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BqW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BqX; else goto c6BqY;
       c6BqX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BqY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_entry() //  [R2]
         { info_tbl: [(c6BqZ,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BqZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Br3; else goto c6Br2;
       c6Br3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Br2: // global
           I64[Hp - 16] = sat_s6AOn_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fMonadAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.229371168 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadPlusAlt_closure" {
     Data.Semigroup.Internal.$fMonadPlusAlt_closure:
         const Data.Semigroup.Internal.$fMonadPlusAlt_info;
 },
 sat_s6AOs_entry() //  [R1]
         { info_tbl: [(c6Brm,
                       label: sat_s6AOs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Brm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Brn; else goto c6Bro;
       c6Brn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bro: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mplus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOr_entry() //  [R1]
         { info_tbl: [(c6Brt,
                       label: sat_s6AOr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Brt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bru; else goto c6Brv;
       c6Bru: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Brv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mzero_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOq_entry() //  [R1]
         { info_tbl: [(c6BrA,
                       label: sat_s6AOq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BrA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BrB; else goto c6BrC;
       c6BrB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BrC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOp_entry() //  [R1]
         { info_tbl: [(c6BrH,
                       label: sat_s6AOp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BrH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BrI; else goto c6BrJ;
       c6BrI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BrJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonadPlusAlt_entry() //  [R2]
         { info_tbl: [(c6BrL,
                       label: Data.Semigroup.Internal.$fMonadPlusAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BrL: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6BrP; else goto c6BrO;
       c6BrP: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonadPlusAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BrO: // global
           I64[Hp - 128] = sat_s6AOs_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6AOr_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6AOq_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6AOp_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.241941454 UTC

[section ""data" . Data.Semigroup.Internal.$fEnumAlt_closure" {
     Data.Semigroup.Internal.$fEnumAlt_closure:
         const Data.Semigroup.Internal.$fEnumAlt_info;
 },
 sat_s6AOB_entry() //  [R1]
         { info_tbl: [(c6Bsw,
                       label: sat_s6AOB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bsw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bsx; else goto c6Bsy;
       c6Bsx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bsy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThenTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOA_entry() //  [R1]
         { info_tbl: [(c6BsD,
                       label: sat_s6AOA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BsD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BsE; else goto c6BsF;
       c6BsE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BsF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromTo_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOz_entry() //  [R1]
         { info_tbl: [(c6BsK,
                       label: sat_s6AOz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BsK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BsL; else goto c6BsM;
       c6BsL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BsM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFromThen_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOy_entry() //  [R1]
         { info_tbl: [(c6BsR,
                       label: sat_s6AOy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BsR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BsS; else goto c6BsT;
       c6BsS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BsT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.enumFrom_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOx_entry() //  [R1]
         { info_tbl: [(c6BsY,
                       label: sat_s6AOx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BsY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BsZ; else goto c6Bt0;
       c6BsZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bt0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.fromEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOw_entry() //  [R1]
         { info_tbl: [(c6Bt5,
                       label: sat_s6AOw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bt5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bt6; else goto c6Bt7;
       c6Bt6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bt7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.toEnum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOv_entry() //  [R1]
         { info_tbl: [(c6Btc,
                       label: sat_s6AOv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Btc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Btd; else goto c6Bte;
       c6Btd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bte: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.pred_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOu_entry() //  [R1]
         { info_tbl: [(c6Btj,
                       label: sat_s6AOu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Btj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Btk; else goto c6Btl;
       c6Btk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Btl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.succ_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEnumAlt_entry() //  [R2]
         { info_tbl: [(c6Btn,
                       label: Data.Semigroup.Internal.$fEnumAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Btn: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6Btr; else goto c6Btq;
       c6Btr: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEnumAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Btq: // global
           I64[Hp - 256] = sat_s6AOB_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6AOA_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6AOz_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6AOy_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6AOx_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6AOw_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6AOv_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6AOu_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Enum.C:Enum_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.262205597 UTC

[section ""data" . Data.Semigroup.Internal.$fNumAlt_closure" {
     Data.Semigroup.Internal.$fNumAlt_closure:
         const Data.Semigroup.Internal.$fNumAlt_info;
 },
 sat_s6AOJ_entry() //  [R1]
         { info_tbl: [(c6BuA,
                       label: sat_s6AOJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BuA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BuB; else goto c6BuC;
       c6BuB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BuC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOI_entry() //  [R1]
         { info_tbl: [(c6BuH,
                       label: sat_s6AOI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BuH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BuI; else goto c6BuJ;
       c6BuI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BuJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOH_entry() //  [R1]
         { info_tbl: [(c6BuO,
                       label: sat_s6AOH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BuO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BuP; else goto c6BuQ;
       c6BuP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BuQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOG_entry() //  [R1]
         { info_tbl: [(c6BuV,
                       label: sat_s6AOG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BuV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BuW; else goto c6BuX;
       c6BuW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BuX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOF_entry() //  [R1]
         { info_tbl: [(c6Bv2,
                       label: sat_s6AOF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bv2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bv3; else goto c6Bv4;
       c6Bv3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bv4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOE_entry() //  [R1]
         { info_tbl: [(c6Bv9,
                       label: sat_s6AOE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bv9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bva; else goto c6Bvb;
       c6Bva: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bvb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOD_entry() //  [R1]
         { info_tbl: [(c6Bvg,
                       label: sat_s6AOD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bvg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bvh; else goto c6Bvi;
       c6Bvh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bvi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumAlt_entry() //  [R2]
         { info_tbl: [(c6Bvk,
                       label: Data.Semigroup.Internal.$fNumAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bvk: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6Bvo; else goto c6Bvn;
       c6Bvo: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bvn: // global
           I64[Hp - 224] = sat_s6AOJ_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6AOI_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6AOH_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6AOG_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6AOF_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6AOE_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6AOD_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.284130342 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAlt_closure" {
     Data.Semigroup.Internal.$fEqAlt_closure:
         const Data.Semigroup.Internal.$fEqAlt_info;
 },
 sat_s6AOM_entry() //  [R1]
         { info_tbl: [(c6Bwq,
                       label: sat_s6AOM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bwq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bwr; else goto c6Bws;
       c6Bwr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bws: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOL_entry() //  [R1]
         { info_tbl: [(c6Bwx,
                       label: sat_s6AOL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bwx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bwy; else goto c6Bwz;
       c6Bwy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bwz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqAlt_entry() //  [R2]
         { info_tbl: [(c6BwB,
                       label: Data.Semigroup.Internal.$fEqAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BwB: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6BwF; else goto c6BwE;
       c6BwF: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BwE: // global
           I64[Hp - 64] = sat_s6AOM_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6AOL_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.291939609 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_info;
 },
 sat_s6AOO_entry() //  [R1]
         { info_tbl: [(c6Bx8,
                       label: sat_s6AOO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bx8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bx9; else goto c6Bxa;
       c6Bx9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Bxa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6Bxb,
                       label: Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bxb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Bxf; else goto c6Bxe;
       c6Bxf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bxe: // global
           I64[Hp - 16] = sat_s6AOO_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqAlt_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.299968285 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAlt_closure" {
     Data.Semigroup.Internal.$fOrdAlt_closure:
         const Data.Semigroup.Internal.$fOrdAlt_info;
 },
 sat_s6AOX_entry() //  [R1]
         { info_tbl: [(c6Bxy,
                       label: sat_s6AOX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bxy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bxz; else goto c6BxA;
       c6Bxz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BxA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOW_entry() //  [R1]
         { info_tbl: [(c6BxF,
                       label: sat_s6AOW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BxF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BxG; else goto c6BxH;
       c6BxG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BxH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOV_entry() //  [R1]
         { info_tbl: [(c6BxM,
                       label: sat_s6AOV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BxM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BxN; else goto c6BxO;
       c6BxN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BxO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOU_entry() //  [R1]
         { info_tbl: [(c6BxT,
                       label: sat_s6AOU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BxT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BxU; else goto c6BxV;
       c6BxU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BxV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOT_entry() //  [R1]
         { info_tbl: [(c6By0,
                       label: sat_s6AOT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6By0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6By1; else goto c6By2;
       c6By1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6By2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOS_entry() //  [R1]
         { info_tbl: [(c6By7,
                       label: sat_s6AOS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6By7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6By8; else goto c6By9;
       c6By8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6By9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOR_entry() //  [R1]
         { info_tbl: [(c6Bye,
                       label: sat_s6AOR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Bye: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Byf; else goto c6Byg;
       c6Byf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Byg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AOQ_entry() //  [R1]
         { info_tbl: [(c6Byl,
                       label: sat_s6AOQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Byl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Bym; else goto c6Byn;
       c6Bym: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Byn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdAlt_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdAlt_entry() //  [R2]
         { info_tbl: [(c6Byp,
                       label: Data.Semigroup.Internal.$fOrdAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Byp: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6Byt; else goto c6Bys;
       c6Byt: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Bys: // global
           I64[Hp - 256] = sat_s6AOX_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6AOW_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6AOV_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6AOU_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6AOT_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6AOS_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6AOR_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6AOQ_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.318896262 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt1_closure" {
     Data.Semigroup.Internal.$fShowAlt1_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.320625057 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAlt3_bytes" {
     Data.Semigroup.Internal.$fShowAlt3_bytes:
         I8[] [65,108,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.32270249 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAlt2_bytes" {
     Data.Semigroup.Internal.$fShowAlt2_bytes:
         I8[] [103,101,116,65,108,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.324393962 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll5_bytes" {
     Data.Semigroup.Internal.$fReadAll5_bytes:
         I8[] [125]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.328195811 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec1_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec1_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec1_info;
 },
 f1_s6AP1_entry() //  [R1]
         { info_tbl: [(c6BzG,
                       label: f1_s6AP1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BzG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6BzH; else goto c6BzI;
       c6BzH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BzI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AP4_entry() //  [R1]
         { info_tbl: [(c6BA3,
                       label: sat_s6AP4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BA3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BA4; else goto c6BA5;
       c6BA4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BA5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AP5_entry() //  [R1]
         { info_tbl: [(c6BA6,
                       label: sat_s6AP5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BA6: // global
           _s6AP5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BA7; else goto c6BA8;
       c6BA8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BAa; else goto c6BA9;
       c6BAa: // global
           HpAlloc = 24;
           goto c6BA7;
       c6BA7: // global
           R1 = _s6AP5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BA9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AP5::P64;
           _s6AP1::P64 = P64[_s6AP5::P64 + 16];
           _s6AP3::P64 = P64[_s6AP5::P64 + 24];
           I64[Hp - 16] = sat_s6AP4_info;
           P64[Hp] = _s6AP3::P64;
           R2 = Hp - 16;
           R1 = _s6AP1::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AP6_entry() //  [R1]
         { info_tbl: [(c6BAb,
                       label: sat_s6AP6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BAb: // global
           _s6AP6::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BAc; else goto c6BAd;
       c6BAd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BAf; else goto c6BAe;
       c6BAf: // global
           HpAlloc = 32;
           goto c6BAc;
       c6BAc: // global
           R1 = _s6AP6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BAe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AP6::P64;
           _s6AP1::P64 = P64[_s6AP6::P64 + 16];
           _s6AP3::P64 = P64[_s6AP6::P64 + 24];
           I64[Hp - 24] = sat_s6AP5_info;
           P64[Hp - 8] = _s6AP1::P64;
           P64[Hp] = _s6AP3::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AP7_entry() //  [R1, R2]
         { info_tbl: [(c6BAg,
                       label: sat_s6AP7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BAg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BAk; else goto c6BAj;
       c6BAk: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BAj: // global
           _s6AP1::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6AP6_info;
           P64[Hp - 8] = _s6AP1::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6APa_entry() //  [R1]
         { info_tbl: [(c6BAI,
                       label: sat_s6APa_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BAI: // global
           _s6APa::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BAJ; else goto c6BAK;
       c6BAK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BAM; else goto c6BAL;
       c6BAM: // global
           HpAlloc = 24;
           goto c6BAJ;
       c6BAJ: // global
           R1 = _s6APa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BAL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6APa::P64;
           _s6AP8::P64 = P64[_s6APa::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6AP8::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6APb_entry() //  [R1]
         { info_tbl: [(c6BAN,
                       label: sat_s6APb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BAN: // global
           _s6APb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BAO; else goto c6BAP;
       c6BAP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BAR; else goto c6BAQ;
       c6BAR: // global
           HpAlloc = 24;
           goto c6BAO;
       c6BAO: // global
           R1 = _s6APb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BAQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6APb::P64;
           _s6AP1::P64 = P64[_s6APb::P64 + 16];
           _s6AP8::P64 = P64[_s6APb::P64 + 24];
           I64[Hp - 16] = sat_s6APa_info;
           P64[Hp] = _s6AP8::P64;
           R2 = Hp - 16;
           R1 = _s6AP1::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6APc_entry() //  [R1]
         { info_tbl: [(c6BAS,
                       label: sat_s6APc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BAS: // global
           _s6APc::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BAT; else goto c6BAU;
       c6BAU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BAW; else goto c6BAV;
       c6BAW: // global
           HpAlloc = 32;
           goto c6BAT;
       c6BAT: // global
           R1 = _s6APc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BAV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6APc::P64;
           _s6AP1::P64 = P64[_s6APc::P64 + 16];
           _s6AP8::P64 = P64[_s6APc::P64 + 24];
           I64[Hp - 24] = sat_s6APb_info;
           P64[Hp - 8] = _s6AP1::P64;
           P64[Hp] = _s6AP8::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6APd_entry() //  [R1]
         { info_tbl: [(c6BAX,
                       label: sat_s6APd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BAX: // global
           _s6APd::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BAY; else goto c6BAZ;
       c6BAZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BB1; else goto c6BB0;
       c6BB1: // global
           HpAlloc = 32;
           goto c6BAY;
       c6BAY: // global
           R1 = _s6APd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BB0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6APd::P64;
           _s6AP1::P64 = P64[_s6APd::P64 + 16];
           _s6AP8::P64 = P64[_s6APd::P64 + 24];
           I64[Hp - 24] = sat_s6APc_info;
           P64[Hp - 8] = _s6AP1::P64;
           P64[Hp] = _s6AP8::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6APe_entry() //  [R1, R2]
         { info_tbl: [(c6BB3,
                       label: sat_s6APe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BB3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6BB7; else goto c6BB6;
       c6BB7: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BB6: // global
           _s6AP1::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6APd_info;
           P64[Hp - 32] = _s6AP1::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec1_entry() //  [R2, R3, R4]
         { info_tbl: [(c6BBb,
                       label: Data.Semigroup.Internal.$w$cshowsPrec1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BBb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6BBf; else goto c6BBe;
       c6BBf: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BBe: // global
           I64[Hp - 40] = f1_s6AP1_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6BzC::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6BB9; else goto c6BBa;
       c6BB9: // global
           I64[Hp - 8] = sat_s6AP7_info;
           P64[Hp] = _c6BzC::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6BBa: // global
           I64[Hp - 8] = sat_s6APe_info;
           P64[Hp] = _c6BzC::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.353954423 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6BCw,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BCw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6BCx; else goto c6BCy;
       c6BCx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BCy: // global
           I64[Sp - 24] = block_c6BCt_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6BCC; else goto c6BCu;
       u6BCC: // global
           call _c6BCt(R1) args: 0, res: 0, upd: 0;
       c6BCu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6BCt() //  [R1]
         { info_tbl: [(c6BCt,
                       label: block_c6BCt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BCt: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.359887897 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll4_closure" {
     Data.Semigroup.Internal.$fReadAll4_closure:
         const Data.Semigroup.Internal.$fReadAll4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll4_entry() //  [R1]
         { info_tbl: [(c6BCT,
                       label: Data.Semigroup.Internal.$fReadAll4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BCT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BCU; else goto c6BCV;
       c6BCU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BCV: // global
           (_c6BCQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6BCQ::I64 == 0) goto c6BCS; else goto c6BCR;
       c6BCS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6BCR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6BCQ::I64;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.364829494 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshow_info;
         const 0;
 },
 sat_s6APm_entry() //  [R1]
         { info_tbl: [(c6BDg,
                       label: sat_s6APm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BDg: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6BDh; else goto c6BDi;
       c6BDh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BDi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6APn_entry() //  [R1]
         { info_tbl: [(c6BDj,
                       label: sat_s6APn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BDj: // global
           _s6APn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BDk; else goto c6BDl;
       c6BDl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BDn; else goto c6BDm;
       c6BDn: // global
           HpAlloc = 32;
           goto c6BDk;
       c6BDk: // global
           R1 = _s6APn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BDm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6APn::P64;
           _s6APk::P64 = P64[_s6APn::P64 + 16];
           _s6APl::P64 = P64[_s6APn::P64 + 24];
           I64[Hp - 24] = sat_s6APm_info;
           P64[Hp - 8] = _s6APk::P64;
           P64[Hp] = _s6APl::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6BDo,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BDo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BDs; else goto c6BDr;
       c6BDs: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BDr: // global
           I64[Hp - 24] = sat_s6APn_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAlt3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.373180585 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAlt_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAlt_$cshowList_info;
 },
 sat_s6APs_entry() //  [R1, R2]
         { info_tbl: [(c6BDW,
                       label: sat_s6APs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BDW: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec1_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c6BDZ,
                       label: Data.Semigroup.Internal.$fShowAlt_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BDZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BE3; else goto c6BE2;
       c6BE3: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BE2: // global
           I64[Hp - 8] = sat_s6APs_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.378823375 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAlt_closure" {
     Data.Semigroup.Internal.$fShowAlt_closure:
         const Data.Semigroup.Internal.$fShowAlt_info;
         const 0;
 },
 sat_s6APw_entry() //  [R1, R2, R3]
         { info_tbl: [(c6BEl,
                       label: sat_s6APw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BEl: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowAlt_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6APv_entry() //  [R1, R2]
         { info_tbl: [(c6BEt,
                       label: sat_s6APv_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BEt: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowAlt_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6APu_entry() //  [R1, R2, R3]
         { info_tbl: [(c6BEB,
                       label: sat_s6APu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BEB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowAlt_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAlt_entry() //  [R2]
         { info_tbl: [(c6BEF,
                       label: Data.Semigroup.Internal.$fShowAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BEF: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6BEJ; else goto c6BEI;
       c6BEJ: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BEI: // global
           I64[Hp - 72] = sat_s6APw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6APv_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6APu_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.388062775 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAlt5_bytes" {
     Data.Semigroup.Internal.$fReadAlt5_bytes:
         I8[] [65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.389932474 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt4_closure" {
     Data.Semigroup.Internal.$fReadAlt4_closure:
         const Data.Semigroup.Internal.$fReadAlt4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAlt4_entry() //  [R1]
         { info_tbl: [(c6BFc,
                       label: Data.Semigroup.Internal.$fReadAlt4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BFc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BFd; else goto c6BFe;
       c6BFd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BFe: // global
           (_c6BF9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6BF9::I64 == 0) goto c6BFb; else goto c6BFa;
       c6BFb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6BFa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6BF9::I64;
           R2 = Data.Semigroup.Internal.$fReadAlt5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.394244721 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAlt_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAlt4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.396009759 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll11_bytes" {
     Data.Semigroup.Internal.$fReadAll11_bytes:
         I8[] [123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.397919895 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll10_closure" {
     Data.Semigroup.Internal.$fReadAll10_closure:
         const Data.Semigroup.Internal.$fReadAll10_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll10_entry() //  [R1]
         { info_tbl: [(c6BFv,
                       label: Data.Semigroup.Internal.$fReadAll10_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BFv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BFw; else goto c6BFx;
       c6BFw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BFx: // global
           (_c6BFs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6BFs::I64 == 0) goto c6BFu; else goto c6BFt;
       c6BFu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6BFt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6BFs::I64;
           R2 = Data.Semigroup.Internal.$fReadAll11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.401903711 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAll_lexeme_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Semigroup.Internal.$fReadAll10_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.403673024 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAlt3_bytes" {
     Data.Semigroup.Internal.$fReadAlt3_bytes:
         I8[] [103,101,116,65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.405487891 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt2_closure" {
     Data.Semigroup.Internal.$fReadAlt2_closure:
         const Data.Semigroup.Internal.$fReadAlt2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAlt2_entry() //  [R1]
         { info_tbl: [(c6BFO,
                       label: Data.Semigroup.Internal.$fReadAlt2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BFO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BFP; else goto c6BFQ;
       c6BFP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BFQ: // global
           (_c6BFL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6BFL::I64 == 0) goto c6BFN; else goto c6BFM;
       c6BFN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6BFM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6BFL::I64;
           R2 = Data.Semigroup.Internal.$fReadAlt3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.4094272 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll6_closure" {
     Data.Semigroup.Internal.$fReadAll6_closure:
         const GHC.Types.I#_con_info;
         const 11;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.411108423 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll3_closure" {
     Data.Semigroup.Internal.$fReadAll3_closure:
         const Text.Read.Lex.Punc_con_info;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.415236472 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt1_closure" {
     Data.Semigroup.Internal.$fReadAlt1_closure:
         const Data.Semigroup.Internal.$fReadAlt1_info;
         const 0;
 },
 lvl12_s6APy_entry() //  [R1]
         { info_tbl: [(c6BG9,
                       label: lvl12_s6APy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BG9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6BGa; else goto c6BGb;
       c6BGa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BGb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6APz_entry() //  [R1]
         { info_tbl: [(c6BGh,
                       label: ds_s6APz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BGh: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6APK_entry() //  [R1]
         { info_tbl: [(c6BGS,
                       label: sat_s6APK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BGS: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6APN_entry() //  [R1, R2]
         { info_tbl: [(c6BGY,
                       label: sat_s6APN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BGY: // global
           _s6API::P64 = R2;
           _s6APN::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6BGZ; else goto c6BH0;
       c6BH0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BH2; else goto c6BH1;
       c6BH2: // global
           HpAlloc = 24;
           goto c6BGZ;
       c6BGZ: // global
           R2 = _s6API::P64;
           R1 = _s6APN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BH1: // global
           _s6APC::P64 = P64[_s6APN::P64 + 7];
           I64[Hp - 16] = sat_s6APK_info;
           P64[Hp - 8] = _s6APC::P64;
           P64[Hp] = _s6API::P64;
           I64[Sp - 8] = block_c6BGV_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6BGV() //  [R1]
         { info_tbl: [(c6BGV,
                       label: block_c6BGV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BGV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BH5; else goto c6BH4;
       c6BH5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6BH4: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6APO_entry() //  [R1, R2]
         { info_tbl: [(c6BH6,
                       label: sat_s6APO_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BH6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BHa; else goto c6BH9;
       c6BHa: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BH9: // global
           _s6APz::P64 = P64[R1 + 7];
           _s6APC::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6APN_info;
           P64[Hp] = _s6APC::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6APz::P64;
           R2 = Data.Semigroup.Internal.$fReadAlt2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6APR_entry() //  [R1, R2]
         { info_tbl: [(c6BHe,
                       label: sat_s6APR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BHe: // global
           _s6APG::P64 = R2;
           _s6APR::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6BHf; else goto c6BHg;
       c6BHg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BHi; else goto c6BHh;
       c6BHi: // global
           HpAlloc = 24;
           goto c6BHf;
       c6BHf: // global
           R2 = _s6APG::P64;
           R1 = _s6APR::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BHh: // global
           _s6APz::P64 = P64[_s6APR::P64 + 7];
           _s6APC::P64 = P64[_s6APR::P64 + 15];
           I64[Hp - 16] = sat_s6APO_info;
           P64[Hp - 8] = _s6APz::P64;
           P64[Hp] = _s6APC::P64;
           I64[Sp - 8] = block_c6BHb_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6BHb() //  [R1]
         { info_tbl: [(c6BHb,
                       label: block_c6BHb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BHb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BHl; else goto c6BHk;
       c6BHl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6BHk: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6APU_entry() //  [R1, R2, R3]
         { info_tbl: [(c6BHm,
                       label: sat_s6APU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BHm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6BHn; else goto c6BHo;
       c6BHn: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BHo: // global
           I64[Sp - 24] = block_c6BGp_info;
           _s6APz::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6APz::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6BHB; else goto c6BGq;
       u6BHB: // global
           call _c6BGp(R1) args: 0, res: 0, upd: 0;
       c6BGq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6BGp() //  [R1]
         { info_tbl: [(c6BGp,
                       label: block_c6BGp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BGp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BHr; else goto c6BHq;
       c6BHr: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6BHq: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6BHt; else goto c6BHx;
       c6BHt: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6BHx: // global
           I64[Hp - 16] = sat_s6APR_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6BHu_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAlt_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6BHu() //  [R1]
         { info_tbl: [(c6BHu,
                       label: block_c6BHu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BHu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BHA; else goto c6BHz;
       c6BHA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6BHz: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt1_entry() //  [R2]
         { info_tbl: [(c6BHC,
                       label: Data.Semigroup.Internal.$fReadAlt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BHC: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6BHG; else goto c6BHF;
       c6BHG: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BHF: // global
           I64[Hp - 48] = lvl12_s6APy_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6APz_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6APU_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.442117876 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadsPrec_info;
         const 0;
 },
 ds_s6APW_entry() //  [R1]
         { info_tbl: [(c6BIW,
                       label: ds_s6APW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BIW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BIX; else goto c6BIY;
       c6BIX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BIY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6APY_entry() //  [R1]
         { info_tbl: [(c6BJ8,
                       label: sat_s6APY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BJ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BJ9; else goto c6BJa;
       c6BJ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BJa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6APZ_entry() //  [R1, R2]
         { info_tbl: [(c6BJb,
                       label: sat_s6APZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BJb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BJf; else goto c6BJe;
       c6BJf: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BJe: // global
           _s6APW::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6APY_info;
           P64[Hp - 8] = _s6APW::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6BJg,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BJg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6BJk; else goto c6BJj;
       c6BJk: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BJj: // global
           I64[Hp - 32] = ds_s6APW_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6APZ_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.451944518 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadListPrec_info;
         const 0;
 },
 sat_s6AQ1_entry() //  [R1]
         { info_tbl: [(c6BJR,
                       label: sat_s6AQ1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BJR: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6BJU,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BJU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BJY; else goto c6BJX;
       c6BJY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BJX: // global
           I64[Hp - 16] = sat_s6AQ1_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.458889659 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAlt_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAlt_$creadList_info;
         const 0;
 },
 sat_s6AQ3_entry() //  [R1]
         { info_tbl: [(c6BKj,
                       label: sat_s6AQ3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BKj: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AQ4_entry() //  [R1]
         { info_tbl: [(c6BKm,
                       label: sat_s6AQ4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BKm: // global
           _s6AQ4::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6BKn; else goto c6BKo;
       c6BKo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BKq; else goto c6BKp;
       c6BKq: // global
           HpAlloc = 24;
           goto c6BKn;
       c6BKn: // global
           R1 = _s6AQ4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BKp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AQ4::P64;
           _s6AQ2::P64 = P64[_s6AQ4::P64 + 16];
           I64[Hp - 16] = sat_s6AQ3_info;
           P64[Hp] = _s6AQ2::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_$creadList_entry() //  [R2]
         { info_tbl: [(c6BKr,
                       label: Data.Semigroup.Internal.$fReadAlt_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BKr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BKv; else goto c6BKu;
       c6BKv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BKu: // global
           I64[Hp - 16] = sat_s6AQ4_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.46741815 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAlt_closure" {
     Data.Semigroup.Internal.$fReadAlt_closure:
         const Data.Semigroup.Internal.$fReadAlt_info;
         const 0;
 },
 sat_s6AQ9_entry() //  [R1]
         { info_tbl: [(c6BKX,
                       label: sat_s6AQ9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BKX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BKY; else goto c6BKZ;
       c6BKY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BKZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQ8_entry() //  [R1]
         { info_tbl: [(c6BL4,
                       label: sat_s6AQ8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BL4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BL5; else goto c6BL6;
       c6BL5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BL6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQ7_entry() //  [R1]
         { info_tbl: [(c6BLb,
                       label: sat_s6AQ7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BLb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BLc; else goto c6BLd;
       c6BLc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BLd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQ6_entry() //  [R1]
         { info_tbl: [(c6BLi,
                       label: sat_s6AQ6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BLi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BLj; else goto c6BLk;
       c6BLj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BLk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadAlt_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAlt_entry() //  [R2]
         { info_tbl: [(c6BLm,
                       label: Data.Semigroup.Internal.$fReadAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BLm: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6BLq; else goto c6BLp;
       c6BLq: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BLp: // global
           I64[Hp - 128] = sat_s6AQ9_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6AQ8_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6AQ7_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6AQ6_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.479208766 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt1_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt1_closure:
         const Data.Semigroup.Internal.$fGeneric1Alt1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Alt1_entry() //  [R2]
         { info_tbl: [(c6BM3,
                       label: Data.Semigroup.Internal.$fGeneric1Alt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BM3: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.482927567 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt2_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt2_closure:
         const Data.Semigroup.Internal.$fGeneric1Alt2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Alt2_entry() //  [R2]
         { info_tbl: [(c6BMe,
                       label: Data.Semigroup.Internal.$fGeneric1Alt2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BMe: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.486219485 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Alt_closure" {
     Data.Semigroup.Internal.$fGeneric1Alt_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Alt2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Alt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.488202313 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt1_closure" {
     Data.Semigroup.Internal.$fGenericAlt1_closure:
         const Data.Semigroup.Internal.$fGenericAlt1_info;
 },
 Data.Semigroup.Internal.$fGenericAlt1_entry() //  [R2]
         { info_tbl: [(c6BMq,
                       label: Data.Semigroup.Internal.$fGenericAlt1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BMq: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.491692701 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt2_closure" {
     Data.Semigroup.Internal.$fGenericAlt2_closure:
         const Data.Semigroup.Internal.$fGenericAlt2_info;
 },
 Data.Semigroup.Internal.$fGenericAlt2_entry() //  [R2]
         { info_tbl: [(c6BMB,
                       label: Data.Semigroup.Internal.$fGenericAlt2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BMB: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.494987723 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAlt_closure" {
     Data.Semigroup.Internal.$fGenericAlt_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAlt2_closure+1;
         const Data.Semigroup.Internal.$fGenericAlt1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.498052251 UTC

[section ""data" . Data.Semigroup.Internal.$fNumProduct_closure" {
     Data.Semigroup.Internal.$fNumProduct_closure:
         const Data.Semigroup.Internal.$fNumProduct_info;
 },
 sat_s6AQl_entry() //  [R1]
         { info_tbl: [(c6BMR,
                       label: sat_s6AQl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BMR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BMS; else goto c6BMT;
       c6BMS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BMT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQk_entry() //  [R1]
         { info_tbl: [(c6BMY,
                       label: sat_s6AQk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BMY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BMZ; else goto c6BN0;
       c6BMZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BN0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQj_entry() //  [R1]
         { info_tbl: [(c6BN5,
                       label: sat_s6AQj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BN5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BN6; else goto c6BN7;
       c6BN6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BN7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQi_entry() //  [R1]
         { info_tbl: [(c6BNc,
                       label: sat_s6AQi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BNc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BNd; else goto c6BNe;
       c6BNd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BNe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQh_entry() //  [R1]
         { info_tbl: [(c6BNj,
                       label: sat_s6AQh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BNj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BNk; else goto c6BNl;
       c6BNk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BNl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQg_entry() //  [R1]
         { info_tbl: [(c6BNq,
                       label: sat_s6AQg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BNq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BNr; else goto c6BNs;
       c6BNr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BNs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQf_entry() //  [R1]
         { info_tbl: [(c6BNx,
                       label: sat_s6AQf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BNx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BNy; else goto c6BNz;
       c6BNy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BNz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumProduct_entry() //  [R2]
         { info_tbl: [(c6BNB,
                       label: Data.Semigroup.Internal.$fNumProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BNB: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6BNF; else goto c6BNE;
       c6BNF: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BNE: // global
           I64[Hp - 224] = sat_s6AQl_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6AQk_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6AQj_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6AQi_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6AQh_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6AQg_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6AQf_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.515275391 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product1_closure" {
     Data.Semigroup.Internal.$fGeneric1Product1_closure:
         const Data.Semigroup.Internal.$fGeneric1Product1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Product1_entry() //  [R2]
         { info_tbl: [(c6BOD,
                       label: Data.Semigroup.Internal.$fGeneric1Product1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BOD: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.519085316 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product2_closure" {
     Data.Semigroup.Internal.$fGeneric1Product2_closure:
         const Data.Semigroup.Internal.$fGeneric1Product2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Product2_entry() //  [R2]
         { info_tbl: [(c6BOO,
                       label: Data.Semigroup.Internal.$fGeneric1Product2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BOO: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.522459477 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Product_closure" {
     Data.Semigroup.Internal.$fGeneric1Product_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Product2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Product1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.524269858 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct1_closure" {
     Data.Semigroup.Internal.$fGenericProduct1_closure:
         const Data.Semigroup.Internal.$fGenericProduct1_info;
 },
 Data.Semigroup.Internal.$fGenericProduct1_entry() //  [R2]
         { info_tbl: [(c6BP0,
                       label: Data.Semigroup.Internal.$fGenericProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BP0: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.5277697 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct2_closure" {
     Data.Semigroup.Internal.$fGenericProduct2_closure:
         const Data.Semigroup.Internal.$fGenericProduct2_info;
 },
 Data.Semigroup.Internal.$fGenericProduct2_entry() //  [R2]
         { info_tbl: [(c6BPb,
                       label: Data.Semigroup.Internal.$fGenericProduct2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BPb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.531438605 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericProduct_closure" {
     Data.Semigroup.Internal.$fGenericProduct_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericProduct2_closure+1;
         const Data.Semigroup.Internal.$fGenericProduct1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.533790917 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedProduct_closure" {
     Data.Semigroup.Internal.$fBoundedProduct_closure:
         const Data.Semigroup.Internal.$fBoundedProduct_info;
 },
 sat_s6AQs_entry() //  [R1]
         { info_tbl: [(c6BPr,
                       label: sat_s6AQs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BPr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BPs; else goto c6BPt;
       c6BPs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BPt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQr_entry() //  [R1]
         { info_tbl: [(c6BPy,
                       label: sat_s6AQr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BPy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BPz; else goto c6BPA;
       c6BPz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BPA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedProduct_entry() //  [R2]
         { info_tbl: [(c6BPC,
                       label: Data.Semigroup.Internal.$fBoundedProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BPC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6BPG; else goto c6BPF;
       c6BPG: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BPF: // global
           I64[Hp - 64] = sat_s6AQs_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6AQr_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.541355259 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowProduct2_bytes" {
     Data.Semigroup.Internal.$fShowProduct2_bytes:
         I8[] [80,114,111,100,117,99,116,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.542995691 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowProduct1_bytes" {
     Data.Semigroup.Internal.$fShowProduct1_bytes:
         I8[] [103,101,116,80,114,111,100,117,99,116,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.546862791 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec4_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec4_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec4_info;
 },
 f_s6AQw_entry() //  [R1]
         { info_tbl: [(c6BQb,
                       label: f_s6AQw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BQb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6BQc; else goto c6BQd;
       c6BQc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BQd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AQz_entry() //  [R1]
         { info_tbl: [(c6BQy,
                       label: sat_s6AQz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BQy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BQz; else goto c6BQA;
       c6BQz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BQA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQA_entry() //  [R1]
         { info_tbl: [(c6BQB,
                       label: sat_s6AQA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BQB: // global
           _s6AQA::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BQC; else goto c6BQD;
       c6BQD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BQF; else goto c6BQE;
       c6BQF: // global
           HpAlloc = 24;
           goto c6BQC;
       c6BQC: // global
           R1 = _s6AQA::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BQE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AQA::P64;
           _s6AQw::P64 = P64[_s6AQA::P64 + 16];
           _s6AQy::P64 = P64[_s6AQA::P64 + 24];
           I64[Hp - 16] = sat_s6AQz_info;
           P64[Hp] = _s6AQy::P64;
           R2 = Hp - 16;
           R1 = _s6AQw::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQB_entry() //  [R1]
         { info_tbl: [(c6BQG,
                       label: sat_s6AQB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BQG: // global
           _s6AQB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BQH; else goto c6BQI;
       c6BQI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BQK; else goto c6BQJ;
       c6BQK: // global
           HpAlloc = 32;
           goto c6BQH;
       c6BQH: // global
           R1 = _s6AQB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BQJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AQB::P64;
           _s6AQw::P64 = P64[_s6AQB::P64 + 16];
           _s6AQy::P64 = P64[_s6AQB::P64 + 24];
           I64[Hp - 24] = sat_s6AQA_info;
           P64[Hp - 8] = _s6AQw::P64;
           P64[Hp] = _s6AQy::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQC_entry() //  [R1, R2]
         { info_tbl: [(c6BQL,
                       label: sat_s6AQC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BQL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BQP; else goto c6BQO;
       c6BQP: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BQO: // global
           _s6AQw::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6AQB_info;
           P64[Hp - 8] = _s6AQw::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AQF_entry() //  [R1]
         { info_tbl: [(c6BRd,
                       label: sat_s6AQF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BRd: // global
           _s6AQF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BRe; else goto c6BRf;
       c6BRf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BRh; else goto c6BRg;
       c6BRh: // global
           HpAlloc = 24;
           goto c6BRe;
       c6BRe: // global
           R1 = _s6AQF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BRg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AQF::P64;
           _s6AQD::P64 = P64[_s6AQF::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6AQD::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQG_entry() //  [R1]
         { info_tbl: [(c6BRi,
                       label: sat_s6AQG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BRi: // global
           _s6AQG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BRj; else goto c6BRk;
       c6BRk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BRm; else goto c6BRl;
       c6BRm: // global
           HpAlloc = 24;
           goto c6BRj;
       c6BRj: // global
           R1 = _s6AQG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BRl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AQG::P64;
           _s6AQw::P64 = P64[_s6AQG::P64 + 16];
           _s6AQD::P64 = P64[_s6AQG::P64 + 24];
           I64[Hp - 16] = sat_s6AQF_info;
           P64[Hp] = _s6AQD::P64;
           R2 = Hp - 16;
           R1 = _s6AQw::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQH_entry() //  [R1]
         { info_tbl: [(c6BRn,
                       label: sat_s6AQH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BRn: // global
           _s6AQH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BRo; else goto c6BRp;
       c6BRp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BRr; else goto c6BRq;
       c6BRr: // global
           HpAlloc = 32;
           goto c6BRo;
       c6BRo: // global
           R1 = _s6AQH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BRq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AQH::P64;
           _s6AQw::P64 = P64[_s6AQH::P64 + 16];
           _s6AQD::P64 = P64[_s6AQH::P64 + 24];
           I64[Hp - 24] = sat_s6AQG_info;
           P64[Hp - 8] = _s6AQw::P64;
           P64[Hp] = _s6AQD::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQI_entry() //  [R1]
         { info_tbl: [(c6BRs,
                       label: sat_s6AQI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BRs: // global
           _s6AQI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BRt; else goto c6BRu;
       c6BRu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BRw; else goto c6BRv;
       c6BRw: // global
           HpAlloc = 32;
           goto c6BRt;
       c6BRt: // global
           R1 = _s6AQI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BRv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AQI::P64;
           _s6AQw::P64 = P64[_s6AQI::P64 + 16];
           _s6AQD::P64 = P64[_s6AQI::P64 + 24];
           I64[Hp - 24] = sat_s6AQH_info;
           P64[Hp - 8] = _s6AQw::P64;
           P64[Hp] = _s6AQD::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AQJ_entry() //  [R1, R2]
         { info_tbl: [(c6BRy,
                       label: sat_s6AQJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BRy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6BRC; else goto c6BRB;
       c6BRC: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BRB: // global
           _s6AQw::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6AQI_info;
           P64[Hp - 32] = _s6AQw::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec4_entry() //  [R2, R3, R4]
         { info_tbl: [(c6BRG,
                       label: Data.Semigroup.Internal.$w$cshowsPrec4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BRG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6BRK; else goto c6BRJ;
       c6BRK: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BRJ: // global
           I64[Hp - 40] = f_s6AQw_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6BQ7::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6BRE; else goto c6BRF;
       c6BRE: // global
           I64[Hp - 8] = sat_s6AQC_info;
           P64[Hp] = _c6BQ7::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6BRF: // global
           I64[Hp - 8] = sat_s6AQJ_info;
           P64[Hp] = _c6BQ7::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.57288933 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_entry() //  [R2,
                                                                R3, R4]
         { info_tbl: [(c6BT1,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BT1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6BT2; else goto c6BT3;
       c6BT2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BT3: // global
           I64[Sp - 24] = block_c6BSY_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6BT7; else goto c6BSZ;
       u6BT7: // global
           call _c6BSY(R1) args: 0, res: 0, upd: 0;
       c6BSZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6BSY() //  [R1]
         { info_tbl: [(c6BSY,
                       label: block_c6BSY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BSY: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.579119735 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshow_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshow_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshow_info;
         const 0;
 },
 sat_s6AQR_entry() //  [R1]
         { info_tbl: [(c6BTu,
                       label: sat_s6AQR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BTu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6BTv; else goto c6BTw;
       c6BTv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BTw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6AQS_entry() //  [R1]
         { info_tbl: [(c6BTx,
                       label: sat_s6AQS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BTx: // global
           _s6AQS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6BTy; else goto c6BTz;
       c6BTz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BTB; else goto c6BTA;
       c6BTB: // global
           HpAlloc = 32;
           goto c6BTy;
       c6BTy: // global
           R1 = _s6AQS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BTA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AQS::P64;
           _s6AQP::P64 = P64[_s6AQS::P64 + 16];
           _s6AQQ::P64 = P64[_s6AQS::P64 + 24];
           I64[Hp - 24] = sat_s6AQR_info;
           P64[Hp - 8] = _s6AQP::P64;
           P64[Hp] = _s6AQQ::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6BTC,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BTC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BTG; else goto c6BTF;
       c6BTG: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BTF: // global
           I64[Hp - 24] = sat_s6AQS_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowProduct2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.587676937 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowProduct_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowProduct_$cshowList_info;
 },
 sat_s6AQX_entry() //  [R1, R2]
         { info_tbl: [(c6BUa,
                       label: sat_s6AQX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BUa: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec4_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_$cshowList_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c6BUd,
                       label: Data.Semigroup.Internal.$fShowProduct_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BUd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BUh; else goto c6BUg;
       c6BUh: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BUg: // global
           I64[Hp - 8] = sat_s6AQX_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.593724023 UTC

[section ""data" . Data.Semigroup.Internal.$fShowProduct_closure" {
     Data.Semigroup.Internal.$fShowProduct_closure:
         const Data.Semigroup.Internal.$fShowProduct_info;
         const 0;
 },
 sat_s6AR1_entry() //  [R1, R2, R3]
         { info_tbl: [(c6BUz,
                       label: sat_s6AR1_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BUz: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowProduct_$cshowList_entry(R4,
                                                                       R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AR0_entry() //  [R1, R2]
         { info_tbl: [(c6BUH,
                       label: sat_s6AR0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BUH: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowProduct_$cshow_entry(R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AQZ_entry() //  [R1, R2, R3]
         { info_tbl: [(c6BUP,
                       label: sat_s6AQZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BUP: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowProduct_$cshowsPrec_entry(R4,
                                                                        R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowProduct_entry() //  [R2]
         { info_tbl: [(c6BUT,
                       label: Data.Semigroup.Internal.$fShowProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BUT: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6BUX; else goto c6BUW;
       c6BUX: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BUW: // global
           I64[Hp - 72] = sat_s6AR1_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6AR0_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6AQZ_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.602647123 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadProduct5_bytes" {
     Data.Semigroup.Internal.$fReadProduct5_bytes:
         I8[] [80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.604688055 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct4_closure" {
     Data.Semigroup.Internal.$fReadProduct4_closure:
         const Data.Semigroup.Internal.$fReadProduct4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadProduct4_entry() //  [R1]
         { info_tbl: [(c6BVq,
                       label: Data.Semigroup.Internal.$fReadProduct4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BVq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BVr; else goto c6BVs;
       c6BVr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BVs: // global
           (_c6BVn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6BVn::I64 == 0) goto c6BVp; else goto c6BVo;
       c6BVp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6BVo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6BVn::I64;
           R2 = Data.Semigroup.Internal.$fReadProduct5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.609163611 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_lexeme_closure" {
     Data.Semigroup.Internal.$fReadProduct_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadProduct4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.6114572 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadProduct3_bytes" {
     Data.Semigroup.Internal.$fReadProduct3_bytes:
         I8[] [103,101,116,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.613621929 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct2_closure" {
     Data.Semigroup.Internal.$fReadProduct2_closure:
         const Data.Semigroup.Internal.$fReadProduct2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadProduct2_entry() //  [R1]
         { info_tbl: [(c6BVJ,
                       label: Data.Semigroup.Internal.$fReadProduct2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BVJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BVK; else goto c6BVL;
       c6BVK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BVL: // global
           (_c6BVG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6BVG::I64 == 0) goto c6BVI; else goto c6BVH;
       c6BVI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6BVH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6BVG::I64;
           R2 = Data.Semigroup.Internal.$fReadProduct3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.619591933 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct1_closure" {
     Data.Semigroup.Internal.$fReadProduct1_closure:
         const Data.Semigroup.Internal.$fReadProduct1_info;
         const 0;
 },
 lvl12_s6AR3_entry() //  [R1]
         { info_tbl: [(c6BW2,
                       label: lvl12_s6AR3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BW2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6BW3; else goto c6BW4;
       c6BW3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BW4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6AR4_entry() //  [R1]
         { info_tbl: [(c6BWa,
                       label: ds_s6AR4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BWa: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ARf_entry() //  [R1]
         { info_tbl: [(c6BWL,
                       label: sat_s6ARf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BWL: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ARi_entry() //  [R1, R2]
         { info_tbl: [(c6BWR,
                       label: sat_s6ARi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BWR: // global
           _s6ARd::P64 = R2;
           _s6ARi::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6BWS; else goto c6BWT;
       c6BWT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BWV; else goto c6BWU;
       c6BWV: // global
           HpAlloc = 24;
           goto c6BWS;
       c6BWS: // global
           R2 = _s6ARd::P64;
           R1 = _s6ARi::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BWU: // global
           _s6AR7::P64 = P64[_s6ARi::P64 + 7];
           I64[Hp - 16] = sat_s6ARf_info;
           P64[Hp - 8] = _s6AR7::P64;
           P64[Hp] = _s6ARd::P64;
           I64[Sp - 8] = block_c6BWO_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6BWO() //  [R1]
         { info_tbl: [(c6BWO,
                       label: block_c6BWO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BWO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BWY; else goto c6BWX;
       c6BWY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6BWX: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ARj_entry() //  [R1, R2]
         { info_tbl: [(c6BWZ,
                       label: sat_s6ARj_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BWZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BX3; else goto c6BX2;
       c6BX3: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BX2: // global
           _s6AR4::P64 = P64[R1 + 7];
           _s6AR7::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6ARi_info;
           P64[Hp] = _s6AR7::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6AR4::P64;
           R2 = Data.Semigroup.Internal.$fReadProduct2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ARm_entry() //  [R1, R2]
         { info_tbl: [(c6BX7,
                       label: sat_s6ARm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BX7: // global
           _s6ARb::P64 = R2;
           _s6ARm::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6BX8; else goto c6BX9;
       c6BX9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BXb; else goto c6BXa;
       c6BXb: // global
           HpAlloc = 24;
           goto c6BX8;
       c6BX8: // global
           R2 = _s6ARb::P64;
           R1 = _s6ARm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BXa: // global
           _s6AR4::P64 = P64[_s6ARm::P64 + 7];
           _s6AR7::P64 = P64[_s6ARm::P64 + 15];
           I64[Hp - 16] = sat_s6ARj_info;
           P64[Hp - 8] = _s6AR4::P64;
           P64[Hp] = _s6AR7::P64;
           I64[Sp - 8] = block_c6BX4_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6BX4() //  [R1]
         { info_tbl: [(c6BX4,
                       label: block_c6BX4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BX4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BXe; else goto c6BXd;
       c6BXe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6BXd: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ARp_entry() //  [R1, R2, R3]
         { info_tbl: [(c6BXf,
                       label: sat_s6ARp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BXf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6BXg; else goto c6BXh;
       c6BXg: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6BXh: // global
           I64[Sp - 24] = block_c6BWi_info;
           _s6AR4::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6AR4::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6BXu; else goto c6BWj;
       u6BXu: // global
           call _c6BWi(R1) args: 0, res: 0, upd: 0;
       c6BWj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6BWi() //  [R1]
         { info_tbl: [(c6BWi,
                       label: block_c6BWi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BWi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BXk; else goto c6BXj;
       c6BXk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6BXj: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6BXm; else goto c6BXq;
       c6BXm: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6BXq: // global
           I64[Hp - 16] = sat_s6ARm_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6BXn_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadProduct_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6BXn() //  [R1]
         { info_tbl: [(c6BXn,
                       label: block_c6BXn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BXn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6BXt; else goto c6BXs;
       c6BXt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6BXs: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct1_entry() //  [R2]
         { info_tbl: [(c6BXv,
                       label: Data.Semigroup.Internal.$fReadProduct1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BXv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6BXz; else goto c6BXy;
       c6BXz: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BXy: // global
           I64[Hp - 48] = lvl12_s6AR3_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6AR4_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6ARp_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.647924409 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadsPrec_info;
         const 0;
 },
 ds_s6ARr_entry() //  [R1]
         { info_tbl: [(c6BYP,
                       label: ds_s6ARr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BYP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BYQ; else goto c6BYR;
       c6BYQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BYR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARt_entry() //  [R1]
         { info_tbl: [(c6BZ1,
                       label: sat_s6ARt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BZ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6BZ2; else goto c6BZ3;
       c6BZ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6BZ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARu_entry() //  [R1, R2]
         { info_tbl: [(c6BZ4,
                       label: sat_s6ARu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BZ4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6BZ8; else goto c6BZ7;
       c6BZ8: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BZ7: // global
           _s6ARr::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6ARt_info;
           P64[Hp - 8] = _s6ARr::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6BZ9,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BZ9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6BZd; else goto c6BZc;
       c6BZd: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BZc: // global
           I64[Hp - 32] = ds_s6ARr_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6ARu_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.658686994 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadListPrec_info;
         const 0;
 },
 sat_s6ARw_entry() //  [R1]
         { info_tbl: [(c6BZK,
                       label: sat_s6ARw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BZK: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6BZN,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6BZN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6BZR; else goto c6BZQ;
       c6BZR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6BZQ: // global
           I64[Hp - 16] = sat_s6ARw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.664586741 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_$creadList_closure" {
     Data.Semigroup.Internal.$fReadProduct_$creadList_closure:
         const Data.Semigroup.Internal.$fReadProduct_$creadList_info;
         const 0;
 },
 sat_s6ARy_entry() //  [R1]
         { info_tbl: [(c6C0c,
                       label: sat_s6ARy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C0c: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ARz_entry() //  [R1]
         { info_tbl: [(c6C0f,
                       label: sat_s6ARz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C0f: // global
           _s6ARz::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6C0g; else goto c6C0h;
       c6C0h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6C0j; else goto c6C0i;
       c6C0j: // global
           HpAlloc = 24;
           goto c6C0g;
       c6C0g: // global
           R1 = _s6ARz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C0i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6ARz::P64;
           _s6ARx::P64 = P64[_s6ARz::P64 + 16];
           I64[Hp - 16] = sat_s6ARy_info;
           P64[Hp] = _s6ARx::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_$creadList_entry() //  [R2]
         { info_tbl: [(c6C0k,
                       label: Data.Semigroup.Internal.$fReadProduct_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C0k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6C0o; else goto c6C0n;
       c6C0o: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6C0n: // global
           I64[Hp - 16] = sat_s6ARz_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.673195038 UTC

[section ""data" . Data.Semigroup.Internal.$fReadProduct_closure" {
     Data.Semigroup.Internal.$fReadProduct_closure:
         const Data.Semigroup.Internal.$fReadProduct_info;
         const 0;
 },
 sat_s6ARE_entry() //  [R1]
         { info_tbl: [(c6C0Q,
                       label: sat_s6ARE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C0Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C0R; else goto c6C0S;
       c6C0R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C0S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARD_entry() //  [R1]
         { info_tbl: [(c6C0X,
                       label: sat_s6ARD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C0X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C0Y; else goto c6C0Z;
       c6C0Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C0Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARC_entry() //  [R1]
         { info_tbl: [(c6C14,
                       label: sat_s6ARC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C14: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C15; else goto c6C16;
       c6C15: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C16: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARB_entry() //  [R1]
         { info_tbl: [(c6C1b,
                       label: sat_s6ARB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C1b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C1c; else goto c6C1d;
       c6C1c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C1d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadProduct_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadProduct_entry() //  [R2]
         { info_tbl: [(c6C1f,
                       label: Data.Semigroup.Internal.$fReadProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C1f: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6C1j; else goto c6C1i;
       c6C1j: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6C1i: // global
           I64[Hp - 128] = sat_s6ARE_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6ARD_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6ARC_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6ARB_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.685878889 UTC

[section ""data" . Data.Semigroup.Internal.$fEqProduct_closure" {
     Data.Semigroup.Internal.$fEqProduct_closure:
         const Data.Semigroup.Internal.$fEqProduct_info;
 },
 sat_s6ARH_entry() //  [R1]
         { info_tbl: [(c6C20,
                       label: sat_s6ARH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C20: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C21; else goto c6C22;
       c6C21: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C22: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARG_entry() //  [R1]
         { info_tbl: [(c6C27,
                       label: sat_s6ARG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C27: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C28; else goto c6C29;
       c6C28: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C29: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqProduct_entry() //  [R2]
         { info_tbl: [(c6C2b,
                       label: Data.Semigroup.Internal.$fEqProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C2b: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6C2f; else goto c6C2e;
       c6C2f: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6C2e: // global
           I64[Hp - 64] = sat_s6ARH_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6ARG_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.694454228 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_info;
 },
 sat_s6ARJ_entry() //  [R1]
         { info_tbl: [(c6C2I,
                       label: sat_s6ARJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C2I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C2J; else goto c6C2K;
       c6C2J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C2K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6C2L,
                       label: Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C2L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6C2P; else goto c6C2O;
       c6C2P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6C2O: // global
           I64[Hp - 16] = sat_s6ARJ_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqProduct_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.702483323 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdProduct_closure" {
     Data.Semigroup.Internal.$fOrdProduct_closure:
         const Data.Semigroup.Internal.$fOrdProduct_info;
 },
 sat_s6ARS_entry() //  [R1]
         { info_tbl: [(c6C38,
                       label: sat_s6ARS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C38: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C39; else goto c6C3a;
       c6C39: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C3a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARR_entry() //  [R1]
         { info_tbl: [(c6C3f,
                       label: sat_s6ARR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C3f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C3g; else goto c6C3h;
       c6C3g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C3h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARQ_entry() //  [R1]
         { info_tbl: [(c6C3m,
                       label: sat_s6ARQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C3m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C3n; else goto c6C3o;
       c6C3n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C3o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARP_entry() //  [R1]
         { info_tbl: [(c6C3t,
                       label: sat_s6ARP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C3t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C3u; else goto c6C3v;
       c6C3u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C3v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARO_entry() //  [R1]
         { info_tbl: [(c6C3A,
                       label: sat_s6ARO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C3A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C3B; else goto c6C3C;
       c6C3B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C3C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARN_entry() //  [R1]
         { info_tbl: [(c6C3H,
                       label: sat_s6ARN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C3H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C3I; else goto c6C3J;
       c6C3I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C3J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARM_entry() //  [R1]
         { info_tbl: [(c6C3O,
                       label: sat_s6ARM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C3O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C3P; else goto c6C3Q;
       c6C3P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C3Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARL_entry() //  [R1]
         { info_tbl: [(c6C3V,
                       label: sat_s6ARL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C3V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C3W; else goto c6C3X;
       c6C3W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C3X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdProduct_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdProduct_entry() //  [R2]
         { info_tbl: [(c6C3Z,
                       label: Data.Semigroup.Internal.$fOrdProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C3Z: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6C43; else goto c6C42;
       c6C43: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdProduct_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6C42: // global
           I64[Hp - 256] = sat_s6ARS_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6ARR_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6ARQ_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6ARP_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6ARO_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6ARN_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6ARM_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6ARL_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.724813968 UTC

[section ""data" . Data.Semigroup.Internal.$fNumSum_closure" {
     Data.Semigroup.Internal.$fNumSum_closure:
         const Data.Semigroup.Internal.$fNumSum_info;
 },
 sat_s6AS0_entry() //  [R1]
         { info_tbl: [(c6C5c,
                       label: sat_s6AS0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C5c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C5d; else goto c6C5e;
       c6C5d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C5e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARZ_entry() //  [R1]
         { info_tbl: [(c6C5j,
                       label: sat_s6ARZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C5j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C5k; else goto c6C5l;
       c6C5k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C5l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.signum_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARY_entry() //  [R1]
         { info_tbl: [(c6C5q,
                       label: sat_s6ARY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C5q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C5r; else goto c6C5s;
       c6C5r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C5s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.abs_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARX_entry() //  [R1]
         { info_tbl: [(c6C5x,
                       label: sat_s6ARX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C5x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C5y; else goto c6C5z;
       c6C5y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C5z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.negate_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARW_entry() //  [R1]
         { info_tbl: [(c6C5E,
                       label: sat_s6ARW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C5E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C5F; else goto c6C5G;
       c6C5F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C5G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARV_entry() //  [R1]
         { info_tbl: [(c6C5L,
                       label: sat_s6ARV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C5L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C5M; else goto c6C5N;
       c6C5M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C5N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.-_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ARU_entry() //  [R1]
         { info_tbl: [(c6C5S,
                       label: sat_s6ARU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C5S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C5T; else goto c6C5U;
       c6C5T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C5U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fNumSum_entry() //  [R2]
         { info_tbl: [(c6C5W,
                       label: Data.Semigroup.Internal.$fNumSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C5W: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto c6C60; else goto c6C5Z;
       c6C60: // global
           HpAlloc = 232;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fNumSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6C5Z: // global
           I64[Hp - 224] = sat_s6AS0_info;
           P64[Hp - 208] = R2;
           I64[Hp - 200] = sat_s6ARZ_info;
           P64[Hp - 184] = R2;
           I64[Hp - 176] = sat_s6ARY_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s6ARX_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s6ARW_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6ARV_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6ARU_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = GHC.Num.C:Num_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = Hp - 104;
           P64[Hp - 32] = Hp - 128;
           P64[Hp - 24] = Hp - 152;
           P64[Hp - 16] = Hp - 176;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 224;
           R1 = Hp - 55;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.745204974 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum1_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum1_closure:
         const Data.Semigroup.Internal.$fGeneric1Sum1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Sum1_entry() //  [R2]
         { info_tbl: [(c6C6Y,
                       label: Data.Semigroup.Internal.$fGeneric1Sum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C6Y: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.749120365 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum2_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum2_closure:
         const Data.Semigroup.Internal.$fGeneric1Sum2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Sum2_entry() //  [R2]
         { info_tbl: [(c6C79,
                       label: Data.Semigroup.Internal.$fGeneric1Sum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C79: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.752735661 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Sum_closure" {
     Data.Semigroup.Internal.$fGeneric1Sum_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Sum2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Sum1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.755123259 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum1_closure" {
     Data.Semigroup.Internal.$fGenericSum1_closure:
         const Data.Semigroup.Internal.$fGenericSum1_info;
 },
 Data.Semigroup.Internal.$fGenericSum1_entry() //  [R2]
         { info_tbl: [(c6C7l,
                       label: Data.Semigroup.Internal.$fGenericSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C7l: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.758982465 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum2_closure" {
     Data.Semigroup.Internal.$fGenericSum2_closure:
         const Data.Semigroup.Internal.$fGenericSum2_info;
 },
 Data.Semigroup.Internal.$fGenericSum2_entry() //  [R2]
         { info_tbl: [(c6C7w,
                       label: Data.Semigroup.Internal.$fGenericSum2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C7w: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.762620004 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericSum_closure" {
     Data.Semigroup.Internal.$fGenericSum_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericSum2_closure+1;
         const Data.Semigroup.Internal.$fGenericSum1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.765075408 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedSum_closure" {
     Data.Semigroup.Internal.$fBoundedSum_closure:
         const Data.Semigroup.Internal.$fBoundedSum_info;
 },
 sat_s6AS7_entry() //  [R1]
         { info_tbl: [(c6C7M,
                       label: sat_s6AS7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C7M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C7N; else goto c6C7O;
       c6C7N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C7O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AS6_entry() //  [R1]
         { info_tbl: [(c6C7T,
                       label: sat_s6AS6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C7T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C7U; else goto c6C7V;
       c6C7U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C7V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedSum_entry() //  [R2]
         { info_tbl: [(c6C7X,
                       label: Data.Semigroup.Internal.$fBoundedSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C7X: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6C81; else goto c6C80;
       c6C81: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6C80: // global
           I64[Hp - 64] = sat_s6AS7_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6AS6_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.774341837 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowSum2_bytes" {
     Data.Semigroup.Internal.$fShowSum2_bytes:
         I8[] [83,117,109,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.776457375 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowSum1_bytes" {
     Data.Semigroup.Internal.$fShowSum1_bytes:
         I8[] [103,101,116,83,117,109,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.780676061 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec5_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec5_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec5_info;
 },
 f_s6ASb_entry() //  [R1]
         { info_tbl: [(c6C8w,
                       label: f_s6ASb_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C8w: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6C8x; else goto c6C8y;
       c6C8x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C8y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6ASe_entry() //  [R1]
         { info_tbl: [(c6C8T,
                       label: sat_s6ASe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C8T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6C8U; else goto c6C8V;
       c6C8U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C8V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ASf_entry() //  [R1]
         { info_tbl: [(c6C8W,
                       label: sat_s6ASf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C8W: // global
           _s6ASf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6C8X; else goto c6C8Y;
       c6C8Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6C90; else goto c6C8Z;
       c6C90: // global
           HpAlloc = 24;
           goto c6C8X;
       c6C8X: // global
           R1 = _s6ASf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C8Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6ASf::P64;
           _s6ASb::P64 = P64[_s6ASf::P64 + 16];
           _s6ASd::P64 = P64[_s6ASf::P64 + 24];
           I64[Hp - 16] = sat_s6ASe_info;
           P64[Hp] = _s6ASd::P64;
           R2 = Hp - 16;
           R1 = _s6ASb::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ASg_entry() //  [R1]
         { info_tbl: [(c6C91,
                       label: sat_s6ASg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C91: // global
           _s6ASg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6C92; else goto c6C93;
       c6C93: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6C95; else goto c6C94;
       c6C95: // global
           HpAlloc = 32;
           goto c6C92;
       c6C92: // global
           R1 = _s6ASg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C94: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6ASg::P64;
           _s6ASb::P64 = P64[_s6ASg::P64 + 16];
           _s6ASd::P64 = P64[_s6ASg::P64 + 24];
           I64[Hp - 24] = sat_s6ASf_info;
           P64[Hp - 8] = _s6ASb::P64;
           P64[Hp] = _s6ASd::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ASh_entry() //  [R1, R2]
         { info_tbl: [(c6C96,
                       label: sat_s6ASh_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C96: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6C9a; else goto c6C99;
       c6C9a: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6C99: // global
           _s6ASb::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6ASg_info;
           P64[Hp - 8] = _s6ASb::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ASk_entry() //  [R1]
         { info_tbl: [(c6C9y,
                       label: sat_s6ASk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C9y: // global
           _s6ASk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6C9z; else goto c6C9A;
       c6C9A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6C9C; else goto c6C9B;
       c6C9C: // global
           HpAlloc = 24;
           goto c6C9z;
       c6C9z: // global
           R1 = _s6ASk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C9B: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6ASk::P64;
           _s6ASi::P64 = P64[_s6ASk::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6ASi::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ASl_entry() //  [R1]
         { info_tbl: [(c6C9D,
                       label: sat_s6ASl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C9D: // global
           _s6ASl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6C9E; else goto c6C9F;
       c6C9F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6C9H; else goto c6C9G;
       c6C9H: // global
           HpAlloc = 24;
           goto c6C9E;
       c6C9E: // global
           R1 = _s6ASl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C9G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6ASl::P64;
           _s6ASb::P64 = P64[_s6ASl::P64 + 16];
           _s6ASi::P64 = P64[_s6ASl::P64 + 24];
           I64[Hp - 16] = sat_s6ASk_info;
           P64[Hp] = _s6ASi::P64;
           R2 = Hp - 16;
           R1 = _s6ASb::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ASm_entry() //  [R1]
         { info_tbl: [(c6C9I,
                       label: sat_s6ASm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C9I: // global
           _s6ASm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6C9J; else goto c6C9K;
       c6C9K: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6C9M; else goto c6C9L;
       c6C9M: // global
           HpAlloc = 32;
           goto c6C9J;
       c6C9J: // global
           R1 = _s6ASm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C9L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6ASm::P64;
           _s6ASb::P64 = P64[_s6ASm::P64 + 16];
           _s6ASi::P64 = P64[_s6ASm::P64 + 24];
           I64[Hp - 24] = sat_s6ASl_info;
           P64[Hp - 8] = _s6ASb::P64;
           P64[Hp] = _s6ASi::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ASn_entry() //  [R1]
         { info_tbl: [(c6C9N,
                       label: sat_s6ASn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C9N: // global
           _s6ASn::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6C9O; else goto c6C9P;
       c6C9P: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6C9R; else goto c6C9Q;
       c6C9R: // global
           HpAlloc = 32;
           goto c6C9O;
       c6C9O: // global
           R1 = _s6ASn::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6C9Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6ASn::P64;
           _s6ASb::P64 = P64[_s6ASn::P64 + 16];
           _s6ASi::P64 = P64[_s6ASn::P64 + 24];
           I64[Hp - 24] = sat_s6ASm_info;
           P64[Hp - 8] = _s6ASb::P64;
           P64[Hp] = _s6ASi::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ASo_entry() //  [R1, R2]
         { info_tbl: [(c6C9T,
                       label: sat_s6ASo_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6C9T: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6C9X; else goto c6C9W;
       c6C9X: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6C9W: // global
           _s6ASb::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6ASn_info;
           P64[Hp - 32] = _s6ASb::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec5_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Ca1,
                       label: Data.Semigroup.Internal.$w$cshowsPrec5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ca1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Ca5; else goto c6Ca4;
       c6Ca5: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Ca4: // global
           I64[Hp - 40] = f_s6ASb_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6C8s::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6C9Z; else goto c6Ca0;
       c6C9Z: // global
           I64[Hp - 8] = sat_s6ASh_info;
           P64[Hp] = _c6C8s::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Ca0: // global
           I64[Hp - 8] = sat_s6ASo_info;
           P64[Hp] = _c6C8s::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.81075518 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowSum_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6Cbm,
                       label: Data.Semigroup.Internal.$fShowSum_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cbm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Cbn; else goto c6Cbo;
       c6Cbn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Cbo: // global
           I64[Sp - 24] = block_c6Cbj_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6Cbs; else goto c6Cbk;
       u6Cbs: // global
           call _c6Cbj(R1) args: 0, res: 0, upd: 0;
       c6Cbk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Cbj() //  [R1]
         { info_tbl: [(c6Cbj,
                       label: block_c6Cbj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cbj: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.98515614 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshow_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshow_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshow_info;
         const 0;
 },
 sat_s6ASw_entry() //  [R1]
         { info_tbl: [(c6CbP,
                       label: sat_s6ASw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CbP: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6CbQ; else goto c6CbR;
       c6CbQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CbR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6ASx_entry() //  [R1]
         { info_tbl: [(c6CbS,
                       label: sat_s6ASx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CbS: // global
           _s6ASx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6CbT; else goto c6CbU;
       c6CbU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CbW; else goto c6CbV;
       c6CbW: // global
           HpAlloc = 32;
           goto c6CbT;
       c6CbT: // global
           R1 = _s6ASx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CbV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6ASx::P64;
           _s6ASu::P64 = P64[_s6ASx::P64 + 16];
           _s6ASv::P64 = P64[_s6ASx::P64 + 24];
           I64[Hp - 24] = sat_s6ASw_info;
           P64[Hp - 8] = _s6ASu::P64;
           P64[Hp] = _s6ASv::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowSum_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6CbX,
                       label: Data.Semigroup.Internal.$fShowSum_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CbX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Cc1; else goto c6Cc0;
       c6Cc1: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Cc0: // global
           I64[Hp - 24] = sat_s6ASx_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowSum2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:54.994378182 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowSum_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowSum_$cshowList_info;
 },
 sat_s6ASC_entry() //  [R1, R2]
         { info_tbl: [(c6Ccv,
                       label: sat_s6ASC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ccv: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec5_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowSum_$cshowList_entry() //  [R2, R3,
                                                           R4]
         { info_tbl: [(c6Ccy,
                       label: Data.Semigroup.Internal.$fShowSum_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ccy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CcC; else goto c6CcB;
       c6CcC: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CcB: // global
           I64[Hp - 8] = sat_s6ASC_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.000338131 UTC

[section ""data" . Data.Semigroup.Internal.$fShowSum_closure" {
     Data.Semigroup.Internal.$fShowSum_closure:
         const Data.Semigroup.Internal.$fShowSum_info;
         const 0;
 },
 sat_s6ASG_entry() //  [R1, R2, R3]
         { info_tbl: [(c6CcU,
                       label: sat_s6ASG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CcU: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowSum_$cshowList_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ASF_entry() //  [R1, R2]
         { info_tbl: [(c6Cd2,
                       label: sat_s6ASF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cd2: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowSum_$cshow_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ASE_entry() //  [R1, R2, R3]
         { info_tbl: [(c6Cda,
                       label: sat_s6ASE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cda: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowSum_$cshowsPrec_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowSum_entry() //  [R2]
         { info_tbl: [(c6Cde,
                       label: Data.Semigroup.Internal.$fShowSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cde: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6Cdi; else goto c6Cdh;
       c6Cdi: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cdh: // global
           I64[Hp - 72] = sat_s6ASG_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6ASF_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6ASE_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.008987596 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadSum5_bytes" {
     Data.Semigroup.Internal.$fReadSum5_bytes:
         I8[] [83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.011072958 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum4_closure" {
     Data.Semigroup.Internal.$fReadSum4_closure:
         const Data.Semigroup.Internal.$fReadSum4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadSum4_entry() //  [R1]
         { info_tbl: [(c6CdL,
                       label: Data.Semigroup.Internal.$fReadSum4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CdL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CdM; else goto c6CdN;
       c6CdM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CdN: // global
           (_c6CdI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CdI::I64 == 0) goto c6CdK; else goto c6CdJ;
       c6CdK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CdJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CdI::I64;
           R2 = Data.Semigroup.Internal.$fReadSum5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.015209005 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_lexeme_closure" {
     Data.Semigroup.Internal.$fReadSum_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadSum4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.016973172 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadSum3_bytes" {
     Data.Semigroup.Internal.$fReadSum3_bytes:
         I8[] [103,101,116,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.019917478 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum2_closure" {
     Data.Semigroup.Internal.$fReadSum2_closure:
         const Data.Semigroup.Internal.$fReadSum2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadSum2_entry() //  [R1]
         { info_tbl: [(c6Ce4,
                       label: Data.Semigroup.Internal.$fReadSum2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ce4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ce5; else goto c6Ce6;
       c6Ce5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ce6: // global
           (_c6Ce1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Ce1::I64 == 0) goto c6Ce3; else goto c6Ce2;
       c6Ce3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Ce2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Ce1::I64;
           R2 = Data.Semigroup.Internal.$fReadSum3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.026146393 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum1_closure" {
     Data.Semigroup.Internal.$fReadSum1_closure:
         const Data.Semigroup.Internal.$fReadSum1_info;
         const 0;
 },
 lvl12_s6ASI_entry() //  [R1]
         { info_tbl: [(c6Cen,
                       label: lvl12_s6ASI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cen: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Ceo; else goto c6Cep;
       c6Ceo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cep: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6ASJ_entry() //  [R1]
         { info_tbl: [(c6Cev,
                       label: ds_s6ASJ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cev: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ASU_entry() //  [R1]
         { info_tbl: [(c6Cf6,
                       label: sat_s6ASU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cf6: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ASX_entry() //  [R1, R2]
         { info_tbl: [(c6Cfc,
                       label: sat_s6ASX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cfc: // global
           _s6ASS::P64 = R2;
           _s6ASX::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6Cfd; else goto c6Cfe;
       c6Cfe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Cfg; else goto c6Cff;
       c6Cfg: // global
           HpAlloc = 24;
           goto c6Cfd;
       c6Cfd: // global
           R2 = _s6ASS::P64;
           R1 = _s6ASX::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cff: // global
           _s6ASM::P64 = P64[_s6ASX::P64 + 7];
           I64[Hp - 16] = sat_s6ASU_info;
           P64[Hp - 8] = _s6ASM::P64;
           P64[Hp] = _s6ASS::P64;
           I64[Sp - 8] = block_c6Cf9_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Cf9() //  [R1]
         { info_tbl: [(c6Cf9,
                       label: block_c6Cf9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cf9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Cfj; else goto c6Cfi;
       c6Cfj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Cfi: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ASY_entry() //  [R1, R2]
         { info_tbl: [(c6Cfk,
                       label: sat_s6ASY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cfk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Cfo; else goto c6Cfn;
       c6Cfo: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cfn: // global
           _s6ASJ::P64 = P64[R1 + 7];
           _s6ASM::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6ASX_info;
           P64[Hp] = _s6ASM::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6ASJ::P64;
           R2 = Data.Semigroup.Internal.$fReadSum2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AT1_entry() //  [R1, R2]
         { info_tbl: [(c6Cfs,
                       label: sat_s6AT1_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cfs: // global
           _s6ASQ::P64 = R2;
           _s6AT1::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6Cft; else goto c6Cfu;
       c6Cfu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Cfw; else goto c6Cfv;
       c6Cfw: // global
           HpAlloc = 24;
           goto c6Cft;
       c6Cft: // global
           R2 = _s6ASQ::P64;
           R1 = _s6AT1::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cfv: // global
           _s6ASJ::P64 = P64[_s6AT1::P64 + 7];
           _s6ASM::P64 = P64[_s6AT1::P64 + 15];
           I64[Hp - 16] = sat_s6ASY_info;
           P64[Hp - 8] = _s6ASJ::P64;
           P64[Hp] = _s6ASM::P64;
           I64[Sp - 8] = block_c6Cfp_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Cfp() //  [R1]
         { info_tbl: [(c6Cfp,
                       label: block_c6Cfp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cfp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Cfz; else goto c6Cfy;
       c6Cfz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Cfy: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AT4_entry() //  [R1, R2, R3]
         { info_tbl: [(c6CfA,
                       label: sat_s6AT4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CfA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6CfB; else goto c6CfC;
       c6CfB: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CfC: // global
           I64[Sp - 24] = block_c6CeD_info;
           _s6ASJ::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6ASJ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6CfP; else goto c6CeE;
       u6CfP: // global
           call _c6CeD(R1) args: 0, res: 0, upd: 0;
       c6CeE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6CeD() //  [R1]
         { info_tbl: [(c6CeD,
                       label: block_c6CeD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CeD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CfF; else goto c6CfE;
       c6CfF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6CfE: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6CfH; else goto c6CfL;
       c6CfH: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6CfL: // global
           I64[Hp - 16] = sat_s6AT1_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6CfI_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadSum_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6CfI() //  [R1]
         { info_tbl: [(c6CfI,
                       label: block_c6CfI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CfI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CfO; else goto c6CfN;
       c6CfO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6CfN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum1_entry() //  [R2]
         { info_tbl: [(c6CfQ,
                       label: Data.Semigroup.Internal.$fReadSum1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CfQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6CfU; else goto c6CfT;
       c6CfU: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CfT: // global
           I64[Hp - 48] = lvl12_s6ASI_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6ASJ_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6AT4_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.061267176 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadsPrec_info;
         const 0;
 },
 ds_s6AT6_entry() //  [R1]
         { info_tbl: [(c6Cha,
                       label: ds_s6AT6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cha: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Chb; else goto c6Chc;
       c6Chb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Chc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AT8_entry() //  [R1]
         { info_tbl: [(c6Chm,
                       label: sat_s6AT8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Chm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Chn; else goto c6Cho;
       c6Chn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cho: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AT9_entry() //  [R1, R2]
         { info_tbl: [(c6Chp,
                       label: sat_s6AT9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Chp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Cht; else goto c6Chs;
       c6Cht: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Chs: // global
           _s6AT6::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6AT8_info;
           P64[Hp - 8] = _s6AT6::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6Chu,
                       label: Data.Semigroup.Internal.$fReadSum_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Chu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6Chy; else goto c6Chx;
       c6Chy: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Chx: // global
           I64[Hp - 32] = ds_s6AT6_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6AT9_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.077670093 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadListPrec_info;
         const 0;
 },
 sat_s6ATb_entry() //  [R1]
         { info_tbl: [(c6Ci5,
                       label: sat_s6ATb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ci5: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6Ci8,
                       label: Data.Semigroup.Internal.$fReadSum_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ci8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Cic; else goto c6Cib;
       c6Cic: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cib: // global
           I64[Hp - 16] = sat_s6ATb_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.086086344 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_$creadList_closure" {
     Data.Semigroup.Internal.$fReadSum_$creadList_closure:
         const Data.Semigroup.Internal.$fReadSum_$creadList_info;
         const 0;
 },
 sat_s6ATd_entry() //  [R1]
         { info_tbl: [(c6Cix,
                       label: sat_s6ATd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cix: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ATe_entry() //  [R1]
         { info_tbl: [(c6CiA,
                       label: sat_s6ATe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CiA: // global
           _s6ATe::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6CiB; else goto c6CiC;
       c6CiC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CiE; else goto c6CiD;
       c6CiE: // global
           HpAlloc = 24;
           goto c6CiB;
       c6CiB: // global
           R1 = _s6ATe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CiD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6ATe::P64;
           _s6ATc::P64 = P64[_s6ATe::P64 + 16];
           I64[Hp - 16] = sat_s6ATd_info;
           P64[Hp] = _s6ATc::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadSum_$creadList_entry() //  [R2]
         { info_tbl: [(c6CiF,
                       label: Data.Semigroup.Internal.$fReadSum_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CiF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CiJ; else goto c6CiI;
       c6CiJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CiI: // global
           I64[Hp - 16] = sat_s6ATe_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.099076009 UTC

[section ""data" . Data.Semigroup.Internal.$fReadSum_closure" {
     Data.Semigroup.Internal.$fReadSum_closure:
         const Data.Semigroup.Internal.$fReadSum_info;
         const 0;
 },
 sat_s6ATj_entry() //  [R1]
         { info_tbl: [(c6Cjb,
                       label: sat_s6ATj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cjb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cjc; else goto c6Cjd;
       c6Cjc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cjd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATi_entry() //  [R1]
         { info_tbl: [(c6Cji,
                       label: sat_s6ATi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cji: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cjj; else goto c6Cjk;
       c6Cjj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cjk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATh_entry() //  [R1]
         { info_tbl: [(c6Cjp,
                       label: sat_s6ATh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cjp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cjq; else goto c6Cjr;
       c6Cjq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cjr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATg_entry() //  [R1]
         { info_tbl: [(c6Cjw,
                       label: sat_s6ATg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cjw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cjx; else goto c6Cjy;
       c6Cjx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cjy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadSum_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadSum_entry() //  [R2]
         { info_tbl: [(c6CjA,
                       label: Data.Semigroup.Internal.$fReadSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CjA: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6CjE; else goto c6CjD;
       c6CjE: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CjD: // global
           I64[Hp - 128] = sat_s6ATj_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6ATi_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6ATh_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6ATg_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.115953059 UTC

[section ""data" . Data.Semigroup.Internal.$fEqSum_closure" {
     Data.Semigroup.Internal.$fEqSum_closure:
         const Data.Semigroup.Internal.$fEqSum_info;
 },
 sat_s6ATm_entry() //  [R1]
         { info_tbl: [(c6Ckl,
                       label: sat_s6ATm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ckl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ckm; else goto c6Ckn;
       c6Ckm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Ckn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATl_entry() //  [R1]
         { info_tbl: [(c6Cks,
                       label: sat_s6ATl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cks: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Ckt; else goto c6Cku;
       c6Ckt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cku: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqSum_entry() //  [R2]
         { info_tbl: [(c6Ckw,
                       label: Data.Semigroup.Internal.$fEqSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ckw: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6CkA; else goto c6Ckz;
       c6CkA: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Ckz: // global
           I64[Hp - 64] = sat_s6ATm_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6ATl_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.124030056 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdSum_$cp1Ord_info;
 },
 sat_s6ATo_entry() //  [R1]
         { info_tbl: [(c6Cl3,
                       label: sat_s6ATo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cl3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cl4; else goto c6Cl5;
       c6Cl4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cl5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdSum_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6Cl6,
                       label: Data.Semigroup.Internal.$fOrdSum_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cl6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Cla; else goto c6Cl9;
       c6Cla: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdSum_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cl9: // global
           I64[Hp - 16] = sat_s6ATo_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqSum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.131250728 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdSum_closure" {
     Data.Semigroup.Internal.$fOrdSum_closure:
         const Data.Semigroup.Internal.$fOrdSum_info;
 },
 sat_s6ATx_entry() //  [R1]
         { info_tbl: [(c6Clt,
                       label: sat_s6ATx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Clt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Clu; else goto c6Clv;
       c6Clu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Clv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATw_entry() //  [R1]
         { info_tbl: [(c6ClA,
                       label: sat_s6ATw_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ClA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ClB; else goto c6ClC;
       c6ClB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ClC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATv_entry() //  [R1]
         { info_tbl: [(c6ClH,
                       label: sat_s6ATv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ClH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ClI; else goto c6ClJ;
       c6ClI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ClJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATu_entry() //  [R1]
         { info_tbl: [(c6ClO,
                       label: sat_s6ATu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ClO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ClP; else goto c6ClQ;
       c6ClP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ClQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATt_entry() //  [R1]
         { info_tbl: [(c6ClV,
                       label: sat_s6ATt_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6ClV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6ClW; else goto c6ClX;
       c6ClW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6ClX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATs_entry() //  [R1]
         { info_tbl: [(c6Cm2,
                       label: sat_s6ATs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cm2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cm3; else goto c6Cm4;
       c6Cm3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cm4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATr_entry() //  [R1]
         { info_tbl: [(c6Cm9,
                       label: sat_s6ATr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cm9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cma; else goto c6Cmb;
       c6Cma: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cmb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATq_entry() //  [R1]
         { info_tbl: [(c6Cmg,
                       label: sat_s6ATq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cmg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cmh; else goto c6Cmi;
       c6Cmh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cmi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdSum_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdSum_entry() //  [R2]
         { info_tbl: [(c6Cmk,
                       label: Data.Semigroup.Internal.$fOrdSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cmk: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6Cmo; else goto c6Cmn;
       c6Cmo: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdSum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cmn: // global
           I64[Hp - 256] = sat_s6ATx_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6ATw_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6ATv_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6ATu_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6ATt_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6ATs_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6ATr_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6ATq_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.150096611 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny1_closure" {
     Data.Semigroup.Internal.$fGenericAny1_closure:
         const Data.Semigroup.Internal.$fGenericAny1_info;
 },
 Data.Semigroup.Internal.$fGenericAny1_entry() //  [R2]
         { info_tbl: [(c6Cnt,
                       label: Data.Semigroup.Internal.$fGenericAny1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cnt: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.153935877 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny2_closure" {
     Data.Semigroup.Internal.$fGenericAny2_closure:
         const Data.Semigroup.Internal.$fGenericAny2_info;
 },
 Data.Semigroup.Internal.$fGenericAny2_entry() //  [R2]
         { info_tbl: [(c6CnE,
                       label: Data.Semigroup.Internal.$fGenericAny2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CnE: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.157333273 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAny_closure" {
     Data.Semigroup.Internal.$fGenericAny_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAny2_closure+1;
         const Data.Semigroup.Internal.$fGenericAny1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.159059744 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedAny_closure" {
     Data.Semigroup.Internal.$fBoundedAny_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.160735045 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAny4_bytes" {
     Data.Semigroup.Internal.$fShowAny4_bytes:
         I8[] [65,110,121,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.16323667 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny3_closure" {
     Data.Semigroup.Internal.$fShowAny3_closure:
         const Data.Semigroup.Internal.$fShowAny3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny3_entry() //  [R1]
         { info_tbl: [(c6CnW,
                       label: Data.Semigroup.Internal.$fShowAny3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CnW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CnX; else goto c6CnY;
       c6CnX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CnY: // global
           (_c6CnT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CnT::I64 == 0) goto c6CnV; else goto c6CnU;
       c6CnV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CnU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CnT::I64;
           R2 = Data.Semigroup.Internal.$fShowAny4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.167595836 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAny2_bytes" {
     Data.Semigroup.Internal.$fShowAny2_bytes:
         I8[] [103,101,116,65,110,121,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.171391701 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec2_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec2_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec2_info;
         const 0;
 },
 sat_s6ATF_entry() //  [R1]
         { info_tbl: [(c6Cow,
                       label: sat_s6ATF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cow: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ATG_entry() //  [R1]
         { info_tbl: [(c6CoF,
                       label: sat_s6ATG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CoF: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ATH_entry() //  [R1]
         { info_tbl: [(c6CoM,
                       label: sat_s6ATH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CoM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6CoN; else goto c6CoO;
       c6CoN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CoO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6Con_info;
           _s6ATC::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6ATC::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6CoV; else goto c6Coo;
       u6CoV: // global
           call _c6Con(R1) args: 0, res: 0, upd: 0;
       c6Coo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6Con() //  [R1]
         { info_tbl: [(c6Con,
                       label: block_c6Con_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Con: // global
           _s6ATC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6CoJ; else goto c6CoK;
       c6CoJ: // global
           Hp = Hp + 24;
           _s6ATE::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CoU; else goto c6CoQ;
       c6CoQ: // global
           I64[Hp - 16] = sat_s6ATF_info;
           P64[Hp] = _s6ATC::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6CoK: // global
           Hp = Hp + 24;
           _s6ATE::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CoU; else goto c6CoT;
       c6CoU: // global
           HpAlloc = 24;
           R1 = _s6ATE::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6CoT: // global
           I64[Hp - 16] = sat_s6ATG_info;
           P64[Hp] = _s6ATC::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATI_entry() //  [R1]
         { info_tbl: [(c6CoW,
                       label: sat_s6ATI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CoW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Cp0; else goto c6CoZ;
       c6Cp0: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CoZ: // global
           _s6ATB::P64 = P64[R1 + 16];
           _s6ATC::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6ATH_info;
           P64[Hp - 8] = _s6ATB::P64;
           P64[Hp] = _s6ATC::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ATL_entry() //  [R1]
         { info_tbl: [(c6Cpo,
                       label: sat_s6ATL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cpo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Cps; else goto c6Cpr;
       c6Cps: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cpr: // global
           _s6ATC::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6ATC::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ATN_entry() //  [R1]
         { info_tbl: [(c6CpA,
                       label: sat_s6ATN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CpA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CpE; else goto c6CpD;
       c6CpE: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CpD: // global
           _s6ATC::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6ATC::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ATO_entry() //  [R1]
         { info_tbl: [(c6CpJ,
                       label: sat_s6ATO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CpJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6CpK; else goto c6CpL;
       c6CpK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CpL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6Cpe_info;
           _s6ATC::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6ATC::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6CpS; else goto c6Cpf;
       u6CpS: // global
           call _c6Cpe(R1) args: 0, res: 0, upd: 0;
       c6Cpf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6Cpe() //  [R1]
         { info_tbl: [(c6Cpe,
                       label: block_c6Cpe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cpe: // global
           _s6ATC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6CpG; else goto c6CpH;
       c6CpG: // global
           Hp = Hp + 24;
           _s6ATJ::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CpR; else goto c6CpN;
       c6CpN: // global
           I64[Hp - 16] = sat_s6ATL_info;
           P64[Hp] = _s6ATC::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6CpH: // global
           Hp = Hp + 24;
           _s6ATJ::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CpR; else goto c6CpQ;
       c6CpR: // global
           HpAlloc = 24;
           R1 = _s6ATJ::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6CpQ: // global
           I64[Hp - 16] = sat_s6ATN_info;
           P64[Hp] = _s6ATC::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATP_entry() //  [R1]
         { info_tbl: [(c6CpT,
                       label: sat_s6ATP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CpT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CpX; else goto c6CpW;
       c6CpX: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CpW: // global
           _s6ATB::P64 = P64[R1 + 16];
           _s6ATC::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6ATO_info;
           P64[Hp - 8] = _s6ATB::P64;
           P64[Hp] = _s6ATC::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6ATQ_entry() //  [R1]
         { info_tbl: [(c6CpY,
                       label: sat_s6ATQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CpY: // global
           _s6ATQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6CpZ; else goto c6Cq0;
       c6Cq0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Cq2; else goto c6Cq1;
       c6Cq2: // global
           HpAlloc = 32;
           goto c6CpZ;
       c6CpZ: // global
           R1 = _s6ATQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cq1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6ATQ::P64;
           _s6ATB::P64 = P64[_s6ATQ::P64 + 16];
           _s6ATC::P64 = P64[_s6ATQ::P64 + 24];
           I64[Hp - 24] = sat_s6ATP_info;
           P64[Hp - 8] = _s6ATB::P64;
           P64[Hp] = _s6ATC::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec2_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Cq6,
                       label: Data.Semigroup.Internal.$w$cshowsPrec2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cq6: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6Cqa; else goto c6Cq9;
       c6Cqa: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Cq9: // global
           if (%MO_S_Lt_W64(R2, 11)) goto c6Cq4; else goto c6Cq5;
       c6Cq4: // global
           I64[Hp - 48] = sat_s6ATI_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _c6Cof::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c6Cof::P64;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6Cq5: // global
           I64[Hp - 48] = sat_s6ATQ_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.198863473 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6Crp,
                       label: Data.Semigroup.Internal.$fShowAny_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Crp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Crq; else goto c6Crr;
       c6Crq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Crr: // global
           I64[Sp - 24] = block_c6Crm_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6Crv; else goto c6Crn;
       u6Crv: // global
           call _c6Crm(R1) args: 0, res: 0, upd: 0;
       c6Crn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Crm() //  [R1]
         { info_tbl: [(c6Crm,
                       label: block_c6Crm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Crm: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec2_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.205280308 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll6_closure" {
     Data.Semigroup.Internal.$fShowAll6_closure:
         const Data.Semigroup.Internal.$fShowAll6_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll6_entry() //  [R1]
         { info_tbl: [(c6CrM,
                       label: Data.Semigroup.Internal.$fShowAll6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CrM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CrN; else goto c6CrO;
       c6CrN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CrO: // global
           (_c6CrJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CrJ::I64 == 0) goto c6CrL; else goto c6CrK;
       c6CrL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CrK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CrJ::I64;
           R3 = Data.Semigroup.Internal.$fReadAll4_closure;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.210590141 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll5_closure" {
     Data.Semigroup.Internal.$fShowAll5_closure:
         const Data.Semigroup.Internal.$fShowAll5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll5_entry() //  [R1]
         { info_tbl: [(c6Cs3,
                       label: Data.Semigroup.Internal.$fShowAll5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cs3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cs4; else goto c6Cs5;
       c6Cs4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cs5: // global
           (_c6Cs0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Cs0::I64 == 0) goto c6Cs2; else goto c6Cs1;
       c6Cs2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Cs1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Cs0::I64;
           R3 = Data.Semigroup.Internal.$fReadAll4_closure;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.215564354 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshow_info;
         const 0;
 },
 sat_s6ATY_entry() //  [R1]
         { info_tbl: [(c6Csx,
                       label: sat_s6ATY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Csx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Csy; else goto c6Csz;
       c6Csy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Csz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6Csq_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6CsG; else goto c6Csr;
       u6CsG: // global
           call _c6Csq(R1) args: 0, res: 0, upd: 0;
       c6Csr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6Csq() //  [R1]
         { info_tbl: [(c6Csq,
                       label: block_c6Csq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Csq: // global
           if (R1 & 7 == 1) goto c6Csu; else goto c6Csv;
       c6Csu: // global
           R1 = Data.Semigroup.Internal.$fShowAll6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6Csv: // global
           R1 = Data.Semigroup.Internal.$fShowAll5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6ATZ_entry() //  [R1]
         { info_tbl: [(c6CsH,
                       label: sat_s6ATZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CsH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CsL; else goto c6CsK;
       c6CsL: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CsK: // global
           _s6ATW::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s6ATY_info;
           P64[Hp] = _s6ATW::P64;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAny_$cshow_entry() //  [R2]
         { info_tbl: [(c6CsM,
                       label: Data.Semigroup.Internal.$fShowAny_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CsM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CsQ; else goto c6CsP;
       c6CsQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CsP: // global
           I64[Hp - 16] = sat_s6ATZ_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.226953903 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny1_closure" {
     Data.Semigroup.Internal.$fShowAny1_closure:
         const Data.Semigroup.Internal.$fShowAny1_info;
         const 0;
 },
 sat_s6AU3_entry() //  [R1]
         { info_tbl: [(c6Ctz,
                       label: sat_s6AU3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ctz: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AU4_entry() //  [R1]
         { info_tbl: [(c6CtI,
                       label: sat_s6AU4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CtI: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AU5_entry() //  [R1]
         { info_tbl: [(c6CtP,
                       label: sat_s6AU5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CtP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6CtQ; else goto c6CtR;
       c6CtQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CtR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6Ctq_info;
           _s6AU1::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6AU1::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6CtY; else goto c6Ctr;
       u6CtY: // global
           call _c6Ctq(R1) args: 0, res: 0, upd: 0;
       c6Ctr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6Ctq() //  [R1]
         { info_tbl: [(c6Ctq,
                       label: block_c6Ctq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ctq: // global
           _s6AU1::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6CtM; else goto c6CtN;
       c6CtM: // global
           Hp = Hp + 24;
           _s6AU2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CtX; else goto c6CtT;
       c6CtT: // global
           I64[Hp - 16] = sat_s6AU3_info;
           P64[Hp] = _s6AU1::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6CtN: // global
           Hp = Hp + 24;
           _s6AU2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CtX; else goto c6CtW;
       c6CtX: // global
           HpAlloc = 24;
           R1 = _s6AU2::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6CtW: // global
           I64[Hp - 16] = sat_s6AU4_info;
           P64[Hp] = _s6AU1::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AU6_entry() //  [R1]
         { info_tbl: [(c6CtZ,
                       label: sat_s6AU6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CtZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Cu3; else goto c6Cu2;
       c6Cu3: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cu2: // global
           _s6AU0::P64 = P64[R1 + 16];
           _s6AU1::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6AU5_info;
           P64[Hp - 8] = _s6AU0::P64;
           P64[Hp] = _s6AU1::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAny1_entry() //  [R2, R3]
         { info_tbl: [(c6Cu4,
                       label: Data.Semigroup.Internal.$fShowAny1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cu4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Cu8; else goto c6Cu7;
       c6Cu8: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAny1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Cu7: // global
           I64[Hp - 24] = sat_s6AU6_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAny3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.241639062 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAny_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAny_$cshowList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAny_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c6CuG,
                       label: Data.Semigroup.Internal.$fShowAny_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CuG: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fShowAny1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.245365078 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAny_closure" {
     Data.Semigroup.Internal.$fShowAny_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure+3;
         const Data.Semigroup.Internal.$fShowAny_$cshow_closure+1;
         const Data.Semigroup.Internal.$fShowAny_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.247985066 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAny6_bytes" {
     Data.Semigroup.Internal.$fReadAny6_bytes:
         I8[] [65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.250377474 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny5_closure" {
     Data.Semigroup.Internal.$fReadAny5_closure:
         const Data.Semigroup.Internal.$fReadAny5_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny5_entry() //  [R1]
         { info_tbl: [(c6CuV,
                       label: Data.Semigroup.Internal.$fReadAny5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CuV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CuW; else goto c6CuX;
       c6CuW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CuX: // global
           (_c6CuS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CuS::I64 == 0) goto c6CuU; else goto c6CuT;
       c6CuU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CuT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CuS::I64;
           R2 = Data.Semigroup.Internal.$fReadAny6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.254698727 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_lexeme_closure" {
     Data.Semigroup.Internal.$fReadAny_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAny5_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.256471999 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAny4_bytes" {
     Data.Semigroup.Internal.$fReadAny4_bytes:
         I8[] [103,101,116,65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.258570225 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny3_closure" {
     Data.Semigroup.Internal.$fReadAny3_closure:
         const Data.Semigroup.Internal.$fReadAny3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny3_entry() //  [R1]
         { info_tbl: [(c6Cve,
                       label: Data.Semigroup.Internal.$fReadAny3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cve: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cvf; else goto c6Cvg;
       c6Cvf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cvg: // global
           (_c6Cvb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Cvb::I64 == 0) goto c6Cvd; else goto c6Cvc;
       c6Cvd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Cvc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Cvb::I64;
           R2 = Data.Semigroup.Internal.$fReadAny4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.262973755 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll7_closure" {
     Data.Semigroup.Internal.$fReadAll7_closure:
         const Data.Semigroup.Internal.$fReadAll7_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll7_entry() //  [R3]
         { info_tbl: [(c6Cvt,
                       label: Data.Semigroup.Internal.$fReadAll7_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cvt: // global
           R4 = R3;
           R3 = Text.ParserCombinators.ReadPrec.minPrec_closure;
           R2 = GHC.Read.$fReadBool2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.267897965 UTC

[section ""data" . Data.Semigroup.Internal.$w$creadPrec1_closure" {
     Data.Semigroup.Internal.$w$creadPrec1_closure:
         const Data.Semigroup.Internal.$w$creadPrec1_info;
         const 0;
 },
 sat_s6AUi_entry() //  [R1]
         { info_tbl: [(c6Cw3,
                       label: sat_s6AUi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cw3: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AUl_entry() //  [R1, R2]
         { info_tbl: [(c6Cw9,
                       label: sat_s6AUl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cw9: // global
           _s6AUg::P64 = R2;
           _s6AUl::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6Cwa; else goto c6Cwb;
       c6Cwb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Cwd; else goto c6Cwc;
       c6Cwd: // global
           HpAlloc = 24;
           goto c6Cwa;
       c6Cwa: // global
           R2 = _s6AUg::P64;
           R1 = _s6AUl::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cwc: // global
           _s6AUc::P64 = P64[_s6AUl::P64 + 7];
           I64[Hp - 16] = sat_s6AUi_info;
           P64[Hp - 8] = _s6AUc::P64;
           P64[Hp] = _s6AUg::P64;
           I64[Sp - 8] = block_c6Cw6_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Cw6() //  [R1]
         { info_tbl: [(c6Cw6,
                       label: block_c6Cw6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cw6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Cwg; else goto c6Cwf;
       c6Cwg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Cwf: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6CwL_srtd" {
     u6CwL_srtd:
         const S6Bb6_srt+128;
         const 45;
         const 32985348833281;
 },
 sat_s6AUm_entry() //  [R1, R2]
         { info_tbl: [(c6Cwh,
                       label: sat_s6AUm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cwh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Cwl; else goto c6Cwk;
       c6Cwl: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cwk: // global
           _s6AUc::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s6AUl_info;
           P64[Hp] = _s6AUc::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = Data.Semigroup.Internal.$fReadAll7_closure+2;
           R2 = Data.Semigroup.Internal.$fReadAny3_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6CwM_srtd" {
     u6CwM_srtd:
         const S6Bb6_srt+128;
         const 45;
         const 32985348833285;
 },
 sat_s6AUp_entry() //  [R1, R2]
         { info_tbl: [(c6Cwp,
                       label: sat_s6AUp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cwp: // global
           _s6AUe::P64 = R2;
           _s6AUp::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6Cwq; else goto c6Cwr;
       c6Cwr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Cwt; else goto c6Cws;
       c6Cwt: // global
           HpAlloc = 16;
           goto c6Cwq;
       c6Cwq: // global
           R2 = _s6AUe::P64;
           R1 = _s6AUp::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cws: // global
           _s6AUc::P64 = P64[_s6AUp::P64 + 7];
           I64[Hp - 8] = sat_s6AUm_info;
           P64[Hp] = _s6AUc::P64;
           I64[Sp - 8] = block_c6Cwm_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Cwm() //  [R1]
         { info_tbl: [(c6Cwm,
                       label: block_c6Cwm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cwm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Cww; else goto c6Cwv;
       c6Cww: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Cwv: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6CwN_srtd" {
     u6CwN_srtd:
         const S6Bb6_srt+128;
         const 47;
         const 138538465099781;
 },
 Data.Semigroup.Internal.$w$creadPrec1_entry() //  [R2, R3]
         { info_tbl: [(c6CwA,
                       label: Data.Semigroup.Internal.$w$creadPrec1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CwA: // global
           _s6AUc::P64 = R3;
           _s6AUb::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c6CwB; else goto c6CwC;
       c6CwC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CwE; else goto c6CwD;
       c6CwE: // global
           HpAlloc = 16;
           goto c6CwB;
       c6CwB: // global
           R3 = _s6AUc::P64;
           R2 = _s6AUb::I64;
           R1 = Data.Semigroup.Internal.$w$creadPrec1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CwD: // global
           if (%MO_S_Gt_W64(_s6AUb::I64, 11)) goto c6Cwy; else goto c6Cwz;
       c6Cwy: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Cwz: // global
           I64[Hp - 8] = sat_s6AUp_info;
           P64[Hp] = _s6AUc::P64;
           I64[Sp - 8] = block_c6CwF_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAny_lexeme_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6CwF() //  [R1]
         { info_tbl: [(c6CwF,
                       label: block_c6CwF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CwF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CwK; else goto c6CwJ;
       c6CwK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6CwJ: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.291252271 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny2_closure" {
     Data.Semigroup.Internal.$fReadAny2_closure:
         const Data.Semigroup.Internal.$fReadAny2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny2_entry() //  [R2, R3]
         { info_tbl: [(c6CxF,
                       label: Data.Semigroup.Internal.$fReadAny2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CxF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CxG; else goto c6CxH;
       c6CxG: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAny2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CxH: // global
           I64[Sp - 16] = block_c6CxC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6CxL; else goto c6CxD;
       u6CxL: // global
           call _c6CxC(R1) args: 0, res: 0, upd: 0;
       c6CxD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6CxC() //  [R1]
         { info_tbl: [(c6CxC,
                       label: block_c6CxC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CxC: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$creadPrec1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.297361344 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny1_closure" {
     Data.Semigroup.Internal.$fReadAny1_closure:
         const Data.Semigroup.Internal.$fReadAny1_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny1_entry() //  [R2, R3]
         { info_tbl: [(c6Cy0,
                       label: Data.Semigroup.Internal.$fReadAny1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cy0: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAny2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.301541823 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_info;
         const 0;
 },
 sat_s6AUx_entry() //  [R1]
         { info_tbl: [(c6Cyf,
                       label: sat_s6AUx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cyf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Cyg; else goto c6Cyh;
       c6Cyg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Cyh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAny2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAny_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6Cyi,
                       label: Data.Semigroup.Internal.$fReadAny_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Cyi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Cym; else goto c6Cyl;
       c6Cym: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Cyl: // global
           I64[Hp - 16] = sat_s6AUx_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.308908475 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c6CyF,
                       label: Data.Semigroup.Internal.$fReadAny_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CyF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CyG; else goto c6CyH;
       c6CyG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CyH: // global
           (_c6CyC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CyC::I64 == 0) goto c6CyE; else goto c6CyD;
       c6CyE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CyD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CyC::I64;
           R2 = Data.Semigroup.Internal.$fReadAny1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.313917951 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny7_closure" {
     Data.Semigroup.Internal.$fReadAny7_closure:
         const Data.Semigroup.Internal.$fReadAny7_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny7_entry() //  [R1]
         { info_tbl: [(c6CyW,
                       label: Data.Semigroup.Internal.$fReadAny7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CyW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CyX; else goto c6CyY;
       c6CyX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CyY: // global
           (_c6CyT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CyT::I64 == 0) goto c6CyV; else goto c6CyU;
       c6CyV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CyU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CyT::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.318407212 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAny_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAny_$creadList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAny_$creadList_entry() //  [R2]
         { info_tbl: [(c6Czc,
                       label: Data.Semigroup.Internal.$fReadAny_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Czc: // global
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAny7_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.321931825 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAny_closure" {
     Data.Semigroup.Internal.$fReadAny_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure+1;
         const Data.Semigroup.Internal.$fReadAny_$creadList_closure+1;
         const Data.Semigroup.Internal.$fReadAny1_closure+2;
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.323856629 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAny_closure" {
     Data.Semigroup.Internal.$fEqAny_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.$fEqBool_$c==_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.326773614 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAny_closure" {
     Data.Semigroup.Internal.$fOrdAny_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Semigroup.Internal.$fEqAny_closure+1;
         const GHC.Classes.$fOrdBool_$ccompare_closure+2;
         const GHC.Classes.$fOrdBool_$c<_closure+2;
         const GHC.Classes.$fOrdBool_$c<=_closure+2;
         const GHC.Classes.$fOrdBool_$c>_closure+2;
         const GHC.Classes.$fOrdBool_$c>=_closure+2;
         const GHC.Classes.$fOrdBool_$cmax_closure+2;
         const GHC.Classes.$fOrdBool_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.329007088 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll1_closure" {
     Data.Semigroup.Internal.$fGenericAll1_closure:
         const Data.Semigroup.Internal.$fGenericAll1_info;
 },
 Data.Semigroup.Internal.$fGenericAll1_entry() //  [R2]
         { info_tbl: [(c6Czq,
                       label: Data.Semigroup.Internal.$fGenericAll1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Czq: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.332640524 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll2_closure" {
     Data.Semigroup.Internal.$fGenericAll2_closure:
         const Data.Semigroup.Internal.$fGenericAll2_info;
 },
 Data.Semigroup.Internal.$fGenericAll2_entry() //  [R2]
         { info_tbl: [(c6CzB,
                       label: Data.Semigroup.Internal.$fGenericAll2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CzB: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.336095843 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericAll_closure" {
     Data.Semigroup.Internal.$fGenericAll_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericAll2_closure+1;
         const Data.Semigroup.Internal.$fGenericAll1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.337972644 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedAll_closure" {
     Data.Semigroup.Internal.$fBoundedAll_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.Types.False_closure+1;
         const GHC.Types.True_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.339883784 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAll4_bytes" {
     Data.Semigroup.Internal.$fShowAll4_bytes:
         I8[] [65,108,108,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.342009966 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll3_closure" {
     Data.Semigroup.Internal.$fShowAll3_closure:
         const Data.Semigroup.Internal.$fShowAll3_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll3_entry() //  [R1]
         { info_tbl: [(c6CzT,
                       label: Data.Semigroup.Internal.$fShowAll3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CzT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CzU; else goto c6CzV;
       c6CzU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CzV: // global
           (_c6CzQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CzQ::I64 == 0) goto c6CzS; else goto c6CzR;
       c6CzS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CzR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CzQ::I64;
           R2 = Data.Semigroup.Internal.$fShowAll4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.34665061 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowAll2_bytes" {
     Data.Semigroup.Internal.$fShowAll2_bytes:
         I8[] [103,101,116,65,108,108,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.350705228 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec_info;
         const 0;
 },
 sat_s6AUF_entry() //  [R1]
         { info_tbl: [(c6CAt,
                       label: sat_s6AUF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CAt: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AUG_entry() //  [R1]
         { info_tbl: [(c6CAC,
                       label: sat_s6AUG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CAC: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AUH_entry() //  [R1]
         { info_tbl: [(c6CAJ,
                       label: sat_s6AUH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CAJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6CAK; else goto c6CAL;
       c6CAK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CAL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6CAk_info;
           _s6AUC::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6AUC::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6CAS; else goto c6CAl;
       u6CAS: // global
           call _c6CAk(R1) args: 0, res: 0, upd: 0;
       c6CAl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6CAk() //  [R1]
         { info_tbl: [(c6CAk,
                       label: block_c6CAk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CAk: // global
           _s6AUC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6CAG; else goto c6CAH;
       c6CAG: // global
           Hp = Hp + 24;
           _s6AUE::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CAR; else goto c6CAN;
       c6CAN: // global
           I64[Hp - 16] = sat_s6AUF_info;
           P64[Hp] = _s6AUC::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6CAH: // global
           Hp = Hp + 24;
           _s6AUE::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CAR; else goto c6CAQ;
       c6CAR: // global
           HpAlloc = 24;
           R1 = _s6AUE::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6CAQ: // global
           I64[Hp - 16] = sat_s6AUG_info;
           P64[Hp] = _s6AUC::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AUI_entry() //  [R1]
         { info_tbl: [(c6CAT,
                       label: sat_s6AUI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CAT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CAX; else goto c6CAW;
       c6CAX: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CAW: // global
           _s6AUB::P64 = P64[R1 + 16];
           _s6AUC::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6AUH_info;
           P64[Hp - 8] = _s6AUB::P64;
           P64[Hp] = _s6AUC::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AUL_entry() //  [R1]
         { info_tbl: [(c6CBl,
                       label: sat_s6AUL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CBl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CBp; else goto c6CBo;
       c6CBp: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CBo: // global
           _s6AUC::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6AUC::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AUN_entry() //  [R1]
         { info_tbl: [(c6CBx,
                       label: sat_s6AUN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CBx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CBB; else goto c6CBA;
       c6CBB: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CBA: // global
           _s6AUC::P64 = P64[R1 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6AUC::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AUO_entry() //  [R1]
         { info_tbl: [(c6CBG,
                       label: sat_s6AUO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CBG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6CBH; else goto c6CBI;
       c6CBH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CBI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6CBb_info;
           _s6AUC::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6AUC::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6CBP; else goto c6CBc;
       u6CBP: // global
           call _c6CBb(R1) args: 0, res: 0, upd: 0;
       c6CBc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6CBb() //  [R1]
         { info_tbl: [(c6CBb,
                       label: block_c6CBb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CBb: // global
           _s6AUC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6CBD; else goto c6CBE;
       c6CBD: // global
           Hp = Hp + 24;
           _s6AUJ::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CBO; else goto c6CBK;
       c6CBK: // global
           I64[Hp - 16] = sat_s6AUL_info;
           P64[Hp] = _s6AUC::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6CBE: // global
           Hp = Hp + 24;
           _s6AUJ::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CBO; else goto c6CBN;
       c6CBO: // global
           HpAlloc = 24;
           R1 = _s6AUJ::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6CBN: // global
           I64[Hp - 16] = sat_s6AUN_info;
           P64[Hp] = _s6AUC::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AUP_entry() //  [R1]
         { info_tbl: [(c6CBQ,
                       label: sat_s6AUP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CBQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CBU; else goto c6CBT;
       c6CBU: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CBT: // global
           _s6AUB::P64 = P64[R1 + 16];
           _s6AUC::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6AUO_info;
           P64[Hp - 8] = _s6AUB::P64;
           P64[Hp] = _s6AUC::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AUQ_entry() //  [R1]
         { info_tbl: [(c6CBV,
                       label: sat_s6AUQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CBV: // global
           _s6AUQ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6CBW; else goto c6CBX;
       c6CBX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CBZ; else goto c6CBY;
       c6CBZ: // global
           HpAlloc = 32;
           goto c6CBW;
       c6CBW: // global
           R1 = _s6AUQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CBY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AUQ::P64;
           _s6AUB::P64 = P64[_s6AUQ::P64 + 16];
           _s6AUC::P64 = P64[_s6AUQ::P64 + 24];
           I64[Hp - 24] = sat_s6AUP_info;
           P64[Hp - 8] = _s6AUB::P64;
           P64[Hp] = _s6AUC::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec_entry() //  [R2, R3, R4]
         { info_tbl: [(c6CC3,
                       label: Data.Semigroup.Internal.$w$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CC3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6CC7; else goto c6CC6;
       c6CC7: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CC6: // global
           if (%MO_S_Lt_W64(R2, 11)) goto c6CC1; else goto c6CC2;
       c6CC1: // global
           I64[Hp - 48] = sat_s6AUI_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           _c6CAc::P64 = Hp - 48;
           Hp = Hp - 24;
           R3 = _c6CAc::P64;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6CC2: // global
           I64[Hp - 48] = sat_s6AUQ_info;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.380719604 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll_$cshowsPrec_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6CDm,
                       label: Data.Semigroup.Internal.$fShowAll_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CDm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6CDn; else goto c6CDo;
       c6CDn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CDo: // global
           I64[Sp - 24] = block_c6CDj_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6CDs; else goto c6CDk;
       u6CDs: // global
           call _c6CDj(R1) args: 0, res: 0, upd: 0;
       c6CDk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6CDj() //  [R1]
         { info_tbl: [(c6CDj,
                       label: block_c6CDj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CDj: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.38749829 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshow_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshow_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshow_info;
         const 0;
 },
 sat_s6AUY_entry() //  [R1]
         { info_tbl: [(c6CDW,
                       label: sat_s6AUY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CDW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6CDX; else goto c6CDY;
       c6CDX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CDY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6CDP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6CE5; else goto c6CDQ;
       u6CE5: // global
           call _c6CDP(R1) args: 0, res: 0, upd: 0;
       c6CDQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6CDP() //  [R1]
         { info_tbl: [(c6CDP,
                       label: block_c6CDP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CDP: // global
           if (R1 & 7 == 1) goto c6CDT; else goto c6CDU;
       c6CDT: // global
           R1 = Data.Semigroup.Internal.$fShowAll6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       c6CDU: // global
           R1 = Data.Semigroup.Internal.$fShowAll5_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AUZ_entry() //  [R1]
         { info_tbl: [(c6CE6,
                       label: sat_s6AUZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CE6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CEa; else goto c6CE9;
       c6CEa: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CE9: // global
           _s6AUW::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_s6AUY_info;
           P64[Hp] = _s6AUW::P64;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAll_$cshow_entry() //  [R2]
         { info_tbl: [(c6CEb,
                       label: Data.Semigroup.Internal.$fShowAll_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CEb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CEf; else goto c6CEe;
       c6CEf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CEe: // global
           I64[Hp - 16] = sat_s6AUZ_info;
           P64[Hp] = R2;
           R3 = Hp - 16;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.39839707 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll1_closure" {
     Data.Semigroup.Internal.$fShowAll1_closure:
         const Data.Semigroup.Internal.$fShowAll1_info;
         const 0;
 },
 sat_s6AV3_entry() //  [R1]
         { info_tbl: [(c6CEY,
                       label: sat_s6AV3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CEY: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AV4_entry() //  [R1]
         { info_tbl: [(c6CF7,
                       label: sat_s6AV4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CF7: // global
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll4_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AV5_entry() //  [R1]
         { info_tbl: [(c6CFe,
                       label: sat_s6AV5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CFe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6CFf; else goto c6CFg;
       c6CFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c6CEP_info;
           _s6AV1::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s6AV1::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6CFn; else goto c6CEQ;
       u6CFn: // global
           call _c6CEP(R1) args: 0, res: 0, upd: 0;
       c6CEQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c6CEP() //  [R1]
         { info_tbl: [(c6CEP,
                       label: block_c6CEP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CEP: // global
           _s6AV1::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6CFb; else goto c6CFc;
       c6CFb: // global
           Hp = Hp + 24;
           _s6AV2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CFm; else goto c6CFi;
       c6CFi: // global
           I64[Hp - 16] = sat_s6AV3_info;
           P64[Hp] = _s6AV1::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool4_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       c6CFc: // global
           Hp = Hp + 24;
           _s6AV2::P64 = R1;
           if (Hp > HpLim) (likely: False) goto c6CFm; else goto c6CFl;
       c6CFm: // global
           HpAlloc = 24;
           R1 = _s6AV2::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c6CFl: // global
           I64[Hp - 16] = sat_s6AV4_info;
           P64[Hp] = _s6AV1::P64;
           R3 = Hp - 16;
           R2 = GHC.Show.$fShowBool2_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AV6_entry() //  [R1]
         { info_tbl: [(c6CFo,
                       label: sat_s6AV6_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CFo: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CFs; else goto c6CFr;
       c6CFs: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CFr: // global
           _s6AV0::P64 = P64[R1 + 16];
           _s6AV1::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_s6AV5_info;
           P64[Hp - 8] = _s6AV0::P64;
           P64[Hp] = _s6AV1::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowAll1_entry() //  [R2, R3]
         { info_tbl: [(c6CFt,
                       label: Data.Semigroup.Internal.$fShowAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CFt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CFx; else goto c6CFw;
       c6CFx: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowAll1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CFw: // global
           I64[Hp - 24] = sat_s6AV6_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowAll3_closure;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.414780291 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowAll_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowAll_$cshowList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fShowAll_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c6CG5,
                       label: Data.Semigroup.Internal.$fShowAll_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CG5: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fShowAll1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.418447561 UTC

[section ""data" . Data.Semigroup.Internal.$fShowAll_closure" {
     Data.Semigroup.Internal.$fShowAll_closure:
         const GHC.Show.C:Show_con_info;
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure+3;
         const Data.Semigroup.Internal.$fShowAll_$cshow_closure+1;
         const Data.Semigroup.Internal.$fShowAll_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.420590921 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll13_bytes" {
     Data.Semigroup.Internal.$fReadAll13_bytes:
         I8[] [65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.422972083 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll12_closure" {
     Data.Semigroup.Internal.$fReadAll12_closure:
         const Data.Semigroup.Internal.$fReadAll12_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll12_entry() //  [R1]
         { info_tbl: [(c6CGk,
                       label: Data.Semigroup.Internal.$fReadAll12_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CGk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CGl; else goto c6CGm;
       c6CGl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CGm: // global
           (_c6CGh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CGh::I64 == 0) goto c6CGj; else goto c6CGi;
       c6CGj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CGi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CGh::I64;
           R2 = Data.Semigroup.Internal.$fReadAll13_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.428152924 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_lexeme1_closure" {
     Data.Semigroup.Internal.$fReadAll_lexeme1_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadAll12_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.42994039 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadAll9_bytes" {
     Data.Semigroup.Internal.$fReadAll9_bytes:
         I8[] [103,101,116,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.431914955 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll8_closure" {
     Data.Semigroup.Internal.$fReadAll8_closure:
         const Data.Semigroup.Internal.$fReadAll8_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll8_entry() //  [R1]
         { info_tbl: [(c6CGD,
                       label: Data.Semigroup.Internal.$fReadAll8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CGD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CGE; else goto c6CGF;
       c6CGE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CGF: // global
           (_c6CGA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CGA::I64 == 0) goto c6CGC; else goto c6CGB;
       c6CGC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CGB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CGA::I64;
           R2 = Data.Semigroup.Internal.$fReadAll9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.437533471 UTC

[section ""data" . Data.Semigroup.Internal.$w$creadPrec_closure" {
     Data.Semigroup.Internal.$w$creadPrec_closure:
         const Data.Semigroup.Internal.$w$creadPrec_info;
         const 0;
 },
 sat_s6AVg_entry() //  [R1]
         { info_tbl: [(c6CHg,
                       label: sat_s6AVg_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CHg: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AVj_entry() //  [R1, R2]
         { info_tbl: [(c6CHm,
                       label: sat_s6AVj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CHm: // global
           _s6AVe::P64 = R2;
           _s6AVj::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6CHn; else goto c6CHo;
       c6CHo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CHq; else goto c6CHp;
       c6CHq: // global
           HpAlloc = 24;
           goto c6CHn;
       c6CHn: // global
           R2 = _s6AVe::P64;
           R1 = _s6AVj::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CHp: // global
           _s6AVa::P64 = P64[_s6AVj::P64 + 7];
           I64[Hp - 16] = sat_s6AVg_info;
           P64[Hp - 8] = _s6AVa::P64;
           P64[Hp] = _s6AVe::P64;
           I64[Sp - 8] = block_c6CHj_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6CHj() //  [R1]
         { info_tbl: [(c6CHj,
                       label: block_c6CHj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CHj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CHt; else goto c6CHs;
       c6CHt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6CHs: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6CHY_srtd" {
     u6CHY_srtd:
         const S6Bb6_srt+128;
         const 59;
         const 288245769314500609;
 },
 sat_s6AVk_entry() //  [R1, R2]
         { info_tbl: [(c6CHu,
                       label: sat_s6AVk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CHu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CHy; else goto c6CHx;
       c6CHy: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CHx: // global
           _s6AVa::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s6AVj_info;
           P64[Hp] = _s6AVa::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = Data.Semigroup.Internal.$fReadAll7_closure+2;
           R2 = Data.Semigroup.Internal.$fReadAll8_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6CHZ_srtd" {
     u6CHZ_srtd:
         const S6Bb6_srt+128;
         const 59;
         const 288245769314500613;
 },
 sat_s6AVn_entry() //  [R1, R2]
         { info_tbl: [(c6CHC,
                       label: sat_s6AVn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CHC: // global
           _s6AVc::P64 = R2;
           _s6AVn::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6CHD; else goto c6CHE;
       c6CHE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CHG; else goto c6CHF;
       c6CHG: // global
           HpAlloc = 16;
           goto c6CHD;
       c6CHD: // global
           R2 = _s6AVc::P64;
           R1 = _s6AVn::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CHF: // global
           _s6AVa::P64 = P64[_s6AVn::P64 + 7];
           I64[Hp - 8] = sat_s6AVk_info;
           P64[Hp] = _s6AVa::P64;
           I64[Sp - 8] = block_c6CHz_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6CHz() //  [R1]
         { info_tbl: [(c6CHz,
                       label: block_c6CHz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CHz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CHJ; else goto c6CHI;
       c6CHJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6CHI: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6CI0_srtd" {
     u6CI0_srtd:
         const S6Bb6_srt+128;
         const 61;
         const 2017628026224771077;
 },
 Data.Semigroup.Internal.$w$creadPrec_entry() //  [R2, R3]
         { info_tbl: [(c6CHN,
                       label: Data.Semigroup.Internal.$w$creadPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CHN: // global
           _s6AVa::P64 = R3;
           _s6AV9::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto c6CHO; else goto c6CHP;
       c6CHP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CHR; else goto c6CHQ;
       c6CHR: // global
           HpAlloc = 16;
           goto c6CHO;
       c6CHO: // global
           R3 = _s6AVa::P64;
           R2 = _s6AV9::I64;
           R1 = Data.Semigroup.Internal.$w$creadPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CHQ: // global
           if (%MO_S_Gt_W64(_s6AV9::I64, 11)) goto c6CHL; else goto c6CHM;
       c6CHL: // global
           Hp = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6CHM: // global
           I64[Hp - 8] = sat_s6AVn_info;
           P64[Hp] = _s6AVa::P64;
           I64[Sp - 8] = block_c6CHS_info;
           R3 = Hp - 7;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme1_closure+4;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6CHS() //  [R1]
         { info_tbl: [(c6CHS,
                       label: block_c6CHS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CHS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CHX; else goto c6CHW;
       c6CHX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6CHW: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.459755505 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll2_closure" {
     Data.Semigroup.Internal.$fReadAll2_closure:
         const Data.Semigroup.Internal.$fReadAll2_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll2_entry() //  [R2, R3]
         { info_tbl: [(c6CIS,
                       label: Data.Semigroup.Internal.$fReadAll2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CIS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CIT; else goto c6CIU;
       c6CIT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAll2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CIU: // global
           I64[Sp - 16] = block_c6CIP_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6CIY; else goto c6CIQ;
       u6CIY: // global
           call _c6CIP(R1) args: 0, res: 0, upd: 0;
       c6CIQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6CIP() //  [R1]
         { info_tbl: [(c6CIP,
                       label: block_c6CIP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CIP: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$creadPrec_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.465897243 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll1_closure" {
     Data.Semigroup.Internal.$fReadAll1_closure:
         const Data.Semigroup.Internal.$fReadAll1_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll1_entry() //  [R2, R3]
         { info_tbl: [(c6CJd,
                       label: Data.Semigroup.Internal.$fReadAll1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CJd: // global
           R4 = R3;
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAll2_closure+2;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.469751645 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_info;
         const 0;
 },
 sat_s6AVv_entry() //  [R1]
         { info_tbl: [(c6CJs,
                       label: sat_s6AVv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CJs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CJt; else goto c6CJu;
       c6CJt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CJu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll2_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadAll_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6CJv,
                       label: Data.Semigroup.Internal.$fReadAll_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CJv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CJz; else goto c6CJy;
       c6CJz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CJy: // global
           I64[Hp - 16] = sat_s6AVv_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.475891993 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll_$creadListPrec_entry() //  [R1]
         { info_tbl: [(c6CJS,
                       label: Data.Semigroup.Internal.$fReadAll_$creadListPrec_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CJS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CJT; else goto c6CJU;
       c6CJT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CJU: // global
           (_c6CJP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CJP::I64 == 0) goto c6CJR; else goto c6CJQ;
       c6CJR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CJQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CJP::I64;
           R2 = Data.Semigroup.Internal.$fReadAll1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.480395104 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll14_closure" {
     Data.Semigroup.Internal.$fReadAll14_closure:
         const Data.Semigroup.Internal.$fReadAll14_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll14_entry() //  [R1]
         { info_tbl: [(c6CK9,
                       label: Data.Semigroup.Internal.$fReadAll14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CK9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CKa; else goto c6CKb;
       c6CKa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CKb: // global
           (_c6CK6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CK6::I64 == 0) goto c6CK8; else goto c6CK7;
       c6CK8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CK7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CK6::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.484984962 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_$creadList_closure" {
     Data.Semigroup.Internal.$fReadAll_$creadList_closure:
         const Data.Semigroup.Internal.$fReadAll_$creadList_info;
         const 0;
 },
 Data.Semigroup.Internal.$fReadAll_$creadList_entry() //  [R2]
         { info_tbl: [(c6CKp,
                       label: Data.Semigroup.Internal.$fReadAll_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CKp: // global
           R3 = R2;
           R2 = Data.Semigroup.Internal.$fReadAll14_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.489360194 UTC

[section ""data" . Data.Semigroup.Internal.$fReadAll_closure" {
     Data.Semigroup.Internal.$fReadAll_closure:
         const GHC.Read.C:Read_con_info;
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure+1;
         const Data.Semigroup.Internal.$fReadAll_$creadList_closure+1;
         const Data.Semigroup.Internal.$fReadAll1_closure+2;
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.491179386 UTC

[section ""data" . Data.Semigroup.Internal.$fEqAll_closure" {
     Data.Semigroup.Internal.$fEqAll_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Classes.$fEqBool_$c==_closure+2;
         const GHC.Classes.$fEqBool_$c/=_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.493024326 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdAll_closure" {
     Data.Semigroup.Internal.$fOrdAll_closure:
         const GHC.Classes.C:Ord_con_info;
         const Data.Semigroup.Internal.$fEqAll_closure+1;
         const GHC.Classes.$fOrdBool_$ccompare_closure+2;
         const GHC.Classes.$fOrdBool_$c<_closure+2;
         const GHC.Classes.$fOrdBool_$c<=_closure+2;
         const GHC.Classes.$fOrdBool_$c>_closure+2;
         const GHC.Classes.$fOrdBool_$c>=_closure+2;
         const GHC.Classes.$fOrdBool_$cmax_closure+2;
         const GHC.Classes.$fOrdBool_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.495240428 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo1_closure" {
     Data.Semigroup.Internal.$fGenericEndo1_closure:
         const Data.Semigroup.Internal.$fGenericEndo1_info;
 },
 Data.Semigroup.Internal.$fGenericEndo1_entry() //  [R2]
         { info_tbl: [(c6CKD,
                       label: Data.Semigroup.Internal.$fGenericEndo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CKD: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.499190635 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo2_closure" {
     Data.Semigroup.Internal.$fGenericEndo2_closure:
         const Data.Semigroup.Internal.$fGenericEndo2_info;
 },
 Data.Semigroup.Internal.$fGenericEndo2_entry() //  [R2]
         { info_tbl: [(c6CKO,
                       label: Data.Semigroup.Internal.$fGenericEndo2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CKO: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.502457093 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericEndo_closure" {
     Data.Semigroup.Internal.$fGenericEndo_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericEndo2_closure+1;
         const Data.Semigroup.Internal.$fGenericEndo1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.504481812 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual1_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual1_closure:
         const Data.Semigroup.Internal.$fGeneric1Dual1_info;
 },
 Data.Semigroup.Internal.$fGeneric1Dual1_entry() //  [R2]
         { info_tbl: [(c6CL0,
                       label: Data.Semigroup.Internal.$fGeneric1Dual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CL0: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.508070553 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual2_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual2_closure:
         const Data.Semigroup.Internal.$fGeneric1Dual2_info;
 },
 Data.Semigroup.Internal.$fGeneric1Dual2_entry() //  [R2]
         { info_tbl: [(c6CLb,
                       label: Data.Semigroup.Internal.$fGeneric1Dual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CLb: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.511774668 UTC

[section ""data" . Data.Semigroup.Internal.$fGeneric1Dual_closure" {
     Data.Semigroup.Internal.$fGeneric1Dual_closure:
         const GHC.Generics.C:Generic1_con_info;
         const Data.Semigroup.Internal.$fGeneric1Dual2_closure+1;
         const Data.Semigroup.Internal.$fGeneric1Dual1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.514008351 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual1_closure" {
     Data.Semigroup.Internal.$fGenericDual1_closure:
         const Data.Semigroup.Internal.$fGenericDual1_info;
 },
 Data.Semigroup.Internal.$fGenericDual1_entry() //  [R2]
         { info_tbl: [(c6CLn,
                       label: Data.Semigroup.Internal.$fGenericDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CLn: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.51893215 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual2_closure" {
     Data.Semigroup.Internal.$fGenericDual2_closure:
         const Data.Semigroup.Internal.$fGenericDual2_info;
 },
 Data.Semigroup.Internal.$fGenericDual2_entry() //  [R2]
         { info_tbl: [(c6CLy,
                       label: Data.Semigroup.Internal.$fGenericDual2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CLy: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.522657696 UTC

[section ""data" . Data.Semigroup.Internal.$fGenericDual_closure" {
     Data.Semigroup.Internal.$fGenericDual_closure:
         const GHC.Generics.C:Generic_con_info;
         const Data.Semigroup.Internal.$fGenericDual2_closure+1;
         const Data.Semigroup.Internal.$fGenericDual1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.524968619 UTC

[section ""data" . Data.Semigroup.Internal.$fBoundedDual_closure" {
     Data.Semigroup.Internal.$fBoundedDual_closure:
         const Data.Semigroup.Internal.$fBoundedDual_info;
 },
 sat_s6AVE_entry() //  [R1]
         { info_tbl: [(c6CLO,
                       label: sat_s6AVE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CLO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CLP; else goto c6CLQ;
       c6CLP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CLQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.maxBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AVD_entry() //  [R1]
         { info_tbl: [(c6CLV,
                       label: sat_s6AVD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CLV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CLW; else goto c6CLX;
       c6CLW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CLX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Enum.minBound_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fBoundedDual_entry() //  [R2]
         { info_tbl: [(c6CLZ,
                       label: Data.Semigroup.Internal.$fBoundedDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CLZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6CM3; else goto c6CM2;
       c6CM3: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fBoundedDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CM2: // global
           I64[Hp - 64] = sat_s6AVE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6AVD_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Enum.C:Bounded_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.533025666 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowDual2_bytes" {
     Data.Semigroup.Internal.$fShowDual2_bytes:
         I8[] [68,117,97,108,32,123]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.534868428 UTC

[section ""cstring" . Data.Semigroup.Internal.$fShowDual1_bytes" {
     Data.Semigroup.Internal.$fShowDual1_bytes:
         I8[] [103,101,116,68,117,97,108,32,61,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.5388613 UTC

[section ""data" . Data.Semigroup.Internal.$w$cshowsPrec3_closure" {
     Data.Semigroup.Internal.$w$cshowsPrec3_closure:
         const Data.Semigroup.Internal.$w$cshowsPrec3_info;
 },
 f_s6AVI_entry() //  [R1]
         { info_tbl: [(c6CMy,
                       label: f_s6AVI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CMy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6CMz; else goto c6CMA;
       c6CMz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CMA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Show.showsPrec_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AVL_entry() //  [R1]
         { info_tbl: [(c6CMV,
                       label: sat_s6AVL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CMV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CMW; else goto c6CMX;
       c6CMW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CMX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AVM_entry() //  [R1]
         { info_tbl: [(c6CMY,
                       label: sat_s6AVM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CMY: // global
           _s6AVM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6CMZ; else goto c6CN0;
       c6CN0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CN2; else goto c6CN1;
       c6CN2: // global
           HpAlloc = 24;
           goto c6CMZ;
       c6CMZ: // global
           R1 = _s6AVM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CN1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AVM::P64;
           _s6AVI::P64 = P64[_s6AVM::P64 + 16];
           _s6AVK::P64 = P64[_s6AVM::P64 + 24];
           I64[Hp - 16] = sat_s6AVL_info;
           P64[Hp] = _s6AVK::P64;
           R2 = Hp - 16;
           R1 = _s6AVI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AVN_entry() //  [R1]
         { info_tbl: [(c6CN3,
                       label: sat_s6AVN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CN3: // global
           _s6AVN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6CN4; else goto c6CN5;
       c6CN5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CN7; else goto c6CN6;
       c6CN7: // global
           HpAlloc = 32;
           goto c6CN4;
       c6CN4: // global
           R1 = _s6AVN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CN6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AVN::P64;
           _s6AVI::P64 = P64[_s6AVN::P64 + 16];
           _s6AVK::P64 = P64[_s6AVN::P64 + 24];
           I64[Hp - 24] = sat_s6AVM_info;
           P64[Hp - 8] = _s6AVI::P64;
           P64[Hp] = _s6AVK::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AVO_entry() //  [R1, R2]
         { info_tbl: [(c6CN8,
                       label: sat_s6AVO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CN8: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CNc; else goto c6CNb;
       c6CNc: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CNb: // global
           _s6AVI::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6AVN_info;
           P64[Hp - 8] = _s6AVI::P64;
           P64[Hp] = R2;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AVR_entry() //  [R1]
         { info_tbl: [(c6CNA,
                       label: sat_s6AVR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CNA: // global
           _s6AVR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6CNB; else goto c6CNC;
       c6CNC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CNE; else goto c6CND;
       c6CNE: // global
           HpAlloc = 24;
           goto c6CNB;
       c6CNB: // global
           R1 = _s6AVR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CND: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AVR::P64;
           _s6AVP::P64 = P64[_s6AVR::P64 + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)2_closure;
           P64[Hp] = _s6AVP::P64;
           R3 = Hp - 14;
           R2 = Data.Semigroup.Internal.$fReadAll5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AVS_entry() //  [R1]
         { info_tbl: [(c6CNF,
                       label: sat_s6AVS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CNF: // global
           _s6AVS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6CNG; else goto c6CNH;
       c6CNH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CNJ; else goto c6CNI;
       c6CNJ: // global
           HpAlloc = 24;
           goto c6CNG;
       c6CNG: // global
           R1 = _s6AVS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CNI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AVS::P64;
           _s6AVI::P64 = P64[_s6AVS::P64 + 16];
           _s6AVP::P64 = P64[_s6AVS::P64 + 24];
           I64[Hp - 16] = sat_s6AVR_info;
           P64[Hp] = _s6AVP::P64;
           R2 = Hp - 16;
           R1 = _s6AVI::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AVT_entry() //  [R1]
         { info_tbl: [(c6CNK,
                       label: sat_s6AVT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CNK: // global
           _s6AVT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6CNL; else goto c6CNM;
       c6CNM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CNO; else goto c6CNN;
       c6CNO: // global
           HpAlloc = 32;
           goto c6CNL;
       c6CNL: // global
           R1 = _s6AVT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CNN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AVT::P64;
           _s6AVI::P64 = P64[_s6AVT::P64 + 16];
           _s6AVP::P64 = P64[_s6AVT::P64 + 24];
           I64[Hp - 24] = sat_s6AVS_info;
           P64[Hp - 8] = _s6AVI::P64;
           P64[Hp] = _s6AVP::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AVU_entry() //  [R1]
         { info_tbl: [(c6CNP,
                       label: sat_s6AVU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CNP: // global
           _s6AVU::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6CNQ; else goto c6CNR;
       c6CNR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CNT; else goto c6CNS;
       c6CNT: // global
           HpAlloc = 32;
           goto c6CNQ;
       c6CNQ: // global
           R1 = _s6AVU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CNS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AVU::P64;
           _s6AVI::P64 = P64[_s6AVU::P64 + 16];
           _s6AVP::P64 = P64[_s6AVU::P64 + 24];
           I64[Hp - 24] = sat_s6AVT_info;
           P64[Hp - 8] = _s6AVI::P64;
           P64[Hp] = _s6AVP::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AVV_entry() //  [R1, R2]
         { info_tbl: [(c6CNV,
                       label: sat_s6AVV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CNV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6CNZ; else goto c6CNY;
       c6CNZ: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CNY: // global
           _s6AVI::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_s6AVU_info;
           P64[Hp - 32] = _s6AVI::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = GHC.Show.$fShow(,)4_closure;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$cshowsPrec3_entry() //  [R2, R3, R4]
         { info_tbl: [(c6CO3,
                       label: Data.Semigroup.Internal.$w$cshowsPrec3_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CO3: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6CO7; else goto c6CO6;
       c6CO7: // global
           HpAlloc = 48;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$cshowsPrec3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CO6: // global
           I64[Hp - 40] = f_s6AVI_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R4;
           _c6CMu::P64 = Hp - 40;
           if (%MO_S_Lt_W64(R3, 11)) goto c6CO1; else goto c6CO2;
       c6CO1: // global
           I64[Hp - 8] = sat_s6AVO_info;
           P64[Hp] = _c6CMu::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6CO2: // global
           I64[Hp - 8] = sat_s6AVV_info;
           P64[Hp] = _c6CMu::P64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.567397914 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshowsPrec_info;
 },
 Data.Semigroup.Internal.$fShowDual_$cshowsPrec_entry() //  [R2, R3,
                                                             R4]
         { info_tbl: [(c6CPo,
                       label: Data.Semigroup.Internal.$fShowDual_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CPo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6CPp; else goto c6CPq;
       c6CPp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CPq: // global
           I64[Sp - 24] = block_c6CPl_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6CPu; else goto c6CPm;
       u6CPu: // global
           call _c6CPl(R1) args: 0, res: 0, upd: 0;
       c6CPm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6CPl() //  [R1]
         { info_tbl: [(c6CPl,
                       label: block_c6CPl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CPl: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Data.Semigroup.Internal.$w$cshowsPrec3_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.573947352 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshow_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshow_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshow_info;
         const 0;
 },
 sat_s6AW3_entry() //  [R1]
         { info_tbl: [(c6CPR,
                       label: sat_s6AW3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CPR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6CPS; else goto c6CPT;
       c6CPS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CPT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = Data.Semigroup.Internal.$fShowAlt1_closure+1;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = Data.Semigroup.Internal.$fReadAll4_closure;
           Sp = Sp - 48;
           call GHC.Show.showsPrec_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 sat_s6AW4_entry() //  [R1]
         { info_tbl: [(c6CPU,
                       label: sat_s6AW4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CPU: // global
           _s6AW4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c6CPV; else goto c6CPW;
       c6CPW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CPY; else goto c6CPX;
       c6CPY: // global
           HpAlloc = 32;
           goto c6CPV;
       c6CPV: // global
           R1 = _s6AW4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CPX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AW4::P64;
           _s6AW1::P64 = P64[_s6AW4::P64 + 16];
           _s6AW2::P64 = P64[_s6AW4::P64 + 24];
           I64[Hp - 24] = sat_s6AW3_info;
           P64[Hp - 8] = _s6AW1::P64;
           P64[Hp] = _s6AW2::P64;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fShowDual_$cshow_entry() //  [R2, R3]
         { info_tbl: [(c6CPZ,
                       label: Data.Semigroup.Internal.$fShowDual_$cshow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CPZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CQ3; else goto c6CQ2;
       c6CQ3: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CQ2: // global
           I64[Hp - 24] = sat_s6AW4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = Hp - 24;
           R2 = Data.Semigroup.Internal.$fShowDual2_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.583474354 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_$cshowList_closure" {
     Data.Semigroup.Internal.$fShowDual_$cshowList_closure:
         const Data.Semigroup.Internal.$fShowDual_$cshowList_info;
 },
 sat_s6AW9_entry() //  [R1, R2]
         { info_tbl: [(c6CQx,
                       label: sat_s6AW9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CQx: // global
           R4 = R2;
           R3 = 0;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$w$cshowsPrec3_entry(R4,
                                                             R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowDual_$cshowList_entry() //  [R2, R3,
                                                            R4]
         { info_tbl: [(c6CQA,
                       label: Data.Semigroup.Internal.$fShowDual_$cshowList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CQA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CQE; else goto c6CQD;
       c6CQE: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_$cshowList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CQD: // global
           I64[Hp - 8] = sat_s6AW9_info;
           P64[Hp] = R2;
           R4 = R4;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.58975672 UTC

[section ""data" . Data.Semigroup.Internal.$fShowDual_closure" {
     Data.Semigroup.Internal.$fShowDual_closure:
         const Data.Semigroup.Internal.$fShowDual_info;
         const 0;
 },
 sat_s6AWd_entry() //  [R1, R2, R3]
         { info_tbl: [(c6CQW,
                       label: sat_s6AWd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CQW: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowDual_$cshowList_entry(R4,
                                                                    R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AWc_entry() //  [R1, R2]
         { info_tbl: [(c6CR4,
                       label: sat_s6AWc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CR4: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fShowDual_$cshow_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AWb_entry() //  [R1, R2, R3]
         { info_tbl: [(c6CRc,
                       label: sat_s6AWb_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CRc: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call Data.Semigroup.Internal.$fShowDual_$cshowsPrec_entry(R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fShowDual_entry() //  [R2]
         { info_tbl: [(c6CRg,
                       label: Data.Semigroup.Internal.$fShowDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CRg: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto c6CRk; else goto c6CRj;
       c6CRk: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fShowDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CRj: // global
           I64[Hp - 72] = sat_s6AWd_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6AWc_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6AWb_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Show.C:Show_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 70;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.599467528 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadDual5_bytes" {
     Data.Semigroup.Internal.$fReadDual5_bytes:
         I8[] [68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.602456553 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual4_closure" {
     Data.Semigroup.Internal.$fReadDual4_closure:
         const Data.Semigroup.Internal.$fReadDual4_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadDual4_entry() //  [R1]
         { info_tbl: [(c6CRN,
                       label: Data.Semigroup.Internal.$fReadDual4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CRN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CRO; else goto c6CRP;
       c6CRO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CRP: // global
           (_c6CRK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CRK::I64 == 0) goto c6CRM; else goto c6CRL;
       c6CRM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CRL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CRK::I64;
           R2 = Data.Semigroup.Internal.$fReadDual5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.607049317 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_lexeme_closure" {
     Data.Semigroup.Internal.$fReadDual_lexeme_closure:
         const Text.Read.Lex.Ident_con_info;
         const Data.Semigroup.Internal.$fReadDual4_closure;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.60893299 UTC

[section ""cstring" . Data.Semigroup.Internal.$fReadDual3_bytes" {
     Data.Semigroup.Internal.$fReadDual3_bytes:
         I8[] [103,101,116,68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.610998255 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual2_closure" {
     Data.Semigroup.Internal.$fReadDual2_closure:
         const Data.Semigroup.Internal.$fReadDual2_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.$fReadDual2_entry() //  [R1]
         { info_tbl: [(c6CS6,
                       label: Data.Semigroup.Internal.$fReadDual2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CS6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CS7; else goto c6CS8;
       c6CS7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CS8: // global
           (_c6CS3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6CS3::I64 == 0) goto c6CS5; else goto c6CS4;
       c6CS5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6CS4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6CS3::I64;
           R2 = Data.Semigroup.Internal.$fReadDual3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.617116923 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual1_closure" {
     Data.Semigroup.Internal.$fReadDual1_closure:
         const Data.Semigroup.Internal.$fReadDual1_info;
         const 0;
 },
 lvl12_s6AWf_entry() //  [R1]
         { info_tbl: [(c6CSp,
                       label: lvl12_s6AWf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CSp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6CSq; else goto c6CSr;
       c6CSq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CSr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           Sp = Sp - 32;
           call GHC.Read.readPrec_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds_s6AWg_entry() //  [R1]
         { info_tbl: [(c6CSx,
                       label: ds_s6AWg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CSx: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AWr_entry() //  [R1]
         { info_tbl: [(c6CT8,
                       label: sat_s6AWr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CT8: // global
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AWu_entry() //  [R1, R2]
         { info_tbl: [(c6CTe,
                       label: sat_s6AWu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CTe: // global
           _s6AWp::P64 = R2;
           _s6AWu::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6CTf; else goto c6CTg;
       c6CTg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CTi; else goto c6CTh;
       c6CTi: // global
           HpAlloc = 24;
           goto c6CTf;
       c6CTf: // global
           R2 = _s6AWp::P64;
           R1 = _s6AWu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CTh: // global
           _s6AWj::P64 = P64[_s6AWu::P64 + 7];
           I64[Hp - 16] = sat_s6AWr_info;
           P64[Hp - 8] = _s6AWj::P64;
           P64[Hp] = _s6AWp::P64;
           I64[Sp - 8] = block_c6CTb_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll3_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6CTb() //  [R1]
         { info_tbl: [(c6CTb,
                       label: block_c6CTb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CTb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CTl; else goto c6CTk;
       c6CTl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6CTk: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6CTX_srtd" {
     u6CTX_srtd:
         const S6Bb6_srt+128;
         const 70;
         const 6597069766657;
         const 32;
 },
 sat_s6AWv_entry() //  [R1, R2]
         { info_tbl: [(c6CTm,
                       label: sat_s6AWv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CTm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CTq; else goto c6CTp;
       c6CTq: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CTp: // global
           _s6AWg::P64 = P64[R1 + 7];
           _s6AWj::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s6AWu_info;
           P64[Hp] = _s6AWj::P64;
           R5 = Hp - 7;
           R4 = Data.Semigroup.Internal.$fReadAll6_closure+1;
           R3 = _s6AWg::P64;
           R2 = Data.Semigroup.Internal.$fReadDual2_closure;
           call GHC.Read.readField_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6CTY_srtd" {
     u6CTY_srtd:
         const S6Bb6_srt+128;
         const 70;
         const 6597069766661;
         const 32;
 },
 sat_s6AWy_entry() //  [R1, R2]
         { info_tbl: [(c6CTu,
                       label: sat_s6AWy_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CTu: // global
           _s6AWn::P64 = R2;
           _s6AWy::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto c6CTv; else goto c6CTw;
       c6CTw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CTy; else goto c6CTx;
       c6CTy: // global
           HpAlloc = 24;
           goto c6CTv;
       c6CTv: // global
           R2 = _s6AWn::P64;
           R1 = _s6AWy::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CTx: // global
           _s6AWg::P64 = P64[_s6AWy::P64 + 7];
           _s6AWj::P64 = P64[_s6AWy::P64 + 15];
           I64[Hp - 16] = sat_s6AWv_info;
           P64[Hp - 8] = _s6AWg::P64;
           P64[Hp] = _s6AWj::P64;
           I64[Sp - 8] = block_c6CTr_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadAll_lexeme_closure+3;
           Sp = Sp - 8;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6CTr() //  [R1]
         { info_tbl: [(c6CTr,
                       label: block_c6CTr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CTr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CTB; else goto c6CTA;
       c6CTB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6CTA: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6CTZ_srtd" {
     u6CTZ_srtd:
         const S6Bb6_srt+128;
         const 71;
         const 6597069766661;
         const 96;
 },
 sat_s6AWB_entry() //  [R1, R2, R3]
         { info_tbl: [(c6CTC,
                       label: sat_s6AWB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CTC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6CTD; else goto c6CTE;
       c6CTD: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6CTE: // global
           I64[Sp - 24] = block_c6CSF_info;
           _s6AWg::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s6AWg::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u6CTR; else goto c6CSG;
       u6CTR: // global
           call _c6CSF(R1) args: 0, res: 0, upd: 0;
       c6CSG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u6CU0_srtd" {
     u6CU0_srtd:
         const S6Bb6_srt+128;
         const 71;
         const 6597069766661;
         const 96;
 },
 _c6CSF() //  [R1]
         { info_tbl: [(c6CSF,
                       label: block_c6CSF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CSF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CTH; else goto c6CTG;
       c6CTH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6CTG: // global
           if (%MO_S_Gt_W64(I64[R1 + 7], 11)) goto c6CTJ; else goto c6CTN;
       c6CTJ: // global
           Hp = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.Fail_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6CTN: // global
           I64[Hp - 16] = sat_s6AWy_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_c6CTK_info;
           R3 = Hp - 15;
           R2 = Data.Semigroup.Internal.$fReadDual_lexeme_closure+4;
           Sp = Sp + 16;
           call Text.Read.Lex.$wexpect_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6CTK() //  [R1]
         { info_tbl: [(c6CTK,
                       label: block_c6CTK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CTK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6CTQ; else goto c6CTP;
       c6CTQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6CTP: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u6CU1_srtd" {
     u6CU1_srtd:
         const S6Bb6_srt+128;
         const 72;
         const 7696581394437;
         const 224;
 },
 Data.Semigroup.Internal.$fReadDual1_entry() //  [R2]
         { info_tbl: [(c6CTS,
                       label: Data.Semigroup.Internal.$fReadDual1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CTS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6CTW; else goto c6CTV;
       c6CTW: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CTV: // global
           I64[Hp - 48] = lvl12_s6AWf_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = ds_s6AWg_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s6AWB_info;
           P64[Hp] = Hp - 23;
           R2 = Hp - 6;
           R1 = GHC.Read.list3_closure+3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.649789335 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadsPrec_info;
         const 0;
 },
 ds_s6AWD_entry() //  [R1]
         { info_tbl: [(c6CVm,
                       label: ds_s6AWD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CVm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CVn; else goto c6CVo;
       c6CVn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CVo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AWF_entry() //  [R1]
         { info_tbl: [(c6CVy,
                       label: sat_s6AWF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CVy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CVz; else goto c6CVA;
       c6CVz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CVA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AWG_entry() //  [R1, R2]
         { info_tbl: [(c6CVB,
                       label: sat_s6AWG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CVB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6CVF; else goto c6CVE;
       c6CVF: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CVE: // global
           _s6AWD::P64 = P64[R1 + 7];
           I64[Hp - 24] = sat_s6AWF_info;
           P64[Hp - 8] = _s6AWD::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c6CVG,
                       label: Data.Semigroup.Internal.$fReadDual_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CVG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6CVK; else goto c6CVJ;
       c6CVK: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CVJ: // global
           I64[Hp - 32] = ds_s6AWD_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s6AWG_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.660331511 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadListPrec_info;
         const 0;
 },
 sat_s6AWI_entry() //  [R1]
         { info_tbl: [(c6CWh,
                       label: sat_s6AWI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CWh: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadListPrec_entry() //  [R2]
         { info_tbl: [(c6CWk,
                       label: Data.Semigroup.Internal.$fReadDual_$creadListPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CWk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CWo; else goto c6CWn;
       c6CWo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CWn: // global
           I64[Hp - 16] = sat_s6AWI_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Read.list_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.666880847 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_$creadList_closure" {
     Data.Semigroup.Internal.$fReadDual_$creadList_closure:
         const Data.Semigroup.Internal.$fReadDual_$creadList_info;
         const 0;
 },
 sat_s6AWK_entry() //  [R1]
         { info_tbl: [(c6CWJ,
                       label: sat_s6AWK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CWJ: // global
           R2 = P64[R1 + 16];
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AWL_entry() //  [R1]
         { info_tbl: [(c6CWM,
                       label: sat_s6AWL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CWM: // global
           _s6AWL::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto c6CWN; else goto c6CWO;
       c6CWO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CWQ; else goto c6CWP;
       c6CWQ: // global
           HpAlloc = 24;
           goto c6CWN;
       c6CWN: // global
           R1 = _s6AWL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CWP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s6AWL::P64;
           _s6AWJ::P64 = P64[_s6AWL::P64 + 16];
           I64[Hp - 16] = sat_s6AWK_info;
           P64[Hp] = _s6AWJ::P64;
           R2 = Hp - 16;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Read.$fRead()7_closure;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadDual_$creadList_entry() //  [R2]
         { info_tbl: [(c6CWR,
                       label: Data.Semigroup.Internal.$fReadDual_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CWR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CWV; else goto c6CWU;
       c6CWV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_$creadList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CWU: // global
           I64[Hp - 16] = sat_s6AWL_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.675733039 UTC

[section ""data" . Data.Semigroup.Internal.$fReadDual_closure" {
     Data.Semigroup.Internal.$fReadDual_closure:
         const Data.Semigroup.Internal.$fReadDual_info;
         const 0;
 },
 sat_s6AWQ_entry() //  [R1]
         { info_tbl: [(c6CXn,
                       label: sat_s6AWQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CXn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CXo; else goto c6CXp;
       c6CXo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CXp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadListPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AWP_entry() //  [R1]
         { info_tbl: [(c6CXu,
                       label: sat_s6AWP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CXu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CXv; else goto c6CXw;
       c6CXv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CXw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AWO_entry() //  [R1]
         { info_tbl: [(c6CXB,
                       label: sat_s6AWO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CXB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CXC; else goto c6CXD;
       c6CXC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CXD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AWN_entry() //  [R1]
         { info_tbl: [(c6CXI,
                       label: sat_s6AWN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CXI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CXJ; else goto c6CXK;
       c6CXJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CXK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fReadDual_$creadsPrec_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fReadDual_entry() //  [R2]
         { info_tbl: [(c6CXM,
                       label: Data.Semigroup.Internal.$fReadDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CXM: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto c6CXQ; else goto c6CXP;
       c6CXQ: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fReadDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CXP: // global
           I64[Hp - 128] = sat_s6AWQ_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6AWP_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6AWO_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6AWN_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Read.C:Read_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.689075268 UTC

[section ""data" . Data.Semigroup.Internal.$fEqDual_closure" {
     Data.Semigroup.Internal.$fEqDual_closure:
         const Data.Semigroup.Internal.$fEqDual_info;
 },
 sat_s6AWT_entry() //  [R1]
         { info_tbl: [(c6CYx,
                       label: sat_s6AWT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CYx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CYy; else goto c6CYz;
       c6CYy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CYz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes./=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AWS_entry() //  [R1]
         { info_tbl: [(c6CYE,
                       label: sat_s6AWS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CYE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CYF; else goto c6CYG;
       c6CYF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CYG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fEqDual_entry() //  [R2]
         { info_tbl: [(c6CYI,
                       label: Data.Semigroup.Internal.$fEqDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CYI: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6CYM; else goto c6CYL;
       c6CYM: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fEqDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CYL: // global
           I64[Hp - 64] = sat_s6AWT_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s6AWS_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.697670589 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure" {
     Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure:
         const Data.Semigroup.Internal.$fOrdDual_$cp1Ord_info;
 },
 sat_s6AWV_entry() //  [R1]
         { info_tbl: [(c6CZf,
                       label: sat_s6AWV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CZf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CZg; else goto c6CZh;
       c6CZg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CZh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdDual_$cp1Ord_entry() //  [R2]
         { info_tbl: [(c6CZi,
                       label: Data.Semigroup.Internal.$fOrdDual_$cp1Ord_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CZi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6CZm; else goto c6CZl;
       c6CZm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdDual_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6CZl: // global
           I64[Hp - 16] = sat_s6AWV_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call Data.Semigroup.Internal.$fEqDual_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.70442554 UTC

[section ""data" . Data.Semigroup.Internal.$fOrdDual_closure" {
     Data.Semigroup.Internal.$fOrdDual_closure:
         const Data.Semigroup.Internal.$fOrdDual_info;
 },
 sat_s6AX4_entry() //  [R1]
         { info_tbl: [(c6CZF,
                       label: sat_s6AX4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CZF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CZG; else goto c6CZH;
       c6CZG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CZH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.min_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AX3_entry() //  [R1]
         { info_tbl: [(c6CZM,
                       label: sat_s6AX3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CZM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CZN; else goto c6CZO;
       c6CZN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CZO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.max_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AX2_entry() //  [R1]
         { info_tbl: [(c6CZT,
                       label: sat_s6AX2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6CZT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6CZU; else goto c6CZV;
       c6CZU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6CZV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AX1_entry() //  [R1]
         { info_tbl: [(c6D00,
                       label: sat_s6AX1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D00: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6D01; else goto c6D02;
       c6D01: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6D02: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AX0_entry() //  [R1]
         { info_tbl: [(c6D07,
                       label: sat_s6AX0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D07: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6D08; else goto c6D09;
       c6D08: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6D09: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<=_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AWZ_entry() //  [R1]
         { info_tbl: [(c6D0e,
                       label: sat_s6AWZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D0e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6D0f; else goto c6D0g;
       c6D0f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6D0g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AWY_entry() //  [R1]
         { info_tbl: [(c6D0l,
                       label: sat_s6AWY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D0l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6D0m; else goto c6D0n;
       c6D0m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6D0n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AWX_entry() //  [R1]
         { info_tbl: [(c6D0s,
                       label: sat_s6AWX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D0s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6D0t; else goto c6D0u;
       c6D0t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6D0u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fOrdDual_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fOrdDual_entry() //  [R2]
         { info_tbl: [(c6D0w,
                       label: Data.Semigroup.Internal.$fOrdDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D0w: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto c6D0A; else goto c6D0z;
       c6D0A: // global
           HpAlloc = 264;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fOrdDual_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6D0z: // global
           I64[Hp - 256] = sat_s6AX4_info;
           P64[Hp - 240] = R2;
           I64[Hp - 232] = sat_s6AX3_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s6AX2_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s6AX1_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = sat_s6AX0_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s6AWZ_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s6AWY_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s6AWX_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 160;
           P64[Hp - 24] = Hp - 184;
           P64[Hp - 16] = Hp - 208;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 256;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.724951316 UTC

[section ""data" . Data.Semigroup.Internal.getDual_closure" {
     Data.Semigroup.Internal.getDual_closure:
         const Data.Semigroup.Internal.getDual_info;
 },
 Data.Semigroup.Internal.getDual_entry() //  [R2]
         { info_tbl: [(c6D1F,
                       label: Data.Semigroup.Internal.getDual_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D1F: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Dual2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.729532011 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadDual_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadDual_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadDual_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6D1Q,
                       label: Data.Semigroup.Internal.$fMonadDual_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D1Q: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.733193442 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadDual_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadDual_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadDual_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6D21,
                       label: Data.Semigroup.Internal.$fMonadDual_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D21: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeDual_$c*>_entry(R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.736766325 UTC

[section ""data" . lvl_r6v16_closure" {
     lvl_r6v16_closure:
         const lvl_r6v16_info;
         const 0;
 },
 lvl_r6v16_entry() //  [R2]
         { info_tbl: [(c6D2c,
                       label: lvl_r6v16_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D2c: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.740539935 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadDual_closure" {
     Data.Semigroup.Internal.$fMonadDual_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeDual_closure+1;
         const Data.Semigroup.Internal.$fMonadDual_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadDual_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl_r6v16_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.742655852 UTC

[section ""data" . Data.Semigroup.Internal.appEndo1_closure" {
     Data.Semigroup.Internal.appEndo1_closure:
         const Data.Semigroup.Internal.appEndo1_info;
 },
 Data.Semigroup.Internal.appEndo1_entry() //  [R2]
         { info_tbl: [(c6D2o,
                       label: Data.Semigroup.Internal.appEndo1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D2o: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.746219761 UTC

[section ""data" . Data.Semigroup.Internal.appEndo_closure" {
     Data.Semigroup.Internal.appEndo_closure:
         const Data.Semigroup.Internal.appEndo_info;
 },
 Data.Semigroup.Internal.appEndo_entry() //  [R2]
         { info_tbl: [(c6D2z,
                       label: Data.Semigroup.Internal.appEndo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D2z: // global
           R2 = R2;
           call Data.Semigroup.Internal.appEndo1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.749786381 UTC

[section ""data" . Data.Semigroup.Internal.getAll1_closure" {
     Data.Semigroup.Internal.getAll1_closure:
         const Data.Semigroup.Internal.getAll1_info;
 },
 Data.Semigroup.Internal.getAll1_entry() //  [R2]
         { info_tbl: [(c6D2K,
                       label: Data.Semigroup.Internal.getAll1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D2K: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.753686802 UTC

[section ""data" . Data.Semigroup.Internal.getAll_closure" {
     Data.Semigroup.Internal.getAll_closure:
         const Data.Semigroup.Internal.getAll_info;
 },
 Data.Semigroup.Internal.getAll_entry() //  [R2]
         { info_tbl: [(c6D2X,
                       label: Data.Semigroup.Internal.getAll_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D2X: // global
           R2 = R2;
           call Data.Semigroup.Internal.getAll1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.757334099 UTC

[section ""data" . Data.Semigroup.Internal.getAny1_closure" {
     Data.Semigroup.Internal.getAny1_closure:
         const Data.Semigroup.Internal.getAny1_info;
 },
 Data.Semigroup.Internal.getAny1_entry() //  [R2]
         { info_tbl: [(c6D38,
                       label: Data.Semigroup.Internal.getAny1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D38: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.761783532 UTC

[section ""data" . Data.Semigroup.Internal.getAny_closure" {
     Data.Semigroup.Internal.getAny_closure:
         const Data.Semigroup.Internal.getAny_info;
 },
 Data.Semigroup.Internal.getAny_entry() //  [R2]
         { info_tbl: [(c6D3l,
                       label: Data.Semigroup.Internal.getAny_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D3l: // global
           R2 = R2;
           call Data.Semigroup.Internal.getAny1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.765152045 UTC

[section ""data" . Data.Semigroup.Internal.getSum_closure" {
     Data.Semigroup.Internal.getSum_closure:
         const Data.Semigroup.Internal.getSum_info;
 },
 Data.Semigroup.Internal.getSum_entry() //  [R2]
         { info_tbl: [(c6D3w,
                       label: Data.Semigroup.Internal.getSum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D3w: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Sum2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.769065292 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadSum_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadSum_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadSum_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6D3H,
                       label: Data.Semigroup.Internal.$fMonadSum_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D3H: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.772674842 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadSum_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadSum_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadSum_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6D3S,
                       label: Data.Semigroup.Internal.$fMonadSum_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D3S: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeSum_$c*>_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.776276503 UTC

[section ""data" . lvl1_r6v17_closure" {
     lvl1_r6v17_closure:
         const lvl1_r6v17_info;
         const 0;
 },
 lvl1_r6v17_entry() //  [R2]
         { info_tbl: [(c6D43,
                       label: lvl1_r6v17_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D43: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.779777177 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadSum_closure" {
     Data.Semigroup.Internal.$fMonadSum_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeSum_closure+1;
         const Data.Semigroup.Internal.$fMonadSum_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadSum_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl1_r6v17_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.782128757 UTC

[section ""data" . Data.Semigroup.Internal.getProduct_closure" {
     Data.Semigroup.Internal.getProduct_closure:
         const Data.Semigroup.Internal.getProduct_info;
 },
 Data.Semigroup.Internal.getProduct_entry() //  [R2]
         { info_tbl: [(c6D4f,
                       label: Data.Semigroup.Internal.getProduct_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D4f: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Product2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.785721315 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure" {
     Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure:
         const Data.Semigroup.Internal.$fMonadProduct_$c>>=_info;
 },
 Data.Semigroup.Internal.$fMonadProduct_$c>>=_entry() //  [R2, R3]
         { info_tbl: [(c6D4q,
                       label: Data.Semigroup.Internal.$fMonadProduct_$c>>=_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D4q: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.789389453 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_$c>>_closure" {
     Data.Semigroup.Internal.$fMonadProduct_$c>>_closure:
         const Data.Semigroup.Internal.$fMonadProduct_$c>>_info;
 },
 Data.Semigroup.Internal.$fMonadProduct_$c>>_entry() //  [R2, R3]
         { info_tbl: [(c6D4B,
                       label: Data.Semigroup.Internal.$fMonadProduct_$c>>_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D4B: // global
           R3 = R3;
           R2 = R2;
           call Data.Semigroup.Internal.$fApplicativeProduct_$c*>_entry(R3,
                                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.793756163 UTC

[section ""data" . lvl2_r6v18_closure" {
     lvl2_r6v18_closure:
         const lvl2_r6v18_info;
         const 0;
 },
 lvl2_r6v18_entry() //  [R2]
         { info_tbl: [(c6D4M,
                       label: lvl2_r6v18_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D4M: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.797185311 UTC

[section ""data" . Data.Semigroup.Internal.$fMonadProduct_closure" {
     Data.Semigroup.Internal.$fMonadProduct_closure:
         const GHC.Base.C:Monad_con_info;
         const Data.Semigroup.Internal.$fApplicativeProduct_closure+1;
         const Data.Semigroup.Internal.$fMonadProduct_$c>>=_closure+2;
         const Data.Semigroup.Internal.$fMonadProduct_$c>>_closure+2;
         const Data.Semigroup.Internal.$fApplicativeDual4_closure+1;
         const lvl2_r6v18_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.799849194 UTC

[section ""data" . Data.Semigroup.Internal.getAlt_closure" {
     Data.Semigroup.Internal.getAlt_closure:
         const Data.Semigroup.Internal.getAlt_info;
 },
 Data.Semigroup.Internal.getAlt_entry() //  [R2]
         { info_tbl: [(c6D4Y,
                       label: Data.Semigroup.Internal.getAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D4Y: // global
           R2 = R2;
           call Data.Semigroup.Internal.$fGeneric1Alt2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.803118579 UTC

[section ""cstring" . lvl3_r6v19_bytes" {
     lvl3_r6v19_bytes:
         I8[] [115,116,105,109,101,115,73,100,101,109,112,111,116,101,110,116,58,32,112,111,115,105,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114,32,101,120,112,101,99,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.805198482 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotent1_closure" {
     Data.Semigroup.Internal.stimesIdempotent1_closure:
         const Data.Semigroup.Internal.stimesIdempotent1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesIdempotent1_entry() //  [R1]
         { info_tbl: [(c6D5e,
                       label: Data.Semigroup.Internal.stimesIdempotent1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D5e: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6D5f; else goto c6D5g;
       c6D5f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6D5g: // global
           (_c6D59::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6D59::I64 == 0) goto c6D5b; else goto c6D5a;
       c6D5b: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6D5a: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6D59::I64;
           I64[Sp - 24] = block_c6D5c_info;
           R2 = lvl3_r6v19_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6D5c() //  [R1]
         { info_tbl: [(c6D5c,
                       label: block_c6D5c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D5c: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.811886693 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotent_closure" {
     Data.Semigroup.Internal.stimesIdempotent_closure:
         const Data.Semigroup.Internal.stimesIdempotent_info;
         const 0;
 },
 sat_s6AXo_entry() //  [R1]
         { info_tbl: [(c6D5K,
                       label: sat_s6AXo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D5K: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6D5L; else goto c6D5M;
       c6D5L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6D5M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6D5I_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6D5I() //  [R1]
         { info_tbl: [(c6D5I,
                       label: block_c6D5I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D5I: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesIdempotent_entry() //  [R2, R3, R4]
         { info_tbl: [(c6D5Q,
                       label: Data.Semigroup.Internal.stimesIdempotent_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D5Q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6D5S; else goto c6D5T;
       c6D5S: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotent_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6D5T: // global
           I64[Sp - 24] = block_c6D5A_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6D5A() //  [R1]
         { info_tbl: [(c6D5A,
                       label: block_c6D5A_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D5A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6D5W; else goto c6D5V;
       c6D5W: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6D5V: // global
           I64[Hp - 16] = sat_s6AXo_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6D5R_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6D5R() //  [R1]
         { info_tbl: [(c6D5R,
                       label: block_c6D5R_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D5R: // global
           _s6AXj::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c6D60_info;
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s6AXj::P64;
           Sp = Sp - 8;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6D60() //  [R1]
         { info_tbl: [(c6D60,
                       label: block_c6D60_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D60: // global
           if (R1 & 7 == 1) goto c6D67; else goto c6D6b;
       c6D67: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6D6b: // global
           R1 = Data.Semigroup.Internal.stimesIdempotent1_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.825157319 UTC

[section ""cstring" . lvl4_r6v1a_bytes" {
     lvl4_r6v1a_bytes:
         I8[] [115,116,105,109,101,115,73,100,101,109,112,111,116,101,110,116,77,111,110,111,105,100,58,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.828699443 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotentMonoid1_closure" {
     Data.Semigroup.Internal.stimesIdempotentMonoid1_closure:
         const Data.Semigroup.Internal.stimesIdempotentMonoid1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesIdempotentMonoid1_entry() //  [R1]
         { info_tbl: [(c6D6T,
                       label: Data.Semigroup.Internal.stimesIdempotentMonoid1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D6T: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6D6U; else goto c6D6V;
       c6D6U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6D6V: // global
           (_c6D6O::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6D6O::I64 == 0) goto c6D6Q; else goto c6D6P;
       c6D6Q: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6D6P: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6D6O::I64;
           I64[Sp - 24] = block_c6D6R_info;
           R2 = lvl4_r6v1a_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6D6R() //  [R1]
         { info_tbl: [(c6D6R,
                       label: block_c6D6R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D6R: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.835532835 UTC

[section ""data" . Data.Semigroup.Internal.stimesIdempotentMonoid_closure" {
     Data.Semigroup.Internal.stimesIdempotentMonoid_closure:
         const Data.Semigroup.Internal.stimesIdempotentMonoid_info;
         const 0;
 },
 sat_s6AXy_entry() //  [R1]
         { info_tbl: [(c6D7p,
                       label: sat_s6AXy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D7p: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6D7q; else goto c6D7r;
       c6D7q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6D7r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6D7n_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6D7n() //  [R1]
         { info_tbl: [(c6D7n,
                       label: block_c6D7n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D7n: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesIdempotentMonoid_entry() //  [R2, R3,
                                                             R4, R5]
         { info_tbl: [(c6D7v,
                       label: Data.Semigroup.Internal.stimesIdempotentMonoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D7v: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c6D7x; else goto c6D7y;
       c6D7x: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6D7y: // global
           I64[Sp - 32] = block_c6D7f_info;
           R2 = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6D7f() //  [R1]
         { info_tbl: [(c6D7f,
                       label: block_c6D7f_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D7f: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6D7B; else goto c6D7A;
       c6D7B: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6D7A: // global
           I64[Hp - 16] = sat_s6AXy_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6D7w_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6D7w() //  [R1]
         { info_tbl: [(c6D7w,
                       label: block_c6D7w_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D7w: // global
           _c6D7j::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6D7F_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = _c6D7j::P64;
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6D7F() //  [R1]
         { info_tbl: [(c6D7F,
                       label: block_c6D7F_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D7F: // global
           _c6D7V::P64 = R1 & 7;
           if (_c6D7V::P64 < 3) goto u6D7W; else goto c6D7U;
       u6D7W: // global
           if (_c6D7V::P64 < 2) goto c6D7M; else goto c6D7Q;
       c6D7M: // global
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid1_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6D7Q: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
       c6D7U: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.850573486 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_go_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_go_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_go_info;
 },
 Data.Semigroup.Internal.$fSemigroupAny_go_entry() //  [R2, R3]
         { info_tbl: [(c6D8F,
                       label: Data.Semigroup.Internal.$fSemigroupAny_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D8F: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6D8G; else goto u6D91;
       c6D8G: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAny_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6D91: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6D8v() args: 0, res: 0, upd: 0;
     }
 },
 _c6D8v() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D8v: // global
           I64[Sp - 8] = block_c6D8y_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6D93; else goto c6D8z;
       u6D93: // global
           call _c6D8y(R1) args: 0, res: 0, upd: 0;
       c6D8z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6D8y() //  [R1]
         { info_tbl: [(c6D8y,
                       label: block_c6D8y_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D8y: // global
           _s6AXA::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6D8C; else goto c6D8D;
       c6D8C: // global
           R1 = _s6AXA::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6D8D: // global
           I64[Sp] = block_c6D8N_info;
           _s6AXD::P64 = P64[R1 + 6];
           _s6AXE::P64 = P64[R1 + 14];
           R1 = _s6AXA::P64;
           P64[Sp + 8] = _s6AXE::P64;
           P64[Sp + 16] = _s6AXD::P64;
           if (R1 & 7 != 0) goto u6D94; else goto c6D8P;
       u6D94: // global
           call _c6D8N(R1) args: 0, res: 0, upd: 0;
       c6D8P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6D8N() //  [R1]
         { info_tbl: [(c6D8N,
                       label: block_c6D8N_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D8N: // global
           if (R1 & 7 == 1) goto c6D8V; else goto c6D8Z;
       c6D8V: // global
           _s6AXB::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6AXB::P64;
           Sp = Sp + 8;
           call _c6D8v() args: 0, res: 0, upd: 0;
       c6D8Z: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.860053897 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAny_$csconcat_entry() //  [R2]
         { info_tbl: [(c6D9E,
                       label: Data.Semigroup.Internal.$fSemigroupAny_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D9E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6D9F; else goto c6D9G;
       c6D9F: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6D9G: // global
           I64[Sp - 8] = block_c6D9B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6D9K; else goto c6D9C;
       u6D9K: // global
           call _c6D9B(R1) args: 0, res: 0, upd: 0;
       c6D9C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6D9B() //  [R1]
         { info_tbl: [(c6D9B,
                       label: block_c6D9B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D9B: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupAny_go_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.86644792 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAny_go_closure" {
     Data.Semigroup.Internal.$fMonoidAny_go_closure:
         const Data.Semigroup.Internal.$fMonoidAny_go_info;
 },
 Data.Semigroup.Internal.$fMonoidAny_go_entry() //  [R2]
         { info_tbl: [(c6Da6,
                       label: Data.Semigroup.Internal.$fMonoidAny_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Da6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Da7; else goto u6Das;
       c6Da7: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAny_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6Das: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6D9W() args: 0, res: 0, upd: 0;
     }
 },
 _c6D9W() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D9W: // global
           _s6AXK::P64 = P64[Sp];
           I64[Sp] = block_c6D9Z_info;
           R1 = _s6AXK::P64;
           if (R1 & 7 != 0) goto u6Dau; else goto c6Da0;
       u6Dau: // global
           call _c6D9Z(R1) args: 0, res: 0, upd: 0;
       c6Da0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6D9Z() //  [R1]
         { info_tbl: [(c6D9Z,
                       label: block_c6D9Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6D9Z: // global
           if (R1 & 7 == 1) goto c6Da3; else goto c6Da4;
       c6Da3: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Da4: // global
           I64[Sp - 8] = block_c6Dae_info;
           _s6AXN::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6AXN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Dav; else goto c6Dag;
       u6Dav: // global
           call _c6Dae(R1) args: 0, res: 0, upd: 0;
       c6Dag: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dae() //  [R1]
         { info_tbl: [(c6Dae,
                       label: block_c6Dae_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dae: // global
           if (R1 & 7 == 1) goto c6Dam; else goto c6Daq;
       c6Dam: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6D9W() args: 0, res: 0, upd: 0;
       c6Daq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.876287686 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAny_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Classes.||_closure+2;
         const Data.Semigroup.Internal.$fSemigroupAny_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAny_closure" {
     Data.Semigroup.Internal.$fMonoidAny_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupAny_closure+1;
         const GHC.Types.False_closure+1;
         const GHC.Classes.||_closure+2;
         const Data.Semigroup.Internal.$fMonoidAny_go_closure+1;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAny_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAny_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupAny_$cstimes_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(c6Db2,
                       label: Data.Semigroup.Internal.$fSemigroupAny_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Db2: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidAny_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.882329351 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_go_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_go_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_go_info;
 },
 Data.Semigroup.Internal.$fSemigroupAll_go_entry() //  [R2, R3]
         { info_tbl: [(c6Dbm,
                       label: Data.Semigroup.Internal.$fSemigroupAll_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dbm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Dbn; else goto u6DbI;
       c6Dbn: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAll_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       u6DbI: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _c6Dbc() args: 0, res: 0, upd: 0;
     }
 },
 _c6Dbc() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dbc: // global
           I64[Sp - 8] = block_c6Dbf_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6DbK; else goto c6Dbg;
       u6DbK: // global
           call _c6Dbf(R1) args: 0, res: 0, upd: 0;
       c6Dbg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dbf() //  [R1]
         { info_tbl: [(c6Dbf,
                       label: block_c6Dbf_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dbf: // global
           _s6AXQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6Dbj; else goto c6Dbk;
       c6Dbj: // global
           R1 = _s6AXQ::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c6Dbk: // global
           I64[Sp] = block_c6Dbu_info;
           _s6AXT::P64 = P64[R1 + 6];
           _s6AXU::P64 = P64[R1 + 14];
           R1 = _s6AXQ::P64;
           P64[Sp + 8] = _s6AXU::P64;
           P64[Sp + 16] = _s6AXT::P64;
           if (R1 & 7 != 0) goto u6DbL; else goto c6Dbw;
       u6DbL: // global
           call _c6Dbu(R1) args: 0, res: 0, upd: 0;
       c6Dbw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dbu() //  [R1]
         { info_tbl: [(c6Dbu,
                       label: block_c6Dbu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dbu: // global
           if (R1 & 7 == 1) goto c6DbC; else goto c6DbG;
       c6DbC: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6DbG: // global
           _s6AXR::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s6AXR::P64;
           Sp = Sp + 8;
           call _c6Dbc() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.891444488 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAll_$csconcat_entry() //  [R2]
         { info_tbl: [(c6Dcl,
                       label: Data.Semigroup.Internal.$fSemigroupAll_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dcl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6Dcm; else goto c6Dcn;
       c6Dcm: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Dcn: // global
           I64[Sp - 8] = block_c6Dci_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Dcr; else goto c6Dcj;
       u6Dcr: // global
           call _c6Dci(R1) args: 0, res: 0, upd: 0;
       c6Dcj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dci() //  [R1]
         { info_tbl: [(c6Dci,
                       label: block_c6Dci_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dci: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupAll_go_entry(R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.897411025 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAll_go_closure" {
     Data.Semigroup.Internal.$fMonoidAll_go_closure:
         const Data.Semigroup.Internal.$fMonoidAll_go_info;
 },
 Data.Semigroup.Internal.$fMonoidAll_go_entry() //  [R2]
         { info_tbl: [(c6DcN,
                       label: Data.Semigroup.Internal.$fMonoidAll_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DcN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6DcO; else goto u6Dd9;
       c6DcO: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAll_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u6Dd9: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c6DcD() args: 0, res: 0, upd: 0;
     }
 },
 _c6DcD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DcD: // global
           _s6AY0::P64 = P64[Sp];
           I64[Sp] = block_c6DcG_info;
           R1 = _s6AY0::P64;
           if (R1 & 7 != 0) goto u6Ddb; else goto c6DcH;
       u6Ddb: // global
           call _c6DcG(R1) args: 0, res: 0, upd: 0;
       c6DcH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6DcG() //  [R1]
         { info_tbl: [(c6DcG,
                       label: block_c6DcG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DcG: // global
           if (R1 & 7 == 1) goto c6DcK; else goto c6DcL;
       c6DcK: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6DcL: // global
           I64[Sp - 8] = block_c6DcV_info;
           _s6AY3::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s6AY3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6Ddc; else goto c6DcX;
       u6Ddc: // global
           call _c6DcV(R1) args: 0, res: 0, upd: 0;
       c6DcX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6DcV() //  [R1]
         { info_tbl: [(c6DcV,
                       label: block_c6DcV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DcV: // global
           if (R1 & 7 == 1) goto c6Dd3; else goto c6Dd7;
       c6Dd3: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c6Dd7: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6DcD() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.906259948 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAll_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Classes.&&_closure+2;
         const Data.Semigroup.Internal.$fSemigroupAll_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAll_closure" {
     Data.Semigroup.Internal.$fMonoidAll_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupAll_closure+1;
         const GHC.Types.True_closure+2;
         const GHC.Classes.&&_closure+2;
         const Data.Semigroup.Internal.$fMonoidAll_go_closure+1;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAll_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAll_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupAll_$cstimes_entry() //  [R2,
                                                              R3, R4]
         { info_tbl: [(c6DdJ,
                       label: Data.Semigroup.Internal.$fSemigroupAll_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DdJ: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidAll_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesIdempotentMonoid_entry(R5,
                                                                     R4,
                                                                     R3,
                                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.912248302 UTC

[section ""cstring" . lvl5_r6v1b_bytes" {
     lvl5_r6v1b_bytes:
         I8[] [115,116,105,109,101,115,77,111,110,111,105,100,58,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.914310917 UTC

[section ""data" . lvl6_r6v1c_closure" {
     lvl6_r6v1c_closure:
         const lvl6_r6v1c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r6v1c_entry() //  [R1]
         { info_tbl: [(c6De1,
                       label: lvl6_r6v1c_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6De1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6De2; else goto c6De3;
       c6De2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6De3: // global
           (_c6DdW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6DdW::I64 == 0) goto c6DdY; else goto c6DdX;
       c6DdY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6DdX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6DdW::I64;
           I64[Sp - 24] = block_c6DdZ_info;
           R2 = lvl5_r6v1b_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6DdZ() //  [R1]
         { info_tbl: [(c6DdZ,
                       label: block_c6DdZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DdZ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.919723746 UTC

[section ""data" . sat_s6AY7_closure" {
     sat_s6AY7_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.92190179 UTC

[section ""data" . sat_s6AY8_closure" {
     sat_s6AY8_closure:
         const :_con_info;
         const sat_s6AY7_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.923834942 UTC

[section ""data" . lvl7_r6v1d_closure" {
     lvl7_r6v1d_closure:
         const lvl7_r6v1d_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_r6v1d_entry() //  [R1]
         { info_tbl: [(c6Der,
                       label: lvl7_r6v1d_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Der: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Des; else goto c6Det;
       c6Des: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Det: // global
           (_c6Deo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6Deo::I64 == 0) goto c6Deq; else goto c6Dep;
       c6Deq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6Dep: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6Deo::I64;
           R3 = sat_s6AY8_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.931581969 UTC

[section ""data" . Data.Semigroup.Internal.stimesMonoid_closure" {
     Data.Semigroup.Internal.stimesMonoid_closure:
         const Data.Semigroup.Internal.stimesMonoid_info;
         const 0;
 },
 sat_s6AYg_entry() //  [R1]
         { info_tbl: [(c6Dg4,
                       label: sat_s6AYg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dg4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Dg5; else goto c6Dg6;
       c6Dg5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dg6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6Dg2_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6Dg2() //  [R1]
         { info_tbl: [(c6Dg2,
                       label: block_c6Dg2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dg2: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s6AYi_entry() //  [R1]
         { info_tbl: [(c6Dgc,
                       label: $dNum_s6AYi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dgc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Dgd; else goto c6Dge;
       c6Dgd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dge: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_s6AYj_entry() //  [R1]
         { info_tbl: [(c6Dgh,
                       label: lvl12_s6AYj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dgh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Dgi; else goto c6Dgj;
       c6Dgi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dgj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl7_r6v1d_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6AYp_entry() //  [R1]
         { info_tbl: [(c6Dgm,
                       label: lvl13_s6AYp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dgm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Dgn; else goto c6Dgo;
       c6Dgn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dgo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6AYG_entry() //  [R1]
         { info_tbl: [(c6Dgr,
                       label: sat_s6AYG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dgr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Dgs; else goto c6Dgt;
       c6Dgs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dgt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AYF_entry() //  [R1]
         { info_tbl: [(c6Dgw,
                       label: sat_s6AYF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dgw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Dgx; else goto c6Dgy;
       c6Dgx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dgy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6AYl::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6AYl::P64;
           P64[Sp - 24] = _s6AYl::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AYC_entry() //  [R1]
         { info_tbl: [(c6DgB,
                       label: sat_s6AYC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DgB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6DgC; else goto c6DgD;
       c6DgC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DgD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AYB_entry() //  [R1]
         { info_tbl: [(c6DgG,
                       label: sat_s6AYB_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DgG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6DgH; else goto c6DgI;
       c6DgH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DgI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AYA_entry() //  [R1]
         { info_tbl: [(c6DgM,
                       label: sat_s6AYA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DgM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6DgN; else goto c6DgO;
       c6DgN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DgO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6AYv::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6AYv::P64;
           P64[Sp - 24] = _s6AYv::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AYE_entry() //  [R1]
         { info_tbl: [(c6DgR,
                       label: sat_s6AYE_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DgR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6DgS; else goto c6DgT;
       c6DgS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DgT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AYD_entry() //  [R1]
         { info_tbl: [(c6DgX,
                       label: sat_s6AYD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DgX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6DgY; else goto c6DgZ;
       c6DgY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DgZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6AYv::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6AYv::P64;
           P64[Sp - 24] = _s6AYv::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AYM_entry() //  [R1]
         { info_tbl: [(c6Dh2,
                       label: sat_s6AYM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dh2: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Dh3; else goto c6Dh4;
       c6Dh3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dh4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6AYL_entry() //  [R1]
         { info_tbl: [(c6Dh8,
                       label: sat_s6AYL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dh8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Dh9; else goto c6Dha;
       c6Dh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dha: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6AYI::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6AYI::P64;
           P64[Sp - 24] = _s6AYI::P64;
           Sp = Sp - 40;
           call GHC.Base.mappend_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesMonoid_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6Dhb,
                       label: Data.Semigroup.Internal.stimesMonoid_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dhb: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c6Dhc; else goto c6Dhd;
       c6Dhc: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMonoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Dhd: // global
           I64[Sp - 40] = block_c6DeH_info;
           _s6AY9::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s6AY9::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6DeH() //  [R1]
         { info_tbl: [(c6DeH,
                       label: block_c6DeH_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DeH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Dhg; else goto c6Dhf;
       c6Dhg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dhf: // global
           I64[Hp - 16] = sat_s6AYg_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c6DeN_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6DeN() //  [R1]
         { info_tbl: [(c6DeN,
                       label: block_c6DeN_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DeN: // global
           I64[Sp] = block_c6DeR_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6DeR() //  [R1]
         { info_tbl: [(c6DeR,
                       label: block_c6DeR_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DeR: // global
           _c6Dib::P64 = R1 & 7;
           if (_c6Dib::P64 < 3) goto u6Dig; else goto c6Dhp;
       u6Dig: // global
           if (_c6Dib::P64 < 2) goto c6Dhl; else goto c6Dho;
       c6Dhl: // global
           R1 = lvl6_r6v1c_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6Dho: // global
           R2 = P64[Sp + 32];
           Sp = Sp + 56;
           call GHC.Base.mempty_entry(R2) args: 8, res: 0, upd: 8;
       c6Dhp: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Dhs; else goto c6Dhr;
       c6Dhs: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dhr: // global
           I64[Hp - 40] = $dNum_s6AYi_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = lvl12_s6AYj_info;
           _c6DeX::P64 = Hp - 40;
           P64[Hp] = _c6DeX::P64;
           P64[Sp] = P64[Sp + 40];
           P64[Sp + 16] = P64[Sp + 48];
           P64[Sp + 40] = Hp - 16;
           P64[Sp + 48] = _c6DeX::P64;
           call _c6DfQ() args: 0, res: 0, upd: 0;
     }
 },
 _c6DfQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DfQ: // global
           I64[Sp - 8] = block_c6DfS_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6DfS() //  [R1]
         { info_tbl: [(c6DfS,
                       label: block_c6DfS_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DfS: // global
           _s6AYI::P64 = P64[Sp + 24];
           _s6AYJ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6Di6; else goto c6Di7;
       c6Di6: // global
           I64[Sp + 8] = block_c6Df6_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s6AYJ::P64;
           P64[Sp + 24] = _s6AYI::P64;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c6Di7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6Dia; else goto c6Di9;
       c6Dia: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Di9: // global
           I64[Hp - 64] = sat_s6AYM_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s6AYJ::P64;
           I64[Hp - 24] = sat_s6AYL_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6AYI::P64;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c6DfQ() args: 0, res: 0, upd: 0;
     }
 },
 _c6Df6() //  [R1]
         { info_tbl: [(c6Df6,
                       label: block_c6Df6_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Df6: // global
           I64[Sp] = block_c6Dfa_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dfa() //  [R1]
         { info_tbl: [(c6Dfa,
                       label: block_c6Dfa_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dfa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Dhx; else goto c6Dhw;
       c6Dhx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dhw: // global
           I64[Hp - 16] = lvl13_s6AYp_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp - 8] = block_c6Dfg_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c6Dfe::P64 = Hp - 16;
           P64[Sp - 16] = _c6Dfe::P64;
           P64[Sp] = R1;
           P64[Sp + 48] = _c6Dfe::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6Dfg() //  [R1]
         { info_tbl: [(c6Dfg,
                       label: block_c6Dfg_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dfg: // global
           _s6AYl::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6Dhz; else goto c6Di1;
       c6Dhz: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6DhC; else goto c6DhB;
       c6DhC: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DhB: // global
           I64[Hp - 64] = sat_s6AYG_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s6AYF_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6AYl::P64;
           P64[Sp] = _s6AYl::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 24] = Hp - 24;
           call _c6Dft() args: 0, res: 0, upd: 0;
       c6Di1: // global
           R1 = _s6AYl::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Dft() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dft: // global
           I64[Sp - 8] = block_c6Dfv_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dfv() //  [R1]
         { info_tbl: [(c6Dfv,
                       label: block_c6Dfv_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dfv: // global
           _s6AYw::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6DhK; else goto c6DhU;
       c6DhK: // global
           I64[Sp] = block_c6Dfz_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s6AYw::P64;
           P64[Sp - 8] = P64[Sp + 64];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c6DhU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6DhX; else goto c6DhW;
       c6DhX: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DhW: // global
           I64[Hp - 64] = sat_s6AYE_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s6AYw::P64;
           I64[Hp - 24] = sat_s6AYD_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6Dft() args: 0, res: 0, upd: 0;
     }
 },
 _c6Dfz() //  [R1]
         { info_tbl: [(c6Dfz,
                       label: block_c6Dfz_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dfz: // global
           _s6AYa::P64 = P64[Sp + 48];
           _s6AYv::P64 = P64[Sp + 32];
           _s6AYx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6DhM; else goto c6DhT;
       c6DhM: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c6DhP; else goto c6DhO;
       c6DhP: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DhO: // global
           I64[Hp - 104] = sat_s6AYC_info;
           P64[Hp - 88] = _s6AYa::P64;
           P64[Hp - 80] = _s6AYv::P64;
           P64[Hp - 72] = _s6AYx::P64;
           I64[Hp - 64] = sat_s6AYB_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s6AYA_info;
           P64[Hp - 8] = _s6AYa::P64;
           P64[Hp] = _s6AYv::P64;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c6Dft() args: 0, res: 0, upd: 0;
       c6DhT: // global
           R2 = _s6AYa::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s6AYv::P64;
           P64[Sp + 64] = _s6AYx::P64;
           Sp = Sp + 48;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.984650643 UTC

[section ""data" . Data.Semigroup.Internal.$w$csconcat_closure" {
     Data.Semigroup.Internal.$w$csconcat_closure:
         const Data.Semigroup.Internal.$w$csconcat_info;
 },
 go_s6AYQ_entry() //  [R1, R2, R3]
         { info_tbl: [(c6DlU,
                       label: go_s6AYQ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DlU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6DlV; else goto c6DlW;
       c6DlV: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6DlW: // global
           I64[Sp - 32] = block_c6DlN_info;
           _s6AYQ::P64 = R1;
           _s6AYN::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s6AYN::P64;
           P64[Sp - 16] = _s6AYQ::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6Dm6; else goto c6DlO;
       u6Dm6: // global
           call _c6DlN(R1) args: 0, res: 0, upd: 0;
       c6DlO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6DlN() //  [R1]
         { info_tbl: [(c6DlN,
                       label: block_c6DlN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DlN: // global
           _s6AYR::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6DlR; else goto c6DlS;
       c6DlR: // global
           R1 = _s6AYR::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6DlS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6Dm4; else goto c6Dm3;
       c6Dm4: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dm3: // global
           _s6AYU::P64 = P64[R1 + 6];
           _s6AYV::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s6AYU::P64;
           P64[Hp] = _s6AYV::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6AYR::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$w$csconcat_entry() //  [R2, R3, R4]
         { info_tbl: [(c6Dm7,
                       label: Data.Semigroup.Internal.$w$csconcat_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dm7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c6Dmb; else goto c6Dma;
       c6Dmb: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$w$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Dma: // global
           I64[Hp - 8] = go_s6AYQ_info;
           P64[Hp] = R2;
           _s6AYO::P64 = R3;
           R3 = R4;
           R2 = _s6AYO::P64;
           R1 = Hp - 6;
           call go_s6AYQ_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:55.994545467 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_entry() //  [R2,
                                                               R3]
         { info_tbl: [(c6DmD,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DmD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6DmE; else goto c6DmF;
       c6DmE: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6DmF: // global
           I64[Sp - 16] = block_c6DmA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6DmJ; else goto c6DmB;
       u6DmJ: // global
           call _c6DmA(R1) args: 0, res: 0, upd: 0;
       c6DmB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6DmA() //  [R1]
         { info_tbl: [(c6DmA,
                       label: block_c6DmA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DmA: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.Semigroup.Internal.$w$csconcat_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.000984139 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure" {
     Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure:
         const Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_info;
 },
 z_s6AZ4_entry() //  [R1]
         { info_tbl: [(c6Dn2,
                       label: z_s6AZ4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dn2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Dn3; else goto c6Dn4;
       c6Dn3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dn4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 go_s6AZ5_entry() //  [R1, R2]
         { info_tbl: [(c6Dnh,
                       label: go_s6AZ5_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dnh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Dni; else goto c6Dnj;
       c6Dni: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Dnj: // global
           I64[Sp - 32] = block_c6Dna_info;
           _s6AZ5::P64 = R1;
           _s6AZ2::P64 = P64[R1 + 7];
           _s6AZ4::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s6AZ2::P64;
           P64[Sp - 16] = _s6AZ4::P64;
           P64[Sp - 8] = _s6AZ5::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6Dnt; else goto c6Dnb;
       u6Dnt: // global
           call _c6Dna(R1) args: 0, res: 0, upd: 0;
       c6Dnb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dna() //  [R1]
         { info_tbl: [(c6Dna,
                       label: block_c6Dna_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dna: // global
           if (R1 & 7 == 1) goto c6Dne; else goto c6Dnf;
       c6Dne: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6Dnf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Dnr; else goto c6Dnq;
       c6Dnr: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dnq: // global
           _s6AZ8::P64 = P64[R1 + 6];
           _s6AZ9::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s6AZ9::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s6AZ8::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_entry() //  [R2, R3]
         { info_tbl: [(c6Dnu,
                       label: Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dnu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Dny; else goto c6Dnx;
       c6Dny: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Dnx: // global
           I64[Hp - 40] = z_s6AZ4_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s6AZ5_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s6AZ5_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.012473114 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_info;
         const 0;
 },
 sat_s6AZe_entry() //  [R1, R2]
         { info_tbl: [(c6Do9,
                       label: sat_s6AZe_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Do9: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AZd_entry() //  [R1, R2]
         { info_tbl: [(c6Doh,
                       label: sat_s6AZd_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Doh: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fSemigroupAlt_$csconcat_entry(R3,
                                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AZc_entry() //  [R1]
         { info_tbl: [(c6Doo,
                       label: sat_s6AZc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Doo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Dop; else goto c6Doq;
       c6Dop: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Doq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupAlt_entry() //  [R2]
         { info_tbl: [(c6Dos,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dos: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c6Dow; else goto c6Dov;
       c6Dow: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Dov: // global
           I64[Hp - 80] = sat_s6AZe_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s6AZd_info;
           P64[Hp - 56] = R2;
           I64[Hp - 48] = sat_s6AZc_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 63;
           P64[Hp] = Hp - 79;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidAlt_closure" {
     Data.Semigroup.Internal.$fMonoidAlt_closure:
         const Data.Semigroup.Internal.$fMonoidAlt_info;
         const 0;
 },
 sat_s6AZj_entry() //  [R1, R2]
         { info_tbl: [(c6DoG,
                       label: sat_s6AZj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DoG: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call Data.Semigroup.Internal.$fMonoidAlt_$cmconcat_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s6AZi_entry() //  [R1]
         { info_tbl: [(c6DoN,
                       label: sat_s6AZi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DoN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6DoO; else goto c6DoP;
       c6DoO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DoP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<|>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AZh_entry() //  [R1]
         { info_tbl: [(c6DoU,
                       label: sat_s6AZh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DoU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6DoV; else goto c6DoW;
       c6DoV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DoW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.empty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AZg_entry() //  [R1]
         { info_tbl: [(c6Dp1,
                       label: sat_s6AZg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dp1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Dp2; else goto c6Dp3;
       c6Dp2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dp3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupAlt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidAlt_entry() //  [R2]
         { info_tbl: [(c6Dp5,
                       label: Data.Semigroup.Internal.$fMonoidAlt_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dp5: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto c6Dp9; else goto c6Dp8;
       c6Dp9: // global
           HpAlloc = 128;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidAlt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6Dp8: // global
           I64[Hp - 120] = sat_s6AZj_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s6AZi_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s6AZh_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s6AZg_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 119;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_info;
         const 0;
 },
 sat_s6AZm_entry() //  [R1]
         { info_tbl: [(c6Dpi,
                       label: sat_s6AZm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dpi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Dpj; else goto c6Dpk;
       c6Dpj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dpk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidAlt_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c6Dpl,
                       label: Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dpl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Dpp; else goto c6Dpo;
       c6Dpp: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Dpo: // global
           I64[Hp - 16] = sat_s6AZm_info;
           P64[Hp] = R2;
           _s6AZl::P64 = R3;
           R3 = Hp - 16;
           R2 = _s6AZl::P64;
           R1 = Data.Semigroup.Internal.stimesMonoid_closure+4;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.037879489 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo1_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo1_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo1_info;
 },
 g_s6AZs_entry() //  [R1]
         { info_tbl: [(c6DqH,
                       label: g_s6AZs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DqH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6DqI; else goto c6DqJ;
       c6DqI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DqJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fSemigroupEndo1_entry(R3,
                                                               R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6AZv_entry() //  [R1, R2]
         { info_tbl: [(c6DqQ,
                       label: sat_s6AZv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DqQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6DqU; else goto c6DqT;
       c6DqU: // global
           HpAlloc = 32;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6DqT: // global
           _s6AZn::P64 = P64[R1 + 7];
           _s6AZs::P64 = P64[R1 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s6AZs::P64;
           P64[Hp] = R2;
           R2 = Hp - 24;
           R1 = _s6AZn::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.$fSemigroupEndo1_entry() //  [R2, R3]
         { info_tbl: [(c6DqZ,
                       label: Data.Semigroup.Internal.$fSemigroupEndo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DqZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Dr0; else goto c6Dr1;
       c6Dr0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupEndo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Dr1: // global
           I64[Sp - 16] = block_c6Dqx_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Dr7; else goto c6Dqy;
       u6Dr7: // global
           call _c6Dqx(R1) args: 0, res: 0, upd: 0;
       c6Dqy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dqx() //  [R1]
         { info_tbl: [(c6Dqx,
                       label: block_c6Dqx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dqx: // global
           _s6AZn::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6DqW; else goto c6DqX;
       c6DqW: // global
           R1 = _s6AZn::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6DqX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c6Dr6; else goto c6Dr5;
       c6Dr6: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dr5: // global
           _s6AZq::P64 = P64[R1 + 6];
           _s6AZr::P64 = P64[R1 + 14];
           I64[Hp - 48] = g_s6AZs_info;
           P64[Hp - 32] = _s6AZq::P64;
           P64[Hp - 24] = _s6AZr::P64;
           I64[Hp - 16] = sat_s6AZv_info;
           P64[Hp - 8] = _s6AZn::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.048575087 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_info;
 },
 Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_entry() //  [R2]
         { info_tbl: [(c6DrE,
                       label: Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DrE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c6DrF; else goto c6DrG;
       c6DrF: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6DrG: // global
           I64[Sp - 8] = block_c6DrB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u6DrK; else goto c6DrC;
       u6DrK: // global
           call _c6DrB(R1) args: 0, res: 0, upd: 0;
       c6DrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6DrB() //  [R1]
         { info_tbl: [(c6DrB,
                       label: block_c6DrB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DrB: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.Semigroup.Internal.$fSemigroupEndo1_entry(R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.054701777 UTC

[section ""data" . Data.Semigroup.Internal.$fMonoidEndo1_closure" {
     Data.Semigroup.Internal.$fMonoidEndo1_closure:
         const Data.Semigroup.Internal.$fMonoidEndo1_info;
 },
 sat_s6AZF_entry() //  [R1]
         { info_tbl: [(c6Ds9,
                       label: sat_s6AZF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Ds9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Dsa; else goto c6Dsb;
       c6Dsa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dsb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Semigroup.Internal.$fMonoidEndo1_entry(R3,
                                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.$fMonoidEndo1_entry() //  [R2, R3]
         { info_tbl: [(c6Dsg,
                       label: Data.Semigroup.Internal.$fMonoidEndo1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dsg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6Dsh; else goto c6Dsi;
       c6Dsh: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.$fMonoidEndo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c6Dsi: // global
           I64[Sp - 16] = block_c6DrZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u6Dso; else goto c6Ds0;
       u6Dso: // global
           call _c6DrZ(R1) args: 0, res: 0, upd: 0;
       c6Ds0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6DrZ() //  [R1]
         { info_tbl: [(c6DrZ,
                       label: block_c6DrZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DrZ: // global
           _s6AZB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6Dsd; else goto c6Dse;
       c6Dsd: // global
           R1 = _s6AZB::P64;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c6Dse: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c6Dsn; else goto c6Dsm;
       c6Dsn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dsm: // global
           _s6AZD::P64 = P64[R1 + 6];
           _s6AZE::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s6AZF_info;
           P64[Hp - 8] = _s6AZB::P64;
           P64[Hp] = _s6AZE::P64;
           R2 = Hp - 24;
           R1 = _s6AZD::P64;
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.063376674 UTC

[section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.._closure+3;
         const Data.Semigroup.Internal.$fSemigroupEndo_$csconcat_closure+1;
         const Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure+3;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fMonoidEndo_closure" {
     Data.Semigroup.Internal.$fMonoidEndo_closure:
         const GHC.Base.C:Monoid_con_info;
         const Data.Semigroup.Internal.$fSemigroupEndo_closure+1;
         const GHC.Base.id_closure+1;
         const GHC.Base.._closure+3;
         const Data.Semigroup.Internal.$fMonoidEndo1_closure+2;
         const 0;
 },
 section ""data" . Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure" {
     Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_closure:
         const Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_info;
         const 0;
 },
 Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_entry() //  [R2,
                                                               R3, R4]
         { info_tbl: [(c6DsL,
                       label: Data.Semigroup.Internal.$fSemigroupEndo_$cstimes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DsL: // global
           R5 = R4;
           R4 = R3;
           R3 = Data.Semigroup.Internal.$fMonoidEndo_closure+1;
           R2 = R2;
           call Data.Semigroup.Internal.stimesMonoid_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.068443279 UTC

[section ""cstring" . lvl8_r6v1e_bytes" {
     lvl8_r6v1e_bytes:
         I8[] [115,116,105,109,101,115,58,32,112,111,115,105,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114,32,101,120,112,101,99,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.071771155 UTC

[section ""data" . lvl9_r6v1f_closure" {
     lvl9_r6v1f_closure:
         const lvl9_r6v1f_info;
         const 0;
         const 0;
         const 0;
 },
 lvl9_r6v1f_entry() //  [R1]
         { info_tbl: [(c6Dt3,
                       label: lvl9_r6v1f_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dt3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6Dt4; else goto c6Dt5;
       c6Dt4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dt5: // global
           (_c6DsY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6DsY::I64 == 0) goto c6Dt0; else goto c6DsZ;
       c6Dt0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6DsZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6DsY::I64;
           I64[Sp - 24] = block_c6Dt1_info;
           R2 = lvl8_r6v1e_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6Dt1() //  [R1]
         { info_tbl: [(c6Dt1,
                       label: block_c6Dt1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dt1: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.081518121 UTC

[section ""data" . Data.Semigroup.Internal.stimesDefault_closure" {
     Data.Semigroup.Internal.stimesDefault_closure:
         const Data.Semigroup.Internal.stimesDefault_info;
         const 0;
 },
 sat_s6AZP_entry() //  [R1]
         { info_tbl: [(c6DuK,
                       label: sat_s6AZP_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DuK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6DuL; else goto c6DuM;
       c6DuL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DuM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6DuI_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6DuI() //  [R1]
         { info_tbl: [(c6DuI,
                       label: block_c6DuI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DuI: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 $dNum_s6AZR_entry() //  [R1]
         { info_tbl: [(c6DuS,
                       label: $dNum_s6AZR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DuS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6DuT; else goto c6DuU;
       c6DuT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DuU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_s6AZS_entry() //  [R1]
         { info_tbl: [(c6DuX,
                       label: lvl12_s6AZS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DuX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6DuY; else goto c6DuZ;
       c6DuY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DuZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl7_r6v1d_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6AZY_entry() //  [R1]
         { info_tbl: [(c6Dv2,
                       label: lvl13_s6AZY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dv2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6Dv3; else goto c6Dv4;
       c6Dv3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dv4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6B0f_entry() //  [R1]
         { info_tbl: [(c6Dv7,
                       label: sat_s6B0f_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dv7: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Dv8; else goto c6Dv9;
       c6Dv8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dv9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6B0e_entry() //  [R1]
         { info_tbl: [(c6Dvc,
                       label: sat_s6B0e_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dvc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Dvd; else goto c6Dve;
       c6Dvd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dve: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6AZU::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6AZU::P64;
           P64[Sp - 24] = _s6AZU::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6B0b_entry() //  [R1]
         { info_tbl: [(c6Dvh,
                       label: sat_s6B0b_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dvh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Dvi; else goto c6Dvj;
       c6Dvi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dvj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6B0a_entry() //  [R1]
         { info_tbl: [(c6Dvm,
                       label: sat_s6B0a_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dvm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Dvn; else goto c6Dvo;
       c6Dvn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dvo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6B09_entry() //  [R1]
         { info_tbl: [(c6Dvs,
                       label: sat_s6B09_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dvs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Dvt; else goto c6Dvu;
       c6Dvt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dvu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6B04::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6B04::P64;
           P64[Sp - 24] = _s6B04::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6B0d_entry() //  [R1]
         { info_tbl: [(c6Dvx,
                       label: sat_s6B0d_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dvx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6Dvy; else goto c6Dvz;
       c6Dvy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6Dvz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6B0c_entry() //  [R1]
         { info_tbl: [(c6DvD,
                       label: sat_s6B0c_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DvD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6DvE; else goto c6DvF;
       c6DvE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DvF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6B04::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6B04::P64;
           P64[Sp - 24] = _s6B04::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6B0l_entry() //  [R1]
         { info_tbl: [(c6DvI,
                       label: sat_s6B0l_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DvI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6DvJ; else goto c6DvK;
       c6DvJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DvK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Real.quot_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6B0k_entry() //  [R1]
         { info_tbl: [(c6DvO,
                       label: sat_s6B0k_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DvO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6DvP; else goto c6DvQ;
       c6DvP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DvQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           _s6B0h::P64 = P64[R1 + 24];
           P64[Sp - 32] = _s6B0h::P64;
           P64[Sp - 24] = _s6B0h::P64;
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesDefault_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6DvR,
                       label: Data.Semigroup.Internal.stimesDefault_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DvR: // global
           if ((Sp + -96) < SpLim) (likely: False) goto c6DvS; else goto c6DvT;
       c6DvS: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6DvT: // global
           I64[Sp - 40] = block_c6Dtp_info;
           _s6AZI::P64 = R2;
           R2 = R2;
           P64[Sp - 32] = _s6AZI::P64;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dtp() //  [R1]
         { info_tbl: [(c6Dtp,
                       label: block_c6Dtp_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dtp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6DvW; else goto c6DvV;
       c6DvW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DvV: // global
           I64[Hp - 16] = sat_s6AZP_info;
           P64[Hp] = R1;
           I64[Sp - 16] = block_c6Dtv_info;
           R2 = R1;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 16;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dtv() //  [R1]
         { info_tbl: [(c6Dtv,
                       label: block_c6Dtv_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dtv: // global
           I64[Sp] = block_c6Dtz_info;
           R2 = R1;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 40];
           P64[Sp - 8] = P64[Sp + 16];
           Sp = Sp - 24;
           call GHC.Classes.<=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6Dtz() //  [R1]
         { info_tbl: [(c6Dtz,
                       label: block_c6Dtz_info
                       rep:StackRep [False, True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dtz: // global
           if (R1 & 7 == 1) goto c6DvZ; else goto c6DwO;
       c6DvZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6Dw2; else goto c6Dw1;
       c6Dw2: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dw1: // global
           I64[Hp - 40] = $dNum_s6AZR_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = lvl12_s6AZS_info;
           _c6DtD::P64 = Hp - 40;
           P64[Hp] = _c6DtD::P64;
           P64[Sp] = P64[Sp + 40];
           P64[Sp + 16] = P64[Sp + 48];
           P64[Sp + 40] = Hp - 16;
           P64[Sp + 48] = _c6DtD::P64;
           call _c6Duw() args: 0, res: 0, upd: 0;
       c6DwO: // global
           R1 = lvl9_r6v1f_closure;
           Sp = Sp + 56;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Duw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Duw: // global
           I64[Sp - 8] = block_c6Duy_info;
           R3 = P64[Sp];
           R2 = P64[Sp + 24];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Duy() //  [R1]
         { info_tbl: [(c6Duy,
                       label: block_c6Duy_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Duy: // global
           _s6B0h::P64 = P64[Sp + 24];
           _s6B0i::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6DwG; else goto c6DwH;
       c6DwG: // global
           I64[Sp + 8] = block_c6DtM_info;
           R2 = P64[Sp + 16];
           P64[Sp + 16] = _s6B0i::P64;
           P64[Sp + 24] = _s6B0h::P64;
           Sp = Sp + 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
       c6DwH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6DwK; else goto c6DwJ;
       c6DwK: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DwJ: // global
           I64[Hp - 64] = sat_s6B0l_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s6B0i::P64;
           I64[Hp - 24] = sat_s6B0k_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6B0h::P64;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 8] = Hp - 64;
           Sp = Sp + 8;
           call _c6Duw() args: 0, res: 0, upd: 0;
     }
 },
 _c6DtM() //  [R1]
         { info_tbl: [(c6DtM,
                       label: block_c6DtM_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DtM: // global
           I64[Sp] = block_c6DtQ_info;
           R2 = R1;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6DtQ() //  [R1]
         { info_tbl: [(c6DtQ,
                       label: block_c6DtQ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DtQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6Dw7; else goto c6Dw6;
       c6Dw7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dw6: // global
           I64[Hp - 16] = lvl13_s6AZY_info;
           P64[Hp] = P64[Sp + 48];
           I64[Sp - 8] = block_c6DtW_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 8];
           _c6DtU::P64 = Hp - 16;
           P64[Sp - 16] = _c6DtU::P64;
           P64[Sp] = R1;
           P64[Sp + 48] = _c6DtU::P64;
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6DtW() //  [R1]
         { info_tbl: [(c6DtW,
                       label: block_c6DtW_info
                       rep:StackRep [False, False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DtW: // global
           _s6AZU::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6Dw9; else goto c6DwB;
       c6Dw9: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6Dwc; else goto c6Dwb;
       c6Dwc: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dwb: // global
           I64[Hp - 64] = sat_s6B0f_info;
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = P64[Sp + 16];
           I64[Hp - 24] = sat_s6B0e_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _s6AZU::P64;
           P64[Sp] = _s6AZU::P64;
           P64[Sp + 16] = Hp - 64;
           P64[Sp + 24] = Hp - 24;
           call _c6Du9() args: 0, res: 0, upd: 0;
       c6DwB: // global
           R1 = _s6AZU::P64;
           Sp = Sp + 64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6Du9() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Du9: // global
           I64[Sp - 8] = block_c6Dub_info;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 32];
           Sp = Sp - 8;
           call GHC.Real.even_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6Dub() //  [R1]
         { info_tbl: [(c6Dub,
                       label: block_c6Dub_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Dub: // global
           _s6B05::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto c6Dwk; else goto c6Dwu;
       c6Dwk: // global
           I64[Sp] = block_c6Duf_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s6B05::P64;
           P64[Sp - 8] = P64[Sp + 64];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
       c6Dwu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c6Dwx; else goto c6Dww;
       c6Dwx: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dww: // global
           I64[Hp - 64] = sat_s6B0d_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = _s6B05::P64;
           I64[Hp - 24] = sat_s6B0c_info;
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 32];
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c6Du9() args: 0, res: 0, upd: 0;
     }
 },
 _c6Duf() //  [R1]
         { info_tbl: [(c6Duf,
                       label: block_c6Duf_info
                       rep:StackRep [False, False, False, False, False, False, False,
                                     False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6Duf: // global
           _s6AZJ::P64 = P64[Sp + 48];
           _s6B04::P64 = P64[Sp + 32];
           _s6B06::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c6Dwm; else goto c6Dwt;
       c6Dwm: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto c6Dwp; else goto c6Dwo;
       c6Dwp: // global
           HpAlloc = 112;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6Dwo: // global
           I64[Hp - 104] = sat_s6B0b_info;
           P64[Hp - 88] = _s6AZJ::P64;
           P64[Hp - 80] = _s6B04::P64;
           P64[Hp - 72] = _s6B06::P64;
           I64[Hp - 64] = sat_s6B0a_info;
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 24];
           I64[Hp - 24] = sat_s6B09_info;
           P64[Hp - 8] = _s6AZJ::P64;
           P64[Hp] = _s6B04::P64;
           P64[Sp + 32] = Hp - 24;
           P64[Sp + 24] = Hp - 64;
           P64[Sp + 8] = Hp - 104;
           Sp = Sp + 8;
           call _c6Du9() args: 0, res: 0, upd: 0;
       c6Dwt: // global
           R2 = _s6AZJ::P64;
           I64[Sp + 48] = stg_ap_pp_info;
           P64[Sp + 56] = _s6B04::P64;
           P64[Sp + 64] = _s6B06::P64;
           Sp = Sp + 48;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.135483929 UTC

[section ""cstring" . lvl10_r6v1g_bytes" {
     lvl10_r6v1g_bytes:
         I8[] [115,116,105,109,101,115,58,32,77,97,121,98,101,44,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.137841216 UTC

[section ""data" . Data.Semigroup.Internal.stimesMaybe1_closure" {
     Data.Semigroup.Internal.stimesMaybe1_closure:
         const Data.Semigroup.Internal.stimesMaybe1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesMaybe1_entry() //  [R1]
         { info_tbl: [(c6DAr,
                       label: Data.Semigroup.Internal.stimesMaybe1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DAr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6DAs; else goto c6DAt;
       c6DAs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DAt: // global
           (_c6DAm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6DAm::I64 == 0) goto c6DAo; else goto c6DAn;
       c6DAo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6DAn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6DAm::I64;
           I64[Sp - 24] = block_c6DAp_info;
           R2 = lvl10_r6v1g_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6DAp() //  [R1]
         { info_tbl: [(c6DAp,
                       label: block_c6DAp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DAp: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.14502759 UTC

[section ""data" . Data.Semigroup.Internal.stimesMaybe_closure" {
     Data.Semigroup.Internal.stimesMaybe_closure:
         const Data.Semigroup.Internal.stimesMaybe_info;
         const 0;
 },
 sat_s6B0w_entry() //  [R1]
         { info_tbl: [(c6DB3,
                       label: sat_s6B0w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DB3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6DB4; else goto c6DB5;
       c6DB4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DB5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c6DB1_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Real.$p1Real_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6DB1() //  [R1]
         { info_tbl: [(c6DB1,
                       label: block_c6DB1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DB1: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 8;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6B0y_entry() //  [R1]
         { info_tbl: [(c6DBn,
                       label: sat_s6B0y_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DBn: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c6DBo; else goto c6DBp;
       c6DBo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DBp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 24];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 Data.Semigroup.Internal.stimesMaybe_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c6DBu,
                       label: Data.Semigroup.Internal.stimesMaybe_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DBu: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c6DBv; else goto c6DBw;
       c6DBv: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMaybe_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6DBw: // global
           I64[Sp - 32] = block_c6DAN_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u6DBW; else goto c6DAO;
       u6DBW: // global
           call _c6DAN(R1) args: 0, res: 0, upd: 0;
       c6DAO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c6DAN() //  [R1]
         { info_tbl: [(c6DAN,
                       label: block_c6DAN_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DAN: // global
           if (R1 & 7 == 1) goto u6DBS; else goto c6DBs;
       u6DBS: // global
           Sp = Sp + 32;
           call _c6DBK() args: 0, res: 0, upd: 0;
       c6DBs: // global
           I64[Sp - 8] = block_c6DAT_info;
           R2 = P64[Sp + 8];
           P64[Sp] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6DAT() //  [R1]
         { info_tbl: [(c6DAT,
                       label: block_c6DAT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DAT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6DBC; else goto c6DBB;
       c6DBC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DBB: // global
           I64[Hp - 16] = sat_s6B0w_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6DB9_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6DB9() //  [R1]
         { info_tbl: [(c6DB9,
                       label: block_c6DB9_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DB9: // global
           _c6DAX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c6DBd_info;
           R2 = R1;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[Sp + 40];
           P64[Sp] = _c6DAX::P64;
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6DBd() //  [R1]
         { info_tbl: [(c6DBd,
                       label: block_c6DBd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DBd: // global
           _c6DBQ::P64 = R1 & 7;
           if (_c6DBQ::P64 < 3) goto u6DBR; else goto c6DBM;
       u6DBR: // global
           if (_c6DBQ::P64 < 2) goto c6DBH; else goto u6DBT;
       c6DBH: // global
           R1 = Data.Semigroup.Internal.stimesMaybe1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       u6DBT: // global
           Sp = Sp + 40;
           call _c6DBK() args: 0, res: 0, upd: 0;
       c6DBM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c6DBP; else goto c6DBO;
       c6DBP: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DBO: // global
           I64[Hp - 56] = sat_s6B0y_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6DBK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DBK: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.165780539 UTC

[section ""cstring" . lvl11_r6v1h_bytes" {
     lvl11_r6v1h_bytes:
         I8[] [115,116,105,109,101,115,58,32,91,93,44,32,110,101,103,97,116,105,118,101,32,109,117,108,116,105,112,108,105,101,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.168031332 UTC

[section ""data" . Data.Semigroup.Internal.stimesList1_closure" {
     Data.Semigroup.Internal.stimesList1_closure:
         const Data.Semigroup.Internal.stimesList1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.Semigroup.Internal.stimesList1_entry() //  [R1]
         { info_tbl: [(c6DD7,
                       label: Data.Semigroup.Internal.stimesList1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DD7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c6DD8; else goto c6DD9;
       c6DD8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DD9: // global
           (_c6DD2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c6DD2::I64 == 0) goto c6DD4; else goto c6DD3;
       c6DD4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c6DD3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c6DD2::I64;
           I64[Sp - 24] = block_c6DD5_info;
           R2 = lvl11_r6v1h_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c6DD5() //  [R1]
         { info_tbl: [(c6DD5,
                       label: block_c6DD5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DD5: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.176134037 UTC

[section ""data" . Data.Semigroup.Internal.stimesList_closure" {
     Data.Semigroup.Internal.stimesList_closure:
         const Data.Semigroup.Internal.stimesList_info;
         const 0;
 },
 $dNum_s6B0E_entry() //  [R1]
         { info_tbl: [(c6DDB,
                       label: $dNum_s6B0E_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DDB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c6DDC; else goto c6DDD;
       c6DDC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DDD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.$p1Real_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s6B0G_entry() //  [R1]
         { info_tbl: [(c6DDM,
                       label: sat_s6B0G_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DDM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6DDN; else goto c6DDO;
       c6DDN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DDO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl12_s6B0I_entry() //  [R1]
         { info_tbl: [(c6DDX,
                       label: lvl12_s6B0I_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DDX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6DDY; else goto c6DDZ;
       c6DDY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DDZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidProduct1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 lvl13_s6B0J_entry() //  [R1]
         { info_tbl: [(c6DE4,
                       label: lvl13_s6B0J_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DE4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c6DE5; else goto c6DE6;
       c6DE5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DE6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Data.Semigroup.Internal.$fMonoidSum1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s6B0O_entry() //  [R1]
         { info_tbl: [(c6DEs,
                       label: sat_s6B0O_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DEs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c6DEt; else goto c6DEu;
       c6DEt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DEu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Num.-_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_s6B0P_entry() //  [R1]
         { info_tbl: [(c6DEv,
                       label: sat_s6B0P_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DEv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c6DEz; else goto c6DEy;
       c6DEz: // global
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c6DEy: // global
           _s6B0E::P64 = P64[R1 + 16];
           _s6B0I::P64 = P64[R1 + 24];
           _s6B0L::P64 = P64[R1 + 32];
           _s6B0M::P64 = P64[R1 + 40];
           I64[Hp - 32] = sat_s6B0O_info;
           P64[Hp - 16] = _s6B0E::P64;
           P64[Hp - 8] = _s6B0I::P64;
           P64[Hp] = _s6B0M::P64;
           R2 = Hp - 32;
           R1 = _s6B0L::P64;
           call rep_s6B0L_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 rep_s6B0L_entry() //  [R1, R2]
         { info_tbl: [(c6DEE,
                       label: rep_s6B0L_info
                       rep:HeapRep 5 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DEE: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c6DEF; else goto c6DEG;
       c6DEF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c6DEG: // global
           I64[Sp - 48] = block_c6DEg_info;
           _s6B0M::P64 = R2;
           R2 = P64[R1 + 39];
           I64[Sp - 72] = stg_ap_pp_info;
           P64[Sp - 64] = _s6B0M::P64;
           P64[Sp - 56] = P64[R1 + 31];
           P64[Sp - 40] = P64[R1 + 7];
           P64[Sp - 32] = P64[R1 + 15];
           P64[Sp - 24] = P64[R1 + 23];
           P64[Sp - 16] = R1;
           P64[Sp - 8] = _s6B0M::P64;
           Sp = Sp - 72;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6DEg() //  [R1]
         { info_tbl: [(c6DEg,
                       label: block_c6DEg_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DEg: // global
           if (R1 & 7 == 1) goto c6DEB; else goto c6DEC;
       c6DEB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6DEJ; else goto c6DEI;
       c6DEJ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DEI: // global
           I64[Hp - 40] = sat_s6B0P_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           R3 = Hp - 40;
           R2 = P64[Sp + 8];
           Sp = Sp + 48;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       c6DEC: // global
           R1 = []_closure+1;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.Semigroup.Internal.stimesList_entry() //  [R2, R3, R4]
         { info_tbl: [(c6DEN,
                       label: Data.Semigroup.Internal.stimesList_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DEN: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c6DEO; else goto c6DEP;
       c6DEO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesList_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c6DEP: // global
           I64[Sp - 24] = block_c6DDt_info;
           R2 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call GHC.Real.$p1Integral_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6DDt() //  [R1]
         { info_tbl: [(c6DDt,
                       label: block_c6DDt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DDt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6DES; else goto c6DER;
       c6DES: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DER: // global
           I64[Hp - 16] = $dNum_s6B0E_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_c6DDE_info;
           R2 = R1;
           P64[Sp] = Hp - 16;
           Sp = Sp - 8;
           call GHC.Real.$p2Real_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c6DDE() //  [R1]
         { info_tbl: [(c6DDE,
                       label: block_c6DDE_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DDE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c6DEV; else goto c6DEU;
       c6DEV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DEU: // global
           I64[Hp - 16] = sat_s6B0G_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp - 8] = block_c6DDP_info;
           R2 = R1;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = Hp - 16;
           P64[Sp] = R1;
           Sp = Sp - 32;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c6DDP() //  [R1]
         { info_tbl: [(c6DDP,
                       label: block_c6DDP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DDP: // global
           if (R1 & 7 == 1) goto c6DEX; else goto c6DF7;
       c6DEX: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6DF0; else goto c6DEZ;
       c6DF0: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DEZ: // global
           I64[Hp - 40] = lvl12_s6B0I_info;
           _c6DDx::P64 = P64[Sp + 16];
           P64[Hp - 24] = _c6DDx::P64;
           I64[Hp - 16] = lvl13_s6B0J_info;
           P64[Hp] = _c6DDx::P64;
           I64[Sp - 8] = block_c6DE7_info;
           R2 = P64[Sp + 8];
           P64[Sp] = Hp - 16;
           P64[Sp + 8] = Hp - 40;
           Sp = Sp - 8;
           call GHC.Classes.$p1Ord_entry(R2) args: 8, res: 8, upd: 8;
       c6DF7: // global
           R1 = Data.Semigroup.Internal.stimesList1_closure;
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c6DE7() //  [R1]
         { info_tbl: [(c6DE7,
                       label: block_c6DE7_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c6DE7: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c6DF3; else goto c6DF2;
       c6DF3: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c6DF2: // global
           I64[Hp - 40] = rep_s6B0L_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = P64[Sp + 32];
           R1 = Hp - 39;
           Sp = Sp + 48;
           call rep_s6B0L_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.206978961 UTC

[section ""cstring" . Data.Semigroup.Internal.$trModule4_bytes" {
     Data.Semigroup.Internal.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.208868025 UTC

[section ""data" . Data.Semigroup.Internal.$trModule3_closure" {
     Data.Semigroup.Internal.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.210939934 UTC

[section ""cstring" . Data.Semigroup.Internal.$trModule2_bytes" {
     Data.Semigroup.Internal.$trModule2_bytes:
         I8[] [68,97,116,97,46,83,101,109,105,103,114,111,117,112,46,73,110,116,101,114,110,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.212707872 UTC

[section ""data" . Data.Semigroup.Internal.$trModule1_closure" {
     Data.Semigroup.Internal.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.214599458 UTC

[section ""data" . Data.Semigroup.Internal.$trModule_closure" {
     Data.Semigroup.Internal.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.Semigroup.Internal.$trModule3_closure+1;
         const Data.Semigroup.Internal.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.2165062 UTC

[section ""data" . $krep_r6v1i_closure" {
     $krep_r6v1i_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcBool_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.218451592 UTC

[section ""data" . $krep1_r6v1j_closure" {
     $krep1_r6v1j_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.220276105 UTC

[section ""data" . $krep2_r6v1k_closure" {
     $krep2_r6v1k_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep1_r6v1j_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.222248664 UTC

[section ""data" . $krep3_r6v1l_closure" {
     $krep3_r6v1l_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const GHC.Types.krep$*_closure;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.224069839 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt1_closure" {
     Data.Semigroup.Internal.$tcAlt1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep3_r6v1l_closure+4;
         const $krep3_r6v1l_closure+4;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.22589457 UTC

[section ""data" . $krep4_r6v1m_closure" {
     $krep4_r6v1m_closure:
         const GHC.Types.KindRepVar_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.22765549 UTC

[section ""data" . $krep5_r6v1n_closure" {
     $krep5_r6v1n_closure:
         const GHC.Types.KindRepVar_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.229528374 UTC

[section ""data" . $krep6_r6v1o_closure" {
     $krep6_r6v1o_closure:
         const GHC.Types.KindRepApp_con_info;
         const $krep4_r6v1m_closure+2;
         const $krep5_r6v1n_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.231367378 UTC

[section ""data" . Data.Semigroup.Internal.$tcDual1_closure" {
     Data.Semigroup.Internal.$tcDual1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadDual5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.234064538 UTC

[section ""data" . Data.Semigroup.Internal.$tcDual_closure" {
     Data.Semigroup.Internal.$tcDual_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcDual1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 14711416616195557841;
         const 10971851269997195248;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.236014431 UTC

[section ""data" . $krep7_r6v1p_closure" {
     $krep7_r6v1p_closure:
         const :_con_info;
         const $krep1_r6v1j_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.238334062 UTC

[section ""data" . $krep8_r6v1q_closure" {
     $krep8_r6v1q_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcDual_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.240121464 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual1_closure" {
     Data.Semigroup.Internal.$tc'Dual1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep8_r6v1q_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.241847518 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Dual3_bytes" {
     Data.Semigroup.Internal.$tc'Dual3_bytes:
         I8[] [39,68,117,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.243573535 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual2_closure" {
     Data.Semigroup.Internal.$tc'Dual2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Dual3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.245359391 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Dual_closure" {
     Data.Semigroup.Internal.$tc'Dual_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Dual2_closure+1;
         const Data.Semigroup.Internal.$tc'Dual1_closure+4;
         const 15885009659242865261;
         const 15931193389986079612;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.247283426 UTC

[section ""cstring" . Data.Semigroup.Internal.$tcEndo2_bytes" {
     Data.Semigroup.Internal.$tcEndo2_bytes:
         I8[] [69,110,100,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.248970658 UTC

[section ""data" . Data.Semigroup.Internal.$tcEndo1_closure" {
     Data.Semigroup.Internal.$tcEndo1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tcEndo2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.25069959 UTC

[section ""data" . Data.Semigroup.Internal.$tcEndo_closure" {
     Data.Semigroup.Internal.$tcEndo_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcEndo1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 16820921632006328603;
         const 4981834339379479823;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.252548629 UTC

[section ""data" . $krep9_r6v1r_closure" {
     $krep9_r6v1r_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcEndo_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.254340553 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo1_closure" {
     Data.Semigroup.Internal.$tc'Endo1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r6v1k_closure+4;
         const $krep9_r6v1r_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.25622692 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Endo3_bytes" {
     Data.Semigroup.Internal.$tc'Endo3_bytes:
         I8[] [39,69,110,100,111]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.258444693 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo2_closure" {
     Data.Semigroup.Internal.$tc'Endo2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Endo3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.260956841 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Endo_closure" {
     Data.Semigroup.Internal.$tc'Endo_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Endo2_closure+1;
         const Data.Semigroup.Internal.$tc'Endo1_closure+4;
         const 156297185665537802;
         const 8988325904501215692;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.26299048 UTC

[section ""data" . Data.Semigroup.Internal.$tcAll1_closure" {
     Data.Semigroup.Internal.$tcAll1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAll13_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.264718707 UTC

[section ""data" . Data.Semigroup.Internal.$tcAll_closure" {
     Data.Semigroup.Internal.$tcAll_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAll1_closure+1;
         const GHC.Types.krep$*_closure;
         const 14149274874874504208;
         const 8164254778609961234;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.266683835 UTC

[section ""data" . $krep10_r6v1s_closure" {
     $krep10_r6v1s_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAll_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.268473187 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All1_closure" {
     Data.Semigroup.Internal.$tc'All1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r6v1i_closure+1;
         const $krep10_r6v1s_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.270353467 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'All3_bytes" {
     Data.Semigroup.Internal.$tc'All3_bytes:
         I8[] [39,65,108,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.272160765 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All2_closure" {
     Data.Semigroup.Internal.$tc'All2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'All3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.27402055 UTC

[section ""data" . Data.Semigroup.Internal.$tc'All_closure" {
     Data.Semigroup.Internal.$tc'All_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'All2_closure+1;
         const Data.Semigroup.Internal.$tc'All1_closure+4;
         const 1168494541548489787;
         const 10689931498683547374;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.275987267 UTC

[section ""data" . Data.Semigroup.Internal.$tcAny1_closure" {
     Data.Semigroup.Internal.$tcAny1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAny6_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.277877542 UTC

[section ""data" . Data.Semigroup.Internal.$tcAny_closure" {
     Data.Semigroup.Internal.$tcAny_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAny1_closure+1;
         const GHC.Types.krep$*_closure;
         const 11600287624241135668;
         const 17600231731807245316;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.279802691 UTC

[section ""data" . $krep11_r6v1t_closure" {
     $krep11_r6v1t_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAny_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.281704151 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any1_closure" {
     Data.Semigroup.Internal.$tc'Any1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r6v1i_closure+1;
         const $krep11_r6v1t_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.283537108 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Any3_bytes" {
     Data.Semigroup.Internal.$tc'Any3_bytes:
         I8[] [39,65,110,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.285310273 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any2_closure" {
     Data.Semigroup.Internal.$tc'Any2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Any3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.287109255 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Any_closure" {
     Data.Semigroup.Internal.$tc'Any_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Any2_closure+1;
         const Data.Semigroup.Internal.$tc'Any1_closure+4;
         const 16164188984560189013;
         const 110490866064676064;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.289834558 UTC

[section ""data" . Data.Semigroup.Internal.$tcSum1_closure" {
     Data.Semigroup.Internal.$tcSum1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadSum5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.291710837 UTC

[section ""data" . Data.Semigroup.Internal.$tcSum_closure" {
     Data.Semigroup.Internal.$tcSum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcSum1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 7521450980204740829;
         const 14029043805042477297;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.293746316 UTC

[section ""data" . $krep12_r6v1u_closure" {
     $krep12_r6v1u_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcSum_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.295598404 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum1_closure" {
     Data.Semigroup.Internal.$tc'Sum1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep12_r6v1u_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.297480289 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Sum3_bytes" {
     Data.Semigroup.Internal.$tc'Sum3_bytes:
         I8[] [39,83,117,109]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.299219208 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum2_closure" {
     Data.Semigroup.Internal.$tc'Sum2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Sum3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.301027352 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Sum_closure" {
     Data.Semigroup.Internal.$tc'Sum_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Sum2_closure+1;
         const Data.Semigroup.Internal.$tc'Sum1_closure+4;
         const 7144872330799658717;
         const 13465414667749873698;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.303593238 UTC

[section ""data" . Data.Semigroup.Internal.$tcProduct1_closure" {
     Data.Semigroup.Internal.$tcProduct1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadProduct5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.30548748 UTC

[section ""data" . Data.Semigroup.Internal.$tcProduct_closure" {
     Data.Semigroup.Internal.$tcProduct_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcProduct1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 12271745360620305859;
         const 5747185732973757022;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.307398992 UTC

[section ""data" . $krep13_r6v1v_closure" {
     $krep13_r6v1v_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcProduct_closure+1;
         const $krep7_r6v1p_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.309167187 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product1_closure" {
     Data.Semigroup.Internal.$tc'Product1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep13_r6v1v_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.311585433 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Product3_bytes" {
     Data.Semigroup.Internal.$tc'Product3_bytes:
         I8[] [39,80,114,111,100,117,99,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.313356611 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product2_closure" {
     Data.Semigroup.Internal.$tc'Product2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Product3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.315213011 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Product_closure" {
     Data.Semigroup.Internal.$tc'Product_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Product2_closure+1;
         const Data.Semigroup.Internal.$tc'Product1_closure+4;
         const 3191278115598904989;
         const 12638872580785847167;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.318015788 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt2_closure" {
     Data.Semigroup.Internal.$tcAlt2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$fReadAlt5_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.319900011 UTC

[section ""data" . Data.Semigroup.Internal.$tcAlt_closure" {
     Data.Semigroup.Internal.$tcAlt_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tcAlt2_closure+1;
         const Data.Semigroup.Internal.$tcAlt1_closure+4;
         const 7601313288863504805;
         const 2369500163797891218;
         const 1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.321889894 UTC

[section ""data" . $krep14_r6v1w_closure" {
     $krep14_r6v1w_closure:
         const :_con_info;
         const $krep5_r6v1n_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.323695259 UTC

[section ""data" . $krep15_r6v1x_closure" {
     $krep15_r6v1x_closure:
         const :_con_info;
         const $krep4_r6v1m_closure+2;
         const $krep14_r6v1w_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.326338471 UTC

[section ""data" . $krep16_r6v1y_closure" {
     $krep16_r6v1y_closure:
         const :_con_info;
         const $krep1_r6v1j_closure+2;
         const $krep15_r6v1x_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.328170363 UTC

[section ""data" . $krep17_r6v1z_closure" {
     $krep17_r6v1z_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Data.Semigroup.Internal.$tcAlt_closure+1;
         const $krep16_r6v1y_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.329984631 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt1_closure" {
     Data.Semigroup.Internal.$tc'Alt1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r6v1o_closure+3;
         const $krep17_r6v1z_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.331850145 UTC

[section ""cstring" . Data.Semigroup.Internal.$tc'Alt3_bytes" {
     Data.Semigroup.Internal.$tc'Alt3_bytes:
         I8[] [39,65,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.33362881 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt2_closure" {
     Data.Semigroup.Internal.$tc'Alt2_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.Semigroup.Internal.$tc'Alt3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.335434987 UTC

[section ""data" . Data.Semigroup.Internal.$tc'Alt_closure" {
     Data.Semigroup.Internal.$tc'Alt_closure:
         const GHC.Types.TyCon_con_info;
         const Data.Semigroup.Internal.$trModule_closure+1;
         const Data.Semigroup.Internal.$tc'Alt2_closure+1;
         const Data.Semigroup.Internal.$tc'Alt1_closure+4;
         const 1436877498177162483;
         const 16937142347825669760;
         const 3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:01:56.337812366 UTC

[section ""relreadonly" . S6Bb6_srt" {
     S6Bb6_srt:
         const Data.Semigroup.Internal.$fMonoidSum1_closure;
         const Data.Semigroup.Internal.$fMonoidSum2_closure;
         const Data.Semigroup.Internal.$fMonoidSum_$cmconcat_closure;
         const Data.Semigroup.Internal.$fMonoidSum_closure;
         const GHC.Real.^_closure;
         const Data.Semigroup.Internal.$fSemigroupProduct_closure;
         const sat_s6ANw_closure;
         const Data.Semigroup.Internal.$fMonoidProduct1_closure;
         const Data.Semigroup.Internal.$fMonoidProduct2_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_$cmconcat_closure;
         const Data.Semigroup.Internal.$fMonoidProduct_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const Data.Semigroup.Internal.$fShowAlt_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAlt_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Semigroup.Internal.$fReadAll3_closure;
         const GHC.Read.readField_closure;
         const Data.Semigroup.Internal.$fReadAlt2_closure;
         const Data.Semigroup.Internal.$fReadAll_lexeme_closure;
         const Data.Semigroup.Internal.$fReadAlt_lexeme_closure;
         const GHC.Read.list3_closure;
         const Data.Semigroup.Internal.$fReadAlt1_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAlt_$creadList_closure;
         const Data.Semigroup.Internal.$fReadAlt_closure;
         const Data.Semigroup.Internal.$fShowProduct_$cshow_closure;
         const Data.Semigroup.Internal.$fShowProduct_closure;
         const Data.Semigroup.Internal.$fReadProduct2_closure;
         const Data.Semigroup.Internal.$fReadProduct_lexeme_closure;
         const Data.Semigroup.Internal.$fReadProduct1_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadProduct_$creadList_closure;
         const Data.Semigroup.Internal.$fReadProduct_closure;
         const Data.Semigroup.Internal.$fShowSum_$cshow_closure;
         const Data.Semigroup.Internal.$fShowSum_closure;
         const Data.Semigroup.Internal.$fReadSum2_closure;
         const Data.Semigroup.Internal.$fReadSum_lexeme_closure;
         const Data.Semigroup.Internal.$fReadSum1_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadSum_$creadList_closure;
         const Data.Semigroup.Internal.$fReadSum_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const GHC.Show.$fShowBool2_closure;
         const GHC.Show.$fShowBool4_closure;
         const Data.Semigroup.Internal.$fShowAny3_closure;
         const Data.Semigroup.Internal.$w$cshowsPrec2_closure;
         const Data.Semigroup.Internal.$fShowAny_$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll5_closure;
         const Data.Semigroup.Internal.$fShowAll6_closure;
         const Data.Semigroup.Internal.$fShowAny_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAny1_closure;
         const GHC.Read.$fReadBool2_closure;
         const GHC.Read.list3_closure;
         const Data.Semigroup.Internal.$fReadAll3_closure;
         const Text.Read.Lex.$wexpect_closure;
         const Data.Semigroup.Internal.$fReadAll7_closure;
         const Data.Semigroup.Internal.$fReadAny3_closure;
         const Data.Semigroup.Internal.$w$creadPrec1_closure;
         const Data.Semigroup.Internal.$fReadAny_lexeme_closure;
         const Data.Semigroup.Internal.$fReadAny2_closure;
         const Data.Semigroup.Internal.$fReadAny_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadAny1_closure;
         const GHC.Read.list_closure;
         const Data.Semigroup.Internal.$fReadAny_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAny7_closure;
         const Data.Semigroup.Internal.$fShowAll3_closure;
         const Data.Semigroup.Internal.$w$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll_$cshowsPrec_closure;
         const Data.Semigroup.Internal.$fShowAll_$cshow_closure;
         const Data.Semigroup.Internal.$fShowAll1_closure;
         const Data.Semigroup.Internal.$fReadAll8_closure;
         const Data.Semigroup.Internal.$w$creadPrec_closure;
         const Data.Semigroup.Internal.$fReadAll_lexeme1_closure;
         const Data.Semigroup.Internal.$fReadAll2_closure;
         const Data.Semigroup.Internal.$fReadAll_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadAll1_closure;
         const Data.Semigroup.Internal.$fReadAll_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadAll14_closure;
         const Data.Semigroup.Internal.$fReadAll4_closure;
         const Data.Semigroup.Internal.$fShowDual_$cshow_closure;
         const Data.Semigroup.Internal.$fShowDual_closure;
         const Data.Semigroup.Internal.$fReadDual2_closure;
         const Data.Semigroup.Internal.$fReadDual_lexeme_closure;
         const Data.Semigroup.Internal.$fReadDual1_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadsPrec_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadListPrec_closure;
         const Data.Semigroup.Internal.$fReadDual_$creadList_closure;
         const Data.Semigroup.Internal.$fReadDual_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Semigroup.Internal.$fMonoidSum1_closure;
         const Data.Semigroup.Internal.stimesIdempotent_closure;
         const Data.Semigroup.Internal.stimesIdempotent1_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid1_closure;
         const Data.Semigroup.Internal.$fMonoidAny_closure;
         const Data.Semigroup.Internal.$fMonoidAll_closure;
         const sat_s6AY8_closure;
         const lvl7_r6v1d_closure;
         const Data.Semigroup.Internal.$fMonoidProduct1_closure;
         const GHC.Real.even_closure;
         const Data.Semigroup.Internal.stimesMonoid_closure;
         const lvl6_r6v1c_closure;
         const Data.Semigroup.Internal.$fSemigroupAlt_$cstimes_closure;
         const Data.Semigroup.Internal.$fSemigroupAlt_closure;
         const Data.Semigroup.Internal.$fMonoidAlt_closure;
         const Data.Semigroup.Internal.$fMonoidEndo_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const lvl9_r6v1f_closure;
         const Data.Semigroup.Internal.stimesMaybe_closure;
         const Data.Semigroup.Internal.stimesMaybe1_closure;
         const Data.Semigroup.Internal.stimesList_closure;
         const Data.Semigroup.Internal.stimesList1_closure;
 }]

