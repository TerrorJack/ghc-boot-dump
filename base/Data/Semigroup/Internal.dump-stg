
==================== Pre unarise: ====================
2018-03-16 16:01:42.887842897 UTC

Data.Semigroup.Internal.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     Data.Semigroup.Internal.Dual a
     -> [Data.Semigroup.Internal.Dual a]
     -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6v1B ww_s6v1C ww1_s6v1D]
        let {
          go_s6v1E [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Dual a_s6uKL
               -> [Data.Semigroup.Internal.Dual a_s6uKL]
               -> Data.Semigroup.Internal.Dual a_s6uKL
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6v1B go_s6v1E] \r [b_s6v1F ds1_s6v1G]
                  case ds1_s6v1G of {
                    [] -> b_s6v1F;
                    : c_s6v1I [Occ=Once] cs_s6v1J [Occ=Once] ->
                        let {
                          sat_s6v1K [Occ=Once] :: a_s6uKL
                          [LclId] =
                              [go_s6v1E c_s6v1I cs_s6v1J] \u [] go_s6v1E c_s6v1I cs_s6v1J;
                        } in  GHC.Base.<> w_s6v1B sat_s6v1K b_s6v1F;
                  };
        } in  go_s6v1E ww_s6v1C ww1_s6v1D;

Data.Semigroup.Internal.$fSemigroupDual_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Dual a)
     -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6v1L w1_s6v1M]
        case w1_s6v1M of {
          GHC.Base.:| ww1_s6v1O [Occ=Once] ww2_s6v1P [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat1 w_s6v1L ww1_s6v1O ww2_s6v1P;
        };

Data.Semigroup.Internal.$fSemigroupDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s6v1Q]
        let {
          sat_s6v1Y [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6v1Q] \r [$dIntegral_s6v1V n_s6v1W ds_s6v1X]
                  GHC.Base.stimes
                      $dSemigroup_s6v1Q $dIntegral_s6v1V n_s6v1W ds_s6v1X; } in
        let {
          sat_s6v1U [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Dual a_X6tId)
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6v1Q] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupDual_$csconcat
                      $dSemigroup_s6v1Q eta_B1; } in
        let {
          sat_s6v1T [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6v1Q] \r [ds_s6v1R ds1_s6v1S]
                  GHC.Base.<> $dSemigroup_s6v1Q ds1_s6v1S ds_s6v1R;
        } in  GHC.Base.C:Semigroup [sat_s6v1T sat_s6v1U sat_s6v1Y];

Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6v1Z]
        let {
          sat_s6v20 [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a6tBw
          [LclId] =
              [$dMonoid_s6v1Z] \u [] GHC.Base.$p1Monoid $dMonoid_s6v1Z;
        } in  Data.Semigroup.Internal.$fSemigroupDual sat_s6v20;

$cmappend_r6v15
  :: forall a.
     GHC.Base.Monoid a =>
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dMonoid_s6v21 ds_s6v22 ds1_s6v23]
        case GHC.Base.$p1Monoid $dMonoid_s6v21 of sat_s6v24 {
          __DEFAULT -> GHC.Base.<> sat_s6v24 ds1_s6v23 ds_s6v22;
        };

Data.Semigroup.Internal.$fMonoidDual_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Base.Monoid a =>
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $cmappend_r6v15 eta_B3 eta_B2 eta_B1;

Data.Semigroup.Internal.$fMonoidDual_$cmconcat
  :: forall a.
     GHC.Base.Monoid a =>
     [Data.Semigroup.Internal.Dual a] -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6v25 eta_s6v26]
        let {
          lvl12_s6v27 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X6tHX
          [LclId] =
              [$dMonoid_s6v25] \u [] GHC.Base.$p1Monoid $dMonoid_s6v25; } in
        let {
          z_s6v28 [Occ=OnceL] :: a_X6tHX
          [LclId] =
              [$dMonoid_s6v25] \u [] GHC.Base.mempty $dMonoid_s6v25; } in
        let {
          go_s6v29 [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Dual a_X6tHX]
               -> Data.Semigroup.Internal.Dual a_X6tHX
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [lvl12_s6v27 z_s6v28 go_s6v29] \r [ds_s6v2a]
                  case ds_s6v2a of {
                    [] -> z_s6v28;
                    : y_s6v2c [Occ=Once] ys_s6v2d [Occ=Once] ->
                        let {
                          sat_s6v2e [Occ=Once] :: a_X6tHX
                          [LclId] =
                              [go_s6v29 ys_s6v2d] \u [] go_s6v29 ys_s6v2d;
                        } in  GHC.Base.<> lvl12_s6v27 sat_s6v2e y_s6v2c;
                  };
        } in  go_s6v29 eta_s6v26;

Data.Semigroup.Internal.$fMonoidDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s6v2f]
        let {
          sat_s6v2j [Occ=Once]
            :: [Data.Semigroup.Internal.Dual a_a6tBw]
               -> Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6v2f] \r [eta_B1]
                  Data.Semigroup.Internal.$fMonoidDual_$cmconcat
                      $dMonoid_s6v2f eta_B1; } in
        let {
          sat_s6v2i [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6tBw
               -> Data.Semigroup.Internal.Dual a_a6tBw
               -> Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6v2f] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fMonoidDual_$cmappend
                      $dMonoid_s6v2f eta_B2 eta_B1; } in
        let {
          sat_s6v2h [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6v2f] \u [] GHC.Base.mempty $dMonoid_s6v2f; } in
        let {
          sat_s6v2g [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a_a6tBw)
          [LclId] =
              [$dMonoid_s6v2f] \u []
                  Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid $dMonoid_s6v2f;
        } in  GHC.Base.C:Monoid [sat_s6v2g sat_s6v2h sat_s6v2i sat_s6v2j];

Data.Semigroup.Internal.$fFunctorDual2
  :: forall a b. (a -> b) -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6v2k] v_s6v2k;

Data.Semigroup.Internal.$fFunctorDual1 :: forall b a. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6v2l ds_s6v2m] x_s6v2l;

Data.Semigroup.Internal.$fFunctorDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeDual3
  :: forall a b.
     Data.Semigroup.Internal.Dual (a -> b)
     -> Data.Semigroup.Internal.Dual (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6v2n] v_s6v2n;

Data.Semigroup.Internal.$fApplicativeDual4 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6v2o] v_s6v2o;

Data.Semigroup.Internal.$fApplicativeDual2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Dual a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6v2p x_s6v2q] f1_s6v2p x_s6v2q;

Data.Semigroup.Internal.$fApplicativeDual_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6v2r a2_s6v2s] a2_s6v2s;

Data.Semigroup.Internal.$fApplicativeDual1
  :: forall b a.
     Data.Semigroup.Internal.Dual a
     -> b -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6v2t ds_s6v2u] x_s6v2t;

Data.Semigroup.Internal.$fApplicativeDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorDual
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeDual3
                                           Data.Semigroup.Internal.$fApplicativeDual2
                                           Data.Semigroup.Internal.$fApplicativeDual_$c*>
                                           Data.Semigroup.Internal.$fApplicativeDual1];

Data.Semigroup.Internal.$fSemigroupSum1
  :: forall a.
     GHC.Num.Num a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.Sum a -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><L,1*U(A,A,A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6v2v $dIntegral_s6v2w n_s6v2x ds_s6v2y]
        let {
          sat_s6v2A [Occ=Once] :: a_a6two
          [LclId] =
              [$dNum_s6v2v $dIntegral_s6v2w n_s6v2x] \u []
                  let {
                    sat_s6v2z [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [$dIntegral_s6v2w n_s6v2x] \u []
                            GHC.Real.toInteger $dIntegral_s6v2w n_s6v2x;
                  } in  GHC.Num.fromInteger $dNum_s6v2v sat_s6v2z;
        } in  GHC.Num.* $dNum_s6v2v sat_s6v2A ds_s6v2y;

Data.Semigroup.Internal.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Sum a
     -> [Data.Semigroup.Internal.Sum a] -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6v2B ww_s6v2C ww1_s6v2D]
        let {
          go_s6v2E [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Sum a_s6uL0
               -> [Data.Semigroup.Internal.Sum a_s6uL0]
               -> Data.Semigroup.Internal.Sum a_s6uL0
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6v2B go_s6v2E] \r [b_s6v2F ds1_s6v2G]
                  case ds1_s6v2G of {
                    [] -> b_s6v2F;
                    : c_s6v2I [Occ=Once] cs_s6v2J [Occ=Once] ->
                        let {
                          sat_s6v2K [Occ=Once] :: a_s6uL0
                          [LclId] =
                              [go_s6v2E c_s6v2I cs_s6v2J] \u [] go_s6v2E c_s6v2I cs_s6v2J;
                        } in  GHC.Num.+ w_s6v2B b_s6v2F sat_s6v2K;
                  };
        } in  go_s6v2E ww_s6v2C ww1_s6v2D;

Data.Semigroup.Internal.$fSemigroupSum_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Sum a)
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A,A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6v2L w1_s6v2M]
        case w1_s6v2M of {
          GHC.Base.:| ww1_s6v2O [Occ=Once] ww2_s6v2P [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat3 w_s6v2L ww1_s6v2O ww2_s6v2P;
        };

Data.Semigroup.Internal.$fSemigroupSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U,A,C(C1(U)),A,A,A,C(U))>m] =
    [] \r [$dNum_s6v2Q]
        let {
          sat_s6v2T [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6v2Q] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fSemigroupSum1
                      $dNum_s6v2Q eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6v2S [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Sum a_X6tDl)
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6v2Q] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupSum_$csconcat
                      $dNum_s6v2Q eta_B1; } in
        let {
          sat_s6v2R [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6v2Q] \u [] GHC.Num.+ $dNum_s6v2Q;
        } in  GHC.Base.C:Semigroup [sat_s6v2R sat_s6v2S sat_s6v2T];

Data.Semigroup.Internal.$fMonoidSum1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Semigroup.Internal.$fMonoidSum2
  :: forall a. GHC.Num.Num a => a
[GblId,
 Arity=1,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6v2U]
        GHC.Num.fromInteger
            $dNum_s6v2U Data.Semigroup.Internal.$fMonoidSum1;

Data.Semigroup.Internal.$fMonoidSum_$cmconcat
  :: forall a.
     GHC.Num.Num a =>
     [Data.Semigroup.Internal.Sum a] -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6v2V]
        let {
          z_s6v2W [Occ=OnceL] :: a_X6tD4
          [LclId] =
              [$dNum_s6v2V] \u []
                  GHC.Num.fromInteger
                      $dNum_s6v2V Data.Semigroup.Internal.$fMonoidSum1; } in
        let {
          go_s6v2X [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Sum a_X6tD4]
               -> Data.Semigroup.Internal.Sum a_X6tD4
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dNum_s6v2V z_s6v2W go_s6v2X] \r [ds_s6v2Y]
                  case ds_s6v2Y of {
                    [] -> z_s6v2W;
                    : y_s6v30 [Occ=Once] ys_s6v31 [Occ=Once] ->
                        let {
                          sat_s6v32 [Occ=Once] :: a_X6tD4
                          [LclId] =
                              [go_s6v2X ys_s6v31] \u [] go_s6v2X ys_s6v31;
                        } in  GHC.Num.+ $dNum_s6v2V y_s6v30 sat_s6v32;
                  };
        } in  go_s6v2X;

Data.Semigroup.Internal.$fMonoidSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(U,A,C(C1(U)),A,A,A,C(U))>m] =
    [] \r [$dNum_s6v33]
        let {
          sat_s6v37 [Occ=Once]
            :: [Data.Semigroup.Internal.Sum a_X6tD2]
               -> Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6v33] \u []
                  Data.Semigroup.Internal.$fMonoidSum_$cmconcat $dNum_s6v33; } in
        let {
          sat_s6v36 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_X6tD2
               -> Data.Semigroup.Internal.Sum a_X6tD2
               -> Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6v33] \u [] GHC.Num.+ $dNum_s6v33; } in
        let {
          sat_s6v35 [Occ=Once] :: Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6v33] \u []
                  Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6v33; } in
        let {
          sat_s6v34 [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Sum a_X6tD2)
          [LclId] =
              [$dNum_s6v33] \u []
                  Data.Semigroup.Internal.$fSemigroupSum $dNum_s6v33;
        } in  GHC.Base.C:Monoid [sat_s6v34 sat_s6v35 sat_s6v36 sat_s6v37];

Data.Semigroup.Internal.$fFunctorSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeSum3
  :: forall a b.
     Data.Semigroup.Internal.Sum (a -> b)
     -> Data.Semigroup.Internal.Sum (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6v38] v_s6v38;

Data.Semigroup.Internal.$fApplicativeSum2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Sum a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6v39 x_s6v3a] f1_s6v39 x_s6v3a;

Data.Semigroup.Internal.$fApplicativeSum_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6v3b a2_s6v3c] a2_s6v3c;

Data.Semigroup.Internal.$fApplicativeSum1
  :: forall b a.
     Data.Semigroup.Internal.Sum a -> b -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6v3d ds_s6v3e] x_s6v3d;

Data.Semigroup.Internal.$fApplicativeSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorSum
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeSum3
                                           Data.Semigroup.Internal.$fApplicativeSum2
                                           Data.Semigroup.Internal.$fApplicativeSum_$c*>
                                           Data.Semigroup.Internal.$fApplicativeSum1];

Data.Semigroup.Internal.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Product a
     -> [Data.Semigroup.Internal.Product a]
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6v3f ww_s6v3g ww1_s6v3h]
        let {
          go_s6v3i [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Product a_s6uLe
               -> [Data.Semigroup.Internal.Product a_s6uLe]
               -> Data.Semigroup.Internal.Product a_s6uLe
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6v3f go_s6v3i] \r [b_s6v3j ds1_s6v3k]
                  case ds1_s6v3k of {
                    [] -> b_s6v3j;
                    : c_s6v3m [Occ=Once] cs_s6v3n [Occ=Once] ->
                        let {
                          sat_s6v3o [Occ=Once] :: a_s6uLe
                          [LclId] =
                              [go_s6v3i c_s6v3m cs_s6v3n] \u [] go_s6v3i c_s6v3m cs_s6v3n;
                        } in  GHC.Num.* w_s6v3f b_s6v3j sat_s6v3o;
                  };
        } in  go_s6v3i ww_s6v3g ww1_s6v3h;

Data.Semigroup.Internal.$fSemigroupProduct_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Product a)
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6v3p w1_s6v3q]
        case w1_s6v3q of {
          GHC.Base.:| ww1_s6v3s [Occ=Once] ww2_s6v3t [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat2 w_s6v3p ww1_s6v3s ww2_s6v3t;
        };

Data.Semigroup.Internal.$fSemigroupProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A,A,A,C(U))>m] =
    [] \r [$dNum_s6v3u]
        let {
          sat_s6v3A [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6v3u] \r [$dIntegral_s6v3x n_s6v3y ds_s6v3z]
                  GHC.Real.^ $dNum_s6v3u $dIntegral_s6v3x ds_s6v3z n_s6v3y; } in
        let {
          sat_s6v3w [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Product a_X6tB3)
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6v3u] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupProduct_$csconcat
                      $dNum_s6v3u eta_B1; } in
        let {
          sat_s6v3v [Occ=Once]
            :: Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6v3u] \u [] GHC.Num.* $dNum_s6v3u;
        } in  GHC.Base.C:Semigroup [sat_s6v3v sat_s6v3w sat_s6v3A];

sat_s6v3B :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s6v3C :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6v3B GHC.Types.[]];

Data.Semigroup.Internal.$fMonoidProduct1
  :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6v3C;

Data.Semigroup.Internal.$fMonoidProduct2
  :: forall a. GHC.Num.Num a => a
[GblId,
 Arity=1,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6v3D]
        GHC.Num.fromInteger
            $dNum_s6v3D Data.Semigroup.Internal.$fMonoidProduct1;

Data.Semigroup.Internal.$fMonoidProduct_$cmconcat
  :: forall a.
     GHC.Num.Num a =>
     [Data.Semigroup.Internal.Product a]
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6v3E]
        let {
          z_s6v3F [Occ=OnceL] :: a_X6tAM
          [LclId] =
              [$dNum_s6v3E] \u []
                  GHC.Num.fromInteger
                      $dNum_s6v3E Data.Semigroup.Internal.$fMonoidProduct1; } in
        let {
          go_s6v3G [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Product a_X6tAM]
               -> Data.Semigroup.Internal.Product a_X6tAM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dNum_s6v3E z_s6v3F go_s6v3G] \r [ds_s6v3H]
                  case ds_s6v3H of {
                    [] -> z_s6v3F;
                    : y_s6v3J [Occ=Once] ys_s6v3K [Occ=Once] ->
                        let {
                          sat_s6v3L [Occ=Once] :: a_X6tAM
                          [LclId] =
                              [go_s6v3G ys_s6v3K] \u [] go_s6v3G ys_s6v3K;
                        } in  GHC.Num.* $dNum_s6v3E y_s6v3J sat_s6v3L;
                  };
        } in  go_s6v3G;

Data.Semigroup.Internal.$fMonoidProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A,A,A,C(U))>m] =
    [] \r [$dNum_s6v3M]
        let {
          sat_s6v3Q [Occ=Once]
            :: [Data.Semigroup.Internal.Product a_X6tAK]
               -> Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6v3M] \u []
                  Data.Semigroup.Internal.$fMonoidProduct_$cmconcat $dNum_s6v3M; } in
        let {
          sat_s6v3P [Occ=Once]
            :: Data.Semigroup.Internal.Product a_X6tAK
               -> Data.Semigroup.Internal.Product a_X6tAK
               -> Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6v3M] \u [] GHC.Num.* $dNum_s6v3M; } in
        let {
          sat_s6v3O [Occ=Once] :: Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6v3M] \u []
                  Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6v3M; } in
        let {
          sat_s6v3N [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Product a_X6tAK)
          [LclId] =
              [$dNum_s6v3M] \u []
                  Data.Semigroup.Internal.$fSemigroupProduct $dNum_s6v3M;
        } in  GHC.Base.C:Monoid [sat_s6v3N sat_s6v3O sat_s6v3P sat_s6v3Q];

Data.Semigroup.Internal.$fFunctorProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeProduct3
  :: forall a b.
     Data.Semigroup.Internal.Product (a -> b)
     -> Data.Semigroup.Internal.Product (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6v3R] v_s6v3R;

Data.Semigroup.Internal.$fApplicativeProduct2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Product a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6v3S x_s6v3T] f1_s6v3S x_s6v3T;

Data.Semigroup.Internal.$fApplicativeProduct_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6v3U a2_s6v3V] a2_s6v3V;

Data.Semigroup.Internal.$fApplicativeProduct1
  :: forall b a.
     Data.Semigroup.Internal.Product a
     -> b -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6v3W ds_s6v3X] x_s6v3W;

Data.Semigroup.Internal.$fApplicativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorProduct
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeProduct3
                                           Data.Semigroup.Internal.$fApplicativeProduct2
                                           Data.Semigroup.Internal.$fApplicativeProduct_$c*>
                                           Data.Semigroup.Internal.$fApplicativeProduct1];

Data.Semigroup.Internal.$fFunctorAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     GHC.Base.Functor (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dFunctor_s6v3Y]
        let {
          sat_s6v40 [Occ=Once]
            :: forall a b.
               a
               -> Data.Semigroup.Internal.Alt f_a6tow b
               -> Data.Semigroup.Internal.Alt f_a6tow a
          [LclId] =
              [$dFunctor_s6v3Y] \u [] GHC.Base.<$ $dFunctor_s6v3Y; } in
        let {
          sat_s6v3Z [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Semigroup.Internal.Alt f_a6tow a
               -> Data.Semigroup.Internal.Alt f_a6tow b
          [LclId] =
              [$dFunctor_s6v3Y] \u [] GHC.Base.fmap $dFunctor_s6v3Y;
        } in  GHC.Base.C:Functor [sat_s6v3Z sat_s6v40];

Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Functor (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s6v41]
        let {
          sat_s6v42 [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_a6tkt
          [LclId] =
              [$dApplicative_s6v41] \u []
                  GHC.Base.$p1Applicative $dApplicative_s6v41;
        } in  Data.Semigroup.Internal.$fFunctorAlt sat_s6v42;

Data.Semigroup.Internal.$fApplicativeAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dApplicative_s6v43]
        let {
          sat_s6v49 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt a
          [LclId] =
              [$dApplicative_s6v43] \u [] GHC.Base.<* $dApplicative_s6v43; } in
        let {
          sat_s6v48 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt b
          [LclId] =
              [$dApplicative_s6v43] \u [] GHC.Base.*> $dApplicative_s6v43; } in
        let {
          sat_s6v47 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt c
          [LclId] =
              [$dApplicative_s6v43] \u []
                  GHC.Base.liftA2 $dApplicative_s6v43; } in
        let {
          sat_s6v46 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt (a -> b)
               -> Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
          [LclId] =
              [$dApplicative_s6v43] \u [] GHC.Base.<*> $dApplicative_s6v43; } in
        let {
          sat_s6v45 [Occ=Once]
            :: forall a. a -> Data.Semigroup.Internal.Alt f_a6tkt a
          [LclId] =
              [$dApplicative_s6v43] \u [] GHC.Base.pure $dApplicative_s6v43; } in
        let {
          sat_s6v44 [Occ=Once]
            :: GHC.Base.Functor (Data.Semigroup.Internal.Alt f_a6tkt)
          [LclId] =
              [$dApplicative_s6v43] \u []
                  Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative
                      $dApplicative_s6v43;
        } in 
          GHC.Base.C:Applicative [sat_s6v44
                                  sat_s6v45
                                  sat_s6v46
                                  sat_s6v47
                                  sat_s6v48
                                  sat_s6v49];

Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6v4a]
        let {
          sat_s6v4b [Occ=Once, Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Applicative f_a6tn6
          [LclId] =
              [$dAlternative_s6v4a] \u []
                  GHC.Base.$p1Alternative $dAlternative_s6v4a;
        } in  Data.Semigroup.Internal.$fApplicativeAlt sat_s6v4b;

Data.Semigroup.Internal.$fAlternativeAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Alternative (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>m] =
    [] \r [$dAlternative_s6v4c]
        let {
          sat_s6v4h [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 [a]
          [LclId] =
              [$dAlternative_s6v4c] \u [] GHC.Base.many $dAlternative_s6v4c; } in
        let {
          sat_s6v4g [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 [a]
          [LclId] =
              [$dAlternative_s6v4c] \u [] GHC.Base.some $dAlternative_s6v4c; } in
        let {
          sat_s6v4f [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 a
          [LclId] =
              [$dAlternative_s6v4c] \u [] GHC.Base.<|> $dAlternative_s6v4c; } in
        let {
          sat_s6v4e [Occ=Once]
            :: forall a. Data.Semigroup.Internal.Alt f_a6tn6 a
          [LclId] =
              [$dAlternative_s6v4c] \u []
                  GHC.Base.empty $dAlternative_s6v4c; } in
        let {
          sat_s6v4d [Occ=Once]
            :: GHC.Base.Applicative (Data.Semigroup.Internal.Alt f_a6tn6)
          [LclId] =
              [$dAlternative_s6v4c] \u []
                  Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative
                      $dAlternative_s6v4c;
        } in 
          GHC.Base.C:Alternative [sat_s6v4d
                                  sat_s6v4e
                                  sat_s6v4f
                                  sat_s6v4g
                                  sat_s6v4h];

Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.Alternative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s6v4i]
        let {
          sat_s6v4j [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Alternative f_a6tjD
          [LclId] =
              [$dMonadPlus_s6v4i] \u [] GHC.Base.$p1MonadPlus $dMonadPlus_s6v4i;
        } in  Data.Semigroup.Internal.$fAlternativeAlt sat_s6v4j;

Data.Semigroup.Internal.$fMonadAlt_$cp1Monad
  :: forall (f :: * -> *).
     GHC.Base.Monad f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_s6v4k]
        let {
          sat_s6v4l [Occ=Once, Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Applicative f_a6thT
          [LclId] =
              [$dMonad_s6v4k] \u [] GHC.Base.$p1Monad $dMonad_s6v4k;
        } in  Data.Semigroup.Internal.$fApplicativeAlt sat_s6v4l;

Data.Semigroup.Internal.$fMonadAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Monad f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>m] =
    [] \r [$dMonad_s6v4m]
        let {
          sat_s6v4r [Occ=Once]
            :: forall a.
               GHC.Base.String -> Data.Semigroup.Internal.Alt f_a6thT a
          [LclId] =
              [$dMonad_s6v4m] \u [] GHC.Base.fail $dMonad_s6v4m; } in
        let {
          sat_s6v4q [Occ=Once]
            :: forall a. a -> Data.Semigroup.Internal.Alt f_a6thT a
          [LclId] =
              [$dMonad_s6v4m] \u [] GHC.Base.return $dMonad_s6v4m; } in
        let {
          sat_s6v4p [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6thT a
               -> Data.Semigroup.Internal.Alt f_a6thT b
               -> Data.Semigroup.Internal.Alt f_a6thT b
          [LclId] =
              [$dMonad_s6v4m] \u [] GHC.Base.>> $dMonad_s6v4m; } in
        let {
          sat_s6v4o [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6thT a
               -> (a -> Data.Semigroup.Internal.Alt f_a6thT b)
               -> Data.Semigroup.Internal.Alt f_a6thT b
          [LclId] =
              [$dMonad_s6v4m] \u [] GHC.Base.>>= $dMonad_s6v4m; } in
        let {
          sat_s6v4n [Occ=Once]
            :: GHC.Base.Applicative (Data.Semigroup.Internal.Alt f_a6thT)
          [LclId] =
              [$dMonad_s6v4m] \u []
                  Data.Semigroup.Internal.$fMonadAlt_$cp1Monad $dMonad_s6v4m;
        } in 
          GHC.Base.C:Monad [sat_s6v4n
                            sat_s6v4o
                            sat_s6v4p
                            sat_s6v4q
                            sat_s6v4r];

Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s6v4s]
        let {
          sat_s6v4t [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_a6tjD
          [LclId] =
              [$dMonadPlus_s6v4s] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_s6v4s;
        } in  Data.Semigroup.Internal.$fMonadAlt sat_s6v4t;

Data.Semigroup.Internal.$fMonadPlusAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.MonadPlus (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),1*U,1*U)>m] =
    [] \r [$dMonadPlus_s6v4u]
        let {
          sat_s6v4y [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tjD a
               -> Data.Semigroup.Internal.Alt f_a6tjD a
               -> Data.Semigroup.Internal.Alt f_a6tjD a
          [LclId] =
              [$dMonadPlus_s6v4u] \u [] GHC.Base.mplus $dMonadPlus_s6v4u; } in
        let {
          sat_s6v4x [Occ=Once]
            :: forall a. Data.Semigroup.Internal.Alt f_a6tjD a
          [LclId] =
              [$dMonadPlus_s6v4u] \u [] GHC.Base.mzero $dMonadPlus_s6v4u; } in
        let {
          sat_s6v4w [Occ=Once]
            :: GHC.Base.Monad (Data.Semigroup.Internal.Alt f_a6tjD)
          [LclId] =
              [$dMonadPlus_s6v4u] \u []
                  Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus
                      $dMonadPlus_s6v4u; } in
        let {
          sat_s6v4v [Occ=Once]
            :: GHC.Base.Alternative (Data.Semigroup.Internal.Alt f_a6tjD)
          [LclId] =
              [$dMonadPlus_s6v4u] \u []
                  Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus
                      $dMonadPlus_s6v4u;
        } in 
          GHC.Base.C:MonadPlus [sat_s6v4v sat_s6v4w sat_s6v4x sat_s6v4y];

Data.Semigroup.Internal.$fEnumAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Enum.Enum (f a) =>
     GHC.Enum.Enum (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dEnum_s6v4z]
        let {
          sat_s6v4H [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.enumFromThenTo $dEnum_s6v4z; } in
        let {
          sat_s6v4G [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.enumFromTo $dEnum_s6v4z; } in
        let {
          sat_s6v4F [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.enumFromThen $dEnum_s6v4z; } in
        let {
          sat_s6v4E [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.enumFrom $dEnum_s6v4z; } in
        let {
          sat_s6v4D [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm -> GHC.Types.Int
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.fromEnum $dEnum_s6v4z; } in
        let {
          sat_s6v4C [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.toEnum $dEnum_s6v4z; } in
        let {
          sat_s6v4B [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.pred $dEnum_s6v4z; } in
        let {
          sat_s6v4A [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.succ $dEnum_s6v4z;
        } in 
          GHC.Enum.C:Enum [sat_s6v4A
                           sat_s6v4B
                           sat_s6v4C
                           sat_s6v4D
                           sat_s6v4E
                           sat_s6v4F
                           sat_s6v4G
                           sat_s6v4H];

Data.Semigroup.Internal.$fNumAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Num.Num (f a) =>
     GHC.Num.Num (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6v4I]
        let {
          sat_s6v4P [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.fromInteger $dNum_s6v4I; } in
        let {
          sat_s6v4O [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.signum $dNum_s6v4I; } in
        let {
          sat_s6v4N [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.abs $dNum_s6v4I; } in
        let {
          sat_s6v4M [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.negate $dNum_s6v4I; } in
        let {
          sat_s6v4L [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.* $dNum_s6v4I; } in
        let {
          sat_s6v4K [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.- $dNum_s6v4I; } in
        let {
          sat_s6v4J [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.+ $dNum_s6v4I;
        } in 
          GHC.Num.C:Num [sat_s6v4J
                         sat_s6v4K
                         sat_s6v4L
                         sat_s6v4M
                         sat_s6v4N
                         sat_s6v4O
                         sat_s6v4P];

Data.Semigroup.Internal.$fEqAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Eq (f a) =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6v4Q]
        let {
          sat_s6v4S [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6txq a_X6txt
               -> Data.Semigroup.Internal.Alt f_X6txq a_X6txt -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v4Q] \u [] GHC.Classes./= $dEq_s6v4Q; } in
        let {
          sat_s6v4R [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6txq a_X6txt
               -> Data.Semigroup.Internal.Alt f_X6txq a_X6txt -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v4Q] \u [] GHC.Classes.== $dEq_s6v4Q;
        } in  GHC.Classes.C:Eq [sat_s6v4R sat_s6v4S];

Data.Semigroup.Internal.$fOrdAlt_$cp1Ord
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Ord (f a) =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Alt f a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6v4T]
        let {
          sat_s6v4U [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Classes.Eq (f_X6tn1 a_X6tn3)
          [LclId] =
              [$dOrd_s6v4T] \u [] GHC.Classes.$p1Ord $dOrd_s6v4T;
        } in  Data.Semigroup.Internal.$fEqAlt sat_s6v4U;

Data.Semigroup.Internal.$fOrdAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Ord (f a) =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6v4V]
        let {
          sat_s6v53 [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.min $dOrd_s6v4V; } in
        let {
          sat_s6v52 [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.max $dOrd_s6v4V; } in
        let {
          sat_s6v51 [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.>= $dOrd_s6v4V; } in
        let {
          sat_s6v50 [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.> $dOrd_s6v4V; } in
        let {
          sat_s6v4Z [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.<= $dOrd_s6v4V; } in
        let {
          sat_s6v4Y [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.< $dOrd_s6v4V; } in
        let {
          sat_s6v4X [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.compare $dOrd_s6v4V; } in
        let {
          sat_s6v4W [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4)
          [LclId] =
              [$dOrd_s6v4V] \u []
                  Data.Semigroup.Internal.$fOrdAlt_$cp1Ord $dOrd_s6v4V;
        } in 
          GHC.Classes.C:Ord [sat_s6v4W
                             sat_s6v4X
                             sat_s6v4Y
                             sat_s6v4Z
                             sat_s6v50
                             sat_s6v51
                             sat_s6v52
                             sat_s6v53];

Data.Semigroup.Internal.$fShowAlt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Semigroup.Internal.$fShowAlt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alt {"#;

Data.Semigroup.Internal.$fShowAlt2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAlt = "#;

Data.Semigroup.Internal.$fReadAll5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Semigroup.Internal.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Alt f a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v54 ww_s6v55 w1_s6v56]
        let {
          f1_s6v57 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6v54 w1_s6v56] \u []
                  GHC.Show.showsPrec
                      w_s6v54 Data.Semigroup.Internal.$fShowAlt1 w1_s6v56;
        } in 
          case >=# [ww_s6v55 11#] of {
            __DEFAULT ->
                let {
                  sat_s6v5d [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f1_s6v57] \r [x_s6v59]
                          let {
                            sat_s6v5c [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_s6v57 x_s6v59] \u []
                                    let {
                                      sat_s6v5b [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_s6v57 x_s6v59] \u []
                                              let {
                                                sat_s6v5a [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6v59] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6v59;
                                              } in  f1_s6v57 sat_s6v5a;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowAlt2 sat_s6v5b;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowAlt3 sat_s6v5c;
                } in  sat_s6v5d;
            1# ->
                let {
                  sat_s6v5k [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f1_s6v57] \r [x_s6v5e]
                          let {
                            sat_s6v5j [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_s6v57 x_s6v5e] \u []
                                    let {
                                      sat_s6v5i [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_s6v57 x_s6v5e] \u []
                                              let {
                                                sat_s6v5h [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f1_s6v57 x_s6v5e] \u []
                                                        let {
                                                          sat_s6v5g [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6v5e] \u []
                                                                  let {
                                                                    sat_s6v5f [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6v5e];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6v5f;
                                                        } in  f1_s6v57 sat_s6v5g;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowAlt2 sat_s6v5h;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowAlt3 sat_s6v5i;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6v5j];
                } in  sat_s6v5k;
          };

Data.Semigroup.Internal.$fShowAlt_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Types.Int -> Data.Semigroup.Internal.Alt f a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v5l w1_s6v5m w2_s6v5n]
        case w1_s6v5m of {
          GHC.Types.I# ww1_s6v5p [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec1 w_s6v5l ww1_s6v5p w2_s6v5n;
        };

Data.Semigroup.Internal.$fReadAll4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll5;

Data.Semigroup.Internal.$fShowAlt_$cshow
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     Data.Semigroup.Internal.Alt f a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v5q x_s6v5r]
        let {
          sat_s6v5t [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6v5q x_s6v5r] \u []
                  let {
                    sat_s6v5s [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6v5q x_s6v5r] \u []
                            GHC.Show.showsPrec
                                $dShow_s6v5q
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6v5r
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAlt2 sat_s6v5s;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowAlt3 sat_s6v5t;

Data.Semigroup.Internal.$fShowAlt_$cshowList
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     [Data.Semigroup.Internal.Alt f a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v5u ls_s6v5v s_s6v5w]
        let {
          sat_s6v5y [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v5u] \r [w_s6v5x]
                  Data.Semigroup.Internal.$w$cshowsPrec1 $dShow_s6v5u 0# w_s6v5x;
        } in  GHC.Show.showList__ sat_s6v5y ls_s6v5v s_s6v5w;

Data.Semigroup.Internal.$fShowAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Show.Show (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6v5z]
        let {
          sat_s6v5C [Occ=Once]
            :: [Data.Semigroup.Internal.Alt f_a6taL a_a6taM] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v5z] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshowList
                      $dShow_s6v5z eta_B2 eta_B1; } in
        let {
          sat_s6v5B [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Base.String
          [LclId] =
              [$dShow_s6v5z] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshow $dShow_s6v5z eta_B1; } in
        let {
          sat_s6v5A [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v5z] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshowsPrec
                      $dShow_s6v5z eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6v5A sat_s6v5B sat_s6v5C];

Data.Semigroup.Internal.$fReadAlt5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alt"#;

Data.Semigroup.Internal.$fReadAlt4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAlt5;

Data.Semigroup.Internal.$fReadAlt_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAlt4];

Data.Semigroup.Internal.$fReadAll11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Semigroup.Internal.$fReadAll10 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll11;

Data.Semigroup.Internal.$fReadAll_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.Internal.$fReadAll10];

Data.Semigroup.Internal.$fReadAlt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAlt"#;

Data.Semigroup.Internal.$fReadAlt2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAlt3;

Data.Semigroup.Internal.$fReadAll6 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Semigroup.Internal.$fReadAll3 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.Internal.$fReadAll4];

Data.Semigroup.Internal.$fReadAlt1
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Alt f a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v5D]
        let {
          lvl12_s6v5E [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP (f_a6t9S a_a6t9T)
          [LclId] =
              [$dRead_s6v5D] \u []
                  GHC.Read.readPrec
                      $dRead_s6v5D Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6v5F [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP (f_a6t9S a_a6t9T)
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6v5E] \r [ds1_s6v5G] lvl12_s6v5E; } in
        let {
          sat_s6v60 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_a6t9S a_a6t9T)
          [LclId] =
              [ds_s6v5F] \r [c_s6v5H eta_s6v5I]
                  case c_s6v5H of {
                    GHC.Types.I# x_s6v5K [Occ=Once] ->
                        case <=# [x_s6v5K 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6v5X [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6v5F eta_s6v5I] \r [a1_s6v5M]
                                        let {
                                          sat_s6v5U [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6v5F eta_s6v5I] \r [a2_s6v5N]
                                                  let {
                                                    sat_s6v5T [Occ=Once]
                                                      :: f_a6t9S a_a6t9T
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6v5I] \r [a3_s6v5O]
                                                            let {
                                                              sat_s6v5Q [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6v5I a3_s6v5O] \r [a4_s6v5P]
                                                                      eta_s6v5I a3_s6v5O;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6v5Q
                                                              of
                                                              { Unit# ww1_s6v5S [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6v5S];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadAlt2
                                                        ds_s6v5F
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6v5T;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6v5U
                                          of
                                          { Unit# ww1_s6v5W [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6v5W];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadAlt_lexeme sat_s6v5X
                                of
                                { Unit# ww1_s6v5Z [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6v5Z];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6v60;

Data.Semigroup.Internal.$fReadAlt_$creadsPrec
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Alt f a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v61]
        let {
          ds_s6v62 [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6v61] \u []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6v61; } in
        let {
          sat_s6v65 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle)
          [LclId] =
              [ds_s6v62] \r [n_s6v63]
                  let {
                    sat_s6v64 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle)
                    [LclId] =
                        [ds_s6v62 n_s6v63] \u []
                            ds_s6v62
                                n_s6v63 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6v64;
        } in  sat_s6v65;

Data.Semigroup.Internal.$fReadAlt_$creadListPrec
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Alt f a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v66]
        let {
          sat_s6v67 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_X6tla a_X6tlc)
          [LclId] =
              [$dRead_s6v66] \s []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6v66;
        } in  GHC.Read.list sat_s6v67;

Data.Semigroup.Internal.$fReadAlt_$creadList
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Semigroup.Internal.Alt f a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v68]
        let {
          sat_s6v6a [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Alt f_X6tlb a_X6tld]
          [LclId] =
              [$dRead_s6v68] \u []
                  let {
                    sat_s6v69 [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Alt f_X6tlb a_X6tld)
                    [LclId] =
                        [$dRead_s6v68] \s []
                            Data.Semigroup.Internal.$fReadAlt1 $dRead_s6v68;
                  } in 
                    GHC.Read.list
                        sat_s6v69
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6v6a;

Data.Semigroup.Internal.$fReadAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     GHC.Read.Read (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6v6b]
        let {
          sat_s6v6f [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb]
          [LclId] =
              [$dRead_s6v6b] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadListPrec $dRead_s6v6b; } in
        let {
          sat_s6v6e [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb)
          [LclId] =
              [$dRead_s6v6b] \u []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6v6b; } in
        let {
          sat_s6v6d [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb]
          [LclId] =
              [$dRead_s6v6b] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadList $dRead_s6v6b; } in
        let {
          sat_s6v6c [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb)
          [LclId] =
              [$dRead_s6v6b] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadsPrec $dRead_s6v6b;
        } in  GHC.Read.C:Read [sat_s6v6c sat_s6v6d sat_s6v6e sat_s6v6f];

Data.Semigroup.Internal.$fGeneric1Alt1
  :: forall k (f :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Semigroup.Internal.Alt f) a
     -> GHC.Generics.Rep1 (Data.Semigroup.Internal.Alt f) a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v6g] ds_s6v6g;

Data.Semigroup.Internal.$fGeneric1Alt2
  :: forall k (f :: k -> *) (a :: k).
     Data.Semigroup.Internal.Alt f a -> Data.Semigroup.Internal.Alt f a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6v6h] x_s6v6h;

Data.Semigroup.Internal.$fGeneric1Alt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *).
     GHC.Generics.Generic1 (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Alt2
                                            Data.Semigroup.Internal.$fGeneric1Alt1];

Data.Semigroup.Internal.$fGenericAlt1
  :: forall k (f :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Alt f a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Alt f a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v6i] ds_s6v6i;

Data.Semigroup.Internal.$fGenericAlt2
  :: forall k (f :: k -> *) (a :: k) x.
     Data.Semigroup.Internal.Alt f a -> Data.Semigroup.Internal.Alt f a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6v6j] x1_s6v6j;

Data.Semigroup.Internal.$fGenericAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAlt2
                                           Data.Semigroup.Internal.$fGenericAlt1];

Data.Semigroup.Internal.$fNumProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Semigroup.Internal.Product a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6v6k]
        let {
          sat_s6v6r [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.fromInteger $dNum_s6v6k; } in
        let {
          sat_s6v6q [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.signum $dNum_s6v6k; } in
        let {
          sat_s6v6p [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.abs $dNum_s6v6k; } in
        let {
          sat_s6v6o [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.negate $dNum_s6v6k; } in
        let {
          sat_s6v6n [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.* $dNum_s6v6k; } in
        let {
          sat_s6v6m [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.- $dNum_s6v6k; } in
        let {
          sat_s6v6l [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.+ $dNum_s6v6k;
        } in 
          GHC.Num.C:Num [sat_s6v6l
                         sat_s6v6m
                         sat_s6v6n
                         sat_s6v6o
                         sat_s6v6p
                         sat_s6v6q
                         sat_s6v6r];

Data.Semigroup.Internal.$fGeneric1Product1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Product a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v6s] ds_s6v6s;

Data.Semigroup.Internal.$fGeneric1Product2
  :: forall a.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6v6t] x_s6v6t;

Data.Semigroup.Internal.$fGeneric1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Product
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Product2
                                            Data.Semigroup.Internal.$fGeneric1Product1];

Data.Semigroup.Internal.$fGenericProduct1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Product a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Product a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v6u] ds_s6v6u;

Data.Semigroup.Internal.$fGenericProduct2
  :: forall a x.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6v6v] x1_s6v6v;

Data.Semigroup.Internal.$fGenericProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Generics.Generic (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericProduct2
                                           Data.Semigroup.Internal.$fGenericProduct1];

Data.Semigroup.Internal.$fBoundedProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6v6w]
        let {
          sat_s6v6y [Occ=Once] :: Data.Semigroup.Internal.Product a_a6t49
          [LclId] =
              [$dBounded_s6v6w] \u [] GHC.Enum.maxBound $dBounded_s6v6w; } in
        let {
          sat_s6v6x [Occ=Once] :: Data.Semigroup.Internal.Product a_a6t49
          [LclId] =
              [$dBounded_s6v6w] \u [] GHC.Enum.minBound $dBounded_s6v6w;
        } in  GHC.Enum.C:Bounded [sat_s6v6x sat_s6v6y];

Data.Semigroup.Internal.$fShowProduct2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product {"#;

Data.Semigroup.Internal.$fShowProduct1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getProduct = "#;

Data.Semigroup.Internal.$w$cshowsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int#
     -> Data.Semigroup.Internal.Product a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v6z ww_s6v6A w1_s6v6B]
        let {
          f_s6v6C [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6v6z w1_s6v6B] \u []
                  GHC.Show.showsPrec
                      w_s6v6z Data.Semigroup.Internal.$fShowAlt1 w1_s6v6B;
        } in 
          case >=# [ww_s6v6A 11#] of {
            __DEFAULT ->
                let {
                  sat_s6v6I [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6v6C] \r [x_s6v6E]
                          let {
                            sat_s6v6H [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6v6C x_s6v6E] \u []
                                    let {
                                      sat_s6v6G [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6v6C x_s6v6E] \u []
                                              let {
                                                sat_s6v6F [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6v6E] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6v6E;
                                              } in  f_s6v6C sat_s6v6F;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowProduct1 sat_s6v6G;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowProduct2 sat_s6v6H;
                } in  sat_s6v6I;
            1# ->
                let {
                  sat_s6v6P [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6v6C] \r [x_s6v6J]
                          let {
                            sat_s6v6O [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6v6C x_s6v6J] \u []
                                    let {
                                      sat_s6v6N [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6v6C x_s6v6J] \u []
                                              let {
                                                sat_s6v6M [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6v6C x_s6v6J] \u []
                                                        let {
                                                          sat_s6v6L [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6v6J] \u []
                                                                  let {
                                                                    sat_s6v6K [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6v6J];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6v6K;
                                                        } in  f_s6v6C sat_s6v6L;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowProduct1
                                                    sat_s6v6M;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowProduct2 sat_s6v6N;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6v6O];
                } in  sat_s6v6P;
          };

Data.Semigroup.Internal.$fShowProduct_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int
     -> Data.Semigroup.Internal.Product a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v6Q w1_s6v6R w2_s6v6S]
        case w1_s6v6R of {
          GHC.Types.I# ww1_s6v6U [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec4 w_s6v6Q ww1_s6v6U w2_s6v6S;
        };

Data.Semigroup.Internal.$fShowProduct_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Product a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v6V x_s6v6W]
        let {
          sat_s6v6Y [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6v6V x_s6v6W] \u []
                  let {
                    sat_s6v6X [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6v6V x_s6v6W] \u []
                            GHC.Show.showsPrec
                                $dShow_s6v6V
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6v6W
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowProduct1 sat_s6v6X;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowProduct2 sat_s6v6Y;

Data.Semigroup.Internal.$fShowProduct_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Product a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v6Z ls_s6v70 s_s6v71]
        let {
          sat_s6v73 [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t3E -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v6Z] \r [w_s6v72]
                  Data.Semigroup.Internal.$w$cshowsPrec4 $dShow_s6v6Z 0# w_s6v72;
        } in  GHC.Show.showList__ sat_s6v73 ls_s6v70 s_s6v71;

Data.Semigroup.Internal.$fShowProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6v74]
        let {
          sat_s6v77 [Occ=Once]
            :: [Data.Semigroup.Internal.Product a_a6t3E] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v74] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshowList
                      $dShow_s6v74 eta_B2 eta_B1; } in
        let {
          sat_s6v76 [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t3E -> GHC.Base.String
          [LclId] =
              [$dShow_s6v74] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshow
                      $dShow_s6v74 eta_B1; } in
        let {
          sat_s6v75 [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Product a_a6t3E -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v74] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshowsPrec
                      $dShow_s6v74 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6v75 sat_s6v76 sat_s6v77];

Data.Semigroup.Internal.$fReadProduct5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product"#;

Data.Semigroup.Internal.$fReadProduct4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadProduct5;

Data.Semigroup.Internal.$fReadProduct_lexeme
  :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadProduct4];

Data.Semigroup.Internal.$fReadProduct3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getProduct"#;

Data.Semigroup.Internal.$fReadProduct2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadProduct3;

Data.Semigroup.Internal.$fReadProduct1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Product a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v78]
        let {
          lvl12_s6v79 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6t2P
          [LclId] =
              [$dRead_s6v78] \u []
                  GHC.Read.readPrec
                      $dRead_s6v78 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6v7a [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6t2P
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6v79] \r [ds1_s6v7b] lvl12_s6v79; } in
        let {
          sat_s6v7v [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_a6t2P)
          [LclId] =
              [ds_s6v7a] \r [c_s6v7c eta_s6v7d]
                  case c_s6v7c of {
                    GHC.Types.I# x_s6v7f [Occ=Once] ->
                        case <=# [x_s6v7f 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6v7s [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6v7a eta_s6v7d] \r [a1_s6v7h]
                                        let {
                                          sat_s6v7p [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6v7a eta_s6v7d] \r [a2_s6v7i]
                                                  let {
                                                    sat_s6v7o [Occ=Once]
                                                      :: a_a6t2P
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6v7d] \r [a3_s6v7j]
                                                            let {
                                                              sat_s6v7l [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6v7d a3_s6v7j] \r [a4_s6v7k]
                                                                      eta_s6v7d a3_s6v7j;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6v7l
                                                              of
                                                              { Unit# ww1_s6v7n [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6v7n];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadProduct2
                                                        ds_s6v7a
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6v7o;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6v7p
                                          of
                                          { Unit# ww1_s6v7r [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6v7r];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadProduct_lexeme sat_s6v7s
                                of
                                { Unit# ww1_s6v7u [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6v7u];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6v7v;

Data.Semigroup.Internal.$fReadProduct_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Product a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v7w]
        let {
          ds_s6v7x [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Product a_X6tfh
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6v7w] \u []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6v7w; } in
        let {
          sat_s6v7A [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Product a_X6tfh)
          [LclId] =
              [ds_s6v7x] \r [n_s6v7y]
                  let {
                    sat_s6v7z [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Product a_X6tfh)
                    [LclId] =
                        [ds_s6v7x n_s6v7y] \u []
                            ds_s6v7x
                                n_s6v7y Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6v7z;
        } in  sat_s6v7A;

Data.Semigroup.Internal.$fReadProduct_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Product a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v7B]
        let {
          sat_s6v7C [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_X6tff)
          [LclId] =
              [$dRead_s6v7B] \s []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6v7B;
        } in  GHC.Read.list sat_s6v7C;

Data.Semigroup.Internal.$fReadProduct_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Semigroup.Internal.Product a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v7D]
        let {
          sat_s6v7F [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Product a_X6tfg]
          [LclId] =
              [$dRead_s6v7D] \u []
                  let {
                    sat_s6v7E [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Product a_X6tfg)
                    [LclId] =
                        [$dRead_s6v7D] \s []
                            Data.Semigroup.Internal.$fReadProduct1 $dRead_s6v7D;
                  } in 
                    GHC.Read.list
                        sat_s6v7E
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6v7F;

Data.Semigroup.Internal.$fReadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6v7G]
        let {
          sat_s6v7K [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Product a_X6tfe]
          [LclId] =
              [$dRead_s6v7G] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadListPrec
                      $dRead_s6v7G; } in
        let {
          sat_s6v7J [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_X6tfe)
          [LclId] =
              [$dRead_s6v7G] \u []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6v7G; } in
        let {
          sat_s6v7I [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Product a_X6tfe]
          [LclId] =
              [$dRead_s6v7G] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadList $dRead_s6v7G; } in
        let {
          sat_s6v7H [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Product a_X6tfe)
          [LclId] =
              [$dRead_s6v7G] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadsPrec $dRead_s6v7G;
        } in  GHC.Read.C:Read [sat_s6v7H sat_s6v7I sat_s6v7J sat_s6v7K];

Data.Semigroup.Internal.$fEqProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6v7L]
        let {
          sat_s6v7N [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t0s
               -> Data.Semigroup.Internal.Product a_a6t0s -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v7L] \u [] GHC.Classes./= $dEq_s6v7L; } in
        let {
          sat_s6v7M [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t0s
               -> Data.Semigroup.Internal.Product a_a6t0s -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v7L] \u [] GHC.Classes.== $dEq_s6v7L;
        } in  GHC.Classes.C:Eq [sat_s6v7M sat_s6v7N];

Data.Semigroup.Internal.$fOrdProduct_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6v7O]
        let {
          sat_s6v7P [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6t10
          [LclId] =
              [$dOrd_s6v7O] \u [] GHC.Classes.$p1Ord $dOrd_s6v7O;
        } in  Data.Semigroup.Internal.$fEqProduct sat_s6v7P;

Data.Semigroup.Internal.$fOrdProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Product a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6v7Q]
        let {
          sat_s6v7Y [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.min $dOrd_s6v7Q; } in
        let {
          sat_s6v7X [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.max $dOrd_s6v7Q; } in
        let {
          sat_s6v7W [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.>= $dOrd_s6v7Q; } in
        let {
          sat_s6v7V [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.> $dOrd_s6v7Q; } in
        let {
          sat_s6v7U [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.<= $dOrd_s6v7Q; } in
        let {
          sat_s6v7T [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.< $dOrd_s6v7Q; } in
        let {
          sat_s6v7S [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.compare $dOrd_s6v7Q; } in
        let {
          sat_s6v7R [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Product a_a6t10)
          [LclId] =
              [$dOrd_s6v7Q] \u []
                  Data.Semigroup.Internal.$fOrdProduct_$cp1Ord $dOrd_s6v7Q;
        } in 
          GHC.Classes.C:Ord [sat_s6v7R
                             sat_s6v7S
                             sat_s6v7T
                             sat_s6v7U
                             sat_s6v7V
                             sat_s6v7W
                             sat_s6v7X
                             sat_s6v7Y];

Data.Semigroup.Internal.$fNumSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6v7Z]
        let {
          sat_s6v86 [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.fromInteger $dNum_s6v7Z; } in
        let {
          sat_s6v85 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.signum $dNum_s6v7Z; } in
        let {
          sat_s6v84 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.abs $dNum_s6v7Z; } in
        let {
          sat_s6v83 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.negate $dNum_s6v7Z; } in
        let {
          sat_s6v82 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.* $dNum_s6v7Z; } in
        let {
          sat_s6v81 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.- $dNum_s6v7Z; } in
        let {
          sat_s6v80 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.+ $dNum_s6v7Z;
        } in 
          GHC.Num.C:Num [sat_s6v80
                         sat_s6v81
                         sat_s6v82
                         sat_s6v83
                         sat_s6v84
                         sat_s6v85
                         sat_s6v86];

Data.Semigroup.Internal.$fGeneric1Sum1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Sum a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v87] ds_s6v87;

Data.Semigroup.Internal.$fGeneric1Sum2
  :: forall a.
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6v88] x_s6v88;

Data.Semigroup.Internal.$fGeneric1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Sum
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Sum2
                                            Data.Semigroup.Internal.$fGeneric1Sum1];

Data.Semigroup.Internal.$fGenericSum1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Sum a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Sum a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v89] ds_s6v89;

Data.Semigroup.Internal.$fGenericSum2
  :: forall a x.
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6v8a] x1_s6v8a;

Data.Semigroup.Internal.$fGenericSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericSum2
                                           Data.Semigroup.Internal.$fGenericSum1];

Data.Semigroup.Internal.$fBoundedSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6v8b]
        let {
          sat_s6v8d [Occ=Once] :: Data.Semigroup.Internal.Sum a_a6sWQ
          [LclId] =
              [$dBounded_s6v8b] \u [] GHC.Enum.maxBound $dBounded_s6v8b; } in
        let {
          sat_s6v8c [Occ=Once] :: Data.Semigroup.Internal.Sum a_a6sWQ
          [LclId] =
              [$dBounded_s6v8b] \u [] GHC.Enum.minBound $dBounded_s6v8b;
        } in  GHC.Enum.C:Bounded [sat_s6v8c sat_s6v8d];

Data.Semigroup.Internal.$fShowSum2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum {"#;

Data.Semigroup.Internal.$fShowSum1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getSum = "#;

Data.Semigroup.Internal.$w$cshowsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Sum a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v8e ww_s6v8f w1_s6v8g]
        let {
          f_s6v8h [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6v8e w1_s6v8g] \u []
                  GHC.Show.showsPrec
                      w_s6v8e Data.Semigroup.Internal.$fShowAlt1 w1_s6v8g;
        } in 
          case >=# [ww_s6v8f 11#] of {
            __DEFAULT ->
                let {
                  sat_s6v8n [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6v8h] \r [x_s6v8j]
                          let {
                            sat_s6v8m [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6v8h x_s6v8j] \u []
                                    let {
                                      sat_s6v8l [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6v8h x_s6v8j] \u []
                                              let {
                                                sat_s6v8k [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6v8j] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6v8j;
                                              } in  f_s6v8h sat_s6v8k;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowSum1 sat_s6v8l;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowSum2 sat_s6v8m;
                } in  sat_s6v8n;
            1# ->
                let {
                  sat_s6v8u [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6v8h] \r [x_s6v8o]
                          let {
                            sat_s6v8t [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6v8h x_s6v8o] \u []
                                    let {
                                      sat_s6v8s [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6v8h x_s6v8o] \u []
                                              let {
                                                sat_s6v8r [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6v8h x_s6v8o] \u []
                                                        let {
                                                          sat_s6v8q [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6v8o] \u []
                                                                  let {
                                                                    sat_s6v8p [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6v8o];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6v8p;
                                                        } in  f_s6v8h sat_s6v8q;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowSum1 sat_s6v8r;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowSum2 sat_s6v8s;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6v8t];
                } in  sat_s6v8u;
          };

Data.Semigroup.Internal.$fShowSum_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Internal.Sum a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v8v w1_s6v8w w2_s6v8x]
        case w1_s6v8w of {
          GHC.Types.I# ww1_s6v8z [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec5 w_s6v8v ww1_s6v8z w2_s6v8x;
        };

Data.Semigroup.Internal.$fShowSum_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Sum a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v8A x_s6v8B]
        let {
          sat_s6v8D [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6v8A x_s6v8B] \u []
                  let {
                    sat_s6v8C [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6v8A x_s6v8B] \u []
                            GHC.Show.showsPrec
                                $dShow_s6v8A
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6v8B
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowSum1 sat_s6v8C;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowSum2 sat_s6v8D;

Data.Semigroup.Internal.$fShowSum_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Sum a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v8E ls_s6v8F s_s6v8G]
        let {
          sat_s6v8I [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v8E] \r [w_s6v8H]
                  Data.Semigroup.Internal.$w$cshowsPrec5 $dShow_s6v8E 0# w_s6v8H;
        } in  GHC.Show.showList__ sat_s6v8I ls_s6v8F s_s6v8G;

Data.Semigroup.Internal.$fShowSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6v8J]
        let {
          sat_s6v8M [Occ=Once]
            :: [Data.Semigroup.Internal.Sum a_a6sWl] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v8J] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshowList
                      $dShow_s6v8J eta_B2 eta_B1; } in
        let {
          sat_s6v8L [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Base.String
          [LclId] =
              [$dShow_s6v8J] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshow $dShow_s6v8J eta_B1; } in
        let {
          sat_s6v8K [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v8J] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshowsPrec
                      $dShow_s6v8J eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6v8K sat_s6v8L sat_s6v8M];

Data.Semigroup.Internal.$fReadSum5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum"#;

Data.Semigroup.Internal.$fReadSum4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadSum5;

Data.Semigroup.Internal.$fReadSum_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadSum4];

Data.Semigroup.Internal.$fReadSum3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getSum"#;

Data.Semigroup.Internal.$fReadSum2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadSum3;

Data.Semigroup.Internal.$fReadSum1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Sum a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v8N]
        let {
          lvl12_s6v8O [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6sVw
          [LclId] =
              [$dRead_s6v8N] \u []
                  GHC.Read.readPrec
                      $dRead_s6v8N Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6v8P [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6sVw
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6v8O] \r [ds1_s6v8Q] lvl12_s6v8O; } in
        let {
          sat_s6v9a [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_a6sVw)
          [LclId] =
              [ds_s6v8P] \r [c_s6v8R eta_s6v8S]
                  case c_s6v8R of {
                    GHC.Types.I# x_s6v8U [Occ=Once] ->
                        case <=# [x_s6v8U 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6v97 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6v8P eta_s6v8S] \r [a1_s6v8W]
                                        let {
                                          sat_s6v94 [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6v8P eta_s6v8S] \r [a2_s6v8X]
                                                  let {
                                                    sat_s6v93 [Occ=Once]
                                                      :: a_a6sVw
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6v8S] \r [a3_s6v8Y]
                                                            let {
                                                              sat_s6v90 [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6v8S a3_s6v8Y] \r [a4_s6v8Z]
                                                                      eta_s6v8S a3_s6v8Y;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6v90
                                                              of
                                                              { Unit# ww1_s6v92 [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6v92];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadSum2
                                                        ds_s6v8P
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6v93;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6v94
                                          of
                                          { Unit# ww1_s6v96 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6v96];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadSum_lexeme sat_s6v97
                                of
                                { Unit# ww1_s6v99 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6v99];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6v9a;

Data.Semigroup.Internal.$fReadSum_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Sum a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v9b]
        let {
          ds_s6v9c [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Sum a_X6t8R
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6v9b] \u []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6v9b; } in
        let {
          sat_s6v9f [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Sum a_X6t8R)
          [LclId] =
              [ds_s6v9c] \r [n_s6v9d]
                  let {
                    sat_s6v9e [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Sum a_X6t8R)
                    [LclId] =
                        [ds_s6v9c n_s6v9d] \u []
                            ds_s6v9c
                                n_s6v9d Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6v9e;
        } in  sat_s6v9f;

Data.Semigroup.Internal.$fReadSum_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Sum a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v9g]
        let {
          sat_s6v9h [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_X6t8P)
          [LclId] =
              [$dRead_s6v9g] \s []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6v9g;
        } in  GHC.Read.list sat_s6v9h;

Data.Semigroup.Internal.$fReadSum_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Sum a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v9i]
        let {
          sat_s6v9k [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Sum a_X6t8Q]
          [LclId] =
              [$dRead_s6v9i] \u []
                  let {
                    sat_s6v9j [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Sum a_X6t8Q)
                    [LclId] =
                        [$dRead_s6v9i] \s []
                            Data.Semigroup.Internal.$fReadSum1 $dRead_s6v9i;
                  } in 
                    GHC.Read.list
                        sat_s6v9j
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6v9k;

Data.Semigroup.Internal.$fReadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6v9l]
        let {
          sat_s6v9p [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Sum a_X6t8O]
          [LclId] =
              [$dRead_s6v9l] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadListPrec $dRead_s6v9l; } in
        let {
          sat_s6v9o [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_X6t8O)
          [LclId] =
              [$dRead_s6v9l] \u []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6v9l; } in
        let {
          sat_s6v9n [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Sum a_X6t8O]
          [LclId] =
              [$dRead_s6v9l] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadList $dRead_s6v9l; } in
        let {
          sat_s6v9m [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Sum a_X6t8O)
          [LclId] =
              [$dRead_s6v9l] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadsPrec $dRead_s6v9l;
        } in  GHC.Read.C:Read [sat_s6v9m sat_s6v9n sat_s6v9o sat_s6v9p];

Data.Semigroup.Internal.$fEqSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6v9q]
        let {
          sat_s6v9s [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sT9
               -> Data.Semigroup.Internal.Sum a_a6sT9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v9q] \u [] GHC.Classes./= $dEq_s6v9q; } in
        let {
          sat_s6v9r [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sT9
               -> Data.Semigroup.Internal.Sum a_a6sT9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v9q] \u [] GHC.Classes.== $dEq_s6v9q;
        } in  GHC.Classes.C:Eq [sat_s6v9r sat_s6v9s];

Data.Semigroup.Internal.$fOrdSum_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6v9t]
        let {
          sat_s6v9u [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6sTH
          [LclId] =
              [$dOrd_s6v9t] \u [] GHC.Classes.$p1Ord $dOrd_s6v9t;
        } in  Data.Semigroup.Internal.$fEqSum sat_s6v9u;

Data.Semigroup.Internal.$fOrdSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6v9v]
        let {
          sat_s6v9D [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.min $dOrd_s6v9v; } in
        let {
          sat_s6v9C [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.max $dOrd_s6v9v; } in
        let {
          sat_s6v9B [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.>= $dOrd_s6v9v; } in
        let {
          sat_s6v9A [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.> $dOrd_s6v9v; } in
        let {
          sat_s6v9z [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.<= $dOrd_s6v9v; } in
        let {
          sat_s6v9y [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.< $dOrd_s6v9v; } in
        let {
          sat_s6v9x [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.compare $dOrd_s6v9v; } in
        let {
          sat_s6v9w [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Sum a_a6sTH)
          [LclId] =
              [$dOrd_s6v9v] \u []
                  Data.Semigroup.Internal.$fOrdSum_$cp1Ord $dOrd_s6v9v;
        } in 
          GHC.Classes.C:Ord [sat_s6v9w
                             sat_s6v9x
                             sat_s6v9y
                             sat_s6v9z
                             sat_s6v9A
                             sat_s6v9B
                             sat_s6v9C
                             sat_s6v9D];

Data.Semigroup.Internal.$fGenericAny1
  :: forall x.
     GHC.Generics.Rep Data.Semigroup.Internal.Any x
     -> GHC.Generics.Rep Data.Semigroup.Internal.Any x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v9E] ds_s6v9E;

Data.Semigroup.Internal.$fGenericAny2
  :: forall x.
     Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6v9F] x1_s6v9F;

Data.Semigroup.Internal.$fGenericAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAny2
                                           Data.Semigroup.Internal.$fGenericAny1];

Data.Semigroup.Internal.$fBoundedAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Bounded Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Bounded! [GHC.Types.False GHC.Types.True];

Data.Semigroup.Internal.$fShowAny4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Any {"#;

Data.Semigroup.Internal.$fShowAny3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fShowAny4;

Data.Semigroup.Internal.$fShowAny2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAny = "#;

Data.Semigroup.Internal.$w$cshowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> Data.Semigroup.Internal.Any
     -> GHC.Base.String
     -> GHC.Base.String
[GblId, Arity=3, Str=<S,U><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s6v9G w_s6v9H w1_s6v9I]
        case >=# [ww_s6v9G 11#] of {
          __DEFAULT ->
              let {
                sat_s6v9O [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6v9H w1_s6v9I] \s []
                        let {
                          sat_s6v9N [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6v9H w1_s6v9I] \u []
                                  case w_s6v9H of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s6v9L [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6v9I] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6v9I;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6v9L;
                                    GHC.Types.True ->
                                        let {
                                          sat_s6v9M [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6v9I] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6v9I;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6v9M;
                                  };
                        } in 
                          GHC.CString.unpackAppendCString#
                              Data.Semigroup.Internal.$fShowAny2 sat_s6v9N;
              } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6v9O;
          1# ->
              let {
                sat_s6v9W [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6v9H w1_s6v9I] \u []
                        let {
                          sat_s6v9V [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6v9H w1_s6v9I] \s []
                                  let {
                                    sat_s6v9U [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w_s6v9H w1_s6v9I] \u []
                                            case w_s6v9H of {
                                              GHC.Types.False ->
                                                  let {
                                                    sat_s6v9R [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6v9I] \s []
                                                            let {
                                                              sat_s6v9Q [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6v9I];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6v9Q;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6v9R;
                                              GHC.Types.True ->
                                                  let {
                                                    sat_s6v9T [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6v9I] \s []
                                                            let {
                                                              sat_s6v9S [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6v9I];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6v9S;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6v9T;
                                            };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        Data.Semigroup.Internal.$fShowAny2 sat_s6v9U;
                        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6v9V;
              } in  : [GHC.Show.$fShow(,)4 sat_s6v9W];
        };

Data.Semigroup.Internal.$fShowAny_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> Data.Semigroup.Internal.Any -> GHC.Show.ShowS
[GblId, Arity=3, Str=<S(S),1*U(U)><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [w_s6v9X w1_s6v9Y w2_s6v9Z]
        case w_s6v9X of {
          GHC.Types.I# ww1_s6va1 [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec2 ww1_s6va1 w1_s6v9Y w2_s6v9Z;
        };

Data.Semigroup.Internal.$fShowAll6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++
            GHC.Show.$fShowBool4 Data.Semigroup.Internal.$fReadAll4;

Data.Semigroup.Internal.$fShowAll5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++
            GHC.Show.$fShowBool2 Data.Semigroup.Internal.$fReadAll4;

Data.Semigroup.Internal.$fShowAny_$cshow
  :: Data.Semigroup.Internal.Any -> GHC.Base.String
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s6va2]
        let {
          sat_s6va5 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [x_s6va2] \s []
                  let {
                    sat_s6va4 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [x_s6va2] \u []
                            case x_s6va2 of {
                              GHC.Types.False -> Data.Semigroup.Internal.$fShowAll6;
                              GHC.Types.True -> Data.Semigroup.Internal.$fShowAll5;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAny2 sat_s6va4;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6va5;

Data.Semigroup.Internal.$fShowAny1
  :: Data.Semigroup.Internal.Any -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,1*U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6va6 x_s6va7]
        let {
          sat_s6vac [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [ds_s6va6 x_s6va7] \s []
                  let {
                    sat_s6vab [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ds_s6va6 x_s6va7] \u []
                            case ds_s6va6 of {
                              GHC.Types.False ->
                                  let {
                                    sat_s6va9 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6va7] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6va7;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6va9;
                              GHC.Types.True ->
                                  let {
                                    sat_s6vaa [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6va7] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6va7;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6vaa;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAny2 sat_s6vab;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6vac;

Data.Semigroup.Internal.$fShowAny_$cshowList
  :: [Data.Semigroup.Internal.Any] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s6vad s_s6vae]
        GHC.Show.showList__
            Data.Semigroup.Internal.$fShowAny1 ls_s6vad s_s6vae;

Data.Semigroup.Internal.$fShowAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Semigroup.Internal.$fShowAny_$cshowsPrec
                                    Data.Semigroup.Internal.$fShowAny_$cshow
                                    Data.Semigroup.Internal.$fShowAny_$cshowList];

Data.Semigroup.Internal.$fReadAny6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Any"#;

Data.Semigroup.Internal.$fReadAny5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAny6;

Data.Semigroup.Internal.$fReadAny_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAny5];

Data.Semigroup.Internal.$fReadAny4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAny"#;

Data.Semigroup.Internal.$fReadAny3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAny4;

Data.Semigroup.Internal.$fReadAll7
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
    [] \r [ds1_s6vaf eta_s6vag]
        GHC.Read.list3
            GHC.Read.$fReadBool2
            Text.ParserCombinators.ReadPrec.minPrec
            eta_s6vag;

Data.Semigroup.Internal.$w$creadPrec1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ww_s6vah w_s6vai]
        case <=# [ww_s6vah 11#] of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
          1# ->
              let {
                sat_s6vav [Occ=Once]
                  :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                [LclId] =
                    [w_s6vai] \r [a1_s6vak]
                        let {
                          sat_s6vas [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                          [LclId] =
                              [w_s6vai] \r [a2_s6val]
                                  let {
                                    sat_s6var [Occ=Once]
                                      :: GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b_s6uMw
                                    [LclId] =
                                        [w_s6vai] \r [a3_s6vam]
                                            let {
                                              sat_s6vao [Occ=Once]
                                                :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                                              [LclId] =
                                                  [w_s6vai a3_s6vam] \r [a4_s6van] w_s6vai a3_s6vam;
                                            } in 
                                              case
                                                  Text.Read.Lex.$wexpect
                                                      Data.Semigroup.Internal.$fReadAll3 sat_s6vao
                                              of
                                              { Unit# ww2_s6vaq [Occ=Once] ->
                                                    Text.ParserCombinators.ReadP.Look [ww2_s6vaq];
                                              };
                                  } in 
                                    GHC.Read.readField
                                        Data.Semigroup.Internal.$fReadAny3
                                        Data.Semigroup.Internal.$fReadAll7
                                        Data.Semigroup.Internal.$fReadAll6
                                        sat_s6var;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6vas
                          of
                          { Unit# ww2_s6vau [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_s6vau];
                          };
              } in 
                case
                    Text.Read.Lex.$wexpect
                        Data.Semigroup.Internal.$fReadAny_lexeme sat_s6vav
                of
                { Unit# ww2_s6vax [Occ=Once] ->
                      Text.ParserCombinators.ReadP.Look [ww2_s6vax];
                };
        };

Data.Semigroup.Internal.$fReadAny2 [InlPrag=NOUSERINLINE[0]]
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_s6vay w1_s6vaz]
        case w_s6vay of {
          GHC.Types.I# ww1_s6vaB [Occ=Once] ->
              Data.Semigroup.Internal.$w$creadPrec1 ww1_s6vaB w1_s6vaz;
        };

Data.Semigroup.Internal.$fReadAny1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Semigroup.Internal.$fReadAny2 eta_B2 eta_B1;

Data.Semigroup.Internal.$fReadAny_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Semigroup.Internal.Any
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [n_s6vaC]
        let {
          sat_s6vaD [Occ=Once]
            :: Text.ParserCombinators.ReadP.P Data.Semigroup.Internal.Any
          [LclId] =
              [n_s6vaC] \u []
                  GHC.Read.list3
                      Data.Semigroup.Internal.$fReadAny2
                      n_s6vaC
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6vaD;

Data.Semigroup.Internal.$fReadAny_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Any]
[GblId] =
    [] \u [] GHC.Read.list Data.Semigroup.Internal.$fReadAny1;

Data.Semigroup.Internal.$fReadAny7
  :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Internal.Any]
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fReadAny_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Semigroup.Internal.$fReadAny_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Any]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Data.Semigroup.Internal.$fReadAny7 eta_B1;

Data.Semigroup.Internal.$fReadAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Semigroup.Internal.$fReadAny_$creadsPrec
                                    Data.Semigroup.Internal.$fReadAny_$creadList
                                    Data.Semigroup.Internal.$fReadAny1
                                    Data.Semigroup.Internal.$fReadAny_$creadListPrec];

Data.Semigroup.Internal.$fEqAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Classes.$fEqBool_$c==
                                     GHC.Classes.$fEqBool_$c/=];

Data.Semigroup.Internal.$fOrdAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Semigroup.Internal.$fEqAny
                                      GHC.Classes.$fOrdBool_$ccompare
                                      GHC.Classes.$fOrdBool_$c<
                                      GHC.Classes.$fOrdBool_$c<=
                                      GHC.Classes.$fOrdBool_$c>
                                      GHC.Classes.$fOrdBool_$c>=
                                      GHC.Classes.$fOrdBool_$cmax
                                      GHC.Classes.$fOrdBool_$cmin];

Data.Semigroup.Internal.$fGenericAll1
  :: forall x.
     GHC.Generics.Rep Data.Semigroup.Internal.All x
     -> GHC.Generics.Rep Data.Semigroup.Internal.All x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vaE] ds_s6vaE;

Data.Semigroup.Internal.$fGenericAll2
  :: forall x.
     Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6vaF] x1_s6vaF;

Data.Semigroup.Internal.$fGenericAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAll2
                                           Data.Semigroup.Internal.$fGenericAll1];

Data.Semigroup.Internal.$fBoundedAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Bounded Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Bounded! [GHC.Types.False GHC.Types.True];

Data.Semigroup.Internal.$fShowAll4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "All {"#;

Data.Semigroup.Internal.$fShowAll3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fShowAll4;

Data.Semigroup.Internal.$fShowAll2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAll = "#;

Data.Semigroup.Internal.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> Data.Semigroup.Internal.All
     -> GHC.Base.String
     -> GHC.Base.String
[GblId, Arity=3, Str=<S,U><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s6vaG w_s6vaH w1_s6vaI]
        case >=# [ww_s6vaG 11#] of {
          __DEFAULT ->
              let {
                sat_s6vaO [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6vaH w1_s6vaI] \s []
                        let {
                          sat_s6vaN [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6vaH w1_s6vaI] \u []
                                  case w_s6vaH of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s6vaL [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6vaI] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6vaI;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6vaL;
                                    GHC.Types.True ->
                                        let {
                                          sat_s6vaM [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6vaI] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6vaI;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6vaM;
                                  };
                        } in 
                          GHC.CString.unpackAppendCString#
                              Data.Semigroup.Internal.$fShowAll2 sat_s6vaN;
              } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6vaO;
          1# ->
              let {
                sat_s6vaW [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6vaH w1_s6vaI] \u []
                        let {
                          sat_s6vaV [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6vaH w1_s6vaI] \s []
                                  let {
                                    sat_s6vaU [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w_s6vaH w1_s6vaI] \u []
                                            case w_s6vaH of {
                                              GHC.Types.False ->
                                                  let {
                                                    sat_s6vaR [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6vaI] \s []
                                                            let {
                                                              sat_s6vaQ [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6vaI];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6vaQ;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6vaR;
                                              GHC.Types.True ->
                                                  let {
                                                    sat_s6vaT [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6vaI] \s []
                                                            let {
                                                              sat_s6vaS [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6vaI];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6vaS;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6vaT;
                                            };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        Data.Semigroup.Internal.$fShowAll2 sat_s6vaU;
                        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6vaV;
              } in  : [GHC.Show.$fShow(,)4 sat_s6vaW];
        };

Data.Semigroup.Internal.$fShowAll_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> Data.Semigroup.Internal.All -> GHC.Show.ShowS
[GblId, Arity=3, Str=<S(S),1*U(U)><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [w_s6vaX w1_s6vaY w2_s6vaZ]
        case w_s6vaX of {
          GHC.Types.I# ww1_s6vb1 [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec ww1_s6vb1 w1_s6vaY w2_s6vaZ;
        };

Data.Semigroup.Internal.$fShowAll_$cshow
  :: Data.Semigroup.Internal.All -> GHC.Base.String
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s6vb2]
        let {
          sat_s6vb5 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [x_s6vb2] \s []
                  let {
                    sat_s6vb4 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [x_s6vb2] \u []
                            case x_s6vb2 of {
                              GHC.Types.False -> Data.Semigroup.Internal.$fShowAll6;
                              GHC.Types.True -> Data.Semigroup.Internal.$fShowAll5;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAll2 sat_s6vb4;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6vb5;

Data.Semigroup.Internal.$fShowAll1
  :: Data.Semigroup.Internal.All -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,1*U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vb6 x_s6vb7]
        let {
          sat_s6vbc [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [ds_s6vb6 x_s6vb7] \s []
                  let {
                    sat_s6vbb [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ds_s6vb6 x_s6vb7] \u []
                            case ds_s6vb6 of {
                              GHC.Types.False ->
                                  let {
                                    sat_s6vb9 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6vb7] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6vb7;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6vb9;
                              GHC.Types.True ->
                                  let {
                                    sat_s6vba [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6vb7] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6vb7;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6vba;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAll2 sat_s6vbb;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6vbc;

Data.Semigroup.Internal.$fShowAll_$cshowList
  :: [Data.Semigroup.Internal.All] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s6vbd s_s6vbe]
        GHC.Show.showList__
            Data.Semigroup.Internal.$fShowAll1 ls_s6vbd s_s6vbe;

Data.Semigroup.Internal.$fShowAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Semigroup.Internal.$fShowAll_$cshowsPrec
                                    Data.Semigroup.Internal.$fShowAll_$cshow
                                    Data.Semigroup.Internal.$fShowAll_$cshowList];

Data.Semigroup.Internal.$fReadAll13 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "All"#;

Data.Semigroup.Internal.$fReadAll12 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll13;

Data.Semigroup.Internal.$fReadAll_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAll12];

Data.Semigroup.Internal.$fReadAll9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAll"#;

Data.Semigroup.Internal.$fReadAll8 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll9;

Data.Semigroup.Internal.$w$creadPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ww_s6vbf w_s6vbg]
        case <=# [ww_s6vbf 11#] of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
          1# ->
              let {
                sat_s6vbt [Occ=Once]
                  :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                [LclId] =
                    [w_s6vbg] \r [a1_s6vbi]
                        let {
                          sat_s6vbq [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                          [LclId] =
                              [w_s6vbg] \r [a2_s6vbj]
                                  let {
                                    sat_s6vbp [Occ=Once]
                                      :: GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b_s6uMP
                                    [LclId] =
                                        [w_s6vbg] \r [a3_s6vbk]
                                            let {
                                              sat_s6vbm [Occ=Once]
                                                :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                                              [LclId] =
                                                  [w_s6vbg a3_s6vbk] \r [a4_s6vbl] w_s6vbg a3_s6vbk;
                                            } in 
                                              case
                                                  Text.Read.Lex.$wexpect
                                                      Data.Semigroup.Internal.$fReadAll3 sat_s6vbm
                                              of
                                              { Unit# ww2_s6vbo [Occ=Once] ->
                                                    Text.ParserCombinators.ReadP.Look [ww2_s6vbo];
                                              };
                                  } in 
                                    GHC.Read.readField
                                        Data.Semigroup.Internal.$fReadAll8
                                        Data.Semigroup.Internal.$fReadAll7
                                        Data.Semigroup.Internal.$fReadAll6
                                        sat_s6vbp;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6vbq
                          of
                          { Unit# ww2_s6vbs [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_s6vbs];
                          };
              } in 
                case
                    Text.Read.Lex.$wexpect
                        Data.Semigroup.Internal.$fReadAll_lexeme1 sat_s6vbt
                of
                { Unit# ww2_s6vbv [Occ=Once] ->
                      Text.ParserCombinators.ReadP.Look [ww2_s6vbv];
                };
        };

Data.Semigroup.Internal.$fReadAll2 [InlPrag=NOUSERINLINE[0]]
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_s6vbw w1_s6vbx]
        case w_s6vbw of {
          GHC.Types.I# ww1_s6vbz [Occ=Once] ->
              Data.Semigroup.Internal.$w$creadPrec ww1_s6vbz w1_s6vbx;
        };

Data.Semigroup.Internal.$fReadAll1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Semigroup.Internal.$fReadAll2 eta_B2 eta_B1;

Data.Semigroup.Internal.$fReadAll_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Semigroup.Internal.All
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [n_s6vbA]
        let {
          sat_s6vbB [Occ=Once]
            :: Text.ParserCombinators.ReadP.P Data.Semigroup.Internal.All
          [LclId] =
              [n_s6vbA] \u []
                  GHC.Read.list3
                      Data.Semigroup.Internal.$fReadAll2
                      n_s6vbA
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6vbB;

Data.Semigroup.Internal.$fReadAll_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.All]
[GblId] =
    [] \u [] GHC.Read.list Data.Semigroup.Internal.$fReadAll1;

Data.Semigroup.Internal.$fReadAll14
  :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Internal.All]
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fReadAll_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Semigroup.Internal.$fReadAll_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.All]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Data.Semigroup.Internal.$fReadAll14 eta_B1;

Data.Semigroup.Internal.$fReadAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Semigroup.Internal.$fReadAll_$creadsPrec
                                    Data.Semigroup.Internal.$fReadAll_$creadList
                                    Data.Semigroup.Internal.$fReadAll1
                                    Data.Semigroup.Internal.$fReadAll_$creadListPrec];

Data.Semigroup.Internal.$fEqAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Classes.$fEqBool_$c==
                                     GHC.Classes.$fEqBool_$c/=];

Data.Semigroup.Internal.$fOrdAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Semigroup.Internal.$fEqAll
                                      GHC.Classes.$fOrdBool_$ccompare
                                      GHC.Classes.$fOrdBool_$c<
                                      GHC.Classes.$fOrdBool_$c<=
                                      GHC.Classes.$fOrdBool_$c>
                                      GHC.Classes.$fOrdBool_$c>=
                                      GHC.Classes.$fOrdBool_$cmax
                                      GHC.Classes.$fOrdBool_$cmin];

Data.Semigroup.Internal.$fGenericEndo1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Endo a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Endo a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vbC] ds_s6vbC;

Data.Semigroup.Internal.$fGenericEndo2
  :: forall a x.
     Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6vbD] x1_s6vbD;

Data.Semigroup.Internal.$fGenericEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericEndo2
                                           Data.Semigroup.Internal.$fGenericEndo1];

Data.Semigroup.Internal.$fGeneric1Dual1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Dual a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vbE] ds_s6vbE;

Data.Semigroup.Internal.$fGeneric1Dual2
  :: forall a.
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6vbF] x_s6vbF;

Data.Semigroup.Internal.$fGeneric1Dual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Dual
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Dual2
                                            Data.Semigroup.Internal.$fGeneric1Dual1];

Data.Semigroup.Internal.$fGenericDual1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Dual a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Dual a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vbG] ds_s6vbG;

Data.Semigroup.Internal.$fGenericDual2
  :: forall a x.
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6vbH] x1_s6vbH;

Data.Semigroup.Internal.$fGenericDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericDual2
                                           Data.Semigroup.Internal.$fGenericDual1];

Data.Semigroup.Internal.$fBoundedDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6vbI]
        let {
          sat_s6vbK [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6sGr
          [LclId] =
              [$dBounded_s6vbI] \u [] GHC.Enum.maxBound $dBounded_s6vbI; } in
        let {
          sat_s6vbJ [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6sGr
          [LclId] =
              [$dBounded_s6vbI] \u [] GHC.Enum.minBound $dBounded_s6vbI;
        } in  GHC.Enum.C:Bounded [sat_s6vbJ sat_s6vbK];

Data.Semigroup.Internal.$fShowDual2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Dual {"#;

Data.Semigroup.Internal.$fShowDual1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getDual = "#;

Data.Semigroup.Internal.$w$cshowsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Dual a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6vbL ww_s6vbM w1_s6vbN]
        let {
          f_s6vbO [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6vbL w1_s6vbN] \u []
                  GHC.Show.showsPrec
                      w_s6vbL Data.Semigroup.Internal.$fShowAlt1 w1_s6vbN;
        } in 
          case >=# [ww_s6vbM 11#] of {
            __DEFAULT ->
                let {
                  sat_s6vbU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6vbO] \r [x_s6vbQ]
                          let {
                            sat_s6vbT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6vbO x_s6vbQ] \u []
                                    let {
                                      sat_s6vbS [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6vbO x_s6vbQ] \u []
                                              let {
                                                sat_s6vbR [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6vbQ] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6vbQ;
                                              } in  f_s6vbO sat_s6vbR;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowDual1 sat_s6vbS;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowDual2 sat_s6vbT;
                } in  sat_s6vbU;
            1# ->
                let {
                  sat_s6vc1 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6vbO] \r [x_s6vbV]
                          let {
                            sat_s6vc0 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6vbO x_s6vbV] \u []
                                    let {
                                      sat_s6vbZ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6vbO x_s6vbV] \u []
                                              let {
                                                sat_s6vbY [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6vbO x_s6vbV] \u []
                                                        let {
                                                          sat_s6vbX [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6vbV] \u []
                                                                  let {
                                                                    sat_s6vbW [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6vbV];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6vbW;
                                                        } in  f_s6vbO sat_s6vbX;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowDual1 sat_s6vbY;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowDual2 sat_s6vbZ;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6vc0];
                } in  sat_s6vc1;
          };

Data.Semigroup.Internal.$fShowDual_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Internal.Dual a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6vc2 w1_s6vc3 w2_s6vc4]
        case w1_s6vc3 of {
          GHC.Types.I# ww1_s6vc6 [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec3 w_s6vc2 ww1_s6vc6 w2_s6vc4;
        };

Data.Semigroup.Internal.$fShowDual_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Dual a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6vc7 x_s6vc8]
        let {
          sat_s6vca [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6vc7 x_s6vc8] \u []
                  let {
                    sat_s6vc9 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6vc7 x_s6vc8] \u []
                            GHC.Show.showsPrec
                                $dShow_s6vc7
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6vc8
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowDual1 sat_s6vc9;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowDual2 sat_s6vca;

Data.Semigroup.Internal.$fShowDual_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Dual a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6vcb ls_s6vcc s_s6vcd]
        let {
          sat_s6vcf [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6vcb] \r [w_s6vce]
                  Data.Semigroup.Internal.$w$cshowsPrec3 $dShow_s6vcb 0# w_s6vce;
        } in  GHC.Show.showList__ sat_s6vcf ls_s6vcc s_s6vcd;

Data.Semigroup.Internal.$fShowDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6vcg]
        let {
          sat_s6vcj [Occ=Once]
            :: [Data.Semigroup.Internal.Dual a_a6sFL] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6vcg] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshowList
                      $dShow_s6vcg eta_B2 eta_B1; } in
        let {
          sat_s6vci [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Base.String
          [LclId] =
              [$dShow_s6vcg] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshow $dShow_s6vcg eta_B1; } in
        let {
          sat_s6vch [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6vcg] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshowsPrec
                      $dShow_s6vcg eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6vch sat_s6vci sat_s6vcj];

Data.Semigroup.Internal.$fReadDual5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Dual"#;

Data.Semigroup.Internal.$fReadDual4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadDual5;

Data.Semigroup.Internal.$fReadDual_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadDual4];

Data.Semigroup.Internal.$fReadDual3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getDual"#;

Data.Semigroup.Internal.$fReadDual2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadDual3;

Data.Semigroup.Internal.$fReadDual1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Dual a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6vck]
        let {
          lvl12_s6vcl [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6sEx
          [LclId] =
              [$dRead_s6vck] \u []
                  GHC.Read.readPrec
                      $dRead_s6vck Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6vcm [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6sEx
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6vcl] \r [ds1_s6vcn] lvl12_s6vcl; } in
        let {
          sat_s6vcH [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_a6sEx)
          [LclId] =
              [ds_s6vcm] \r [c_s6vco eta_s6vcp]
                  case c_s6vco of {
                    GHC.Types.I# x_s6vcr [Occ=Once] ->
                        case <=# [x_s6vcr 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6vcE [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6vcm eta_s6vcp] \r [a1_s6vct]
                                        let {
                                          sat_s6vcB [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6vcm eta_s6vcp] \r [a2_s6vcu]
                                                  let {
                                                    sat_s6vcA [Occ=Once]
                                                      :: a_a6sEx
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6vcp] \r [a3_s6vcv]
                                                            let {
                                                              sat_s6vcx [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6vcp a3_s6vcv] \r [a4_s6vcw]
                                                                      eta_s6vcp a3_s6vcv;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6vcx
                                                              of
                                                              { Unit# ww1_s6vcz [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6vcz];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadDual2
                                                        ds_s6vcm
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6vcA;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6vcB
                                          of
                                          { Unit# ww1_s6vcD [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6vcD];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadDual_lexeme sat_s6vcE
                                of
                                { Unit# ww1_s6vcG [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6vcG];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6vcH;

Data.Semigroup.Internal.$fReadDual_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Dual a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6vcI]
        let {
          ds_s6vcJ [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Dual a_X6sTW
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6vcI] \u []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6vcI; } in
        let {
          sat_s6vcM [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Dual a_X6sTW)
          [LclId] =
              [ds_s6vcJ] \r [n_s6vcK]
                  let {
                    sat_s6vcL [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Dual a_X6sTW)
                    [LclId] =
                        [ds_s6vcJ n_s6vcK] \u []
                            ds_s6vcJ
                                n_s6vcK Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6vcL;
        } in  sat_s6vcM;

Data.Semigroup.Internal.$fReadDual_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Dual a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6vcN]
        let {
          sat_s6vcO [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_X6sTU)
          [LclId] =
              [$dRead_s6vcN] \s []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6vcN;
        } in  GHC.Read.list sat_s6vcO;

Data.Semigroup.Internal.$fReadDual_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Dual a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6vcP]
        let {
          sat_s6vcR [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Dual a_X6sTV]
          [LclId] =
              [$dRead_s6vcP] \u []
                  let {
                    sat_s6vcQ [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Dual a_X6sTV)
                    [LclId] =
                        [$dRead_s6vcP] \s []
                            Data.Semigroup.Internal.$fReadDual1 $dRead_s6vcP;
                  } in 
                    GHC.Read.list
                        sat_s6vcQ
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6vcR;

Data.Semigroup.Internal.$fReadDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6vcS]
        let {
          sat_s6vcW [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Dual a_X6sTT]
          [LclId] =
              [$dRead_s6vcS] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadListPrec
                      $dRead_s6vcS; } in
        let {
          sat_s6vcV [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_X6sTT)
          [LclId] =
              [$dRead_s6vcS] \u []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6vcS; } in
        let {
          sat_s6vcU [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Dual a_X6sTT]
          [LclId] =
              [$dRead_s6vcS] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadList $dRead_s6vcS; } in
        let {
          sat_s6vcT [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Dual a_X6sTT)
          [LclId] =
              [$dRead_s6vcS] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadsPrec $dRead_s6vcS;
        } in  GHC.Read.C:Read [sat_s6vcT sat_s6vcU sat_s6vcV sat_s6vcW];

Data.Semigroup.Internal.$fEqDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6vcX]
        let {
          sat_s6vcZ [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCa
               -> Data.Semigroup.Internal.Dual a_a6sCa -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6vcX] \u [] GHC.Classes./= $dEq_s6vcX; } in
        let {
          sat_s6vcY [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCa
               -> Data.Semigroup.Internal.Dual a_a6sCa -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6vcX] \u [] GHC.Classes.== $dEq_s6vcX;
        } in  GHC.Classes.C:Eq [sat_s6vcY sat_s6vcZ];

Data.Semigroup.Internal.$fOrdDual_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6vd0]
        let {
          sat_s6vd1 [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6sCI
          [LclId] =
              [$dOrd_s6vd0] \u [] GHC.Classes.$p1Ord $dOrd_s6vd0;
        } in  Data.Semigroup.Internal.$fEqDual sat_s6vd1;

Data.Semigroup.Internal.$fOrdDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6vd2]
        let {
          sat_s6vda [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.min $dOrd_s6vd2; } in
        let {
          sat_s6vd9 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.max $dOrd_s6vd2; } in
        let {
          sat_s6vd8 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.>= $dOrd_s6vd2; } in
        let {
          sat_s6vd7 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.> $dOrd_s6vd2; } in
        let {
          sat_s6vd6 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.<= $dOrd_s6vd2; } in
        let {
          sat_s6vd5 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.< $dOrd_s6vd2; } in
        let {
          sat_s6vd4 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.compare $dOrd_s6vd2; } in
        let {
          sat_s6vd3 [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Dual a_a6sCI)
          [LclId] =
              [$dOrd_s6vd2] \u []
                  Data.Semigroup.Internal.$fOrdDual_$cp1Ord $dOrd_s6vd2;
        } in 
          GHC.Classes.C:Ord [sat_s6vd3
                             sat_s6vd4
                             sat_s6vd5
                             sat_s6vd6
                             sat_s6vd7
                             sat_s6vd8
                             sat_s6vd9
                             sat_s6vda];

Data.Semigroup.Internal.getDual
  :: forall a. Data.Semigroup.Internal.Dual a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Semigroup.Internal.$fMonadDual_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> (a -> Data.Semigroup.Internal.Dual b)
     -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6vdb k_s6vdc] k_s6vdc m_s6vdb;

Data.Semigroup.Internal.$fMonadDual_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeDual_$c*> eta_B2 eta_B1;

lvl_r6v16
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6vdd] GHC.Err.errorWithoutStackTrace eta_s6vdd;

Data.Semigroup.Internal.$fMonadDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeDual
                                     Data.Semigroup.Internal.$fMonadDual_$c>>=
                                     Data.Semigroup.Internal.$fMonadDual_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl_r6v16];

Data.Semigroup.Internal.appEndo1
  :: forall a.
     Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vde] ds_s6vde;

Data.Semigroup.Internal.appEndo
  :: forall a. Data.Semigroup.Internal.Endo a -> a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.appEndo1 eta_B1;

Data.Semigroup.Internal.getAll1
  :: Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vdf] ds_s6vdf;

Data.Semigroup.Internal.getAll
  :: Data.Semigroup.Internal.All -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.getAll1 eta_B1;

Data.Semigroup.Internal.getAny1
  :: Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vdg] ds_s6vdg;

Data.Semigroup.Internal.getAny
  :: Data.Semigroup.Internal.Any -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.getAny1 eta_B1;

Data.Semigroup.Internal.getSum
  :: forall a. Data.Semigroup.Internal.Sum a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Semigroup.Internal.$fMonadSum_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> (a -> Data.Semigroup.Internal.Sum b)
     -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6vdh k_s6vdi] k_s6vdi m_s6vdh;

Data.Semigroup.Internal.$fMonadSum_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeSum_$c*> eta_B2 eta_B1;

lvl1_r6v17
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6vdj] GHC.Err.errorWithoutStackTrace eta_s6vdj;

Data.Semigroup.Internal.$fMonadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeSum
                                     Data.Semigroup.Internal.$fMonadSum_$c>>=
                                     Data.Semigroup.Internal.$fMonadSum_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl1_r6v17];

Data.Semigroup.Internal.getProduct
  :: forall a. Data.Semigroup.Internal.Product a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Semigroup.Internal.$fMonadProduct_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> (a -> Data.Semigroup.Internal.Product b)
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6vdk k_s6vdl] k_s6vdl m_s6vdk;

Data.Semigroup.Internal.$fMonadProduct_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeProduct_$c*> eta_B2 eta_B1;

lvl2_r6v18
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6vdm] GHC.Err.errorWithoutStackTrace eta_s6vdm;

Data.Semigroup.Internal.$fMonadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeProduct
                                     Data.Semigroup.Internal.$fMonadProduct_$c>>=
                                     Data.Semigroup.Internal.$fMonadProduct_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl2_r6v18];

Data.Semigroup.Internal.getAlt
  :: forall k (f :: k -> *) (a :: k).
     Data.Semigroup.Internal.Alt f a -> f a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Alt2 eta_B1;

lvl3_r6v19 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesIdempotent: positive multiplier expected"#;

Data.Semigroup.Internal.stimesIdempotent1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_r6v19 of sat_s6vdn {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vdn;
        };

Data.Semigroup.Internal.stimesIdempotent
  :: forall b a. GHC.Real.Integral b => b -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vdo eta_s6vdp eta1_s6vdq]
        case
            GHC.Real.$p1Integral $dIntegral_s6vdo
        of
        $dReal_s6vdr [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6vdu [Occ=Once] :: b_a6sBZ
                [LclId] =
                    [$dReal_s6vdr] \u []
                        case GHC.Real.$p1Real $dReal_s6vdr of sat_s6vdt {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6vdt Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6vdr of sat_s6vds {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s6vds eta_s6vdp sat_s6vdu of {
                        GHC.Types.False -> eta1_s6vdq;
                        GHC.Types.True -> Data.Semigroup.Internal.stimesIdempotent1;
                      };
                };
        };

lvl4_r6v1a :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesIdempotentMonoid: negative multiplier"#;

Data.Semigroup.Internal.stimesIdempotentMonoid1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl4_r6v1a of sat_s6vdw {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vdw;
        };

Data.Semigroup.Internal.stimesIdempotentMonoid
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(LC(C(S))LLLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,1*U(A,1*U,A,A)><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vdx $dMonoid_s6vdy eta_s6vdz eta1_s6vdA]
        case
            GHC.Real.$p1Integral $dIntegral_s6vdx
        of
        $dReal_s6vdB [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6vdE [Occ=Once] :: b_a6sBJ
                [LclId] =
                    [$dReal_s6vdB] \u []
                        case GHC.Real.$p1Real $dReal_s6vdB of sat_s6vdD {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6vdD Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6vdB of sat_s6vdC {
                  __DEFAULT ->
                      case GHC.Classes.compare sat_s6vdC eta_s6vdz sat_s6vdE of {
                        GHC.Types.LT -> Data.Semigroup.Internal.stimesIdempotentMonoid1;
                        GHC.Types.EQ -> GHC.Base.mempty $dMonoid_s6vdy;
                        GHC.Types.GT -> eta1_s6vdA;
                      };
                };
        };

Data.Semigroup.Internal.$fSemigroupAny_go [Occ=LoopBreaker]
  :: Data.Semigroup.Internal.Any
     -> [Data.Semigroup.Internal.Any] -> Data.Semigroup.Internal.Any
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6vdG ds1_s6vdH]
        case ds1_s6vdH of {
          [] -> b_s6vdG;
          : c_s6vdJ [Occ=Once] cs_s6vdK [Occ=Once] ->
              case b_s6vdG of {
                GHC.Types.False ->
                    Data.Semigroup.Internal.$fSemigroupAny_go c_s6vdJ cs_s6vdK;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

Data.Semigroup.Internal.$fSemigroupAny_$csconcat
  :: GHC.Base.NonEmpty Data.Semigroup.Internal.Any
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6vdM]
        case ds_s6vdM of {
          GHC.Base.:| a1_s6vdO [Occ=Once] as_s6vdP [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupAny_go a1_s6vdO as_s6vdP;
        };

Data.Semigroup.Internal.$fMonoidAny_go [Occ=LoopBreaker]
  :: [Data.Semigroup.Internal.Any] -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vdQ]
        case ds_s6vdQ of {
          [] -> GHC.Types.False [];
          : y_s6vdS [Occ=Once] ys_s6vdT [Occ=Once] ->
              case y_s6vdS of {
                GHC.Types.False -> Data.Semigroup.Internal.$fMonoidAny_go ys_s6vdT;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

Data.Semigroup.Internal.$fSemigroupAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Classes.||
                                         Data.Semigroup.Internal.$fSemigroupAny_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupAny_$cstimes];
Data.Semigroup.Internal.$fMonoidAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupAny
                                      GHC.Types.False
                                      GHC.Classes.||
                                      Data.Semigroup.Internal.$fMonoidAny_go];
Data.Semigroup.Internal.$fSemigroupAny_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vdV eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6vdV Data.Semigroup.Internal.$fMonoidAny eta_B2 eta_B1;

Data.Semigroup.Internal.$fSemigroupAll_go [Occ=LoopBreaker]
  :: Data.Semigroup.Internal.All
     -> [Data.Semigroup.Internal.All] -> Data.Semigroup.Internal.All
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6vdW ds1_s6vdX]
        case ds1_s6vdX of {
          [] -> b_s6vdW;
          : c_s6vdZ [Occ=Once] cs_s6ve0 [Occ=Once] ->
              case b_s6vdW of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Semigroup.Internal.$fSemigroupAll_go c_s6vdZ cs_s6ve0;
              };
        };

Data.Semigroup.Internal.$fSemigroupAll_$csconcat
  :: GHC.Base.NonEmpty Data.Semigroup.Internal.All
     -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6ve2]
        case ds_s6ve2 of {
          GHC.Base.:| a1_s6ve4 [Occ=Once] as_s6ve5 [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupAll_go a1_s6ve4 as_s6ve5;
        };

Data.Semigroup.Internal.$fMonoidAll_go [Occ=LoopBreaker]
  :: [Data.Semigroup.Internal.All] -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6ve6]
        case ds_s6ve6 of {
          [] -> GHC.Types.True [];
          : y_s6ve8 [Occ=Once] ys_s6ve9 [Occ=Once] ->
              case y_s6ve8 of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> Data.Semigroup.Internal.$fMonoidAll_go ys_s6ve9;
              };
        };

Data.Semigroup.Internal.$fSemigroupAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Classes.&&
                                         Data.Semigroup.Internal.$fSemigroupAll_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupAll_$cstimes];
Data.Semigroup.Internal.$fMonoidAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupAll
                                      GHC.Types.True
                                      GHC.Classes.&&
                                      Data.Semigroup.Internal.$fMonoidAll_go];
Data.Semigroup.Internal.$fSemigroupAll_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6veb eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6veb Data.Semigroup.Internal.$fMonoidAll eta_B2 eta_B1;

lvl5_r6v1b :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesMonoid: negative multiplier"#;

lvl6_r6v1c :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r6v1b of sat_s6vec {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vec;
        };

sat_s6ved :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s6vee :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6ved GHC.Types.[]];

lvl7_r6v1d :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6vee;

Data.Semigroup.Internal.stimesMonoid
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(LC(C(S))LLLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(A,1*U,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vef $dMonoid_s6veg eta_s6veh eta1_s6vei]
        case
            GHC.Real.$p1Integral $dIntegral_s6vef
        of
        $dReal_s6vej [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6vem [Occ=Once] :: b_a6szg
                [LclId] =
                    [$dReal_s6vej] \u []
                        case GHC.Real.$p1Real $dReal_s6vej of sat_s6vel {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6vel Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6vej of sat_s6vek {
                  __DEFAULT ->
                      case GHC.Classes.compare sat_s6vek eta_s6veh sat_s6vem of {
                        GHC.Types.LT -> lvl6_r6v1c;
                        GHC.Types.EQ -> GHC.Base.mempty $dMonoid_s6veg;
                        GHC.Types.GT ->
                            let {
                              $dNum_s6veo [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a6szg
                              [LclId] =
                                  [$dReal_s6vej] \u [] GHC.Real.$p1Real $dReal_s6vej; } in
                            let {
                              lvl12_s6vep :: b_a6szg
                              [LclId] =
                                  [$dNum_s6veo] \u [] GHC.Num.fromInteger $dNum_s6veo lvl7_r6v1d;
                            } in 
                              let-no-escape {
                                exit_s6veq [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                  :: a_a6szh -> b_a6szg -> a_a6szh
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s6vef
                                              $dMonoid_s6veg
                                              $dReal_s6vej
                                              $dNum_s6veo
                                              lvl12_s6vep] \r [x_s6ver y_s6ves]
                                        case
                                            GHC.Real.$p2Real $dReal_s6vej
                                        of
                                        $dEq_s6vet [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              case
                                                  GHC.Classes.$p1Ord $dEq_s6vet
                                              of
                                              $dEq1_s6veu [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      lvl13_s6vev :: b_a6szg
                                                      [LclId] =
                                                          [$dNum_s6veo] \u []
                                                              GHC.Num.fromInteger
                                                                  $dNum_s6veo
                                                                  Data.Semigroup.Internal.$fMonoidProduct1;
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq1_s6veu y_s6ves lvl13_s6vev
                                                      of
                                                      { GHC.Types.False ->
                                                            let {
                                                              sat_s6veM [Occ=Once] :: b_a6szg
                                                              [LclId] =
                                                                  [$dIntegral_s6vef
                                                                   lvl12_s6vep
                                                                   y_s6ves] \u []
                                                                      GHC.Real.quot
                                                                          $dIntegral_s6vef
                                                                          y_s6ves
                                                                          lvl12_s6vep; } in
                                                            let {
                                                              sat_s6veL [Occ=Once] :: a_a6szh
                                                              [LclId] =
                                                                  [$dMonoid_s6veg x_s6ver] \u []
                                                                      GHC.Base.mappend
                                                                          $dMonoid_s6veg
                                                                          x_s6ver
                                                                          x_s6ver;
                                                            } in 
                                                              let-no-escape {
                                                                exit1_s6vex [Occ=OnceL!T[2],
                                                                             Dmd=<C(C(S)),C(C1(U))>]
                                                                  :: a_a6szh -> a_a6szh -> a_a6szh
                                                                [LclId[JoinId(2)],
                                                                 Arity=2,
                                                                 Str=<L,U><L,U>,
                                                                 Unf=OtherCon []] =
                                                                    sat-only [$dMonoid_s6veg] \r [x1_s6vey
                                                                                                  z_s6vez]
                                                                        GHC.Base.mappend
                                                                            $dMonoid_s6veg
                                                                            x1_s6vey
                                                                            z_s6vez;
                                                              } in 
                                                                let-no-escape {
                                                                  g_s6veA [Occ=LoopBreakerT[3]]
                                                                    :: a_a6szh
                                                                       -> b_a6szg
                                                                       -> a_a6szh
                                                                       -> a_a6szh
                                                                  [LclId[JoinId(3)],
                                                                   Arity=3,
                                                                   Str=<L,U><L,U><L,U>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [$dIntegral_s6vef
                                                                                $dMonoid_s6veg
                                                                                lvl12_s6vep
                                                                                $dEq1_s6veu
                                                                                lvl13_s6vev
                                                                                exit1_s6vex
                                                                                g_s6veA] \r [x1_s6veB
                                                                                             y1_s6veC
                                                                                             z_s6veD]
                                                                          case
                                                                              GHC.Real.even
                                                                                  $dIntegral_s6vef
                                                                                  y1_s6veC
                                                                          of
                                                                          { GHC.Types.False ->
                                                                                case
                                                                                    GHC.Classes.==
                                                                                        $dEq1_s6veu
                                                                                        y1_s6veC
                                                                                        lvl13_s6vev
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s6veI [Occ=Once]
                                                                                          :: a_a6szh
                                                                                        [LclId] =
                                                                                            [$dMonoid_s6veg
                                                                                             x1_s6veB
                                                                                             z_s6veD] \u []
                                                                                                GHC.Base.mappend
                                                                                                    $dMonoid_s6veg
                                                                                                    x1_s6veB
                                                                                                    z_s6veD; } in
                                                                                      let {
                                                                                        sat_s6veH [Occ=Once]
                                                                                          :: b_a6szg
                                                                                        [LclId] =
                                                                                            [$dIntegral_s6vef
                                                                                             lvl12_s6vep
                                                                                             y1_s6veC] \u []
                                                                                                GHC.Real.quot
                                                                                                    $dIntegral_s6vef
                                                                                                    y1_s6veC
                                                                                                    lvl12_s6vep; } in
                                                                                      let {
                                                                                        sat_s6veG [Occ=Once]
                                                                                          :: a_a6szh
                                                                                        [LclId] =
                                                                                            [$dMonoid_s6veg
                                                                                             x1_s6veB] \u []
                                                                                                GHC.Base.mappend
                                                                                                    $dMonoid_s6veg
                                                                                                    x1_s6veB
                                                                                                    x1_s6veB;
                                                                                      } in 
                                                                                        g_s6veA
                                                                                            sat_s6veG
                                                                                            sat_s6veH
                                                                                            sat_s6veI;
                                                                                  GHC.Types.True ->
                                                                                      exit1_s6vex
                                                                                          x1_s6veB
                                                                                          z_s6veD;
                                                                                };
                                                                            GHC.Types.True ->
                                                                                let {
                                                                                  sat_s6veK [Occ=Once]
                                                                                    :: b_a6szg
                                                                                  [LclId] =
                                                                                      [$dIntegral_s6vef
                                                                                       lvl12_s6vep
                                                                                       y1_s6veC] \u []
                                                                                          GHC.Real.quot
                                                                                              $dIntegral_s6vef
                                                                                              y1_s6veC
                                                                                              lvl12_s6vep; } in
                                                                                let {
                                                                                  sat_s6veJ [Occ=Once]
                                                                                    :: a_a6szh
                                                                                  [LclId] =
                                                                                      [$dMonoid_s6veg
                                                                                       x1_s6veB] \u []
                                                                                          GHC.Base.mappend
                                                                                              $dMonoid_s6veg
                                                                                              x1_s6veB
                                                                                              x1_s6veB;
                                                                                } in 
                                                                                  g_s6veA
                                                                                      sat_s6veJ
                                                                                      sat_s6veK
                                                                                      z_s6veD;
                                                                          };
                                                                } in 
                                                                  g_s6veA
                                                                      sat_s6veL sat_s6veM x_s6ver;
                                                        GHC.Types.True -> x_s6ver;
                                                      };
                                              };
                                        };
                              } in 
                                let-no-escape {
                                  f_s6veN [Occ=LoopBreakerT[2]] :: a_a6szh -> b_a6szg -> a_a6szh
                                  [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dIntegral_s6vef
                                                $dMonoid_s6veg
                                                lvl12_s6vep
                                                exit_s6veq
                                                f_s6veN] \r [x_s6veO y_s6veP]
                                          case GHC.Real.even $dIntegral_s6vef y_s6veP of {
                                            GHC.Types.False -> exit_s6veq x_s6veO y_s6veP;
                                            GHC.Types.True ->
                                                let {
                                                  sat_s6veS [Occ=Once] :: b_a6szg
                                                  [LclId] =
                                                      [$dIntegral_s6vef lvl12_s6vep y_s6veP] \u []
                                                          GHC.Real.quot
                                                              $dIntegral_s6vef
                                                              y_s6veP
                                                              lvl12_s6vep; } in
                                                let {
                                                  sat_s6veR [Occ=Once] :: a_a6szh
                                                  [LclId] =
                                                      [$dMonoid_s6veg x_s6veO] \u []
                                                          GHC.Base.mappend
                                                              $dMonoid_s6veg x_s6veO x_s6veO;
                                                } in  f_s6veN sat_s6veR sat_s6veS;
                                          };
                                } in  f_s6veN eta1_s6vei eta_s6veh;
                      };
                };
        };

Data.Semigroup.Internal.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     Data.Semigroup.Internal.Alt f a
     -> [Data.Semigroup.Internal.Alt f a]
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6veT ww_s6veU ww1_s6veV]
        let {
          go_s6veW [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL
               -> [Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL]
               -> Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6veT go_s6veW] \r [b_s6veX ds1_s6veY]
                  case ds1_s6veY of {
                    [] -> b_s6veX;
                    : c_s6vf0 [Occ=Once] cs_s6vf1 [Occ=Once] ->
                        let {
                          sat_s6vf2 [Occ=Once] :: f_s6uNK a_s6uNL
                          [LclId] =
                              [go_s6veW c_s6vf0 cs_s6vf1] \u [] go_s6veW c_s6vf0 cs_s6vf1;
                        } in  GHC.Base.<|> w_s6veT b_s6veX sat_s6vf2;
                  };
        } in  go_s6veW ww_s6veU ww1_s6veV;

Data.Semigroup.Internal.$fSemigroupAlt_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Alt f a)
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6vf3 w1_s6vf4]
        case w1_s6vf4 of {
          GHC.Base.:| ww1_s6vf6 [Occ=Once] ww2_s6vf7 [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat w_s6vf3 ww1_s6vf6 ww2_s6vf7;
        };

Data.Semigroup.Internal.$fMonoidAlt_$cmconcat
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     [Data.Semigroup.Internal.Alt f a]
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6vf8 eta_s6vf9]
        let {
          z_s6vfa [Occ=OnceL] :: f_X6tGf a_X6tGh
          [LclId] =
              [$dAlternative_s6vf8] \u []
                  GHC.Base.empty $dAlternative_s6vf8; } in
        let {
          go_s6vfb [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Alt f_X6tGf a_X6tGh]
               -> Data.Semigroup.Internal.Alt f_X6tGf a_X6tGh
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dAlternative_s6vf8 z_s6vfa go_s6vfb] \r [ds_s6vfc]
                  case ds_s6vfc of {
                    [] -> z_s6vfa;
                    : y_s6vfe [Occ=Once] ys_s6vff [Occ=Once] ->
                        let {
                          sat_s6vfg [Occ=Once] :: f_X6tGf a_X6tGh
                          [LclId] =
                              [go_s6vfb ys_s6vff] \u [] go_s6vfb ys_s6vff;
                        } in  GHC.Base.<|> $dAlternative_s6vf8 y_s6vfe sat_s6vfg;
                  };
        } in  go_s6vfb eta_s6vf9;

Data.Semigroup.Internal.$fSemigroupAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A,A)>m] =
    [] \r [$dAlternative_s6vfh]
        let {
          sat_s6vfk [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6vfh] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupAlt_$cstimes
                      $dAlternative_s6vfh eta_B1; } in
        let {
          sat_s6vfj [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF)
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6vfh] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupAlt_$csconcat
                      $dAlternative_s6vfh eta_B1; } in
        let {
          sat_s6vfi [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6vfh] \u [] GHC.Base.<|> $dAlternative_s6vfh;
        } in  GHC.Base.C:Semigroup [sat_s6vfi sat_s6vfj sat_s6vfk];
Data.Semigroup.Internal.$fMonoidAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A,A)>m] =
    [] \r [$dAlternative_s6vfl]
        let {
          sat_s6vfp [Occ=Once]
            :: [Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9]
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6vfl] \r [eta_B1]
                  Data.Semigroup.Internal.$fMonoidAlt_$cmconcat
                      $dAlternative_s6vfl eta_B1; } in
        let {
          sat_s6vfo [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6vfl] \u [] GHC.Base.<|> $dAlternative_s6vfl; } in
        let {
          sat_s6vfn [Occ=Once] :: Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6vfl] \u []
                  GHC.Base.empty $dAlternative_s6vfl; } in
        let {
          sat_s6vfm [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9)
          [LclId] =
              [$dAlternative_s6vfl] \u []
                  Data.Semigroup.Internal.$fSemigroupAlt $dAlternative_s6vfl;
        } in  GHC.Base.C:Monoid [sat_s6vfm sat_s6vfn sat_s6vfo sat_s6vfp];
Data.Semigroup.Internal.$fSemigroupAlt_$cstimes [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     forall b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.Internal.Alt f a
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Str=<L,U(A,U,U,A,A)><L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6vfq $dIntegral_s6vfr]
        let {
          sat_s6vfs [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Alt f_X6tGK a_X6tGM)
          [LclId] =
              [$dAlternative_s6vfq] \u []
                  Data.Semigroup.Internal.$fMonoidAlt $dAlternative_s6vfq;
        } in 
          Data.Semigroup.Internal.stimesMonoid $dIntegral_s6vfr sat_s6vfs;

Data.Semigroup.Internal.$fSemigroupEndo1 [Occ=LoopBreaker]
  :: forall a.
     Data.Semigroup.Internal.Endo a
     -> [Data.Semigroup.Internal.Endo a]
     -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6vft ds1_s6vfu]
        case ds1_s6vfu of {
          [] -> b_s6vft;
          : c_s6vfw [Occ=Once] cs_s6vfx [Occ=Once] ->
              let {
                g_s6vfy [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Data.Semigroup.Internal.Endo a_a6tyX
                [LclId] =
                    [c_s6vfw cs_s6vfx] \u []
                        Data.Semigroup.Internal.$fSemigroupEndo1 c_s6vfw cs_s6vfx; } in
              let {
                sat_s6vfB [Occ=Once] :: a_a6tyX -> a_a6tyX
                [LclId] =
                    [b_s6vft g_s6vfy] \r [x_s6vfz]
                        let {
                          sat_s6vfA [Occ=Once] :: a_a6tyX
                          [LclId] =
                              [g_s6vfy x_s6vfz] \u [] g_s6vfy x_s6vfz;
                        } in  b_s6vft sat_s6vfA;
              } in  sat_s6vfB;
        };

Data.Semigroup.Internal.$fSemigroupEndo_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Endo a)
     -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6vfC]
        case ds_s6vfC of {
          GHC.Base.:| a1_s6vfE [Occ=Once] as_s6vfF [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupEndo1 a1_s6vfE as_s6vfF;
        };

Data.Semigroup.Internal.$fMonoidEndo1 [Occ=LoopBreaker]
  :: forall a. [Data.Semigroup.Internal.Endo a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6vfG eta_s6vfH]
        case ds_s6vfG of {
          [] -> eta_s6vfH;
          : y_s6vfJ [Occ=Once] ys_s6vfK [Occ=Once] ->
              let {
                sat_s6vfL [Occ=Once] :: a_a6tyy
                [LclId] =
                    [eta_s6vfH ys_s6vfK] \u []
                        Data.Semigroup.Internal.$fMonoidEndo1 ys_s6vfK eta_s6vfH;
              } in  y_s6vfJ sat_s6vfL;
        };

Data.Semigroup.Internal.$fSemigroupEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base..
                                         Data.Semigroup.Internal.$fSemigroupEndo_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupEndo_$cstimes];
Data.Semigroup.Internal.$fMonoidEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupEndo
                                      GHC.Base.id
                                      GHC.Base..
                                      Data.Semigroup.Internal.$fMonoidEndo1];
Data.Semigroup.Internal.$fSemigroupEndo_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vfM eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesMonoid
            $dIntegral_s6vfM
            Data.Semigroup.Internal.$fMonoidEndo
            eta_B2
            eta_B1;

lvl8_r6v1e :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: positive multiplier expected"#;

lvl9_r6v1f :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl8_r6v1e of sat_s6vfN {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vfN;
        };

Data.Semigroup.Internal.stimesDefault
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Semigroup a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LLC(C(S))LLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(C(C1(U)),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vfO $dSemigroup_s6vfP eta_s6vfQ eta1_s6vfR]
        case
            GHC.Real.$p1Integral $dIntegral_s6vfO
        of
        $dReal_s6vfS [Dmd=<S(LS(S(C(C(S))L)LLC(C(S))LLLL)L),U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6vfV [Occ=Once] :: b_a6swD
                [LclId] =
                    [$dReal_s6vfS] \u []
                        case GHC.Real.$p1Real $dReal_s6vfS of sat_s6vfU {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6vfU Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6vfS of sat_s6vfT {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s6vfT eta_s6vfQ sat_s6vfV of {
                        GHC.Types.False ->
                            let {
                              $dNum_s6vfX [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a6swD
                              [LclId] =
                                  [$dReal_s6vfS] \u [] GHC.Real.$p1Real $dReal_s6vfS; } in
                            let {
                              lvl12_s6vfY :: b_a6swD
                              [LclId] =
                                  [$dNum_s6vfX] \u [] GHC.Num.fromInteger $dNum_s6vfX lvl7_r6v1d;
                            } in 
                              let-no-escape {
                                exit_s6vfZ [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                  :: a_a6swE -> b_a6swD -> a_a6swE
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s6vfO
                                              $dSemigroup_s6vfP
                                              $dReal_s6vfS
                                              $dNum_s6vfX
                                              lvl12_s6vfY] \r [x_s6vg0 y_s6vg1]
                                        case
                                            GHC.Real.$p2Real $dReal_s6vfS
                                        of
                                        $dEq_s6vg2 [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              case
                                                  GHC.Classes.$p1Ord $dEq_s6vg2
                                              of
                                              $dEq1_s6vg3 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      lvl13_s6vg4 :: b_a6swD
                                                      [LclId] =
                                                          [$dNum_s6vfX] \u []
                                                              GHC.Num.fromInteger
                                                                  $dNum_s6vfX
                                                                  Data.Semigroup.Internal.$fMonoidProduct1;
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq1_s6vg3 y_s6vg1 lvl13_s6vg4
                                                      of
                                                      { GHC.Types.False ->
                                                            let {
                                                              sat_s6vgl [Occ=Once] :: b_a6swD
                                                              [LclId] =
                                                                  [$dIntegral_s6vfO
                                                                   lvl12_s6vfY
                                                                   y_s6vg1] \u []
                                                                      GHC.Real.quot
                                                                          $dIntegral_s6vfO
                                                                          y_s6vg1
                                                                          lvl12_s6vfY; } in
                                                            let {
                                                              sat_s6vgk [Occ=Once] :: a_a6swE
                                                              [LclId] =
                                                                  [$dSemigroup_s6vfP x_s6vg0] \u []
                                                                      GHC.Base.<>
                                                                          $dSemigroup_s6vfP
                                                                          x_s6vg0
                                                                          x_s6vg0;
                                                            } in 
                                                              let-no-escape {
                                                                exit1_s6vg6 [Occ=OnceL!T[2],
                                                                             Dmd=<C(C(S)),C(C1(U))>]
                                                                  :: a_a6swE -> a_a6swE -> a_a6swE
                                                                [LclId[JoinId(2)],
                                                                 Arity=2,
                                                                 Str=<L,U><L,U>,
                                                                 Unf=OtherCon []] =
                                                                    sat-only [$dSemigroup_s6vfP] \r [x1_s6vg7
                                                                                                     z_s6vg8]
                                                                        GHC.Base.<>
                                                                            $dSemigroup_s6vfP
                                                                            x1_s6vg7
                                                                            z_s6vg8;
                                                              } in 
                                                                let-no-escape {
                                                                  g_s6vg9 [Occ=LoopBreakerT[3]]
                                                                    :: a_a6swE
                                                                       -> b_a6swD
                                                                       -> a_a6swE
                                                                       -> a_a6swE
                                                                  [LclId[JoinId(3)],
                                                                   Arity=3,
                                                                   Str=<L,U><L,U><L,U>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [$dIntegral_s6vfO
                                                                                $dSemigroup_s6vfP
                                                                                lvl12_s6vfY
                                                                                $dEq1_s6vg3
                                                                                lvl13_s6vg4
                                                                                exit1_s6vg6
                                                                                g_s6vg9] \r [x1_s6vga
                                                                                             y1_s6vgb
                                                                                             z_s6vgc]
                                                                          case
                                                                              GHC.Real.even
                                                                                  $dIntegral_s6vfO
                                                                                  y1_s6vgb
                                                                          of
                                                                          { GHC.Types.False ->
                                                                                case
                                                                                    GHC.Classes.==
                                                                                        $dEq1_s6vg3
                                                                                        y1_s6vgb
                                                                                        lvl13_s6vg4
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s6vgh [Occ=Once]
                                                                                          :: a_a6swE
                                                                                        [LclId] =
                                                                                            [$dSemigroup_s6vfP
                                                                                             x1_s6vga
                                                                                             z_s6vgc] \u []
                                                                                                GHC.Base.<>
                                                                                                    $dSemigroup_s6vfP
                                                                                                    x1_s6vga
                                                                                                    z_s6vgc; } in
                                                                                      let {
                                                                                        sat_s6vgg [Occ=Once]
                                                                                          :: b_a6swD
                                                                                        [LclId] =
                                                                                            [$dIntegral_s6vfO
                                                                                             lvl12_s6vfY
                                                                                             y1_s6vgb] \u []
                                                                                                GHC.Real.quot
                                                                                                    $dIntegral_s6vfO
                                                                                                    y1_s6vgb
                                                                                                    lvl12_s6vfY; } in
                                                                                      let {
                                                                                        sat_s6vgf [Occ=Once]
                                                                                          :: a_a6swE
                                                                                        [LclId] =
                                                                                            [$dSemigroup_s6vfP
                                                                                             x1_s6vga] \u []
                                                                                                GHC.Base.<>
                                                                                                    $dSemigroup_s6vfP
                                                                                                    x1_s6vga
                                                                                                    x1_s6vga;
                                                                                      } in 
                                                                                        g_s6vg9
                                                                                            sat_s6vgf
                                                                                            sat_s6vgg
                                                                                            sat_s6vgh;
                                                                                  GHC.Types.True ->
                                                                                      exit1_s6vg6
                                                                                          x1_s6vga
                                                                                          z_s6vgc;
                                                                                };
                                                                            GHC.Types.True ->
                                                                                let {
                                                                                  sat_s6vgj [Occ=Once]
                                                                                    :: b_a6swD
                                                                                  [LclId] =
                                                                                      [$dIntegral_s6vfO
                                                                                       lvl12_s6vfY
                                                                                       y1_s6vgb] \u []
                                                                                          GHC.Real.quot
                                                                                              $dIntegral_s6vfO
                                                                                              y1_s6vgb
                                                                                              lvl12_s6vfY; } in
                                                                                let {
                                                                                  sat_s6vgi [Occ=Once]
                                                                                    :: a_a6swE
                                                                                  [LclId] =
                                                                                      [$dSemigroup_s6vfP
                                                                                       x1_s6vga] \u []
                                                                                          GHC.Base.<>
                                                                                              $dSemigroup_s6vfP
                                                                                              x1_s6vga
                                                                                              x1_s6vga;
                                                                                } in 
                                                                                  g_s6vg9
                                                                                      sat_s6vgi
                                                                                      sat_s6vgj
                                                                                      z_s6vgc;
                                                                          };
                                                                } in 
                                                                  g_s6vg9
                                                                      sat_s6vgk sat_s6vgl x_s6vg0;
                                                        GHC.Types.True -> x_s6vg0;
                                                      };
                                              };
                                        };
                              } in 
                                let-no-escape {
                                  f_s6vgm [Occ=LoopBreakerT[2]] :: a_a6swE -> b_a6swD -> a_a6swE
                                  [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dIntegral_s6vfO
                                                $dSemigroup_s6vfP
                                                lvl12_s6vfY
                                                exit_s6vfZ
                                                f_s6vgm] \r [x_s6vgn y_s6vgo]
                                          case GHC.Real.even $dIntegral_s6vfO y_s6vgo of {
                                            GHC.Types.False -> exit_s6vfZ x_s6vgn y_s6vgo;
                                            GHC.Types.True ->
                                                let {
                                                  sat_s6vgr [Occ=Once] :: b_a6swD
                                                  [LclId] =
                                                      [$dIntegral_s6vfO lvl12_s6vfY y_s6vgo] \u []
                                                          GHC.Real.quot
                                                              $dIntegral_s6vfO
                                                              y_s6vgo
                                                              lvl12_s6vfY; } in
                                                let {
                                                  sat_s6vgq [Occ=Once] :: a_a6swE
                                                  [LclId] =
                                                      [$dSemigroup_s6vfP x_s6vgn] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup_s6vfP x_s6vgn x_s6vgn;
                                                } in  f_s6vgm sat_s6vgq sat_s6vgr;
                                          };
                                } in  f_s6vgm eta1_s6vfR eta_s6vfQ;
                        GHC.Types.True -> lvl9_r6v1f;
                      };
                };
        };

lvl10_r6v1g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: Maybe, negative multiplier"#;

Data.Semigroup.Internal.stimesMaybe1 :: forall a. GHC.Base.Maybe a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl10_r6v1g of sat_s6vgs {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vgs;
        };

Data.Semigroup.Internal.stimesMaybe
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Semigroup a) =>
     b -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=4,
 Str=<L,U(U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vgt $dSemigroup_s6vgu eta_s6vgv eta1_s6vgw]
        case eta1_s6vgw of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_s6vgy [Occ=Once] ->
              case
                  GHC.Real.$p1Integral $dIntegral_s6vgt
              of
              $dReal_s6vgz [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_s6vgC [Occ=Once] :: b_a6swh
                      [LclId] =
                          [$dReal_s6vgz] \u []
                              case GHC.Real.$p1Real $dReal_s6vgz of sat_s6vgB {
                                __DEFAULT ->
                                    GHC.Num.fromInteger
                                        sat_s6vgB Data.Semigroup.Internal.$fMonoidSum1;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_s6vgz of sat_s6vgA {
                        __DEFAULT ->
                            case GHC.Classes.compare sat_s6vgA eta_s6vgv sat_s6vgC of {
                              GHC.Types.LT -> Data.Semigroup.Internal.stimesMaybe1;
                              GHC.Types.EQ -> GHC.Base.Nothing [];
                              GHC.Types.GT ->
                                  let {
                                    sat_s6vgE [Occ=Once] :: a_a6swi
                                    [LclId] =
                                        [$dIntegral_s6vgt
                                         $dSemigroup_s6vgu
                                         eta_s6vgv
                                         a1_s6vgy] \u []
                                            GHC.Base.stimes
                                                $dSemigroup_s6vgu
                                                $dIntegral_s6vgt
                                                eta_s6vgv
                                                a1_s6vgy;
                                  } in  GHC.Base.Just [sat_s6vgE];
                            };
                      };
              };
        };

lvl11_r6v1h :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: [], negative multiplier"#;

Data.Semigroup.Internal.stimesList1 :: forall a. [a]
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_r6v1h of sat_s6vgF {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vgF;
        };

Data.Semigroup.Internal.stimesList
  :: forall b a. GHC.Real.Integral b => b -> [a] -> [a]
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vgG eta_s6vgH eta1_s6vgI]
        case
            GHC.Real.$p1Integral $dIntegral_s6vgG
        of
        $dReal_s6vgJ [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,C(C1(U)),A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s6vgK [Dmd=<L,U(A,C(C1(U)),A,A,A,A,C(U))>]
                  :: GHC.Num.Num b_a6svr
                [LclId] =
                    [$dReal_s6vgJ] \u [] GHC.Real.$p1Real $dReal_s6vgJ;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s6vgJ
                of
                $dOrd_s6vgL [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s6vgM [Occ=Once] :: b_a6svr
                        [LclId] =
                            [$dNum_s6vgK] \u []
                                GHC.Num.fromInteger
                                    $dNum_s6vgK Data.Semigroup.Internal.$fMonoidSum1;
                      } in 
                        case GHC.Classes.< $dOrd_s6vgL eta_s6vgH sat_s6vgM of {
                          GHC.Types.False ->
                              let {
                                lvl12_s6vgO [Occ=OnceL] :: b_a6svr
                                [LclId] =
                                    [$dNum_s6vgK] \u []
                                        GHC.Num.fromInteger
                                            $dNum_s6vgK
                                            Data.Semigroup.Internal.$fMonoidProduct1; } in
                              let {
                                lvl13_s6vgP [Occ=OnceL] :: b_a6svr
                                [LclId] =
                                    [$dNum_s6vgK] \u []
                                        GHC.Num.fromInteger
                                            $dNum_s6vgK Data.Semigroup.Internal.$fMonoidSum1;
                              } in 
                                case
                                    GHC.Classes.$p1Ord $dOrd_s6vgL
                                of
                                $dEq_s6vgQ [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                { __DEFAULT ->
                                      let {
                                        rep_s6vgR [Occ=LoopBreaker] :: b_a6svr -> [a_a6svs]
                                        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                            sat-only [eta1_s6vgI
                                                      $dNum_s6vgK
                                                      lvl12_s6vgO
                                                      lvl13_s6vgP
                                                      $dEq_s6vgQ
                                                      rep_s6vgR] \r [ds_s6vgS]
                                                case
                                                    GHC.Classes.== $dEq_s6vgQ ds_s6vgS lvl13_s6vgP
                                                of
                                                { GHC.Types.False ->
                                                      let {
                                                        sat_s6vgV [Occ=Once, Dmd=<L,1*U>]
                                                          :: [a_a6svs]
                                                        [LclId] =
                                                            [$dNum_s6vgK
                                                             lvl12_s6vgO
                                                             rep_s6vgR
                                                             ds_s6vgS] \s []
                                                                let {
                                                                  sat_s6vgU [Occ=Once] :: b_a6svr
                                                                  [LclId] =
                                                                      [$dNum_s6vgK
                                                                       lvl12_s6vgO
                                                                       ds_s6vgS] \u []
                                                                          GHC.Num.-
                                                                              $dNum_s6vgK
                                                                              ds_s6vgS
                                                                              lvl12_s6vgO;
                                                                } in  rep_s6vgR sat_s6vgU;
                                                      } in  GHC.Base.++ eta1_s6vgI sat_s6vgV;
                                                  GHC.Types.True -> [] [];
                                                };
                                      } in  rep_s6vgR eta_s6vgH;
                                };
                          GHC.Types.True -> Data.Semigroup.Internal.stimesList1;
                        };
                };
        };

Data.Semigroup.Internal.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Semigroup.Internal.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$trModule4];

Data.Semigroup.Internal.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Semigroup.Internal"#;

Data.Semigroup.Internal.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$trModule2];

Data.Semigroup.Internal.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Semigroup.Internal.$trModule3
                                     Data.Semigroup.Internal.$trModule1];

$krep_r6v1i :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep1_r6v1j :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r6v1k :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep1_r6v1j];

$krep3_r6v1l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j
                                         GHC.Types.krep$*];

Data.Semigroup.Internal.$tcAlt1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r6v1l $krep3_r6v1l];

$krep4_r6v1m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_r6v1n :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep6_r6v1o :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_r6v1m $krep5_r6v1n];

Data.Semigroup.Internal.$tcDual1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadDual5];

Data.Semigroup.Internal.$tcDual :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14711416616195557841##
                                    10971851269997195248##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcDual1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep7_r6v1p :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r6v1j GHC.Types.[]];

$krep8_r6v1q :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcDual
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Dual1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep8_r6v1q];

Data.Semigroup.Internal.$tc'Dual3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Dual"#;

Data.Semigroup.Internal.$tc'Dual2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Dual3];

Data.Semigroup.Internal.$tc'Dual :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15885009659242865261##
                                    15931193389986079612##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Dual2
                                    1#
                                    Data.Semigroup.Internal.$tc'Dual1];

Data.Semigroup.Internal.$tcEndo2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Endo"#;

Data.Semigroup.Internal.$tcEndo1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tcEndo2];

Data.Semigroup.Internal.$tcEndo :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16820921632006328603##
                                    4981834339379479823##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcEndo1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r6v1r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcEndo
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Endo1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6v1k $krep9_r6v1r];

Data.Semigroup.Internal.$tc'Endo3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Endo"#;

Data.Semigroup.Internal.$tc'Endo2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Endo3];

Data.Semigroup.Internal.$tc'Endo :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [156297185665537802##
                                    8988325904501215692##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Endo2
                                    1#
                                    Data.Semigroup.Internal.$tc'Endo1];

Data.Semigroup.Internal.$tcAll1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAll13];

Data.Semigroup.Internal.$tcAll :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14149274874874504208##
                                    8164254778609961234##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAll1
                                    0#
                                    GHC.Types.krep$*];

$krep10_r6v1s :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAll
                                              GHC.Types.[]];

Data.Semigroup.Internal.$tc'All1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r6v1i $krep10_r6v1s];

Data.Semigroup.Internal.$tc'All3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'All"#;

Data.Semigroup.Internal.$tc'All2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'All3];

Data.Semigroup.Internal.$tc'All :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1168494541548489787##
                                    10689931498683547374##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'All2
                                    0#
                                    Data.Semigroup.Internal.$tc'All1];

Data.Semigroup.Internal.$tcAny1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAny6];

Data.Semigroup.Internal.$tcAny :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11600287624241135668##
                                    17600231731807245316##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAny1
                                    0#
                                    GHC.Types.krep$*];

$krep11_r6v1t :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAny
                                              GHC.Types.[]];

Data.Semigroup.Internal.$tc'Any1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r6v1i $krep11_r6v1t];

Data.Semigroup.Internal.$tc'Any3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Any"#;

Data.Semigroup.Internal.$tc'Any2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Any3];

Data.Semigroup.Internal.$tc'Any :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16164188984560189013##
                                    110490866064676064##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Any2
                                    0#
                                    Data.Semigroup.Internal.$tc'Any1];

Data.Semigroup.Internal.$tcSum1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadSum5];

Data.Semigroup.Internal.$tcSum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7521450980204740829##
                                    14029043805042477297##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcSum1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep12_r6v1u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcSum
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Sum1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep12_r6v1u];

Data.Semigroup.Internal.$tc'Sum3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Sum"#;

Data.Semigroup.Internal.$tc'Sum2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Sum3];

Data.Semigroup.Internal.$tc'Sum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7144872330799658717##
                                    13465414667749873698##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Sum2
                                    1#
                                    Data.Semigroup.Internal.$tc'Sum1];

Data.Semigroup.Internal.$tcProduct1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadProduct5];

Data.Semigroup.Internal.$tcProduct :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12271745360620305859##
                                    5747185732973757022##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcProduct1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_r6v1v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcProduct
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Product1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep13_r6v1v];

Data.Semigroup.Internal.$tc'Product3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Product"#;

Data.Semigroup.Internal.$tc'Product2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Product3];

Data.Semigroup.Internal.$tc'Product :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3191278115598904989##
                                    12638872580785847167##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Product2
                                    1#
                                    Data.Semigroup.Internal.$tc'Product1];

Data.Semigroup.Internal.$tcAlt2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAlt5];

Data.Semigroup.Internal.$tcAlt :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7601313288863504805##
                                    2369500163797891218##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAlt2
                                    1#
                                    Data.Semigroup.Internal.$tcAlt1];

$krep14_r6v1w :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_r6v1n GHC.Types.[]];

$krep15_r6v1x :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_r6v1m $krep14_r6v1w];

$krep16_r6v1y :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r6v1j $krep15_r6v1x];

$krep17_r6v1z :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAlt
                                              $krep16_r6v1y];

Data.Semigroup.Internal.$tc'Alt1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r6v1o $krep17_r6v1z];

Data.Semigroup.Internal.$tc'Alt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Alt"#;

Data.Semigroup.Internal.$tc'Alt2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Alt3];

Data.Semigroup.Internal.$tc'Alt :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1436877498177162483##
                                    16937142347825669760##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Alt2
                                    3#
                                    Data.Semigroup.Internal.$tc'Alt1];


==================== STG syntax: ====================
2018-03-16 16:01:42.988516765 UTC

Data.Semigroup.Internal.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     Data.Semigroup.Internal.Dual a
     -> [Data.Semigroup.Internal.Dual a]
     -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6v1B ww_s6v1C ww1_s6v1D]
        let {
          go_s6v1E [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Dual a_s6uKL
               -> [Data.Semigroup.Internal.Dual a_s6uKL]
               -> Data.Semigroup.Internal.Dual a_s6uKL
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6v1B go_s6v1E] \r [b_s6v1F ds1_s6v1G]
                  case ds1_s6v1G of {
                    [] -> b_s6v1F;
                    : c_s6v1I [Occ=Once] cs_s6v1J [Occ=Once] ->
                        let {
                          sat_s6v1K [Occ=Once] :: a_s6uKL
                          [LclId] =
                              [go_s6v1E c_s6v1I cs_s6v1J] \u [] go_s6v1E c_s6v1I cs_s6v1J;
                        } in  GHC.Base.<> w_s6v1B sat_s6v1K b_s6v1F;
                  };
        } in  go_s6v1E ww_s6v1C ww1_s6v1D;

Data.Semigroup.Internal.$fSemigroupDual_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Dual a)
     -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6v1L w1_s6v1M]
        case w1_s6v1M of {
          GHC.Base.:| ww1_s6v1O [Occ=Once] ww2_s6v1P [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat1 w_s6v1L ww1_s6v1O ww2_s6v1P;
        };

Data.Semigroup.Internal.$fSemigroupDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s6v1Q]
        let {
          sat_s6v1Y [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6v1Q] \r [$dIntegral_s6v1V n_s6v1W ds_s6v1X]
                  GHC.Base.stimes
                      $dSemigroup_s6v1Q $dIntegral_s6v1V n_s6v1W ds_s6v1X; } in
        let {
          sat_s6v1U [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Dual a_X6tId)
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6v1Q] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupDual_$csconcat
                      $dSemigroup_s6v1Q eta_B1; } in
        let {
          sat_s6v1T [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6v1Q] \r [ds_s6v1R ds1_s6v1S]
                  GHC.Base.<> $dSemigroup_s6v1Q ds1_s6v1S ds_s6v1R;
        } in  GHC.Base.C:Semigroup [sat_s6v1T sat_s6v1U sat_s6v1Y];

Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6v1Z]
        let {
          sat_s6v20 [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a6tBw
          [LclId] =
              [$dMonoid_s6v1Z] \u [] GHC.Base.$p1Monoid $dMonoid_s6v1Z;
        } in  Data.Semigroup.Internal.$fSemigroupDual sat_s6v20;

$cmappend_r6v15
  :: forall a.
     GHC.Base.Monoid a =>
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dMonoid_s6v21 ds_s6v22 ds1_s6v23]
        case GHC.Base.$p1Monoid $dMonoid_s6v21 of sat_s6v24 {
          __DEFAULT -> GHC.Base.<> sat_s6v24 ds1_s6v23 ds_s6v22;
        };

Data.Semigroup.Internal.$fMonoidDual_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Base.Monoid a =>
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $cmappend_r6v15 eta_B3 eta_B2 eta_B1;

Data.Semigroup.Internal.$fMonoidDual_$cmconcat
  :: forall a.
     GHC.Base.Monoid a =>
     [Data.Semigroup.Internal.Dual a] -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6v25 eta_s6v26]
        let {
          lvl12_s6v27 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X6tHX
          [LclId] =
              [$dMonoid_s6v25] \u [] GHC.Base.$p1Monoid $dMonoid_s6v25; } in
        let {
          z_s6v28 [Occ=OnceL] :: a_X6tHX
          [LclId] =
              [$dMonoid_s6v25] \u [] GHC.Base.mempty $dMonoid_s6v25; } in
        let {
          go_s6v29 [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Dual a_X6tHX]
               -> Data.Semigroup.Internal.Dual a_X6tHX
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [lvl12_s6v27 z_s6v28 go_s6v29] \r [ds_s6v2a]
                  case ds_s6v2a of {
                    [] -> z_s6v28;
                    : y_s6v2c [Occ=Once] ys_s6v2d [Occ=Once] ->
                        let {
                          sat_s6v2e [Occ=Once] :: a_X6tHX
                          [LclId] =
                              [go_s6v29 ys_s6v2d] \u [] go_s6v29 ys_s6v2d;
                        } in  GHC.Base.<> lvl12_s6v27 sat_s6v2e y_s6v2c;
                  };
        } in  go_s6v29 eta_s6v26;

Data.Semigroup.Internal.$fMonoidDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s6v2f]
        let {
          sat_s6v2j [Occ=Once]
            :: [Data.Semigroup.Internal.Dual a_a6tBw]
               -> Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6v2f] \r [eta_B1]
                  Data.Semigroup.Internal.$fMonoidDual_$cmconcat
                      $dMonoid_s6v2f eta_B1; } in
        let {
          sat_s6v2i [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6tBw
               -> Data.Semigroup.Internal.Dual a_a6tBw
               -> Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6v2f] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fMonoidDual_$cmappend
                      $dMonoid_s6v2f eta_B2 eta_B1; } in
        let {
          sat_s6v2h [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6v2f] \u [] GHC.Base.mempty $dMonoid_s6v2f; } in
        let {
          sat_s6v2g [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a_a6tBw)
          [LclId] =
              [$dMonoid_s6v2f] \u []
                  Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid $dMonoid_s6v2f;
        } in  GHC.Base.C:Monoid [sat_s6v2g sat_s6v2h sat_s6v2i sat_s6v2j];

Data.Semigroup.Internal.$fFunctorDual2
  :: forall a b. (a -> b) -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6v2k] v_s6v2k;

Data.Semigroup.Internal.$fFunctorDual1 :: forall b a. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6v2l ds_s6v2m] x_s6v2l;

Data.Semigroup.Internal.$fFunctorDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeDual3
  :: forall a b.
     Data.Semigroup.Internal.Dual (a -> b)
     -> Data.Semigroup.Internal.Dual (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6v2n] v_s6v2n;

Data.Semigroup.Internal.$fApplicativeDual4 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6v2o] v_s6v2o;

Data.Semigroup.Internal.$fApplicativeDual2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Dual a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6v2p x_s6v2q] f1_s6v2p x_s6v2q;

Data.Semigroup.Internal.$fApplicativeDual_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6v2r a2_s6v2s] a2_s6v2s;

Data.Semigroup.Internal.$fApplicativeDual1
  :: forall b a.
     Data.Semigroup.Internal.Dual a
     -> b -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6v2t ds_s6v2u] x_s6v2t;

Data.Semigroup.Internal.$fApplicativeDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorDual
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeDual3
                                           Data.Semigroup.Internal.$fApplicativeDual2
                                           Data.Semigroup.Internal.$fApplicativeDual_$c*>
                                           Data.Semigroup.Internal.$fApplicativeDual1];

Data.Semigroup.Internal.$fSemigroupSum1
  :: forall a.
     GHC.Num.Num a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.Sum a -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><L,1*U(A,A,A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6v2v $dIntegral_s6v2w n_s6v2x ds_s6v2y]
        let {
          sat_s6v2A [Occ=Once] :: a_a6two
          [LclId] =
              [$dNum_s6v2v $dIntegral_s6v2w n_s6v2x] \u []
                  let {
                    sat_s6v2z [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [$dIntegral_s6v2w n_s6v2x] \u []
                            GHC.Real.toInteger $dIntegral_s6v2w n_s6v2x;
                  } in  GHC.Num.fromInteger $dNum_s6v2v sat_s6v2z;
        } in  GHC.Num.* $dNum_s6v2v sat_s6v2A ds_s6v2y;

Data.Semigroup.Internal.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Sum a
     -> [Data.Semigroup.Internal.Sum a] -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6v2B ww_s6v2C ww1_s6v2D]
        let {
          go_s6v2E [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Sum a_s6uL0
               -> [Data.Semigroup.Internal.Sum a_s6uL0]
               -> Data.Semigroup.Internal.Sum a_s6uL0
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6v2B go_s6v2E] \r [b_s6v2F ds1_s6v2G]
                  case ds1_s6v2G of {
                    [] -> b_s6v2F;
                    : c_s6v2I [Occ=Once] cs_s6v2J [Occ=Once] ->
                        let {
                          sat_s6v2K [Occ=Once] :: a_s6uL0
                          [LclId] =
                              [go_s6v2E c_s6v2I cs_s6v2J] \u [] go_s6v2E c_s6v2I cs_s6v2J;
                        } in  GHC.Num.+ w_s6v2B b_s6v2F sat_s6v2K;
                  };
        } in  go_s6v2E ww_s6v2C ww1_s6v2D;

Data.Semigroup.Internal.$fSemigroupSum_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Sum a)
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A,A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6v2L w1_s6v2M]
        case w1_s6v2M of {
          GHC.Base.:| ww1_s6v2O [Occ=Once] ww2_s6v2P [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat3 w_s6v2L ww1_s6v2O ww2_s6v2P;
        };

Data.Semigroup.Internal.$fSemigroupSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U,A,C(C1(U)),A,A,A,C(U))>m] =
    [] \r [$dNum_s6v2Q]
        let {
          sat_s6v2T [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6v2Q] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fSemigroupSum1
                      $dNum_s6v2Q eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6v2S [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Sum a_X6tDl)
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6v2Q] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupSum_$csconcat
                      $dNum_s6v2Q eta_B1; } in
        let {
          sat_s6v2R [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6v2Q] \u [] GHC.Num.+ $dNum_s6v2Q;
        } in  GHC.Base.C:Semigroup [sat_s6v2R sat_s6v2S sat_s6v2T];

Data.Semigroup.Internal.$fMonoidSum1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Semigroup.Internal.$fMonoidSum2
  :: forall a. GHC.Num.Num a => a
[GblId,
 Arity=1,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6v2U]
        GHC.Num.fromInteger
            $dNum_s6v2U Data.Semigroup.Internal.$fMonoidSum1;

Data.Semigroup.Internal.$fMonoidSum_$cmconcat
  :: forall a.
     GHC.Num.Num a =>
     [Data.Semigroup.Internal.Sum a] -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6v2V]
        let {
          z_s6v2W [Occ=OnceL] :: a_X6tD4
          [LclId] =
              [$dNum_s6v2V] \u []
                  GHC.Num.fromInteger
                      $dNum_s6v2V Data.Semigroup.Internal.$fMonoidSum1; } in
        let {
          go_s6v2X [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Sum a_X6tD4]
               -> Data.Semigroup.Internal.Sum a_X6tD4
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dNum_s6v2V z_s6v2W go_s6v2X] \r [ds_s6v2Y]
                  case ds_s6v2Y of {
                    [] -> z_s6v2W;
                    : y_s6v30 [Occ=Once] ys_s6v31 [Occ=Once] ->
                        let {
                          sat_s6v32 [Occ=Once] :: a_X6tD4
                          [LclId] =
                              [go_s6v2X ys_s6v31] \u [] go_s6v2X ys_s6v31;
                        } in  GHC.Num.+ $dNum_s6v2V y_s6v30 sat_s6v32;
                  };
        } in  go_s6v2X;

Data.Semigroup.Internal.$fMonoidSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(U,A,C(C1(U)),A,A,A,C(U))>m] =
    [] \r [$dNum_s6v33]
        let {
          sat_s6v37 [Occ=Once]
            :: [Data.Semigroup.Internal.Sum a_X6tD2]
               -> Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6v33] \u []
                  Data.Semigroup.Internal.$fMonoidSum_$cmconcat $dNum_s6v33; } in
        let {
          sat_s6v36 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_X6tD2
               -> Data.Semigroup.Internal.Sum a_X6tD2
               -> Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6v33] \u [] GHC.Num.+ $dNum_s6v33; } in
        let {
          sat_s6v35 [Occ=Once] :: Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6v33] \u []
                  Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6v33; } in
        let {
          sat_s6v34 [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Sum a_X6tD2)
          [LclId] =
              [$dNum_s6v33] \u []
                  Data.Semigroup.Internal.$fSemigroupSum $dNum_s6v33;
        } in  GHC.Base.C:Monoid [sat_s6v34 sat_s6v35 sat_s6v36 sat_s6v37];

Data.Semigroup.Internal.$fFunctorSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeSum3
  :: forall a b.
     Data.Semigroup.Internal.Sum (a -> b)
     -> Data.Semigroup.Internal.Sum (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6v38] v_s6v38;

Data.Semigroup.Internal.$fApplicativeSum2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Sum a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6v39 x_s6v3a] f1_s6v39 x_s6v3a;

Data.Semigroup.Internal.$fApplicativeSum_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6v3b a2_s6v3c] a2_s6v3c;

Data.Semigroup.Internal.$fApplicativeSum1
  :: forall b a.
     Data.Semigroup.Internal.Sum a -> b -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6v3d ds_s6v3e] x_s6v3d;

Data.Semigroup.Internal.$fApplicativeSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorSum
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeSum3
                                           Data.Semigroup.Internal.$fApplicativeSum2
                                           Data.Semigroup.Internal.$fApplicativeSum_$c*>
                                           Data.Semigroup.Internal.$fApplicativeSum1];

Data.Semigroup.Internal.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Product a
     -> [Data.Semigroup.Internal.Product a]
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6v3f ww_s6v3g ww1_s6v3h]
        let {
          go_s6v3i [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Product a_s6uLe
               -> [Data.Semigroup.Internal.Product a_s6uLe]
               -> Data.Semigroup.Internal.Product a_s6uLe
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6v3f go_s6v3i] \r [b_s6v3j ds1_s6v3k]
                  case ds1_s6v3k of {
                    [] -> b_s6v3j;
                    : c_s6v3m [Occ=Once] cs_s6v3n [Occ=Once] ->
                        let {
                          sat_s6v3o [Occ=Once] :: a_s6uLe
                          [LclId] =
                              [go_s6v3i c_s6v3m cs_s6v3n] \u [] go_s6v3i c_s6v3m cs_s6v3n;
                        } in  GHC.Num.* w_s6v3f b_s6v3j sat_s6v3o;
                  };
        } in  go_s6v3i ww_s6v3g ww1_s6v3h;

Data.Semigroup.Internal.$fSemigroupProduct_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Product a)
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6v3p w1_s6v3q]
        case w1_s6v3q of {
          GHC.Base.:| ww1_s6v3s [Occ=Once] ww2_s6v3t [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat2 w_s6v3p ww1_s6v3s ww2_s6v3t;
        };

Data.Semigroup.Internal.$fSemigroupProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A,A,A,C(U))>m] =
    [] \r [$dNum_s6v3u]
        let {
          sat_s6v3A [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6v3u] \r [$dIntegral_s6v3x n_s6v3y ds_s6v3z]
                  GHC.Real.^ $dNum_s6v3u $dIntegral_s6v3x ds_s6v3z n_s6v3y; } in
        let {
          sat_s6v3w [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Product a_X6tB3)
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6v3u] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupProduct_$csconcat
                      $dNum_s6v3u eta_B1; } in
        let {
          sat_s6v3v [Occ=Once]
            :: Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6v3u] \u [] GHC.Num.* $dNum_s6v3u;
        } in  GHC.Base.C:Semigroup [sat_s6v3v sat_s6v3w sat_s6v3A];

sat_s6v3B :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s6v3C :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6v3B GHC.Types.[]];

Data.Semigroup.Internal.$fMonoidProduct1
  :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6v3C;

Data.Semigroup.Internal.$fMonoidProduct2
  :: forall a. GHC.Num.Num a => a
[GblId,
 Arity=1,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6v3D]
        GHC.Num.fromInteger
            $dNum_s6v3D Data.Semigroup.Internal.$fMonoidProduct1;

Data.Semigroup.Internal.$fMonoidProduct_$cmconcat
  :: forall a.
     GHC.Num.Num a =>
     [Data.Semigroup.Internal.Product a]
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6v3E]
        let {
          z_s6v3F [Occ=OnceL] :: a_X6tAM
          [LclId] =
              [$dNum_s6v3E] \u []
                  GHC.Num.fromInteger
                      $dNum_s6v3E Data.Semigroup.Internal.$fMonoidProduct1; } in
        let {
          go_s6v3G [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Product a_X6tAM]
               -> Data.Semigroup.Internal.Product a_X6tAM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dNum_s6v3E z_s6v3F go_s6v3G] \r [ds_s6v3H]
                  case ds_s6v3H of {
                    [] -> z_s6v3F;
                    : y_s6v3J [Occ=Once] ys_s6v3K [Occ=Once] ->
                        let {
                          sat_s6v3L [Occ=Once] :: a_X6tAM
                          [LclId] =
                              [go_s6v3G ys_s6v3K] \u [] go_s6v3G ys_s6v3K;
                        } in  GHC.Num.* $dNum_s6v3E y_s6v3J sat_s6v3L;
                  };
        } in  go_s6v3G;

Data.Semigroup.Internal.$fMonoidProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A,A,A,C(U))>m] =
    [] \r [$dNum_s6v3M]
        let {
          sat_s6v3Q [Occ=Once]
            :: [Data.Semigroup.Internal.Product a_X6tAK]
               -> Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6v3M] \u []
                  Data.Semigroup.Internal.$fMonoidProduct_$cmconcat $dNum_s6v3M; } in
        let {
          sat_s6v3P [Occ=Once]
            :: Data.Semigroup.Internal.Product a_X6tAK
               -> Data.Semigroup.Internal.Product a_X6tAK
               -> Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6v3M] \u [] GHC.Num.* $dNum_s6v3M; } in
        let {
          sat_s6v3O [Occ=Once] :: Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6v3M] \u []
                  Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6v3M; } in
        let {
          sat_s6v3N [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Product a_X6tAK)
          [LclId] =
              [$dNum_s6v3M] \u []
                  Data.Semigroup.Internal.$fSemigroupProduct $dNum_s6v3M;
        } in  GHC.Base.C:Monoid [sat_s6v3N sat_s6v3O sat_s6v3P sat_s6v3Q];

Data.Semigroup.Internal.$fFunctorProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeProduct3
  :: forall a b.
     Data.Semigroup.Internal.Product (a -> b)
     -> Data.Semigroup.Internal.Product (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6v3R] v_s6v3R;

Data.Semigroup.Internal.$fApplicativeProduct2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Product a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6v3S x_s6v3T] f1_s6v3S x_s6v3T;

Data.Semigroup.Internal.$fApplicativeProduct_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6v3U a2_s6v3V] a2_s6v3V;

Data.Semigroup.Internal.$fApplicativeProduct1
  :: forall b a.
     Data.Semigroup.Internal.Product a
     -> b -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6v3W ds_s6v3X] x_s6v3W;

Data.Semigroup.Internal.$fApplicativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorProduct
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeProduct3
                                           Data.Semigroup.Internal.$fApplicativeProduct2
                                           Data.Semigroup.Internal.$fApplicativeProduct_$c*>
                                           Data.Semigroup.Internal.$fApplicativeProduct1];

Data.Semigroup.Internal.$fFunctorAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     GHC.Base.Functor (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dFunctor_s6v3Y]
        let {
          sat_s6v40 [Occ=Once]
            :: forall a b.
               a
               -> Data.Semigroup.Internal.Alt f_a6tow b
               -> Data.Semigroup.Internal.Alt f_a6tow a
          [LclId] =
              [$dFunctor_s6v3Y] \u [] GHC.Base.<$ $dFunctor_s6v3Y; } in
        let {
          sat_s6v3Z [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Semigroup.Internal.Alt f_a6tow a
               -> Data.Semigroup.Internal.Alt f_a6tow b
          [LclId] =
              [$dFunctor_s6v3Y] \u [] GHC.Base.fmap $dFunctor_s6v3Y;
        } in  GHC.Base.C:Functor [sat_s6v3Z sat_s6v40];

Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Functor (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s6v41]
        let {
          sat_s6v42 [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_a6tkt
          [LclId] =
              [$dApplicative_s6v41] \u []
                  GHC.Base.$p1Applicative $dApplicative_s6v41;
        } in  Data.Semigroup.Internal.$fFunctorAlt sat_s6v42;

Data.Semigroup.Internal.$fApplicativeAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dApplicative_s6v43]
        let {
          sat_s6v49 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt a
          [LclId] =
              [$dApplicative_s6v43] \u [] GHC.Base.<* $dApplicative_s6v43; } in
        let {
          sat_s6v48 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt b
          [LclId] =
              [$dApplicative_s6v43] \u [] GHC.Base.*> $dApplicative_s6v43; } in
        let {
          sat_s6v47 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt c
          [LclId] =
              [$dApplicative_s6v43] \u []
                  GHC.Base.liftA2 $dApplicative_s6v43; } in
        let {
          sat_s6v46 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt (a -> b)
               -> Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
          [LclId] =
              [$dApplicative_s6v43] \u [] GHC.Base.<*> $dApplicative_s6v43; } in
        let {
          sat_s6v45 [Occ=Once]
            :: forall a. a -> Data.Semigroup.Internal.Alt f_a6tkt a
          [LclId] =
              [$dApplicative_s6v43] \u [] GHC.Base.pure $dApplicative_s6v43; } in
        let {
          sat_s6v44 [Occ=Once]
            :: GHC.Base.Functor (Data.Semigroup.Internal.Alt f_a6tkt)
          [LclId] =
              [$dApplicative_s6v43] \u []
                  Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative
                      $dApplicative_s6v43;
        } in 
          GHC.Base.C:Applicative [sat_s6v44
                                  sat_s6v45
                                  sat_s6v46
                                  sat_s6v47
                                  sat_s6v48
                                  sat_s6v49];

Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6v4a]
        let {
          sat_s6v4b [Occ=Once, Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Applicative f_a6tn6
          [LclId] =
              [$dAlternative_s6v4a] \u []
                  GHC.Base.$p1Alternative $dAlternative_s6v4a;
        } in  Data.Semigroup.Internal.$fApplicativeAlt sat_s6v4b;

Data.Semigroup.Internal.$fAlternativeAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Alternative (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>m] =
    [] \r [$dAlternative_s6v4c]
        let {
          sat_s6v4h [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 [a]
          [LclId] =
              [$dAlternative_s6v4c] \u [] GHC.Base.many $dAlternative_s6v4c; } in
        let {
          sat_s6v4g [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 [a]
          [LclId] =
              [$dAlternative_s6v4c] \u [] GHC.Base.some $dAlternative_s6v4c; } in
        let {
          sat_s6v4f [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 a
          [LclId] =
              [$dAlternative_s6v4c] \u [] GHC.Base.<|> $dAlternative_s6v4c; } in
        let {
          sat_s6v4e [Occ=Once]
            :: forall a. Data.Semigroup.Internal.Alt f_a6tn6 a
          [LclId] =
              [$dAlternative_s6v4c] \u []
                  GHC.Base.empty $dAlternative_s6v4c; } in
        let {
          sat_s6v4d [Occ=Once]
            :: GHC.Base.Applicative (Data.Semigroup.Internal.Alt f_a6tn6)
          [LclId] =
              [$dAlternative_s6v4c] \u []
                  Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative
                      $dAlternative_s6v4c;
        } in 
          GHC.Base.C:Alternative [sat_s6v4d
                                  sat_s6v4e
                                  sat_s6v4f
                                  sat_s6v4g
                                  sat_s6v4h];

Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.Alternative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s6v4i]
        let {
          sat_s6v4j [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Alternative f_a6tjD
          [LclId] =
              [$dMonadPlus_s6v4i] \u [] GHC.Base.$p1MonadPlus $dMonadPlus_s6v4i;
        } in  Data.Semigroup.Internal.$fAlternativeAlt sat_s6v4j;

Data.Semigroup.Internal.$fMonadAlt_$cp1Monad
  :: forall (f :: * -> *).
     GHC.Base.Monad f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_s6v4k]
        let {
          sat_s6v4l [Occ=Once, Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Applicative f_a6thT
          [LclId] =
              [$dMonad_s6v4k] \u [] GHC.Base.$p1Monad $dMonad_s6v4k;
        } in  Data.Semigroup.Internal.$fApplicativeAlt sat_s6v4l;

Data.Semigroup.Internal.$fMonadAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Monad f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>m] =
    [] \r [$dMonad_s6v4m]
        let {
          sat_s6v4r [Occ=Once]
            :: forall a.
               GHC.Base.String -> Data.Semigroup.Internal.Alt f_a6thT a
          [LclId] =
              [$dMonad_s6v4m] \u [] GHC.Base.fail $dMonad_s6v4m; } in
        let {
          sat_s6v4q [Occ=Once]
            :: forall a. a -> Data.Semigroup.Internal.Alt f_a6thT a
          [LclId] =
              [$dMonad_s6v4m] \u [] GHC.Base.return $dMonad_s6v4m; } in
        let {
          sat_s6v4p [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6thT a
               -> Data.Semigroup.Internal.Alt f_a6thT b
               -> Data.Semigroup.Internal.Alt f_a6thT b
          [LclId] =
              [$dMonad_s6v4m] \u [] GHC.Base.>> $dMonad_s6v4m; } in
        let {
          sat_s6v4o [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6thT a
               -> (a -> Data.Semigroup.Internal.Alt f_a6thT b)
               -> Data.Semigroup.Internal.Alt f_a6thT b
          [LclId] =
              [$dMonad_s6v4m] \u [] GHC.Base.>>= $dMonad_s6v4m; } in
        let {
          sat_s6v4n [Occ=Once]
            :: GHC.Base.Applicative (Data.Semigroup.Internal.Alt f_a6thT)
          [LclId] =
              [$dMonad_s6v4m] \u []
                  Data.Semigroup.Internal.$fMonadAlt_$cp1Monad $dMonad_s6v4m;
        } in 
          GHC.Base.C:Monad [sat_s6v4n
                            sat_s6v4o
                            sat_s6v4p
                            sat_s6v4q
                            sat_s6v4r];

Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s6v4s]
        let {
          sat_s6v4t [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_a6tjD
          [LclId] =
              [$dMonadPlus_s6v4s] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_s6v4s;
        } in  Data.Semigroup.Internal.$fMonadAlt sat_s6v4t;

Data.Semigroup.Internal.$fMonadPlusAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.MonadPlus (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),1*U,1*U)>m] =
    [] \r [$dMonadPlus_s6v4u]
        let {
          sat_s6v4y [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tjD a
               -> Data.Semigroup.Internal.Alt f_a6tjD a
               -> Data.Semigroup.Internal.Alt f_a6tjD a
          [LclId] =
              [$dMonadPlus_s6v4u] \u [] GHC.Base.mplus $dMonadPlus_s6v4u; } in
        let {
          sat_s6v4x [Occ=Once]
            :: forall a. Data.Semigroup.Internal.Alt f_a6tjD a
          [LclId] =
              [$dMonadPlus_s6v4u] \u [] GHC.Base.mzero $dMonadPlus_s6v4u; } in
        let {
          sat_s6v4w [Occ=Once]
            :: GHC.Base.Monad (Data.Semigroup.Internal.Alt f_a6tjD)
          [LclId] =
              [$dMonadPlus_s6v4u] \u []
                  Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus
                      $dMonadPlus_s6v4u; } in
        let {
          sat_s6v4v [Occ=Once]
            :: GHC.Base.Alternative (Data.Semigroup.Internal.Alt f_a6tjD)
          [LclId] =
              [$dMonadPlus_s6v4u] \u []
                  Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus
                      $dMonadPlus_s6v4u;
        } in 
          GHC.Base.C:MonadPlus [sat_s6v4v sat_s6v4w sat_s6v4x sat_s6v4y];

Data.Semigroup.Internal.$fEnumAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Enum.Enum (f a) =>
     GHC.Enum.Enum (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dEnum_s6v4z]
        let {
          sat_s6v4H [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.enumFromThenTo $dEnum_s6v4z; } in
        let {
          sat_s6v4G [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.enumFromTo $dEnum_s6v4z; } in
        let {
          sat_s6v4F [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.enumFromThen $dEnum_s6v4z; } in
        let {
          sat_s6v4E [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.enumFrom $dEnum_s6v4z; } in
        let {
          sat_s6v4D [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm -> GHC.Types.Int
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.fromEnum $dEnum_s6v4z; } in
        let {
          sat_s6v4C [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.toEnum $dEnum_s6v4z; } in
        let {
          sat_s6v4B [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.pred $dEnum_s6v4z; } in
        let {
          sat_s6v4A [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6v4z] \u [] GHC.Enum.succ $dEnum_s6v4z;
        } in 
          GHC.Enum.C:Enum [sat_s6v4A
                           sat_s6v4B
                           sat_s6v4C
                           sat_s6v4D
                           sat_s6v4E
                           sat_s6v4F
                           sat_s6v4G
                           sat_s6v4H];

Data.Semigroup.Internal.$fNumAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Num.Num (f a) =>
     GHC.Num.Num (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6v4I]
        let {
          sat_s6v4P [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.fromInteger $dNum_s6v4I; } in
        let {
          sat_s6v4O [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.signum $dNum_s6v4I; } in
        let {
          sat_s6v4N [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.abs $dNum_s6v4I; } in
        let {
          sat_s6v4M [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.negate $dNum_s6v4I; } in
        let {
          sat_s6v4L [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.* $dNum_s6v4I; } in
        let {
          sat_s6v4K [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.- $dNum_s6v4I; } in
        let {
          sat_s6v4J [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6v4I] \u [] GHC.Num.+ $dNum_s6v4I;
        } in 
          GHC.Num.C:Num [sat_s6v4J
                         sat_s6v4K
                         sat_s6v4L
                         sat_s6v4M
                         sat_s6v4N
                         sat_s6v4O
                         sat_s6v4P];

Data.Semigroup.Internal.$fEqAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Eq (f a) =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6v4Q]
        let {
          sat_s6v4S [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6txq a_X6txt
               -> Data.Semigroup.Internal.Alt f_X6txq a_X6txt -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v4Q] \u [] GHC.Classes./= $dEq_s6v4Q; } in
        let {
          sat_s6v4R [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6txq a_X6txt
               -> Data.Semigroup.Internal.Alt f_X6txq a_X6txt -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v4Q] \u [] GHC.Classes.== $dEq_s6v4Q;
        } in  GHC.Classes.C:Eq [sat_s6v4R sat_s6v4S];

Data.Semigroup.Internal.$fOrdAlt_$cp1Ord
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Ord (f a) =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Alt f a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6v4T]
        let {
          sat_s6v4U [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Classes.Eq (f_X6tn1 a_X6tn3)
          [LclId] =
              [$dOrd_s6v4T] \u [] GHC.Classes.$p1Ord $dOrd_s6v4T;
        } in  Data.Semigroup.Internal.$fEqAlt sat_s6v4U;

Data.Semigroup.Internal.$fOrdAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Ord (f a) =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6v4V]
        let {
          sat_s6v53 [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.min $dOrd_s6v4V; } in
        let {
          sat_s6v52 [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.max $dOrd_s6v4V; } in
        let {
          sat_s6v51 [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.>= $dOrd_s6v4V; } in
        let {
          sat_s6v50 [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.> $dOrd_s6v4V; } in
        let {
          sat_s6v4Z [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.<= $dOrd_s6v4V; } in
        let {
          sat_s6v4Y [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.< $dOrd_s6v4V; } in
        let {
          sat_s6v4X [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6v4V] \u [] GHC.Classes.compare $dOrd_s6v4V; } in
        let {
          sat_s6v4W [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4)
          [LclId] =
              [$dOrd_s6v4V] \u []
                  Data.Semigroup.Internal.$fOrdAlt_$cp1Ord $dOrd_s6v4V;
        } in 
          GHC.Classes.C:Ord [sat_s6v4W
                             sat_s6v4X
                             sat_s6v4Y
                             sat_s6v4Z
                             sat_s6v50
                             sat_s6v51
                             sat_s6v52
                             sat_s6v53];

Data.Semigroup.Internal.$fShowAlt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Semigroup.Internal.$fShowAlt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alt {"#;

Data.Semigroup.Internal.$fShowAlt2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAlt = "#;

Data.Semigroup.Internal.$fReadAll5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Semigroup.Internal.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Alt f a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v54 ww_s6v55 w1_s6v56]
        let {
          f1_s6v57 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6v54 w1_s6v56] \u []
                  GHC.Show.showsPrec
                      w_s6v54 Data.Semigroup.Internal.$fShowAlt1 w1_s6v56;
        } in 
          case >=# [ww_s6v55 11#] of {
            __DEFAULT ->
                let {
                  sat_s6v5d [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f1_s6v57] \r [x_s6v59]
                          let {
                            sat_s6v5c [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_s6v57 x_s6v59] \u []
                                    let {
                                      sat_s6v5b [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_s6v57 x_s6v59] \u []
                                              let {
                                                sat_s6v5a [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6v59] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6v59;
                                              } in  f1_s6v57 sat_s6v5a;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowAlt2 sat_s6v5b;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowAlt3 sat_s6v5c;
                } in  sat_s6v5d;
            1# ->
                let {
                  sat_s6v5k [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f1_s6v57] \r [x_s6v5e]
                          let {
                            sat_s6v5j [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_s6v57 x_s6v5e] \u []
                                    let {
                                      sat_s6v5i [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_s6v57 x_s6v5e] \u []
                                              let {
                                                sat_s6v5h [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f1_s6v57 x_s6v5e] \u []
                                                        let {
                                                          sat_s6v5g [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6v5e] \u []
                                                                  let {
                                                                    sat_s6v5f [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6v5e];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6v5f;
                                                        } in  f1_s6v57 sat_s6v5g;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowAlt2 sat_s6v5h;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowAlt3 sat_s6v5i;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6v5j];
                } in  sat_s6v5k;
          };

Data.Semigroup.Internal.$fShowAlt_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Types.Int -> Data.Semigroup.Internal.Alt f a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v5l w1_s6v5m w2_s6v5n]
        case w1_s6v5m of {
          GHC.Types.I# ww1_s6v5p [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec1 w_s6v5l ww1_s6v5p w2_s6v5n;
        };

Data.Semigroup.Internal.$fReadAll4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll5;

Data.Semigroup.Internal.$fShowAlt_$cshow
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     Data.Semigroup.Internal.Alt f a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v5q x_s6v5r]
        let {
          sat_s6v5t [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6v5q x_s6v5r] \u []
                  let {
                    sat_s6v5s [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6v5q x_s6v5r] \u []
                            GHC.Show.showsPrec
                                $dShow_s6v5q
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6v5r
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAlt2 sat_s6v5s;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowAlt3 sat_s6v5t;

Data.Semigroup.Internal.$fShowAlt_$cshowList
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     [Data.Semigroup.Internal.Alt f a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v5u ls_s6v5v s_s6v5w]
        let {
          sat_s6v5y [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v5u] \r [w_s6v5x]
                  Data.Semigroup.Internal.$w$cshowsPrec1 $dShow_s6v5u 0# w_s6v5x;
        } in  GHC.Show.showList__ sat_s6v5y ls_s6v5v s_s6v5w;

Data.Semigroup.Internal.$fShowAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Show.Show (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6v5z]
        let {
          sat_s6v5C [Occ=Once]
            :: [Data.Semigroup.Internal.Alt f_a6taL a_a6taM] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v5z] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshowList
                      $dShow_s6v5z eta_B2 eta_B1; } in
        let {
          sat_s6v5B [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Base.String
          [LclId] =
              [$dShow_s6v5z] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshow $dShow_s6v5z eta_B1; } in
        let {
          sat_s6v5A [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v5z] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshowsPrec
                      $dShow_s6v5z eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6v5A sat_s6v5B sat_s6v5C];

Data.Semigroup.Internal.$fReadAlt5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alt"#;

Data.Semigroup.Internal.$fReadAlt4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAlt5;

Data.Semigroup.Internal.$fReadAlt_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAlt4];

Data.Semigroup.Internal.$fReadAll11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Semigroup.Internal.$fReadAll10 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll11;

Data.Semigroup.Internal.$fReadAll_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.Internal.$fReadAll10];

Data.Semigroup.Internal.$fReadAlt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAlt"#;

Data.Semigroup.Internal.$fReadAlt2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAlt3;

Data.Semigroup.Internal.$fReadAll6 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Semigroup.Internal.$fReadAll3 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.Internal.$fReadAll4];

Data.Semigroup.Internal.$fReadAlt1
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Alt f a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v5D]
        let {
          lvl12_s6v5E [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP (f_a6t9S a_a6t9T)
          [LclId] =
              [$dRead_s6v5D] \u []
                  GHC.Read.readPrec
                      $dRead_s6v5D Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6v5F [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP (f_a6t9S a_a6t9T)
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6v5E] \r [ds1_s6v5G] lvl12_s6v5E; } in
        let {
          sat_s6v60 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_a6t9S a_a6t9T)
          [LclId] =
              [ds_s6v5F] \r [c_s6v5H eta_s6v5I]
                  case c_s6v5H of {
                    GHC.Types.I# x_s6v5K [Occ=Once] ->
                        case <=# [x_s6v5K 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6v5X [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6v5F eta_s6v5I] \r [a1_s6v5M]
                                        let {
                                          sat_s6v5U [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6v5F eta_s6v5I] \r [a2_s6v5N]
                                                  let {
                                                    sat_s6v5T [Occ=Once]
                                                      :: f_a6t9S a_a6t9T
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6v5I] \r [a3_s6v5O]
                                                            let {
                                                              sat_s6v5Q [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6v5I a3_s6v5O] \r [a4_s6v5P]
                                                                      eta_s6v5I a3_s6v5O;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6v5Q
                                                              of
                                                              { Unit# ww1_s6v5S [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6v5S];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadAlt2
                                                        ds_s6v5F
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6v5T;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6v5U
                                          of
                                          { Unit# ww1_s6v5W [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6v5W];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadAlt_lexeme sat_s6v5X
                                of
                                { Unit# ww1_s6v5Z [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6v5Z];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6v60;

Data.Semigroup.Internal.$fReadAlt_$creadsPrec
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Alt f a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v61]
        let {
          ds_s6v62 [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6v61] \u []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6v61; } in
        let {
          sat_s6v65 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle)
          [LclId] =
              [ds_s6v62] \r [n_s6v63]
                  let {
                    sat_s6v64 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle)
                    [LclId] =
                        [ds_s6v62 n_s6v63] \u []
                            ds_s6v62
                                n_s6v63 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6v64;
        } in  sat_s6v65;

Data.Semigroup.Internal.$fReadAlt_$creadListPrec
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Alt f a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v66]
        let {
          sat_s6v67 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_X6tla a_X6tlc)
          [LclId] =
              [$dRead_s6v66] \s []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6v66;
        } in  GHC.Read.list sat_s6v67;

Data.Semigroup.Internal.$fReadAlt_$creadList
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Semigroup.Internal.Alt f a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v68]
        let {
          sat_s6v6a [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Alt f_X6tlb a_X6tld]
          [LclId] =
              [$dRead_s6v68] \u []
                  let {
                    sat_s6v69 [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Alt f_X6tlb a_X6tld)
                    [LclId] =
                        [$dRead_s6v68] \s []
                            Data.Semigroup.Internal.$fReadAlt1 $dRead_s6v68;
                  } in 
                    GHC.Read.list
                        sat_s6v69
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6v6a;

Data.Semigroup.Internal.$fReadAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     GHC.Read.Read (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6v6b]
        let {
          sat_s6v6f [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb]
          [LclId] =
              [$dRead_s6v6b] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadListPrec $dRead_s6v6b; } in
        let {
          sat_s6v6e [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb)
          [LclId] =
              [$dRead_s6v6b] \u []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6v6b; } in
        let {
          sat_s6v6d [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb]
          [LclId] =
              [$dRead_s6v6b] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadList $dRead_s6v6b; } in
        let {
          sat_s6v6c [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb)
          [LclId] =
              [$dRead_s6v6b] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadsPrec $dRead_s6v6b;
        } in  GHC.Read.C:Read [sat_s6v6c sat_s6v6d sat_s6v6e sat_s6v6f];

Data.Semigroup.Internal.$fGeneric1Alt1
  :: forall k (f :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Semigroup.Internal.Alt f) a
     -> GHC.Generics.Rep1 (Data.Semigroup.Internal.Alt f) a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v6g] ds_s6v6g;

Data.Semigroup.Internal.$fGeneric1Alt2
  :: forall k (f :: k -> *) (a :: k).
     Data.Semigroup.Internal.Alt f a -> Data.Semigroup.Internal.Alt f a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6v6h] x_s6v6h;

Data.Semigroup.Internal.$fGeneric1Alt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *).
     GHC.Generics.Generic1 (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Alt2
                                            Data.Semigroup.Internal.$fGeneric1Alt1];

Data.Semigroup.Internal.$fGenericAlt1
  :: forall k (f :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Alt f a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Alt f a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v6i] ds_s6v6i;

Data.Semigroup.Internal.$fGenericAlt2
  :: forall k (f :: k -> *) (a :: k) x.
     Data.Semigroup.Internal.Alt f a -> Data.Semigroup.Internal.Alt f a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6v6j] x1_s6v6j;

Data.Semigroup.Internal.$fGenericAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAlt2
                                           Data.Semigroup.Internal.$fGenericAlt1];

Data.Semigroup.Internal.$fNumProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Semigroup.Internal.Product a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6v6k]
        let {
          sat_s6v6r [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.fromInteger $dNum_s6v6k; } in
        let {
          sat_s6v6q [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.signum $dNum_s6v6k; } in
        let {
          sat_s6v6p [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.abs $dNum_s6v6k; } in
        let {
          sat_s6v6o [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.negate $dNum_s6v6k; } in
        let {
          sat_s6v6n [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.* $dNum_s6v6k; } in
        let {
          sat_s6v6m [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.- $dNum_s6v6k; } in
        let {
          sat_s6v6l [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6v6k] \u [] GHC.Num.+ $dNum_s6v6k;
        } in 
          GHC.Num.C:Num [sat_s6v6l
                         sat_s6v6m
                         sat_s6v6n
                         sat_s6v6o
                         sat_s6v6p
                         sat_s6v6q
                         sat_s6v6r];

Data.Semigroup.Internal.$fGeneric1Product1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Product a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v6s] ds_s6v6s;

Data.Semigroup.Internal.$fGeneric1Product2
  :: forall a.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6v6t] x_s6v6t;

Data.Semigroup.Internal.$fGeneric1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Product
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Product2
                                            Data.Semigroup.Internal.$fGeneric1Product1];

Data.Semigroup.Internal.$fGenericProduct1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Product a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Product a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v6u] ds_s6v6u;

Data.Semigroup.Internal.$fGenericProduct2
  :: forall a x.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6v6v] x1_s6v6v;

Data.Semigroup.Internal.$fGenericProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Generics.Generic (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericProduct2
                                           Data.Semigroup.Internal.$fGenericProduct1];

Data.Semigroup.Internal.$fBoundedProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6v6w]
        let {
          sat_s6v6y [Occ=Once] :: Data.Semigroup.Internal.Product a_a6t49
          [LclId] =
              [$dBounded_s6v6w] \u [] GHC.Enum.maxBound $dBounded_s6v6w; } in
        let {
          sat_s6v6x [Occ=Once] :: Data.Semigroup.Internal.Product a_a6t49
          [LclId] =
              [$dBounded_s6v6w] \u [] GHC.Enum.minBound $dBounded_s6v6w;
        } in  GHC.Enum.C:Bounded [sat_s6v6x sat_s6v6y];

Data.Semigroup.Internal.$fShowProduct2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product {"#;

Data.Semigroup.Internal.$fShowProduct1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getProduct = "#;

Data.Semigroup.Internal.$w$cshowsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int#
     -> Data.Semigroup.Internal.Product a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v6z ww_s6v6A w1_s6v6B]
        let {
          f_s6v6C [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6v6z w1_s6v6B] \u []
                  GHC.Show.showsPrec
                      w_s6v6z Data.Semigroup.Internal.$fShowAlt1 w1_s6v6B;
        } in 
          case >=# [ww_s6v6A 11#] of {
            __DEFAULT ->
                let {
                  sat_s6v6I [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6v6C] \r [x_s6v6E]
                          let {
                            sat_s6v6H [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6v6C x_s6v6E] \u []
                                    let {
                                      sat_s6v6G [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6v6C x_s6v6E] \u []
                                              let {
                                                sat_s6v6F [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6v6E] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6v6E;
                                              } in  f_s6v6C sat_s6v6F;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowProduct1 sat_s6v6G;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowProduct2 sat_s6v6H;
                } in  sat_s6v6I;
            1# ->
                let {
                  sat_s6v6P [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6v6C] \r [x_s6v6J]
                          let {
                            sat_s6v6O [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6v6C x_s6v6J] \u []
                                    let {
                                      sat_s6v6N [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6v6C x_s6v6J] \u []
                                              let {
                                                sat_s6v6M [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6v6C x_s6v6J] \u []
                                                        let {
                                                          sat_s6v6L [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6v6J] \u []
                                                                  let {
                                                                    sat_s6v6K [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6v6J];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6v6K;
                                                        } in  f_s6v6C sat_s6v6L;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowProduct1
                                                    sat_s6v6M;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowProduct2 sat_s6v6N;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6v6O];
                } in  sat_s6v6P;
          };

Data.Semigroup.Internal.$fShowProduct_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int
     -> Data.Semigroup.Internal.Product a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v6Q w1_s6v6R w2_s6v6S]
        case w1_s6v6R of {
          GHC.Types.I# ww1_s6v6U [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec4 w_s6v6Q ww1_s6v6U w2_s6v6S;
        };

Data.Semigroup.Internal.$fShowProduct_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Product a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v6V x_s6v6W]
        let {
          sat_s6v6Y [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6v6V x_s6v6W] \u []
                  let {
                    sat_s6v6X [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6v6V x_s6v6W] \u []
                            GHC.Show.showsPrec
                                $dShow_s6v6V
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6v6W
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowProduct1 sat_s6v6X;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowProduct2 sat_s6v6Y;

Data.Semigroup.Internal.$fShowProduct_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Product a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v6Z ls_s6v70 s_s6v71]
        let {
          sat_s6v73 [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t3E -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v6Z] \r [w_s6v72]
                  Data.Semigroup.Internal.$w$cshowsPrec4 $dShow_s6v6Z 0# w_s6v72;
        } in  GHC.Show.showList__ sat_s6v73 ls_s6v70 s_s6v71;

Data.Semigroup.Internal.$fShowProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6v74]
        let {
          sat_s6v77 [Occ=Once]
            :: [Data.Semigroup.Internal.Product a_a6t3E] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v74] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshowList
                      $dShow_s6v74 eta_B2 eta_B1; } in
        let {
          sat_s6v76 [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t3E -> GHC.Base.String
          [LclId] =
              [$dShow_s6v74] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshow
                      $dShow_s6v74 eta_B1; } in
        let {
          sat_s6v75 [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Product a_a6t3E -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v74] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshowsPrec
                      $dShow_s6v74 eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6v75 sat_s6v76 sat_s6v77];

Data.Semigroup.Internal.$fReadProduct5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product"#;

Data.Semigroup.Internal.$fReadProduct4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadProduct5;

Data.Semigroup.Internal.$fReadProduct_lexeme
  :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadProduct4];

Data.Semigroup.Internal.$fReadProduct3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getProduct"#;

Data.Semigroup.Internal.$fReadProduct2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadProduct3;

Data.Semigroup.Internal.$fReadProduct1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Product a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v78]
        let {
          lvl12_s6v79 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6t2P
          [LclId] =
              [$dRead_s6v78] \u []
                  GHC.Read.readPrec
                      $dRead_s6v78 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6v7a [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6t2P
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6v79] \r [ds1_s6v7b] lvl12_s6v79; } in
        let {
          sat_s6v7v [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_a6t2P)
          [LclId] =
              [ds_s6v7a] \r [c_s6v7c eta_s6v7d]
                  case c_s6v7c of {
                    GHC.Types.I# x_s6v7f [Occ=Once] ->
                        case <=# [x_s6v7f 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6v7s [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6v7a eta_s6v7d] \r [a1_s6v7h]
                                        let {
                                          sat_s6v7p [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6v7a eta_s6v7d] \r [a2_s6v7i]
                                                  let {
                                                    sat_s6v7o [Occ=Once]
                                                      :: a_a6t2P
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6v7d] \r [a3_s6v7j]
                                                            let {
                                                              sat_s6v7l [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6v7d a3_s6v7j] \r [a4_s6v7k]
                                                                      eta_s6v7d a3_s6v7j;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6v7l
                                                              of
                                                              { Unit# ww1_s6v7n [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6v7n];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadProduct2
                                                        ds_s6v7a
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6v7o;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6v7p
                                          of
                                          { Unit# ww1_s6v7r [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6v7r];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadProduct_lexeme sat_s6v7s
                                of
                                { Unit# ww1_s6v7u [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6v7u];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6v7v;

Data.Semigroup.Internal.$fReadProduct_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Product a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v7w]
        let {
          ds_s6v7x [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Product a_X6tfh
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6v7w] \u []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6v7w; } in
        let {
          sat_s6v7A [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Product a_X6tfh)
          [LclId] =
              [ds_s6v7x] \r [n_s6v7y]
                  let {
                    sat_s6v7z [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Product a_X6tfh)
                    [LclId] =
                        [ds_s6v7x n_s6v7y] \u []
                            ds_s6v7x
                                n_s6v7y Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6v7z;
        } in  sat_s6v7A;

Data.Semigroup.Internal.$fReadProduct_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Product a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v7B]
        let {
          sat_s6v7C [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_X6tff)
          [LclId] =
              [$dRead_s6v7B] \s []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6v7B;
        } in  GHC.Read.list sat_s6v7C;

Data.Semigroup.Internal.$fReadProduct_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Semigroup.Internal.Product a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v7D]
        let {
          sat_s6v7F [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Product a_X6tfg]
          [LclId] =
              [$dRead_s6v7D] \u []
                  let {
                    sat_s6v7E [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Product a_X6tfg)
                    [LclId] =
                        [$dRead_s6v7D] \s []
                            Data.Semigroup.Internal.$fReadProduct1 $dRead_s6v7D;
                  } in 
                    GHC.Read.list
                        sat_s6v7E
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6v7F;

Data.Semigroup.Internal.$fReadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6v7G]
        let {
          sat_s6v7K [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Product a_X6tfe]
          [LclId] =
              [$dRead_s6v7G] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadListPrec
                      $dRead_s6v7G; } in
        let {
          sat_s6v7J [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_X6tfe)
          [LclId] =
              [$dRead_s6v7G] \u []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6v7G; } in
        let {
          sat_s6v7I [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Product a_X6tfe]
          [LclId] =
              [$dRead_s6v7G] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadList $dRead_s6v7G; } in
        let {
          sat_s6v7H [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Product a_X6tfe)
          [LclId] =
              [$dRead_s6v7G] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadsPrec $dRead_s6v7G;
        } in  GHC.Read.C:Read [sat_s6v7H sat_s6v7I sat_s6v7J sat_s6v7K];

Data.Semigroup.Internal.$fEqProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6v7L]
        let {
          sat_s6v7N [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t0s
               -> Data.Semigroup.Internal.Product a_a6t0s -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v7L] \u [] GHC.Classes./= $dEq_s6v7L; } in
        let {
          sat_s6v7M [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t0s
               -> Data.Semigroup.Internal.Product a_a6t0s -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v7L] \u [] GHC.Classes.== $dEq_s6v7L;
        } in  GHC.Classes.C:Eq [sat_s6v7M sat_s6v7N];

Data.Semigroup.Internal.$fOrdProduct_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6v7O]
        let {
          sat_s6v7P [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6t10
          [LclId] =
              [$dOrd_s6v7O] \u [] GHC.Classes.$p1Ord $dOrd_s6v7O;
        } in  Data.Semigroup.Internal.$fEqProduct sat_s6v7P;

Data.Semigroup.Internal.$fOrdProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Product a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6v7Q]
        let {
          sat_s6v7Y [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.min $dOrd_s6v7Q; } in
        let {
          sat_s6v7X [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.max $dOrd_s6v7Q; } in
        let {
          sat_s6v7W [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.>= $dOrd_s6v7Q; } in
        let {
          sat_s6v7V [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.> $dOrd_s6v7Q; } in
        let {
          sat_s6v7U [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.<= $dOrd_s6v7Q; } in
        let {
          sat_s6v7T [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.< $dOrd_s6v7Q; } in
        let {
          sat_s6v7S [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6v7Q] \u [] GHC.Classes.compare $dOrd_s6v7Q; } in
        let {
          sat_s6v7R [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Product a_a6t10)
          [LclId] =
              [$dOrd_s6v7Q] \u []
                  Data.Semigroup.Internal.$fOrdProduct_$cp1Ord $dOrd_s6v7Q;
        } in 
          GHC.Classes.C:Ord [sat_s6v7R
                             sat_s6v7S
                             sat_s6v7T
                             sat_s6v7U
                             sat_s6v7V
                             sat_s6v7W
                             sat_s6v7X
                             sat_s6v7Y];

Data.Semigroup.Internal.$fNumSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6v7Z]
        let {
          sat_s6v86 [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.fromInteger $dNum_s6v7Z; } in
        let {
          sat_s6v85 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.signum $dNum_s6v7Z; } in
        let {
          sat_s6v84 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.abs $dNum_s6v7Z; } in
        let {
          sat_s6v83 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.negate $dNum_s6v7Z; } in
        let {
          sat_s6v82 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.* $dNum_s6v7Z; } in
        let {
          sat_s6v81 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.- $dNum_s6v7Z; } in
        let {
          sat_s6v80 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6v7Z] \u [] GHC.Num.+ $dNum_s6v7Z;
        } in 
          GHC.Num.C:Num [sat_s6v80
                         sat_s6v81
                         sat_s6v82
                         sat_s6v83
                         sat_s6v84
                         sat_s6v85
                         sat_s6v86];

Data.Semigroup.Internal.$fGeneric1Sum1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Sum a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v87] ds_s6v87;

Data.Semigroup.Internal.$fGeneric1Sum2
  :: forall a.
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6v88] x_s6v88;

Data.Semigroup.Internal.$fGeneric1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Sum
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Sum2
                                            Data.Semigroup.Internal.$fGeneric1Sum1];

Data.Semigroup.Internal.$fGenericSum1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Sum a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Sum a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v89] ds_s6v89;

Data.Semigroup.Internal.$fGenericSum2
  :: forall a x.
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6v8a] x1_s6v8a;

Data.Semigroup.Internal.$fGenericSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericSum2
                                           Data.Semigroup.Internal.$fGenericSum1];

Data.Semigroup.Internal.$fBoundedSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6v8b]
        let {
          sat_s6v8d [Occ=Once] :: Data.Semigroup.Internal.Sum a_a6sWQ
          [LclId] =
              [$dBounded_s6v8b] \u [] GHC.Enum.maxBound $dBounded_s6v8b; } in
        let {
          sat_s6v8c [Occ=Once] :: Data.Semigroup.Internal.Sum a_a6sWQ
          [LclId] =
              [$dBounded_s6v8b] \u [] GHC.Enum.minBound $dBounded_s6v8b;
        } in  GHC.Enum.C:Bounded [sat_s6v8c sat_s6v8d];

Data.Semigroup.Internal.$fShowSum2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum {"#;

Data.Semigroup.Internal.$fShowSum1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getSum = "#;

Data.Semigroup.Internal.$w$cshowsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Sum a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v8e ww_s6v8f w1_s6v8g]
        let {
          f_s6v8h [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6v8e w1_s6v8g] \u []
                  GHC.Show.showsPrec
                      w_s6v8e Data.Semigroup.Internal.$fShowAlt1 w1_s6v8g;
        } in 
          case >=# [ww_s6v8f 11#] of {
            __DEFAULT ->
                let {
                  sat_s6v8n [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6v8h] \r [x_s6v8j]
                          let {
                            sat_s6v8m [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6v8h x_s6v8j] \u []
                                    let {
                                      sat_s6v8l [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6v8h x_s6v8j] \u []
                                              let {
                                                sat_s6v8k [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6v8j] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6v8j;
                                              } in  f_s6v8h sat_s6v8k;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowSum1 sat_s6v8l;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowSum2 sat_s6v8m;
                } in  sat_s6v8n;
            1# ->
                let {
                  sat_s6v8u [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6v8h] \r [x_s6v8o]
                          let {
                            sat_s6v8t [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6v8h x_s6v8o] \u []
                                    let {
                                      sat_s6v8s [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6v8h x_s6v8o] \u []
                                              let {
                                                sat_s6v8r [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6v8h x_s6v8o] \u []
                                                        let {
                                                          sat_s6v8q [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6v8o] \u []
                                                                  let {
                                                                    sat_s6v8p [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6v8o];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6v8p;
                                                        } in  f_s6v8h sat_s6v8q;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowSum1 sat_s6v8r;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowSum2 sat_s6v8s;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6v8t];
                } in  sat_s6v8u;
          };

Data.Semigroup.Internal.$fShowSum_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Internal.Sum a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6v8v w1_s6v8w w2_s6v8x]
        case w1_s6v8w of {
          GHC.Types.I# ww1_s6v8z [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec5 w_s6v8v ww1_s6v8z w2_s6v8x;
        };

Data.Semigroup.Internal.$fShowSum_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Sum a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v8A x_s6v8B]
        let {
          sat_s6v8D [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6v8A x_s6v8B] \u []
                  let {
                    sat_s6v8C [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6v8A x_s6v8B] \u []
                            GHC.Show.showsPrec
                                $dShow_s6v8A
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6v8B
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowSum1 sat_s6v8C;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowSum2 sat_s6v8D;

Data.Semigroup.Internal.$fShowSum_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Sum a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6v8E ls_s6v8F s_s6v8G]
        let {
          sat_s6v8I [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v8E] \r [w_s6v8H]
                  Data.Semigroup.Internal.$w$cshowsPrec5 $dShow_s6v8E 0# w_s6v8H;
        } in  GHC.Show.showList__ sat_s6v8I ls_s6v8F s_s6v8G;

Data.Semigroup.Internal.$fShowSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6v8J]
        let {
          sat_s6v8M [Occ=Once]
            :: [Data.Semigroup.Internal.Sum a_a6sWl] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v8J] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshowList
                      $dShow_s6v8J eta_B2 eta_B1; } in
        let {
          sat_s6v8L [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Base.String
          [LclId] =
              [$dShow_s6v8J] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshow $dShow_s6v8J eta_B1; } in
        let {
          sat_s6v8K [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6v8J] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshowsPrec
                      $dShow_s6v8J eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6v8K sat_s6v8L sat_s6v8M];

Data.Semigroup.Internal.$fReadSum5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum"#;

Data.Semigroup.Internal.$fReadSum4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadSum5;

Data.Semigroup.Internal.$fReadSum_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadSum4];

Data.Semigroup.Internal.$fReadSum3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getSum"#;

Data.Semigroup.Internal.$fReadSum2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadSum3;

Data.Semigroup.Internal.$fReadSum1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Sum a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v8N]
        let {
          lvl12_s6v8O [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6sVw
          [LclId] =
              [$dRead_s6v8N] \u []
                  GHC.Read.readPrec
                      $dRead_s6v8N Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6v8P [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6sVw
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6v8O] \r [ds1_s6v8Q] lvl12_s6v8O; } in
        let {
          sat_s6v9a [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_a6sVw)
          [LclId] =
              [ds_s6v8P] \r [c_s6v8R eta_s6v8S]
                  case c_s6v8R of {
                    GHC.Types.I# x_s6v8U [Occ=Once] ->
                        case <=# [x_s6v8U 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6v97 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6v8P eta_s6v8S] \r [a1_s6v8W]
                                        let {
                                          sat_s6v94 [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6v8P eta_s6v8S] \r [a2_s6v8X]
                                                  let {
                                                    sat_s6v93 [Occ=Once]
                                                      :: a_a6sVw
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6v8S] \r [a3_s6v8Y]
                                                            let {
                                                              sat_s6v90 [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6v8S a3_s6v8Y] \r [a4_s6v8Z]
                                                                      eta_s6v8S a3_s6v8Y;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6v90
                                                              of
                                                              { Unit# ww1_s6v92 [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6v92];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadSum2
                                                        ds_s6v8P
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6v93;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6v94
                                          of
                                          { Unit# ww1_s6v96 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6v96];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadSum_lexeme sat_s6v97
                                of
                                { Unit# ww1_s6v99 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6v99];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6v9a;

Data.Semigroup.Internal.$fReadSum_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Sum a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v9b]
        let {
          ds_s6v9c [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Sum a_X6t8R
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6v9b] \u []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6v9b; } in
        let {
          sat_s6v9f [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Sum a_X6t8R)
          [LclId] =
              [ds_s6v9c] \r [n_s6v9d]
                  let {
                    sat_s6v9e [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Sum a_X6t8R)
                    [LclId] =
                        [ds_s6v9c n_s6v9d] \u []
                            ds_s6v9c
                                n_s6v9d Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6v9e;
        } in  sat_s6v9f;

Data.Semigroup.Internal.$fReadSum_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Sum a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v9g]
        let {
          sat_s6v9h [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_X6t8P)
          [LclId] =
              [$dRead_s6v9g] \s []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6v9g;
        } in  GHC.Read.list sat_s6v9h;

Data.Semigroup.Internal.$fReadSum_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Sum a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6v9i]
        let {
          sat_s6v9k [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Sum a_X6t8Q]
          [LclId] =
              [$dRead_s6v9i] \u []
                  let {
                    sat_s6v9j [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Sum a_X6t8Q)
                    [LclId] =
                        [$dRead_s6v9i] \s []
                            Data.Semigroup.Internal.$fReadSum1 $dRead_s6v9i;
                  } in 
                    GHC.Read.list
                        sat_s6v9j
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6v9k;

Data.Semigroup.Internal.$fReadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6v9l]
        let {
          sat_s6v9p [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Sum a_X6t8O]
          [LclId] =
              [$dRead_s6v9l] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadListPrec $dRead_s6v9l; } in
        let {
          sat_s6v9o [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_X6t8O)
          [LclId] =
              [$dRead_s6v9l] \u []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6v9l; } in
        let {
          sat_s6v9n [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Sum a_X6t8O]
          [LclId] =
              [$dRead_s6v9l] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadList $dRead_s6v9l; } in
        let {
          sat_s6v9m [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Sum a_X6t8O)
          [LclId] =
              [$dRead_s6v9l] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadsPrec $dRead_s6v9l;
        } in  GHC.Read.C:Read [sat_s6v9m sat_s6v9n sat_s6v9o sat_s6v9p];

Data.Semigroup.Internal.$fEqSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6v9q]
        let {
          sat_s6v9s [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sT9
               -> Data.Semigroup.Internal.Sum a_a6sT9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v9q] \u [] GHC.Classes./= $dEq_s6v9q; } in
        let {
          sat_s6v9r [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sT9
               -> Data.Semigroup.Internal.Sum a_a6sT9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6v9q] \u [] GHC.Classes.== $dEq_s6v9q;
        } in  GHC.Classes.C:Eq [sat_s6v9r sat_s6v9s];

Data.Semigroup.Internal.$fOrdSum_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6v9t]
        let {
          sat_s6v9u [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6sTH
          [LclId] =
              [$dOrd_s6v9t] \u [] GHC.Classes.$p1Ord $dOrd_s6v9t;
        } in  Data.Semigroup.Internal.$fEqSum sat_s6v9u;

Data.Semigroup.Internal.$fOrdSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6v9v]
        let {
          sat_s6v9D [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.min $dOrd_s6v9v; } in
        let {
          sat_s6v9C [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.max $dOrd_s6v9v; } in
        let {
          sat_s6v9B [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.>= $dOrd_s6v9v; } in
        let {
          sat_s6v9A [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.> $dOrd_s6v9v; } in
        let {
          sat_s6v9z [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.<= $dOrd_s6v9v; } in
        let {
          sat_s6v9y [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.< $dOrd_s6v9v; } in
        let {
          sat_s6v9x [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6v9v] \u [] GHC.Classes.compare $dOrd_s6v9v; } in
        let {
          sat_s6v9w [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Sum a_a6sTH)
          [LclId] =
              [$dOrd_s6v9v] \u []
                  Data.Semigroup.Internal.$fOrdSum_$cp1Ord $dOrd_s6v9v;
        } in 
          GHC.Classes.C:Ord [sat_s6v9w
                             sat_s6v9x
                             sat_s6v9y
                             sat_s6v9z
                             sat_s6v9A
                             sat_s6v9B
                             sat_s6v9C
                             sat_s6v9D];

Data.Semigroup.Internal.$fGenericAny1
  :: forall x.
     GHC.Generics.Rep Data.Semigroup.Internal.Any x
     -> GHC.Generics.Rep Data.Semigroup.Internal.Any x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6v9E] ds_s6v9E;

Data.Semigroup.Internal.$fGenericAny2
  :: forall x.
     Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6v9F] x1_s6v9F;

Data.Semigroup.Internal.$fGenericAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAny2
                                           Data.Semigroup.Internal.$fGenericAny1];

Data.Semigroup.Internal.$fBoundedAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Bounded Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Bounded! [GHC.Types.False GHC.Types.True];

Data.Semigroup.Internal.$fShowAny4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Any {"#;

Data.Semigroup.Internal.$fShowAny3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fShowAny4;

Data.Semigroup.Internal.$fShowAny2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAny = "#;

Data.Semigroup.Internal.$w$cshowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> Data.Semigroup.Internal.Any
     -> GHC.Base.String
     -> GHC.Base.String
[GblId, Arity=3, Str=<S,U><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s6v9G w_s6v9H w1_s6v9I]
        case >=# [ww_s6v9G 11#] of {
          __DEFAULT ->
              let {
                sat_s6v9O [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6v9H w1_s6v9I] \s []
                        let {
                          sat_s6v9N [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6v9H w1_s6v9I] \u []
                                  case w_s6v9H of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s6v9L [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6v9I] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6v9I;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6v9L;
                                    GHC.Types.True ->
                                        let {
                                          sat_s6v9M [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6v9I] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6v9I;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6v9M;
                                  };
                        } in 
                          GHC.CString.unpackAppendCString#
                              Data.Semigroup.Internal.$fShowAny2 sat_s6v9N;
              } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6v9O;
          1# ->
              let {
                sat_s6v9W [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6v9H w1_s6v9I] \u []
                        let {
                          sat_s6v9V [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6v9H w1_s6v9I] \s []
                                  let {
                                    sat_s6v9U [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w_s6v9H w1_s6v9I] \u []
                                            case w_s6v9H of {
                                              GHC.Types.False ->
                                                  let {
                                                    sat_s6v9R [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6v9I] \s []
                                                            let {
                                                              sat_s6v9Q [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6v9I];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6v9Q;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6v9R;
                                              GHC.Types.True ->
                                                  let {
                                                    sat_s6v9T [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6v9I] \s []
                                                            let {
                                                              sat_s6v9S [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6v9I];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6v9S;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6v9T;
                                            };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        Data.Semigroup.Internal.$fShowAny2 sat_s6v9U;
                        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6v9V;
              } in  : [GHC.Show.$fShow(,)4 sat_s6v9W];
        };

Data.Semigroup.Internal.$fShowAny_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> Data.Semigroup.Internal.Any -> GHC.Show.ShowS
[GblId, Arity=3, Str=<S(S),1*U(U)><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [w_s6v9X w1_s6v9Y w2_s6v9Z]
        case w_s6v9X of {
          GHC.Types.I# ww1_s6va1 [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec2 ww1_s6va1 w1_s6v9Y w2_s6v9Z;
        };

Data.Semigroup.Internal.$fShowAll6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++
            GHC.Show.$fShowBool4 Data.Semigroup.Internal.$fReadAll4;

Data.Semigroup.Internal.$fShowAll5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++
            GHC.Show.$fShowBool2 Data.Semigroup.Internal.$fReadAll4;

Data.Semigroup.Internal.$fShowAny_$cshow
  :: Data.Semigroup.Internal.Any -> GHC.Base.String
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s6va2]
        let {
          sat_s6va5 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [x_s6va2] \s []
                  let {
                    sat_s6va4 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [x_s6va2] \u []
                            case x_s6va2 of {
                              GHC.Types.False -> Data.Semigroup.Internal.$fShowAll6;
                              GHC.Types.True -> Data.Semigroup.Internal.$fShowAll5;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAny2 sat_s6va4;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6va5;

Data.Semigroup.Internal.$fShowAny1
  :: Data.Semigroup.Internal.Any -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,1*U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6va6 x_s6va7]
        let {
          sat_s6vac [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [ds_s6va6 x_s6va7] \s []
                  let {
                    sat_s6vab [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ds_s6va6 x_s6va7] \u []
                            case ds_s6va6 of {
                              GHC.Types.False ->
                                  let {
                                    sat_s6va9 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6va7] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6va7;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6va9;
                              GHC.Types.True ->
                                  let {
                                    sat_s6vaa [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6va7] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6va7;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6vaa;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAny2 sat_s6vab;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6vac;

Data.Semigroup.Internal.$fShowAny_$cshowList
  :: [Data.Semigroup.Internal.Any] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s6vad s_s6vae]
        GHC.Show.showList__
            Data.Semigroup.Internal.$fShowAny1 ls_s6vad s_s6vae;

Data.Semigroup.Internal.$fShowAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Semigroup.Internal.$fShowAny_$cshowsPrec
                                    Data.Semigroup.Internal.$fShowAny_$cshow
                                    Data.Semigroup.Internal.$fShowAny_$cshowList];

Data.Semigroup.Internal.$fReadAny6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Any"#;

Data.Semigroup.Internal.$fReadAny5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAny6;

Data.Semigroup.Internal.$fReadAny_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAny5];

Data.Semigroup.Internal.$fReadAny4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAny"#;

Data.Semigroup.Internal.$fReadAny3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAny4;

Data.Semigroup.Internal.$fReadAll7
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
    [] \r [ds1_s6vaf eta_s6vag]
        GHC.Read.list3
            GHC.Read.$fReadBool2
            Text.ParserCombinators.ReadPrec.minPrec
            eta_s6vag;

Data.Semigroup.Internal.$w$creadPrec1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ww_s6vah w_s6vai]
        case <=# [ww_s6vah 11#] of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
          1# ->
              let {
                sat_s6vav [Occ=Once]
                  :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                [LclId] =
                    [w_s6vai] \r [a1_s6vak]
                        let {
                          sat_s6vas [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                          [LclId] =
                              [w_s6vai] \r [a2_s6val]
                                  let {
                                    sat_s6var [Occ=Once]
                                      :: GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b_s6uMw
                                    [LclId] =
                                        [w_s6vai] \r [a3_s6vam]
                                            let {
                                              sat_s6vao [Occ=Once]
                                                :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                                              [LclId] =
                                                  [w_s6vai a3_s6vam] \r [a4_s6van] w_s6vai a3_s6vam;
                                            } in 
                                              case
                                                  Text.Read.Lex.$wexpect
                                                      Data.Semigroup.Internal.$fReadAll3 sat_s6vao
                                              of
                                              { Unit# ww2_s6vaq [Occ=Once] ->
                                                    Text.ParserCombinators.ReadP.Look [ww2_s6vaq];
                                              };
                                  } in 
                                    GHC.Read.readField
                                        Data.Semigroup.Internal.$fReadAny3
                                        Data.Semigroup.Internal.$fReadAll7
                                        Data.Semigroup.Internal.$fReadAll6
                                        sat_s6var;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6vas
                          of
                          { Unit# ww2_s6vau [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_s6vau];
                          };
              } in 
                case
                    Text.Read.Lex.$wexpect
                        Data.Semigroup.Internal.$fReadAny_lexeme sat_s6vav
                of
                { Unit# ww2_s6vax [Occ=Once] ->
                      Text.ParserCombinators.ReadP.Look [ww2_s6vax];
                };
        };

Data.Semigroup.Internal.$fReadAny2 [InlPrag=NOUSERINLINE[0]]
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_s6vay w1_s6vaz]
        case w_s6vay of {
          GHC.Types.I# ww1_s6vaB [Occ=Once] ->
              Data.Semigroup.Internal.$w$creadPrec1 ww1_s6vaB w1_s6vaz;
        };

Data.Semigroup.Internal.$fReadAny1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Semigroup.Internal.$fReadAny2 eta_B2 eta_B1;

Data.Semigroup.Internal.$fReadAny_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Semigroup.Internal.Any
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [n_s6vaC]
        let {
          sat_s6vaD [Occ=Once]
            :: Text.ParserCombinators.ReadP.P Data.Semigroup.Internal.Any
          [LclId] =
              [n_s6vaC] \u []
                  GHC.Read.list3
                      Data.Semigroup.Internal.$fReadAny2
                      n_s6vaC
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6vaD;

Data.Semigroup.Internal.$fReadAny_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Any]
[GblId] =
    [] \u [] GHC.Read.list Data.Semigroup.Internal.$fReadAny1;

Data.Semigroup.Internal.$fReadAny7
  :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Internal.Any]
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fReadAny_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Semigroup.Internal.$fReadAny_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Any]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Data.Semigroup.Internal.$fReadAny7 eta_B1;

Data.Semigroup.Internal.$fReadAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Semigroup.Internal.$fReadAny_$creadsPrec
                                    Data.Semigroup.Internal.$fReadAny_$creadList
                                    Data.Semigroup.Internal.$fReadAny1
                                    Data.Semigroup.Internal.$fReadAny_$creadListPrec];

Data.Semigroup.Internal.$fEqAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Classes.$fEqBool_$c==
                                     GHC.Classes.$fEqBool_$c/=];

Data.Semigroup.Internal.$fOrdAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Semigroup.Internal.$fEqAny
                                      GHC.Classes.$fOrdBool_$ccompare
                                      GHC.Classes.$fOrdBool_$c<
                                      GHC.Classes.$fOrdBool_$c<=
                                      GHC.Classes.$fOrdBool_$c>
                                      GHC.Classes.$fOrdBool_$c>=
                                      GHC.Classes.$fOrdBool_$cmax
                                      GHC.Classes.$fOrdBool_$cmin];

Data.Semigroup.Internal.$fGenericAll1
  :: forall x.
     GHC.Generics.Rep Data.Semigroup.Internal.All x
     -> GHC.Generics.Rep Data.Semigroup.Internal.All x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vaE] ds_s6vaE;

Data.Semigroup.Internal.$fGenericAll2
  :: forall x.
     Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6vaF] x1_s6vaF;

Data.Semigroup.Internal.$fGenericAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAll2
                                           Data.Semigroup.Internal.$fGenericAll1];

Data.Semigroup.Internal.$fBoundedAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Bounded Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Bounded! [GHC.Types.False GHC.Types.True];

Data.Semigroup.Internal.$fShowAll4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "All {"#;

Data.Semigroup.Internal.$fShowAll3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fShowAll4;

Data.Semigroup.Internal.$fShowAll2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAll = "#;

Data.Semigroup.Internal.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> Data.Semigroup.Internal.All
     -> GHC.Base.String
     -> GHC.Base.String
[GblId, Arity=3, Str=<S,U><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s6vaG w_s6vaH w1_s6vaI]
        case >=# [ww_s6vaG 11#] of {
          __DEFAULT ->
              let {
                sat_s6vaO [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6vaH w1_s6vaI] \s []
                        let {
                          sat_s6vaN [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6vaH w1_s6vaI] \u []
                                  case w_s6vaH of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s6vaL [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6vaI] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6vaI;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6vaL;
                                    GHC.Types.True ->
                                        let {
                                          sat_s6vaM [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6vaI] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6vaI;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6vaM;
                                  };
                        } in 
                          GHC.CString.unpackAppendCString#
                              Data.Semigroup.Internal.$fShowAll2 sat_s6vaN;
              } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6vaO;
          1# ->
              let {
                sat_s6vaW [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6vaH w1_s6vaI] \u []
                        let {
                          sat_s6vaV [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6vaH w1_s6vaI] \s []
                                  let {
                                    sat_s6vaU [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w_s6vaH w1_s6vaI] \u []
                                            case w_s6vaH of {
                                              GHC.Types.False ->
                                                  let {
                                                    sat_s6vaR [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6vaI] \s []
                                                            let {
                                                              sat_s6vaQ [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6vaI];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6vaQ;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6vaR;
                                              GHC.Types.True ->
                                                  let {
                                                    sat_s6vaT [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6vaI] \s []
                                                            let {
                                                              sat_s6vaS [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6vaI];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6vaS;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6vaT;
                                            };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        Data.Semigroup.Internal.$fShowAll2 sat_s6vaU;
                        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6vaV;
              } in  : [GHC.Show.$fShow(,)4 sat_s6vaW];
        };

Data.Semigroup.Internal.$fShowAll_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> Data.Semigroup.Internal.All -> GHC.Show.ShowS
[GblId, Arity=3, Str=<S(S),1*U(U)><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [w_s6vaX w1_s6vaY w2_s6vaZ]
        case w_s6vaX of {
          GHC.Types.I# ww1_s6vb1 [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec ww1_s6vb1 w1_s6vaY w2_s6vaZ;
        };

Data.Semigroup.Internal.$fShowAll_$cshow
  :: Data.Semigroup.Internal.All -> GHC.Base.String
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s6vb2]
        let {
          sat_s6vb5 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [x_s6vb2] \s []
                  let {
                    sat_s6vb4 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [x_s6vb2] \u []
                            case x_s6vb2 of {
                              GHC.Types.False -> Data.Semigroup.Internal.$fShowAll6;
                              GHC.Types.True -> Data.Semigroup.Internal.$fShowAll5;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAll2 sat_s6vb4;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6vb5;

Data.Semigroup.Internal.$fShowAll1
  :: Data.Semigroup.Internal.All -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,1*U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vb6 x_s6vb7]
        let {
          sat_s6vbc [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [ds_s6vb6 x_s6vb7] \s []
                  let {
                    sat_s6vbb [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ds_s6vb6 x_s6vb7] \u []
                            case ds_s6vb6 of {
                              GHC.Types.False ->
                                  let {
                                    sat_s6vb9 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6vb7] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6vb7;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6vb9;
                              GHC.Types.True ->
                                  let {
                                    sat_s6vba [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6vb7] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6vb7;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6vba;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAll2 sat_s6vbb;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6vbc;

Data.Semigroup.Internal.$fShowAll_$cshowList
  :: [Data.Semigroup.Internal.All] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s6vbd s_s6vbe]
        GHC.Show.showList__
            Data.Semigroup.Internal.$fShowAll1 ls_s6vbd s_s6vbe;

Data.Semigroup.Internal.$fShowAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Semigroup.Internal.$fShowAll_$cshowsPrec
                                    Data.Semigroup.Internal.$fShowAll_$cshow
                                    Data.Semigroup.Internal.$fShowAll_$cshowList];

Data.Semigroup.Internal.$fReadAll13 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "All"#;

Data.Semigroup.Internal.$fReadAll12 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll13;

Data.Semigroup.Internal.$fReadAll_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAll12];

Data.Semigroup.Internal.$fReadAll9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAll"#;

Data.Semigroup.Internal.$fReadAll8 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll9;

Data.Semigroup.Internal.$w$creadPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ww_s6vbf w_s6vbg]
        case <=# [ww_s6vbf 11#] of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
          1# ->
              let {
                sat_s6vbt [Occ=Once]
                  :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                [LclId] =
                    [w_s6vbg] \r [a1_s6vbi]
                        let {
                          sat_s6vbq [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                          [LclId] =
                              [w_s6vbg] \r [a2_s6vbj]
                                  let {
                                    sat_s6vbp [Occ=Once]
                                      :: GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b_s6uMP
                                    [LclId] =
                                        [w_s6vbg] \r [a3_s6vbk]
                                            let {
                                              sat_s6vbm [Occ=Once]
                                                :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                                              [LclId] =
                                                  [w_s6vbg a3_s6vbk] \r [a4_s6vbl] w_s6vbg a3_s6vbk;
                                            } in 
                                              case
                                                  Text.Read.Lex.$wexpect
                                                      Data.Semigroup.Internal.$fReadAll3 sat_s6vbm
                                              of
                                              { Unit# ww2_s6vbo [Occ=Once] ->
                                                    Text.ParserCombinators.ReadP.Look [ww2_s6vbo];
                                              };
                                  } in 
                                    GHC.Read.readField
                                        Data.Semigroup.Internal.$fReadAll8
                                        Data.Semigroup.Internal.$fReadAll7
                                        Data.Semigroup.Internal.$fReadAll6
                                        sat_s6vbp;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6vbq
                          of
                          { Unit# ww2_s6vbs [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_s6vbs];
                          };
              } in 
                case
                    Text.Read.Lex.$wexpect
                        Data.Semigroup.Internal.$fReadAll_lexeme1 sat_s6vbt
                of
                { Unit# ww2_s6vbv [Occ=Once] ->
                      Text.ParserCombinators.ReadP.Look [ww2_s6vbv];
                };
        };

Data.Semigroup.Internal.$fReadAll2 [InlPrag=NOUSERINLINE[0]]
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_s6vbw w1_s6vbx]
        case w_s6vbw of {
          GHC.Types.I# ww1_s6vbz [Occ=Once] ->
              Data.Semigroup.Internal.$w$creadPrec ww1_s6vbz w1_s6vbx;
        };

Data.Semigroup.Internal.$fReadAll1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Semigroup.Internal.$fReadAll2 eta_B2 eta_B1;

Data.Semigroup.Internal.$fReadAll_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Semigroup.Internal.All
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [n_s6vbA]
        let {
          sat_s6vbB [Occ=Once]
            :: Text.ParserCombinators.ReadP.P Data.Semigroup.Internal.All
          [LclId] =
              [n_s6vbA] \u []
                  GHC.Read.list3
                      Data.Semigroup.Internal.$fReadAll2
                      n_s6vbA
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6vbB;

Data.Semigroup.Internal.$fReadAll_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.All]
[GblId] =
    [] \u [] GHC.Read.list Data.Semigroup.Internal.$fReadAll1;

Data.Semigroup.Internal.$fReadAll14
  :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Internal.All]
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fReadAll_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Semigroup.Internal.$fReadAll_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.All]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Data.Semigroup.Internal.$fReadAll14 eta_B1;

Data.Semigroup.Internal.$fReadAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Semigroup.Internal.$fReadAll_$creadsPrec
                                    Data.Semigroup.Internal.$fReadAll_$creadList
                                    Data.Semigroup.Internal.$fReadAll1
                                    Data.Semigroup.Internal.$fReadAll_$creadListPrec];

Data.Semigroup.Internal.$fEqAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Classes.$fEqBool_$c==
                                     GHC.Classes.$fEqBool_$c/=];

Data.Semigroup.Internal.$fOrdAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Semigroup.Internal.$fEqAll
                                      GHC.Classes.$fOrdBool_$ccompare
                                      GHC.Classes.$fOrdBool_$c<
                                      GHC.Classes.$fOrdBool_$c<=
                                      GHC.Classes.$fOrdBool_$c>
                                      GHC.Classes.$fOrdBool_$c>=
                                      GHC.Classes.$fOrdBool_$cmax
                                      GHC.Classes.$fOrdBool_$cmin];

Data.Semigroup.Internal.$fGenericEndo1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Endo a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Endo a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vbC] ds_s6vbC;

Data.Semigroup.Internal.$fGenericEndo2
  :: forall a x.
     Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6vbD] x1_s6vbD;

Data.Semigroup.Internal.$fGenericEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericEndo2
                                           Data.Semigroup.Internal.$fGenericEndo1];

Data.Semigroup.Internal.$fGeneric1Dual1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Dual a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vbE] ds_s6vbE;

Data.Semigroup.Internal.$fGeneric1Dual2
  :: forall a.
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6vbF] x_s6vbF;

Data.Semigroup.Internal.$fGeneric1Dual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Dual
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Dual2
                                            Data.Semigroup.Internal.$fGeneric1Dual1];

Data.Semigroup.Internal.$fGenericDual1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Dual a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Dual a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vbG] ds_s6vbG;

Data.Semigroup.Internal.$fGenericDual2
  :: forall a x.
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6vbH] x1_s6vbH;

Data.Semigroup.Internal.$fGenericDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericDual2
                                           Data.Semigroup.Internal.$fGenericDual1];

Data.Semigroup.Internal.$fBoundedDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6vbI]
        let {
          sat_s6vbK [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6sGr
          [LclId] =
              [$dBounded_s6vbI] \u [] GHC.Enum.maxBound $dBounded_s6vbI; } in
        let {
          sat_s6vbJ [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6sGr
          [LclId] =
              [$dBounded_s6vbI] \u [] GHC.Enum.minBound $dBounded_s6vbI;
        } in  GHC.Enum.C:Bounded [sat_s6vbJ sat_s6vbK];

Data.Semigroup.Internal.$fShowDual2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Dual {"#;

Data.Semigroup.Internal.$fShowDual1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getDual = "#;

Data.Semigroup.Internal.$w$cshowsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Dual a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6vbL ww_s6vbM w1_s6vbN]
        let {
          f_s6vbO [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6vbL w1_s6vbN] \u []
                  GHC.Show.showsPrec
                      w_s6vbL Data.Semigroup.Internal.$fShowAlt1 w1_s6vbN;
        } in 
          case >=# [ww_s6vbM 11#] of {
            __DEFAULT ->
                let {
                  sat_s6vbU [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6vbO] \r [x_s6vbQ]
                          let {
                            sat_s6vbT [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6vbO x_s6vbQ] \u []
                                    let {
                                      sat_s6vbS [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6vbO x_s6vbQ] \u []
                                              let {
                                                sat_s6vbR [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6vbQ] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6vbQ;
                                              } in  f_s6vbO sat_s6vbR;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowDual1 sat_s6vbS;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowDual2 sat_s6vbT;
                } in  sat_s6vbU;
            1# ->
                let {
                  sat_s6vc1 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6vbO] \r [x_s6vbV]
                          let {
                            sat_s6vc0 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6vbO x_s6vbV] \u []
                                    let {
                                      sat_s6vbZ [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6vbO x_s6vbV] \u []
                                              let {
                                                sat_s6vbY [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6vbO x_s6vbV] \u []
                                                        let {
                                                          sat_s6vbX [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6vbV] \u []
                                                                  let {
                                                                    sat_s6vbW [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6vbV];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6vbW;
                                                        } in  f_s6vbO sat_s6vbX;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowDual1 sat_s6vbY;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowDual2 sat_s6vbZ;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6vc0];
                } in  sat_s6vc1;
          };

Data.Semigroup.Internal.$fShowDual_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Internal.Dual a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6vc2 w1_s6vc3 w2_s6vc4]
        case w1_s6vc3 of {
          GHC.Types.I# ww1_s6vc6 [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec3 w_s6vc2 ww1_s6vc6 w2_s6vc4;
        };

Data.Semigroup.Internal.$fShowDual_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Dual a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6vc7 x_s6vc8]
        let {
          sat_s6vca [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6vc7 x_s6vc8] \u []
                  let {
                    sat_s6vc9 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6vc7 x_s6vc8] \u []
                            GHC.Show.showsPrec
                                $dShow_s6vc7
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6vc8
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowDual1 sat_s6vc9;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowDual2 sat_s6vca;

Data.Semigroup.Internal.$fShowDual_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Dual a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6vcb ls_s6vcc s_s6vcd]
        let {
          sat_s6vcf [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6vcb] \r [w_s6vce]
                  Data.Semigroup.Internal.$w$cshowsPrec3 $dShow_s6vcb 0# w_s6vce;
        } in  GHC.Show.showList__ sat_s6vcf ls_s6vcc s_s6vcd;

Data.Semigroup.Internal.$fShowDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6vcg]
        let {
          sat_s6vcj [Occ=Once]
            :: [Data.Semigroup.Internal.Dual a_a6sFL] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6vcg] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshowList
                      $dShow_s6vcg eta_B2 eta_B1; } in
        let {
          sat_s6vci [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Base.String
          [LclId] =
              [$dShow_s6vcg] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshow $dShow_s6vcg eta_B1; } in
        let {
          sat_s6vch [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6vcg] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshowsPrec
                      $dShow_s6vcg eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6vch sat_s6vci sat_s6vcj];

Data.Semigroup.Internal.$fReadDual5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Dual"#;

Data.Semigroup.Internal.$fReadDual4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadDual5;

Data.Semigroup.Internal.$fReadDual_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadDual4];

Data.Semigroup.Internal.$fReadDual3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getDual"#;

Data.Semigroup.Internal.$fReadDual2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadDual3;

Data.Semigroup.Internal.$fReadDual1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Dual a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6vck]
        let {
          lvl12_s6vcl [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6sEx
          [LclId] =
              [$dRead_s6vck] \u []
                  GHC.Read.readPrec
                      $dRead_s6vck Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6vcm [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6sEx
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6vcl] \r [ds1_s6vcn] lvl12_s6vcl; } in
        let {
          sat_s6vcH [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_a6sEx)
          [LclId] =
              [ds_s6vcm] \r [c_s6vco eta_s6vcp]
                  case c_s6vco of {
                    GHC.Types.I# x_s6vcr [Occ=Once] ->
                        case <=# [x_s6vcr 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6vcE [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6vcm eta_s6vcp] \r [a1_s6vct]
                                        let {
                                          sat_s6vcB [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6vcm eta_s6vcp] \r [a2_s6vcu]
                                                  let {
                                                    sat_s6vcA [Occ=Once]
                                                      :: a_a6sEx
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6vcp] \r [a3_s6vcv]
                                                            let {
                                                              sat_s6vcx [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6vcp a3_s6vcv] \r [a4_s6vcw]
                                                                      eta_s6vcp a3_s6vcv;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6vcx
                                                              of
                                                              { Unit# ww1_s6vcz [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6vcz];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadDual2
                                                        ds_s6vcm
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6vcA;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6vcB
                                          of
                                          { Unit# ww1_s6vcD [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6vcD];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadDual_lexeme sat_s6vcE
                                of
                                { Unit# ww1_s6vcG [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6vcG];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6vcH;

Data.Semigroup.Internal.$fReadDual_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Dual a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6vcI]
        let {
          ds_s6vcJ [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Dual a_X6sTW
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6vcI] \u []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6vcI; } in
        let {
          sat_s6vcM [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Dual a_X6sTW)
          [LclId] =
              [ds_s6vcJ] \r [n_s6vcK]
                  let {
                    sat_s6vcL [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Dual a_X6sTW)
                    [LclId] =
                        [ds_s6vcJ n_s6vcK] \u []
                            ds_s6vcJ
                                n_s6vcK Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6vcL;
        } in  sat_s6vcM;

Data.Semigroup.Internal.$fReadDual_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Dual a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6vcN]
        let {
          sat_s6vcO [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_X6sTU)
          [LclId] =
              [$dRead_s6vcN] \s []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6vcN;
        } in  GHC.Read.list sat_s6vcO;

Data.Semigroup.Internal.$fReadDual_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Dual a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6vcP]
        let {
          sat_s6vcR [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Dual a_X6sTV]
          [LclId] =
              [$dRead_s6vcP] \u []
                  let {
                    sat_s6vcQ [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Dual a_X6sTV)
                    [LclId] =
                        [$dRead_s6vcP] \s []
                            Data.Semigroup.Internal.$fReadDual1 $dRead_s6vcP;
                  } in 
                    GHC.Read.list
                        sat_s6vcQ
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6vcR;

Data.Semigroup.Internal.$fReadDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6vcS]
        let {
          sat_s6vcW [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Dual a_X6sTT]
          [LclId] =
              [$dRead_s6vcS] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadListPrec
                      $dRead_s6vcS; } in
        let {
          sat_s6vcV [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_X6sTT)
          [LclId] =
              [$dRead_s6vcS] \u []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6vcS; } in
        let {
          sat_s6vcU [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Dual a_X6sTT]
          [LclId] =
              [$dRead_s6vcS] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadList $dRead_s6vcS; } in
        let {
          sat_s6vcT [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Dual a_X6sTT)
          [LclId] =
              [$dRead_s6vcS] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadsPrec $dRead_s6vcS;
        } in  GHC.Read.C:Read [sat_s6vcT sat_s6vcU sat_s6vcV sat_s6vcW];

Data.Semigroup.Internal.$fEqDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6vcX]
        let {
          sat_s6vcZ [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCa
               -> Data.Semigroup.Internal.Dual a_a6sCa -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6vcX] \u [] GHC.Classes./= $dEq_s6vcX; } in
        let {
          sat_s6vcY [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCa
               -> Data.Semigroup.Internal.Dual a_a6sCa -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6vcX] \u [] GHC.Classes.== $dEq_s6vcX;
        } in  GHC.Classes.C:Eq [sat_s6vcY sat_s6vcZ];

Data.Semigroup.Internal.$fOrdDual_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6vd0]
        let {
          sat_s6vd1 [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6sCI
          [LclId] =
              [$dOrd_s6vd0] \u [] GHC.Classes.$p1Ord $dOrd_s6vd0;
        } in  Data.Semigroup.Internal.$fEqDual sat_s6vd1;

Data.Semigroup.Internal.$fOrdDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6vd2]
        let {
          sat_s6vda [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.min $dOrd_s6vd2; } in
        let {
          sat_s6vd9 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.max $dOrd_s6vd2; } in
        let {
          sat_s6vd8 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.>= $dOrd_s6vd2; } in
        let {
          sat_s6vd7 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.> $dOrd_s6vd2; } in
        let {
          sat_s6vd6 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.<= $dOrd_s6vd2; } in
        let {
          sat_s6vd5 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.< $dOrd_s6vd2; } in
        let {
          sat_s6vd4 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6vd2] \u [] GHC.Classes.compare $dOrd_s6vd2; } in
        let {
          sat_s6vd3 [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Dual a_a6sCI)
          [LclId] =
              [$dOrd_s6vd2] \u []
                  Data.Semigroup.Internal.$fOrdDual_$cp1Ord $dOrd_s6vd2;
        } in 
          GHC.Classes.C:Ord [sat_s6vd3
                             sat_s6vd4
                             sat_s6vd5
                             sat_s6vd6
                             sat_s6vd7
                             sat_s6vd8
                             sat_s6vd9
                             sat_s6vda];

Data.Semigroup.Internal.getDual
  :: forall a. Data.Semigroup.Internal.Dual a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Semigroup.Internal.$fMonadDual_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> (a -> Data.Semigroup.Internal.Dual b)
     -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6vdb k_s6vdc] k_s6vdc m_s6vdb;

Data.Semigroup.Internal.$fMonadDual_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeDual_$c*> eta_B2 eta_B1;

lvl_r6v16
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6vdd] GHC.Err.errorWithoutStackTrace eta_s6vdd;

Data.Semigroup.Internal.$fMonadDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeDual
                                     Data.Semigroup.Internal.$fMonadDual_$c>>=
                                     Data.Semigroup.Internal.$fMonadDual_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl_r6v16];

Data.Semigroup.Internal.appEndo1
  :: forall a.
     Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vde] ds_s6vde;

Data.Semigroup.Internal.appEndo
  :: forall a. Data.Semigroup.Internal.Endo a -> a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.appEndo1 eta_B1;

Data.Semigroup.Internal.getAll1
  :: Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vdf] ds_s6vdf;

Data.Semigroup.Internal.getAll
  :: Data.Semigroup.Internal.All -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.getAll1 eta_B1;

Data.Semigroup.Internal.getAny1
  :: Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vdg] ds_s6vdg;

Data.Semigroup.Internal.getAny
  :: Data.Semigroup.Internal.Any -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.getAny1 eta_B1;

Data.Semigroup.Internal.getSum
  :: forall a. Data.Semigroup.Internal.Sum a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Semigroup.Internal.$fMonadSum_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> (a -> Data.Semigroup.Internal.Sum b)
     -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6vdh k_s6vdi] k_s6vdi m_s6vdh;

Data.Semigroup.Internal.$fMonadSum_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeSum_$c*> eta_B2 eta_B1;

lvl1_r6v17
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6vdj] GHC.Err.errorWithoutStackTrace eta_s6vdj;

Data.Semigroup.Internal.$fMonadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeSum
                                     Data.Semigroup.Internal.$fMonadSum_$c>>=
                                     Data.Semigroup.Internal.$fMonadSum_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl1_r6v17];

Data.Semigroup.Internal.getProduct
  :: forall a. Data.Semigroup.Internal.Product a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Semigroup.Internal.$fMonadProduct_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> (a -> Data.Semigroup.Internal.Product b)
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6vdk k_s6vdl] k_s6vdl m_s6vdk;

Data.Semigroup.Internal.$fMonadProduct_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeProduct_$c*> eta_B2 eta_B1;

lvl2_r6v18
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6vdm] GHC.Err.errorWithoutStackTrace eta_s6vdm;

Data.Semigroup.Internal.$fMonadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeProduct
                                     Data.Semigroup.Internal.$fMonadProduct_$c>>=
                                     Data.Semigroup.Internal.$fMonadProduct_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl2_r6v18];

Data.Semigroup.Internal.getAlt
  :: forall k (f :: k -> *) (a :: k).
     Data.Semigroup.Internal.Alt f a -> f a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Alt2 eta_B1;

lvl3_r6v19 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesIdempotent: positive multiplier expected"#;

Data.Semigroup.Internal.stimesIdempotent1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_r6v19 of sat_s6vdn {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vdn;
        };

Data.Semigroup.Internal.stimesIdempotent
  :: forall b a. GHC.Real.Integral b => b -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vdo eta_s6vdp eta1_s6vdq]
        case
            GHC.Real.$p1Integral $dIntegral_s6vdo
        of
        $dReal_s6vdr [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6vdu [Occ=Once] :: b_a6sBZ
                [LclId] =
                    [$dReal_s6vdr] \u []
                        case GHC.Real.$p1Real $dReal_s6vdr of sat_s6vdt {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6vdt Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6vdr of sat_s6vds {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s6vds eta_s6vdp sat_s6vdu of {
                        GHC.Types.False -> eta1_s6vdq;
                        GHC.Types.True -> Data.Semigroup.Internal.stimesIdempotent1;
                      };
                };
        };

lvl4_r6v1a :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesIdempotentMonoid: negative multiplier"#;

Data.Semigroup.Internal.stimesIdempotentMonoid1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl4_r6v1a of sat_s6vdw {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vdw;
        };

Data.Semigroup.Internal.stimesIdempotentMonoid
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(LC(C(S))LLLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,1*U(A,1*U,A,A)><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vdx $dMonoid_s6vdy eta_s6vdz eta1_s6vdA]
        case
            GHC.Real.$p1Integral $dIntegral_s6vdx
        of
        $dReal_s6vdB [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6vdE [Occ=Once] :: b_a6sBJ
                [LclId] =
                    [$dReal_s6vdB] \u []
                        case GHC.Real.$p1Real $dReal_s6vdB of sat_s6vdD {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6vdD Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6vdB of sat_s6vdC {
                  __DEFAULT ->
                      case GHC.Classes.compare sat_s6vdC eta_s6vdz sat_s6vdE of {
                        GHC.Types.LT -> Data.Semigroup.Internal.stimesIdempotentMonoid1;
                        GHC.Types.EQ -> GHC.Base.mempty $dMonoid_s6vdy;
                        GHC.Types.GT -> eta1_s6vdA;
                      };
                };
        };

Data.Semigroup.Internal.$fSemigroupAny_go [Occ=LoopBreaker]
  :: Data.Semigroup.Internal.Any
     -> [Data.Semigroup.Internal.Any] -> Data.Semigroup.Internal.Any
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6vdG ds1_s6vdH]
        case ds1_s6vdH of {
          [] -> b_s6vdG;
          : c_s6vdJ [Occ=Once] cs_s6vdK [Occ=Once] ->
              case b_s6vdG of {
                GHC.Types.False ->
                    Data.Semigroup.Internal.$fSemigroupAny_go c_s6vdJ cs_s6vdK;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

Data.Semigroup.Internal.$fSemigroupAny_$csconcat
  :: GHC.Base.NonEmpty Data.Semigroup.Internal.Any
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6vdM]
        case ds_s6vdM of {
          GHC.Base.:| a1_s6vdO [Occ=Once] as_s6vdP [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupAny_go a1_s6vdO as_s6vdP;
        };

Data.Semigroup.Internal.$fMonoidAny_go [Occ=LoopBreaker]
  :: [Data.Semigroup.Internal.Any] -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6vdQ]
        case ds_s6vdQ of {
          [] -> GHC.Types.False [];
          : y_s6vdS [Occ=Once] ys_s6vdT [Occ=Once] ->
              case y_s6vdS of {
                GHC.Types.False -> Data.Semigroup.Internal.$fMonoidAny_go ys_s6vdT;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

Data.Semigroup.Internal.$fSemigroupAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Classes.||
                                         Data.Semigroup.Internal.$fSemigroupAny_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupAny_$cstimes];
Data.Semigroup.Internal.$fMonoidAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupAny
                                      GHC.Types.False
                                      GHC.Classes.||
                                      Data.Semigroup.Internal.$fMonoidAny_go];
Data.Semigroup.Internal.$fSemigroupAny_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vdV eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6vdV Data.Semigroup.Internal.$fMonoidAny eta_B2 eta_B1;

Data.Semigroup.Internal.$fSemigroupAll_go [Occ=LoopBreaker]
  :: Data.Semigroup.Internal.All
     -> [Data.Semigroup.Internal.All] -> Data.Semigroup.Internal.All
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6vdW ds1_s6vdX]
        case ds1_s6vdX of {
          [] -> b_s6vdW;
          : c_s6vdZ [Occ=Once] cs_s6ve0 [Occ=Once] ->
              case b_s6vdW of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Semigroup.Internal.$fSemigroupAll_go c_s6vdZ cs_s6ve0;
              };
        };

Data.Semigroup.Internal.$fSemigroupAll_$csconcat
  :: GHC.Base.NonEmpty Data.Semigroup.Internal.All
     -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6ve2]
        case ds_s6ve2 of {
          GHC.Base.:| a1_s6ve4 [Occ=Once] as_s6ve5 [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupAll_go a1_s6ve4 as_s6ve5;
        };

Data.Semigroup.Internal.$fMonoidAll_go [Occ=LoopBreaker]
  :: [Data.Semigroup.Internal.All] -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6ve6]
        case ds_s6ve6 of {
          [] -> GHC.Types.True [];
          : y_s6ve8 [Occ=Once] ys_s6ve9 [Occ=Once] ->
              case y_s6ve8 of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> Data.Semigroup.Internal.$fMonoidAll_go ys_s6ve9;
              };
        };

Data.Semigroup.Internal.$fSemigroupAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Classes.&&
                                         Data.Semigroup.Internal.$fSemigroupAll_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupAll_$cstimes];
Data.Semigroup.Internal.$fMonoidAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupAll
                                      GHC.Types.True
                                      GHC.Classes.&&
                                      Data.Semigroup.Internal.$fMonoidAll_go];
Data.Semigroup.Internal.$fSemigroupAll_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6veb eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6veb Data.Semigroup.Internal.$fMonoidAll eta_B2 eta_B1;

lvl5_r6v1b :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesMonoid: negative multiplier"#;

lvl6_r6v1c :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r6v1b of sat_s6vec {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vec;
        };

sat_s6ved :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s6vee :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6ved GHC.Types.[]];

lvl7_r6v1d :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6vee;

Data.Semigroup.Internal.stimesMonoid
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(LC(C(S))LLLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(A,1*U,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vef $dMonoid_s6veg eta_s6veh eta1_s6vei]
        case
            GHC.Real.$p1Integral $dIntegral_s6vef
        of
        $dReal_s6vej [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6vem [Occ=Once] :: b_a6szg
                [LclId] =
                    [$dReal_s6vej] \u []
                        case GHC.Real.$p1Real $dReal_s6vej of sat_s6vel {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6vel Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6vej of sat_s6vek {
                  __DEFAULT ->
                      case GHC.Classes.compare sat_s6vek eta_s6veh sat_s6vem of {
                        GHC.Types.LT -> lvl6_r6v1c;
                        GHC.Types.EQ -> GHC.Base.mempty $dMonoid_s6veg;
                        GHC.Types.GT ->
                            let {
                              $dNum_s6veo [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a6szg
                              [LclId] =
                                  [$dReal_s6vej] \u [] GHC.Real.$p1Real $dReal_s6vej; } in
                            let {
                              lvl12_s6vep :: b_a6szg
                              [LclId] =
                                  [$dNum_s6veo] \u [] GHC.Num.fromInteger $dNum_s6veo lvl7_r6v1d;
                            } in 
                              let-no-escape {
                                exit_s6veq [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                  :: a_a6szh -> b_a6szg -> a_a6szh
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s6vef
                                              $dMonoid_s6veg
                                              $dReal_s6vej
                                              $dNum_s6veo
                                              lvl12_s6vep] \r [x_s6ver y_s6ves]
                                        case
                                            GHC.Real.$p2Real $dReal_s6vej
                                        of
                                        $dEq_s6vet [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              case
                                                  GHC.Classes.$p1Ord $dEq_s6vet
                                              of
                                              $dEq1_s6veu [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      lvl13_s6vev :: b_a6szg
                                                      [LclId] =
                                                          [$dNum_s6veo] \u []
                                                              GHC.Num.fromInteger
                                                                  $dNum_s6veo
                                                                  Data.Semigroup.Internal.$fMonoidProduct1;
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq1_s6veu y_s6ves lvl13_s6vev
                                                      of
                                                      { GHC.Types.False ->
                                                            let {
                                                              sat_s6veM [Occ=Once] :: b_a6szg
                                                              [LclId] =
                                                                  [$dIntegral_s6vef
                                                                   lvl12_s6vep
                                                                   y_s6ves] \u []
                                                                      GHC.Real.quot
                                                                          $dIntegral_s6vef
                                                                          y_s6ves
                                                                          lvl12_s6vep; } in
                                                            let {
                                                              sat_s6veL [Occ=Once] :: a_a6szh
                                                              [LclId] =
                                                                  [$dMonoid_s6veg x_s6ver] \u []
                                                                      GHC.Base.mappend
                                                                          $dMonoid_s6veg
                                                                          x_s6ver
                                                                          x_s6ver;
                                                            } in 
                                                              let-no-escape {
                                                                exit1_s6vex [Occ=OnceL!T[2],
                                                                             Dmd=<C(C(S)),C(C1(U))>]
                                                                  :: a_a6szh -> a_a6szh -> a_a6szh
                                                                [LclId[JoinId(2)],
                                                                 Arity=2,
                                                                 Str=<L,U><L,U>,
                                                                 Unf=OtherCon []] =
                                                                    sat-only [$dMonoid_s6veg] \r [x1_s6vey
                                                                                                  z_s6vez]
                                                                        GHC.Base.mappend
                                                                            $dMonoid_s6veg
                                                                            x1_s6vey
                                                                            z_s6vez;
                                                              } in 
                                                                let-no-escape {
                                                                  g_s6veA [Occ=LoopBreakerT[3]]
                                                                    :: a_a6szh
                                                                       -> b_a6szg
                                                                       -> a_a6szh
                                                                       -> a_a6szh
                                                                  [LclId[JoinId(3)],
                                                                   Arity=3,
                                                                   Str=<L,U><L,U><L,U>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [$dIntegral_s6vef
                                                                                $dMonoid_s6veg
                                                                                lvl12_s6vep
                                                                                $dEq1_s6veu
                                                                                lvl13_s6vev
                                                                                exit1_s6vex
                                                                                g_s6veA] \r [x1_s6veB
                                                                                             y1_s6veC
                                                                                             z_s6veD]
                                                                          case
                                                                              GHC.Real.even
                                                                                  $dIntegral_s6vef
                                                                                  y1_s6veC
                                                                          of
                                                                          { GHC.Types.False ->
                                                                                case
                                                                                    GHC.Classes.==
                                                                                        $dEq1_s6veu
                                                                                        y1_s6veC
                                                                                        lvl13_s6vev
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s6veI [Occ=Once]
                                                                                          :: a_a6szh
                                                                                        [LclId] =
                                                                                            [$dMonoid_s6veg
                                                                                             x1_s6veB
                                                                                             z_s6veD] \u []
                                                                                                GHC.Base.mappend
                                                                                                    $dMonoid_s6veg
                                                                                                    x1_s6veB
                                                                                                    z_s6veD; } in
                                                                                      let {
                                                                                        sat_s6veH [Occ=Once]
                                                                                          :: b_a6szg
                                                                                        [LclId] =
                                                                                            [$dIntegral_s6vef
                                                                                             lvl12_s6vep
                                                                                             y1_s6veC] \u []
                                                                                                GHC.Real.quot
                                                                                                    $dIntegral_s6vef
                                                                                                    y1_s6veC
                                                                                                    lvl12_s6vep; } in
                                                                                      let {
                                                                                        sat_s6veG [Occ=Once]
                                                                                          :: a_a6szh
                                                                                        [LclId] =
                                                                                            [$dMonoid_s6veg
                                                                                             x1_s6veB] \u []
                                                                                                GHC.Base.mappend
                                                                                                    $dMonoid_s6veg
                                                                                                    x1_s6veB
                                                                                                    x1_s6veB;
                                                                                      } in 
                                                                                        g_s6veA
                                                                                            sat_s6veG
                                                                                            sat_s6veH
                                                                                            sat_s6veI;
                                                                                  GHC.Types.True ->
                                                                                      exit1_s6vex
                                                                                          x1_s6veB
                                                                                          z_s6veD;
                                                                                };
                                                                            GHC.Types.True ->
                                                                                let {
                                                                                  sat_s6veK [Occ=Once]
                                                                                    :: b_a6szg
                                                                                  [LclId] =
                                                                                      [$dIntegral_s6vef
                                                                                       lvl12_s6vep
                                                                                       y1_s6veC] \u []
                                                                                          GHC.Real.quot
                                                                                              $dIntegral_s6vef
                                                                                              y1_s6veC
                                                                                              lvl12_s6vep; } in
                                                                                let {
                                                                                  sat_s6veJ [Occ=Once]
                                                                                    :: a_a6szh
                                                                                  [LclId] =
                                                                                      [$dMonoid_s6veg
                                                                                       x1_s6veB] \u []
                                                                                          GHC.Base.mappend
                                                                                              $dMonoid_s6veg
                                                                                              x1_s6veB
                                                                                              x1_s6veB;
                                                                                } in 
                                                                                  g_s6veA
                                                                                      sat_s6veJ
                                                                                      sat_s6veK
                                                                                      z_s6veD;
                                                                          };
                                                                } in 
                                                                  g_s6veA
                                                                      sat_s6veL sat_s6veM x_s6ver;
                                                        GHC.Types.True -> x_s6ver;
                                                      };
                                              };
                                        };
                              } in 
                                let-no-escape {
                                  f_s6veN [Occ=LoopBreakerT[2]] :: a_a6szh -> b_a6szg -> a_a6szh
                                  [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dIntegral_s6vef
                                                $dMonoid_s6veg
                                                lvl12_s6vep
                                                exit_s6veq
                                                f_s6veN] \r [x_s6veO y_s6veP]
                                          case GHC.Real.even $dIntegral_s6vef y_s6veP of {
                                            GHC.Types.False -> exit_s6veq x_s6veO y_s6veP;
                                            GHC.Types.True ->
                                                let {
                                                  sat_s6veS [Occ=Once] :: b_a6szg
                                                  [LclId] =
                                                      [$dIntegral_s6vef lvl12_s6vep y_s6veP] \u []
                                                          GHC.Real.quot
                                                              $dIntegral_s6vef
                                                              y_s6veP
                                                              lvl12_s6vep; } in
                                                let {
                                                  sat_s6veR [Occ=Once] :: a_a6szh
                                                  [LclId] =
                                                      [$dMonoid_s6veg x_s6veO] \u []
                                                          GHC.Base.mappend
                                                              $dMonoid_s6veg x_s6veO x_s6veO;
                                                } in  f_s6veN sat_s6veR sat_s6veS;
                                          };
                                } in  f_s6veN eta1_s6vei eta_s6veh;
                      };
                };
        };

Data.Semigroup.Internal.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     Data.Semigroup.Internal.Alt f a
     -> [Data.Semigroup.Internal.Alt f a]
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6veT ww_s6veU ww1_s6veV]
        let {
          go_s6veW [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL
               -> [Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL]
               -> Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6veT go_s6veW] \r [b_s6veX ds1_s6veY]
                  case ds1_s6veY of {
                    [] -> b_s6veX;
                    : c_s6vf0 [Occ=Once] cs_s6vf1 [Occ=Once] ->
                        let {
                          sat_s6vf2 [Occ=Once] :: f_s6uNK a_s6uNL
                          [LclId] =
                              [go_s6veW c_s6vf0 cs_s6vf1] \u [] go_s6veW c_s6vf0 cs_s6vf1;
                        } in  GHC.Base.<|> w_s6veT b_s6veX sat_s6vf2;
                  };
        } in  go_s6veW ww_s6veU ww1_s6veV;

Data.Semigroup.Internal.$fSemigroupAlt_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Alt f a)
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6vf3 w1_s6vf4]
        case w1_s6vf4 of {
          GHC.Base.:| ww1_s6vf6 [Occ=Once] ww2_s6vf7 [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat w_s6vf3 ww1_s6vf6 ww2_s6vf7;
        };

Data.Semigroup.Internal.$fMonoidAlt_$cmconcat
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     [Data.Semigroup.Internal.Alt f a]
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6vf8 eta_s6vf9]
        let {
          z_s6vfa [Occ=OnceL] :: f_X6tGf a_X6tGh
          [LclId] =
              [$dAlternative_s6vf8] \u []
                  GHC.Base.empty $dAlternative_s6vf8; } in
        let {
          go_s6vfb [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Alt f_X6tGf a_X6tGh]
               -> Data.Semigroup.Internal.Alt f_X6tGf a_X6tGh
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dAlternative_s6vf8 z_s6vfa go_s6vfb] \r [ds_s6vfc]
                  case ds_s6vfc of {
                    [] -> z_s6vfa;
                    : y_s6vfe [Occ=Once] ys_s6vff [Occ=Once] ->
                        let {
                          sat_s6vfg [Occ=Once] :: f_X6tGf a_X6tGh
                          [LclId] =
                              [go_s6vfb ys_s6vff] \u [] go_s6vfb ys_s6vff;
                        } in  GHC.Base.<|> $dAlternative_s6vf8 y_s6vfe sat_s6vfg;
                  };
        } in  go_s6vfb eta_s6vf9;

Data.Semigroup.Internal.$fSemigroupAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A,A)>m] =
    [] \r [$dAlternative_s6vfh]
        let {
          sat_s6vfk [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6vfh] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupAlt_$cstimes
                      $dAlternative_s6vfh eta_B1; } in
        let {
          sat_s6vfj [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF)
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6vfh] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupAlt_$csconcat
                      $dAlternative_s6vfh eta_B1; } in
        let {
          sat_s6vfi [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6vfh] \u [] GHC.Base.<|> $dAlternative_s6vfh;
        } in  GHC.Base.C:Semigroup [sat_s6vfi sat_s6vfj sat_s6vfk];
Data.Semigroup.Internal.$fMonoidAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A,A)>m] =
    [] \r [$dAlternative_s6vfl]
        let {
          sat_s6vfp [Occ=Once]
            :: [Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9]
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6vfl] \r [eta_B1]
                  Data.Semigroup.Internal.$fMonoidAlt_$cmconcat
                      $dAlternative_s6vfl eta_B1; } in
        let {
          sat_s6vfo [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6vfl] \u [] GHC.Base.<|> $dAlternative_s6vfl; } in
        let {
          sat_s6vfn [Occ=Once] :: Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6vfl] \u []
                  GHC.Base.empty $dAlternative_s6vfl; } in
        let {
          sat_s6vfm [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9)
          [LclId] =
              [$dAlternative_s6vfl] \u []
                  Data.Semigroup.Internal.$fSemigroupAlt $dAlternative_s6vfl;
        } in  GHC.Base.C:Monoid [sat_s6vfm sat_s6vfn sat_s6vfo sat_s6vfp];
Data.Semigroup.Internal.$fSemigroupAlt_$cstimes [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     forall b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.Internal.Alt f a
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Str=<L,U(A,U,U,A,A)><L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6vfq $dIntegral_s6vfr]
        let {
          sat_s6vfs [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Alt f_X6tGK a_X6tGM)
          [LclId] =
              [$dAlternative_s6vfq] \u []
                  Data.Semigroup.Internal.$fMonoidAlt $dAlternative_s6vfq;
        } in 
          Data.Semigroup.Internal.stimesMonoid $dIntegral_s6vfr sat_s6vfs;

Data.Semigroup.Internal.$fSemigroupEndo1 [Occ=LoopBreaker]
  :: forall a.
     Data.Semigroup.Internal.Endo a
     -> [Data.Semigroup.Internal.Endo a]
     -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6vft ds1_s6vfu]
        case ds1_s6vfu of {
          [] -> b_s6vft;
          : c_s6vfw [Occ=Once] cs_s6vfx [Occ=Once] ->
              let {
                g_s6vfy [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Data.Semigroup.Internal.Endo a_a6tyX
                [LclId] =
                    [c_s6vfw cs_s6vfx] \u []
                        Data.Semigroup.Internal.$fSemigroupEndo1 c_s6vfw cs_s6vfx; } in
              let {
                sat_s6vfB [Occ=Once] :: a_a6tyX -> a_a6tyX
                [LclId] =
                    [b_s6vft g_s6vfy] \r [x_s6vfz]
                        let {
                          sat_s6vfA [Occ=Once] :: a_a6tyX
                          [LclId] =
                              [g_s6vfy x_s6vfz] \u [] g_s6vfy x_s6vfz;
                        } in  b_s6vft sat_s6vfA;
              } in  sat_s6vfB;
        };

Data.Semigroup.Internal.$fSemigroupEndo_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Endo a)
     -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6vfC]
        case ds_s6vfC of {
          GHC.Base.:| a1_s6vfE [Occ=Once] as_s6vfF [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupEndo1 a1_s6vfE as_s6vfF;
        };

Data.Semigroup.Internal.$fMonoidEndo1 [Occ=LoopBreaker]
  :: forall a. [Data.Semigroup.Internal.Endo a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6vfG eta_s6vfH]
        case ds_s6vfG of {
          [] -> eta_s6vfH;
          : y_s6vfJ [Occ=Once] ys_s6vfK [Occ=Once] ->
              let {
                sat_s6vfL [Occ=Once] :: a_a6tyy
                [LclId] =
                    [eta_s6vfH ys_s6vfK] \u []
                        Data.Semigroup.Internal.$fMonoidEndo1 ys_s6vfK eta_s6vfH;
              } in  y_s6vfJ sat_s6vfL;
        };

Data.Semigroup.Internal.$fSemigroupEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base..
                                         Data.Semigroup.Internal.$fSemigroupEndo_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupEndo_$cstimes];
Data.Semigroup.Internal.$fMonoidEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupEndo
                                      GHC.Base.id
                                      GHC.Base..
                                      Data.Semigroup.Internal.$fMonoidEndo1];
Data.Semigroup.Internal.$fSemigroupEndo_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vfM eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesMonoid
            $dIntegral_s6vfM
            Data.Semigroup.Internal.$fMonoidEndo
            eta_B2
            eta_B1;

lvl8_r6v1e :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: positive multiplier expected"#;

lvl9_r6v1f :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl8_r6v1e of sat_s6vfN {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vfN;
        };

Data.Semigroup.Internal.stimesDefault
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Semigroup a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LLC(C(S))LLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(C(C1(U)),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vfO $dSemigroup_s6vfP eta_s6vfQ eta1_s6vfR]
        case
            GHC.Real.$p1Integral $dIntegral_s6vfO
        of
        $dReal_s6vfS [Dmd=<S(LS(S(C(C(S))L)LLC(C(S))LLLL)L),U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6vfV [Occ=Once] :: b_a6swD
                [LclId] =
                    [$dReal_s6vfS] \u []
                        case GHC.Real.$p1Real $dReal_s6vfS of sat_s6vfU {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6vfU Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6vfS of sat_s6vfT {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s6vfT eta_s6vfQ sat_s6vfV of {
                        GHC.Types.False ->
                            let {
                              $dNum_s6vfX [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a6swD
                              [LclId] =
                                  [$dReal_s6vfS] \u [] GHC.Real.$p1Real $dReal_s6vfS; } in
                            let {
                              lvl12_s6vfY :: b_a6swD
                              [LclId] =
                                  [$dNum_s6vfX] \u [] GHC.Num.fromInteger $dNum_s6vfX lvl7_r6v1d;
                            } in 
                              let-no-escape {
                                exit_s6vfZ [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                  :: a_a6swE -> b_a6swD -> a_a6swE
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s6vfO
                                              $dSemigroup_s6vfP
                                              $dReal_s6vfS
                                              $dNum_s6vfX
                                              lvl12_s6vfY] \r [x_s6vg0 y_s6vg1]
                                        case
                                            GHC.Real.$p2Real $dReal_s6vfS
                                        of
                                        $dEq_s6vg2 [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              case
                                                  GHC.Classes.$p1Ord $dEq_s6vg2
                                              of
                                              $dEq1_s6vg3 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      lvl13_s6vg4 :: b_a6swD
                                                      [LclId] =
                                                          [$dNum_s6vfX] \u []
                                                              GHC.Num.fromInteger
                                                                  $dNum_s6vfX
                                                                  Data.Semigroup.Internal.$fMonoidProduct1;
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq1_s6vg3 y_s6vg1 lvl13_s6vg4
                                                      of
                                                      { GHC.Types.False ->
                                                            let {
                                                              sat_s6vgl [Occ=Once] :: b_a6swD
                                                              [LclId] =
                                                                  [$dIntegral_s6vfO
                                                                   lvl12_s6vfY
                                                                   y_s6vg1] \u []
                                                                      GHC.Real.quot
                                                                          $dIntegral_s6vfO
                                                                          y_s6vg1
                                                                          lvl12_s6vfY; } in
                                                            let {
                                                              sat_s6vgk [Occ=Once] :: a_a6swE
                                                              [LclId] =
                                                                  [$dSemigroup_s6vfP x_s6vg0] \u []
                                                                      GHC.Base.<>
                                                                          $dSemigroup_s6vfP
                                                                          x_s6vg0
                                                                          x_s6vg0;
                                                            } in 
                                                              let-no-escape {
                                                                exit1_s6vg6 [Occ=OnceL!T[2],
                                                                             Dmd=<C(C(S)),C(C1(U))>]
                                                                  :: a_a6swE -> a_a6swE -> a_a6swE
                                                                [LclId[JoinId(2)],
                                                                 Arity=2,
                                                                 Str=<L,U><L,U>,
                                                                 Unf=OtherCon []] =
                                                                    sat-only [$dSemigroup_s6vfP] \r [x1_s6vg7
                                                                                                     z_s6vg8]
                                                                        GHC.Base.<>
                                                                            $dSemigroup_s6vfP
                                                                            x1_s6vg7
                                                                            z_s6vg8;
                                                              } in 
                                                                let-no-escape {
                                                                  g_s6vg9 [Occ=LoopBreakerT[3]]
                                                                    :: a_a6swE
                                                                       -> b_a6swD
                                                                       -> a_a6swE
                                                                       -> a_a6swE
                                                                  [LclId[JoinId(3)],
                                                                   Arity=3,
                                                                   Str=<L,U><L,U><L,U>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [$dIntegral_s6vfO
                                                                                $dSemigroup_s6vfP
                                                                                lvl12_s6vfY
                                                                                $dEq1_s6vg3
                                                                                lvl13_s6vg4
                                                                                exit1_s6vg6
                                                                                g_s6vg9] \r [x1_s6vga
                                                                                             y1_s6vgb
                                                                                             z_s6vgc]
                                                                          case
                                                                              GHC.Real.even
                                                                                  $dIntegral_s6vfO
                                                                                  y1_s6vgb
                                                                          of
                                                                          { GHC.Types.False ->
                                                                                case
                                                                                    GHC.Classes.==
                                                                                        $dEq1_s6vg3
                                                                                        y1_s6vgb
                                                                                        lvl13_s6vg4
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s6vgh [Occ=Once]
                                                                                          :: a_a6swE
                                                                                        [LclId] =
                                                                                            [$dSemigroup_s6vfP
                                                                                             x1_s6vga
                                                                                             z_s6vgc] \u []
                                                                                                GHC.Base.<>
                                                                                                    $dSemigroup_s6vfP
                                                                                                    x1_s6vga
                                                                                                    z_s6vgc; } in
                                                                                      let {
                                                                                        sat_s6vgg [Occ=Once]
                                                                                          :: b_a6swD
                                                                                        [LclId] =
                                                                                            [$dIntegral_s6vfO
                                                                                             lvl12_s6vfY
                                                                                             y1_s6vgb] \u []
                                                                                                GHC.Real.quot
                                                                                                    $dIntegral_s6vfO
                                                                                                    y1_s6vgb
                                                                                                    lvl12_s6vfY; } in
                                                                                      let {
                                                                                        sat_s6vgf [Occ=Once]
                                                                                          :: a_a6swE
                                                                                        [LclId] =
                                                                                            [$dSemigroup_s6vfP
                                                                                             x1_s6vga] \u []
                                                                                                GHC.Base.<>
                                                                                                    $dSemigroup_s6vfP
                                                                                                    x1_s6vga
                                                                                                    x1_s6vga;
                                                                                      } in 
                                                                                        g_s6vg9
                                                                                            sat_s6vgf
                                                                                            sat_s6vgg
                                                                                            sat_s6vgh;
                                                                                  GHC.Types.True ->
                                                                                      exit1_s6vg6
                                                                                          x1_s6vga
                                                                                          z_s6vgc;
                                                                                };
                                                                            GHC.Types.True ->
                                                                                let {
                                                                                  sat_s6vgj [Occ=Once]
                                                                                    :: b_a6swD
                                                                                  [LclId] =
                                                                                      [$dIntegral_s6vfO
                                                                                       lvl12_s6vfY
                                                                                       y1_s6vgb] \u []
                                                                                          GHC.Real.quot
                                                                                              $dIntegral_s6vfO
                                                                                              y1_s6vgb
                                                                                              lvl12_s6vfY; } in
                                                                                let {
                                                                                  sat_s6vgi [Occ=Once]
                                                                                    :: a_a6swE
                                                                                  [LclId] =
                                                                                      [$dSemigroup_s6vfP
                                                                                       x1_s6vga] \u []
                                                                                          GHC.Base.<>
                                                                                              $dSemigroup_s6vfP
                                                                                              x1_s6vga
                                                                                              x1_s6vga;
                                                                                } in 
                                                                                  g_s6vg9
                                                                                      sat_s6vgi
                                                                                      sat_s6vgj
                                                                                      z_s6vgc;
                                                                          };
                                                                } in 
                                                                  g_s6vg9
                                                                      sat_s6vgk sat_s6vgl x_s6vg0;
                                                        GHC.Types.True -> x_s6vg0;
                                                      };
                                              };
                                        };
                              } in 
                                let-no-escape {
                                  f_s6vgm [Occ=LoopBreakerT[2]] :: a_a6swE -> b_a6swD -> a_a6swE
                                  [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dIntegral_s6vfO
                                                $dSemigroup_s6vfP
                                                lvl12_s6vfY
                                                exit_s6vfZ
                                                f_s6vgm] \r [x_s6vgn y_s6vgo]
                                          case GHC.Real.even $dIntegral_s6vfO y_s6vgo of {
                                            GHC.Types.False -> exit_s6vfZ x_s6vgn y_s6vgo;
                                            GHC.Types.True ->
                                                let {
                                                  sat_s6vgr [Occ=Once] :: b_a6swD
                                                  [LclId] =
                                                      [$dIntegral_s6vfO lvl12_s6vfY y_s6vgo] \u []
                                                          GHC.Real.quot
                                                              $dIntegral_s6vfO
                                                              y_s6vgo
                                                              lvl12_s6vfY; } in
                                                let {
                                                  sat_s6vgq [Occ=Once] :: a_a6swE
                                                  [LclId] =
                                                      [$dSemigroup_s6vfP x_s6vgn] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup_s6vfP x_s6vgn x_s6vgn;
                                                } in  f_s6vgm sat_s6vgq sat_s6vgr;
                                          };
                                } in  f_s6vgm eta1_s6vfR eta_s6vfQ;
                        GHC.Types.True -> lvl9_r6v1f;
                      };
                };
        };

lvl10_r6v1g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: Maybe, negative multiplier"#;

Data.Semigroup.Internal.stimesMaybe1 :: forall a. GHC.Base.Maybe a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl10_r6v1g of sat_s6vgs {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vgs;
        };

Data.Semigroup.Internal.stimesMaybe
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Semigroup a) =>
     b -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=4,
 Str=<L,U(U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vgt $dSemigroup_s6vgu eta_s6vgv eta1_s6vgw]
        case eta1_s6vgw of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_s6vgy [Occ=Once] ->
              case
                  GHC.Real.$p1Integral $dIntegral_s6vgt
              of
              $dReal_s6vgz [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_s6vgC [Occ=Once] :: b_a6swh
                      [LclId] =
                          [$dReal_s6vgz] \u []
                              case GHC.Real.$p1Real $dReal_s6vgz of sat_s6vgB {
                                __DEFAULT ->
                                    GHC.Num.fromInteger
                                        sat_s6vgB Data.Semigroup.Internal.$fMonoidSum1;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_s6vgz of sat_s6vgA {
                        __DEFAULT ->
                            case GHC.Classes.compare sat_s6vgA eta_s6vgv sat_s6vgC of {
                              GHC.Types.LT -> Data.Semigroup.Internal.stimesMaybe1;
                              GHC.Types.EQ -> GHC.Base.Nothing [];
                              GHC.Types.GT ->
                                  let {
                                    sat_s6vgE [Occ=Once] :: a_a6swi
                                    [LclId] =
                                        [$dIntegral_s6vgt
                                         $dSemigroup_s6vgu
                                         eta_s6vgv
                                         a1_s6vgy] \u []
                                            GHC.Base.stimes
                                                $dSemigroup_s6vgu
                                                $dIntegral_s6vgt
                                                eta_s6vgv
                                                a1_s6vgy;
                                  } in  GHC.Base.Just [sat_s6vgE];
                            };
                      };
              };
        };

lvl11_r6v1h :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: [], negative multiplier"#;

Data.Semigroup.Internal.stimesList1 :: forall a. [a]
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_r6v1h of sat_s6vgF {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6vgF;
        };

Data.Semigroup.Internal.stimesList
  :: forall b a. GHC.Real.Integral b => b -> [a] -> [a]
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6vgG eta_s6vgH eta1_s6vgI]
        case
            GHC.Real.$p1Integral $dIntegral_s6vgG
        of
        $dReal_s6vgJ [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,C(C1(U)),A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s6vgK [Dmd=<L,U(A,C(C1(U)),A,A,A,A,C(U))>]
                  :: GHC.Num.Num b_a6svr
                [LclId] =
                    [$dReal_s6vgJ] \u [] GHC.Real.$p1Real $dReal_s6vgJ;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s6vgJ
                of
                $dOrd_s6vgL [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s6vgM [Occ=Once] :: b_a6svr
                        [LclId] =
                            [$dNum_s6vgK] \u []
                                GHC.Num.fromInteger
                                    $dNum_s6vgK Data.Semigroup.Internal.$fMonoidSum1;
                      } in 
                        case GHC.Classes.< $dOrd_s6vgL eta_s6vgH sat_s6vgM of {
                          GHC.Types.False ->
                              let {
                                lvl12_s6vgO [Occ=OnceL] :: b_a6svr
                                [LclId] =
                                    [$dNum_s6vgK] \u []
                                        GHC.Num.fromInteger
                                            $dNum_s6vgK
                                            Data.Semigroup.Internal.$fMonoidProduct1; } in
                              let {
                                lvl13_s6vgP [Occ=OnceL] :: b_a6svr
                                [LclId] =
                                    [$dNum_s6vgK] \u []
                                        GHC.Num.fromInteger
                                            $dNum_s6vgK Data.Semigroup.Internal.$fMonoidSum1;
                              } in 
                                case
                                    GHC.Classes.$p1Ord $dOrd_s6vgL
                                of
                                $dEq_s6vgQ [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                { __DEFAULT ->
                                      let {
                                        rep_s6vgR [Occ=LoopBreaker] :: b_a6svr -> [a_a6svs]
                                        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                            sat-only [eta1_s6vgI
                                                      $dNum_s6vgK
                                                      lvl12_s6vgO
                                                      lvl13_s6vgP
                                                      $dEq_s6vgQ
                                                      rep_s6vgR] \r [ds_s6vgS]
                                                case
                                                    GHC.Classes.== $dEq_s6vgQ ds_s6vgS lvl13_s6vgP
                                                of
                                                { GHC.Types.False ->
                                                      let {
                                                        sat_s6vgV [Occ=Once, Dmd=<L,1*U>]
                                                          :: [a_a6svs]
                                                        [LclId] =
                                                            [$dNum_s6vgK
                                                             lvl12_s6vgO
                                                             rep_s6vgR
                                                             ds_s6vgS] \s []
                                                                let {
                                                                  sat_s6vgU [Occ=Once] :: b_a6svr
                                                                  [LclId] =
                                                                      [$dNum_s6vgK
                                                                       lvl12_s6vgO
                                                                       ds_s6vgS] \u []
                                                                          GHC.Num.-
                                                                              $dNum_s6vgK
                                                                              ds_s6vgS
                                                                              lvl12_s6vgO;
                                                                } in  rep_s6vgR sat_s6vgU;
                                                      } in  GHC.Base.++ eta1_s6vgI sat_s6vgV;
                                                  GHC.Types.True -> [] [];
                                                };
                                      } in  rep_s6vgR eta_s6vgH;
                                };
                          GHC.Types.True -> Data.Semigroup.Internal.stimesList1;
                        };
                };
        };

Data.Semigroup.Internal.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Semigroup.Internal.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$trModule4];

Data.Semigroup.Internal.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Semigroup.Internal"#;

Data.Semigroup.Internal.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$trModule2];

Data.Semigroup.Internal.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Semigroup.Internal.$trModule3
                                     Data.Semigroup.Internal.$trModule1];

$krep_r6v1i :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep1_r6v1j :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r6v1k :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep1_r6v1j];

$krep3_r6v1l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j
                                         GHC.Types.krep$*];

Data.Semigroup.Internal.$tcAlt1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r6v1l $krep3_r6v1l];

$krep4_r6v1m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_r6v1n :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep6_r6v1o :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_r6v1m $krep5_r6v1n];

Data.Semigroup.Internal.$tcDual1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadDual5];

Data.Semigroup.Internal.$tcDual :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14711416616195557841##
                                    10971851269997195248##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcDual1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep7_r6v1p :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r6v1j GHC.Types.[]];

$krep8_r6v1q :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcDual
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Dual1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep8_r6v1q];

Data.Semigroup.Internal.$tc'Dual3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Dual"#;

Data.Semigroup.Internal.$tc'Dual2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Dual3];

Data.Semigroup.Internal.$tc'Dual :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15885009659242865261##
                                    15931193389986079612##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Dual2
                                    1#
                                    Data.Semigroup.Internal.$tc'Dual1];

Data.Semigroup.Internal.$tcEndo2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Endo"#;

Data.Semigroup.Internal.$tcEndo1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tcEndo2];

Data.Semigroup.Internal.$tcEndo :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16820921632006328603##
                                    4981834339379479823##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcEndo1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r6v1r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcEndo
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Endo1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6v1k $krep9_r6v1r];

Data.Semigroup.Internal.$tc'Endo3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Endo"#;

Data.Semigroup.Internal.$tc'Endo2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Endo3];

Data.Semigroup.Internal.$tc'Endo :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [156297185665537802##
                                    8988325904501215692##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Endo2
                                    1#
                                    Data.Semigroup.Internal.$tc'Endo1];

Data.Semigroup.Internal.$tcAll1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAll13];

Data.Semigroup.Internal.$tcAll :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14149274874874504208##
                                    8164254778609961234##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAll1
                                    0#
                                    GHC.Types.krep$*];

$krep10_r6v1s :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAll
                                              GHC.Types.[]];

Data.Semigroup.Internal.$tc'All1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r6v1i $krep10_r6v1s];

Data.Semigroup.Internal.$tc'All3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'All"#;

Data.Semigroup.Internal.$tc'All2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'All3];

Data.Semigroup.Internal.$tc'All :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1168494541548489787##
                                    10689931498683547374##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'All2
                                    0#
                                    Data.Semigroup.Internal.$tc'All1];

Data.Semigroup.Internal.$tcAny1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAny6];

Data.Semigroup.Internal.$tcAny :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11600287624241135668##
                                    17600231731807245316##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAny1
                                    0#
                                    GHC.Types.krep$*];

$krep11_r6v1t :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAny
                                              GHC.Types.[]];

Data.Semigroup.Internal.$tc'Any1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r6v1i $krep11_r6v1t];

Data.Semigroup.Internal.$tc'Any3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Any"#;

Data.Semigroup.Internal.$tc'Any2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Any3];

Data.Semigroup.Internal.$tc'Any :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16164188984560189013##
                                    110490866064676064##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Any2
                                    0#
                                    Data.Semigroup.Internal.$tc'Any1];

Data.Semigroup.Internal.$tcSum1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadSum5];

Data.Semigroup.Internal.$tcSum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7521450980204740829##
                                    14029043805042477297##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcSum1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep12_r6v1u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcSum
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Sum1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep12_r6v1u];

Data.Semigroup.Internal.$tc'Sum3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Sum"#;

Data.Semigroup.Internal.$tc'Sum2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Sum3];

Data.Semigroup.Internal.$tc'Sum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7144872330799658717##
                                    13465414667749873698##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Sum2
                                    1#
                                    Data.Semigroup.Internal.$tc'Sum1];

Data.Semigroup.Internal.$tcProduct1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadProduct5];

Data.Semigroup.Internal.$tcProduct :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12271745360620305859##
                                    5747185732973757022##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcProduct1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_r6v1v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcProduct
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Product1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep13_r6v1v];

Data.Semigroup.Internal.$tc'Product3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Product"#;

Data.Semigroup.Internal.$tc'Product2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Product3];

Data.Semigroup.Internal.$tc'Product :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3191278115598904989##
                                    12638872580785847167##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Product2
                                    1#
                                    Data.Semigroup.Internal.$tc'Product1];

Data.Semigroup.Internal.$tcAlt2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAlt5];

Data.Semigroup.Internal.$tcAlt :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7601313288863504805##
                                    2369500163797891218##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAlt2
                                    1#
                                    Data.Semigroup.Internal.$tcAlt1];

$krep14_r6v1w :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_r6v1n GHC.Types.[]];

$krep15_r6v1x :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_r6v1m $krep14_r6v1w];

$krep16_r6v1y :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r6v1j $krep15_r6v1x];

$krep17_r6v1z :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAlt
                                              $krep16_r6v1y];

Data.Semigroup.Internal.$tc'Alt1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r6v1o $krep17_r6v1z];

Data.Semigroup.Internal.$tc'Alt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Alt"#;

Data.Semigroup.Internal.$tc'Alt2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Alt3];

Data.Semigroup.Internal.$tc'Alt :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1436877498177162483##
                                    16937142347825669760##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Alt2
                                    3#
                                    Data.Semigroup.Internal.$tc'Alt1];


==================== Pre unarise: ====================
2018-03-16 16:01:53.643028561 UTC

Data.Semigroup.Internal.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     Data.Semigroup.Internal.Dual a
     -> [Data.Semigroup.Internal.Dual a]
     -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6ALv ww_s6ALw ww1_s6ALx]
        let {
          go_s6ALy [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Dual a_s6uKL
               -> [Data.Semigroup.Internal.Dual a_s6uKL]
               -> Data.Semigroup.Internal.Dual a_s6uKL
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6ALv go_s6ALy] \r [b_s6ALz ds1_s6ALA]
                  case ds1_s6ALA of {
                    [] -> b_s6ALz;
                    : c_s6ALC [Occ=Once] cs_s6ALD [Occ=Once] ->
                        let {
                          sat_s6ALE [Occ=Once] :: a_s6uKL
                          [LclId] =
                              [go_s6ALy c_s6ALC cs_s6ALD] \u [] go_s6ALy c_s6ALC cs_s6ALD;
                        } in  GHC.Base.<> w_s6ALv sat_s6ALE b_s6ALz;
                  };
        } in  go_s6ALy ww_s6ALw ww1_s6ALx;

Data.Semigroup.Internal.$fSemigroupDual_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Dual a)
     -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6ALF w1_s6ALG]
        case w1_s6ALG of {
          GHC.Base.:| ww1_s6ALI [Occ=Once] ww2_s6ALJ [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat1 w_s6ALF ww1_s6ALI ww2_s6ALJ;
        };

Data.Semigroup.Internal.$fSemigroupDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s6ALK]
        let {
          sat_s6ALS [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6ALK] \r [$dIntegral_s6ALP n_s6ALQ ds_s6ALR]
                  GHC.Base.stimes
                      $dSemigroup_s6ALK $dIntegral_s6ALP n_s6ALQ ds_s6ALR; } in
        let {
          sat_s6ALO [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Dual a_X6tId)
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6ALK] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupDual_$csconcat
                      $dSemigroup_s6ALK eta_B1; } in
        let {
          sat_s6ALN [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6ALK] \r [ds_s6ALL ds1_s6ALM]
                  GHC.Base.<> $dSemigroup_s6ALK ds1_s6ALM ds_s6ALL;
        } in  GHC.Base.C:Semigroup [sat_s6ALN sat_s6ALO sat_s6ALS];

Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6ALT]
        let {
          sat_s6ALU [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a6tBw
          [LclId] =
              [$dMonoid_s6ALT] \u [] GHC.Base.$p1Monoid $dMonoid_s6ALT;
        } in  Data.Semigroup.Internal.$fSemigroupDual sat_s6ALU;

$cmappend_r6v15
  :: forall a.
     GHC.Base.Monoid a =>
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dMonoid_s6ALV ds_s6ALW ds1_s6ALX]
        case GHC.Base.$p1Monoid $dMonoid_s6ALV of sat_s6ALY {
          __DEFAULT -> GHC.Base.<> sat_s6ALY ds1_s6ALX ds_s6ALW;
        };

Data.Semigroup.Internal.$fMonoidDual_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Base.Monoid a =>
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $cmappend_r6v15 eta_B3 eta_B2 eta_B1;

Data.Semigroup.Internal.$fMonoidDual_$cmconcat
  :: forall a.
     GHC.Base.Monoid a =>
     [Data.Semigroup.Internal.Dual a] -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6ALZ eta_s6AM0]
        let {
          lvl12_s6AM1 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X6tHX
          [LclId] =
              [$dMonoid_s6ALZ] \u [] GHC.Base.$p1Monoid $dMonoid_s6ALZ; } in
        let {
          z_s6AM2 [Occ=OnceL] :: a_X6tHX
          [LclId] =
              [$dMonoid_s6ALZ] \u [] GHC.Base.mempty $dMonoid_s6ALZ; } in
        let {
          go_s6AM3 [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Dual a_X6tHX]
               -> Data.Semigroup.Internal.Dual a_X6tHX
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [lvl12_s6AM1 z_s6AM2 go_s6AM3] \r [ds_s6AM4]
                  case ds_s6AM4 of {
                    [] -> z_s6AM2;
                    : y_s6AM6 [Occ=Once] ys_s6AM7 [Occ=Once] ->
                        let {
                          sat_s6AM8 [Occ=Once] :: a_X6tHX
                          [LclId] =
                              [go_s6AM3 ys_s6AM7] \u [] go_s6AM3 ys_s6AM7;
                        } in  GHC.Base.<> lvl12_s6AM1 sat_s6AM8 y_s6AM6;
                  };
        } in  go_s6AM3 eta_s6AM0;

Data.Semigroup.Internal.$fMonoidDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s6AM9]
        let {
          sat_s6AMd [Occ=Once]
            :: [Data.Semigroup.Internal.Dual a_a6tBw]
               -> Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6AM9] \r [eta_B1]
                  Data.Semigroup.Internal.$fMonoidDual_$cmconcat
                      $dMonoid_s6AM9 eta_B1; } in
        let {
          sat_s6AMc [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6tBw
               -> Data.Semigroup.Internal.Dual a_a6tBw
               -> Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6AM9] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fMonoidDual_$cmappend
                      $dMonoid_s6AM9 eta_B2 eta_B1; } in
        let {
          sat_s6AMb [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6AM9] \u [] GHC.Base.mempty $dMonoid_s6AM9; } in
        let {
          sat_s6AMa [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a_a6tBw)
          [LclId] =
              [$dMonoid_s6AM9] \u []
                  Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid $dMonoid_s6AM9;
        } in  GHC.Base.C:Monoid [sat_s6AMa sat_s6AMb sat_s6AMc sat_s6AMd];

Data.Semigroup.Internal.$fFunctorDual2
  :: forall a b. (a -> b) -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6AMe] v_s6AMe;

Data.Semigroup.Internal.$fFunctorDual1 :: forall b a. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6AMf ds_s6AMg] x_s6AMf;

Data.Semigroup.Internal.$fFunctorDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeDual3
  :: forall a b.
     Data.Semigroup.Internal.Dual (a -> b)
     -> Data.Semigroup.Internal.Dual (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6AMh] v_s6AMh;

Data.Semigroup.Internal.$fApplicativeDual4 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6AMi] v_s6AMi;

Data.Semigroup.Internal.$fApplicativeDual2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Dual a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6AMj x_s6AMk] f1_s6AMj x_s6AMk;

Data.Semigroup.Internal.$fApplicativeDual_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6AMl a2_s6AMm] a2_s6AMm;

Data.Semigroup.Internal.$fApplicativeDual1
  :: forall b a.
     Data.Semigroup.Internal.Dual a
     -> b -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6AMn ds_s6AMo] x_s6AMn;

Data.Semigroup.Internal.$fApplicativeDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorDual
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeDual3
                                           Data.Semigroup.Internal.$fApplicativeDual2
                                           Data.Semigroup.Internal.$fApplicativeDual_$c*>
                                           Data.Semigroup.Internal.$fApplicativeDual1];

Data.Semigroup.Internal.$fSemigroupSum1
  :: forall a.
     GHC.Num.Num a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.Sum a -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><L,1*U(A,A,A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6AMp $dIntegral_s6AMq n_s6AMr ds_s6AMs]
        let {
          sat_s6AMu [Occ=Once] :: a_a6two
          [LclId] =
              [$dNum_s6AMp $dIntegral_s6AMq n_s6AMr] \u []
                  let {
                    sat_s6AMt [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [$dIntegral_s6AMq n_s6AMr] \u []
                            GHC.Real.toInteger $dIntegral_s6AMq n_s6AMr;
                  } in  GHC.Num.fromInteger $dNum_s6AMp sat_s6AMt;
        } in  GHC.Num.* $dNum_s6AMp sat_s6AMu ds_s6AMs;

Data.Semigroup.Internal.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Sum a
     -> [Data.Semigroup.Internal.Sum a] -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6AMv ww_s6AMw ww1_s6AMx]
        let {
          go_s6AMy [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Sum a_s6uL0
               -> [Data.Semigroup.Internal.Sum a_s6uL0]
               -> Data.Semigroup.Internal.Sum a_s6uL0
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6AMv go_s6AMy] \r [b_s6AMz ds1_s6AMA]
                  case ds1_s6AMA of {
                    [] -> b_s6AMz;
                    : c_s6AMC [Occ=Once] cs_s6AMD [Occ=Once] ->
                        let {
                          sat_s6AME [Occ=Once] :: a_s6uL0
                          [LclId] =
                              [go_s6AMy c_s6AMC cs_s6AMD] \u [] go_s6AMy c_s6AMC cs_s6AMD;
                        } in  GHC.Num.+ w_s6AMv b_s6AMz sat_s6AME;
                  };
        } in  go_s6AMy ww_s6AMw ww1_s6AMx;

Data.Semigroup.Internal.$fSemigroupSum_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Sum a)
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A,A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6AMF w1_s6AMG]
        case w1_s6AMG of {
          GHC.Base.:| ww1_s6AMI [Occ=Once] ww2_s6AMJ [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat3 w_s6AMF ww1_s6AMI ww2_s6AMJ;
        };

Data.Semigroup.Internal.$fSemigroupSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U,A,C(C1(U)),A,A,A,C(U))>m] =
    [] \r [$dNum_s6AMK]
        let {
          sat_s6AMN [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6AMK] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fSemigroupSum1
                      $dNum_s6AMK eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6AMM [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Sum a_X6tDl)
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6AMK] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupSum_$csconcat
                      $dNum_s6AMK eta_B1; } in
        let {
          sat_s6AML [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6AMK] \u [] GHC.Num.+ $dNum_s6AMK;
        } in  GHC.Base.C:Semigroup [sat_s6AML sat_s6AMM sat_s6AMN];

Data.Semigroup.Internal.$fMonoidSum1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Semigroup.Internal.$fMonoidSum2
  :: forall a. GHC.Num.Num a => a
[GblId,
 Arity=1,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6AMO]
        GHC.Num.fromInteger
            $dNum_s6AMO Data.Semigroup.Internal.$fMonoidSum1;

Data.Semigroup.Internal.$fMonoidSum_$cmconcat
  :: forall a.
     GHC.Num.Num a =>
     [Data.Semigroup.Internal.Sum a] -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6AMP]
        let {
          z_s6AMQ [Occ=OnceL] :: a_X6tD4
          [LclId] =
              [$dNum_s6AMP] \u []
                  GHC.Num.fromInteger
                      $dNum_s6AMP Data.Semigroup.Internal.$fMonoidSum1; } in
        let {
          go_s6AMR [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Sum a_X6tD4]
               -> Data.Semigroup.Internal.Sum a_X6tD4
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dNum_s6AMP z_s6AMQ go_s6AMR] \r [ds_s6AMS]
                  case ds_s6AMS of {
                    [] -> z_s6AMQ;
                    : y_s6AMU [Occ=Once] ys_s6AMV [Occ=Once] ->
                        let {
                          sat_s6AMW [Occ=Once] :: a_X6tD4
                          [LclId] =
                              [go_s6AMR ys_s6AMV] \u [] go_s6AMR ys_s6AMV;
                        } in  GHC.Num.+ $dNum_s6AMP y_s6AMU sat_s6AMW;
                  };
        } in  go_s6AMR;

Data.Semigroup.Internal.$fMonoidSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(U,A,C(C1(U)),A,A,A,C(U))>m] =
    [] \r [$dNum_s6AMX]
        let {
          sat_s6AN1 [Occ=Once]
            :: [Data.Semigroup.Internal.Sum a_X6tD2]
               -> Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6AMX] \u []
                  Data.Semigroup.Internal.$fMonoidSum_$cmconcat $dNum_s6AMX; } in
        let {
          sat_s6AN0 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_X6tD2
               -> Data.Semigroup.Internal.Sum a_X6tD2
               -> Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6AMX] \u [] GHC.Num.+ $dNum_s6AMX; } in
        let {
          sat_s6AMZ [Occ=Once] :: Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6AMX] \u []
                  Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6AMX; } in
        let {
          sat_s6AMY [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Sum a_X6tD2)
          [LclId] =
              [$dNum_s6AMX] \u []
                  Data.Semigroup.Internal.$fSemigroupSum $dNum_s6AMX;
        } in  GHC.Base.C:Monoid [sat_s6AMY sat_s6AMZ sat_s6AN0 sat_s6AN1];

Data.Semigroup.Internal.$fFunctorSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeSum3
  :: forall a b.
     Data.Semigroup.Internal.Sum (a -> b)
     -> Data.Semigroup.Internal.Sum (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6AN2] v_s6AN2;

Data.Semigroup.Internal.$fApplicativeSum2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Sum a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6AN3 x_s6AN4] f1_s6AN3 x_s6AN4;

Data.Semigroup.Internal.$fApplicativeSum_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6AN5 a2_s6AN6] a2_s6AN6;

Data.Semigroup.Internal.$fApplicativeSum1
  :: forall b a.
     Data.Semigroup.Internal.Sum a -> b -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6AN7 ds_s6AN8] x_s6AN7;

Data.Semigroup.Internal.$fApplicativeSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorSum
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeSum3
                                           Data.Semigroup.Internal.$fApplicativeSum2
                                           Data.Semigroup.Internal.$fApplicativeSum_$c*>
                                           Data.Semigroup.Internal.$fApplicativeSum1];

Data.Semigroup.Internal.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Product a
     -> [Data.Semigroup.Internal.Product a]
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6AN9 ww_s6ANa ww1_s6ANb]
        let {
          go_s6ANc [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Product a_s6uLe
               -> [Data.Semigroup.Internal.Product a_s6uLe]
               -> Data.Semigroup.Internal.Product a_s6uLe
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6AN9 go_s6ANc] \r [b_s6ANd ds1_s6ANe]
                  case ds1_s6ANe of {
                    [] -> b_s6ANd;
                    : c_s6ANg [Occ=Once] cs_s6ANh [Occ=Once] ->
                        let {
                          sat_s6ANi [Occ=Once] :: a_s6uLe
                          [LclId] =
                              [go_s6ANc c_s6ANg cs_s6ANh] \u [] go_s6ANc c_s6ANg cs_s6ANh;
                        } in  GHC.Num.* w_s6AN9 b_s6ANd sat_s6ANi;
                  };
        } in  go_s6ANc ww_s6ANa ww1_s6ANb;

Data.Semigroup.Internal.$fSemigroupProduct_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Product a)
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6ANj w1_s6ANk]
        case w1_s6ANk of {
          GHC.Base.:| ww1_s6ANm [Occ=Once] ww2_s6ANn [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat2 w_s6ANj ww1_s6ANm ww2_s6ANn;
        };

Data.Semigroup.Internal.$fSemigroupProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A,A,A,C(U))>m] =
    [] \r [$dNum_s6ANo]
        let {
          sat_s6ANu [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6ANo] \r [$dIntegral_s6ANr n_s6ANs ds_s6ANt]
                  GHC.Real.^ $dNum_s6ANo $dIntegral_s6ANr ds_s6ANt n_s6ANs; } in
        let {
          sat_s6ANq [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Product a_X6tB3)
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6ANo] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupProduct_$csconcat
                      $dNum_s6ANo eta_B1; } in
        let {
          sat_s6ANp [Occ=Once]
            :: Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6ANo] \u [] GHC.Num.* $dNum_s6ANo;
        } in  GHC.Base.C:Semigroup [sat_s6ANp sat_s6ANq sat_s6ANu];

sat_s6ANv :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s6ANw :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6ANv GHC.Types.[]];

Data.Semigroup.Internal.$fMonoidProduct1
  :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6ANw;

Data.Semigroup.Internal.$fMonoidProduct2
  :: forall a. GHC.Num.Num a => a
[GblId,
 Arity=1,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6ANx]
        GHC.Num.fromInteger
            $dNum_s6ANx Data.Semigroup.Internal.$fMonoidProduct1;

Data.Semigroup.Internal.$fMonoidProduct_$cmconcat
  :: forall a.
     GHC.Num.Num a =>
     [Data.Semigroup.Internal.Product a]
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6ANy]
        let {
          z_s6ANz [Occ=OnceL] :: a_X6tAM
          [LclId] =
              [$dNum_s6ANy] \u []
                  GHC.Num.fromInteger
                      $dNum_s6ANy Data.Semigroup.Internal.$fMonoidProduct1; } in
        let {
          go_s6ANA [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Product a_X6tAM]
               -> Data.Semigroup.Internal.Product a_X6tAM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dNum_s6ANy z_s6ANz go_s6ANA] \r [ds_s6ANB]
                  case ds_s6ANB of {
                    [] -> z_s6ANz;
                    : y_s6AND [Occ=Once] ys_s6ANE [Occ=Once] ->
                        let {
                          sat_s6ANF [Occ=Once] :: a_X6tAM
                          [LclId] =
                              [go_s6ANA ys_s6ANE] \u [] go_s6ANA ys_s6ANE;
                        } in  GHC.Num.* $dNum_s6ANy y_s6AND sat_s6ANF;
                  };
        } in  go_s6ANA;

Data.Semigroup.Internal.$fMonoidProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A,A,A,C(U))>m] =
    [] \r [$dNum_s6ANG]
        let {
          sat_s6ANK [Occ=Once]
            :: [Data.Semigroup.Internal.Product a_X6tAK]
               -> Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6ANG] \u []
                  Data.Semigroup.Internal.$fMonoidProduct_$cmconcat $dNum_s6ANG; } in
        let {
          sat_s6ANJ [Occ=Once]
            :: Data.Semigroup.Internal.Product a_X6tAK
               -> Data.Semigroup.Internal.Product a_X6tAK
               -> Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6ANG] \u [] GHC.Num.* $dNum_s6ANG; } in
        let {
          sat_s6ANI [Occ=Once] :: Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6ANG] \u []
                  Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6ANG; } in
        let {
          sat_s6ANH [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Product a_X6tAK)
          [LclId] =
              [$dNum_s6ANG] \u []
                  Data.Semigroup.Internal.$fSemigroupProduct $dNum_s6ANG;
        } in  GHC.Base.C:Monoid [sat_s6ANH sat_s6ANI sat_s6ANJ sat_s6ANK];

Data.Semigroup.Internal.$fFunctorProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeProduct3
  :: forall a b.
     Data.Semigroup.Internal.Product (a -> b)
     -> Data.Semigroup.Internal.Product (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6ANL] v_s6ANL;

Data.Semigroup.Internal.$fApplicativeProduct2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Product a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6ANM x_s6ANN] f1_s6ANM x_s6ANN;

Data.Semigroup.Internal.$fApplicativeProduct_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6ANO a2_s6ANP] a2_s6ANP;

Data.Semigroup.Internal.$fApplicativeProduct1
  :: forall b a.
     Data.Semigroup.Internal.Product a
     -> b -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6ANQ ds_s6ANR] x_s6ANQ;

Data.Semigroup.Internal.$fApplicativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorProduct
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeProduct3
                                           Data.Semigroup.Internal.$fApplicativeProduct2
                                           Data.Semigroup.Internal.$fApplicativeProduct_$c*>
                                           Data.Semigroup.Internal.$fApplicativeProduct1];

Data.Semigroup.Internal.$fFunctorAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     GHC.Base.Functor (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dFunctor_s6ANS]
        let {
          sat_s6ANU [Occ=Once]
            :: forall a b.
               a
               -> Data.Semigroup.Internal.Alt f_a6tow b
               -> Data.Semigroup.Internal.Alt f_a6tow a
          [LclId] =
              [$dFunctor_s6ANS] \u [] GHC.Base.<$ $dFunctor_s6ANS; } in
        let {
          sat_s6ANT [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Semigroup.Internal.Alt f_a6tow a
               -> Data.Semigroup.Internal.Alt f_a6tow b
          [LclId] =
              [$dFunctor_s6ANS] \u [] GHC.Base.fmap $dFunctor_s6ANS;
        } in  GHC.Base.C:Functor [sat_s6ANT sat_s6ANU];

Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Functor (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s6ANV]
        let {
          sat_s6ANW [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_a6tkt
          [LclId] =
              [$dApplicative_s6ANV] \u []
                  GHC.Base.$p1Applicative $dApplicative_s6ANV;
        } in  Data.Semigroup.Internal.$fFunctorAlt sat_s6ANW;

Data.Semigroup.Internal.$fApplicativeAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dApplicative_s6ANX]
        let {
          sat_s6AO3 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt a
          [LclId] =
              [$dApplicative_s6ANX] \u [] GHC.Base.<* $dApplicative_s6ANX; } in
        let {
          sat_s6AO2 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt b
          [LclId] =
              [$dApplicative_s6ANX] \u [] GHC.Base.*> $dApplicative_s6ANX; } in
        let {
          sat_s6AO1 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt c
          [LclId] =
              [$dApplicative_s6ANX] \u []
                  GHC.Base.liftA2 $dApplicative_s6ANX; } in
        let {
          sat_s6AO0 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt (a -> b)
               -> Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
          [LclId] =
              [$dApplicative_s6ANX] \u [] GHC.Base.<*> $dApplicative_s6ANX; } in
        let {
          sat_s6ANZ [Occ=Once]
            :: forall a. a -> Data.Semigroup.Internal.Alt f_a6tkt a
          [LclId] =
              [$dApplicative_s6ANX] \u [] GHC.Base.pure $dApplicative_s6ANX; } in
        let {
          sat_s6ANY [Occ=Once]
            :: GHC.Base.Functor (Data.Semigroup.Internal.Alt f_a6tkt)
          [LclId] =
              [$dApplicative_s6ANX] \u []
                  Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative
                      $dApplicative_s6ANX;
        } in 
          GHC.Base.C:Applicative [sat_s6ANY
                                  sat_s6ANZ
                                  sat_s6AO0
                                  sat_s6AO1
                                  sat_s6AO2
                                  sat_s6AO3];

Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6AO4]
        let {
          sat_s6AO5 [Occ=Once, Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Applicative f_a6tn6
          [LclId] =
              [$dAlternative_s6AO4] \u []
                  GHC.Base.$p1Alternative $dAlternative_s6AO4;
        } in  Data.Semigroup.Internal.$fApplicativeAlt sat_s6AO5;

Data.Semigroup.Internal.$fAlternativeAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Alternative (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>m] =
    [] \r [$dAlternative_s6AO6]
        let {
          sat_s6AOb [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 [a]
          [LclId] =
              [$dAlternative_s6AO6] \u [] GHC.Base.many $dAlternative_s6AO6; } in
        let {
          sat_s6AOa [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 [a]
          [LclId] =
              [$dAlternative_s6AO6] \u [] GHC.Base.some $dAlternative_s6AO6; } in
        let {
          sat_s6AO9 [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 a
          [LclId] =
              [$dAlternative_s6AO6] \u [] GHC.Base.<|> $dAlternative_s6AO6; } in
        let {
          sat_s6AO8 [Occ=Once]
            :: forall a. Data.Semigroup.Internal.Alt f_a6tn6 a
          [LclId] =
              [$dAlternative_s6AO6] \u []
                  GHC.Base.empty $dAlternative_s6AO6; } in
        let {
          sat_s6AO7 [Occ=Once]
            :: GHC.Base.Applicative (Data.Semigroup.Internal.Alt f_a6tn6)
          [LclId] =
              [$dAlternative_s6AO6] \u []
                  Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative
                      $dAlternative_s6AO6;
        } in 
          GHC.Base.C:Alternative [sat_s6AO7
                                  sat_s6AO8
                                  sat_s6AO9
                                  sat_s6AOa
                                  sat_s6AOb];

Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.Alternative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s6AOc]
        let {
          sat_s6AOd [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Alternative f_a6tjD
          [LclId] =
              [$dMonadPlus_s6AOc] \u [] GHC.Base.$p1MonadPlus $dMonadPlus_s6AOc;
        } in  Data.Semigroup.Internal.$fAlternativeAlt sat_s6AOd;

Data.Semigroup.Internal.$fMonadAlt_$cp1Monad
  :: forall (f :: * -> *).
     GHC.Base.Monad f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_s6AOe]
        let {
          sat_s6AOf [Occ=Once, Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Applicative f_a6thT
          [LclId] =
              [$dMonad_s6AOe] \u [] GHC.Base.$p1Monad $dMonad_s6AOe;
        } in  Data.Semigroup.Internal.$fApplicativeAlt sat_s6AOf;

Data.Semigroup.Internal.$fMonadAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Monad f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>m] =
    [] \r [$dMonad_s6AOg]
        let {
          sat_s6AOl [Occ=Once]
            :: forall a.
               GHC.Base.String -> Data.Semigroup.Internal.Alt f_a6thT a
          [LclId] =
              [$dMonad_s6AOg] \u [] GHC.Base.fail $dMonad_s6AOg; } in
        let {
          sat_s6AOk [Occ=Once]
            :: forall a. a -> Data.Semigroup.Internal.Alt f_a6thT a
          [LclId] =
              [$dMonad_s6AOg] \u [] GHC.Base.return $dMonad_s6AOg; } in
        let {
          sat_s6AOj [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6thT a
               -> Data.Semigroup.Internal.Alt f_a6thT b
               -> Data.Semigroup.Internal.Alt f_a6thT b
          [LclId] =
              [$dMonad_s6AOg] \u [] GHC.Base.>> $dMonad_s6AOg; } in
        let {
          sat_s6AOi [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6thT a
               -> (a -> Data.Semigroup.Internal.Alt f_a6thT b)
               -> Data.Semigroup.Internal.Alt f_a6thT b
          [LclId] =
              [$dMonad_s6AOg] \u [] GHC.Base.>>= $dMonad_s6AOg; } in
        let {
          sat_s6AOh [Occ=Once]
            :: GHC.Base.Applicative (Data.Semigroup.Internal.Alt f_a6thT)
          [LclId] =
              [$dMonad_s6AOg] \u []
                  Data.Semigroup.Internal.$fMonadAlt_$cp1Monad $dMonad_s6AOg;
        } in 
          GHC.Base.C:Monad [sat_s6AOh
                            sat_s6AOi
                            sat_s6AOj
                            sat_s6AOk
                            sat_s6AOl];

Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s6AOm]
        let {
          sat_s6AOn [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_a6tjD
          [LclId] =
              [$dMonadPlus_s6AOm] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_s6AOm;
        } in  Data.Semigroup.Internal.$fMonadAlt sat_s6AOn;

Data.Semigroup.Internal.$fMonadPlusAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.MonadPlus (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),1*U,1*U)>m] =
    [] \r [$dMonadPlus_s6AOo]
        let {
          sat_s6AOs [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tjD a
               -> Data.Semigroup.Internal.Alt f_a6tjD a
               -> Data.Semigroup.Internal.Alt f_a6tjD a
          [LclId] =
              [$dMonadPlus_s6AOo] \u [] GHC.Base.mplus $dMonadPlus_s6AOo; } in
        let {
          sat_s6AOr [Occ=Once]
            :: forall a. Data.Semigroup.Internal.Alt f_a6tjD a
          [LclId] =
              [$dMonadPlus_s6AOo] \u [] GHC.Base.mzero $dMonadPlus_s6AOo; } in
        let {
          sat_s6AOq [Occ=Once]
            :: GHC.Base.Monad (Data.Semigroup.Internal.Alt f_a6tjD)
          [LclId] =
              [$dMonadPlus_s6AOo] \u []
                  Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus
                      $dMonadPlus_s6AOo; } in
        let {
          sat_s6AOp [Occ=Once]
            :: GHC.Base.Alternative (Data.Semigroup.Internal.Alt f_a6tjD)
          [LclId] =
              [$dMonadPlus_s6AOo] \u []
                  Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus
                      $dMonadPlus_s6AOo;
        } in 
          GHC.Base.C:MonadPlus [sat_s6AOp sat_s6AOq sat_s6AOr sat_s6AOs];

Data.Semigroup.Internal.$fEnumAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Enum.Enum (f a) =>
     GHC.Enum.Enum (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dEnum_s6AOt]
        let {
          sat_s6AOB [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.enumFromThenTo $dEnum_s6AOt; } in
        let {
          sat_s6AOA [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.enumFromTo $dEnum_s6AOt; } in
        let {
          sat_s6AOz [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.enumFromThen $dEnum_s6AOt; } in
        let {
          sat_s6AOy [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.enumFrom $dEnum_s6AOt; } in
        let {
          sat_s6AOx [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm -> GHC.Types.Int
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.fromEnum $dEnum_s6AOt; } in
        let {
          sat_s6AOw [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.toEnum $dEnum_s6AOt; } in
        let {
          sat_s6AOv [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.pred $dEnum_s6AOt; } in
        let {
          sat_s6AOu [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.succ $dEnum_s6AOt;
        } in 
          GHC.Enum.C:Enum [sat_s6AOu
                           sat_s6AOv
                           sat_s6AOw
                           sat_s6AOx
                           sat_s6AOy
                           sat_s6AOz
                           sat_s6AOA
                           sat_s6AOB];

Data.Semigroup.Internal.$fNumAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Num.Num (f a) =>
     GHC.Num.Num (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6AOC]
        let {
          sat_s6AOJ [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.fromInteger $dNum_s6AOC; } in
        let {
          sat_s6AOI [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.signum $dNum_s6AOC; } in
        let {
          sat_s6AOH [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.abs $dNum_s6AOC; } in
        let {
          sat_s6AOG [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.negate $dNum_s6AOC; } in
        let {
          sat_s6AOF [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.* $dNum_s6AOC; } in
        let {
          sat_s6AOE [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.- $dNum_s6AOC; } in
        let {
          sat_s6AOD [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.+ $dNum_s6AOC;
        } in 
          GHC.Num.C:Num [sat_s6AOD
                         sat_s6AOE
                         sat_s6AOF
                         sat_s6AOG
                         sat_s6AOH
                         sat_s6AOI
                         sat_s6AOJ];

Data.Semigroup.Internal.$fEqAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Eq (f a) =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6AOK]
        let {
          sat_s6AOM [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6txq a_X6txt
               -> Data.Semigroup.Internal.Alt f_X6txq a_X6txt -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6AOK] \u [] GHC.Classes./= $dEq_s6AOK; } in
        let {
          sat_s6AOL [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6txq a_X6txt
               -> Data.Semigroup.Internal.Alt f_X6txq a_X6txt -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6AOK] \u [] GHC.Classes.== $dEq_s6AOK;
        } in  GHC.Classes.C:Eq [sat_s6AOL sat_s6AOM];

Data.Semigroup.Internal.$fOrdAlt_$cp1Ord
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Ord (f a) =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Alt f a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6AON]
        let {
          sat_s6AOO [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Classes.Eq (f_X6tn1 a_X6tn3)
          [LclId] =
              [$dOrd_s6AON] \u [] GHC.Classes.$p1Ord $dOrd_s6AON;
        } in  Data.Semigroup.Internal.$fEqAlt sat_s6AOO;

Data.Semigroup.Internal.$fOrdAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Ord (f a) =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6AOP]
        let {
          sat_s6AOX [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.min $dOrd_s6AOP; } in
        let {
          sat_s6AOW [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.max $dOrd_s6AOP; } in
        let {
          sat_s6AOV [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.>= $dOrd_s6AOP; } in
        let {
          sat_s6AOU [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.> $dOrd_s6AOP; } in
        let {
          sat_s6AOT [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.<= $dOrd_s6AOP; } in
        let {
          sat_s6AOS [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.< $dOrd_s6AOP; } in
        let {
          sat_s6AOR [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.compare $dOrd_s6AOP; } in
        let {
          sat_s6AOQ [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4)
          [LclId] =
              [$dOrd_s6AOP] \u []
                  Data.Semigroup.Internal.$fOrdAlt_$cp1Ord $dOrd_s6AOP;
        } in 
          GHC.Classes.C:Ord [sat_s6AOQ
                             sat_s6AOR
                             sat_s6AOS
                             sat_s6AOT
                             sat_s6AOU
                             sat_s6AOV
                             sat_s6AOW
                             sat_s6AOX];

Data.Semigroup.Internal.$fShowAlt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Semigroup.Internal.$fShowAlt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alt {"#;

Data.Semigroup.Internal.$fShowAlt2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAlt = "#;

Data.Semigroup.Internal.$fReadAll5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Semigroup.Internal.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Alt f a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AOY ww_s6AOZ w1_s6AP0]
        let {
          f1_s6AP1 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6AOY w1_s6AP0] \u []
                  GHC.Show.showsPrec
                      w_s6AOY Data.Semigroup.Internal.$fShowAlt1 w1_s6AP0;
        } in 
          case >=# [ww_s6AOZ 11#] of {
            __DEFAULT ->
                let {
                  sat_s6AP7 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f1_s6AP1] \r [x_s6AP3]
                          let {
                            sat_s6AP6 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_s6AP1 x_s6AP3] \u []
                                    let {
                                      sat_s6AP5 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_s6AP1 x_s6AP3] \u []
                                              let {
                                                sat_s6AP4 [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6AP3] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6AP3;
                                              } in  f1_s6AP1 sat_s6AP4;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowAlt2 sat_s6AP5;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowAlt3 sat_s6AP6;
                } in  sat_s6AP7;
            1# ->
                let {
                  sat_s6APe [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f1_s6AP1] \r [x_s6AP8]
                          let {
                            sat_s6APd [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_s6AP1 x_s6AP8] \u []
                                    let {
                                      sat_s6APc [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_s6AP1 x_s6AP8] \u []
                                              let {
                                                sat_s6APb [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f1_s6AP1 x_s6AP8] \u []
                                                        let {
                                                          sat_s6APa [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6AP8] \u []
                                                                  let {
                                                                    sat_s6AP9 [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6AP8];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6AP9;
                                                        } in  f1_s6AP1 sat_s6APa;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowAlt2 sat_s6APb;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowAlt3 sat_s6APc;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6APd];
                } in  sat_s6APe;
          };

Data.Semigroup.Internal.$fShowAlt_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Types.Int -> Data.Semigroup.Internal.Alt f a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6APf w1_s6APg w2_s6APh]
        case w1_s6APg of {
          GHC.Types.I# ww1_s6APj [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec1 w_s6APf ww1_s6APj w2_s6APh;
        };

Data.Semigroup.Internal.$fReadAll4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll5;

Data.Semigroup.Internal.$fShowAlt_$cshow
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     Data.Semigroup.Internal.Alt f a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6APk x_s6APl]
        let {
          sat_s6APn [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6APk x_s6APl] \u []
                  let {
                    sat_s6APm [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6APk x_s6APl] \u []
                            GHC.Show.showsPrec
                                $dShow_s6APk
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6APl
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAlt2 sat_s6APm;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowAlt3 sat_s6APn;

Data.Semigroup.Internal.$fShowAlt_$cshowList
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     [Data.Semigroup.Internal.Alt f a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6APo ls_s6APp s_s6APq]
        let {
          sat_s6APs [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6APo] \r [w_s6APr]
                  Data.Semigroup.Internal.$w$cshowsPrec1 $dShow_s6APo 0# w_s6APr;
        } in  GHC.Show.showList__ sat_s6APs ls_s6APp s_s6APq;

Data.Semigroup.Internal.$fShowAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Show.Show (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6APt]
        let {
          sat_s6APw [Occ=Once]
            :: [Data.Semigroup.Internal.Alt f_a6taL a_a6taM] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6APt] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshowList
                      $dShow_s6APt eta_B2 eta_B1; } in
        let {
          sat_s6APv [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Base.String
          [LclId] =
              [$dShow_s6APt] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshow $dShow_s6APt eta_B1; } in
        let {
          sat_s6APu [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6APt] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshowsPrec
                      $dShow_s6APt eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6APu sat_s6APv sat_s6APw];

Data.Semigroup.Internal.$fReadAlt5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alt"#;

Data.Semigroup.Internal.$fReadAlt4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAlt5;

Data.Semigroup.Internal.$fReadAlt_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAlt4];

Data.Semigroup.Internal.$fReadAll11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Semigroup.Internal.$fReadAll10 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll11;

Data.Semigroup.Internal.$fReadAll_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.Internal.$fReadAll10];

Data.Semigroup.Internal.$fReadAlt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAlt"#;

Data.Semigroup.Internal.$fReadAlt2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAlt3;

Data.Semigroup.Internal.$fReadAll6 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Semigroup.Internal.$fReadAll3 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.Internal.$fReadAll4];

Data.Semigroup.Internal.$fReadAlt1
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Alt f a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6APx]
        let {
          lvl12_s6APy [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP (f_a6t9S a_a6t9T)
          [LclId] =
              [$dRead_s6APx] \u []
                  GHC.Read.readPrec
                      $dRead_s6APx Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6APz [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP (f_a6t9S a_a6t9T)
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6APy] \r [ds1_s6APA] lvl12_s6APy; } in
        let {
          sat_s6APU [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_a6t9S a_a6t9T)
          [LclId] =
              [ds_s6APz] \r [c_s6APB eta_s6APC]
                  case c_s6APB of {
                    GHC.Types.I# x_s6APE [Occ=Once] ->
                        case <=# [x_s6APE 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6APR [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6APz eta_s6APC] \r [a1_s6APG]
                                        let {
                                          sat_s6APO [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6APz eta_s6APC] \r [a2_s6APH]
                                                  let {
                                                    sat_s6APN [Occ=Once]
                                                      :: f_a6t9S a_a6t9T
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6APC] \r [a3_s6API]
                                                            let {
                                                              sat_s6APK [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6APC a3_s6API] \r [a4_s6APJ]
                                                                      eta_s6APC a3_s6API;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6APK
                                                              of
                                                              { Unit# ww1_s6APM [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6APM];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadAlt2
                                                        ds_s6APz
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6APN;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6APO
                                          of
                                          { Unit# ww1_s6APQ [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6APQ];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadAlt_lexeme sat_s6APR
                                of
                                { Unit# ww1_s6APT [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6APT];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6APU;

Data.Semigroup.Internal.$fReadAlt_$creadsPrec
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Alt f a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6APV]
        let {
          ds_s6APW [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6APV] \u []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6APV; } in
        let {
          sat_s6APZ [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle)
          [LclId] =
              [ds_s6APW] \r [n_s6APX]
                  let {
                    sat_s6APY [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle)
                    [LclId] =
                        [ds_s6APW n_s6APX] \u []
                            ds_s6APW
                                n_s6APX Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6APY;
        } in  sat_s6APZ;

Data.Semigroup.Internal.$fReadAlt_$creadListPrec
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Alt f a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AQ0]
        let {
          sat_s6AQ1 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_X6tla a_X6tlc)
          [LclId] =
              [$dRead_s6AQ0] \s []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6AQ0;
        } in  GHC.Read.list sat_s6AQ1;

Data.Semigroup.Internal.$fReadAlt_$creadList
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Semigroup.Internal.Alt f a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AQ2]
        let {
          sat_s6AQ4 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Alt f_X6tlb a_X6tld]
          [LclId] =
              [$dRead_s6AQ2] \u []
                  let {
                    sat_s6AQ3 [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Alt f_X6tlb a_X6tld)
                    [LclId] =
                        [$dRead_s6AQ2] \s []
                            Data.Semigroup.Internal.$fReadAlt1 $dRead_s6AQ2;
                  } in 
                    GHC.Read.list
                        sat_s6AQ3
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6AQ4;

Data.Semigroup.Internal.$fReadAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     GHC.Read.Read (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6AQ5]
        let {
          sat_s6AQ9 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb]
          [LclId] =
              [$dRead_s6AQ5] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadListPrec $dRead_s6AQ5; } in
        let {
          sat_s6AQ8 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb)
          [LclId] =
              [$dRead_s6AQ5] \u []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6AQ5; } in
        let {
          sat_s6AQ7 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb]
          [LclId] =
              [$dRead_s6AQ5] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadList $dRead_s6AQ5; } in
        let {
          sat_s6AQ6 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb)
          [LclId] =
              [$dRead_s6AQ5] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadsPrec $dRead_s6AQ5;
        } in  GHC.Read.C:Read [sat_s6AQ6 sat_s6AQ7 sat_s6AQ8 sat_s6AQ9];

Data.Semigroup.Internal.$fGeneric1Alt1
  :: forall k (f :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Semigroup.Internal.Alt f) a
     -> GHC.Generics.Rep1 (Data.Semigroup.Internal.Alt f) a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AQa] ds_s6AQa;

Data.Semigroup.Internal.$fGeneric1Alt2
  :: forall k (f :: k -> *) (a :: k).
     Data.Semigroup.Internal.Alt f a -> Data.Semigroup.Internal.Alt f a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6AQb] x_s6AQb;

Data.Semigroup.Internal.$fGeneric1Alt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *).
     GHC.Generics.Generic1 (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Alt2
                                            Data.Semigroup.Internal.$fGeneric1Alt1];

Data.Semigroup.Internal.$fGenericAlt1
  :: forall k (f :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Alt f a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Alt f a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AQc] ds_s6AQc;

Data.Semigroup.Internal.$fGenericAlt2
  :: forall k (f :: k -> *) (a :: k) x.
     Data.Semigroup.Internal.Alt f a -> Data.Semigroup.Internal.Alt f a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AQd] x1_s6AQd;

Data.Semigroup.Internal.$fGenericAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAlt2
                                           Data.Semigroup.Internal.$fGenericAlt1];

Data.Semigroup.Internal.$fNumProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Semigroup.Internal.Product a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6AQe]
        let {
          sat_s6AQl [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.fromInteger $dNum_s6AQe; } in
        let {
          sat_s6AQk [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.signum $dNum_s6AQe; } in
        let {
          sat_s6AQj [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.abs $dNum_s6AQe; } in
        let {
          sat_s6AQi [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.negate $dNum_s6AQe; } in
        let {
          sat_s6AQh [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.* $dNum_s6AQe; } in
        let {
          sat_s6AQg [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.- $dNum_s6AQe; } in
        let {
          sat_s6AQf [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.+ $dNum_s6AQe;
        } in 
          GHC.Num.C:Num [sat_s6AQf
                         sat_s6AQg
                         sat_s6AQh
                         sat_s6AQi
                         sat_s6AQj
                         sat_s6AQk
                         sat_s6AQl];

Data.Semigroup.Internal.$fGeneric1Product1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Product a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AQm] ds_s6AQm;

Data.Semigroup.Internal.$fGeneric1Product2
  :: forall a.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6AQn] x_s6AQn;

Data.Semigroup.Internal.$fGeneric1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Product
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Product2
                                            Data.Semigroup.Internal.$fGeneric1Product1];

Data.Semigroup.Internal.$fGenericProduct1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Product a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Product a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AQo] ds_s6AQo;

Data.Semigroup.Internal.$fGenericProduct2
  :: forall a x.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AQp] x1_s6AQp;

Data.Semigroup.Internal.$fGenericProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Generics.Generic (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericProduct2
                                           Data.Semigroup.Internal.$fGenericProduct1];

Data.Semigroup.Internal.$fBoundedProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6AQq]
        let {
          sat_s6AQs [Occ=Once] :: Data.Semigroup.Internal.Product a_a6t49
          [LclId] =
              [$dBounded_s6AQq] \u [] GHC.Enum.maxBound $dBounded_s6AQq; } in
        let {
          sat_s6AQr [Occ=Once] :: Data.Semigroup.Internal.Product a_a6t49
          [LclId] =
              [$dBounded_s6AQq] \u [] GHC.Enum.minBound $dBounded_s6AQq;
        } in  GHC.Enum.C:Bounded [sat_s6AQr sat_s6AQs];

Data.Semigroup.Internal.$fShowProduct2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product {"#;

Data.Semigroup.Internal.$fShowProduct1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getProduct = "#;

Data.Semigroup.Internal.$w$cshowsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int#
     -> Data.Semigroup.Internal.Product a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AQt ww_s6AQu w1_s6AQv]
        let {
          f_s6AQw [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6AQt w1_s6AQv] \u []
                  GHC.Show.showsPrec
                      w_s6AQt Data.Semigroup.Internal.$fShowAlt1 w1_s6AQv;
        } in 
          case >=# [ww_s6AQu 11#] of {
            __DEFAULT ->
                let {
                  sat_s6AQC [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6AQw] \r [x_s6AQy]
                          let {
                            sat_s6AQB [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6AQw x_s6AQy] \u []
                                    let {
                                      sat_s6AQA [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6AQw x_s6AQy] \u []
                                              let {
                                                sat_s6AQz [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6AQy] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6AQy;
                                              } in  f_s6AQw sat_s6AQz;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowProduct1 sat_s6AQA;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowProduct2 sat_s6AQB;
                } in  sat_s6AQC;
            1# ->
                let {
                  sat_s6AQJ [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6AQw] \r [x_s6AQD]
                          let {
                            sat_s6AQI [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6AQw x_s6AQD] \u []
                                    let {
                                      sat_s6AQH [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6AQw x_s6AQD] \u []
                                              let {
                                                sat_s6AQG [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6AQw x_s6AQD] \u []
                                                        let {
                                                          sat_s6AQF [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6AQD] \u []
                                                                  let {
                                                                    sat_s6AQE [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6AQD];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6AQE;
                                                        } in  f_s6AQw sat_s6AQF;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowProduct1
                                                    sat_s6AQG;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowProduct2 sat_s6AQH;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6AQI];
                } in  sat_s6AQJ;
          };

Data.Semigroup.Internal.$fShowProduct_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int
     -> Data.Semigroup.Internal.Product a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AQK w1_s6AQL w2_s6AQM]
        case w1_s6AQL of {
          GHC.Types.I# ww1_s6AQO [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec4 w_s6AQK ww1_s6AQO w2_s6AQM;
        };

Data.Semigroup.Internal.$fShowProduct_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Product a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6AQP x_s6AQQ]
        let {
          sat_s6AQS [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6AQP x_s6AQQ] \u []
                  let {
                    sat_s6AQR [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6AQP x_s6AQQ] \u []
                            GHC.Show.showsPrec
                                $dShow_s6AQP
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6AQQ
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowProduct1 sat_s6AQR;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowProduct2 sat_s6AQS;

Data.Semigroup.Internal.$fShowProduct_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Product a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6AQT ls_s6AQU s_s6AQV]
        let {
          sat_s6AQX [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t3E -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AQT] \r [w_s6AQW]
                  Data.Semigroup.Internal.$w$cshowsPrec4 $dShow_s6AQT 0# w_s6AQW;
        } in  GHC.Show.showList__ sat_s6AQX ls_s6AQU s_s6AQV;

Data.Semigroup.Internal.$fShowProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6AQY]
        let {
          sat_s6AR1 [Occ=Once]
            :: [Data.Semigroup.Internal.Product a_a6t3E] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AQY] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshowList
                      $dShow_s6AQY eta_B2 eta_B1; } in
        let {
          sat_s6AR0 [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t3E -> GHC.Base.String
          [LclId] =
              [$dShow_s6AQY] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshow
                      $dShow_s6AQY eta_B1; } in
        let {
          sat_s6AQZ [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Product a_a6t3E -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AQY] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshowsPrec
                      $dShow_s6AQY eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6AQZ sat_s6AR0 sat_s6AR1];

Data.Semigroup.Internal.$fReadProduct5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product"#;

Data.Semigroup.Internal.$fReadProduct4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadProduct5;

Data.Semigroup.Internal.$fReadProduct_lexeme
  :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadProduct4];

Data.Semigroup.Internal.$fReadProduct3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getProduct"#;

Data.Semigroup.Internal.$fReadProduct2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadProduct3;

Data.Semigroup.Internal.$fReadProduct1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Product a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AR2]
        let {
          lvl12_s6AR3 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6t2P
          [LclId] =
              [$dRead_s6AR2] \u []
                  GHC.Read.readPrec
                      $dRead_s6AR2 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6AR4 [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6t2P
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6AR3] \r [ds1_s6AR5] lvl12_s6AR3; } in
        let {
          sat_s6ARp [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_a6t2P)
          [LclId] =
              [ds_s6AR4] \r [c_s6AR6 eta_s6AR7]
                  case c_s6AR6 of {
                    GHC.Types.I# x_s6AR9 [Occ=Once] ->
                        case <=# [x_s6AR9 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6ARm [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6AR4 eta_s6AR7] \r [a1_s6ARb]
                                        let {
                                          sat_s6ARj [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6AR4 eta_s6AR7] \r [a2_s6ARc]
                                                  let {
                                                    sat_s6ARi [Occ=Once]
                                                      :: a_a6t2P
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6AR7] \r [a3_s6ARd]
                                                            let {
                                                              sat_s6ARf [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6AR7 a3_s6ARd] \r [a4_s6ARe]
                                                                      eta_s6AR7 a3_s6ARd;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6ARf
                                                              of
                                                              { Unit# ww1_s6ARh [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6ARh];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadProduct2
                                                        ds_s6AR4
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6ARi;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6ARj
                                          of
                                          { Unit# ww1_s6ARl [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6ARl];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadProduct_lexeme sat_s6ARm
                                of
                                { Unit# ww1_s6ARo [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6ARo];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6ARp;

Data.Semigroup.Internal.$fReadProduct_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Product a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ARq]
        let {
          ds_s6ARr [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Product a_X6tfh
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6ARq] \u []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6ARq; } in
        let {
          sat_s6ARu [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Product a_X6tfh)
          [LclId] =
              [ds_s6ARr] \r [n_s6ARs]
                  let {
                    sat_s6ARt [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Product a_X6tfh)
                    [LclId] =
                        [ds_s6ARr n_s6ARs] \u []
                            ds_s6ARr
                                n_s6ARs Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6ARt;
        } in  sat_s6ARu;

Data.Semigroup.Internal.$fReadProduct_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Product a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ARv]
        let {
          sat_s6ARw [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_X6tff)
          [LclId] =
              [$dRead_s6ARv] \s []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6ARv;
        } in  GHC.Read.list sat_s6ARw;

Data.Semigroup.Internal.$fReadProduct_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Semigroup.Internal.Product a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ARx]
        let {
          sat_s6ARz [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Product a_X6tfg]
          [LclId] =
              [$dRead_s6ARx] \u []
                  let {
                    sat_s6ARy [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Product a_X6tfg)
                    [LclId] =
                        [$dRead_s6ARx] \s []
                            Data.Semigroup.Internal.$fReadProduct1 $dRead_s6ARx;
                  } in 
                    GHC.Read.list
                        sat_s6ARy
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6ARz;

Data.Semigroup.Internal.$fReadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6ARA]
        let {
          sat_s6ARE [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Product a_X6tfe]
          [LclId] =
              [$dRead_s6ARA] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadListPrec
                      $dRead_s6ARA; } in
        let {
          sat_s6ARD [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_X6tfe)
          [LclId] =
              [$dRead_s6ARA] \u []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6ARA; } in
        let {
          sat_s6ARC [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Product a_X6tfe]
          [LclId] =
              [$dRead_s6ARA] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadList $dRead_s6ARA; } in
        let {
          sat_s6ARB [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Product a_X6tfe)
          [LclId] =
              [$dRead_s6ARA] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadsPrec $dRead_s6ARA;
        } in  GHC.Read.C:Read [sat_s6ARB sat_s6ARC sat_s6ARD sat_s6ARE];

Data.Semigroup.Internal.$fEqProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6ARF]
        let {
          sat_s6ARH [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t0s
               -> Data.Semigroup.Internal.Product a_a6t0s -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6ARF] \u [] GHC.Classes./= $dEq_s6ARF; } in
        let {
          sat_s6ARG [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t0s
               -> Data.Semigroup.Internal.Product a_a6t0s -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6ARF] \u [] GHC.Classes.== $dEq_s6ARF;
        } in  GHC.Classes.C:Eq [sat_s6ARG sat_s6ARH];

Data.Semigroup.Internal.$fOrdProduct_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6ARI]
        let {
          sat_s6ARJ [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6t10
          [LclId] =
              [$dOrd_s6ARI] \u [] GHC.Classes.$p1Ord $dOrd_s6ARI;
        } in  Data.Semigroup.Internal.$fEqProduct sat_s6ARJ;

Data.Semigroup.Internal.$fOrdProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Product a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6ARK]
        let {
          sat_s6ARS [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.min $dOrd_s6ARK; } in
        let {
          sat_s6ARR [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.max $dOrd_s6ARK; } in
        let {
          sat_s6ARQ [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.>= $dOrd_s6ARK; } in
        let {
          sat_s6ARP [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.> $dOrd_s6ARK; } in
        let {
          sat_s6ARO [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.<= $dOrd_s6ARK; } in
        let {
          sat_s6ARN [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.< $dOrd_s6ARK; } in
        let {
          sat_s6ARM [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.compare $dOrd_s6ARK; } in
        let {
          sat_s6ARL [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Product a_a6t10)
          [LclId] =
              [$dOrd_s6ARK] \u []
                  Data.Semigroup.Internal.$fOrdProduct_$cp1Ord $dOrd_s6ARK;
        } in 
          GHC.Classes.C:Ord [sat_s6ARL
                             sat_s6ARM
                             sat_s6ARN
                             sat_s6ARO
                             sat_s6ARP
                             sat_s6ARQ
                             sat_s6ARR
                             sat_s6ARS];

Data.Semigroup.Internal.$fNumSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6ART]
        let {
          sat_s6AS0 [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.fromInteger $dNum_s6ART; } in
        let {
          sat_s6ARZ [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.signum $dNum_s6ART; } in
        let {
          sat_s6ARY [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.abs $dNum_s6ART; } in
        let {
          sat_s6ARX [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.negate $dNum_s6ART; } in
        let {
          sat_s6ARW [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.* $dNum_s6ART; } in
        let {
          sat_s6ARV [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.- $dNum_s6ART; } in
        let {
          sat_s6ARU [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.+ $dNum_s6ART;
        } in 
          GHC.Num.C:Num [sat_s6ARU
                         sat_s6ARV
                         sat_s6ARW
                         sat_s6ARX
                         sat_s6ARY
                         sat_s6ARZ
                         sat_s6AS0];

Data.Semigroup.Internal.$fGeneric1Sum1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Sum a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AS1] ds_s6AS1;

Data.Semigroup.Internal.$fGeneric1Sum2
  :: forall a.
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6AS2] x_s6AS2;

Data.Semigroup.Internal.$fGeneric1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Sum
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Sum2
                                            Data.Semigroup.Internal.$fGeneric1Sum1];

Data.Semigroup.Internal.$fGenericSum1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Sum a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Sum a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AS3] ds_s6AS3;

Data.Semigroup.Internal.$fGenericSum2
  :: forall a x.
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AS4] x1_s6AS4;

Data.Semigroup.Internal.$fGenericSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericSum2
                                           Data.Semigroup.Internal.$fGenericSum1];

Data.Semigroup.Internal.$fBoundedSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6AS5]
        let {
          sat_s6AS7 [Occ=Once] :: Data.Semigroup.Internal.Sum a_a6sWQ
          [LclId] =
              [$dBounded_s6AS5] \u [] GHC.Enum.maxBound $dBounded_s6AS5; } in
        let {
          sat_s6AS6 [Occ=Once] :: Data.Semigroup.Internal.Sum a_a6sWQ
          [LclId] =
              [$dBounded_s6AS5] \u [] GHC.Enum.minBound $dBounded_s6AS5;
        } in  GHC.Enum.C:Bounded [sat_s6AS6 sat_s6AS7];

Data.Semigroup.Internal.$fShowSum2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum {"#;

Data.Semigroup.Internal.$fShowSum1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getSum = "#;

Data.Semigroup.Internal.$w$cshowsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Sum a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AS8 ww_s6AS9 w1_s6ASa]
        let {
          f_s6ASb [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6AS8 w1_s6ASa] \u []
                  GHC.Show.showsPrec
                      w_s6AS8 Data.Semigroup.Internal.$fShowAlt1 w1_s6ASa;
        } in 
          case >=# [ww_s6AS9 11#] of {
            __DEFAULT ->
                let {
                  sat_s6ASh [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6ASb] \r [x_s6ASd]
                          let {
                            sat_s6ASg [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6ASb x_s6ASd] \u []
                                    let {
                                      sat_s6ASf [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6ASb x_s6ASd] \u []
                                              let {
                                                sat_s6ASe [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6ASd] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6ASd;
                                              } in  f_s6ASb sat_s6ASe;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowSum1 sat_s6ASf;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowSum2 sat_s6ASg;
                } in  sat_s6ASh;
            1# ->
                let {
                  sat_s6ASo [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6ASb] \r [x_s6ASi]
                          let {
                            sat_s6ASn [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6ASb x_s6ASi] \u []
                                    let {
                                      sat_s6ASm [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6ASb x_s6ASi] \u []
                                              let {
                                                sat_s6ASl [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6ASb x_s6ASi] \u []
                                                        let {
                                                          sat_s6ASk [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6ASi] \u []
                                                                  let {
                                                                    sat_s6ASj [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6ASi];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6ASj;
                                                        } in  f_s6ASb sat_s6ASk;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowSum1 sat_s6ASl;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowSum2 sat_s6ASm;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6ASn];
                } in  sat_s6ASo;
          };

Data.Semigroup.Internal.$fShowSum_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Internal.Sum a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6ASp w1_s6ASq w2_s6ASr]
        case w1_s6ASq of {
          GHC.Types.I# ww1_s6ASt [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec5 w_s6ASp ww1_s6ASt w2_s6ASr;
        };

Data.Semigroup.Internal.$fShowSum_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Sum a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6ASu x_s6ASv]
        let {
          sat_s6ASx [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6ASu x_s6ASv] \u []
                  let {
                    sat_s6ASw [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6ASu x_s6ASv] \u []
                            GHC.Show.showsPrec
                                $dShow_s6ASu
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6ASv
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowSum1 sat_s6ASw;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowSum2 sat_s6ASx;

Data.Semigroup.Internal.$fShowSum_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Sum a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6ASy ls_s6ASz s_s6ASA]
        let {
          sat_s6ASC [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6ASy] \r [w_s6ASB]
                  Data.Semigroup.Internal.$w$cshowsPrec5 $dShow_s6ASy 0# w_s6ASB;
        } in  GHC.Show.showList__ sat_s6ASC ls_s6ASz s_s6ASA;

Data.Semigroup.Internal.$fShowSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6ASD]
        let {
          sat_s6ASG [Occ=Once]
            :: [Data.Semigroup.Internal.Sum a_a6sWl] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6ASD] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshowList
                      $dShow_s6ASD eta_B2 eta_B1; } in
        let {
          sat_s6ASF [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Base.String
          [LclId] =
              [$dShow_s6ASD] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshow $dShow_s6ASD eta_B1; } in
        let {
          sat_s6ASE [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6ASD] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshowsPrec
                      $dShow_s6ASD eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6ASE sat_s6ASF sat_s6ASG];

Data.Semigroup.Internal.$fReadSum5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum"#;

Data.Semigroup.Internal.$fReadSum4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadSum5;

Data.Semigroup.Internal.$fReadSum_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadSum4];

Data.Semigroup.Internal.$fReadSum3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getSum"#;

Data.Semigroup.Internal.$fReadSum2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadSum3;

Data.Semigroup.Internal.$fReadSum1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Sum a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ASH]
        let {
          lvl12_s6ASI [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6sVw
          [LclId] =
              [$dRead_s6ASH] \u []
                  GHC.Read.readPrec
                      $dRead_s6ASH Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6ASJ [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6sVw
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6ASI] \r [ds1_s6ASK] lvl12_s6ASI; } in
        let {
          sat_s6AT4 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_a6sVw)
          [LclId] =
              [ds_s6ASJ] \r [c_s6ASL eta_s6ASM]
                  case c_s6ASL of {
                    GHC.Types.I# x_s6ASO [Occ=Once] ->
                        case <=# [x_s6ASO 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6AT1 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6ASJ eta_s6ASM] \r [a1_s6ASQ]
                                        let {
                                          sat_s6ASY [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6ASJ eta_s6ASM] \r [a2_s6ASR]
                                                  let {
                                                    sat_s6ASX [Occ=Once]
                                                      :: a_a6sVw
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6ASM] \r [a3_s6ASS]
                                                            let {
                                                              sat_s6ASU [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6ASM a3_s6ASS] \r [a4_s6AST]
                                                                      eta_s6ASM a3_s6ASS;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6ASU
                                                              of
                                                              { Unit# ww1_s6ASW [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6ASW];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadSum2
                                                        ds_s6ASJ
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6ASX;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6ASY
                                          of
                                          { Unit# ww1_s6AT0 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6AT0];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadSum_lexeme sat_s6AT1
                                of
                                { Unit# ww1_s6AT3 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6AT3];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6AT4;

Data.Semigroup.Internal.$fReadSum_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Sum a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AT5]
        let {
          ds_s6AT6 [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Sum a_X6t8R
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6AT5] \u []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6AT5; } in
        let {
          sat_s6AT9 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Sum a_X6t8R)
          [LclId] =
              [ds_s6AT6] \r [n_s6AT7]
                  let {
                    sat_s6AT8 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Sum a_X6t8R)
                    [LclId] =
                        [ds_s6AT6 n_s6AT7] \u []
                            ds_s6AT6
                                n_s6AT7 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6AT8;
        } in  sat_s6AT9;

Data.Semigroup.Internal.$fReadSum_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Sum a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ATa]
        let {
          sat_s6ATb [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_X6t8P)
          [LclId] =
              [$dRead_s6ATa] \s []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6ATa;
        } in  GHC.Read.list sat_s6ATb;

Data.Semigroup.Internal.$fReadSum_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Sum a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ATc]
        let {
          sat_s6ATe [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Sum a_X6t8Q]
          [LclId] =
              [$dRead_s6ATc] \u []
                  let {
                    sat_s6ATd [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Sum a_X6t8Q)
                    [LclId] =
                        [$dRead_s6ATc] \s []
                            Data.Semigroup.Internal.$fReadSum1 $dRead_s6ATc;
                  } in 
                    GHC.Read.list
                        sat_s6ATd
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6ATe;

Data.Semigroup.Internal.$fReadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6ATf]
        let {
          sat_s6ATj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Sum a_X6t8O]
          [LclId] =
              [$dRead_s6ATf] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadListPrec $dRead_s6ATf; } in
        let {
          sat_s6ATi [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_X6t8O)
          [LclId] =
              [$dRead_s6ATf] \u []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6ATf; } in
        let {
          sat_s6ATh [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Sum a_X6t8O]
          [LclId] =
              [$dRead_s6ATf] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadList $dRead_s6ATf; } in
        let {
          sat_s6ATg [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Sum a_X6t8O)
          [LclId] =
              [$dRead_s6ATf] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadsPrec $dRead_s6ATf;
        } in  GHC.Read.C:Read [sat_s6ATg sat_s6ATh sat_s6ATi sat_s6ATj];

Data.Semigroup.Internal.$fEqSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6ATk]
        let {
          sat_s6ATm [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sT9
               -> Data.Semigroup.Internal.Sum a_a6sT9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6ATk] \u [] GHC.Classes./= $dEq_s6ATk; } in
        let {
          sat_s6ATl [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sT9
               -> Data.Semigroup.Internal.Sum a_a6sT9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6ATk] \u [] GHC.Classes.== $dEq_s6ATk;
        } in  GHC.Classes.C:Eq [sat_s6ATl sat_s6ATm];

Data.Semigroup.Internal.$fOrdSum_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6ATn]
        let {
          sat_s6ATo [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6sTH
          [LclId] =
              [$dOrd_s6ATn] \u [] GHC.Classes.$p1Ord $dOrd_s6ATn;
        } in  Data.Semigroup.Internal.$fEqSum sat_s6ATo;

Data.Semigroup.Internal.$fOrdSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6ATp]
        let {
          sat_s6ATx [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.min $dOrd_s6ATp; } in
        let {
          sat_s6ATw [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.max $dOrd_s6ATp; } in
        let {
          sat_s6ATv [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.>= $dOrd_s6ATp; } in
        let {
          sat_s6ATu [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.> $dOrd_s6ATp; } in
        let {
          sat_s6ATt [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.<= $dOrd_s6ATp; } in
        let {
          sat_s6ATs [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.< $dOrd_s6ATp; } in
        let {
          sat_s6ATr [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.compare $dOrd_s6ATp; } in
        let {
          sat_s6ATq [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Sum a_a6sTH)
          [LclId] =
              [$dOrd_s6ATp] \u []
                  Data.Semigroup.Internal.$fOrdSum_$cp1Ord $dOrd_s6ATp;
        } in 
          GHC.Classes.C:Ord [sat_s6ATq
                             sat_s6ATr
                             sat_s6ATs
                             sat_s6ATt
                             sat_s6ATu
                             sat_s6ATv
                             sat_s6ATw
                             sat_s6ATx];

Data.Semigroup.Internal.$fGenericAny1
  :: forall x.
     GHC.Generics.Rep Data.Semigroup.Internal.Any x
     -> GHC.Generics.Rep Data.Semigroup.Internal.Any x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6ATy] ds_s6ATy;

Data.Semigroup.Internal.$fGenericAny2
  :: forall x.
     Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6ATz] x1_s6ATz;

Data.Semigroup.Internal.$fGenericAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAny2
                                           Data.Semigroup.Internal.$fGenericAny1];

Data.Semigroup.Internal.$fBoundedAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Bounded Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Bounded! [GHC.Types.False GHC.Types.True];

Data.Semigroup.Internal.$fShowAny4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Any {"#;

Data.Semigroup.Internal.$fShowAny3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fShowAny4;

Data.Semigroup.Internal.$fShowAny2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAny = "#;

Data.Semigroup.Internal.$w$cshowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> Data.Semigroup.Internal.Any
     -> GHC.Base.String
     -> GHC.Base.String
[GblId, Arity=3, Str=<S,U><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s6ATA w_s6ATB w1_s6ATC]
        case >=# [ww_s6ATA 11#] of {
          __DEFAULT ->
              let {
                sat_s6ATI [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6ATB w1_s6ATC] \s []
                        let {
                          sat_s6ATH [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6ATB w1_s6ATC] \u []
                                  case w_s6ATB of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s6ATF [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6ATC] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6ATC;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6ATF;
                                    GHC.Types.True ->
                                        let {
                                          sat_s6ATG [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6ATC] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6ATC;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6ATG;
                                  };
                        } in 
                          GHC.CString.unpackAppendCString#
                              Data.Semigroup.Internal.$fShowAny2 sat_s6ATH;
              } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6ATI;
          1# ->
              let {
                sat_s6ATQ [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6ATB w1_s6ATC] \u []
                        let {
                          sat_s6ATP [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6ATB w1_s6ATC] \s []
                                  let {
                                    sat_s6ATO [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w_s6ATB w1_s6ATC] \u []
                                            case w_s6ATB of {
                                              GHC.Types.False ->
                                                  let {
                                                    sat_s6ATL [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6ATC] \s []
                                                            let {
                                                              sat_s6ATK [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6ATC];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6ATK;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6ATL;
                                              GHC.Types.True ->
                                                  let {
                                                    sat_s6ATN [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6ATC] \s []
                                                            let {
                                                              sat_s6ATM [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6ATC];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6ATM;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6ATN;
                                            };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        Data.Semigroup.Internal.$fShowAny2 sat_s6ATO;
                        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6ATP;
              } in  : [GHC.Show.$fShow(,)4 sat_s6ATQ];
        };

Data.Semigroup.Internal.$fShowAny_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> Data.Semigroup.Internal.Any -> GHC.Show.ShowS
[GblId, Arity=3, Str=<S(S),1*U(U)><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [w_s6ATR w1_s6ATS w2_s6ATT]
        case w_s6ATR of {
          GHC.Types.I# ww1_s6ATV [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec2 ww1_s6ATV w1_s6ATS w2_s6ATT;
        };

Data.Semigroup.Internal.$fShowAll6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++
            GHC.Show.$fShowBool4 Data.Semigroup.Internal.$fReadAll4;

Data.Semigroup.Internal.$fShowAll5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++
            GHC.Show.$fShowBool2 Data.Semigroup.Internal.$fReadAll4;

Data.Semigroup.Internal.$fShowAny_$cshow
  :: Data.Semigroup.Internal.Any -> GHC.Base.String
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s6ATW]
        let {
          sat_s6ATZ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [x_s6ATW] \s []
                  let {
                    sat_s6ATY [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [x_s6ATW] \u []
                            case x_s6ATW of {
                              GHC.Types.False -> Data.Semigroup.Internal.$fShowAll6;
                              GHC.Types.True -> Data.Semigroup.Internal.$fShowAll5;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAny2 sat_s6ATY;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6ATZ;

Data.Semigroup.Internal.$fShowAny1
  :: Data.Semigroup.Internal.Any -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,1*U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AU0 x_s6AU1]
        let {
          sat_s6AU6 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [ds_s6AU0 x_s6AU1] \s []
                  let {
                    sat_s6AU5 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ds_s6AU0 x_s6AU1] \u []
                            case ds_s6AU0 of {
                              GHC.Types.False ->
                                  let {
                                    sat_s6AU3 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6AU1] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6AU1;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6AU3;
                              GHC.Types.True ->
                                  let {
                                    sat_s6AU4 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6AU1] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6AU1;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6AU4;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAny2 sat_s6AU5;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6AU6;

Data.Semigroup.Internal.$fShowAny_$cshowList
  :: [Data.Semigroup.Internal.Any] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s6AU7 s_s6AU8]
        GHC.Show.showList__
            Data.Semigroup.Internal.$fShowAny1 ls_s6AU7 s_s6AU8;

Data.Semigroup.Internal.$fShowAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Semigroup.Internal.$fShowAny_$cshowsPrec
                                    Data.Semigroup.Internal.$fShowAny_$cshow
                                    Data.Semigroup.Internal.$fShowAny_$cshowList];

Data.Semigroup.Internal.$fReadAny6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Any"#;

Data.Semigroup.Internal.$fReadAny5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAny6;

Data.Semigroup.Internal.$fReadAny_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAny5];

Data.Semigroup.Internal.$fReadAny4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAny"#;

Data.Semigroup.Internal.$fReadAny3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAny4;

Data.Semigroup.Internal.$fReadAll7
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
    [] \r [ds1_s6AU9 eta_s6AUa]
        GHC.Read.list3
            GHC.Read.$fReadBool2
            Text.ParserCombinators.ReadPrec.minPrec
            eta_s6AUa;

Data.Semigroup.Internal.$w$creadPrec1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ww_s6AUb w_s6AUc]
        case <=# [ww_s6AUb 11#] of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
          1# ->
              let {
                sat_s6AUp [Occ=Once]
                  :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                [LclId] =
                    [w_s6AUc] \r [a1_s6AUe]
                        let {
                          sat_s6AUm [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                          [LclId] =
                              [w_s6AUc] \r [a2_s6AUf]
                                  let {
                                    sat_s6AUl [Occ=Once]
                                      :: GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b_s6uMw
                                    [LclId] =
                                        [w_s6AUc] \r [a3_s6AUg]
                                            let {
                                              sat_s6AUi [Occ=Once]
                                                :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                                              [LclId] =
                                                  [w_s6AUc a3_s6AUg] \r [a4_s6AUh] w_s6AUc a3_s6AUg;
                                            } in 
                                              case
                                                  Text.Read.Lex.$wexpect
                                                      Data.Semigroup.Internal.$fReadAll3 sat_s6AUi
                                              of
                                              { Unit# ww2_s6AUk [Occ=Once] ->
                                                    Text.ParserCombinators.ReadP.Look [ww2_s6AUk];
                                              };
                                  } in 
                                    GHC.Read.readField
                                        Data.Semigroup.Internal.$fReadAny3
                                        Data.Semigroup.Internal.$fReadAll7
                                        Data.Semigroup.Internal.$fReadAll6
                                        sat_s6AUl;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6AUm
                          of
                          { Unit# ww2_s6AUo [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_s6AUo];
                          };
              } in 
                case
                    Text.Read.Lex.$wexpect
                        Data.Semigroup.Internal.$fReadAny_lexeme sat_s6AUp
                of
                { Unit# ww2_s6AUr [Occ=Once] ->
                      Text.ParserCombinators.ReadP.Look [ww2_s6AUr];
                };
        };

Data.Semigroup.Internal.$fReadAny2 [InlPrag=NOUSERINLINE[0]]
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_s6AUs w1_s6AUt]
        case w_s6AUs of {
          GHC.Types.I# ww1_s6AUv [Occ=Once] ->
              Data.Semigroup.Internal.$w$creadPrec1 ww1_s6AUv w1_s6AUt;
        };

Data.Semigroup.Internal.$fReadAny1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Semigroup.Internal.$fReadAny2 eta_B2 eta_B1;

Data.Semigroup.Internal.$fReadAny_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Semigroup.Internal.Any
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [n_s6AUw]
        let {
          sat_s6AUx [Occ=Once]
            :: Text.ParserCombinators.ReadP.P Data.Semigroup.Internal.Any
          [LclId] =
              [n_s6AUw] \u []
                  GHC.Read.list3
                      Data.Semigroup.Internal.$fReadAny2
                      n_s6AUw
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6AUx;

Data.Semigroup.Internal.$fReadAny_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Any]
[GblId] =
    [] \u [] GHC.Read.list Data.Semigroup.Internal.$fReadAny1;

Data.Semigroup.Internal.$fReadAny7
  :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Internal.Any]
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fReadAny_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Semigroup.Internal.$fReadAny_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Any]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Data.Semigroup.Internal.$fReadAny7 eta_B1;

Data.Semigroup.Internal.$fReadAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Semigroup.Internal.$fReadAny_$creadsPrec
                                    Data.Semigroup.Internal.$fReadAny_$creadList
                                    Data.Semigroup.Internal.$fReadAny1
                                    Data.Semigroup.Internal.$fReadAny_$creadListPrec];

Data.Semigroup.Internal.$fEqAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Classes.$fEqBool_$c==
                                     GHC.Classes.$fEqBool_$c/=];

Data.Semigroup.Internal.$fOrdAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Semigroup.Internal.$fEqAny
                                      GHC.Classes.$fOrdBool_$ccompare
                                      GHC.Classes.$fOrdBool_$c<
                                      GHC.Classes.$fOrdBool_$c<=
                                      GHC.Classes.$fOrdBool_$c>
                                      GHC.Classes.$fOrdBool_$c>=
                                      GHC.Classes.$fOrdBool_$cmax
                                      GHC.Classes.$fOrdBool_$cmin];

Data.Semigroup.Internal.$fGenericAll1
  :: forall x.
     GHC.Generics.Rep Data.Semigroup.Internal.All x
     -> GHC.Generics.Rep Data.Semigroup.Internal.All x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AUy] ds_s6AUy;

Data.Semigroup.Internal.$fGenericAll2
  :: forall x.
     Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AUz] x1_s6AUz;

Data.Semigroup.Internal.$fGenericAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAll2
                                           Data.Semigroup.Internal.$fGenericAll1];

Data.Semigroup.Internal.$fBoundedAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Bounded Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Bounded! [GHC.Types.False GHC.Types.True];

Data.Semigroup.Internal.$fShowAll4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "All {"#;

Data.Semigroup.Internal.$fShowAll3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fShowAll4;

Data.Semigroup.Internal.$fShowAll2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAll = "#;

Data.Semigroup.Internal.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> Data.Semigroup.Internal.All
     -> GHC.Base.String
     -> GHC.Base.String
[GblId, Arity=3, Str=<S,U><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s6AUA w_s6AUB w1_s6AUC]
        case >=# [ww_s6AUA 11#] of {
          __DEFAULT ->
              let {
                sat_s6AUI [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6AUB w1_s6AUC] \s []
                        let {
                          sat_s6AUH [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6AUB w1_s6AUC] \u []
                                  case w_s6AUB of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s6AUF [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6AUC] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6AUC;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6AUF;
                                    GHC.Types.True ->
                                        let {
                                          sat_s6AUG [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6AUC] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6AUC;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6AUG;
                                  };
                        } in 
                          GHC.CString.unpackAppendCString#
                              Data.Semigroup.Internal.$fShowAll2 sat_s6AUH;
              } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6AUI;
          1# ->
              let {
                sat_s6AUQ [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6AUB w1_s6AUC] \u []
                        let {
                          sat_s6AUP [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6AUB w1_s6AUC] \s []
                                  let {
                                    sat_s6AUO [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w_s6AUB w1_s6AUC] \u []
                                            case w_s6AUB of {
                                              GHC.Types.False ->
                                                  let {
                                                    sat_s6AUL [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6AUC] \s []
                                                            let {
                                                              sat_s6AUK [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6AUC];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6AUK;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6AUL;
                                              GHC.Types.True ->
                                                  let {
                                                    sat_s6AUN [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6AUC] \s []
                                                            let {
                                                              sat_s6AUM [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6AUC];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6AUM;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6AUN;
                                            };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        Data.Semigroup.Internal.$fShowAll2 sat_s6AUO;
                        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6AUP;
              } in  : [GHC.Show.$fShow(,)4 sat_s6AUQ];
        };

Data.Semigroup.Internal.$fShowAll_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> Data.Semigroup.Internal.All -> GHC.Show.ShowS
[GblId, Arity=3, Str=<S(S),1*U(U)><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [w_s6AUR w1_s6AUS w2_s6AUT]
        case w_s6AUR of {
          GHC.Types.I# ww1_s6AUV [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec ww1_s6AUV w1_s6AUS w2_s6AUT;
        };

Data.Semigroup.Internal.$fShowAll_$cshow
  :: Data.Semigroup.Internal.All -> GHC.Base.String
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s6AUW]
        let {
          sat_s6AUZ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [x_s6AUW] \s []
                  let {
                    sat_s6AUY [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [x_s6AUW] \u []
                            case x_s6AUW of {
                              GHC.Types.False -> Data.Semigroup.Internal.$fShowAll6;
                              GHC.Types.True -> Data.Semigroup.Internal.$fShowAll5;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAll2 sat_s6AUY;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6AUZ;

Data.Semigroup.Internal.$fShowAll1
  :: Data.Semigroup.Internal.All -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,1*U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AV0 x_s6AV1]
        let {
          sat_s6AV6 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [ds_s6AV0 x_s6AV1] \s []
                  let {
                    sat_s6AV5 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ds_s6AV0 x_s6AV1] \u []
                            case ds_s6AV0 of {
                              GHC.Types.False ->
                                  let {
                                    sat_s6AV3 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6AV1] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6AV1;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6AV3;
                              GHC.Types.True ->
                                  let {
                                    sat_s6AV4 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6AV1] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6AV1;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6AV4;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAll2 sat_s6AV5;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6AV6;

Data.Semigroup.Internal.$fShowAll_$cshowList
  :: [Data.Semigroup.Internal.All] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s6AV7 s_s6AV8]
        GHC.Show.showList__
            Data.Semigroup.Internal.$fShowAll1 ls_s6AV7 s_s6AV8;

Data.Semigroup.Internal.$fShowAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Semigroup.Internal.$fShowAll_$cshowsPrec
                                    Data.Semigroup.Internal.$fShowAll_$cshow
                                    Data.Semigroup.Internal.$fShowAll_$cshowList];

Data.Semigroup.Internal.$fReadAll13 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "All"#;

Data.Semigroup.Internal.$fReadAll12 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll13;

Data.Semigroup.Internal.$fReadAll_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAll12];

Data.Semigroup.Internal.$fReadAll9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAll"#;

Data.Semigroup.Internal.$fReadAll8 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll9;

Data.Semigroup.Internal.$w$creadPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ww_s6AV9 w_s6AVa]
        case <=# [ww_s6AV9 11#] of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
          1# ->
              let {
                sat_s6AVn [Occ=Once]
                  :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                [LclId] =
                    [w_s6AVa] \r [a1_s6AVc]
                        let {
                          sat_s6AVk [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                          [LclId] =
                              [w_s6AVa] \r [a2_s6AVd]
                                  let {
                                    sat_s6AVj [Occ=Once]
                                      :: GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b_s6uMP
                                    [LclId] =
                                        [w_s6AVa] \r [a3_s6AVe]
                                            let {
                                              sat_s6AVg [Occ=Once]
                                                :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                                              [LclId] =
                                                  [w_s6AVa a3_s6AVe] \r [a4_s6AVf] w_s6AVa a3_s6AVe;
                                            } in 
                                              case
                                                  Text.Read.Lex.$wexpect
                                                      Data.Semigroup.Internal.$fReadAll3 sat_s6AVg
                                              of
                                              { Unit# ww2_s6AVi [Occ=Once] ->
                                                    Text.ParserCombinators.ReadP.Look [ww2_s6AVi];
                                              };
                                  } in 
                                    GHC.Read.readField
                                        Data.Semigroup.Internal.$fReadAll8
                                        Data.Semigroup.Internal.$fReadAll7
                                        Data.Semigroup.Internal.$fReadAll6
                                        sat_s6AVj;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6AVk
                          of
                          { Unit# ww2_s6AVm [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_s6AVm];
                          };
              } in 
                case
                    Text.Read.Lex.$wexpect
                        Data.Semigroup.Internal.$fReadAll_lexeme1 sat_s6AVn
                of
                { Unit# ww2_s6AVp [Occ=Once] ->
                      Text.ParserCombinators.ReadP.Look [ww2_s6AVp];
                };
        };

Data.Semigroup.Internal.$fReadAll2 [InlPrag=NOUSERINLINE[0]]
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_s6AVq w1_s6AVr]
        case w_s6AVq of {
          GHC.Types.I# ww1_s6AVt [Occ=Once] ->
              Data.Semigroup.Internal.$w$creadPrec ww1_s6AVt w1_s6AVr;
        };

Data.Semigroup.Internal.$fReadAll1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Semigroup.Internal.$fReadAll2 eta_B2 eta_B1;

Data.Semigroup.Internal.$fReadAll_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Semigroup.Internal.All
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [n_s6AVu]
        let {
          sat_s6AVv [Occ=Once]
            :: Text.ParserCombinators.ReadP.P Data.Semigroup.Internal.All
          [LclId] =
              [n_s6AVu] \u []
                  GHC.Read.list3
                      Data.Semigroup.Internal.$fReadAll2
                      n_s6AVu
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6AVv;

Data.Semigroup.Internal.$fReadAll_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.All]
[GblId] =
    [] \u [] GHC.Read.list Data.Semigroup.Internal.$fReadAll1;

Data.Semigroup.Internal.$fReadAll14
  :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Internal.All]
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fReadAll_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Semigroup.Internal.$fReadAll_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.All]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Data.Semigroup.Internal.$fReadAll14 eta_B1;

Data.Semigroup.Internal.$fReadAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Semigroup.Internal.$fReadAll_$creadsPrec
                                    Data.Semigroup.Internal.$fReadAll_$creadList
                                    Data.Semigroup.Internal.$fReadAll1
                                    Data.Semigroup.Internal.$fReadAll_$creadListPrec];

Data.Semigroup.Internal.$fEqAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Classes.$fEqBool_$c==
                                     GHC.Classes.$fEqBool_$c/=];

Data.Semigroup.Internal.$fOrdAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Semigroup.Internal.$fEqAll
                                      GHC.Classes.$fOrdBool_$ccompare
                                      GHC.Classes.$fOrdBool_$c<
                                      GHC.Classes.$fOrdBool_$c<=
                                      GHC.Classes.$fOrdBool_$c>
                                      GHC.Classes.$fOrdBool_$c>=
                                      GHC.Classes.$fOrdBool_$cmax
                                      GHC.Classes.$fOrdBool_$cmin];

Data.Semigroup.Internal.$fGenericEndo1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Endo a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Endo a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AVw] ds_s6AVw;

Data.Semigroup.Internal.$fGenericEndo2
  :: forall a x.
     Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AVx] x1_s6AVx;

Data.Semigroup.Internal.$fGenericEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericEndo2
                                           Data.Semigroup.Internal.$fGenericEndo1];

Data.Semigroup.Internal.$fGeneric1Dual1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Dual a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AVy] ds_s6AVy;

Data.Semigroup.Internal.$fGeneric1Dual2
  :: forall a.
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6AVz] x_s6AVz;

Data.Semigroup.Internal.$fGeneric1Dual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Dual
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Dual2
                                            Data.Semigroup.Internal.$fGeneric1Dual1];

Data.Semigroup.Internal.$fGenericDual1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Dual a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Dual a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AVA] ds_s6AVA;

Data.Semigroup.Internal.$fGenericDual2
  :: forall a x.
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AVB] x1_s6AVB;

Data.Semigroup.Internal.$fGenericDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericDual2
                                           Data.Semigroup.Internal.$fGenericDual1];

Data.Semigroup.Internal.$fBoundedDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6AVC]
        let {
          sat_s6AVE [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6sGr
          [LclId] =
              [$dBounded_s6AVC] \u [] GHC.Enum.maxBound $dBounded_s6AVC; } in
        let {
          sat_s6AVD [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6sGr
          [LclId] =
              [$dBounded_s6AVC] \u [] GHC.Enum.minBound $dBounded_s6AVC;
        } in  GHC.Enum.C:Bounded [sat_s6AVD sat_s6AVE];

Data.Semigroup.Internal.$fShowDual2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Dual {"#;

Data.Semigroup.Internal.$fShowDual1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getDual = "#;

Data.Semigroup.Internal.$w$cshowsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Dual a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AVF ww_s6AVG w1_s6AVH]
        let {
          f_s6AVI [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6AVF w1_s6AVH] \u []
                  GHC.Show.showsPrec
                      w_s6AVF Data.Semigroup.Internal.$fShowAlt1 w1_s6AVH;
        } in 
          case >=# [ww_s6AVG 11#] of {
            __DEFAULT ->
                let {
                  sat_s6AVO [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6AVI] \r [x_s6AVK]
                          let {
                            sat_s6AVN [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6AVI x_s6AVK] \u []
                                    let {
                                      sat_s6AVM [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6AVI x_s6AVK] \u []
                                              let {
                                                sat_s6AVL [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6AVK] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6AVK;
                                              } in  f_s6AVI sat_s6AVL;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowDual1 sat_s6AVM;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowDual2 sat_s6AVN;
                } in  sat_s6AVO;
            1# ->
                let {
                  sat_s6AVV [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6AVI] \r [x_s6AVP]
                          let {
                            sat_s6AVU [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6AVI x_s6AVP] \u []
                                    let {
                                      sat_s6AVT [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6AVI x_s6AVP] \u []
                                              let {
                                                sat_s6AVS [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6AVI x_s6AVP] \u []
                                                        let {
                                                          sat_s6AVR [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6AVP] \u []
                                                                  let {
                                                                    sat_s6AVQ [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6AVP];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6AVQ;
                                                        } in  f_s6AVI sat_s6AVR;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowDual1 sat_s6AVS;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowDual2 sat_s6AVT;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6AVU];
                } in  sat_s6AVV;
          };

Data.Semigroup.Internal.$fShowDual_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Internal.Dual a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AVW w1_s6AVX w2_s6AVY]
        case w1_s6AVX of {
          GHC.Types.I# ww1_s6AW0 [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec3 w_s6AVW ww1_s6AW0 w2_s6AVY;
        };

Data.Semigroup.Internal.$fShowDual_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Dual a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6AW1 x_s6AW2]
        let {
          sat_s6AW4 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6AW1 x_s6AW2] \u []
                  let {
                    sat_s6AW3 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6AW1 x_s6AW2] \u []
                            GHC.Show.showsPrec
                                $dShow_s6AW1
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6AW2
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowDual1 sat_s6AW3;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowDual2 sat_s6AW4;

Data.Semigroup.Internal.$fShowDual_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Dual a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6AW5 ls_s6AW6 s_s6AW7]
        let {
          sat_s6AW9 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AW5] \r [w_s6AW8]
                  Data.Semigroup.Internal.$w$cshowsPrec3 $dShow_s6AW5 0# w_s6AW8;
        } in  GHC.Show.showList__ sat_s6AW9 ls_s6AW6 s_s6AW7;

Data.Semigroup.Internal.$fShowDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6AWa]
        let {
          sat_s6AWd [Occ=Once]
            :: [Data.Semigroup.Internal.Dual a_a6sFL] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AWa] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshowList
                      $dShow_s6AWa eta_B2 eta_B1; } in
        let {
          sat_s6AWc [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Base.String
          [LclId] =
              [$dShow_s6AWa] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshow $dShow_s6AWa eta_B1; } in
        let {
          sat_s6AWb [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AWa] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshowsPrec
                      $dShow_s6AWa eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6AWb sat_s6AWc sat_s6AWd];

Data.Semigroup.Internal.$fReadDual5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Dual"#;

Data.Semigroup.Internal.$fReadDual4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadDual5;

Data.Semigroup.Internal.$fReadDual_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadDual4];

Data.Semigroup.Internal.$fReadDual3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getDual"#;

Data.Semigroup.Internal.$fReadDual2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadDual3;

Data.Semigroup.Internal.$fReadDual1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Dual a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AWe]
        let {
          lvl12_s6AWf [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6sEx
          [LclId] =
              [$dRead_s6AWe] \u []
                  GHC.Read.readPrec
                      $dRead_s6AWe Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6AWg [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6sEx
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6AWf] \r [ds1_s6AWh] lvl12_s6AWf; } in
        let {
          sat_s6AWB [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_a6sEx)
          [LclId] =
              [ds_s6AWg] \r [c_s6AWi eta_s6AWj]
                  case c_s6AWi of {
                    GHC.Types.I# x_s6AWl [Occ=Once] ->
                        case <=# [x_s6AWl 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6AWy [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6AWg eta_s6AWj] \r [a1_s6AWn]
                                        let {
                                          sat_s6AWv [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6AWg eta_s6AWj] \r [a2_s6AWo]
                                                  let {
                                                    sat_s6AWu [Occ=Once]
                                                      :: a_a6sEx
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6AWj] \r [a3_s6AWp]
                                                            let {
                                                              sat_s6AWr [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6AWj a3_s6AWp] \r [a4_s6AWq]
                                                                      eta_s6AWj a3_s6AWp;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6AWr
                                                              of
                                                              { Unit# ww1_s6AWt [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6AWt];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadDual2
                                                        ds_s6AWg
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6AWu;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6AWv
                                          of
                                          { Unit# ww1_s6AWx [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6AWx];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadDual_lexeme sat_s6AWy
                                of
                                { Unit# ww1_s6AWA [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6AWA];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6AWB;

Data.Semigroup.Internal.$fReadDual_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Dual a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AWC]
        let {
          ds_s6AWD [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Dual a_X6sTW
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6AWC] \u []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6AWC; } in
        let {
          sat_s6AWG [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Dual a_X6sTW)
          [LclId] =
              [ds_s6AWD] \r [n_s6AWE]
                  let {
                    sat_s6AWF [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Dual a_X6sTW)
                    [LclId] =
                        [ds_s6AWD n_s6AWE] \u []
                            ds_s6AWD
                                n_s6AWE Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6AWF;
        } in  sat_s6AWG;

Data.Semigroup.Internal.$fReadDual_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Dual a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AWH]
        let {
          sat_s6AWI [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_X6sTU)
          [LclId] =
              [$dRead_s6AWH] \s []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6AWH;
        } in  GHC.Read.list sat_s6AWI;

Data.Semigroup.Internal.$fReadDual_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Dual a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AWJ]
        let {
          sat_s6AWL [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Dual a_X6sTV]
          [LclId] =
              [$dRead_s6AWJ] \u []
                  let {
                    sat_s6AWK [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Dual a_X6sTV)
                    [LclId] =
                        [$dRead_s6AWJ] \s []
                            Data.Semigroup.Internal.$fReadDual1 $dRead_s6AWJ;
                  } in 
                    GHC.Read.list
                        sat_s6AWK
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6AWL;

Data.Semigroup.Internal.$fReadDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6AWM]
        let {
          sat_s6AWQ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Dual a_X6sTT]
          [LclId] =
              [$dRead_s6AWM] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadListPrec
                      $dRead_s6AWM; } in
        let {
          sat_s6AWP [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_X6sTT)
          [LclId] =
              [$dRead_s6AWM] \u []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6AWM; } in
        let {
          sat_s6AWO [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Dual a_X6sTT]
          [LclId] =
              [$dRead_s6AWM] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadList $dRead_s6AWM; } in
        let {
          sat_s6AWN [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Dual a_X6sTT)
          [LclId] =
              [$dRead_s6AWM] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadsPrec $dRead_s6AWM;
        } in  GHC.Read.C:Read [sat_s6AWN sat_s6AWO sat_s6AWP sat_s6AWQ];

Data.Semigroup.Internal.$fEqDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6AWR]
        let {
          sat_s6AWT [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCa
               -> Data.Semigroup.Internal.Dual a_a6sCa -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6AWR] \u [] GHC.Classes./= $dEq_s6AWR; } in
        let {
          sat_s6AWS [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCa
               -> Data.Semigroup.Internal.Dual a_a6sCa -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6AWR] \u [] GHC.Classes.== $dEq_s6AWR;
        } in  GHC.Classes.C:Eq [sat_s6AWS sat_s6AWT];

Data.Semigroup.Internal.$fOrdDual_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6AWU]
        let {
          sat_s6AWV [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6sCI
          [LclId] =
              [$dOrd_s6AWU] \u [] GHC.Classes.$p1Ord $dOrd_s6AWU;
        } in  Data.Semigroup.Internal.$fEqDual sat_s6AWV;

Data.Semigroup.Internal.$fOrdDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6AWW]
        let {
          sat_s6AX4 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.min $dOrd_s6AWW; } in
        let {
          sat_s6AX3 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.max $dOrd_s6AWW; } in
        let {
          sat_s6AX2 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.>= $dOrd_s6AWW; } in
        let {
          sat_s6AX1 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.> $dOrd_s6AWW; } in
        let {
          sat_s6AX0 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.<= $dOrd_s6AWW; } in
        let {
          sat_s6AWZ [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.< $dOrd_s6AWW; } in
        let {
          sat_s6AWY [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.compare $dOrd_s6AWW; } in
        let {
          sat_s6AWX [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Dual a_a6sCI)
          [LclId] =
              [$dOrd_s6AWW] \u []
                  Data.Semigroup.Internal.$fOrdDual_$cp1Ord $dOrd_s6AWW;
        } in 
          GHC.Classes.C:Ord [sat_s6AWX
                             sat_s6AWY
                             sat_s6AWZ
                             sat_s6AX0
                             sat_s6AX1
                             sat_s6AX2
                             sat_s6AX3
                             sat_s6AX4];

Data.Semigroup.Internal.getDual
  :: forall a. Data.Semigroup.Internal.Dual a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Semigroup.Internal.$fMonadDual_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> (a -> Data.Semigroup.Internal.Dual b)
     -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6AX5 k_s6AX6] k_s6AX6 m_s6AX5;

Data.Semigroup.Internal.$fMonadDual_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeDual_$c*> eta_B2 eta_B1;

lvl_r6v16
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6AX7] GHC.Err.errorWithoutStackTrace eta_s6AX7;

Data.Semigroup.Internal.$fMonadDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeDual
                                     Data.Semigroup.Internal.$fMonadDual_$c>>=
                                     Data.Semigroup.Internal.$fMonadDual_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl_r6v16];

Data.Semigroup.Internal.appEndo1
  :: forall a.
     Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AX8] ds_s6AX8;

Data.Semigroup.Internal.appEndo
  :: forall a. Data.Semigroup.Internal.Endo a -> a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.appEndo1 eta_B1;

Data.Semigroup.Internal.getAll1
  :: Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AX9] ds_s6AX9;

Data.Semigroup.Internal.getAll
  :: Data.Semigroup.Internal.All -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.getAll1 eta_B1;

Data.Semigroup.Internal.getAny1
  :: Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AXa] ds_s6AXa;

Data.Semigroup.Internal.getAny
  :: Data.Semigroup.Internal.Any -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.getAny1 eta_B1;

Data.Semigroup.Internal.getSum
  :: forall a. Data.Semigroup.Internal.Sum a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Semigroup.Internal.$fMonadSum_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> (a -> Data.Semigroup.Internal.Sum b)
     -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6AXb k_s6AXc] k_s6AXc m_s6AXb;

Data.Semigroup.Internal.$fMonadSum_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeSum_$c*> eta_B2 eta_B1;

lvl1_r6v17
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6AXd] GHC.Err.errorWithoutStackTrace eta_s6AXd;

Data.Semigroup.Internal.$fMonadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeSum
                                     Data.Semigroup.Internal.$fMonadSum_$c>>=
                                     Data.Semigroup.Internal.$fMonadSum_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl1_r6v17];

Data.Semigroup.Internal.getProduct
  :: forall a. Data.Semigroup.Internal.Product a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Semigroup.Internal.$fMonadProduct_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> (a -> Data.Semigroup.Internal.Product b)
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6AXe k_s6AXf] k_s6AXf m_s6AXe;

Data.Semigroup.Internal.$fMonadProduct_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeProduct_$c*> eta_B2 eta_B1;

lvl2_r6v18
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6AXg] GHC.Err.errorWithoutStackTrace eta_s6AXg;

Data.Semigroup.Internal.$fMonadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeProduct
                                     Data.Semigroup.Internal.$fMonadProduct_$c>>=
                                     Data.Semigroup.Internal.$fMonadProduct_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl2_r6v18];

Data.Semigroup.Internal.getAlt
  :: forall k (f :: k -> *) (a :: k).
     Data.Semigroup.Internal.Alt f a -> f a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Alt2 eta_B1;

lvl3_r6v19 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesIdempotent: positive multiplier expected"#;

Data.Semigroup.Internal.stimesIdempotent1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_r6v19 of sat_s6AXh {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6AXh;
        };

Data.Semigroup.Internal.stimesIdempotent
  :: forall b a. GHC.Real.Integral b => b -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AXi eta_s6AXj eta1_s6AXk]
        case
            GHC.Real.$p1Integral $dIntegral_s6AXi
        of
        $dReal_s6AXl [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6AXo [Occ=Once] :: b_a6sBZ
                [LclId] =
                    [$dReal_s6AXl] \u []
                        case GHC.Real.$p1Real $dReal_s6AXl of sat_s6AXn {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6AXn Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6AXl of sat_s6AXm {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s6AXm eta_s6AXj sat_s6AXo of {
                        GHC.Types.False -> eta1_s6AXk;
                        GHC.Types.True -> Data.Semigroup.Internal.stimesIdempotent1;
                      };
                };
        };

lvl4_r6v1a :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesIdempotentMonoid: negative multiplier"#;

Data.Semigroup.Internal.stimesIdempotentMonoid1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl4_r6v1a of sat_s6AXq {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6AXq;
        };

Data.Semigroup.Internal.stimesIdempotentMonoid
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(LC(C(S))LLLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,1*U(A,1*U,A,A)><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AXr $dMonoid_s6AXs eta_s6AXt eta1_s6AXu]
        case
            GHC.Real.$p1Integral $dIntegral_s6AXr
        of
        $dReal_s6AXv [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6AXy [Occ=Once] :: b_a6sBJ
                [LclId] =
                    [$dReal_s6AXv] \u []
                        case GHC.Real.$p1Real $dReal_s6AXv of sat_s6AXx {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6AXx Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6AXv of sat_s6AXw {
                  __DEFAULT ->
                      case GHC.Classes.compare sat_s6AXw eta_s6AXt sat_s6AXy of {
                        GHC.Types.LT -> Data.Semigroup.Internal.stimesIdempotentMonoid1;
                        GHC.Types.EQ -> GHC.Base.mempty $dMonoid_s6AXs;
                        GHC.Types.GT -> eta1_s6AXu;
                      };
                };
        };

Data.Semigroup.Internal.$fSemigroupAny_go [Occ=LoopBreaker]
  :: Data.Semigroup.Internal.Any
     -> [Data.Semigroup.Internal.Any] -> Data.Semigroup.Internal.Any
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6AXA ds1_s6AXB]
        case ds1_s6AXB of {
          [] -> b_s6AXA;
          : c_s6AXD [Occ=Once] cs_s6AXE [Occ=Once] ->
              case b_s6AXA of {
                GHC.Types.False ->
                    Data.Semigroup.Internal.$fSemigroupAny_go c_s6AXD cs_s6AXE;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

Data.Semigroup.Internal.$fSemigroupAny_$csconcat
  :: GHC.Base.NonEmpty Data.Semigroup.Internal.Any
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6AXG]
        case ds_s6AXG of {
          GHC.Base.:| a1_s6AXI [Occ=Once] as_s6AXJ [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupAny_go a1_s6AXI as_s6AXJ;
        };

Data.Semigroup.Internal.$fMonoidAny_go [Occ=LoopBreaker]
  :: [Data.Semigroup.Internal.Any] -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AXK]
        case ds_s6AXK of {
          [] -> GHC.Types.False [];
          : y_s6AXM [Occ=Once] ys_s6AXN [Occ=Once] ->
              case y_s6AXM of {
                GHC.Types.False -> Data.Semigroup.Internal.$fMonoidAny_go ys_s6AXN;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

Data.Semigroup.Internal.$fSemigroupAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Classes.||
                                         Data.Semigroup.Internal.$fSemigroupAny_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupAny_$cstimes];
Data.Semigroup.Internal.$fMonoidAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupAny
                                      GHC.Types.False
                                      GHC.Classes.||
                                      Data.Semigroup.Internal.$fMonoidAny_go];
Data.Semigroup.Internal.$fSemigroupAny_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AXP eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6AXP Data.Semigroup.Internal.$fMonoidAny eta_B2 eta_B1;

Data.Semigroup.Internal.$fSemigroupAll_go [Occ=LoopBreaker]
  :: Data.Semigroup.Internal.All
     -> [Data.Semigroup.Internal.All] -> Data.Semigroup.Internal.All
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6AXQ ds1_s6AXR]
        case ds1_s6AXR of {
          [] -> b_s6AXQ;
          : c_s6AXT [Occ=Once] cs_s6AXU [Occ=Once] ->
              case b_s6AXQ of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Semigroup.Internal.$fSemigroupAll_go c_s6AXT cs_s6AXU;
              };
        };

Data.Semigroup.Internal.$fSemigroupAll_$csconcat
  :: GHC.Base.NonEmpty Data.Semigroup.Internal.All
     -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6AXW]
        case ds_s6AXW of {
          GHC.Base.:| a1_s6AXY [Occ=Once] as_s6AXZ [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupAll_go a1_s6AXY as_s6AXZ;
        };

Data.Semigroup.Internal.$fMonoidAll_go [Occ=LoopBreaker]
  :: [Data.Semigroup.Internal.All] -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AY0]
        case ds_s6AY0 of {
          [] -> GHC.Types.True [];
          : y_s6AY2 [Occ=Once] ys_s6AY3 [Occ=Once] ->
              case y_s6AY2 of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> Data.Semigroup.Internal.$fMonoidAll_go ys_s6AY3;
              };
        };

Data.Semigroup.Internal.$fSemigroupAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Classes.&&
                                         Data.Semigroup.Internal.$fSemigroupAll_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupAll_$cstimes];
Data.Semigroup.Internal.$fMonoidAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupAll
                                      GHC.Types.True
                                      GHC.Classes.&&
                                      Data.Semigroup.Internal.$fMonoidAll_go];
Data.Semigroup.Internal.$fSemigroupAll_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AY5 eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6AY5 Data.Semigroup.Internal.$fMonoidAll eta_B2 eta_B1;

lvl5_r6v1b :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesMonoid: negative multiplier"#;

lvl6_r6v1c :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r6v1b of sat_s6AY6 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6AY6;
        };

sat_s6AY7 :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s6AY8 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6AY7 GHC.Types.[]];

lvl7_r6v1d :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6AY8;

Data.Semigroup.Internal.stimesMonoid
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(LC(C(S))LLLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(A,1*U,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AY9 $dMonoid_s6AYa eta_s6AYb eta1_s6AYc]
        case
            GHC.Real.$p1Integral $dIntegral_s6AY9
        of
        $dReal_s6AYd [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6AYg [Occ=Once] :: b_a6szg
                [LclId] =
                    [$dReal_s6AYd] \u []
                        case GHC.Real.$p1Real $dReal_s6AYd of sat_s6AYf {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6AYf Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6AYd of sat_s6AYe {
                  __DEFAULT ->
                      case GHC.Classes.compare sat_s6AYe eta_s6AYb sat_s6AYg of {
                        GHC.Types.LT -> lvl6_r6v1c;
                        GHC.Types.EQ -> GHC.Base.mempty $dMonoid_s6AYa;
                        GHC.Types.GT ->
                            let {
                              $dNum_s6AYi [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a6szg
                              [LclId] =
                                  [$dReal_s6AYd] \u [] GHC.Real.$p1Real $dReal_s6AYd; } in
                            let {
                              lvl12_s6AYj :: b_a6szg
                              [LclId] =
                                  [$dNum_s6AYi] \u [] GHC.Num.fromInteger $dNum_s6AYi lvl7_r6v1d;
                            } in 
                              let-no-escape {
                                exit_s6AYk [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                  :: a_a6szh -> b_a6szg -> a_a6szh
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s6AY9
                                              $dMonoid_s6AYa
                                              $dReal_s6AYd
                                              $dNum_s6AYi
                                              lvl12_s6AYj] \r [x_s6AYl y_s6AYm]
                                        case
                                            GHC.Real.$p2Real $dReal_s6AYd
                                        of
                                        $dEq_s6AYn [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              case
                                                  GHC.Classes.$p1Ord $dEq_s6AYn
                                              of
                                              $dEq1_s6AYo [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      lvl13_s6AYp :: b_a6szg
                                                      [LclId] =
                                                          [$dNum_s6AYi] \u []
                                                              GHC.Num.fromInteger
                                                                  $dNum_s6AYi
                                                                  Data.Semigroup.Internal.$fMonoidProduct1;
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq1_s6AYo y_s6AYm lvl13_s6AYp
                                                      of
                                                      { GHC.Types.False ->
                                                            let {
                                                              sat_s6AYG [Occ=Once] :: b_a6szg
                                                              [LclId] =
                                                                  [$dIntegral_s6AY9
                                                                   lvl12_s6AYj
                                                                   y_s6AYm] \u []
                                                                      GHC.Real.quot
                                                                          $dIntegral_s6AY9
                                                                          y_s6AYm
                                                                          lvl12_s6AYj; } in
                                                            let {
                                                              sat_s6AYF [Occ=Once] :: a_a6szh
                                                              [LclId] =
                                                                  [$dMonoid_s6AYa x_s6AYl] \u []
                                                                      GHC.Base.mappend
                                                                          $dMonoid_s6AYa
                                                                          x_s6AYl
                                                                          x_s6AYl;
                                                            } in 
                                                              let-no-escape {
                                                                exit1_s6AYr [Occ=OnceL!T[2],
                                                                             Dmd=<C(C(S)),C(C1(U))>]
                                                                  :: a_a6szh -> a_a6szh -> a_a6szh
                                                                [LclId[JoinId(2)],
                                                                 Arity=2,
                                                                 Str=<L,U><L,U>,
                                                                 Unf=OtherCon []] =
                                                                    sat-only [$dMonoid_s6AYa] \r [x1_s6AYs
                                                                                                  z_s6AYt]
                                                                        GHC.Base.mappend
                                                                            $dMonoid_s6AYa
                                                                            x1_s6AYs
                                                                            z_s6AYt;
                                                              } in 
                                                                let-no-escape {
                                                                  g_s6AYu [Occ=LoopBreakerT[3]]
                                                                    :: a_a6szh
                                                                       -> b_a6szg
                                                                       -> a_a6szh
                                                                       -> a_a6szh
                                                                  [LclId[JoinId(3)],
                                                                   Arity=3,
                                                                   Str=<L,U><L,U><L,U>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [$dIntegral_s6AY9
                                                                                $dMonoid_s6AYa
                                                                                lvl12_s6AYj
                                                                                $dEq1_s6AYo
                                                                                lvl13_s6AYp
                                                                                exit1_s6AYr
                                                                                g_s6AYu] \r [x1_s6AYv
                                                                                             y1_s6AYw
                                                                                             z_s6AYx]
                                                                          case
                                                                              GHC.Real.even
                                                                                  $dIntegral_s6AY9
                                                                                  y1_s6AYw
                                                                          of
                                                                          { GHC.Types.False ->
                                                                                case
                                                                                    GHC.Classes.==
                                                                                        $dEq1_s6AYo
                                                                                        y1_s6AYw
                                                                                        lvl13_s6AYp
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s6AYC [Occ=Once]
                                                                                          :: a_a6szh
                                                                                        [LclId] =
                                                                                            [$dMonoid_s6AYa
                                                                                             x1_s6AYv
                                                                                             z_s6AYx] \u []
                                                                                                GHC.Base.mappend
                                                                                                    $dMonoid_s6AYa
                                                                                                    x1_s6AYv
                                                                                                    z_s6AYx; } in
                                                                                      let {
                                                                                        sat_s6AYB [Occ=Once]
                                                                                          :: b_a6szg
                                                                                        [LclId] =
                                                                                            [$dIntegral_s6AY9
                                                                                             lvl12_s6AYj
                                                                                             y1_s6AYw] \u []
                                                                                                GHC.Real.quot
                                                                                                    $dIntegral_s6AY9
                                                                                                    y1_s6AYw
                                                                                                    lvl12_s6AYj; } in
                                                                                      let {
                                                                                        sat_s6AYA [Occ=Once]
                                                                                          :: a_a6szh
                                                                                        [LclId] =
                                                                                            [$dMonoid_s6AYa
                                                                                             x1_s6AYv] \u []
                                                                                                GHC.Base.mappend
                                                                                                    $dMonoid_s6AYa
                                                                                                    x1_s6AYv
                                                                                                    x1_s6AYv;
                                                                                      } in 
                                                                                        g_s6AYu
                                                                                            sat_s6AYA
                                                                                            sat_s6AYB
                                                                                            sat_s6AYC;
                                                                                  GHC.Types.True ->
                                                                                      exit1_s6AYr
                                                                                          x1_s6AYv
                                                                                          z_s6AYx;
                                                                                };
                                                                            GHC.Types.True ->
                                                                                let {
                                                                                  sat_s6AYE [Occ=Once]
                                                                                    :: b_a6szg
                                                                                  [LclId] =
                                                                                      [$dIntegral_s6AY9
                                                                                       lvl12_s6AYj
                                                                                       y1_s6AYw] \u []
                                                                                          GHC.Real.quot
                                                                                              $dIntegral_s6AY9
                                                                                              y1_s6AYw
                                                                                              lvl12_s6AYj; } in
                                                                                let {
                                                                                  sat_s6AYD [Occ=Once]
                                                                                    :: a_a6szh
                                                                                  [LclId] =
                                                                                      [$dMonoid_s6AYa
                                                                                       x1_s6AYv] \u []
                                                                                          GHC.Base.mappend
                                                                                              $dMonoid_s6AYa
                                                                                              x1_s6AYv
                                                                                              x1_s6AYv;
                                                                                } in 
                                                                                  g_s6AYu
                                                                                      sat_s6AYD
                                                                                      sat_s6AYE
                                                                                      z_s6AYx;
                                                                          };
                                                                } in 
                                                                  g_s6AYu
                                                                      sat_s6AYF sat_s6AYG x_s6AYl;
                                                        GHC.Types.True -> x_s6AYl;
                                                      };
                                              };
                                        };
                              } in 
                                let-no-escape {
                                  f_s6AYH [Occ=LoopBreakerT[2]] :: a_a6szh -> b_a6szg -> a_a6szh
                                  [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dIntegral_s6AY9
                                                $dMonoid_s6AYa
                                                lvl12_s6AYj
                                                exit_s6AYk
                                                f_s6AYH] \r [x_s6AYI y_s6AYJ]
                                          case GHC.Real.even $dIntegral_s6AY9 y_s6AYJ of {
                                            GHC.Types.False -> exit_s6AYk x_s6AYI y_s6AYJ;
                                            GHC.Types.True ->
                                                let {
                                                  sat_s6AYM [Occ=Once] :: b_a6szg
                                                  [LclId] =
                                                      [$dIntegral_s6AY9 lvl12_s6AYj y_s6AYJ] \u []
                                                          GHC.Real.quot
                                                              $dIntegral_s6AY9
                                                              y_s6AYJ
                                                              lvl12_s6AYj; } in
                                                let {
                                                  sat_s6AYL [Occ=Once] :: a_a6szh
                                                  [LclId] =
                                                      [$dMonoid_s6AYa x_s6AYI] \u []
                                                          GHC.Base.mappend
                                                              $dMonoid_s6AYa x_s6AYI x_s6AYI;
                                                } in  f_s6AYH sat_s6AYL sat_s6AYM;
                                          };
                                } in  f_s6AYH eta1_s6AYc eta_s6AYb;
                      };
                };
        };

Data.Semigroup.Internal.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     Data.Semigroup.Internal.Alt f a
     -> [Data.Semigroup.Internal.Alt f a]
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6AYN ww_s6AYO ww1_s6AYP]
        let {
          go_s6AYQ [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL
               -> [Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL]
               -> Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6AYN go_s6AYQ] \r [b_s6AYR ds1_s6AYS]
                  case ds1_s6AYS of {
                    [] -> b_s6AYR;
                    : c_s6AYU [Occ=Once] cs_s6AYV [Occ=Once] ->
                        let {
                          sat_s6AYW [Occ=Once] :: f_s6uNK a_s6uNL
                          [LclId] =
                              [go_s6AYQ c_s6AYU cs_s6AYV] \u [] go_s6AYQ c_s6AYU cs_s6AYV;
                        } in  GHC.Base.<|> w_s6AYN b_s6AYR sat_s6AYW;
                  };
        } in  go_s6AYQ ww_s6AYO ww1_s6AYP;

Data.Semigroup.Internal.$fSemigroupAlt_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Alt f a)
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6AYX w1_s6AYY]
        case w1_s6AYY of {
          GHC.Base.:| ww1_s6AZ0 [Occ=Once] ww2_s6AZ1 [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat w_s6AYX ww1_s6AZ0 ww2_s6AZ1;
        };

Data.Semigroup.Internal.$fMonoidAlt_$cmconcat
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     [Data.Semigroup.Internal.Alt f a]
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6AZ2 eta_s6AZ3]
        let {
          z_s6AZ4 [Occ=OnceL] :: f_X6tGf a_X6tGh
          [LclId] =
              [$dAlternative_s6AZ2] \u []
                  GHC.Base.empty $dAlternative_s6AZ2; } in
        let {
          go_s6AZ5 [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Alt f_X6tGf a_X6tGh]
               -> Data.Semigroup.Internal.Alt f_X6tGf a_X6tGh
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dAlternative_s6AZ2 z_s6AZ4 go_s6AZ5] \r [ds_s6AZ6]
                  case ds_s6AZ6 of {
                    [] -> z_s6AZ4;
                    : y_s6AZ8 [Occ=Once] ys_s6AZ9 [Occ=Once] ->
                        let {
                          sat_s6AZa [Occ=Once] :: f_X6tGf a_X6tGh
                          [LclId] =
                              [go_s6AZ5 ys_s6AZ9] \u [] go_s6AZ5 ys_s6AZ9;
                        } in  GHC.Base.<|> $dAlternative_s6AZ2 y_s6AZ8 sat_s6AZa;
                  };
        } in  go_s6AZ5 eta_s6AZ3;

Data.Semigroup.Internal.$fSemigroupAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A,A)>m] =
    [] \r [$dAlternative_s6AZb]
        let {
          sat_s6AZe [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6AZb] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupAlt_$cstimes
                      $dAlternative_s6AZb eta_B1; } in
        let {
          sat_s6AZd [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF)
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6AZb] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupAlt_$csconcat
                      $dAlternative_s6AZb eta_B1; } in
        let {
          sat_s6AZc [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6AZb] \u [] GHC.Base.<|> $dAlternative_s6AZb;
        } in  GHC.Base.C:Semigroup [sat_s6AZc sat_s6AZd sat_s6AZe];
Data.Semigroup.Internal.$fMonoidAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A,A)>m] =
    [] \r [$dAlternative_s6AZf]
        let {
          sat_s6AZj [Occ=Once]
            :: [Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9]
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6AZf] \r [eta_B1]
                  Data.Semigroup.Internal.$fMonoidAlt_$cmconcat
                      $dAlternative_s6AZf eta_B1; } in
        let {
          sat_s6AZi [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6AZf] \u [] GHC.Base.<|> $dAlternative_s6AZf; } in
        let {
          sat_s6AZh [Occ=Once] :: Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6AZf] \u []
                  GHC.Base.empty $dAlternative_s6AZf; } in
        let {
          sat_s6AZg [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9)
          [LclId] =
              [$dAlternative_s6AZf] \u []
                  Data.Semigroup.Internal.$fSemigroupAlt $dAlternative_s6AZf;
        } in  GHC.Base.C:Monoid [sat_s6AZg sat_s6AZh sat_s6AZi sat_s6AZj];
Data.Semigroup.Internal.$fSemigroupAlt_$cstimes [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     forall b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.Internal.Alt f a
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Str=<L,U(A,U,U,A,A)><L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6AZk $dIntegral_s6AZl]
        let {
          sat_s6AZm [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Alt f_X6tGK a_X6tGM)
          [LclId] =
              [$dAlternative_s6AZk] \u []
                  Data.Semigroup.Internal.$fMonoidAlt $dAlternative_s6AZk;
        } in 
          Data.Semigroup.Internal.stimesMonoid $dIntegral_s6AZl sat_s6AZm;

Data.Semigroup.Internal.$fSemigroupEndo1 [Occ=LoopBreaker]
  :: forall a.
     Data.Semigroup.Internal.Endo a
     -> [Data.Semigroup.Internal.Endo a]
     -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6AZn ds1_s6AZo]
        case ds1_s6AZo of {
          [] -> b_s6AZn;
          : c_s6AZq [Occ=Once] cs_s6AZr [Occ=Once] ->
              let {
                g_s6AZs [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Data.Semigroup.Internal.Endo a_a6tyX
                [LclId] =
                    [c_s6AZq cs_s6AZr] \u []
                        Data.Semigroup.Internal.$fSemigroupEndo1 c_s6AZq cs_s6AZr; } in
              let {
                sat_s6AZv [Occ=Once] :: a_a6tyX -> a_a6tyX
                [LclId] =
                    [b_s6AZn g_s6AZs] \r [x_s6AZt]
                        let {
                          sat_s6AZu [Occ=Once] :: a_a6tyX
                          [LclId] =
                              [g_s6AZs x_s6AZt] \u [] g_s6AZs x_s6AZt;
                        } in  b_s6AZn sat_s6AZu;
              } in  sat_s6AZv;
        };

Data.Semigroup.Internal.$fSemigroupEndo_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Endo a)
     -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6AZw]
        case ds_s6AZw of {
          GHC.Base.:| a1_s6AZy [Occ=Once] as_s6AZz [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupEndo1 a1_s6AZy as_s6AZz;
        };

Data.Semigroup.Internal.$fMonoidEndo1 [Occ=LoopBreaker]
  :: forall a. [Data.Semigroup.Internal.Endo a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6AZA eta_s6AZB]
        case ds_s6AZA of {
          [] -> eta_s6AZB;
          : y_s6AZD [Occ=Once] ys_s6AZE [Occ=Once] ->
              let {
                sat_s6AZF [Occ=Once] :: a_a6tyy
                [LclId] =
                    [eta_s6AZB ys_s6AZE] \u []
                        Data.Semigroup.Internal.$fMonoidEndo1 ys_s6AZE eta_s6AZB;
              } in  y_s6AZD sat_s6AZF;
        };

Data.Semigroup.Internal.$fSemigroupEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base..
                                         Data.Semigroup.Internal.$fSemigroupEndo_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupEndo_$cstimes];
Data.Semigroup.Internal.$fMonoidEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupEndo
                                      GHC.Base.id
                                      GHC.Base..
                                      Data.Semigroup.Internal.$fMonoidEndo1];
Data.Semigroup.Internal.$fSemigroupEndo_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AZG eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesMonoid
            $dIntegral_s6AZG
            Data.Semigroup.Internal.$fMonoidEndo
            eta_B2
            eta_B1;

lvl8_r6v1e :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: positive multiplier expected"#;

lvl9_r6v1f :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl8_r6v1e of sat_s6AZH {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6AZH;
        };

Data.Semigroup.Internal.stimesDefault
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Semigroup a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LLC(C(S))LLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(C(C1(U)),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AZI $dSemigroup_s6AZJ eta_s6AZK eta1_s6AZL]
        case
            GHC.Real.$p1Integral $dIntegral_s6AZI
        of
        $dReal_s6AZM [Dmd=<S(LS(S(C(C(S))L)LLC(C(S))LLLL)L),U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6AZP [Occ=Once] :: b_a6swD
                [LclId] =
                    [$dReal_s6AZM] \u []
                        case GHC.Real.$p1Real $dReal_s6AZM of sat_s6AZO {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6AZO Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6AZM of sat_s6AZN {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s6AZN eta_s6AZK sat_s6AZP of {
                        GHC.Types.False ->
                            let {
                              $dNum_s6AZR [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a6swD
                              [LclId] =
                                  [$dReal_s6AZM] \u [] GHC.Real.$p1Real $dReal_s6AZM; } in
                            let {
                              lvl12_s6AZS :: b_a6swD
                              [LclId] =
                                  [$dNum_s6AZR] \u [] GHC.Num.fromInteger $dNum_s6AZR lvl7_r6v1d;
                            } in 
                              let-no-escape {
                                exit_s6AZT [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                  :: a_a6swE -> b_a6swD -> a_a6swE
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s6AZI
                                              $dSemigroup_s6AZJ
                                              $dReal_s6AZM
                                              $dNum_s6AZR
                                              lvl12_s6AZS] \r [x_s6AZU y_s6AZV]
                                        case
                                            GHC.Real.$p2Real $dReal_s6AZM
                                        of
                                        $dEq_s6AZW [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              case
                                                  GHC.Classes.$p1Ord $dEq_s6AZW
                                              of
                                              $dEq1_s6AZX [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      lvl13_s6AZY :: b_a6swD
                                                      [LclId] =
                                                          [$dNum_s6AZR] \u []
                                                              GHC.Num.fromInteger
                                                                  $dNum_s6AZR
                                                                  Data.Semigroup.Internal.$fMonoidProduct1;
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq1_s6AZX y_s6AZV lvl13_s6AZY
                                                      of
                                                      { GHC.Types.False ->
                                                            let {
                                                              sat_s6B0f [Occ=Once] :: b_a6swD
                                                              [LclId] =
                                                                  [$dIntegral_s6AZI
                                                                   lvl12_s6AZS
                                                                   y_s6AZV] \u []
                                                                      GHC.Real.quot
                                                                          $dIntegral_s6AZI
                                                                          y_s6AZV
                                                                          lvl12_s6AZS; } in
                                                            let {
                                                              sat_s6B0e [Occ=Once] :: a_a6swE
                                                              [LclId] =
                                                                  [$dSemigroup_s6AZJ x_s6AZU] \u []
                                                                      GHC.Base.<>
                                                                          $dSemigroup_s6AZJ
                                                                          x_s6AZU
                                                                          x_s6AZU;
                                                            } in 
                                                              let-no-escape {
                                                                exit1_s6B00 [Occ=OnceL!T[2],
                                                                             Dmd=<C(C(S)),C(C1(U))>]
                                                                  :: a_a6swE -> a_a6swE -> a_a6swE
                                                                [LclId[JoinId(2)],
                                                                 Arity=2,
                                                                 Str=<L,U><L,U>,
                                                                 Unf=OtherCon []] =
                                                                    sat-only [$dSemigroup_s6AZJ] \r [x1_s6B01
                                                                                                     z_s6B02]
                                                                        GHC.Base.<>
                                                                            $dSemigroup_s6AZJ
                                                                            x1_s6B01
                                                                            z_s6B02;
                                                              } in 
                                                                let-no-escape {
                                                                  g_s6B03 [Occ=LoopBreakerT[3]]
                                                                    :: a_a6swE
                                                                       -> b_a6swD
                                                                       -> a_a6swE
                                                                       -> a_a6swE
                                                                  [LclId[JoinId(3)],
                                                                   Arity=3,
                                                                   Str=<L,U><L,U><L,U>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [$dIntegral_s6AZI
                                                                                $dSemigroup_s6AZJ
                                                                                lvl12_s6AZS
                                                                                $dEq1_s6AZX
                                                                                lvl13_s6AZY
                                                                                exit1_s6B00
                                                                                g_s6B03] \r [x1_s6B04
                                                                                             y1_s6B05
                                                                                             z_s6B06]
                                                                          case
                                                                              GHC.Real.even
                                                                                  $dIntegral_s6AZI
                                                                                  y1_s6B05
                                                                          of
                                                                          { GHC.Types.False ->
                                                                                case
                                                                                    GHC.Classes.==
                                                                                        $dEq1_s6AZX
                                                                                        y1_s6B05
                                                                                        lvl13_s6AZY
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s6B0b [Occ=Once]
                                                                                          :: a_a6swE
                                                                                        [LclId] =
                                                                                            [$dSemigroup_s6AZJ
                                                                                             x1_s6B04
                                                                                             z_s6B06] \u []
                                                                                                GHC.Base.<>
                                                                                                    $dSemigroup_s6AZJ
                                                                                                    x1_s6B04
                                                                                                    z_s6B06; } in
                                                                                      let {
                                                                                        sat_s6B0a [Occ=Once]
                                                                                          :: b_a6swD
                                                                                        [LclId] =
                                                                                            [$dIntegral_s6AZI
                                                                                             lvl12_s6AZS
                                                                                             y1_s6B05] \u []
                                                                                                GHC.Real.quot
                                                                                                    $dIntegral_s6AZI
                                                                                                    y1_s6B05
                                                                                                    lvl12_s6AZS; } in
                                                                                      let {
                                                                                        sat_s6B09 [Occ=Once]
                                                                                          :: a_a6swE
                                                                                        [LclId] =
                                                                                            [$dSemigroup_s6AZJ
                                                                                             x1_s6B04] \u []
                                                                                                GHC.Base.<>
                                                                                                    $dSemigroup_s6AZJ
                                                                                                    x1_s6B04
                                                                                                    x1_s6B04;
                                                                                      } in 
                                                                                        g_s6B03
                                                                                            sat_s6B09
                                                                                            sat_s6B0a
                                                                                            sat_s6B0b;
                                                                                  GHC.Types.True ->
                                                                                      exit1_s6B00
                                                                                          x1_s6B04
                                                                                          z_s6B06;
                                                                                };
                                                                            GHC.Types.True ->
                                                                                let {
                                                                                  sat_s6B0d [Occ=Once]
                                                                                    :: b_a6swD
                                                                                  [LclId] =
                                                                                      [$dIntegral_s6AZI
                                                                                       lvl12_s6AZS
                                                                                       y1_s6B05] \u []
                                                                                          GHC.Real.quot
                                                                                              $dIntegral_s6AZI
                                                                                              y1_s6B05
                                                                                              lvl12_s6AZS; } in
                                                                                let {
                                                                                  sat_s6B0c [Occ=Once]
                                                                                    :: a_a6swE
                                                                                  [LclId] =
                                                                                      [$dSemigroup_s6AZJ
                                                                                       x1_s6B04] \u []
                                                                                          GHC.Base.<>
                                                                                              $dSemigroup_s6AZJ
                                                                                              x1_s6B04
                                                                                              x1_s6B04;
                                                                                } in 
                                                                                  g_s6B03
                                                                                      sat_s6B0c
                                                                                      sat_s6B0d
                                                                                      z_s6B06;
                                                                          };
                                                                } in 
                                                                  g_s6B03
                                                                      sat_s6B0e sat_s6B0f x_s6AZU;
                                                        GHC.Types.True -> x_s6AZU;
                                                      };
                                              };
                                        };
                              } in 
                                let-no-escape {
                                  f_s6B0g [Occ=LoopBreakerT[2]] :: a_a6swE -> b_a6swD -> a_a6swE
                                  [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dIntegral_s6AZI
                                                $dSemigroup_s6AZJ
                                                lvl12_s6AZS
                                                exit_s6AZT
                                                f_s6B0g] \r [x_s6B0h y_s6B0i]
                                          case GHC.Real.even $dIntegral_s6AZI y_s6B0i of {
                                            GHC.Types.False -> exit_s6AZT x_s6B0h y_s6B0i;
                                            GHC.Types.True ->
                                                let {
                                                  sat_s6B0l [Occ=Once] :: b_a6swD
                                                  [LclId] =
                                                      [$dIntegral_s6AZI lvl12_s6AZS y_s6B0i] \u []
                                                          GHC.Real.quot
                                                              $dIntegral_s6AZI
                                                              y_s6B0i
                                                              lvl12_s6AZS; } in
                                                let {
                                                  sat_s6B0k [Occ=Once] :: a_a6swE
                                                  [LclId] =
                                                      [$dSemigroup_s6AZJ x_s6B0h] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup_s6AZJ x_s6B0h x_s6B0h;
                                                } in  f_s6B0g sat_s6B0k sat_s6B0l;
                                          };
                                } in  f_s6B0g eta1_s6AZL eta_s6AZK;
                        GHC.Types.True -> lvl9_r6v1f;
                      };
                };
        };

lvl10_r6v1g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: Maybe, negative multiplier"#;

Data.Semigroup.Internal.stimesMaybe1 :: forall a. GHC.Base.Maybe a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl10_r6v1g of sat_s6B0m {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6B0m;
        };

Data.Semigroup.Internal.stimesMaybe
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Semigroup a) =>
     b -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=4,
 Str=<L,U(U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6B0n $dSemigroup_s6B0o eta_s6B0p eta1_s6B0q]
        case eta1_s6B0q of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_s6B0s [Occ=Once] ->
              case
                  GHC.Real.$p1Integral $dIntegral_s6B0n
              of
              $dReal_s6B0t [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_s6B0w [Occ=Once] :: b_a6swh
                      [LclId] =
                          [$dReal_s6B0t] \u []
                              case GHC.Real.$p1Real $dReal_s6B0t of sat_s6B0v {
                                __DEFAULT ->
                                    GHC.Num.fromInteger
                                        sat_s6B0v Data.Semigroup.Internal.$fMonoidSum1;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_s6B0t of sat_s6B0u {
                        __DEFAULT ->
                            case GHC.Classes.compare sat_s6B0u eta_s6B0p sat_s6B0w of {
                              GHC.Types.LT -> Data.Semigroup.Internal.stimesMaybe1;
                              GHC.Types.EQ -> GHC.Base.Nothing [];
                              GHC.Types.GT ->
                                  let {
                                    sat_s6B0y [Occ=Once] :: a_a6swi
                                    [LclId] =
                                        [$dIntegral_s6B0n
                                         $dSemigroup_s6B0o
                                         eta_s6B0p
                                         a1_s6B0s] \u []
                                            GHC.Base.stimes
                                                $dSemigroup_s6B0o
                                                $dIntegral_s6B0n
                                                eta_s6B0p
                                                a1_s6B0s;
                                  } in  GHC.Base.Just [sat_s6B0y];
                            };
                      };
              };
        };

lvl11_r6v1h :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: [], negative multiplier"#;

Data.Semigroup.Internal.stimesList1 :: forall a. [a]
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_r6v1h of sat_s6B0z {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6B0z;
        };

Data.Semigroup.Internal.stimesList
  :: forall b a. GHC.Real.Integral b => b -> [a] -> [a]
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6B0A eta_s6B0B eta1_s6B0C]
        case
            GHC.Real.$p1Integral $dIntegral_s6B0A
        of
        $dReal_s6B0D [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,C(C1(U)),A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s6B0E [Dmd=<L,U(A,C(C1(U)),A,A,A,A,C(U))>]
                  :: GHC.Num.Num b_a6svr
                [LclId] =
                    [$dReal_s6B0D] \u [] GHC.Real.$p1Real $dReal_s6B0D;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s6B0D
                of
                $dOrd_s6B0F [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s6B0G [Occ=Once] :: b_a6svr
                        [LclId] =
                            [$dNum_s6B0E] \u []
                                GHC.Num.fromInteger
                                    $dNum_s6B0E Data.Semigroup.Internal.$fMonoidSum1;
                      } in 
                        case GHC.Classes.< $dOrd_s6B0F eta_s6B0B sat_s6B0G of {
                          GHC.Types.False ->
                              let {
                                lvl12_s6B0I [Occ=OnceL] :: b_a6svr
                                [LclId] =
                                    [$dNum_s6B0E] \u []
                                        GHC.Num.fromInteger
                                            $dNum_s6B0E
                                            Data.Semigroup.Internal.$fMonoidProduct1; } in
                              let {
                                lvl13_s6B0J [Occ=OnceL] :: b_a6svr
                                [LclId] =
                                    [$dNum_s6B0E] \u []
                                        GHC.Num.fromInteger
                                            $dNum_s6B0E Data.Semigroup.Internal.$fMonoidSum1;
                              } in 
                                case
                                    GHC.Classes.$p1Ord $dOrd_s6B0F
                                of
                                $dEq_s6B0K [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                { __DEFAULT ->
                                      let {
                                        rep_s6B0L [Occ=LoopBreaker] :: b_a6svr -> [a_a6svs]
                                        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                            sat-only [eta1_s6B0C
                                                      $dNum_s6B0E
                                                      lvl12_s6B0I
                                                      lvl13_s6B0J
                                                      $dEq_s6B0K
                                                      rep_s6B0L] \r [ds_s6B0M]
                                                case
                                                    GHC.Classes.== $dEq_s6B0K ds_s6B0M lvl13_s6B0J
                                                of
                                                { GHC.Types.False ->
                                                      let {
                                                        sat_s6B0P [Occ=Once, Dmd=<L,1*U>]
                                                          :: [a_a6svs]
                                                        [LclId] =
                                                            [$dNum_s6B0E
                                                             lvl12_s6B0I
                                                             rep_s6B0L
                                                             ds_s6B0M] \s []
                                                                let {
                                                                  sat_s6B0O [Occ=Once] :: b_a6svr
                                                                  [LclId] =
                                                                      [$dNum_s6B0E
                                                                       lvl12_s6B0I
                                                                       ds_s6B0M] \u []
                                                                          GHC.Num.-
                                                                              $dNum_s6B0E
                                                                              ds_s6B0M
                                                                              lvl12_s6B0I;
                                                                } in  rep_s6B0L sat_s6B0O;
                                                      } in  GHC.Base.++ eta1_s6B0C sat_s6B0P;
                                                  GHC.Types.True -> [] [];
                                                };
                                      } in  rep_s6B0L eta_s6B0B;
                                };
                          GHC.Types.True -> Data.Semigroup.Internal.stimesList1;
                        };
                };
        };

Data.Semigroup.Internal.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Semigroup.Internal.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$trModule4];

Data.Semigroup.Internal.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Semigroup.Internal"#;

Data.Semigroup.Internal.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$trModule2];

Data.Semigroup.Internal.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Semigroup.Internal.$trModule3
                                     Data.Semigroup.Internal.$trModule1];

$krep_r6v1i :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep1_r6v1j :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r6v1k :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep1_r6v1j];

$krep3_r6v1l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j
                                         GHC.Types.krep$*];

Data.Semigroup.Internal.$tcAlt1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r6v1l $krep3_r6v1l];

$krep4_r6v1m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_r6v1n :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep6_r6v1o :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_r6v1m $krep5_r6v1n];

Data.Semigroup.Internal.$tcDual1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadDual5];

Data.Semigroup.Internal.$tcDual :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14711416616195557841##
                                    10971851269997195248##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcDual1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep7_r6v1p :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r6v1j GHC.Types.[]];

$krep8_r6v1q :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcDual
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Dual1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep8_r6v1q];

Data.Semigroup.Internal.$tc'Dual3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Dual"#;

Data.Semigroup.Internal.$tc'Dual2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Dual3];

Data.Semigroup.Internal.$tc'Dual :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15885009659242865261##
                                    15931193389986079612##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Dual2
                                    1#
                                    Data.Semigroup.Internal.$tc'Dual1];

Data.Semigroup.Internal.$tcEndo2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Endo"#;

Data.Semigroup.Internal.$tcEndo1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tcEndo2];

Data.Semigroup.Internal.$tcEndo :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16820921632006328603##
                                    4981834339379479823##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcEndo1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r6v1r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcEndo
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Endo1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6v1k $krep9_r6v1r];

Data.Semigroup.Internal.$tc'Endo3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Endo"#;

Data.Semigroup.Internal.$tc'Endo2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Endo3];

Data.Semigroup.Internal.$tc'Endo :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [156297185665537802##
                                    8988325904501215692##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Endo2
                                    1#
                                    Data.Semigroup.Internal.$tc'Endo1];

Data.Semigroup.Internal.$tcAll1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAll13];

Data.Semigroup.Internal.$tcAll :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14149274874874504208##
                                    8164254778609961234##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAll1
                                    0#
                                    GHC.Types.krep$*];

$krep10_r6v1s :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAll
                                              GHC.Types.[]];

Data.Semigroup.Internal.$tc'All1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r6v1i $krep10_r6v1s];

Data.Semigroup.Internal.$tc'All3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'All"#;

Data.Semigroup.Internal.$tc'All2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'All3];

Data.Semigroup.Internal.$tc'All :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1168494541548489787##
                                    10689931498683547374##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'All2
                                    0#
                                    Data.Semigroup.Internal.$tc'All1];

Data.Semigroup.Internal.$tcAny1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAny6];

Data.Semigroup.Internal.$tcAny :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11600287624241135668##
                                    17600231731807245316##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAny1
                                    0#
                                    GHC.Types.krep$*];

$krep11_r6v1t :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAny
                                              GHC.Types.[]];

Data.Semigroup.Internal.$tc'Any1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r6v1i $krep11_r6v1t];

Data.Semigroup.Internal.$tc'Any3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Any"#;

Data.Semigroup.Internal.$tc'Any2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Any3];

Data.Semigroup.Internal.$tc'Any :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16164188984560189013##
                                    110490866064676064##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Any2
                                    0#
                                    Data.Semigroup.Internal.$tc'Any1];

Data.Semigroup.Internal.$tcSum1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadSum5];

Data.Semigroup.Internal.$tcSum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7521450980204740829##
                                    14029043805042477297##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcSum1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep12_r6v1u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcSum
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Sum1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep12_r6v1u];

Data.Semigroup.Internal.$tc'Sum3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Sum"#;

Data.Semigroup.Internal.$tc'Sum2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Sum3];

Data.Semigroup.Internal.$tc'Sum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7144872330799658717##
                                    13465414667749873698##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Sum2
                                    1#
                                    Data.Semigroup.Internal.$tc'Sum1];

Data.Semigroup.Internal.$tcProduct1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadProduct5];

Data.Semigroup.Internal.$tcProduct :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12271745360620305859##
                                    5747185732973757022##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcProduct1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_r6v1v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcProduct
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Product1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep13_r6v1v];

Data.Semigroup.Internal.$tc'Product3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Product"#;

Data.Semigroup.Internal.$tc'Product2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Product3];

Data.Semigroup.Internal.$tc'Product :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3191278115598904989##
                                    12638872580785847167##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Product2
                                    1#
                                    Data.Semigroup.Internal.$tc'Product1];

Data.Semigroup.Internal.$tcAlt2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAlt5];

Data.Semigroup.Internal.$tcAlt :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7601313288863504805##
                                    2369500163797891218##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAlt2
                                    1#
                                    Data.Semigroup.Internal.$tcAlt1];

$krep14_r6v1w :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_r6v1n GHC.Types.[]];

$krep15_r6v1x :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_r6v1m $krep14_r6v1w];

$krep16_r6v1y :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r6v1j $krep15_r6v1x];

$krep17_r6v1z :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAlt
                                              $krep16_r6v1y];

Data.Semigroup.Internal.$tc'Alt1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r6v1o $krep17_r6v1z];

Data.Semigroup.Internal.$tc'Alt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Alt"#;

Data.Semigroup.Internal.$tc'Alt2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Alt3];

Data.Semigroup.Internal.$tc'Alt :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1436877498177162483##
                                    16937142347825669760##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Alt2
                                    3#
                                    Data.Semigroup.Internal.$tc'Alt1];


==================== STG syntax: ====================
2018-03-16 16:01:53.791391359 UTC

Data.Semigroup.Internal.$w$csconcat1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     Data.Semigroup.Internal.Dual a
     -> [Data.Semigroup.Internal.Dual a]
     -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6ALv ww_s6ALw ww1_s6ALx]
        let {
          go_s6ALy [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Dual a_s6uKL
               -> [Data.Semigroup.Internal.Dual a_s6uKL]
               -> Data.Semigroup.Internal.Dual a_s6uKL
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6ALv go_s6ALy] \r [b_s6ALz ds1_s6ALA]
                  case ds1_s6ALA of {
                    [] -> b_s6ALz;
                    : c_s6ALC [Occ=Once] cs_s6ALD [Occ=Once] ->
                        let {
                          sat_s6ALE [Occ=Once] :: a_s6uKL
                          [LclId] =
                              [go_s6ALy c_s6ALC cs_s6ALD] \u [] go_s6ALy c_s6ALC cs_s6ALD;
                        } in  GHC.Base.<> w_s6ALv sat_s6ALE b_s6ALz;
                  };
        } in  go_s6ALy ww_s6ALw ww1_s6ALx;

Data.Semigroup.Internal.$fSemigroupDual_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Dual a)
     -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6ALF w1_s6ALG]
        case w1_s6ALG of {
          GHC.Base.:| ww1_s6ALI [Occ=Once] ww2_s6ALJ [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat1 w_s6ALF ww1_s6ALI ww2_s6ALJ;
        };

Data.Semigroup.Internal.$fSemigroupDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Semigroup a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,C(C1(C1(U))))>m] =
    [] \r [$dSemigroup_s6ALK]
        let {
          sat_s6ALS [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6ALK] \r [$dIntegral_s6ALP n_s6ALQ ds_s6ALR]
                  GHC.Base.stimes
                      $dSemigroup_s6ALK $dIntegral_s6ALP n_s6ALQ ds_s6ALR; } in
        let {
          sat_s6ALO [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Dual a_X6tId)
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6ALK] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupDual_$csconcat
                      $dSemigroup_s6ALK eta_B1; } in
        let {
          sat_s6ALN [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
               -> Data.Semigroup.Internal.Dual a_X6tId
          [LclId] =
              [$dSemigroup_s6ALK] \r [ds_s6ALL ds1_s6ALM]
                  GHC.Base.<> $dSemigroup_s6ALK ds1_s6ALM ds_s6ALL;
        } in  GHC.Base.C:Semigroup [sat_s6ALN sat_s6ALO sat_s6ALS];

Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(C(C1(U)),A,C(C1(C1(U)))),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6ALT]
        let {
          sat_s6ALU [Occ=Once, Dmd=<L,U(C(C1(U)),A,C(C1(C1(U))))>]
            :: GHC.Base.Semigroup a_a6tBw
          [LclId] =
              [$dMonoid_s6ALT] \u [] GHC.Base.$p1Monoid $dMonoid_s6ALT;
        } in  Data.Semigroup.Internal.$fSemigroupDual sat_s6ALU;

$cmappend_r6v15
  :: forall a.
     GHC.Base.Monoid a =>
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual a -> a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    sat-only [] \r [$dMonoid_s6ALV ds_s6ALW ds1_s6ALX]
        case GHC.Base.$p1Monoid $dMonoid_s6ALV of sat_s6ALY {
          __DEFAULT -> GHC.Base.<> sat_s6ALY ds1_s6ALX ds_s6ALW;
        };

Data.Semigroup.Internal.$fMonoidDual_$cmappend [InlPrag=INLINE (sat-args=0)]
  :: forall a.
     GHC.Base.Monoid a =>
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S(C(C(S))LL)LLL),1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1] $cmappend_r6v15 eta_B3 eta_B2 eta_B1;

Data.Semigroup.Internal.$fMonoidDual_$cmconcat
  :: forall a.
     GHC.Base.Monoid a =>
     [Data.Semigroup.Internal.Dual a] -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U(C(C1(U)),A,A),1*U,A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dMonoid_s6ALZ eta_s6AM0]
        let {
          lvl12_s6AM1 [Occ=OnceL, Dmd=<L,U(C(C1(U)),A,A)>]
            :: GHC.Base.Semigroup a_X6tHX
          [LclId] =
              [$dMonoid_s6ALZ] \u [] GHC.Base.$p1Monoid $dMonoid_s6ALZ; } in
        let {
          z_s6AM2 [Occ=OnceL] :: a_X6tHX
          [LclId] =
              [$dMonoid_s6ALZ] \u [] GHC.Base.mempty $dMonoid_s6ALZ; } in
        let {
          go_s6AM3 [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Dual a_X6tHX]
               -> Data.Semigroup.Internal.Dual a_X6tHX
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [lvl12_s6AM1 z_s6AM2 go_s6AM3] \r [ds_s6AM4]
                  case ds_s6AM4 of {
                    [] -> z_s6AM2;
                    : y_s6AM6 [Occ=Once] ys_s6AM7 [Occ=Once] ->
                        let {
                          sat_s6AM8 [Occ=Once] :: a_X6tHX
                          [LclId] =
                              [go_s6AM3 ys_s6AM7] \u [] go_s6AM3 ys_s6AM7;
                        } in  GHC.Base.<> lvl12_s6AM1 sat_s6AM8 y_s6AM6;
                  };
        } in  go_s6AM3 eta_s6AM0;

Data.Semigroup.Internal.$fMonoidDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Base.Monoid a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U(C(C1(U)),A,C(C1(C1(U)))),U,A,A)>m] =
    [] \r [$dMonoid_s6AM9]
        let {
          sat_s6AMd [Occ=Once]
            :: [Data.Semigroup.Internal.Dual a_a6tBw]
               -> Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6AM9] \r [eta_B1]
                  Data.Semigroup.Internal.$fMonoidDual_$cmconcat
                      $dMonoid_s6AM9 eta_B1; } in
        let {
          sat_s6AMc [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6tBw
               -> Data.Semigroup.Internal.Dual a_a6tBw
               -> Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6AM9] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fMonoidDual_$cmappend
                      $dMonoid_s6AM9 eta_B2 eta_B1; } in
        let {
          sat_s6AMb [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6tBw
          [LclId] =
              [$dMonoid_s6AM9] \u [] GHC.Base.mempty $dMonoid_s6AM9; } in
        let {
          sat_s6AMa [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Dual a_a6tBw)
          [LclId] =
              [$dMonoid_s6AM9] \u []
                  Data.Semigroup.Internal.$fMonoidDual_$cp1Monoid $dMonoid_s6AM9;
        } in  GHC.Base.C:Monoid [sat_s6AMa sat_s6AMb sat_s6AMc sat_s6AMd];

Data.Semigroup.Internal.$fFunctorDual2
  :: forall a b. (a -> b) -> a -> b
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6AMe] v_s6AMe;

Data.Semigroup.Internal.$fFunctorDual1 :: forall b a. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6AMf ds_s6AMg] x_s6AMf;

Data.Semigroup.Internal.$fFunctorDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeDual3
  :: forall a b.
     Data.Semigroup.Internal.Dual (a -> b)
     -> Data.Semigroup.Internal.Dual (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6AMh] v_s6AMh;

Data.Semigroup.Internal.$fApplicativeDual4 :: forall a. a -> a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6AMi] v_s6AMi;

Data.Semigroup.Internal.$fApplicativeDual2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Dual a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6AMj x_s6AMk] f1_s6AMj x_s6AMk;

Data.Semigroup.Internal.$fApplicativeDual_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6AMl a2_s6AMm] a2_s6AMm;

Data.Semigroup.Internal.$fApplicativeDual1
  :: forall b a.
     Data.Semigroup.Internal.Dual a
     -> b -> Data.Semigroup.Internal.Dual a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6AMn ds_s6AMo] x_s6AMn;

Data.Semigroup.Internal.$fApplicativeDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorDual
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeDual3
                                           Data.Semigroup.Internal.$fApplicativeDual2
                                           Data.Semigroup.Internal.$fApplicativeDual_$c*>
                                           Data.Semigroup.Internal.$fApplicativeDual1];

Data.Semigroup.Internal.$fSemigroupSum1
  :: forall a.
     GHC.Num.Num a =>
     forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.Sum a -> a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLL),U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><L,1*U(A,A,A,A,A,A,A,A,1*C1(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6AMp $dIntegral_s6AMq n_s6AMr ds_s6AMs]
        let {
          sat_s6AMu [Occ=Once] :: a_a6two
          [LclId] =
              [$dNum_s6AMp $dIntegral_s6AMq n_s6AMr] \u []
                  let {
                    sat_s6AMt [Occ=Once] :: GHC.Integer.Type.Integer
                    [LclId] =
                        [$dIntegral_s6AMq n_s6AMr] \u []
                            GHC.Real.toInteger $dIntegral_s6AMq n_s6AMr;
                  } in  GHC.Num.fromInteger $dNum_s6AMp sat_s6AMt;
        } in  GHC.Num.* $dNum_s6AMp sat_s6AMu ds_s6AMs;

Data.Semigroup.Internal.$w$csconcat3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Sum a
     -> [Data.Semigroup.Internal.Sum a] -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6AMv ww_s6AMw ww1_s6AMx]
        let {
          go_s6AMy [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Sum a_s6uL0
               -> [Data.Semigroup.Internal.Sum a_s6uL0]
               -> Data.Semigroup.Internal.Sum a_s6uL0
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6AMv go_s6AMy] \r [b_s6AMz ds1_s6AMA]
                  case ds1_s6AMA of {
                    [] -> b_s6AMz;
                    : c_s6AMC [Occ=Once] cs_s6AMD [Occ=Once] ->
                        let {
                          sat_s6AME [Occ=Once] :: a_s6uL0
                          [LclId] =
                              [go_s6AMy c_s6AMC cs_s6AMD] \u [] go_s6AMy c_s6AMC cs_s6AMD;
                        } in  GHC.Num.+ w_s6AMv b_s6AMz sat_s6AME;
                  };
        } in  go_s6AMy ww_s6AMw ww1_s6AMx;

Data.Semigroup.Internal.$fSemigroupSum_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Sum a)
     -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A,A,A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6AMF w1_s6AMG]
        case w1_s6AMG of {
          GHC.Base.:| ww1_s6AMI [Occ=Once] ww2_s6AMJ [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat3 w_s6AMF ww1_s6AMI ww2_s6AMJ;
        };

Data.Semigroup.Internal.$fSemigroupSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(U,A,C(C1(U)),A,A,A,C(U))>m] =
    [] \r [$dNum_s6AMK]
        let {
          sat_s6AMN [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6AMK] \r [eta_B3 eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fSemigroupSum1
                      $dNum_s6AMK eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s6AMM [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Sum a_X6tDl)
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6AMK] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupSum_$csconcat
                      $dNum_s6AMK eta_B1; } in
        let {
          sat_s6AML [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
               -> Data.Semigroup.Internal.Sum a_X6tDl
          [LclId] =
              [$dNum_s6AMK] \u [] GHC.Num.+ $dNum_s6AMK;
        } in  GHC.Base.C:Semigroup [sat_s6AML sat_s6AMM sat_s6AMN];

Data.Semigroup.Internal.$fMonoidSum1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Data.Semigroup.Internal.$fMonoidSum2
  :: forall a. GHC.Num.Num a => a
[GblId,
 Arity=1,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6AMO]
        GHC.Num.fromInteger
            $dNum_s6AMO Data.Semigroup.Internal.$fMonoidSum1;

Data.Semigroup.Internal.$fMonoidSum_$cmconcat
  :: forall a.
     GHC.Num.Num a =>
     [Data.Semigroup.Internal.Sum a] -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=1,
 Str=<L,U(C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6AMP]
        let {
          z_s6AMQ [Occ=OnceL] :: a_X6tD4
          [LclId] =
              [$dNum_s6AMP] \u []
                  GHC.Num.fromInteger
                      $dNum_s6AMP Data.Semigroup.Internal.$fMonoidSum1; } in
        let {
          go_s6AMR [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Sum a_X6tD4]
               -> Data.Semigroup.Internal.Sum a_X6tD4
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dNum_s6AMP z_s6AMQ go_s6AMR] \r [ds_s6AMS]
                  case ds_s6AMS of {
                    [] -> z_s6AMQ;
                    : y_s6AMU [Occ=Once] ys_s6AMV [Occ=Once] ->
                        let {
                          sat_s6AMW [Occ=Once] :: a_X6tD4
                          [LclId] =
                              [go_s6AMR ys_s6AMV] \u [] go_s6AMR ys_s6AMV;
                        } in  GHC.Num.+ $dNum_s6AMP y_s6AMU sat_s6AMW;
                  };
        } in  go_s6AMR;

Data.Semigroup.Internal.$fMonoidSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(U,A,C(C1(U)),A,A,A,C(U))>m] =
    [] \r [$dNum_s6AMX]
        let {
          sat_s6AN1 [Occ=Once]
            :: [Data.Semigroup.Internal.Sum a_X6tD2]
               -> Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6AMX] \u []
                  Data.Semigroup.Internal.$fMonoidSum_$cmconcat $dNum_s6AMX; } in
        let {
          sat_s6AN0 [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_X6tD2
               -> Data.Semigroup.Internal.Sum a_X6tD2
               -> Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6AMX] \u [] GHC.Num.+ $dNum_s6AMX; } in
        let {
          sat_s6AMZ [Occ=Once] :: Data.Semigroup.Internal.Sum a_X6tD2
          [LclId] =
              [$dNum_s6AMX] \u []
                  Data.Semigroup.Internal.$fMonoidSum2 $dNum_s6AMX; } in
        let {
          sat_s6AMY [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Sum a_X6tD2)
          [LclId] =
              [$dNum_s6AMX] \u []
                  Data.Semigroup.Internal.$fSemigroupSum $dNum_s6AMX;
        } in  GHC.Base.C:Monoid [sat_s6AMY sat_s6AMZ sat_s6AN0 sat_s6AN1];

Data.Semigroup.Internal.$fFunctorSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeSum3
  :: forall a b.
     Data.Semigroup.Internal.Sum (a -> b)
     -> Data.Semigroup.Internal.Sum (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6AN2] v_s6AN2;

Data.Semigroup.Internal.$fApplicativeSum2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Sum a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6AN3 x_s6AN4] f1_s6AN3 x_s6AN4;

Data.Semigroup.Internal.$fApplicativeSum_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6AN5 a2_s6AN6] a2_s6AN6;

Data.Semigroup.Internal.$fApplicativeSum1
  :: forall b a.
     Data.Semigroup.Internal.Sum a -> b -> Data.Semigroup.Internal.Sum a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6AN7 ds_s6AN8] x_s6AN7;

Data.Semigroup.Internal.$fApplicativeSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorSum
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeSum3
                                           Data.Semigroup.Internal.$fApplicativeSum2
                                           Data.Semigroup.Internal.$fApplicativeSum_$c*>
                                           Data.Semigroup.Internal.$fApplicativeSum1];

Data.Semigroup.Internal.$w$csconcat2 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     Data.Semigroup.Internal.Product a
     -> [Data.Semigroup.Internal.Product a]
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6AN9 ww_s6ANa ww1_s6ANb]
        let {
          go_s6ANc [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Product a_s6uLe
               -> [Data.Semigroup.Internal.Product a_s6uLe]
               -> Data.Semigroup.Internal.Product a_s6uLe
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6AN9 go_s6ANc] \r [b_s6ANd ds1_s6ANe]
                  case ds1_s6ANe of {
                    [] -> b_s6ANd;
                    : c_s6ANg [Occ=Once] cs_s6ANh [Occ=Once] ->
                        let {
                          sat_s6ANi [Occ=Once] :: a_s6uLe
                          [LclId] =
                              [go_s6ANc c_s6ANg cs_s6ANh] \u [] go_s6ANc c_s6ANg cs_s6ANh;
                        } in  GHC.Num.* w_s6AN9 b_s6ANd sat_s6ANi;
                  };
        } in  go_s6ANc ww_s6ANa ww1_s6ANb;

Data.Semigroup.Internal.$fSemigroupProduct_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Product a)
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A,A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6ANj w1_s6ANk]
        case w1_s6ANk of {
          GHC.Base.:| ww1_s6ANm [Occ=Once] ww2_s6ANn [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat2 w_s6ANj ww1_s6ANm ww2_s6ANn;
        };

Data.Semigroup.Internal.$fSemigroupProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A,A,A,C(U))>m] =
    [] \r [$dNum_s6ANo]
        let {
          sat_s6ANu [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6ANo] \r [$dIntegral_s6ANr n_s6ANs ds_s6ANt]
                  GHC.Real.^ $dNum_s6ANo $dIntegral_s6ANr ds_s6ANt n_s6ANs; } in
        let {
          sat_s6ANq [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Product a_X6tB3)
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6ANo] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupProduct_$csconcat
                      $dNum_s6ANo eta_B1; } in
        let {
          sat_s6ANp [Occ=Once]
            :: Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
               -> Data.Semigroup.Internal.Product a_X6tB3
          [LclId] =
              [$dNum_s6ANo] \u [] GHC.Num.* $dNum_s6ANo;
        } in  GHC.Base.C:Semigroup [sat_s6ANp sat_s6ANq sat_s6ANu];

sat_s6ANv :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s6ANw :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6ANv GHC.Types.[]];

Data.Semigroup.Internal.$fMonoidProduct1
  :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6ANw;

Data.Semigroup.Internal.$fMonoidProduct2
  :: forall a. GHC.Num.Num a => a
[GblId,
 Arity=1,
 Str=<S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6ANx]
        GHC.Num.fromInteger
            $dNum_s6ANx Data.Semigroup.Internal.$fMonoidProduct1;

Data.Semigroup.Internal.$fMonoidProduct_$cmconcat
  :: forall a.
     GHC.Num.Num a =>
     [Data.Semigroup.Internal.Product a]
     -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=1,
 Str=<L,U(A,A,C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_s6ANy]
        let {
          z_s6ANz [Occ=OnceL] :: a_X6tAM
          [LclId] =
              [$dNum_s6ANy] \u []
                  GHC.Num.fromInteger
                      $dNum_s6ANy Data.Semigroup.Internal.$fMonoidProduct1; } in
        let {
          go_s6ANA [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Product a_X6tAM]
               -> Data.Semigroup.Internal.Product a_X6tAM
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              [$dNum_s6ANy z_s6ANz go_s6ANA] \r [ds_s6ANB]
                  case ds_s6ANB of {
                    [] -> z_s6ANz;
                    : y_s6AND [Occ=Once] ys_s6ANE [Occ=Once] ->
                        let {
                          sat_s6ANF [Occ=Once] :: a_X6tAM
                          [LclId] =
                              [go_s6ANA ys_s6ANE] \u [] go_s6ANA ys_s6ANE;
                        } in  GHC.Num.* $dNum_s6ANy y_s6AND sat_s6ANF;
                  };
        } in  go_s6ANA;

Data.Semigroup.Internal.$fMonoidProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,U,A,A,A,C(U))>m] =
    [] \r [$dNum_s6ANG]
        let {
          sat_s6ANK [Occ=Once]
            :: [Data.Semigroup.Internal.Product a_X6tAK]
               -> Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6ANG] \u []
                  Data.Semigroup.Internal.$fMonoidProduct_$cmconcat $dNum_s6ANG; } in
        let {
          sat_s6ANJ [Occ=Once]
            :: Data.Semigroup.Internal.Product a_X6tAK
               -> Data.Semigroup.Internal.Product a_X6tAK
               -> Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6ANG] \u [] GHC.Num.* $dNum_s6ANG; } in
        let {
          sat_s6ANI [Occ=Once] :: Data.Semigroup.Internal.Product a_X6tAK
          [LclId] =
              [$dNum_s6ANG] \u []
                  Data.Semigroup.Internal.$fMonoidProduct2 $dNum_s6ANG; } in
        let {
          sat_s6ANH [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Product a_X6tAK)
          [LclId] =
              [$dNum_s6ANG] \u []
                  Data.Semigroup.Internal.$fSemigroupProduct $dNum_s6ANG;
        } in  GHC.Base.C:Monoid [sat_s6ANH sat_s6ANI sat_s6ANJ sat_s6ANK];

Data.Semigroup.Internal.$fFunctorProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Functor Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Functor! [Data.Semigroup.Internal.$fFunctorDual2
                                       Data.Semigroup.Internal.$fFunctorDual1];

Data.Semigroup.Internal.$fApplicativeProduct3
  :: forall a b.
     Data.Semigroup.Internal.Product (a -> b)
     -> Data.Semigroup.Internal.Product (a -> b)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [v_s6ANL] v_s6ANL;

Data.Semigroup.Internal.$fApplicativeProduct2
  :: forall a c b.
     (a -> b -> c) -> Data.Semigroup.Internal.Product a -> b -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f1_s6ANM x_s6ANN] f1_s6ANM x_s6ANN;

Data.Semigroup.Internal.$fApplicativeProduct_$c*>
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_s6ANO a2_s6ANP] a2_s6ANP;

Data.Semigroup.Internal.$fApplicativeProduct1
  :: forall b a.
     Data.Semigroup.Internal.Product a
     -> b -> Data.Semigroup.Internal.Product a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [x_s6ANQ ds_s6ANR] x_s6ANQ;

Data.Semigroup.Internal.$fApplicativeProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Applicative Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Applicative! [Data.Semigroup.Internal.$fFunctorProduct
                                           Data.Semigroup.Internal.$fApplicativeDual4
                                           Data.Semigroup.Internal.$fApplicativeProduct3
                                           Data.Semigroup.Internal.$fApplicativeProduct2
                                           Data.Semigroup.Internal.$fApplicativeProduct_$c*>
                                           Data.Semigroup.Internal.$fApplicativeProduct1];

Data.Semigroup.Internal.$fFunctorAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Functor f =>
     GHC.Base.Functor (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dFunctor_s6ANS]
        let {
          sat_s6ANU [Occ=Once]
            :: forall a b.
               a
               -> Data.Semigroup.Internal.Alt f_a6tow b
               -> Data.Semigroup.Internal.Alt f_a6tow a
          [LclId] =
              [$dFunctor_s6ANS] \u [] GHC.Base.<$ $dFunctor_s6ANS; } in
        let {
          sat_s6ANT [Occ=Once]
            :: forall a b.
               (a -> b)
               -> Data.Semigroup.Internal.Alt f_a6tow a
               -> Data.Semigroup.Internal.Alt f_a6tow b
          [LclId] =
              [$dFunctor_s6ANS] \u [] GHC.Base.fmap $dFunctor_s6ANS;
        } in  GHC.Base.C:Functor [sat_s6ANT sat_s6ANU];

Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Functor (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dApplicative_s6ANV]
        let {
          sat_s6ANW [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Base.Functor f_a6tkt
          [LclId] =
              [$dApplicative_s6ANV] \u []
                  GHC.Base.$p1Applicative $dApplicative_s6ANV;
        } in  Data.Semigroup.Internal.$fFunctorAlt sat_s6ANW;

Data.Semigroup.Internal.$fApplicativeAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Applicative f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dApplicative_s6ANX]
        let {
          sat_s6AO3 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt a
          [LclId] =
              [$dApplicative_s6ANX] \u [] GHC.Base.<* $dApplicative_s6ANX; } in
        let {
          sat_s6AO2 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt b
          [LclId] =
              [$dApplicative_s6ANX] \u [] GHC.Base.*> $dApplicative_s6ANX; } in
        let {
          sat_s6AO1 [Occ=Once]
            :: forall a b c.
               (a -> b -> c)
               -> Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
               -> Data.Semigroup.Internal.Alt f_a6tkt c
          [LclId] =
              [$dApplicative_s6ANX] \u []
                  GHC.Base.liftA2 $dApplicative_s6ANX; } in
        let {
          sat_s6AO0 [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6tkt (a -> b)
               -> Data.Semigroup.Internal.Alt f_a6tkt a
               -> Data.Semigroup.Internal.Alt f_a6tkt b
          [LclId] =
              [$dApplicative_s6ANX] \u [] GHC.Base.<*> $dApplicative_s6ANX; } in
        let {
          sat_s6ANZ [Occ=Once]
            :: forall a. a -> Data.Semigroup.Internal.Alt f_a6tkt a
          [LclId] =
              [$dApplicative_s6ANX] \u [] GHC.Base.pure $dApplicative_s6ANX; } in
        let {
          sat_s6ANY [Occ=Once]
            :: GHC.Base.Functor (Data.Semigroup.Internal.Alt f_a6tkt)
          [LclId] =
              [$dApplicative_s6ANX] \u []
                  Data.Semigroup.Internal.$fApplicativeAlt_$cp1Applicative
                      $dApplicative_s6ANX;
        } in 
          GHC.Base.C:Applicative [sat_s6ANY
                                  sat_s6ANZ
                                  sat_s6AO0
                                  sat_s6AO1
                                  sat_s6AO2
                                  sat_s6AO3];

Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6AO4]
        let {
          sat_s6AO5 [Occ=Once, Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Applicative f_a6tn6
          [LclId] =
              [$dAlternative_s6AO4] \u []
                  GHC.Base.$p1Alternative $dAlternative_s6AO4;
        } in  Data.Semigroup.Internal.$fApplicativeAlt sat_s6AO5;

Data.Semigroup.Internal.$fAlternativeAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Alternative f =>
     GHC.Base.Alternative (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>m] =
    [] \r [$dAlternative_s6AO6]
        let {
          sat_s6AOb [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 [a]
          [LclId] =
              [$dAlternative_s6AO6] \u [] GHC.Base.many $dAlternative_s6AO6; } in
        let {
          sat_s6AOa [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 [a]
          [LclId] =
              [$dAlternative_s6AO6] \u [] GHC.Base.some $dAlternative_s6AO6; } in
        let {
          sat_s6AO9 [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 a
               -> Data.Semigroup.Internal.Alt f_a6tn6 a
          [LclId] =
              [$dAlternative_s6AO6] \u [] GHC.Base.<|> $dAlternative_s6AO6; } in
        let {
          sat_s6AO8 [Occ=Once]
            :: forall a. Data.Semigroup.Internal.Alt f_a6tn6 a
          [LclId] =
              [$dAlternative_s6AO6] \u []
                  GHC.Base.empty $dAlternative_s6AO6; } in
        let {
          sat_s6AO7 [Occ=Once]
            :: GHC.Base.Applicative (Data.Semigroup.Internal.Alt f_a6tn6)
          [LclId] =
              [$dAlternative_s6AO6] \u []
                  Data.Semigroup.Internal.$fAlternativeAlt_$cp1Alternative
                      $dAlternative_s6AO6;
        } in 
          GHC.Base.C:Alternative [sat_s6AO7
                                  sat_s6AO8
                                  sat_s6AO9
                                  sat_s6AOa
                                  sat_s6AOb];

Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.Alternative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s6AOc]
        let {
          sat_s6AOd [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Alternative f_a6tjD
          [LclId] =
              [$dMonadPlus_s6AOc] \u [] GHC.Base.$p1MonadPlus $dMonadPlus_s6AOc;
        } in  Data.Semigroup.Internal.$fAlternativeAlt sat_s6AOd;

Data.Semigroup.Internal.$fMonadAlt_$cp1Monad
  :: forall (f :: * -> *).
     GHC.Base.Monad f =>
     GHC.Base.Applicative (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonad_s6AOe]
        let {
          sat_s6AOf [Occ=Once, Dmd=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Applicative f_a6thT
          [LclId] =
              [$dMonad_s6AOe] \u [] GHC.Base.$p1Monad $dMonad_s6AOe;
        } in  Data.Semigroup.Internal.$fApplicativeAlt sat_s6AOf;

Data.Semigroup.Internal.$fMonadAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.Monad f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>m] =
    [] \r [$dMonad_s6AOg]
        let {
          sat_s6AOl [Occ=Once]
            :: forall a.
               GHC.Base.String -> Data.Semigroup.Internal.Alt f_a6thT a
          [LclId] =
              [$dMonad_s6AOg] \u [] GHC.Base.fail $dMonad_s6AOg; } in
        let {
          sat_s6AOk [Occ=Once]
            :: forall a. a -> Data.Semigroup.Internal.Alt f_a6thT a
          [LclId] =
              [$dMonad_s6AOg] \u [] GHC.Base.return $dMonad_s6AOg; } in
        let {
          sat_s6AOj [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6thT a
               -> Data.Semigroup.Internal.Alt f_a6thT b
               -> Data.Semigroup.Internal.Alt f_a6thT b
          [LclId] =
              [$dMonad_s6AOg] \u [] GHC.Base.>> $dMonad_s6AOg; } in
        let {
          sat_s6AOi [Occ=Once]
            :: forall a b.
               Data.Semigroup.Internal.Alt f_a6thT a
               -> (a -> Data.Semigroup.Internal.Alt f_a6thT b)
               -> Data.Semigroup.Internal.Alt f_a6thT b
          [LclId] =
              [$dMonad_s6AOg] \u [] GHC.Base.>>= $dMonad_s6AOg; } in
        let {
          sat_s6AOh [Occ=Once]
            :: GHC.Base.Applicative (Data.Semigroup.Internal.Alt f_a6thT)
          [LclId] =
              [$dMonad_s6AOg] \u []
                  Data.Semigroup.Internal.$fMonadAlt_$cp1Monad $dMonad_s6AOg;
        } in 
          GHC.Base.C:Monad [sat_s6AOh
                            sat_s6AOi
                            sat_s6AOj
                            sat_s6AOk
                            sat_s6AOl];

Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.Monad (Data.Semigroup.Internal.Alt f)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(A,1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dMonadPlus_s6AOm]
        let {
          sat_s6AOn [Occ=Once,
                     Dmd=<L,U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U)>]
            :: GHC.Base.Monad f_a6tjD
          [LclId] =
              [$dMonadPlus_s6AOm] \u [] GHC.Base.$p2MonadPlus $dMonadPlus_s6AOm;
        } in  Data.Semigroup.Internal.$fMonadAlt sat_s6AOn;

Data.Semigroup.Internal.$fMonadPlusAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *).
     GHC.Base.MonadPlus f =>
     GHC.Base.MonadPlus (Data.Semigroup.Internal.Alt f)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),1*U(1*U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U),1*U,1*U,1*U,1*U),1*U,1*U)>m] =
    [] \r [$dMonadPlus_s6AOo]
        let {
          sat_s6AOs [Occ=Once]
            :: forall a.
               Data.Semigroup.Internal.Alt f_a6tjD a
               -> Data.Semigroup.Internal.Alt f_a6tjD a
               -> Data.Semigroup.Internal.Alt f_a6tjD a
          [LclId] =
              [$dMonadPlus_s6AOo] \u [] GHC.Base.mplus $dMonadPlus_s6AOo; } in
        let {
          sat_s6AOr [Occ=Once]
            :: forall a. Data.Semigroup.Internal.Alt f_a6tjD a
          [LclId] =
              [$dMonadPlus_s6AOo] \u [] GHC.Base.mzero $dMonadPlus_s6AOo; } in
        let {
          sat_s6AOq [Occ=Once]
            :: GHC.Base.Monad (Data.Semigroup.Internal.Alt f_a6tjD)
          [LclId] =
              [$dMonadPlus_s6AOo] \u []
                  Data.Semigroup.Internal.$fMonadPlusAlt_$cp2MonadPlus
                      $dMonadPlus_s6AOo; } in
        let {
          sat_s6AOp [Occ=Once]
            :: GHC.Base.Alternative (Data.Semigroup.Internal.Alt f_a6tjD)
          [LclId] =
              [$dMonadPlus_s6AOo] \u []
                  Data.Semigroup.Internal.$fMonadPlusAlt_$cp1MonadPlus
                      $dMonadPlus_s6AOo;
        } in 
          GHC.Base.C:MonadPlus [sat_s6AOp sat_s6AOq sat_s6AOr sat_s6AOs];

Data.Semigroup.Internal.$fEnumAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Enum.Enum (f a) =>
     GHC.Enum.Enum (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dEnum_s6AOt]
        let {
          sat_s6AOB [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.enumFromThenTo $dEnum_s6AOt; } in
        let {
          sat_s6AOA [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.enumFromTo $dEnum_s6AOt; } in
        let {
          sat_s6AOz [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.enumFromThen $dEnum_s6AOt; } in
        let {
          sat_s6AOy [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> [Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm]
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.enumFrom $dEnum_s6AOt; } in
        let {
          sat_s6AOx [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm -> GHC.Types.Int
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.fromEnum $dEnum_s6AOt; } in
        let {
          sat_s6AOw [Occ=Once]
            :: GHC.Types.Int -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.toEnum $dEnum_s6AOt; } in
        let {
          sat_s6AOv [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.pred $dEnum_s6AOt; } in
        let {
          sat_s6AOu [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
               -> Data.Semigroup.Internal.Alt f_X6tpk a_X6tpm
          [LclId] =
              [$dEnum_s6AOt] \u [] GHC.Enum.succ $dEnum_s6AOt;
        } in 
          GHC.Enum.C:Enum [sat_s6AOu
                           sat_s6AOv
                           sat_s6AOw
                           sat_s6AOx
                           sat_s6AOy
                           sat_s6AOz
                           sat_s6AOA
                           sat_s6AOB];

Data.Semigroup.Internal.$fNumAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Num.Num (f a) =>
     GHC.Num.Num (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6AOC]
        let {
          sat_s6AOJ [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.fromInteger $dNum_s6AOC; } in
        let {
          sat_s6AOI [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.signum $dNum_s6AOC; } in
        let {
          sat_s6AOH [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.abs $dNum_s6AOC; } in
        let {
          sat_s6AOG [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.negate $dNum_s6AOC; } in
        let {
          sat_s6AOF [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.* $dNum_s6AOC; } in
        let {
          sat_s6AOE [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.- $dNum_s6AOC; } in
        let {
          sat_s6AOD [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
               -> Data.Semigroup.Internal.Alt f_X6toe a_X6tog
          [LclId] =
              [$dNum_s6AOC] \u [] GHC.Num.+ $dNum_s6AOC;
        } in 
          GHC.Num.C:Num [sat_s6AOD
                         sat_s6AOE
                         sat_s6AOF
                         sat_s6AOG
                         sat_s6AOH
                         sat_s6AOI
                         sat_s6AOJ];

Data.Semigroup.Internal.$fEqAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Eq (f a) =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6AOK]
        let {
          sat_s6AOM [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6txq a_X6txt
               -> Data.Semigroup.Internal.Alt f_X6txq a_X6txt -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6AOK] \u [] GHC.Classes./= $dEq_s6AOK; } in
        let {
          sat_s6AOL [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6txq a_X6txt
               -> Data.Semigroup.Internal.Alt f_X6txq a_X6txt -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6AOK] \u [] GHC.Classes.== $dEq_s6AOK;
        } in  GHC.Classes.C:Eq [sat_s6AOL sat_s6AOM];

Data.Semigroup.Internal.$fOrdAlt_$cp1Ord
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Ord (f a) =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Alt f a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6AON]
        let {
          sat_s6AOO [Occ=Once, Dmd=<L,U(1*U,1*U)>]
            :: GHC.Classes.Eq (f_X6tn1 a_X6tn3)
          [LclId] =
              [$dOrd_s6AON] \u [] GHC.Classes.$p1Ord $dOrd_s6AON;
        } in  Data.Semigroup.Internal.$fEqAlt sat_s6AOO;

Data.Semigroup.Internal.$fOrdAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Classes.Ord (f a) =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6AOP]
        let {
          sat_s6AOX [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.min $dOrd_s6AOP; } in
        let {
          sat_s6AOW [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.max $dOrd_s6AOP; } in
        let {
          sat_s6AOV [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.>= $dOrd_s6AOP; } in
        let {
          sat_s6AOU [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.> $dOrd_s6AOP; } in
        let {
          sat_s6AOT [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.<= $dOrd_s6AOP; } in
        let {
          sat_s6AOS [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.< $dOrd_s6AOP; } in
        let {
          sat_s6AOR [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4
               -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6AOP] \u [] GHC.Classes.compare $dOrd_s6AOP; } in
        let {
          sat_s6AOQ [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Alt f_X6tn2 a_X6tn4)
          [LclId] =
              [$dOrd_s6AOP] \u []
                  Data.Semigroup.Internal.$fOrdAlt_$cp1Ord $dOrd_s6AOP;
        } in 
          GHC.Classes.C:Ord [sat_s6AOQ
                             sat_s6AOR
                             sat_s6AOS
                             sat_s6AOT
                             sat_s6AOU
                             sat_s6AOV
                             sat_s6AOW
                             sat_s6AOX];

Data.Semigroup.Internal.$fShowAlt1 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Data.Semigroup.Internal.$fShowAlt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alt {"#;

Data.Semigroup.Internal.$fShowAlt2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAlt = "#;

Data.Semigroup.Internal.$fReadAll5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "}"#;

Data.Semigroup.Internal.$w$cshowsPrec1 [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Alt f a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AOY ww_s6AOZ w1_s6AP0]
        let {
          f1_s6AP1 [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6AOY w1_s6AP0] \u []
                  GHC.Show.showsPrec
                      w_s6AOY Data.Semigroup.Internal.$fShowAlt1 w1_s6AP0;
        } in 
          case >=# [ww_s6AOZ 11#] of {
            __DEFAULT ->
                let {
                  sat_s6AP7 [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f1_s6AP1] \r [x_s6AP3]
                          let {
                            sat_s6AP6 [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_s6AP1 x_s6AP3] \u []
                                    let {
                                      sat_s6AP5 [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_s6AP1 x_s6AP3] \u []
                                              let {
                                                sat_s6AP4 [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6AP3] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6AP3;
                                              } in  f1_s6AP1 sat_s6AP4;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowAlt2 sat_s6AP5;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowAlt3 sat_s6AP6;
                } in  sat_s6AP7;
            1# ->
                let {
                  sat_s6APe [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f1_s6AP1] \r [x_s6AP8]
                          let {
                            sat_s6APd [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f1_s6AP1 x_s6AP8] \u []
                                    let {
                                      sat_s6APc [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f1_s6AP1 x_s6AP8] \u []
                                              let {
                                                sat_s6APb [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f1_s6AP1 x_s6AP8] \u []
                                                        let {
                                                          sat_s6APa [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6AP8] \u []
                                                                  let {
                                                                    sat_s6AP9 [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6AP8];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6AP9;
                                                        } in  f1_s6AP1 sat_s6APa;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowAlt2 sat_s6APb;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowAlt3 sat_s6APc;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6APd];
                } in  sat_s6APe;
          };

Data.Semigroup.Internal.$fShowAlt_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Types.Int -> Data.Semigroup.Internal.Alt f a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6APf w1_s6APg w2_s6APh]
        case w1_s6APg of {
          GHC.Types.I# ww1_s6APj [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec1 w_s6APf ww1_s6APj w2_s6APh;
        };

Data.Semigroup.Internal.$fReadAll4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll5;

Data.Semigroup.Internal.$fShowAlt_$cshow
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     Data.Semigroup.Internal.Alt f a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6APk x_s6APl]
        let {
          sat_s6APn [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6APk x_s6APl] \u []
                  let {
                    sat_s6APm [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6APk x_s6APl] \u []
                            GHC.Show.showsPrec
                                $dShow_s6APk
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6APl
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAlt2 sat_s6APm;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowAlt3 sat_s6APn;

Data.Semigroup.Internal.$fShowAlt_$cshowList
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     [Data.Semigroup.Internal.Alt f a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6APo ls_s6APp s_s6APq]
        let {
          sat_s6APs [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6APo] \r [w_s6APr]
                  Data.Semigroup.Internal.$w$cshowsPrec1 $dShow_s6APo 0# w_s6APr;
        } in  GHC.Show.showList__ sat_s6APs ls_s6APp s_s6APq;

Data.Semigroup.Internal.$fShowAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Show.Show (f a) =>
     GHC.Show.Show (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6APt]
        let {
          sat_s6APw [Occ=Once]
            :: [Data.Semigroup.Internal.Alt f_a6taL a_a6taM] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6APt] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshowList
                      $dShow_s6APt eta_B2 eta_B1; } in
        let {
          sat_s6APv [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Base.String
          [LclId] =
              [$dShow_s6APt] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshow $dShow_s6APt eta_B1; } in
        let {
          sat_s6APu [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Alt f_a6taL a_a6taM -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6APt] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowAlt_$cshowsPrec
                      $dShow_s6APt eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6APu sat_s6APv sat_s6APw];

Data.Semigroup.Internal.$fReadAlt5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Alt"#;

Data.Semigroup.Internal.$fReadAlt4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAlt5;

Data.Semigroup.Internal.$fReadAlt_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAlt4];

Data.Semigroup.Internal.$fReadAll11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "{"#;

Data.Semigroup.Internal.$fReadAll10 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll11;

Data.Semigroup.Internal.$fReadAll_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.Internal.$fReadAll10];

Data.Semigroup.Internal.$fReadAlt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAlt"#;

Data.Semigroup.Internal.$fReadAlt2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAlt3;

Data.Semigroup.Internal.$fReadAll6 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [11#];

Data.Semigroup.Internal.$fReadAll3 :: Text.Read.Lex.Lexeme
[GblId, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Punc! [Data.Semigroup.Internal.$fReadAll4];

Data.Semigroup.Internal.$fReadAlt1
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Alt f a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6APx]
        let {
          lvl12_s6APy [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP (f_a6t9S a_a6t9T)
          [LclId] =
              [$dRead_s6APx] \u []
                  GHC.Read.readPrec
                      $dRead_s6APx Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6APz [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP (f_a6t9S a_a6t9T)
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6APy] \r [ds1_s6APA] lvl12_s6APy; } in
        let {
          sat_s6APU [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_a6t9S a_a6t9T)
          [LclId] =
              [ds_s6APz] \r [c_s6APB eta_s6APC]
                  case c_s6APB of {
                    GHC.Types.I# x_s6APE [Occ=Once] ->
                        case <=# [x_s6APE 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6APR [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6APz eta_s6APC] \r [a1_s6APG]
                                        let {
                                          sat_s6APO [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6APz eta_s6APC] \r [a2_s6APH]
                                                  let {
                                                    sat_s6APN [Occ=Once]
                                                      :: f_a6t9S a_a6t9T
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6APC] \r [a3_s6API]
                                                            let {
                                                              sat_s6APK [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6APC a3_s6API] \r [a4_s6APJ]
                                                                      eta_s6APC a3_s6API;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6APK
                                                              of
                                                              { Unit# ww1_s6APM [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6APM];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadAlt2
                                                        ds_s6APz
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6APN;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6APO
                                          of
                                          { Unit# ww1_s6APQ [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6APQ];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadAlt_lexeme sat_s6APR
                                of
                                { Unit# ww1_s6APT [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6APT];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6APU;

Data.Semigroup.Internal.$fReadAlt_$creadsPrec
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Alt f a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6APV]
        let {
          ds_s6APW [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6APV] \u []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6APV; } in
        let {
          sat_s6APZ [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle)
          [LclId] =
              [ds_s6APW] \r [n_s6APX]
                  let {
                    sat_s6APY [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Alt f_X6tlc a_X6tle)
                    [LclId] =
                        [ds_s6APW n_s6APX] \u []
                            ds_s6APW
                                n_s6APX Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6APY;
        } in  sat_s6APZ;

Data.Semigroup.Internal.$fReadAlt_$creadListPrec
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Alt f a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AQ0]
        let {
          sat_s6AQ1 [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_X6tla a_X6tlc)
          [LclId] =
              [$dRead_s6AQ0] \s []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6AQ0;
        } in  GHC.Read.list sat_s6AQ1;

Data.Semigroup.Internal.$fReadAlt_$creadList
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Semigroup.Internal.Alt f a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AQ2]
        let {
          sat_s6AQ4 [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Alt f_X6tlb a_X6tld]
          [LclId] =
              [$dRead_s6AQ2] \u []
                  let {
                    sat_s6AQ3 [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Alt f_X6tlb a_X6tld)
                    [LclId] =
                        [$dRead_s6AQ2] \s []
                            Data.Semigroup.Internal.$fReadAlt1 $dRead_s6AQ2;
                  } in 
                    GHC.Read.list
                        sat_s6AQ3
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6AQ4;

Data.Semigroup.Internal.$fReadAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Read.Read (f a) =>
     GHC.Read.Read (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6AQ5]
        let {
          sat_s6AQ9 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb]
          [LclId] =
              [$dRead_s6AQ5] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadListPrec $dRead_s6AQ5; } in
        let {
          sat_s6AQ8 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb)
          [LclId] =
              [$dRead_s6AQ5] \u []
                  Data.Semigroup.Internal.$fReadAlt1 $dRead_s6AQ5; } in
        let {
          sat_s6AQ7 [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb]
          [LclId] =
              [$dRead_s6AQ5] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadList $dRead_s6AQ5; } in
        let {
          sat_s6AQ6 [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Alt f_X6tl9 a_X6tlb)
          [LclId] =
              [$dRead_s6AQ5] \u []
                  Data.Semigroup.Internal.$fReadAlt_$creadsPrec $dRead_s6AQ5;
        } in  GHC.Read.C:Read [sat_s6AQ6 sat_s6AQ7 sat_s6AQ8 sat_s6AQ9];

Data.Semigroup.Internal.$fGeneric1Alt1
  :: forall k (f :: k -> *) (a :: k).
     GHC.Generics.Rep1 (Data.Semigroup.Internal.Alt f) a
     -> GHC.Generics.Rep1 (Data.Semigroup.Internal.Alt f) a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AQa] ds_s6AQa;

Data.Semigroup.Internal.$fGeneric1Alt2
  :: forall k (f :: k -> *) (a :: k).
     Data.Semigroup.Internal.Alt f a -> Data.Semigroup.Internal.Alt f a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6AQb] x_s6AQb;

Data.Semigroup.Internal.$fGeneric1Alt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *).
     GHC.Generics.Generic1 (Data.Semigroup.Internal.Alt f)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Alt2
                                            Data.Semigroup.Internal.$fGeneric1Alt1];

Data.Semigroup.Internal.$fGenericAlt1
  :: forall k (f :: k -> *) (a :: k) x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Alt f a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Alt f a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AQc] ds_s6AQc;

Data.Semigroup.Internal.$fGenericAlt2
  :: forall k (f :: k -> *) (a :: k) x.
     Data.Semigroup.Internal.Alt f a -> Data.Semigroup.Internal.Alt f a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AQd] x1_s6AQd;

Data.Semigroup.Internal.$fGenericAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall k (f :: k -> *) (a :: k).
     GHC.Generics.Generic (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAlt2
                                           Data.Semigroup.Internal.$fGenericAlt1];

Data.Semigroup.Internal.$fNumProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Semigroup.Internal.Product a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6AQe]
        let {
          sat_s6AQl [Occ=Once]
            :: GHC.Integer.Type.Integer
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.fromInteger $dNum_s6AQe; } in
        let {
          sat_s6AQk [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.signum $dNum_s6AQe; } in
        let {
          sat_s6AQj [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.abs $dNum_s6AQe; } in
        let {
          sat_s6AQi [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.negate $dNum_s6AQe; } in
        let {
          sat_s6AQh [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.* $dNum_s6AQe; } in
        let {
          sat_s6AQg [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.- $dNum_s6AQe; } in
        let {
          sat_s6AQf [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
               -> Data.Semigroup.Internal.Product a_a6t6g
          [LclId] =
              [$dNum_s6AQe] \u [] GHC.Num.+ $dNum_s6AQe;
        } in 
          GHC.Num.C:Num [sat_s6AQf
                         sat_s6AQg
                         sat_s6AQh
                         sat_s6AQi
                         sat_s6AQj
                         sat_s6AQk
                         sat_s6AQl];

Data.Semigroup.Internal.$fGeneric1Product1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Product a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AQm] ds_s6AQm;

Data.Semigroup.Internal.$fGeneric1Product2
  :: forall a.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6AQn] x_s6AQn;

Data.Semigroup.Internal.$fGeneric1Product [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Product
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Product2
                                            Data.Semigroup.Internal.$fGeneric1Product1];

Data.Semigroup.Internal.$fGenericProduct1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Product a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Product a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AQo] ds_s6AQo;

Data.Semigroup.Internal.$fGenericProduct2
  :: forall a x.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AQp] x1_s6AQp;

Data.Semigroup.Internal.$fGenericProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Generics.Generic (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericProduct2
                                           Data.Semigroup.Internal.$fGenericProduct1];

Data.Semigroup.Internal.$fBoundedProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6AQq]
        let {
          sat_s6AQs [Occ=Once] :: Data.Semigroup.Internal.Product a_a6t49
          [LclId] =
              [$dBounded_s6AQq] \u [] GHC.Enum.maxBound $dBounded_s6AQq; } in
        let {
          sat_s6AQr [Occ=Once] :: Data.Semigroup.Internal.Product a_a6t49
          [LclId] =
              [$dBounded_s6AQq] \u [] GHC.Enum.minBound $dBounded_s6AQq;
        } in  GHC.Enum.C:Bounded [sat_s6AQr sat_s6AQs];

Data.Semigroup.Internal.$fShowProduct2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product {"#;

Data.Semigroup.Internal.$fShowProduct1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getProduct = "#;

Data.Semigroup.Internal.$w$cshowsPrec4 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int#
     -> Data.Semigroup.Internal.Product a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AQt ww_s6AQu w1_s6AQv]
        let {
          f_s6AQw [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6AQt w1_s6AQv] \u []
                  GHC.Show.showsPrec
                      w_s6AQt Data.Semigroup.Internal.$fShowAlt1 w1_s6AQv;
        } in 
          case >=# [ww_s6AQu 11#] of {
            __DEFAULT ->
                let {
                  sat_s6AQC [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6AQw] \r [x_s6AQy]
                          let {
                            sat_s6AQB [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6AQw x_s6AQy] \u []
                                    let {
                                      sat_s6AQA [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6AQw x_s6AQy] \u []
                                              let {
                                                sat_s6AQz [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6AQy] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6AQy;
                                              } in  f_s6AQw sat_s6AQz;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowProduct1 sat_s6AQA;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowProduct2 sat_s6AQB;
                } in  sat_s6AQC;
            1# ->
                let {
                  sat_s6AQJ [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6AQw] \r [x_s6AQD]
                          let {
                            sat_s6AQI [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6AQw x_s6AQD] \u []
                                    let {
                                      sat_s6AQH [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6AQw x_s6AQD] \u []
                                              let {
                                                sat_s6AQG [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6AQw x_s6AQD] \u []
                                                        let {
                                                          sat_s6AQF [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6AQD] \u []
                                                                  let {
                                                                    sat_s6AQE [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6AQD];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6AQE;
                                                        } in  f_s6AQw sat_s6AQF;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowProduct1
                                                    sat_s6AQG;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowProduct2 sat_s6AQH;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6AQI];
                } in  sat_s6AQJ;
          };

Data.Semigroup.Internal.$fShowProduct_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int
     -> Data.Semigroup.Internal.Product a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AQK w1_s6AQL w2_s6AQM]
        case w1_s6AQL of {
          GHC.Types.I# ww1_s6AQO [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec4 w_s6AQK ww1_s6AQO w2_s6AQM;
        };

Data.Semigroup.Internal.$fShowProduct_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Product a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6AQP x_s6AQQ]
        let {
          sat_s6AQS [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6AQP x_s6AQQ] \u []
                  let {
                    sat_s6AQR [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6AQP x_s6AQQ] \u []
                            GHC.Show.showsPrec
                                $dShow_s6AQP
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6AQQ
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowProduct1 sat_s6AQR;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowProduct2 sat_s6AQS;

Data.Semigroup.Internal.$fShowProduct_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Product a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6AQT ls_s6AQU s_s6AQV]
        let {
          sat_s6AQX [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t3E -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AQT] \r [w_s6AQW]
                  Data.Semigroup.Internal.$w$cshowsPrec4 $dShow_s6AQT 0# w_s6AQW;
        } in  GHC.Show.showList__ sat_s6AQX ls_s6AQU s_s6AQV;

Data.Semigroup.Internal.$fShowProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6AQY]
        let {
          sat_s6AR1 [Occ=Once]
            :: [Data.Semigroup.Internal.Product a_a6t3E] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AQY] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshowList
                      $dShow_s6AQY eta_B2 eta_B1; } in
        let {
          sat_s6AR0 [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t3E -> GHC.Base.String
          [LclId] =
              [$dShow_s6AQY] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshow
                      $dShow_s6AQY eta_B1; } in
        let {
          sat_s6AQZ [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Product a_a6t3E -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AQY] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowProduct_$cshowsPrec
                      $dShow_s6AQY eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6AQZ sat_s6AR0 sat_s6AR1];

Data.Semigroup.Internal.$fReadProduct5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Product"#;

Data.Semigroup.Internal.$fReadProduct4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadProduct5;

Data.Semigroup.Internal.$fReadProduct_lexeme
  :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadProduct4];

Data.Semigroup.Internal.$fReadProduct3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getProduct"#;

Data.Semigroup.Internal.$fReadProduct2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadProduct3;

Data.Semigroup.Internal.$fReadProduct1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Product a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AR2]
        let {
          lvl12_s6AR3 [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6t2P
          [LclId] =
              [$dRead_s6AR2] \u []
                  GHC.Read.readPrec
                      $dRead_s6AR2 Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6AR4 [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6t2P
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6AR3] \r [ds1_s6AR5] lvl12_s6AR3; } in
        let {
          sat_s6ARp [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_a6t2P)
          [LclId] =
              [ds_s6AR4] \r [c_s6AR6 eta_s6AR7]
                  case c_s6AR6 of {
                    GHC.Types.I# x_s6AR9 [Occ=Once] ->
                        case <=# [x_s6AR9 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6ARm [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6AR4 eta_s6AR7] \r [a1_s6ARb]
                                        let {
                                          sat_s6ARj [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6AR4 eta_s6AR7] \r [a2_s6ARc]
                                                  let {
                                                    sat_s6ARi [Occ=Once]
                                                      :: a_a6t2P
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6AR7] \r [a3_s6ARd]
                                                            let {
                                                              sat_s6ARf [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6AR7 a3_s6ARd] \r [a4_s6ARe]
                                                                      eta_s6AR7 a3_s6ARd;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6ARf
                                                              of
                                                              { Unit# ww1_s6ARh [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6ARh];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadProduct2
                                                        ds_s6AR4
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6ARi;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6ARj
                                          of
                                          { Unit# ww1_s6ARl [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6ARl];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadProduct_lexeme sat_s6ARm
                                of
                                { Unit# ww1_s6ARo [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6ARo];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6ARp;

Data.Semigroup.Internal.$fReadProduct_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Product a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ARq]
        let {
          ds_s6ARr [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Product a_X6tfh
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6ARq] \u []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6ARq; } in
        let {
          sat_s6ARu [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Product a_X6tfh)
          [LclId] =
              [ds_s6ARr] \r [n_s6ARs]
                  let {
                    sat_s6ARt [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Product a_X6tfh)
                    [LclId] =
                        [ds_s6ARr n_s6ARs] \u []
                            ds_s6ARr
                                n_s6ARs Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6ARt;
        } in  sat_s6ARu;

Data.Semigroup.Internal.$fReadProduct_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Product a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ARv]
        let {
          sat_s6ARw [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_X6tff)
          [LclId] =
              [$dRead_s6ARv] \s []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6ARv;
        } in  GHC.Read.list sat_s6ARw;

Data.Semigroup.Internal.$fReadProduct_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS
       [Data.Semigroup.Internal.Product a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ARx]
        let {
          sat_s6ARz [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Product a_X6tfg]
          [LclId] =
              [$dRead_s6ARx] \u []
                  let {
                    sat_s6ARy [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Product a_X6tfg)
                    [LclId] =
                        [$dRead_s6ARx] \s []
                            Data.Semigroup.Internal.$fReadProduct1 $dRead_s6ARx;
                  } in 
                    GHC.Read.list
                        sat_s6ARy
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6ARz;

Data.Semigroup.Internal.$fReadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6ARA]
        let {
          sat_s6ARE [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Product a_X6tfe]
          [LclId] =
              [$dRead_s6ARA] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadListPrec
                      $dRead_s6ARA; } in
        let {
          sat_s6ARD [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Product a_X6tfe)
          [LclId] =
              [$dRead_s6ARA] \u []
                  Data.Semigroup.Internal.$fReadProduct1 $dRead_s6ARA; } in
        let {
          sat_s6ARC [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Product a_X6tfe]
          [LclId] =
              [$dRead_s6ARA] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadList $dRead_s6ARA; } in
        let {
          sat_s6ARB [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Product a_X6tfe)
          [LclId] =
              [$dRead_s6ARA] \u []
                  Data.Semigroup.Internal.$fReadProduct_$creadsPrec $dRead_s6ARA;
        } in  GHC.Read.C:Read [sat_s6ARB sat_s6ARC sat_s6ARD sat_s6ARE];

Data.Semigroup.Internal.$fEqProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Product a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6ARF]
        let {
          sat_s6ARH [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t0s
               -> Data.Semigroup.Internal.Product a_a6t0s -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6ARF] \u [] GHC.Classes./= $dEq_s6ARF; } in
        let {
          sat_s6ARG [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t0s
               -> Data.Semigroup.Internal.Product a_a6t0s -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6ARF] \u [] GHC.Classes.== $dEq_s6ARF;
        } in  GHC.Classes.C:Eq [sat_s6ARG sat_s6ARH];

Data.Semigroup.Internal.$fOrdProduct_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Product a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6ARI]
        let {
          sat_s6ARJ [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6t10
          [LclId] =
              [$dOrd_s6ARI] \u [] GHC.Classes.$p1Ord $dOrd_s6ARI;
        } in  Data.Semigroup.Internal.$fEqProduct sat_s6ARJ;

Data.Semigroup.Internal.$fOrdProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Product a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6ARK]
        let {
          sat_s6ARS [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.min $dOrd_s6ARK; } in
        let {
          sat_s6ARR [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.max $dOrd_s6ARK; } in
        let {
          sat_s6ARQ [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.>= $dOrd_s6ARK; } in
        let {
          sat_s6ARP [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.> $dOrd_s6ARK; } in
        let {
          sat_s6ARO [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.<= $dOrd_s6ARK; } in
        let {
          sat_s6ARN [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.< $dOrd_s6ARK; } in
        let {
          sat_s6ARM [Occ=Once]
            :: Data.Semigroup.Internal.Product a_a6t10
               -> Data.Semigroup.Internal.Product a_a6t10 -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6ARK] \u [] GHC.Classes.compare $dOrd_s6ARK; } in
        let {
          sat_s6ARL [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Product a_a6t10)
          [LclId] =
              [$dOrd_s6ARK] \u []
                  Data.Semigroup.Internal.$fOrdProduct_$cp1Ord $dOrd_s6ARK;
        } in 
          GHC.Classes.C:Ord [sat_s6ARL
                             sat_s6ARM
                             sat_s6ARN
                             sat_s6ARO
                             sat_s6ARP
                             sat_s6ARQ
                             sat_s6ARR
                             sat_s6ARS];

Data.Semigroup.Internal.$fNumSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Num.Num a =>
     GHC.Num.Num (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dNum_s6ART]
        let {
          sat_s6AS0 [Occ=Once]
            :: GHC.Integer.Type.Integer -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.fromInteger $dNum_s6ART; } in
        let {
          sat_s6ARZ [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.signum $dNum_s6ART; } in
        let {
          sat_s6ARY [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.abs $dNum_s6ART; } in
        let {
          sat_s6ARX [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.negate $dNum_s6ART; } in
        let {
          sat_s6ARW [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.* $dNum_s6ART; } in
        let {
          sat_s6ARV [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.- $dNum_s6ART; } in
        let {
          sat_s6ARU [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
               -> Data.Semigroup.Internal.Sum a_a6sYX
          [LclId] =
              [$dNum_s6ART] \u [] GHC.Num.+ $dNum_s6ART;
        } in 
          GHC.Num.C:Num [sat_s6ARU
                         sat_s6ARV
                         sat_s6ARW
                         sat_s6ARX
                         sat_s6ARY
                         sat_s6ARZ
                         sat_s6AS0];

Data.Semigroup.Internal.$fGeneric1Sum1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Sum a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AS1] ds_s6AS1;

Data.Semigroup.Internal.$fGeneric1Sum2
  :: forall a.
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6AS2] x_s6AS2;

Data.Semigroup.Internal.$fGeneric1Sum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Sum
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Sum2
                                            Data.Semigroup.Internal.$fGeneric1Sum1];

Data.Semigroup.Internal.$fGenericSum1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Sum a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Sum a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AS3] ds_s6AS3;

Data.Semigroup.Internal.$fGenericSum2
  :: forall a x.
     Data.Semigroup.Internal.Sum a -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AS4] x1_s6AS4;

Data.Semigroup.Internal.$fGenericSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericSum2
                                           Data.Semigroup.Internal.$fGenericSum1];

Data.Semigroup.Internal.$fBoundedSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6AS5]
        let {
          sat_s6AS7 [Occ=Once] :: Data.Semigroup.Internal.Sum a_a6sWQ
          [LclId] =
              [$dBounded_s6AS5] \u [] GHC.Enum.maxBound $dBounded_s6AS5; } in
        let {
          sat_s6AS6 [Occ=Once] :: Data.Semigroup.Internal.Sum a_a6sWQ
          [LclId] =
              [$dBounded_s6AS5] \u [] GHC.Enum.minBound $dBounded_s6AS5;
        } in  GHC.Enum.C:Bounded [sat_s6AS6 sat_s6AS7];

Data.Semigroup.Internal.$fShowSum2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum {"#;

Data.Semigroup.Internal.$fShowSum1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getSum = "#;

Data.Semigroup.Internal.$w$cshowsPrec5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Sum a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AS8 ww_s6AS9 w1_s6ASa]
        let {
          f_s6ASb [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6AS8 w1_s6ASa] \u []
                  GHC.Show.showsPrec
                      w_s6AS8 Data.Semigroup.Internal.$fShowAlt1 w1_s6ASa;
        } in 
          case >=# [ww_s6AS9 11#] of {
            __DEFAULT ->
                let {
                  sat_s6ASh [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6ASb] \r [x_s6ASd]
                          let {
                            sat_s6ASg [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6ASb x_s6ASd] \u []
                                    let {
                                      sat_s6ASf [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6ASb x_s6ASd] \u []
                                              let {
                                                sat_s6ASe [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6ASd] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6ASd;
                                              } in  f_s6ASb sat_s6ASe;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowSum1 sat_s6ASf;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowSum2 sat_s6ASg;
                } in  sat_s6ASh;
            1# ->
                let {
                  sat_s6ASo [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6ASb] \r [x_s6ASi]
                          let {
                            sat_s6ASn [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6ASb x_s6ASi] \u []
                                    let {
                                      sat_s6ASm [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6ASb x_s6ASi] \u []
                                              let {
                                                sat_s6ASl [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6ASb x_s6ASi] \u []
                                                        let {
                                                          sat_s6ASk [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6ASi] \u []
                                                                  let {
                                                                    sat_s6ASj [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6ASi];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6ASj;
                                                        } in  f_s6ASb sat_s6ASk;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowSum1 sat_s6ASl;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowSum2 sat_s6ASm;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6ASn];
                } in  sat_s6ASo;
          };

Data.Semigroup.Internal.$fShowSum_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Internal.Sum a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6ASp w1_s6ASq w2_s6ASr]
        case w1_s6ASq of {
          GHC.Types.I# ww1_s6ASt [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec5 w_s6ASp ww1_s6ASt w2_s6ASr;
        };

Data.Semigroup.Internal.$fShowSum_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Sum a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6ASu x_s6ASv]
        let {
          sat_s6ASx [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6ASu x_s6ASv] \u []
                  let {
                    sat_s6ASw [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6ASu x_s6ASv] \u []
                            GHC.Show.showsPrec
                                $dShow_s6ASu
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6ASv
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowSum1 sat_s6ASw;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowSum2 sat_s6ASx;

Data.Semigroup.Internal.$fShowSum_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Sum a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6ASy ls_s6ASz s_s6ASA]
        let {
          sat_s6ASC [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6ASy] \r [w_s6ASB]
                  Data.Semigroup.Internal.$w$cshowsPrec5 $dShow_s6ASy 0# w_s6ASB;
        } in  GHC.Show.showList__ sat_s6ASC ls_s6ASz s_s6ASA;

Data.Semigroup.Internal.$fShowSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6ASD]
        let {
          sat_s6ASG [Occ=Once]
            :: [Data.Semigroup.Internal.Sum a_a6sWl] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6ASD] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshowList
                      $dShow_s6ASD eta_B2 eta_B1; } in
        let {
          sat_s6ASF [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Base.String
          [LclId] =
              [$dShow_s6ASD] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshow $dShow_s6ASD eta_B1; } in
        let {
          sat_s6ASE [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Sum a_a6sWl -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6ASD] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowSum_$cshowsPrec
                      $dShow_s6ASD eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6ASE sat_s6ASF sat_s6ASG];

Data.Semigroup.Internal.$fReadSum5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Sum"#;

Data.Semigroup.Internal.$fReadSum4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadSum5;

Data.Semigroup.Internal.$fReadSum_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadSum4];

Data.Semigroup.Internal.$fReadSum3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getSum"#;

Data.Semigroup.Internal.$fReadSum2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadSum3;

Data.Semigroup.Internal.$fReadSum1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Sum a -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ASH]
        let {
          lvl12_s6ASI [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6sVw
          [LclId] =
              [$dRead_s6ASH] \u []
                  GHC.Read.readPrec
                      $dRead_s6ASH Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6ASJ [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6sVw
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6ASI] \r [ds1_s6ASK] lvl12_s6ASI; } in
        let {
          sat_s6AT4 [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_a6sVw)
          [LclId] =
              [ds_s6ASJ] \r [c_s6ASL eta_s6ASM]
                  case c_s6ASL of {
                    GHC.Types.I# x_s6ASO [Occ=Once] ->
                        case <=# [x_s6ASO 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6AT1 [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6ASJ eta_s6ASM] \r [a1_s6ASQ]
                                        let {
                                          sat_s6ASY [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6ASJ eta_s6ASM] \r [a2_s6ASR]
                                                  let {
                                                    sat_s6ASX [Occ=Once]
                                                      :: a_a6sVw
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6ASM] \r [a3_s6ASS]
                                                            let {
                                                              sat_s6ASU [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6ASM a3_s6ASS] \r [a4_s6AST]
                                                                      eta_s6ASM a3_s6ASS;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6ASU
                                                              of
                                                              { Unit# ww1_s6ASW [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6ASW];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadSum2
                                                        ds_s6ASJ
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6ASX;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6ASY
                                          of
                                          { Unit# ww1_s6AT0 [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6AT0];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadSum_lexeme sat_s6AT1
                                of
                                { Unit# ww1_s6AT3 [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6AT3];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6AT4;

Data.Semigroup.Internal.$fReadSum_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Sum a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AT5]
        let {
          ds_s6AT6 [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Sum a_X6t8R
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6AT5] \u []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6AT5; } in
        let {
          sat_s6AT9 [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Sum a_X6t8R)
          [LclId] =
              [ds_s6AT6] \r [n_s6AT7]
                  let {
                    sat_s6AT8 [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Sum a_X6t8R)
                    [LclId] =
                        [ds_s6AT6 n_s6AT7] \u []
                            ds_s6AT6
                                n_s6AT7 Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6AT8;
        } in  sat_s6AT9;

Data.Semigroup.Internal.$fReadSum_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Sum a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ATa]
        let {
          sat_s6ATb [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_X6t8P)
          [LclId] =
              [$dRead_s6ATa] \s []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6ATa;
        } in  GHC.Read.list sat_s6ATb;

Data.Semigroup.Internal.$fReadSum_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Sum a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6ATc]
        let {
          sat_s6ATe [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Sum a_X6t8Q]
          [LclId] =
              [$dRead_s6ATc] \u []
                  let {
                    sat_s6ATd [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Sum a_X6t8Q)
                    [LclId] =
                        [$dRead_s6ATc] \s []
                            Data.Semigroup.Internal.$fReadSum1 $dRead_s6ATc;
                  } in 
                    GHC.Read.list
                        sat_s6ATd
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6ATe;

Data.Semigroup.Internal.$fReadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6ATf]
        let {
          sat_s6ATj [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Sum a_X6t8O]
          [LclId] =
              [$dRead_s6ATf] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadListPrec $dRead_s6ATf; } in
        let {
          sat_s6ATi [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Sum a_X6t8O)
          [LclId] =
              [$dRead_s6ATf] \u []
                  Data.Semigroup.Internal.$fReadSum1 $dRead_s6ATf; } in
        let {
          sat_s6ATh [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Sum a_X6t8O]
          [LclId] =
              [$dRead_s6ATf] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadList $dRead_s6ATf; } in
        let {
          sat_s6ATg [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Sum a_X6t8O)
          [LclId] =
              [$dRead_s6ATf] \u []
                  Data.Semigroup.Internal.$fReadSum_$creadsPrec $dRead_s6ATf;
        } in  GHC.Read.C:Read [sat_s6ATg sat_s6ATh sat_s6ATi sat_s6ATj];

Data.Semigroup.Internal.$fEqSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Sum a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6ATk]
        let {
          sat_s6ATm [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sT9
               -> Data.Semigroup.Internal.Sum a_a6sT9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6ATk] \u [] GHC.Classes./= $dEq_s6ATk; } in
        let {
          sat_s6ATl [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sT9
               -> Data.Semigroup.Internal.Sum a_a6sT9 -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6ATk] \u [] GHC.Classes.== $dEq_s6ATk;
        } in  GHC.Classes.C:Eq [sat_s6ATl sat_s6ATm];

Data.Semigroup.Internal.$fOrdSum_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Sum a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6ATn]
        let {
          sat_s6ATo [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6sTH
          [LclId] =
              [$dOrd_s6ATn] \u [] GHC.Classes.$p1Ord $dOrd_s6ATn;
        } in  Data.Semigroup.Internal.$fEqSum sat_s6ATo;

Data.Semigroup.Internal.$fOrdSum [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Sum a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6ATp]
        let {
          sat_s6ATx [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.min $dOrd_s6ATp; } in
        let {
          sat_s6ATw [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.max $dOrd_s6ATp; } in
        let {
          sat_s6ATv [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.>= $dOrd_s6ATp; } in
        let {
          sat_s6ATu [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.> $dOrd_s6ATp; } in
        let {
          sat_s6ATt [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.<= $dOrd_s6ATp; } in
        let {
          sat_s6ATs [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.< $dOrd_s6ATp; } in
        let {
          sat_s6ATr [Occ=Once]
            :: Data.Semigroup.Internal.Sum a_a6sTH
               -> Data.Semigroup.Internal.Sum a_a6sTH -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6ATp] \u [] GHC.Classes.compare $dOrd_s6ATp; } in
        let {
          sat_s6ATq [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Sum a_a6sTH)
          [LclId] =
              [$dOrd_s6ATp] \u []
                  Data.Semigroup.Internal.$fOrdSum_$cp1Ord $dOrd_s6ATp;
        } in 
          GHC.Classes.C:Ord [sat_s6ATq
                             sat_s6ATr
                             sat_s6ATs
                             sat_s6ATt
                             sat_s6ATu
                             sat_s6ATv
                             sat_s6ATw
                             sat_s6ATx];

Data.Semigroup.Internal.$fGenericAny1
  :: forall x.
     GHC.Generics.Rep Data.Semigroup.Internal.Any x
     -> GHC.Generics.Rep Data.Semigroup.Internal.Any x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6ATy] ds_s6ATy;

Data.Semigroup.Internal.$fGenericAny2
  :: forall x.
     Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6ATz] x1_s6ATz;

Data.Semigroup.Internal.$fGenericAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAny2
                                           Data.Semigroup.Internal.$fGenericAny1];

Data.Semigroup.Internal.$fBoundedAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Bounded Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Bounded! [GHC.Types.False GHC.Types.True];

Data.Semigroup.Internal.$fShowAny4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Any {"#;

Data.Semigroup.Internal.$fShowAny3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fShowAny4;

Data.Semigroup.Internal.$fShowAny2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAny = "#;

Data.Semigroup.Internal.$w$cshowsPrec2 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> Data.Semigroup.Internal.Any
     -> GHC.Base.String
     -> GHC.Base.String
[GblId, Arity=3, Str=<S,U><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s6ATA w_s6ATB w1_s6ATC]
        case >=# [ww_s6ATA 11#] of {
          __DEFAULT ->
              let {
                sat_s6ATI [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6ATB w1_s6ATC] \s []
                        let {
                          sat_s6ATH [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6ATB w1_s6ATC] \u []
                                  case w_s6ATB of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s6ATF [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6ATC] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6ATC;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6ATF;
                                    GHC.Types.True ->
                                        let {
                                          sat_s6ATG [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6ATC] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6ATC;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6ATG;
                                  };
                        } in 
                          GHC.CString.unpackAppendCString#
                              Data.Semigroup.Internal.$fShowAny2 sat_s6ATH;
              } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6ATI;
          1# ->
              let {
                sat_s6ATQ [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6ATB w1_s6ATC] \u []
                        let {
                          sat_s6ATP [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6ATB w1_s6ATC] \s []
                                  let {
                                    sat_s6ATO [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w_s6ATB w1_s6ATC] \u []
                                            case w_s6ATB of {
                                              GHC.Types.False ->
                                                  let {
                                                    sat_s6ATL [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6ATC] \s []
                                                            let {
                                                              sat_s6ATK [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6ATC];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6ATK;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6ATL;
                                              GHC.Types.True ->
                                                  let {
                                                    sat_s6ATN [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6ATC] \s []
                                                            let {
                                                              sat_s6ATM [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6ATC];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6ATM;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6ATN;
                                            };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        Data.Semigroup.Internal.$fShowAny2 sat_s6ATO;
                        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6ATP;
              } in  : [GHC.Show.$fShow(,)4 sat_s6ATQ];
        };

Data.Semigroup.Internal.$fShowAny_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> Data.Semigroup.Internal.Any -> GHC.Show.ShowS
[GblId, Arity=3, Str=<S(S),1*U(U)><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [w_s6ATR w1_s6ATS w2_s6ATT]
        case w_s6ATR of {
          GHC.Types.I# ww1_s6ATV [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec2 ww1_s6ATV w1_s6ATS w2_s6ATT;
        };

Data.Semigroup.Internal.$fShowAll6 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++
            GHC.Show.$fShowBool4 Data.Semigroup.Internal.$fReadAll4;

Data.Semigroup.Internal.$fShowAll5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.Base.++
            GHC.Show.$fShowBool2 Data.Semigroup.Internal.$fReadAll4;

Data.Semigroup.Internal.$fShowAny_$cshow
  :: Data.Semigroup.Internal.Any -> GHC.Base.String
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s6ATW]
        let {
          sat_s6ATZ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [x_s6ATW] \s []
                  let {
                    sat_s6ATY [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [x_s6ATW] \u []
                            case x_s6ATW of {
                              GHC.Types.False -> Data.Semigroup.Internal.$fShowAll6;
                              GHC.Types.True -> Data.Semigroup.Internal.$fShowAll5;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAny2 sat_s6ATY;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6ATZ;

Data.Semigroup.Internal.$fShowAny1
  :: Data.Semigroup.Internal.Any -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,1*U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AU0 x_s6AU1]
        let {
          sat_s6AU6 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [ds_s6AU0 x_s6AU1] \s []
                  let {
                    sat_s6AU5 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ds_s6AU0 x_s6AU1] \u []
                            case ds_s6AU0 of {
                              GHC.Types.False ->
                                  let {
                                    sat_s6AU3 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6AU1] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6AU1;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6AU3;
                              GHC.Types.True ->
                                  let {
                                    sat_s6AU4 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6AU1] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6AU1;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6AU4;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAny2 sat_s6AU5;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAny3 sat_s6AU6;

Data.Semigroup.Internal.$fShowAny_$cshowList
  :: [Data.Semigroup.Internal.Any] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s6AU7 s_s6AU8]
        GHC.Show.showList__
            Data.Semigroup.Internal.$fShowAny1 ls_s6AU7 s_s6AU8;

Data.Semigroup.Internal.$fShowAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Semigroup.Internal.$fShowAny_$cshowsPrec
                                    Data.Semigroup.Internal.$fShowAny_$cshow
                                    Data.Semigroup.Internal.$fShowAny_$cshowList];

Data.Semigroup.Internal.$fReadAny6 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Any"#;

Data.Semigroup.Internal.$fReadAny5 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAny6;

Data.Semigroup.Internal.$fReadAny_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAny5];

Data.Semigroup.Internal.$fReadAny4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAny"#;

Data.Semigroup.Internal.$fReadAny3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAny4;

Data.Semigroup.Internal.$fReadAll7
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<L,A><L,U>, Unf=OtherCon []] =
    [] \r [ds1_s6AU9 eta_s6AUa]
        GHC.Read.list3
            GHC.Read.$fReadBool2
            Text.ParserCombinators.ReadPrec.minPrec
            eta_s6AUa;

Data.Semigroup.Internal.$w$creadPrec1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ww_s6AUb w_s6AUc]
        case <=# [ww_s6AUb 11#] of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
          1# ->
              let {
                sat_s6AUp [Occ=Once]
                  :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                [LclId] =
                    [w_s6AUc] \r [a1_s6AUe]
                        let {
                          sat_s6AUm [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                          [LclId] =
                              [w_s6AUc] \r [a2_s6AUf]
                                  let {
                                    sat_s6AUl [Occ=Once]
                                      :: GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b_s6uMw
                                    [LclId] =
                                        [w_s6AUc] \r [a3_s6AUg]
                                            let {
                                              sat_s6AUi [Occ=Once]
                                                :: () -> Text.ParserCombinators.ReadP.P b_s6uMw
                                              [LclId] =
                                                  [w_s6AUc a3_s6AUg] \r [a4_s6AUh] w_s6AUc a3_s6AUg;
                                            } in 
                                              case
                                                  Text.Read.Lex.$wexpect
                                                      Data.Semigroup.Internal.$fReadAll3 sat_s6AUi
                                              of
                                              { Unit# ww2_s6AUk [Occ=Once] ->
                                                    Text.ParserCombinators.ReadP.Look [ww2_s6AUk];
                                              };
                                  } in 
                                    GHC.Read.readField
                                        Data.Semigroup.Internal.$fReadAny3
                                        Data.Semigroup.Internal.$fReadAll7
                                        Data.Semigroup.Internal.$fReadAll6
                                        sat_s6AUl;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6AUm
                          of
                          { Unit# ww2_s6AUo [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_s6AUo];
                          };
              } in 
                case
                    Text.Read.Lex.$wexpect
                        Data.Semigroup.Internal.$fReadAny_lexeme sat_s6AUp
                of
                { Unit# ww2_s6AUr [Occ=Once] ->
                      Text.ParserCombinators.ReadP.Look [ww2_s6AUr];
                };
        };

Data.Semigroup.Internal.$fReadAny2 [InlPrag=NOUSERINLINE[0]]
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_s6AUs w1_s6AUt]
        case w_s6AUs of {
          GHC.Types.I# ww1_s6AUv [Occ=Once] ->
              Data.Semigroup.Internal.$w$creadPrec1 ww1_s6AUv w1_s6AUt;
        };

Data.Semigroup.Internal.$fReadAny1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Any -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Semigroup.Internal.$fReadAny2 eta_B2 eta_B1;

Data.Semigroup.Internal.$fReadAny_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Semigroup.Internal.Any
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [n_s6AUw]
        let {
          sat_s6AUx [Occ=Once]
            :: Text.ParserCombinators.ReadP.P Data.Semigroup.Internal.Any
          [LclId] =
              [n_s6AUw] \u []
                  GHC.Read.list3
                      Data.Semigroup.Internal.$fReadAny2
                      n_s6AUw
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6AUx;

Data.Semigroup.Internal.$fReadAny_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Any]
[GblId] =
    [] \u [] GHC.Read.list Data.Semigroup.Internal.$fReadAny1;

Data.Semigroup.Internal.$fReadAny7
  :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Internal.Any]
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fReadAny_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Semigroup.Internal.$fReadAny_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Any]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Data.Semigroup.Internal.$fReadAny7 eta_B1;

Data.Semigroup.Internal.$fReadAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Semigroup.Internal.$fReadAny_$creadsPrec
                                    Data.Semigroup.Internal.$fReadAny_$creadList
                                    Data.Semigroup.Internal.$fReadAny1
                                    Data.Semigroup.Internal.$fReadAny_$creadListPrec];

Data.Semigroup.Internal.$fEqAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Classes.$fEqBool_$c==
                                     GHC.Classes.$fEqBool_$c/=];

Data.Semigroup.Internal.$fOrdAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Semigroup.Internal.Any
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Semigroup.Internal.$fEqAny
                                      GHC.Classes.$fOrdBool_$ccompare
                                      GHC.Classes.$fOrdBool_$c<
                                      GHC.Classes.$fOrdBool_$c<=
                                      GHC.Classes.$fOrdBool_$c>
                                      GHC.Classes.$fOrdBool_$c>=
                                      GHC.Classes.$fOrdBool_$cmax
                                      GHC.Classes.$fOrdBool_$cmin];

Data.Semigroup.Internal.$fGenericAll1
  :: forall x.
     GHC.Generics.Rep Data.Semigroup.Internal.All x
     -> GHC.Generics.Rep Data.Semigroup.Internal.All x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AUy] ds_s6AUy;

Data.Semigroup.Internal.$fGenericAll2
  :: forall x.
     Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AUz] x1_s6AUz;

Data.Semigroup.Internal.$fGenericAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericAll2
                                           Data.Semigroup.Internal.$fGenericAll1];

Data.Semigroup.Internal.$fBoundedAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Enum.Bounded Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Enum.C:Bounded! [GHC.Types.False GHC.Types.True];

Data.Semigroup.Internal.$fShowAll4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "All {"#;

Data.Semigroup.Internal.$fShowAll3 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fShowAll4;

Data.Semigroup.Internal.$fShowAll2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAll = "#;

Data.Semigroup.Internal.$w$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> Data.Semigroup.Internal.All
     -> GHC.Base.String
     -> GHC.Base.String
[GblId, Arity=3, Str=<S,U><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ww_s6AUA w_s6AUB w1_s6AUC]
        case >=# [ww_s6AUA 11#] of {
          __DEFAULT ->
              let {
                sat_s6AUI [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6AUB w1_s6AUC] \s []
                        let {
                          sat_s6AUH [Occ=Once] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6AUB w1_s6AUC] \u []
                                  case w_s6AUB of {
                                    GHC.Types.False ->
                                        let {
                                          sat_s6AUF [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6AUC] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6AUC;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6AUF;
                                    GHC.Types.True ->
                                        let {
                                          sat_s6AUG [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                          [LclId] =
                                              [w1_s6AUC] \s []
                                                  GHC.Base.++
                                                      Data.Semigroup.Internal.$fReadAll4 w1_s6AUC;
                                        } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6AUG;
                                  };
                        } in 
                          GHC.CString.unpackAppendCString#
                              Data.Semigroup.Internal.$fShowAll2 sat_s6AUH;
              } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6AUI;
          1# ->
              let {
                sat_s6AUQ [Occ=Once] :: [GHC.Types.Char]
                [LclId] =
                    [w_s6AUB w1_s6AUC] \u []
                        let {
                          sat_s6AUP [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                          [LclId] =
                              [w_s6AUB w1_s6AUC] \s []
                                  let {
                                    sat_s6AUO [Occ=Once] :: [GHC.Types.Char]
                                    [LclId] =
                                        [w_s6AUB w1_s6AUC] \u []
                                            case w_s6AUB of {
                                              GHC.Types.False ->
                                                  let {
                                                    sat_s6AUL [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6AUC] \s []
                                                            let {
                                                              sat_s6AUK [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6AUC];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6AUK;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6AUL;
                                              GHC.Types.True ->
                                                  let {
                                                    sat_s6AUN [Occ=Once, Dmd=<L,1*U>]
                                                      :: [GHC.Types.Char]
                                                    [LclId] =
                                                        [w1_s6AUC] \s []
                                                            let {
                                                              sat_s6AUM [Occ=Once]
                                                                :: [GHC.Types.Char]
                                                              [LclId] =
                                                                  CCCS :! [GHC.Show.$fShow(,)2
                                                                           w1_s6AUC];
                                                            } in 
                                                              GHC.Base.++
                                                                  Data.Semigroup.Internal.$fReadAll4
                                                                  sat_s6AUM;
                                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6AUN;
                                            };
                                  } in 
                                    GHC.CString.unpackAppendCString#
                                        Data.Semigroup.Internal.$fShowAll2 sat_s6AUO;
                        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6AUP;
              } in  : [GHC.Show.$fShow(,)4 sat_s6AUQ];
        };

Data.Semigroup.Internal.$fShowAll_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Int -> Data.Semigroup.Internal.All -> GHC.Show.ShowS
[GblId, Arity=3, Str=<S(S),1*U(U)><L,1*U><L,U>, Unf=OtherCon []] =
    [] \r [w_s6AUR w1_s6AUS w2_s6AUT]
        case w_s6AUR of {
          GHC.Types.I# ww1_s6AUV [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec ww1_s6AUV w1_s6AUS w2_s6AUT;
        };

Data.Semigroup.Internal.$fShowAll_$cshow
  :: Data.Semigroup.Internal.All -> GHC.Base.String
[GblId, Arity=1, Str=<L,1*U>, Unf=OtherCon []] =
    [] \r [x_s6AUW]
        let {
          sat_s6AUZ [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [x_s6AUW] \s []
                  let {
                    sat_s6AUY [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [x_s6AUW] \u []
                            case x_s6AUW of {
                              GHC.Types.False -> Data.Semigroup.Internal.$fShowAll6;
                              GHC.Types.True -> Data.Semigroup.Internal.$fShowAll5;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAll2 sat_s6AUY;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6AUZ;

Data.Semigroup.Internal.$fShowAll1
  :: Data.Semigroup.Internal.All -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,1*U><L,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AV0 x_s6AV1]
        let {
          sat_s6AV6 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [ds_s6AV0 x_s6AV1] \s []
                  let {
                    sat_s6AV5 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [ds_s6AV0 x_s6AV1] \u []
                            case ds_s6AV0 of {
                              GHC.Types.False ->
                                  let {
                                    sat_s6AV3 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6AV1] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6AV1;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool4 sat_s6AV3;
                              GHC.Types.True ->
                                  let {
                                    sat_s6AV4 [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
                                    [LclId] =
                                        [x_s6AV1] \s []
                                            GHC.Base.++ Data.Semigroup.Internal.$fReadAll4 x_s6AV1;
                                  } in  GHC.Base.++ GHC.Show.$fShowBool2 sat_s6AV4;
                            };
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowAll2 sat_s6AV5;
        } in  GHC.Base.++ Data.Semigroup.Internal.$fShowAll3 sat_s6AV6;

Data.Semigroup.Internal.$fShowAll_$cshowList
  :: [Data.Semigroup.Internal.All] -> GHC.Show.ShowS
[GblId, Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
    [] \r [ls_s6AV7 s_s6AV8]
        GHC.Show.showList__
            Data.Semigroup.Internal.$fShowAll1 ls_s6AV7 s_s6AV8;

Data.Semigroup.Internal.$fShowAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Show.Show Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Show.C:Show! [Data.Semigroup.Internal.$fShowAll_$cshowsPrec
                                    Data.Semigroup.Internal.$fShowAll_$cshow
                                    Data.Semigroup.Internal.$fShowAll_$cshowList];

Data.Semigroup.Internal.$fReadAll13 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "All"#;

Data.Semigroup.Internal.$fReadAll12 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll13;

Data.Semigroup.Internal.$fReadAll_lexeme1 :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadAll12];

Data.Semigroup.Internal.$fReadAll9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getAll"#;

Data.Semigroup.Internal.$fReadAll8 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadAll9;

Data.Semigroup.Internal.$w$creadPrec [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int#
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S,U><L,C(U)>, Unf=OtherCon []] =
    [] \r [ww_s6AV9 w_s6AVa]
        case <=# [ww_s6AV9 11#] of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
          1# ->
              let {
                sat_s6AVn [Occ=Once]
                  :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                [LclId] =
                    [w_s6AVa] \r [a1_s6AVc]
                        let {
                          sat_s6AVk [Occ=Once]
                            :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                          [LclId] =
                              [w_s6AVa] \r [a2_s6AVd]
                                  let {
                                    sat_s6AVj [Occ=Once]
                                      :: GHC.Types.Bool -> Text.ParserCombinators.ReadP.P b_s6uMP
                                    [LclId] =
                                        [w_s6AVa] \r [a3_s6AVe]
                                            let {
                                              sat_s6AVg [Occ=Once]
                                                :: () -> Text.ParserCombinators.ReadP.P b_s6uMP
                                              [LclId] =
                                                  [w_s6AVa a3_s6AVe] \r [a4_s6AVf] w_s6AVa a3_s6AVe;
                                            } in 
                                              case
                                                  Text.Read.Lex.$wexpect
                                                      Data.Semigroup.Internal.$fReadAll3 sat_s6AVg
                                              of
                                              { Unit# ww2_s6AVi [Occ=Once] ->
                                                    Text.ParserCombinators.ReadP.Look [ww2_s6AVi];
                                              };
                                  } in 
                                    GHC.Read.readField
                                        Data.Semigroup.Internal.$fReadAll8
                                        Data.Semigroup.Internal.$fReadAll7
                                        Data.Semigroup.Internal.$fReadAll6
                                        sat_s6AVj;
                        } in 
                          case
                              Text.Read.Lex.$wexpect
                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6AVk
                          of
                          { Unit# ww2_s6AVm [Occ=Once] ->
                                Text.ParserCombinators.ReadP.Look [ww2_s6AVm];
                          };
              } in 
                case
                    Text.Read.Lex.$wexpect
                        Data.Semigroup.Internal.$fReadAll_lexeme1 sat_s6AVn
                of
                { Unit# ww2_s6AVp [Occ=Once] ->
                      Text.ParserCombinators.ReadP.Look [ww2_s6AVp];
                };
        };

Data.Semigroup.Internal.$fReadAll2 [InlPrag=NOUSERINLINE[0]]
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Str=<S(S),1*U(U)><L,C(U)>, Unf=OtherCon []] =
    [] \r [w_s6AVq w1_s6AVr]
        case w_s6AVq of {
          GHC.Types.I# ww1_s6AVt [Occ=Once] ->
              Data.Semigroup.Internal.$w$creadPrec ww1_s6AVt w1_s6AVr;
        };

Data.Semigroup.Internal.$fReadAll1
  :: Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.All -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=2, Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        GHC.Read.list3 Data.Semigroup.Internal.$fReadAll2 eta_B2 eta_B1;

Data.Semigroup.Internal.$fReadAll_$creadsPrec
  :: GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS Data.Semigroup.Internal.All
[GblId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
    [] \r [n_s6AVu]
        let {
          sat_s6AVv [Occ=Once]
            :: Text.ParserCombinators.ReadP.P Data.Semigroup.Internal.All
          [LclId] =
              [n_s6AVu] \u []
                  GHC.Read.list3
                      Data.Semigroup.Internal.$fReadAll2
                      n_s6AVu
                      Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6AVv;

Data.Semigroup.Internal.$fReadAll_$creadListPrec
  :: Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.All]
[GblId] =
    [] \u [] GHC.Read.list Data.Semigroup.Internal.$fReadAll1;

Data.Semigroup.Internal.$fReadAll14
  :: Text.ParserCombinators.ReadP.P [Data.Semigroup.Internal.All]
[GblId] =
    [] \u []
        Data.Semigroup.Internal.$fReadAll_$creadListPrec
            GHC.Read.$fRead()7
            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;

Data.Semigroup.Internal.$fReadAll_$creadList
  :: Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.All]
[GblId, Arity=1, Unf=OtherCon []] =
    [] \r [eta_B1]
        Text.ParserCombinators.ReadP.run
            Data.Semigroup.Internal.$fReadAll14 eta_B1;

Data.Semigroup.Internal.$fReadAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Read.Read Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Read.C:Read! [Data.Semigroup.Internal.$fReadAll_$creadsPrec
                                    Data.Semigroup.Internal.$fReadAll_$creadList
                                    Data.Semigroup.Internal.$fReadAll1
                                    Data.Semigroup.Internal.$fReadAll_$creadListPrec];

Data.Semigroup.Internal.$fEqAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Eq Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Eq! [GHC.Classes.$fEqBool_$c==
                                     GHC.Classes.$fEqBool_$c/=];

Data.Semigroup.Internal.$fOrdAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Classes.Ord Data.Semigroup.Internal.All
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Classes.C:Ord! [Data.Semigroup.Internal.$fEqAll
                                      GHC.Classes.$fOrdBool_$ccompare
                                      GHC.Classes.$fOrdBool_$c<
                                      GHC.Classes.$fOrdBool_$c<=
                                      GHC.Classes.$fOrdBool_$c>
                                      GHC.Classes.$fOrdBool_$c>=
                                      GHC.Classes.$fOrdBool_$cmax
                                      GHC.Classes.$fOrdBool_$cmin];

Data.Semigroup.Internal.$fGenericEndo1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Endo a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Endo a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AVw] ds_s6AVw;

Data.Semigroup.Internal.$fGenericEndo2
  :: forall a x.
     Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AVx] x1_s6AVx;

Data.Semigroup.Internal.$fGenericEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericEndo2
                                           Data.Semigroup.Internal.$fGenericEndo1];

Data.Semigroup.Internal.$fGeneric1Dual1
  :: forall a.
     GHC.Generics.Rep1 Data.Semigroup.Internal.Dual a
     -> GHC.Generics.Rep1 Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AVy] ds_s6AVy;

Data.Semigroup.Internal.$fGeneric1Dual2
  :: forall a.
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x_s6AVz] x_s6AVz;

Data.Semigroup.Internal.$fGeneric1Dual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Generics.Generic1 Data.Semigroup.Internal.Dual
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic1! [Data.Semigroup.Internal.$fGeneric1Dual2
                                            Data.Semigroup.Internal.$fGeneric1Dual1];

Data.Semigroup.Internal.$fGenericDual1
  :: forall a x.
     GHC.Generics.Rep (Data.Semigroup.Internal.Dual a) x
     -> GHC.Generics.Rep (Data.Semigroup.Internal.Dual a) x
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AVA] ds_s6AVA;

Data.Semigroup.Internal.$fGenericDual2
  :: forall a x.
     Data.Semigroup.Internal.Dual a -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [x1_s6AVB] x1_s6AVB;

Data.Semigroup.Internal.$fGenericDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Generics.Generic (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE GHC.Generics.C:Generic! [Data.Semigroup.Internal.$fGenericDual2
                                           Data.Semigroup.Internal.$fGenericDual1];

Data.Semigroup.Internal.$fBoundedDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Enum.Bounded a =>
     GHC.Enum.Bounded (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dBounded_s6AVC]
        let {
          sat_s6AVE [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6sGr
          [LclId] =
              [$dBounded_s6AVC] \u [] GHC.Enum.maxBound $dBounded_s6AVC; } in
        let {
          sat_s6AVD [Occ=Once] :: Data.Semigroup.Internal.Dual a_a6sGr
          [LclId] =
              [$dBounded_s6AVC] \u [] GHC.Enum.minBound $dBounded_s6AVC;
        } in  GHC.Enum.C:Bounded [sat_s6AVD sat_s6AVE];

Data.Semigroup.Internal.$fShowDual2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Dual {"#;

Data.Semigroup.Internal.$fShowDual1 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getDual = "#;

Data.Semigroup.Internal.$w$cshowsPrec3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Prim.Int# -> Data.Semigroup.Internal.Dual a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AVF ww_s6AVG w1_s6AVH]
        let {
          f_s6AVI [Occ=OnceL*!, Dmd=<L,C(U)>]
            :: GHC.Base.String -> GHC.Base.String
          [LclId] =
              [w_s6AVF w1_s6AVH] \u []
                  GHC.Show.showsPrec
                      w_s6AVF Data.Semigroup.Internal.$fShowAlt1 w1_s6AVH;
        } in 
          case >=# [ww_s6AVG 11#] of {
            __DEFAULT ->
                let {
                  sat_s6AVO [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6AVI] \r [x_s6AVK]
                          let {
                            sat_s6AVN [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6AVI x_s6AVK] \u []
                                    let {
                                      sat_s6AVM [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6AVI x_s6AVK] \u []
                                              let {
                                                sat_s6AVL [Occ=Once] :: GHC.Base.String
                                                [LclId] =
                                                    [x_s6AVK] \u []
                                                        GHC.CString.unpackAppendCString#
                                                            Data.Semigroup.Internal.$fReadAll5
                                                            x_s6AVK;
                                              } in  f_s6AVI sat_s6AVL;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowDual1 sat_s6AVM;
                          } in 
                            GHC.CString.unpackAppendCString#
                                Data.Semigroup.Internal.$fShowDual2 sat_s6AVN;
                } in  sat_s6AVO;
            1# ->
                let {
                  sat_s6AVV [Occ=OnceT[0]] :: GHC.Base.String -> [GHC.Types.Char]
                  [LclId] =
                      [f_s6AVI] \r [x_s6AVP]
                          let {
                            sat_s6AVU [Occ=Once] :: [GHC.Types.Char]
                            [LclId] =
                                [f_s6AVI x_s6AVP] \u []
                                    let {
                                      sat_s6AVT [Occ=Once] :: [GHC.Types.Char]
                                      [LclId] =
                                          [f_s6AVI x_s6AVP] \u []
                                              let {
                                                sat_s6AVS [Occ=Once] :: [GHC.Types.Char]
                                                [LclId] =
                                                    [f_s6AVI x_s6AVP] \u []
                                                        let {
                                                          sat_s6AVR [Occ=Once] :: GHC.Base.String
                                                          [LclId] =
                                                              [x_s6AVP] \u []
                                                                  let {
                                                                    sat_s6AVQ [Occ=Once]
                                                                      :: [GHC.Types.Char]
                                                                    [LclId] =
                                                                        CCCS :! [GHC.Show.$fShow(,)2
                                                                                 x_s6AVP];
                                                                  } in 
                                                                    GHC.CString.unpackAppendCString#
                                                                        Data.Semigroup.Internal.$fReadAll5
                                                                        sat_s6AVQ;
                                                        } in  f_s6AVI sat_s6AVR;
                                              } in 
                                                GHC.CString.unpackAppendCString#
                                                    Data.Semigroup.Internal.$fShowDual1 sat_s6AVS;
                                    } in 
                                      GHC.CString.unpackAppendCString#
                                          Data.Semigroup.Internal.$fShowDual2 sat_s6AVT;
                          } in  : [GHC.Show.$fShow(,)4 sat_s6AVU];
                } in  sat_s6AVV;
          };

Data.Semigroup.Internal.$fShowDual_$cshowsPrec [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Types.Int -> Data.Semigroup.Internal.Dual a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_s6AVW w1_s6AVX w2_s6AVY]
        case w1_s6AVX of {
          GHC.Types.I# ww1_s6AW0 [Occ=Once] ->
              Data.Semigroup.Internal.$w$cshowsPrec3 w_s6AVW ww1_s6AW0 w2_s6AVY;
        };

Data.Semigroup.Internal.$fShowDual_$cshow
  :: forall a.
     GHC.Show.Show a =>
     Data.Semigroup.Internal.Dual a -> GHC.Base.String
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6AW1 x_s6AW2]
        let {
          sat_s6AW4 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s6AW1 x_s6AW2] \u []
                  let {
                    sat_s6AW3 [Occ=Once] :: [GHC.Types.Char]
                    [LclId] =
                        [$dShow_s6AW1 x_s6AW2] \u []
                            GHC.Show.showsPrec
                                $dShow_s6AW1
                                Data.Semigroup.Internal.$fShowAlt1
                                x_s6AW2
                                Data.Semigroup.Internal.$fReadAll4;
                  } in 
                    GHC.CString.unpackAppendCString#
                        Data.Semigroup.Internal.$fShowDual1 sat_s6AW3;
        } in 
          GHC.CString.unpackAppendCString#
              Data.Semigroup.Internal.$fShowDual2 sat_s6AW4;

Data.Semigroup.Internal.$fShowDual_$cshowList
  :: forall a.
     GHC.Show.Show a =>
     [Data.Semigroup.Internal.Dual a] -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dShow_s6AW5 ls_s6AW6 s_s6AW7]
        let {
          sat_s6AW9 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AW5] \r [w_s6AW8]
                  Data.Semigroup.Internal.$w$cshowsPrec3 $dShow_s6AW5 0# w_s6AW8;
        } in  GHC.Show.showList__ sat_s6AW9 ls_s6AW6 s_s6AW7;

Data.Semigroup.Internal.$fShowDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Show.Show a =>
     GHC.Show.Show (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Str=<L,U(C(C1(C(U))),A,A)>m] =
    [] \r [$dShow_s6AWa]
        let {
          sat_s6AWd [Occ=Once]
            :: [Data.Semigroup.Internal.Dual a_a6sFL] -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AWa] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshowList
                      $dShow_s6AWa eta_B2 eta_B1; } in
        let {
          sat_s6AWc [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Base.String
          [LclId] =
              [$dShow_s6AWa] \r [eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshow $dShow_s6AWa eta_B1; } in
        let {
          sat_s6AWb [Occ=Once]
            :: GHC.Types.Int
               -> Data.Semigroup.Internal.Dual a_a6sFL -> GHC.Show.ShowS
          [LclId] =
              [$dShow_s6AWa] \r [eta_B2 eta_B1]
                  Data.Semigroup.Internal.$fShowDual_$cshowsPrec
                      $dShow_s6AWa eta_B2 eta_B1;
        } in  GHC.Show.C:Show [sat_s6AWb sat_s6AWc sat_s6AWd];

Data.Semigroup.Internal.$fReadDual5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Dual"#;

Data.Semigroup.Internal.$fReadDual4 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadDual5;

Data.Semigroup.Internal.$fReadDual_lexeme :: Text.Read.Lex.Lexeme
[GblId, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE Text.Read.Lex.Ident! [Data.Semigroup.Internal.$fReadDual4];

Data.Semigroup.Internal.$fReadDual3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "getDual"#;

Data.Semigroup.Internal.$fReadDual2 :: [GHC.Types.Char]
[GblId] =
    [] \u []
        GHC.CString.unpackCString# Data.Semigroup.Internal.$fReadDual3;

Data.Semigroup.Internal.$fReadDual1
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.Prec
     -> forall b.
        (Data.Semigroup.Internal.Dual a
         -> Text.ParserCombinators.ReadP.P b)
        -> Text.ParserCombinators.ReadP.P b
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AWe]
        let {
          lvl12_s6AWf [Occ=OnceL]
            :: Text.ParserCombinators.ReadP.ReadP a_a6sEx
          [LclId] =
              [$dRead_s6AWe] \u []
                  GHC.Read.readPrec
                      $dRead_s6AWe Text.ParserCombinators.ReadPrec.minPrec; } in
        let {
          ds_s6AWg [Occ=OnceL, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> Text.ParserCombinators.ReadP.ReadP a_a6sEx
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl12_s6AWf] \r [ds1_s6AWh] lvl12_s6AWf; } in
        let {
          sat_s6AWB [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_a6sEx)
          [LclId] =
              [ds_s6AWg] \r [c_s6AWi eta_s6AWj]
                  case c_s6AWi of {
                    GHC.Types.I# x_s6AWl [Occ=Once] ->
                        case <=# [x_s6AWl 11#] of {
                          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                          1# ->
                              let {
                                sat_s6AWy [Occ=Once]
                                  :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                [LclId] =
                                    [ds_s6AWg eta_s6AWj] \r [a1_s6AWn]
                                        let {
                                          sat_s6AWv [Occ=Once]
                                            :: () -> Text.ParserCombinators.ReadP.P b_i6u9v
                                          [LclId] =
                                              [ds_s6AWg eta_s6AWj] \r [a2_s6AWo]
                                                  let {
                                                    sat_s6AWu [Occ=Once]
                                                      :: a_a6sEx
                                                         -> Text.ParserCombinators.ReadP.P b_i6u9v
                                                    [LclId] =
                                                        [eta_s6AWj] \r [a3_s6AWp]
                                                            let {
                                                              sat_s6AWr [Occ=Once]
                                                                :: ()
                                                                   -> Text.ParserCombinators.ReadP.P
                                                                        b_i6u9v
                                                              [LclId] =
                                                                  [eta_s6AWj a3_s6AWp] \r [a4_s6AWq]
                                                                      eta_s6AWj a3_s6AWp;
                                                            } in 
                                                              case
                                                                  Text.Read.Lex.$wexpect
                                                                      Data.Semigroup.Internal.$fReadAll3
                                                                      sat_s6AWr
                                                              of
                                                              { Unit# ww1_s6AWt [Occ=Once] ->
                                                                    Text.ParserCombinators.ReadP.Look [ww1_s6AWt];
                                                              };
                                                  } in 
                                                    GHC.Read.readField
                                                        Data.Semigroup.Internal.$fReadDual2
                                                        ds_s6AWg
                                                        Data.Semigroup.Internal.$fReadAll6
                                                        sat_s6AWu;
                                        } in 
                                          case
                                              Text.Read.Lex.$wexpect
                                                  Data.Semigroup.Internal.$fReadAll_lexeme sat_s6AWv
                                          of
                                          { Unit# ww1_s6AWx [Occ=Once] ->
                                                Text.ParserCombinators.ReadP.Look [ww1_s6AWx];
                                          };
                              } in 
                                case
                                    Text.Read.Lex.$wexpect
                                        Data.Semigroup.Internal.$fReadDual_lexeme sat_s6AWy
                                of
                                { Unit# ww1_s6AWA [Occ=Once] ->
                                      Text.ParserCombinators.ReadP.Look [ww1_s6AWA];
                                };
                        };
                  };
        } in  GHC.Read.list3 sat_s6AWB;

Data.Semigroup.Internal.$fReadDual_$creadsPrec
  :: forall a.
     GHC.Read.Read a =>
     GHC.Types.Int
     -> Text.ParserCombinators.ReadP.ReadS
          (Data.Semigroup.Internal.Dual a)
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AWC]
        let {
          ds_s6AWD [Occ=OnceL!, Dmd=<L,C(C1(U))>]
            :: Text.ParserCombinators.ReadPrec.Prec
               -> forall b.
                  (Data.Semigroup.Internal.Dual a_X6sTW
                   -> Text.ParserCombinators.ReadP.P b)
                  -> Text.ParserCombinators.ReadP.P b
          [LclId] =
              [$dRead_s6AWC] \u []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6AWC; } in
        let {
          sat_s6AWG [Occ=OnceT[0]]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Dual a_X6sTW)
          [LclId] =
              [ds_s6AWD] \r [n_s6AWE]
                  let {
                    sat_s6AWF [Occ=Once]
                      :: Text.ParserCombinators.ReadP.P
                           (Data.Semigroup.Internal.Dual a_X6sTW)
                    [LclId] =
                        [ds_s6AWD n_s6AWE] \u []
                            ds_s6AWD
                                n_s6AWE Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
                  } in  Text.ParserCombinators.ReadP.run sat_s6AWF;
        } in  sat_s6AWG;

Data.Semigroup.Internal.$fReadDual_$creadListPrec
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadPrec.ReadPrec
       [Data.Semigroup.Internal.Dual a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AWH]
        let {
          sat_s6AWI [Occ=Once, Dmd=<L,1*C1(C(U))>]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_X6sTU)
          [LclId] =
              [$dRead_s6AWH] \s []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6AWH;
        } in  GHC.Read.list sat_s6AWI;

Data.Semigroup.Internal.$fReadDual_$creadList
  :: forall a.
     GHC.Read.Read a =>
     Text.ParserCombinators.ReadP.ReadS [Data.Semigroup.Internal.Dual a]
[GblId, Arity=1, Str=<L,1*U(A,A,1*C1(U),A)>, Unf=OtherCon []] =
    [] \r [$dRead_s6AWJ]
        let {
          sat_s6AWL [Occ=Once]
            :: Text.ParserCombinators.ReadP.P
                 [Data.Semigroup.Internal.Dual a_X6sTV]
          [LclId] =
              [$dRead_s6AWJ] \u []
                  let {
                    sat_s6AWK [Occ=Once, Dmd=<L,1*C1(C(U))>]
                      :: Text.ParserCombinators.ReadPrec.ReadPrec
                           (Data.Semigroup.Internal.Dual a_X6sTV)
                    [LclId] =
                        [$dRead_s6AWJ] \s []
                            Data.Semigroup.Internal.$fReadDual1 $dRead_s6AWJ;
                  } in 
                    GHC.Read.list
                        sat_s6AWK
                        GHC.Read.$fRead()7
                        Text.ParserCombinators.ReadP.$fApplicativeP_$cpure;
        } in  Text.ParserCombinators.ReadP.run sat_s6AWL;

Data.Semigroup.Internal.$fReadDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Read.Read a =>
     GHC.Read.Read (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Str=<L,U(A,A,C(U),A)>m] =
    [] \r [$dRead_s6AWM]
        let {
          sat_s6AWQ [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 [Data.Semigroup.Internal.Dual a_X6sTT]
          [LclId] =
              [$dRead_s6AWM] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadListPrec
                      $dRead_s6AWM; } in
        let {
          sat_s6AWP [Occ=Once]
            :: Text.ParserCombinators.ReadPrec.ReadPrec
                 (Data.Semigroup.Internal.Dual a_X6sTT)
          [LclId] =
              [$dRead_s6AWM] \u []
                  Data.Semigroup.Internal.$fReadDual1 $dRead_s6AWM; } in
        let {
          sat_s6AWO [Occ=Once]
            :: Text.ParserCombinators.ReadP.ReadS
                 [Data.Semigroup.Internal.Dual a_X6sTT]
          [LclId] =
              [$dRead_s6AWM] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadList $dRead_s6AWM; } in
        let {
          sat_s6AWN [Occ=Once]
            :: GHC.Types.Int
               -> Text.ParserCombinators.ReadP.ReadS
                    (Data.Semigroup.Internal.Dual a_X6sTT)
          [LclId] =
              [$dRead_s6AWM] \u []
                  Data.Semigroup.Internal.$fReadDual_$creadsPrec $dRead_s6AWM;
        } in  GHC.Read.C:Read [sat_s6AWN sat_s6AWO sat_s6AWP sat_s6AWQ];

Data.Semigroup.Internal.$fEqDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Dual a)
[GblId[DFunId], Arity=1, Caf=NoCafRefs, Str=<L,U(1*U,1*U)>m] =
    [] \r [$dEq_s6AWR]
        let {
          sat_s6AWT [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCa
               -> Data.Semigroup.Internal.Dual a_a6sCa -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6AWR] \u [] GHC.Classes./= $dEq_s6AWR; } in
        let {
          sat_s6AWS [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCa
               -> Data.Semigroup.Internal.Dual a_a6sCa -> GHC.Types.Bool
          [LclId] =
              [$dEq_s6AWR] \u [] GHC.Classes.== $dEq_s6AWR;
        } in  GHC.Classes.C:Eq [sat_s6AWS sat_s6AWT];

Data.Semigroup.Internal.$fOrdDual_$cp1Ord
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Eq (Data.Semigroup.Internal.Dual a)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
 Unf=OtherCon []] =
    [] \r [$dOrd_s6AWU]
        let {
          sat_s6AWV [Occ=Once, Dmd=<L,U(1*U,1*U)>] :: GHC.Classes.Eq a_a6sCI
          [LclId] =
              [$dOrd_s6AWU] \u [] GHC.Classes.$p1Ord $dOrd_s6AWU;
        } in  Data.Semigroup.Internal.$fEqDual sat_s6AWV;

Data.Semigroup.Internal.$fOrdDual [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Classes.Ord (Data.Semigroup.Internal.Dual a)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m] =
    [] \r [$dOrd_s6AWW]
        let {
          sat_s6AX4 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.min $dOrd_s6AWW; } in
        let {
          sat_s6AX3 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.max $dOrd_s6AWW; } in
        let {
          sat_s6AX2 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.>= $dOrd_s6AWW; } in
        let {
          sat_s6AX1 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.> $dOrd_s6AWW; } in
        let {
          sat_s6AX0 [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.<= $dOrd_s6AWW; } in
        let {
          sat_s6AWZ [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Bool
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.< $dOrd_s6AWW; } in
        let {
          sat_s6AWY [Occ=Once]
            :: Data.Semigroup.Internal.Dual a_a6sCI
               -> Data.Semigroup.Internal.Dual a_a6sCI -> GHC.Types.Ordering
          [LclId] =
              [$dOrd_s6AWW] \u [] GHC.Classes.compare $dOrd_s6AWW; } in
        let {
          sat_s6AWX [Occ=Once]
            :: GHC.Classes.Eq (Data.Semigroup.Internal.Dual a_a6sCI)
          [LclId] =
              [$dOrd_s6AWW] \u []
                  Data.Semigroup.Internal.$fOrdDual_$cp1Ord $dOrd_s6AWW;
        } in 
          GHC.Classes.C:Ord [sat_s6AWX
                             sat_s6AWY
                             sat_s6AWZ
                             sat_s6AX0
                             sat_s6AX1
                             sat_s6AX2
                             sat_s6AX3
                             sat_s6AX4];

Data.Semigroup.Internal.getDual
  :: forall a. Data.Semigroup.Internal.Dual a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Dual2 eta_B1;

Data.Semigroup.Internal.$fMonadDual_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> (a -> Data.Semigroup.Internal.Dual b)
     -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6AX5 k_s6AX6] k_s6AX6 m_s6AX5;

Data.Semigroup.Internal.$fMonadDual_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Dual a
     -> Data.Semigroup.Internal.Dual b -> Data.Semigroup.Internal.Dual b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeDual_$c*> eta_B2 eta_B1;

lvl_r6v16
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Dual a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6AX7] GHC.Err.errorWithoutStackTrace eta_s6AX7;

Data.Semigroup.Internal.$fMonadDual [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Dual
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeDual
                                     Data.Semigroup.Internal.$fMonadDual_$c>>=
                                     Data.Semigroup.Internal.$fMonadDual_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl_r6v16];

Data.Semigroup.Internal.appEndo1
  :: forall a.
     Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AX8] ds_s6AX8;

Data.Semigroup.Internal.appEndo
  :: forall a. Data.Semigroup.Internal.Endo a -> a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.appEndo1 eta_B1;

Data.Semigroup.Internal.getAll1
  :: Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AX9] ds_s6AX9;

Data.Semigroup.Internal.getAll
  :: Data.Semigroup.Internal.All -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.getAll1 eta_B1;

Data.Semigroup.Internal.getAny1
  :: Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AXa] ds_s6AXa;

Data.Semigroup.Internal.getAny
  :: Data.Semigroup.Internal.Any -> GHC.Types.Bool
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.getAny1 eta_B1;

Data.Semigroup.Internal.getSum
  :: forall a. Data.Semigroup.Internal.Sum a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Sum2 eta_B1;

Data.Semigroup.Internal.$fMonadSum_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> (a -> Data.Semigroup.Internal.Sum b)
     -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6AXb k_s6AXc] k_s6AXc m_s6AXb;

Data.Semigroup.Internal.$fMonadSum_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Sum a
     -> Data.Semigroup.Internal.Sum b -> Data.Semigroup.Internal.Sum b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeSum_$c*> eta_B2 eta_B1;

lvl1_r6v17
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Sum a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6AXd] GHC.Err.errorWithoutStackTrace eta_s6AXd;

Data.Semigroup.Internal.$fMonadSum [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Sum
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeSum
                                     Data.Semigroup.Internal.$fMonadSum_$c>>=
                                     Data.Semigroup.Internal.$fMonadSum_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl1_r6v17];

Data.Semigroup.Internal.getProduct
  :: forall a. Data.Semigroup.Internal.Product a -> a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Product2 eta_B1;

Data.Semigroup.Internal.$fMonadProduct_$c>>=
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> (a -> Data.Semigroup.Internal.Product b)
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><C(S),1*C1(U)>,
 Unf=OtherCon []] =
    [] \r [m_s6AXe k_s6AXf] k_s6AXf m_s6AXe;

Data.Semigroup.Internal.$fMonadProduct_$c>> [InlPrag=INLINE (sat-args=2)]
  :: forall a b.
     Data.Semigroup.Internal.Product a
     -> Data.Semigroup.Internal.Product b
     -> Data.Semigroup.Internal.Product b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1]
        Data.Semigroup.Internal.$fApplicativeProduct_$c*> eta_B2 eta_B1;

lvl2_r6v18
  :: forall a. [GHC.Types.Char] -> Data.Semigroup.Internal.Product a
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [eta_s6AXg] GHC.Err.errorWithoutStackTrace eta_s6AXg;

Data.Semigroup.Internal.$fMonadProduct [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monad Data.Semigroup.Internal.Product
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monad! [Data.Semigroup.Internal.$fApplicativeProduct
                                     Data.Semigroup.Internal.$fMonadProduct_$c>>=
                                     Data.Semigroup.Internal.$fMonadProduct_$c>>
                                     Data.Semigroup.Internal.$fApplicativeDual4
                                     lvl2_r6v18];

Data.Semigroup.Internal.getAlt
  :: forall k (f :: k -> *) (a :: k).
     Data.Semigroup.Internal.Alt f a -> f a
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_B1] Data.Semigroup.Internal.$fGeneric1Alt2 eta_B1;

lvl3_r6v19 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesIdempotent: positive multiplier expected"#;

Data.Semigroup.Internal.stimesIdempotent1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl3_r6v19 of sat_s6AXh {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6AXh;
        };

Data.Semigroup.Internal.stimesIdempotent
  :: forall b a. GHC.Real.Integral b => b -> a -> a
[GblId,
 Arity=3,
 Str=<S(S(LS(LLLC(C(S))LLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AXi eta_s6AXj eta1_s6AXk]
        case
            GHC.Real.$p1Integral $dIntegral_s6AXi
        of
        $dReal_s6AXl [Dmd=<S(LS(LLLC(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6AXo [Occ=Once] :: b_a6sBZ
                [LclId] =
                    [$dReal_s6AXl] \u []
                        case GHC.Real.$p1Real $dReal_s6AXl of sat_s6AXn {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6AXn Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6AXl of sat_s6AXm {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s6AXm eta_s6AXj sat_s6AXo of {
                        GHC.Types.False -> eta1_s6AXk;
                        GHC.Types.True -> Data.Semigroup.Internal.stimesIdempotent1;
                      };
                };
        };

lvl4_r6v1a :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesIdempotentMonoid: negative multiplier"#;

Data.Semigroup.Internal.stimesIdempotentMonoid1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl4_r6v1a of sat_s6AXq {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6AXq;
        };

Data.Semigroup.Internal.stimesIdempotentMonoid
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(LC(C(S))LLLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,1*U(A,1*U,A,A)><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AXr $dMonoid_s6AXs eta_s6AXt eta1_s6AXu]
        case
            GHC.Real.$p1Integral $dIntegral_s6AXr
        of
        $dReal_s6AXv [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6AXy [Occ=Once] :: b_a6sBJ
                [LclId] =
                    [$dReal_s6AXv] \u []
                        case GHC.Real.$p1Real $dReal_s6AXv of sat_s6AXx {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6AXx Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6AXv of sat_s6AXw {
                  __DEFAULT ->
                      case GHC.Classes.compare sat_s6AXw eta_s6AXt sat_s6AXy of {
                        GHC.Types.LT -> Data.Semigroup.Internal.stimesIdempotentMonoid1;
                        GHC.Types.EQ -> GHC.Base.mempty $dMonoid_s6AXs;
                        GHC.Types.GT -> eta1_s6AXu;
                      };
                };
        };

Data.Semigroup.Internal.$fSemigroupAny_go [Occ=LoopBreaker]
  :: Data.Semigroup.Internal.Any
     -> [Data.Semigroup.Internal.Any] -> Data.Semigroup.Internal.Any
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6AXA ds1_s6AXB]
        case ds1_s6AXB of {
          [] -> b_s6AXA;
          : c_s6AXD [Occ=Once] cs_s6AXE [Occ=Once] ->
              case b_s6AXA of {
                GHC.Types.False ->
                    Data.Semigroup.Internal.$fSemigroupAny_go c_s6AXD cs_s6AXE;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

Data.Semigroup.Internal.$fSemigroupAny_$csconcat
  :: GHC.Base.NonEmpty Data.Semigroup.Internal.Any
     -> Data.Semigroup.Internal.Any
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6AXG]
        case ds_s6AXG of {
          GHC.Base.:| a1_s6AXI [Occ=Once] as_s6AXJ [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupAny_go a1_s6AXI as_s6AXJ;
        };

Data.Semigroup.Internal.$fMonoidAny_go [Occ=LoopBreaker]
  :: [Data.Semigroup.Internal.Any] -> Data.Semigroup.Internal.Any
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AXK]
        case ds_s6AXK of {
          [] -> GHC.Types.False [];
          : y_s6AXM [Occ=Once] ys_s6AXN [Occ=Once] ->
              case y_s6AXM of {
                GHC.Types.False -> Data.Semigroup.Internal.$fMonoidAny_go ys_s6AXN;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

Data.Semigroup.Internal.$fSemigroupAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Classes.||
                                         Data.Semigroup.Internal.$fSemigroupAny_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupAny_$cstimes];
Data.Semigroup.Internal.$fMonoidAny [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid Data.Semigroup.Internal.Any
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupAny
                                      GHC.Types.False
                                      GHC.Classes.||
                                      Data.Semigroup.Internal.$fMonoidAny_go];
Data.Semigroup.Internal.$fSemigroupAny_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.Any -> Data.Semigroup.Internal.Any
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AXP eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6AXP Data.Semigroup.Internal.$fMonoidAny eta_B2 eta_B1;

Data.Semigroup.Internal.$fSemigroupAll_go [Occ=LoopBreaker]
  :: Data.Semigroup.Internal.All
     -> [Data.Semigroup.Internal.All] -> Data.Semigroup.Internal.All
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6AXQ ds1_s6AXR]
        case ds1_s6AXR of {
          [] -> b_s6AXQ;
          : c_s6AXT [Occ=Once] cs_s6AXU [Occ=Once] ->
              case b_s6AXQ of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True ->
                    Data.Semigroup.Internal.$fSemigroupAll_go c_s6AXT cs_s6AXU;
              };
        };

Data.Semigroup.Internal.$fSemigroupAll_$csconcat
  :: GHC.Base.NonEmpty Data.Semigroup.Internal.All
     -> Data.Semigroup.Internal.All
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6AXW]
        case ds_s6AXW of {
          GHC.Base.:| a1_s6AXY [Occ=Once] as_s6AXZ [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupAll_go a1_s6AXY as_s6AXZ;
        };

Data.Semigroup.Internal.$fMonoidAll_go [Occ=LoopBreaker]
  :: [Data.Semigroup.Internal.All] -> Data.Semigroup.Internal.All
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s6AY0]
        case ds_s6AY0 of {
          [] -> GHC.Types.True [];
          : y_s6AY2 [Occ=Once] ys_s6AY3 [Occ=Once] ->
              case y_s6AY2 of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> Data.Semigroup.Internal.$fMonoidAll_go ys_s6AY3;
              };
        };

Data.Semigroup.Internal.$fSemigroupAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Semigroup Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Classes.&&
                                         Data.Semigroup.Internal.$fSemigroupAll_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupAll_$cstimes];
Data.Semigroup.Internal.$fMonoidAll [InlPrag=NOUSERINLINE CONLIKE]
  :: GHC.Base.Monoid Data.Semigroup.Internal.All
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupAll
                                      GHC.Types.True
                                      GHC.Classes.&&
                                      Data.Semigroup.Internal.$fMonoidAll_go];
Data.Semigroup.Internal.$fSemigroupAll_$cstimes [Occ=LoopBreaker]
  :: forall b.
     GHC.Real.Integral b =>
     b -> Data.Semigroup.Internal.All -> Data.Semigroup.Internal.All
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(A,C(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AY5 eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesIdempotentMonoid
            $dIntegral_s6AY5 Data.Semigroup.Internal.$fMonoidAll eta_B2 eta_B1;

lvl5_r6v1b :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimesMonoid: negative multiplier"#;

lvl6_r6v1c :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl5_r6v1b of sat_s6AY6 {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6AY6;
        };

sat_s6AY7 :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s6AY8 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s6AY7 GHC.Types.[]];

lvl7_r6v1d :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s6AY8;

Data.Semigroup.Internal.stimesMonoid
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Monoid a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(LC(C(S))LLLLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(A,1*U,C(C1(U)),A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AY9 $dMonoid_s6AYa eta_s6AYb eta1_s6AYc]
        case
            GHC.Real.$p1Integral $dIntegral_s6AY9
        of
        $dReal_s6AYd [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),1*C1(C1(U)),A,A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6AYg [Occ=Once] :: b_a6szg
                [LclId] =
                    [$dReal_s6AYd] \u []
                        case GHC.Real.$p1Real $dReal_s6AYd of sat_s6AYf {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6AYf Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6AYd of sat_s6AYe {
                  __DEFAULT ->
                      case GHC.Classes.compare sat_s6AYe eta_s6AYb sat_s6AYg of {
                        GHC.Types.LT -> lvl6_r6v1c;
                        GHC.Types.EQ -> GHC.Base.mempty $dMonoid_s6AYa;
                        GHC.Types.GT ->
                            let {
                              $dNum_s6AYi [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a6szg
                              [LclId] =
                                  [$dReal_s6AYd] \u [] GHC.Real.$p1Real $dReal_s6AYd; } in
                            let {
                              lvl12_s6AYj :: b_a6szg
                              [LclId] =
                                  [$dNum_s6AYi] \u [] GHC.Num.fromInteger $dNum_s6AYi lvl7_r6v1d;
                            } in 
                              let-no-escape {
                                exit_s6AYk [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                  :: a_a6szh -> b_a6szg -> a_a6szh
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s6AY9
                                              $dMonoid_s6AYa
                                              $dReal_s6AYd
                                              $dNum_s6AYi
                                              lvl12_s6AYj] \r [x_s6AYl y_s6AYm]
                                        case
                                            GHC.Real.$p2Real $dReal_s6AYd
                                        of
                                        $dEq_s6AYn [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              case
                                                  GHC.Classes.$p1Ord $dEq_s6AYn
                                              of
                                              $dEq1_s6AYo [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      lvl13_s6AYp :: b_a6szg
                                                      [LclId] =
                                                          [$dNum_s6AYi] \u []
                                                              GHC.Num.fromInteger
                                                                  $dNum_s6AYi
                                                                  Data.Semigroup.Internal.$fMonoidProduct1;
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq1_s6AYo y_s6AYm lvl13_s6AYp
                                                      of
                                                      { GHC.Types.False ->
                                                            let {
                                                              sat_s6AYG [Occ=Once] :: b_a6szg
                                                              [LclId] =
                                                                  [$dIntegral_s6AY9
                                                                   lvl12_s6AYj
                                                                   y_s6AYm] \u []
                                                                      GHC.Real.quot
                                                                          $dIntegral_s6AY9
                                                                          y_s6AYm
                                                                          lvl12_s6AYj; } in
                                                            let {
                                                              sat_s6AYF [Occ=Once] :: a_a6szh
                                                              [LclId] =
                                                                  [$dMonoid_s6AYa x_s6AYl] \u []
                                                                      GHC.Base.mappend
                                                                          $dMonoid_s6AYa
                                                                          x_s6AYl
                                                                          x_s6AYl;
                                                            } in 
                                                              let-no-escape {
                                                                exit1_s6AYr [Occ=OnceL!T[2],
                                                                             Dmd=<C(C(S)),C(C1(U))>]
                                                                  :: a_a6szh -> a_a6szh -> a_a6szh
                                                                [LclId[JoinId(2)],
                                                                 Arity=2,
                                                                 Str=<L,U><L,U>,
                                                                 Unf=OtherCon []] =
                                                                    sat-only [$dMonoid_s6AYa] \r [x1_s6AYs
                                                                                                  z_s6AYt]
                                                                        GHC.Base.mappend
                                                                            $dMonoid_s6AYa
                                                                            x1_s6AYs
                                                                            z_s6AYt;
                                                              } in 
                                                                let-no-escape {
                                                                  g_s6AYu [Occ=LoopBreakerT[3]]
                                                                    :: a_a6szh
                                                                       -> b_a6szg
                                                                       -> a_a6szh
                                                                       -> a_a6szh
                                                                  [LclId[JoinId(3)],
                                                                   Arity=3,
                                                                   Str=<L,U><L,U><L,U>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [$dIntegral_s6AY9
                                                                                $dMonoid_s6AYa
                                                                                lvl12_s6AYj
                                                                                $dEq1_s6AYo
                                                                                lvl13_s6AYp
                                                                                exit1_s6AYr
                                                                                g_s6AYu] \r [x1_s6AYv
                                                                                             y1_s6AYw
                                                                                             z_s6AYx]
                                                                          case
                                                                              GHC.Real.even
                                                                                  $dIntegral_s6AY9
                                                                                  y1_s6AYw
                                                                          of
                                                                          { GHC.Types.False ->
                                                                                case
                                                                                    GHC.Classes.==
                                                                                        $dEq1_s6AYo
                                                                                        y1_s6AYw
                                                                                        lvl13_s6AYp
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s6AYC [Occ=Once]
                                                                                          :: a_a6szh
                                                                                        [LclId] =
                                                                                            [$dMonoid_s6AYa
                                                                                             x1_s6AYv
                                                                                             z_s6AYx] \u []
                                                                                                GHC.Base.mappend
                                                                                                    $dMonoid_s6AYa
                                                                                                    x1_s6AYv
                                                                                                    z_s6AYx; } in
                                                                                      let {
                                                                                        sat_s6AYB [Occ=Once]
                                                                                          :: b_a6szg
                                                                                        [LclId] =
                                                                                            [$dIntegral_s6AY9
                                                                                             lvl12_s6AYj
                                                                                             y1_s6AYw] \u []
                                                                                                GHC.Real.quot
                                                                                                    $dIntegral_s6AY9
                                                                                                    y1_s6AYw
                                                                                                    lvl12_s6AYj; } in
                                                                                      let {
                                                                                        sat_s6AYA [Occ=Once]
                                                                                          :: a_a6szh
                                                                                        [LclId] =
                                                                                            [$dMonoid_s6AYa
                                                                                             x1_s6AYv] \u []
                                                                                                GHC.Base.mappend
                                                                                                    $dMonoid_s6AYa
                                                                                                    x1_s6AYv
                                                                                                    x1_s6AYv;
                                                                                      } in 
                                                                                        g_s6AYu
                                                                                            sat_s6AYA
                                                                                            sat_s6AYB
                                                                                            sat_s6AYC;
                                                                                  GHC.Types.True ->
                                                                                      exit1_s6AYr
                                                                                          x1_s6AYv
                                                                                          z_s6AYx;
                                                                                };
                                                                            GHC.Types.True ->
                                                                                let {
                                                                                  sat_s6AYE [Occ=Once]
                                                                                    :: b_a6szg
                                                                                  [LclId] =
                                                                                      [$dIntegral_s6AY9
                                                                                       lvl12_s6AYj
                                                                                       y1_s6AYw] \u []
                                                                                          GHC.Real.quot
                                                                                              $dIntegral_s6AY9
                                                                                              y1_s6AYw
                                                                                              lvl12_s6AYj; } in
                                                                                let {
                                                                                  sat_s6AYD [Occ=Once]
                                                                                    :: a_a6szh
                                                                                  [LclId] =
                                                                                      [$dMonoid_s6AYa
                                                                                       x1_s6AYv] \u []
                                                                                          GHC.Base.mappend
                                                                                              $dMonoid_s6AYa
                                                                                              x1_s6AYv
                                                                                              x1_s6AYv;
                                                                                } in 
                                                                                  g_s6AYu
                                                                                      sat_s6AYD
                                                                                      sat_s6AYE
                                                                                      z_s6AYx;
                                                                          };
                                                                } in 
                                                                  g_s6AYu
                                                                      sat_s6AYF sat_s6AYG x_s6AYl;
                                                        GHC.Types.True -> x_s6AYl;
                                                      };
                                              };
                                        };
                              } in 
                                let-no-escape {
                                  f_s6AYH [Occ=LoopBreakerT[2]] :: a_a6szh -> b_a6szg -> a_a6szh
                                  [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dIntegral_s6AY9
                                                $dMonoid_s6AYa
                                                lvl12_s6AYj
                                                exit_s6AYk
                                                f_s6AYH] \r [x_s6AYI y_s6AYJ]
                                          case GHC.Real.even $dIntegral_s6AY9 y_s6AYJ of {
                                            GHC.Types.False -> exit_s6AYk x_s6AYI y_s6AYJ;
                                            GHC.Types.True ->
                                                let {
                                                  sat_s6AYM [Occ=Once] :: b_a6szg
                                                  [LclId] =
                                                      [$dIntegral_s6AY9 lvl12_s6AYj y_s6AYJ] \u []
                                                          GHC.Real.quot
                                                              $dIntegral_s6AY9
                                                              y_s6AYJ
                                                              lvl12_s6AYj; } in
                                                let {
                                                  sat_s6AYL [Occ=Once] :: a_a6szh
                                                  [LclId] =
                                                      [$dMonoid_s6AYa x_s6AYI] \u []
                                                          GHC.Base.mappend
                                                              $dMonoid_s6AYa x_s6AYI x_s6AYI;
                                                } in  f_s6AYH sat_s6AYL sat_s6AYM;
                                          };
                                } in  f_s6AYH eta1_s6AYc eta_s6AYb;
                      };
                };
        };

Data.Semigroup.Internal.$w$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     Data.Semigroup.Internal.Alt f a
     -> [Data.Semigroup.Internal.Alt f a]
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_s6AYN ww_s6AYO ww1_s6AYP]
        let {
          go_s6AYQ [Occ=LoopBreaker]
            :: Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL
               -> [Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL]
               -> Data.Semigroup.Internal.Alt f_s6uNK a_s6uNL
          [LclId, Arity=2, Str=<L,U><S,1*U>, Unf=OtherCon []] =
              sat-only [w_s6AYN go_s6AYQ] \r [b_s6AYR ds1_s6AYS]
                  case ds1_s6AYS of {
                    [] -> b_s6AYR;
                    : c_s6AYU [Occ=Once] cs_s6AYV [Occ=Once] ->
                        let {
                          sat_s6AYW [Occ=Once] :: f_s6uNK a_s6uNL
                          [LclId] =
                              [go_s6AYQ c_s6AYU cs_s6AYV] \u [] go_s6AYQ c_s6AYU cs_s6AYV;
                        } in  GHC.Base.<|> w_s6AYN b_s6AYR sat_s6AYW;
                  };
        } in  go_s6AYQ ww_s6AYO ww1_s6AYP;

Data.Semigroup.Internal.$fSemigroupAlt_$csconcat [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Alt f a)
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,A,C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_s6AYX w1_s6AYY]
        case w1_s6AYY of {
          GHC.Base.:| ww1_s6AZ0 [Occ=Once] ww2_s6AZ1 [Occ=Once] ->
              Data.Semigroup.Internal.$w$csconcat w_s6AYX ww1_s6AZ0 ww2_s6AZ1;
        };

Data.Semigroup.Internal.$fMonoidAlt_$cmconcat
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     [Data.Semigroup.Internal.Alt f a]
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(A,1*U,C(C1(U)),A,A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6AZ2 eta_s6AZ3]
        let {
          z_s6AZ4 [Occ=OnceL] :: f_X6tGf a_X6tGh
          [LclId] =
              [$dAlternative_s6AZ2] \u []
                  GHC.Base.empty $dAlternative_s6AZ2; } in
        let {
          go_s6AZ5 [Occ=LoopBreaker]
            :: [Data.Semigroup.Internal.Alt f_X6tGf a_X6tGh]
               -> Data.Semigroup.Internal.Alt f_X6tGf a_X6tGh
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dAlternative_s6AZ2 z_s6AZ4 go_s6AZ5] \r [ds_s6AZ6]
                  case ds_s6AZ6 of {
                    [] -> z_s6AZ4;
                    : y_s6AZ8 [Occ=Once] ys_s6AZ9 [Occ=Once] ->
                        let {
                          sat_s6AZa [Occ=Once] :: f_X6tGf a_X6tGh
                          [LclId] =
                              [go_s6AZ5 ys_s6AZ9] \u [] go_s6AZ5 ys_s6AZ9;
                        } in  GHC.Base.<|> $dAlternative_s6AZ2 y_s6AZ8 sat_s6AZa;
                  };
        } in  go_s6AZ5 eta_s6AZ3;

Data.Semigroup.Internal.$fSemigroupAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.Semigroup (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A,A)>m] =
    [] \r [$dAlternative_s6AZb]
        let {
          sat_s6AZe [Occ=Once]
            :: forall b.
               GHC.Real.Integral b =>
               b
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6AZb] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupAlt_$cstimes
                      $dAlternative_s6AZb eta_B1; } in
        let {
          sat_s6AZd [Occ=Once]
            :: GHC.Base.NonEmpty (Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF)
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6AZb] \r [eta_B1]
                  Data.Semigroup.Internal.$fSemigroupAlt_$csconcat
                      $dAlternative_s6AZb eta_B1; } in
        let {
          sat_s6AZc [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
               -> Data.Semigroup.Internal.Alt f_X6tGD a_X6tGF
          [LclId] =
              [$dAlternative_s6AZb] \u [] GHC.Base.<|> $dAlternative_s6AZb;
        } in  GHC.Base.C:Semigroup [sat_s6AZc sat_s6AZd sat_s6AZe];
Data.Semigroup.Internal.$fMonoidAlt [InlPrag=NOUSERINLINE CONLIKE]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     GHC.Base.Monoid (Data.Semigroup.Internal.Alt f a)
[GblId[DFunId], Arity=1, Str=<L,U(A,U,U,A,A)>m] =
    [] \r [$dAlternative_s6AZf]
        let {
          sat_s6AZj [Occ=Once]
            :: [Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9]
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6AZf] \r [eta_B1]
                  Data.Semigroup.Internal.$fMonoidAlt_$cmconcat
                      $dAlternative_s6AZf eta_B1; } in
        let {
          sat_s6AZi [Occ=Once]
            :: Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
               -> Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6AZf] \u [] GHC.Base.<|> $dAlternative_s6AZf; } in
        let {
          sat_s6AZh [Occ=Once] :: Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9
          [LclId] =
              [$dAlternative_s6AZf] \u []
                  GHC.Base.empty $dAlternative_s6AZf; } in
        let {
          sat_s6AZg [Occ=Once]
            :: GHC.Base.Semigroup (Data.Semigroup.Internal.Alt f_X6tG7 a_X6tG9)
          [LclId] =
              [$dAlternative_s6AZf] \u []
                  Data.Semigroup.Internal.$fSemigroupAlt $dAlternative_s6AZf;
        } in  GHC.Base.C:Monoid [sat_s6AZg sat_s6AZh sat_s6AZi sat_s6AZj];
Data.Semigroup.Internal.$fSemigroupAlt_$cstimes [Occ=LoopBreaker]
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     forall b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.Internal.Alt f a
     -> Data.Semigroup.Internal.Alt f a
[GblId,
 Arity=2,
 Str=<L,U(A,U,U,A,A)><L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_s6AZk $dIntegral_s6AZl]
        let {
          sat_s6AZm [Occ=Once]
            :: GHC.Base.Monoid (Data.Semigroup.Internal.Alt f_X6tGK a_X6tGM)
          [LclId] =
              [$dAlternative_s6AZk] \u []
                  Data.Semigroup.Internal.$fMonoidAlt $dAlternative_s6AZk;
        } in 
          Data.Semigroup.Internal.stimesMonoid $dIntegral_s6AZl sat_s6AZm;

Data.Semigroup.Internal.$fSemigroupEndo1 [Occ=LoopBreaker]
  :: forall a.
     Data.Semigroup.Internal.Endo a
     -> [Data.Semigroup.Internal.Endo a]
     -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [b_s6AZn ds1_s6AZo]
        case ds1_s6AZo of {
          [] -> b_s6AZn;
          : c_s6AZq [Occ=Once] cs_s6AZr [Occ=Once] ->
              let {
                g_s6AZs [Occ=OnceL, Dmd=<L,C(U)>]
                  :: Data.Semigroup.Internal.Endo a_a6tyX
                [LclId] =
                    [c_s6AZq cs_s6AZr] \u []
                        Data.Semigroup.Internal.$fSemigroupEndo1 c_s6AZq cs_s6AZr; } in
              let {
                sat_s6AZv [Occ=Once] :: a_a6tyX -> a_a6tyX
                [LclId] =
                    [b_s6AZn g_s6AZs] \r [x_s6AZt]
                        let {
                          sat_s6AZu [Occ=Once] :: a_a6tyX
                          [LclId] =
                              [g_s6AZs x_s6AZt] \u [] g_s6AZs x_s6AZt;
                        } in  b_s6AZn sat_s6AZu;
              } in  sat_s6AZv;
        };

Data.Semigroup.Internal.$fSemigroupEndo_$csconcat
  :: forall a.
     GHC.Base.NonEmpty (Data.Semigroup.Internal.Endo a)
     -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_s6AZw]
        case ds_s6AZw of {
          GHC.Base.:| a1_s6AZy [Occ=Once] as_s6AZz [Occ=Once] ->
              Data.Semigroup.Internal.$fSemigroupEndo1 a1_s6AZy as_s6AZz;
        };

Data.Semigroup.Internal.$fMonoidEndo1 [Occ=LoopBreaker]
  :: forall a. [Data.Semigroup.Internal.Endo a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_s6AZA eta_s6AZB]
        case ds_s6AZA of {
          [] -> eta_s6AZB;
          : y_s6AZD [Occ=Once] ys_s6AZE [Occ=Once] ->
              let {
                sat_s6AZF [Occ=Once] :: a_a6tyy
                [LclId] =
                    [eta_s6AZB ys_s6AZE] \u []
                        Data.Semigroup.Internal.$fMonoidEndo1 ys_s6AZE eta_s6AZB;
              } in  y_s6AZD sat_s6AZF;
        };

Data.Semigroup.Internal.$fSemigroupEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Semigroup (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Semigroup! [GHC.Base..
                                         Data.Semigroup.Internal.$fSemigroupEndo_$csconcat
                                         Data.Semigroup.Internal.$fSemigroupEndo_$cstimes];
Data.Semigroup.Internal.$fMonoidEndo [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. GHC.Base.Monoid (Data.Semigroup.Internal.Endo a)
[GblId[DFunId], Str=m] =
    CCS_DONT_CARE GHC.Base.C:Monoid! [Data.Semigroup.Internal.$fSemigroupEndo
                                      GHC.Base.id
                                      GHC.Base..
                                      Data.Semigroup.Internal.$fMonoidEndo1];
Data.Semigroup.Internal.$fSemigroupEndo_$cstimes [Occ=LoopBreaker]
  :: forall a b.
     GHC.Real.Integral b =>
     b
     -> Data.Semigroup.Internal.Endo a -> Data.Semigroup.Internal.Endo a
[GblId,
 Arity=3,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AZG eta_B2 eta_B1]
        Data.Semigroup.Internal.stimesMonoid
            $dIntegral_s6AZG
            Data.Semigroup.Internal.$fMonoidEndo
            eta_B2
            eta_B1;

lvl8_r6v1e :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: positive multiplier expected"#;

lvl9_r6v1f :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl8_r6v1e of sat_s6AZH {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6AZH;
        };

Data.Semigroup.Internal.stimesDefault
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Semigroup a) =>
     b -> a -> a
[GblId,
 Arity=4,
 Str=<S(S(LS(S(C(C(S))L)LLC(C(S))LLLL)L)LLLLLLLL),U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(C(C1(U)),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6AZI $dSemigroup_s6AZJ eta_s6AZK eta1_s6AZL]
        case
            GHC.Real.$p1Integral $dIntegral_s6AZI
        of
        $dReal_s6AZM [Dmd=<S(LS(S(C(C(S))L)LLC(C(S))LLLL)L),U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s6AZP [Occ=Once] :: b_a6swD
                [LclId] =
                    [$dReal_s6AZM] \u []
                        case GHC.Real.$p1Real $dReal_s6AZM of sat_s6AZO {
                          __DEFAULT ->
                              GHC.Num.fromInteger sat_s6AZO Data.Semigroup.Internal.$fMonoidSum1;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s6AZM of sat_s6AZN {
                  __DEFAULT ->
                      case GHC.Classes.<= sat_s6AZN eta_s6AZK sat_s6AZP of {
                        GHC.Types.False ->
                            let {
                              $dNum_s6AZR [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num b_a6swD
                              [LclId] =
                                  [$dReal_s6AZM] \u [] GHC.Real.$p1Real $dReal_s6AZM; } in
                            let {
                              lvl12_s6AZS :: b_a6swD
                              [LclId] =
                                  [$dNum_s6AZR] \u [] GHC.Num.fromInteger $dNum_s6AZR lvl7_r6v1d;
                            } in 
                              let-no-escape {
                                exit_s6AZT [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                  :: a_a6swE -> b_a6swD -> a_a6swE
                                [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                    sat-only [$dIntegral_s6AZI
                                              $dSemigroup_s6AZJ
                                              $dReal_s6AZM
                                              $dNum_s6AZR
                                              lvl12_s6AZS] \r [x_s6AZU y_s6AZV]
                                        case
                                            GHC.Real.$p2Real $dReal_s6AZM
                                        of
                                        $dEq_s6AZW [Dmd=<S(S(C(C(S))L)LLLLLLL),1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>]
                                        { __DEFAULT ->
                                              case
                                                  GHC.Classes.$p1Ord $dEq_s6AZW
                                              of
                                              $dEq1_s6AZX [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let {
                                                      lvl13_s6AZY :: b_a6swD
                                                      [LclId] =
                                                          [$dNum_s6AZR] \u []
                                                              GHC.Num.fromInteger
                                                                  $dNum_s6AZR
                                                                  Data.Semigroup.Internal.$fMonoidProduct1;
                                                    } in 
                                                      case
                                                          GHC.Classes.==
                                                              $dEq1_s6AZX y_s6AZV lvl13_s6AZY
                                                      of
                                                      { GHC.Types.False ->
                                                            let {
                                                              sat_s6B0f [Occ=Once] :: b_a6swD
                                                              [LclId] =
                                                                  [$dIntegral_s6AZI
                                                                   lvl12_s6AZS
                                                                   y_s6AZV] \u []
                                                                      GHC.Real.quot
                                                                          $dIntegral_s6AZI
                                                                          y_s6AZV
                                                                          lvl12_s6AZS; } in
                                                            let {
                                                              sat_s6B0e [Occ=Once] :: a_a6swE
                                                              [LclId] =
                                                                  [$dSemigroup_s6AZJ x_s6AZU] \u []
                                                                      GHC.Base.<>
                                                                          $dSemigroup_s6AZJ
                                                                          x_s6AZU
                                                                          x_s6AZU;
                                                            } in 
                                                              let-no-escape {
                                                                exit1_s6B00 [Occ=OnceL!T[2],
                                                                             Dmd=<C(C(S)),C(C1(U))>]
                                                                  :: a_a6swE -> a_a6swE -> a_a6swE
                                                                [LclId[JoinId(2)],
                                                                 Arity=2,
                                                                 Str=<L,U><L,U>,
                                                                 Unf=OtherCon []] =
                                                                    sat-only [$dSemigroup_s6AZJ] \r [x1_s6B01
                                                                                                     z_s6B02]
                                                                        GHC.Base.<>
                                                                            $dSemigroup_s6AZJ
                                                                            x1_s6B01
                                                                            z_s6B02;
                                                              } in 
                                                                let-no-escape {
                                                                  g_s6B03 [Occ=LoopBreakerT[3]]
                                                                    :: a_a6swE
                                                                       -> b_a6swD
                                                                       -> a_a6swE
                                                                       -> a_a6swE
                                                                  [LclId[JoinId(3)],
                                                                   Arity=3,
                                                                   Str=<L,U><L,U><L,U>,
                                                                   Unf=OtherCon []] =
                                                                      sat-only [$dIntegral_s6AZI
                                                                                $dSemigroup_s6AZJ
                                                                                lvl12_s6AZS
                                                                                $dEq1_s6AZX
                                                                                lvl13_s6AZY
                                                                                exit1_s6B00
                                                                                g_s6B03] \r [x1_s6B04
                                                                                             y1_s6B05
                                                                                             z_s6B06]
                                                                          case
                                                                              GHC.Real.even
                                                                                  $dIntegral_s6AZI
                                                                                  y1_s6B05
                                                                          of
                                                                          { GHC.Types.False ->
                                                                                case
                                                                                    GHC.Classes.==
                                                                                        $dEq1_s6AZX
                                                                                        y1_s6B05
                                                                                        lvl13_s6AZY
                                                                                of
                                                                                { GHC.Types.False ->
                                                                                      let {
                                                                                        sat_s6B0b [Occ=Once]
                                                                                          :: a_a6swE
                                                                                        [LclId] =
                                                                                            [$dSemigroup_s6AZJ
                                                                                             x1_s6B04
                                                                                             z_s6B06] \u []
                                                                                                GHC.Base.<>
                                                                                                    $dSemigroup_s6AZJ
                                                                                                    x1_s6B04
                                                                                                    z_s6B06; } in
                                                                                      let {
                                                                                        sat_s6B0a [Occ=Once]
                                                                                          :: b_a6swD
                                                                                        [LclId] =
                                                                                            [$dIntegral_s6AZI
                                                                                             lvl12_s6AZS
                                                                                             y1_s6B05] \u []
                                                                                                GHC.Real.quot
                                                                                                    $dIntegral_s6AZI
                                                                                                    y1_s6B05
                                                                                                    lvl12_s6AZS; } in
                                                                                      let {
                                                                                        sat_s6B09 [Occ=Once]
                                                                                          :: a_a6swE
                                                                                        [LclId] =
                                                                                            [$dSemigroup_s6AZJ
                                                                                             x1_s6B04] \u []
                                                                                                GHC.Base.<>
                                                                                                    $dSemigroup_s6AZJ
                                                                                                    x1_s6B04
                                                                                                    x1_s6B04;
                                                                                      } in 
                                                                                        g_s6B03
                                                                                            sat_s6B09
                                                                                            sat_s6B0a
                                                                                            sat_s6B0b;
                                                                                  GHC.Types.True ->
                                                                                      exit1_s6B00
                                                                                          x1_s6B04
                                                                                          z_s6B06;
                                                                                };
                                                                            GHC.Types.True ->
                                                                                let {
                                                                                  sat_s6B0d [Occ=Once]
                                                                                    :: b_a6swD
                                                                                  [LclId] =
                                                                                      [$dIntegral_s6AZI
                                                                                       lvl12_s6AZS
                                                                                       y1_s6B05] \u []
                                                                                          GHC.Real.quot
                                                                                              $dIntegral_s6AZI
                                                                                              y1_s6B05
                                                                                              lvl12_s6AZS; } in
                                                                                let {
                                                                                  sat_s6B0c [Occ=Once]
                                                                                    :: a_a6swE
                                                                                  [LclId] =
                                                                                      [$dSemigroup_s6AZJ
                                                                                       x1_s6B04] \u []
                                                                                          GHC.Base.<>
                                                                                              $dSemigroup_s6AZJ
                                                                                              x1_s6B04
                                                                                              x1_s6B04;
                                                                                } in 
                                                                                  g_s6B03
                                                                                      sat_s6B0c
                                                                                      sat_s6B0d
                                                                                      z_s6B06;
                                                                          };
                                                                } in 
                                                                  g_s6B03
                                                                      sat_s6B0e sat_s6B0f x_s6AZU;
                                                        GHC.Types.True -> x_s6AZU;
                                                      };
                                              };
                                        };
                              } in 
                                let-no-escape {
                                  f_s6B0g [Occ=LoopBreakerT[2]] :: a_a6swE -> b_a6swD -> a_a6swE
                                  [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                      sat-only [$dIntegral_s6AZI
                                                $dSemigroup_s6AZJ
                                                lvl12_s6AZS
                                                exit_s6AZT
                                                f_s6B0g] \r [x_s6B0h y_s6B0i]
                                          case GHC.Real.even $dIntegral_s6AZI y_s6B0i of {
                                            GHC.Types.False -> exit_s6AZT x_s6B0h y_s6B0i;
                                            GHC.Types.True ->
                                                let {
                                                  sat_s6B0l [Occ=Once] :: b_a6swD
                                                  [LclId] =
                                                      [$dIntegral_s6AZI lvl12_s6AZS y_s6B0i] \u []
                                                          GHC.Real.quot
                                                              $dIntegral_s6AZI
                                                              y_s6B0i
                                                              lvl12_s6AZS; } in
                                                let {
                                                  sat_s6B0k [Occ=Once] :: a_a6swE
                                                  [LclId] =
                                                      [$dSemigroup_s6AZJ x_s6B0h] \u []
                                                          GHC.Base.<>
                                                              $dSemigroup_s6AZJ x_s6B0h x_s6B0h;
                                                } in  f_s6B0g sat_s6B0k sat_s6B0l;
                                          };
                                } in  f_s6B0g eta1_s6AZL eta_s6AZK;
                        GHC.Types.True -> lvl9_r6v1f;
                      };
                };
        };

lvl10_r6v1g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: Maybe, negative multiplier"#;

Data.Semigroup.Internal.stimesMaybe1 :: forall a. GHC.Base.Maybe a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl10_r6v1g of sat_s6B0m {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6B0m;
        };

Data.Semigroup.Internal.stimesMaybe
  :: forall b a.
     (GHC.Real.Integral b, GHC.Base.Semigroup a) =>
     b -> GHC.Base.Maybe a -> GHC.Base.Maybe a
[GblId,
 Arity=4,
 Str=<L,U(U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U,U),U),U,U,U,U,U,U,U,U)><L,1*U(A,A,1*C1(C1(C1(U))))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6B0n $dSemigroup_s6B0o eta_s6B0p eta1_s6B0q]
        case eta1_s6B0q of {
          GHC.Base.Nothing -> GHC.Base.Nothing [];
          GHC.Base.Just a1_s6B0s [Occ=Once] ->
              case
                  GHC.Real.$p1Integral $dIntegral_s6B0n
              of
              $dReal_s6B0t [Dmd=<S(LS(LC(C(S))LLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_s6B0w [Occ=Once] :: b_a6swh
                      [LclId] =
                          [$dReal_s6B0t] \u []
                              case GHC.Real.$p1Real $dReal_s6B0t of sat_s6B0v {
                                __DEFAULT ->
                                    GHC.Num.fromInteger
                                        sat_s6B0v Data.Semigroup.Internal.$fMonoidSum1;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_s6B0t of sat_s6B0u {
                        __DEFAULT ->
                            case GHC.Classes.compare sat_s6B0u eta_s6B0p sat_s6B0w of {
                              GHC.Types.LT -> Data.Semigroup.Internal.stimesMaybe1;
                              GHC.Types.EQ -> GHC.Base.Nothing [];
                              GHC.Types.GT ->
                                  let {
                                    sat_s6B0y [Occ=Once] :: a_a6swi
                                    [LclId] =
                                        [$dIntegral_s6B0n
                                         $dSemigroup_s6B0o
                                         eta_s6B0p
                                         a1_s6B0s] \u []
                                            GHC.Base.stimes
                                                $dSemigroup_s6B0o
                                                $dIntegral_s6B0n
                                                eta_s6B0p
                                                a1_s6B0s;
                                  } in  GHC.Base.Just [sat_s6B0y];
                            };
                      };
              };
        };

lvl11_r6v1h :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "stimes: [], negative multiplier"#;

Data.Semigroup.Internal.stimesList1 :: forall a. [a]
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl11_r6v1h of sat_s6B0z {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s6B0z;
        };

Data.Semigroup.Internal.stimesList
  :: forall b a. GHC.Real.Integral b => b -> [a] -> [a]
[GblId,
 Arity=3,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))LLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,C(C1(U)),A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s6B0A eta_s6B0B eta1_s6B0C]
        case
            GHC.Real.$p1Integral $dIntegral_s6B0A
        of
        $dReal_s6B0D [Dmd=<S(LS(S(C(C(S))L)LC(C(S))LLLLL)L),U(1*U(A,C(C1(U)),A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s6B0E [Dmd=<L,U(A,C(C1(U)),A,A,A,A,C(U))>]
                  :: GHC.Num.Num b_a6svr
                [LclId] =
                    [$dReal_s6B0D] \u [] GHC.Real.$p1Real $dReal_s6B0D;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s6B0D
                of
                $dOrd_s6B0F [Dmd=<S(S(C(C(S))L)LC(C(S))LLLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s6B0G [Occ=Once] :: b_a6svr
                        [LclId] =
                            [$dNum_s6B0E] \u []
                                GHC.Num.fromInteger
                                    $dNum_s6B0E Data.Semigroup.Internal.$fMonoidSum1;
                      } in 
                        case GHC.Classes.< $dOrd_s6B0F eta_s6B0B sat_s6B0G of {
                          GHC.Types.False ->
                              let {
                                lvl12_s6B0I [Occ=OnceL] :: b_a6svr
                                [LclId] =
                                    [$dNum_s6B0E] \u []
                                        GHC.Num.fromInteger
                                            $dNum_s6B0E
                                            Data.Semigroup.Internal.$fMonoidProduct1; } in
                              let {
                                lvl13_s6B0J [Occ=OnceL] :: b_a6svr
                                [LclId] =
                                    [$dNum_s6B0E] \u []
                                        GHC.Num.fromInteger
                                            $dNum_s6B0E Data.Semigroup.Internal.$fMonoidSum1;
                              } in 
                                case
                                    GHC.Classes.$p1Ord $dOrd_s6B0F
                                of
                                $dEq_s6B0K [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                { __DEFAULT ->
                                      let {
                                        rep_s6B0L [Occ=LoopBreaker] :: b_a6svr -> [a_a6svs]
                                        [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                            sat-only [eta1_s6B0C
                                                      $dNum_s6B0E
                                                      lvl12_s6B0I
                                                      lvl13_s6B0J
                                                      $dEq_s6B0K
                                                      rep_s6B0L] \r [ds_s6B0M]
                                                case
                                                    GHC.Classes.== $dEq_s6B0K ds_s6B0M lvl13_s6B0J
                                                of
                                                { GHC.Types.False ->
                                                      let {
                                                        sat_s6B0P [Occ=Once, Dmd=<L,1*U>]
                                                          :: [a_a6svs]
                                                        [LclId] =
                                                            [$dNum_s6B0E
                                                             lvl12_s6B0I
                                                             rep_s6B0L
                                                             ds_s6B0M] \s []
                                                                let {
                                                                  sat_s6B0O [Occ=Once] :: b_a6svr
                                                                  [LclId] =
                                                                      [$dNum_s6B0E
                                                                       lvl12_s6B0I
                                                                       ds_s6B0M] \u []
                                                                          GHC.Num.-
                                                                              $dNum_s6B0E
                                                                              ds_s6B0M
                                                                              lvl12_s6B0I;
                                                                } in  rep_s6B0L sat_s6B0O;
                                                      } in  GHC.Base.++ eta1_s6B0C sat_s6B0P;
                                                  GHC.Types.True -> [] [];
                                                };
                                      } in  rep_s6B0L eta_s6B0B;
                                };
                          GHC.Types.True -> Data.Semigroup.Internal.stimesList1;
                        };
                };
        };

Data.Semigroup.Internal.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.Semigroup.Internal.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$trModule4];

Data.Semigroup.Internal.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.Semigroup.Internal"#;

Data.Semigroup.Internal.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$trModule2];

Data.Semigroup.Internal.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.Semigroup.Internal.$trModule3
                                     Data.Semigroup.Internal.$trModule1];

$krep_r6v1i :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcBool
                                              GHC.Types.[]];

$krep1_r6v1j :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [0#];

$krep2_r6v1k :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep1_r6v1j];

$krep3_r6v1l :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j
                                         GHC.Types.krep$*];

Data.Semigroup.Internal.$tcAlt1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep3_r6v1l $krep3_r6v1l];

$krep4_r6v1m :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [1#];

$krep5_r6v1n :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepVar! [2#];

$krep6_r6v1o :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m3, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepApp! [$krep4_r6v1m $krep5_r6v1n];

Data.Semigroup.Internal.$tcDual1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadDual5];

Data.Semigroup.Internal.$tcDual :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14711416616195557841##
                                    10971851269997195248##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcDual1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep7_r6v1p :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r6v1j GHC.Types.[]];

$krep8_r6v1q :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcDual
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Dual1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep8_r6v1q];

Data.Semigroup.Internal.$tc'Dual3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Dual"#;

Data.Semigroup.Internal.$tc'Dual2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Dual3];

Data.Semigroup.Internal.$tc'Dual :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [15885009659242865261##
                                    15931193389986079612##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Dual2
                                    1#
                                    Data.Semigroup.Internal.$tc'Dual1];

Data.Semigroup.Internal.$tcEndo2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Endo"#;

Data.Semigroup.Internal.$tcEndo1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tcEndo2];

Data.Semigroup.Internal.$tcEndo :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16820921632006328603##
                                    4981834339379479823##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcEndo1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep9_r6v1r :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcEndo
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Endo1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep2_r6v1k $krep9_r6v1r];

Data.Semigroup.Internal.$tc'Endo3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Endo"#;

Data.Semigroup.Internal.$tc'Endo2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Endo3];

Data.Semigroup.Internal.$tc'Endo :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [156297185665537802##
                                    8988325904501215692##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Endo2
                                    1#
                                    Data.Semigroup.Internal.$tc'Endo1];

Data.Semigroup.Internal.$tcAll1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAll13];

Data.Semigroup.Internal.$tcAll :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [14149274874874504208##
                                    8164254778609961234##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAll1
                                    0#
                                    GHC.Types.krep$*];

$krep10_r6v1s :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAll
                                              GHC.Types.[]];

Data.Semigroup.Internal.$tc'All1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r6v1i $krep10_r6v1s];

Data.Semigroup.Internal.$tc'All3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'All"#;

Data.Semigroup.Internal.$tc'All2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'All3];

Data.Semigroup.Internal.$tc'All :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1168494541548489787##
                                    10689931498683547374##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'All2
                                    0#
                                    Data.Semigroup.Internal.$tc'All1];

Data.Semigroup.Internal.$tcAny1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAny6];

Data.Semigroup.Internal.$tcAny :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [11600287624241135668##
                                    17600231731807245316##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAny1
                                    0#
                                    GHC.Types.krep$*];

$krep11_r6v1t :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAny
                                              GHC.Types.[]];

Data.Semigroup.Internal.$tc'Any1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep_r6v1i $krep11_r6v1t];

Data.Semigroup.Internal.$tc'Any3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Any"#;

Data.Semigroup.Internal.$tc'Any2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Any3];

Data.Semigroup.Internal.$tc'Any :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [16164188984560189013##
                                    110490866064676064##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Any2
                                    0#
                                    Data.Semigroup.Internal.$tc'Any1];

Data.Semigroup.Internal.$tcSum1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadSum5];

Data.Semigroup.Internal.$tcSum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7521450980204740829##
                                    14029043805042477297##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcSum1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep12_r6v1u :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcSum
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Sum1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep12_r6v1u];

Data.Semigroup.Internal.$tc'Sum3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Sum"#;

Data.Semigroup.Internal.$tc'Sum2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Sum3];

Data.Semigroup.Internal.$tc'Sum :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7144872330799658717##
                                    13465414667749873698##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Sum2
                                    1#
                                    Data.Semigroup.Internal.$tc'Sum1];

Data.Semigroup.Internal.$tcProduct1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadProduct5];

Data.Semigroup.Internal.$tcProduct :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [12271745360620305859##
                                    5747185732973757022##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcProduct1
                                    0#
                                    GHC.Types.krep$*Arr*];

$krep13_r6v1v :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcProduct
                                              $krep7_r6v1p];

Data.Semigroup.Internal.$tc'Product1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep1_r6v1j $krep13_r6v1v];

Data.Semigroup.Internal.$tc'Product3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Product"#;

Data.Semigroup.Internal.$tc'Product2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Product3];

Data.Semigroup.Internal.$tc'Product :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [3191278115598904989##
                                    12638872580785847167##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Product2
                                    1#
                                    Data.Semigroup.Internal.$tc'Product1];

Data.Semigroup.Internal.$tcAlt2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$fReadAlt5];

Data.Semigroup.Internal.$tcAlt :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [7601313288863504805##
                                    2369500163797891218##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tcAlt2
                                    1#
                                    Data.Semigroup.Internal.$tcAlt1];

$krep14_r6v1w :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep5_r6v1n GHC.Types.[]];

$krep15_r6v1x :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep4_r6v1m $krep14_r6v1w];

$krep16_r6v1y :: [GHC.Types.KindRep]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [$krep1_r6v1j $krep15_r6v1x];

$krep17_r6v1z :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [Data.Semigroup.Internal.$tcAlt
                                              $krep16_r6v1y];

Data.Semigroup.Internal.$tc'Alt1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [$krep6_r6v1o $krep17_r6v1z];

Data.Semigroup.Internal.$tc'Alt3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "'Alt"#;

Data.Semigroup.Internal.$tc'Alt2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.Semigroup.Internal.$tc'Alt3];

Data.Semigroup.Internal.$tc'Alt :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [1436877498177162483##
                                    16937142347825669760##
                                    Data.Semigroup.Internal.$trModule
                                    Data.Semigroup.Internal.$tc'Alt2
                                    3#
                                    Data.Semigroup.Internal.$tc'Alt1];

