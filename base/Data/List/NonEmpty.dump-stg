
==================== Pre unarise: ====================
2018-03-16 16:08:35.217317621 UTC

Data.List.NonEmpty.nonEmpty
  :: forall a. [a] -> GHC.Base.Maybe (GHC.Base.NonEmpty a)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sdpww]
        case ds_sdpww of {
          [] -> GHC.Base.Nothing [];
          : a1_sdpwy [Occ=Once] as_sdpwz [Occ=Once] ->
              let {
                sat_sdpwA [Occ=Once] :: GHC.Base.NonEmpty a_adod9
                [LclId] =
                    CCCS GHC.Base.:|! [a1_sdpwy as_sdpwz];
              } in  GHC.Base.Just [sat_sdpwA];
        };

Data.List.NonEmpty.uncons
  :: forall a.
     GHC.Base.NonEmpty a -> (a, GHC.Base.Maybe (GHC.Base.NonEmpty a))
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdpwB]
        let {
          sat_sdpwN [Occ=Once] :: GHC.Base.Maybe (GHC.Base.NonEmpty a_adode)
          [LclId] =
              [ds_sdpwB] \u []
                  case ds_sdpwB of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpwI [Occ=Once!] ->
                        case as_sdpwI of {
                          [] -> GHC.Base.Nothing [];
                          : a2_sdpwK [Occ=Once] as1_sdpwL [Occ=Once] ->
                              let {
                                sat_sdpwM [Occ=Once] :: GHC.Base.NonEmpty a_adode
                                [LclId] =
                                    CCCS GHC.Base.:|! [a2_sdpwK as1_sdpwL];
                              } in  GHC.Base.Just [sat_sdpwM];
                        };
                  }; } in
        let {
          sat_sdpwF [Occ=Once] :: a_adode
          [LclId] =
              [ds_sdpwB] \u []
                  case ds_sdpwB of {
                    GHC.Base.:| a1_sdpwD [Occ=Once] _ [Occ=Dead] -> a1_sdpwD;
                  };
        } in  (,) [sat_sdpwF sat_sdpwN];

Data.List.NonEmpty.$wunfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> (b, GHC.Base.Maybe a)) -> a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,1*U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdpwO w1_sdpwP]
        case w_sdpwO w1_sdpwP of {
          (,) b1_sdpwR [Occ=Once] mc_sdpwS [Occ=Once!] ->
              let {
                sat_sdpx3 [Occ=Once] :: [b_sdp0I]
                [LclId] =
                    [w_sdpwO mc_sdpwS] \u []
                        case mc_sdpwS of {
                          GHC.Base.Nothing -> [] [];
                          GHC.Base.Just x_sdpwU [Occ=Once] ->
                              let {
                                go_sdpwV [Occ=LoopBreaker] :: a_sdp0H -> [b_sdp0I]
                                [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                    sat-only [w_sdpwO go_sdpwV] \r [c_sdpwW]
                                        case w_sdpwO c_sdpwW of {
                                          (,) d_sdpwY [Occ=Once] me_sdpwZ [Occ=Once!] ->
                                              let {
                                                sat_sdpx2 [Occ=Once] :: [b_sdp0I]
                                                [LclId] =
                                                    [go_sdpwV me_sdpwZ] \u []
                                                        case me_sdpwZ of {
                                                          GHC.Base.Nothing -> [] [];
                                                          GHC.Base.Just x1_sdpx1 [Occ=Once] ->
                                                              go_sdpwV x1_sdpx1;
                                                        };
                                              } in  : [d_sdpwY sat_sdpx2];
                                        };
                              } in  go_sdpwV x_sdpwU;
                        };
              } in  (#,#) [b1_sdpwR sat_sdpx3];
        };

Data.List.NonEmpty.unfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> (b, GHC.Base.Maybe a)) -> a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdpx4 w1_sdpx5]
        case Data.List.NonEmpty.$wunfoldr w_sdpx4 w1_sdpx5 of {
          (#,#) ww1_sdpx7 [Occ=Once] ww2_sdpx8 [Occ=Once] ->
              GHC.Base.:| [ww1_sdpx7 ww2_sdpx8];
        };

Data.List.NonEmpty.head :: forall a. GHC.Base.NonEmpty a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sdpx9]
        case ds_sdpx9 of {
          GHC.Base.:| a1_sdpxb [Occ=Once] _ [Occ=Dead] -> a1_sdpxb;
        };

Data.List.NonEmpty.tail :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sdpxd]
        case ds_sdpxd of {
          GHC.Base.:| _ [Occ=Dead] as_sdpxg [Occ=Once] -> as_sdpxg;
        };

poly_go_rdpws :: forall a. [a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ds_sdpxh eta_sdpxi]
        case ds_sdpxh of {
          [] -> eta_sdpxi;
          : y_sdpxk [Occ=Once] ys_sdpxl [Occ=Once] ->
              poly_go_rdpws ys_sdpxl y_sdpxk;
        };

Data.List.NonEmpty.last :: forall a. GHC.Base.NonEmpty a -> a
[GblId, Arity=1, Str=<L,U(1*U,1*U)>, Unf=OtherCon []] =
    [] \r [ds_sdpxm]
        let {
          sat_sdpxu [Occ=Once] :: [a_adocF]
          [LclId] =
              [ds_sdpxm] \u []
                  case ds_sdpxm of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpxt [Occ=Once] -> as_sdpxt;
                  }; } in
        let {
          sat_sdpxq [Occ=Once] :: a_adocF
          [LclId] =
              [ds_sdpxm] \u []
                  case ds_sdpxm of {
                    GHC.Base.:| a1_sdpxo [Occ=Once] _ [Occ=Dead] -> a1_sdpxo;
                  }; } in
        let {
          sat_sdpxv [Occ=Once] :: [a_adocF]
          [LclId] =
              CCCS :! [sat_sdpxq sat_sdpxu];
        } in  poly_go_rdpws sat_sdpxv GHC.List.lastError;

Data.List.NonEmpty.init :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sdpxw]
        case ds_sdpxw of {
          GHC.Base.:| a1_sdpxy [Occ=Once] as_sdpxz [Occ=Once] ->
              GHC.List.init1 a1_sdpxy as_sdpxz;
        };

Data.List.NonEmpty.<|
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [a1_sdpxA ds_sdpxB]
        let {
          sat_sdpxJ [Occ=Once] :: [a_adocs]
          [LclId] =
              [ds_sdpxB] \u []
                  case ds_sdpxB of {
                    GHC.Base.:| _ [Occ=Dead] bs_sdpxI [Occ=Once] -> bs_sdpxI;
                  }; } in
        let {
          sat_sdpxF [Occ=Once] :: a_adocs
          [LclId] =
              [ds_sdpxB] \u []
                  case ds_sdpxB of {
                    GHC.Base.:| b_sdpxD [Occ=Once] _ [Occ=Dead] -> b_sdpxD;
                  }; } in
        let {
          sat_sdpxK [Occ=Once] :: [a_adocs]
          [LclId] =
              CCCS :! [sat_sdpxF sat_sdpxJ];
        } in  GHC.Base.:| [a1_sdpxA sat_sdpxK];

Data.List.NonEmpty.cons
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.List.NonEmpty.<| eta_B2 eta_B1;

Data.List.NonEmpty.$wunfold [InlPrag=NOUSERINLINE[0],
                             Occ=LoopBreaker]
  :: forall a b. (a -> (b, GHC.Base.Maybe a)) -> a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S(LS)),C(U(U,1*U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdpxL w1_sdpxM]
        case w_sdpxL w1_sdpxM of {
          (,) b1_sdpxO [Occ=Once*] ds_sdpxP [Occ=Once!] ->
              case ds_sdpxP of {
                GHC.Base.Nothing -> (#,#) [b1_sdpxO GHC.Types.[]];
                GHC.Base.Just c_sdpxR [Occ=Once] ->
                    let {
                      ds1_sdpxS [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty b_sdp0S
                      [LclId] =
                          [w_sdpxL c_sdpxR] \u []
                              case Data.List.NonEmpty.$wunfold w_sdpxL c_sdpxR of {
                                (#,#) ww1_sdpxU [Occ=Once] ww2_sdpxV [Occ=Once] ->
                                    GHC.Base.:| [ww1_sdpxU ww2_sdpxV];
                              }; } in
                    let {
                      sat_sdpy3 [Occ=Once] :: [b_sdp0S]
                      [LclId] =
                          [ds1_sdpxS] \u []
                              case ds1_sdpxS of {
                                GHC.Base.:| _ [Occ=Dead] bs_sdpy2 [Occ=Once] -> bs_sdpy2;
                              }; } in
                    let {
                      sat_sdpxZ [Occ=Once] :: b_sdp0S
                      [LclId] =
                          [ds1_sdpxS] \u []
                              case ds1_sdpxS of {
                                GHC.Base.:| b2_sdpxX [Occ=Once] _ [Occ=Dead] -> b2_sdpxX;
                              }; } in
                    let {
                      sat_sdpy4 [Occ=Once] :: [b_sdp0S]
                      [LclId] =
                          CCCS :! [sat_sdpxZ sat_sdpy3];
                    } in  (#,#) [b1_sdpxO sat_sdpy4];
              };
        };

Data.List.NonEmpty.unfold [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> (b, GHC.Base.Maybe a)) -> a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S(LS)),C(U(U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdpy5 w1_sdpy6]
        case Data.List.NonEmpty.$wunfold w_sdpy5 w1_sdpy6 of {
          (#,#) ww1_sdpy8 [Occ=Once] ww2_sdpy9 [Occ=Once] ->
              GHC.Base.:| [ww1_sdpy8 ww2_sdpy9];
        };

lvl_rdpwt :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.fromList: empty list"#;

Data.List.NonEmpty.cycle1 :: forall a. GHC.Base.NonEmpty a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rdpwt of sat_sdpya {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sdpya;
        };

Data.List.NonEmpty.fromList :: forall a. [a] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sdpyb]
        case ds_sdpyb of {
          [] -> Data.List.NonEmpty.cycle1;
          : a1_sdpyd [Occ=Once] as_sdpye [Occ=Once] ->
              GHC.Base.:| [a1_sdpyd as_sdpye];
        };

Data.List.NonEmpty.reverse [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U(1*U,1*U)>m, Unf=OtherCon []] =
    [] \r [w_sdpyf]
        let {
          sat_sdpyn [Occ=Once] :: [a_sdp0Z]
          [LclId] =
              [w_sdpyf] \u []
                  case w_sdpyf of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpym [Occ=Once] -> as_sdpym;
                  }; } in
        let {
          sat_sdpyj [Occ=Once] :: a_sdp0Z
          [LclId] =
              [w_sdpyf] \u []
                  case w_sdpyf of {
                    GHC.Base.:| a1_sdpyh [Occ=Once] _ [Occ=Dead] -> a1_sdpyh;
                  }; } in
        let {
          sat_sdpyo [Occ=Once] :: [a_sdp0Z]
          [LclId] =
              CCCS :! [sat_sdpyj sat_sdpyn];
        } in 
          case GHC.List.reverse1 sat_sdpyo GHC.Types.[] of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpyr [Occ=Once] as_sdpys [Occ=Once] ->
                GHC.Base.:| [a1_sdpyr as_sdpys];
          };

Data.List.NonEmpty.sortBy
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdpyt eta_sdpyu]
        let {
          sat_sdpyC [Occ=Once] :: [a_ado9j]
          [LclId] =
              [eta_sdpyu] \u []
                  case eta_sdpyu of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpyB [Occ=Once] -> as_sdpyB;
                  }; } in
        let {
          sat_sdpyy [Occ=Once] :: a_ado9j
          [LclId] =
              [eta_sdpyu] \u []
                  case eta_sdpyu of {
                    GHC.Base.:| a1_sdpyw [Occ=Once] _ [Occ=Dead] -> a1_sdpyw;
                  }; } in
        let {
          sat_sdpyD [Occ=Once] :: [a_ado9j]
          [LclId] =
              CCCS :! [sat_sdpyy sat_sdpyC];
        } in 
          case Data.OldList.sortBy f_sdpyt sat_sdpyD of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpyF [Occ=Once] as_sdpyG [Occ=Once] ->
                GHC.Base.:| [a1_sdpyF as_sdpyG];
          };

Data.List.NonEmpty.sortWith [InlPrag=NOUSERINLINE[0]]
  :: forall o a.
     GHC.Classes.Ord o =>
     (a -> o) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpyH w1_sdpyI w2_sdpyJ]
        let {
          sat_sdpyS [Occ=Once] :: [a_sdp16]
          [LclId] =
              [w2_sdpyJ] \u []
                  case w2_sdpyJ of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpyR [Occ=Once] -> as_sdpyR;
                  }; } in
        let {
          sat_sdpyO [Occ=Once] :: a_sdp16
          [LclId] =
              [w2_sdpyJ] \u []
                  case w2_sdpyJ of {
                    GHC.Base.:| a1_sdpyM [Occ=Once] _ [Occ=Dead] -> a1_sdpyM;
                  }; } in
        let {
          sat_sdpyT [Occ=Once] :: [a_sdp16]
          [LclId] =
              CCCS :! [sat_sdpyO sat_sdpyS]; } in
        let {
          sat_sdpyK [Occ=Once] :: a_sdp16 -> a_sdp16 -> GHC.Types.Ordering
          [LclId] =
              [w_sdpyH w1_sdpyI] \r [eta_B2 eta_B1]
                  Data.Ord.comparing w_sdpyH w1_sdpyI eta_B2 eta_B1;
        } in 
          case Data.OldList.sortBy sat_sdpyK sat_sdpyT of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpyW [Occ=Once] as_sdpyX [Occ=Once] ->
                GHC.Base.:| [a1_sdpyW as_sdpyX];
          };

Data.List.NonEmpty.sort [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C(C1(U)),A,A,A,A,A,A)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpyY w1_sdpyZ]
        let {
          sat_sdpz8 [Occ=Once] :: [a_sdp1e]
          [LclId] =
              [w1_sdpyZ] \u []
                  case w1_sdpyZ of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpz7 [Occ=Once] -> as_sdpz7;
                  }; } in
        let {
          sat_sdpz4 [Occ=Once] :: a_sdp1e
          [LclId] =
              [w1_sdpyZ] \u []
                  case w1_sdpyZ of {
                    GHC.Base.:| a1_sdpz2 [Occ=Once] _ [Occ=Dead] -> a1_sdpz2;
                  }; } in
        let {
          sat_sdpz9 [Occ=Once] :: [a_sdp1e]
          [LclId] =
              CCCS :! [sat_sdpz4 sat_sdpz8]; } in
        let {
          sat_sdpz0 [Occ=Once, Dmd=<L,C(C1(U))>]
            :: a_sdp1e -> a_sdp1e -> GHC.Types.Ordering
          [LclId] =
              [w_sdpyY] \u [] GHC.Classes.compare w_sdpyY;
        } in 
          case Data.OldList.sortBy sat_sdpz0 sat_sdpz9 of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpzc [Occ=Once] as_sdpzd [Occ=Once] ->
                GHC.Base.:| [a1_sdpzc as_sdpzd];
          };

Data.List.NonEmpty.inits
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     f a -> GHC.Base.NonEmpty [a]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpze eta_sdpzf]
        let {
          sat_sdpzg [Occ=Once, Dmd=<L,1*U>] :: [a_ado9V]
          [LclId] =
              [$dFoldable_sdpze eta_sdpzf] \s []
                  Data.Foldable.toList $dFoldable_sdpze eta_sdpzf;
        } in 
          case Data.OldList.$winits sat_sdpzg of {
            (#,#) ww1_sdpzi [Occ=Once] ww2_sdpzj [Occ=Once] ->
                GHC.Base.:| [ww1_sdpzi ww2_sdpzj];
          };

Data.List.NonEmpty.tails1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [xs_sdpzk]
        let {
          sat_sdpzo [Occ=Once] :: [[a_sdp1n]]
          [LclId] =
              [xs_sdpzk] \u []
                  case xs_sdpzk of {
                    [] -> [] [];
                    : _ [Occ=Dead] xs'_sdpzn [Occ=Once] ->
                        Data.List.NonEmpty.tails1 xs'_sdpzn;
                  };
        } in  : [xs_sdpzk sat_sdpzo];

Data.List.NonEmpty.tails [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     f a -> GHC.Base.NonEmpty [a]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdpzp w1_sdpzq]
        let {
          sat_sdpzr [Occ=Once] :: [a_sdp1n]
          [LclId] =
              [w_sdpzp w1_sdpzq] \u [] Data.Foldable.toList w_sdpzp w1_sdpzq;
        } in 
          case Data.List.NonEmpty.tails1 sat_sdpzr of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpzu [Occ=Once] as_sdpzv [Occ=Once] ->
                GHC.Base.:| [a1_sdpzu as_sdpzv];
          };

Data.List.NonEmpty.insert
  :: forall (f :: * -> *) a.
     (Data.Foldable.Foldable f, GHC.Classes.Ord a) =>
     a -> f a -> GHC.Base.NonEmpty a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*U(A,1*C(C1(U)),A,A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpzw $dOrd_sdpzx a1_sdpzy eta_sdpzz]
        case Data.Foldable.toList $dFoldable_sdpzw eta_sdpzz of sat_sdpzB {
          __DEFAULT ->
              let {
                sat_sdpzA [Occ=Once, Dmd=<L,C(C1(U))>]
                  :: a_adoav -> a_adoav -> GHC.Types.Ordering
                [LclId] =
                    [$dOrd_sdpzx] \u [] GHC.Classes.compare $dOrd_sdpzx;
              } in 
                case Data.OldList.$winsertBy sat_sdpzA a1_sdpzy sat_sdpzB of {
                  (#,#) ww1_sdpzD [Occ=Once] ww2_sdpzE [Occ=Once] ->
                      GHC.Base.:| [ww1_sdpzD ww2_sdpzE];
                };
        };

Data.List.NonEmpty.scanl
  :: forall (f :: * -> *) b a.
     Data.Foldable.Foldable f =>
     (b -> a -> b) -> b -> f a -> GHC.Base.NonEmpty b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpzF f1_sdpzG z_sdpzH eta_sdpzI]
        let {
          sat_sdpzN [Occ=Once] :: [b_adoaP]
          [LclId] =
              [$dFoldable_sdpzF f1_sdpzG z_sdpzH eta_sdpzI] \u []
                  let {
                    sat_sdpzJ [Occ=Once, Dmd=<L,1*U>] :: [a_adoaQ]
                    [LclId] =
                        [$dFoldable_sdpzF eta_sdpzI] \s []
                            Data.Foldable.toList $dFoldable_sdpzF eta_sdpzI;
                  } in 
                    case GHC.List.$wscanlGo f1_sdpzG z_sdpzH sat_sdpzJ of {
                      (#,#) _ [Occ=Dead] ww2_sdpzM [Occ=Once] -> ww2_sdpzM;
                    };
        } in  GHC.Base.:| [z_sdpzH sat_sdpzN];

Data.List.NonEmpty.scanr
  :: forall (f :: * -> *) a b.
     Data.Foldable.Foldable f =>
     (a -> b -> b) -> b -> f a -> GHC.Base.NonEmpty b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpzO f1_sdpzP z_sdpzQ eta_sdpzR]
        case Data.Foldable.toList $dFoldable_sdpzO eta_sdpzR of sat_sdpzS {
          __DEFAULT ->
              case GHC.List.$wscanr f1_sdpzP z_sdpzQ sat_sdpzS of {
                (#,#) ww1_sdpzU [Occ=Once] ww2_sdpzV [Occ=Once] ->
                    GHC.Base.:| [ww1_sdpzU ww2_sdpzV];
              };
        };

Data.List.NonEmpty.scanl1
  :: forall a.
     (a -> a -> a) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdpzW ds_sdpzX]
        let {
          a1_sdpzY :: a_adobr
          [LclId] =
              [ds_sdpzX] \u []
                  case ds_sdpzX of {
                    GHC.Base.:| a2_sdpA0 [Occ=Once] _ [Occ=Dead] -> a2_sdpA0;
                  }; } in
        let {
          sat_sdpA8 [Occ=Once] :: [a_adobr]
          [LclId] =
              [f_sdpzW ds_sdpzX a1_sdpzY] \u []
                  case ds_sdpzX of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpA4 [Occ=Once] ->
                        case GHC.List.$wscanlGo f_sdpzW a1_sdpzY as_sdpA4 of {
                          (#,#) _ [Occ=Dead] ww2_sdpA7 [Occ=Once] -> ww2_sdpA7;
                        };
                  };
        } in  GHC.Base.:| [a1_sdpzY sat_sdpA8];

Data.List.NonEmpty.scanr1
  :: forall a.
     (a -> a -> a) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdpA9 ds_sdpAa]
        let {
          sat_sdpAi [Occ=Once] :: [a_adobw]
          [LclId] =
              [ds_sdpAa] \u []
                  case ds_sdpAa of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpAh [Occ=Once] -> as_sdpAh;
                  }; } in
        let {
          sat_sdpAe [Occ=Once] :: a_adobw
          [LclId] =
              [ds_sdpAa] \u []
                  case ds_sdpAa of {
                    GHC.Base.:| a1_sdpAc [Occ=Once] _ [Occ=Dead] -> a1_sdpAc;
                  }; } in
        let {
          sat_sdpAj [Occ=Once] :: [a_adobw]
          [LclId] =
              CCCS :! [sat_sdpAe sat_sdpAi];
        } in 
          case GHC.List.scanr1 f_sdpA9 sat_sdpAj of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpAl [Occ=Once] as_sdpAm [Occ=Once] ->
                GHC.Base.:| [a1_sdpAl as_sdpAm];
          };

Data.List.NonEmpty.toList :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_sdpAn]
        let {
          sat_sdpAv [Occ=Once] :: [a_ado7K]
          [LclId] =
              [ds_sdpAn] \u []
                  case ds_sdpAn of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpAu [Occ=Once] -> as_sdpAu;
                  }; } in
        let {
          sat_sdpAr [Occ=Once] :: a_ado7K
          [LclId] =
              [ds_sdpAn] \u []
                  case ds_sdpAn of {
                    GHC.Base.:| a1_sdpAp [Occ=Once] _ [Occ=Dead] -> a1_sdpAp;
                  };
        } in  : [sat_sdpAr sat_sdpAv];

Data.List.NonEmpty.$wtake [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Prim.Int# -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ww_sdpAw w_sdpAx]
        case <# [0# ww_sdpAw] of {
          __DEFAULT -> [] [];
          1# ->
              let {
                sat_sdpAG [Occ=Once] :: [a_sdp1u]
                [LclId] =
                    [w_sdpAx] \u []
                        case w_sdpAx of {
                          GHC.Base.:| _ [Occ=Dead] as_sdpAF [Occ=Once] -> as_sdpAF;
                        }; } in
              let {
                sat_sdpAC [Occ=Once] :: a_sdp1u
                [LclId] =
                    [w_sdpAx] \u []
                        case w_sdpAx of {
                          GHC.Base.:| a1_sdpAA [Occ=Once] _ [Occ=Dead] -> a1_sdpAA;
                        }; } in
              let {
                sat_sdpAH [Occ=Once] :: [a_sdp1u]
                [LclId] =
                    CCCS :! [sat_sdpAC sat_sdpAG];
              } in  GHC.List.$wunsafeTake ww_sdpAw sat_sdpAH;
        };

Data.List.NonEmpty.take [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpAI w1_sdpAJ]
        case w_sdpAI of {
          GHC.Types.I# ww1_sdpAL [Occ=Once] ->
              Data.List.NonEmpty.$wtake ww1_sdpAL w1_sdpAJ;
        };

Data.List.NonEmpty.$wunsafeDrop [InlPrag=NOUSERINLINE[0],
                                 Occ=LoopBreaker]
  :: forall a1. GHC.Prim.Int# -> [a1] -> [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sdpAM w_sdpAN]
        case w_sdpAN of {
          [] -> [] [];
          : _ [Occ=Dead] ipv2_sdpAQ [Occ=Once*] ->
              case ww_sdpAM of ds3_sdpAR {
                __DEFAULT ->
                    case -# [ds3_sdpAR 1#] of sat_sdpAS {
                      __DEFAULT -> Data.List.NonEmpty.$wunsafeDrop sat_sdpAS ipv2_sdpAQ;
                    };
                1# -> ipv2_sdpAQ;
              };
        };

Data.List.NonEmpty.$wdrop [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Prim.Int# -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ww_sdpAT w_sdpAU]
        case <=# [ww_sdpAT 0#] of {
          __DEFAULT ->
              let {
                sat_sdpB3 [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    [w_sdpAU] \u []
                        case w_sdpAU of {
                          GHC.Base.:| _ [Occ=Dead] as_sdpB2 [Occ=Once] -> as_sdpB2;
                        }; } in
              let {
                sat_sdpAZ [Occ=Once] :: a_sdp1K
                [LclId] =
                    [w_sdpAU] \u []
                        case w_sdpAU of {
                          GHC.Base.:| a1_sdpAX [Occ=Once] _ [Occ=Dead] -> a1_sdpAX;
                        }; } in
              let {
                sat_sdpB4 [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    CCCS :! [sat_sdpAZ sat_sdpB3];
              } in  Data.List.NonEmpty.$wunsafeDrop ww_sdpAT sat_sdpB4;
          1# ->
              let {
                sat_sdpBc [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    [w_sdpAU] \u []
                        case w_sdpAU of {
                          GHC.Base.:| _ [Occ=Dead] as_sdpBb [Occ=Once] -> as_sdpBb;
                        }; } in
              let {
                sat_sdpB8 [Occ=Once] :: a_sdp1K
                [LclId] =
                    [w_sdpAU] \u []
                        case w_sdpAU of {
                          GHC.Base.:| a1_sdpB6 [Occ=Once] _ [Occ=Dead] -> a1_sdpB6;
                        };
              } in  : [sat_sdpB8 sat_sdpBc];
        };

Data.List.NonEmpty.drop [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpBd w1_sdpBe]
        case w_sdpBd of {
          GHC.Types.I# ww1_sdpBg [Occ=Once] ->
              Data.List.NonEmpty.$wdrop ww1_sdpBg w1_sdpBe;
        };

Data.List.NonEmpty.splitAt [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpBh w1_sdpBi]
        case w_sdpBh of ww_sdpBj {
          GHC.Types.I# ww1_sdpBk [Occ=Once] ->
              case <=# [ww1_sdpBk 0#] of {
                __DEFAULT ->
                    let {
                      sat_sdpBt [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          [w1_sdpBi] \u []
                              case w1_sdpBi of {
                                GHC.Base.:| _ [Occ=Dead] as_sdpBs [Occ=Once] -> as_sdpBs;
                              }; } in
                    let {
                      sat_sdpBp [Occ=Once] :: a_sdp1S
                      [LclId] =
                          [w1_sdpBi] \u []
                              case w1_sdpBi of {
                                GHC.Base.:| a1_sdpBn [Occ=Once] _ [Occ=Dead] -> a1_sdpBn;
                              }; } in
                    let {
                      sat_sdpBu [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          CCCS :! [sat_sdpBp sat_sdpBt];
                    } in 
                      case GHC.List.$wsplitAt' ww_sdpBj sat_sdpBu of {
                        (#,#) ww3_sdpBw [Occ=Once] ww4_sdpBx [Occ=Once] ->
                            (,) [ww3_sdpBw ww4_sdpBx];
                      };
                1# ->
                    let {
                      sat_sdpBF [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          [w1_sdpBi] \u []
                              case w1_sdpBi of {
                                GHC.Base.:| _ [Occ=Dead] as_sdpBE [Occ=Once] -> as_sdpBE;
                              }; } in
                    let {
                      sat_sdpBB [Occ=Once] :: a_sdp1S
                      [LclId] =
                          [w1_sdpBi] \u []
                              case w1_sdpBi of {
                                GHC.Base.:| a1_sdpBz [Occ=Once] _ [Occ=Dead] -> a1_sdpBz;
                              }; } in
                    let {
                      sat_sdpBG [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          CCCS :! [sat_sdpBB sat_sdpBF];
                    } in  (,) [GHC.Types.[] sat_sdpBG];
              };
        };

Data.List.NonEmpty.takeWhile
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdpBH x_sdpBI]
        let {
          sat_sdpBQ [Occ=Once] :: [a_ado8a]
          [LclId] =
              [x_sdpBI] \u []
                  case x_sdpBI of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpBP [Occ=Once] -> as_sdpBP;
                  }; } in
        let {
          sat_sdpBM [Occ=Once] :: a_ado8a
          [LclId] =
              [x_sdpBI] \u []
                  case x_sdpBI of {
                    GHC.Base.:| a1_sdpBK [Occ=Once] _ [Occ=Dead] -> a1_sdpBK;
                  }; } in
        let {
          sat_sdpBR [Occ=Once] :: [a_ado8a]
          [LclId] =
              CCCS :! [sat_sdpBM sat_sdpBQ];
        } in  GHC.List.takeWhile p_sdpBH sat_sdpBR;

Data.List.NonEmpty.dropWhile
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdpBS x_sdpBT]
        let {
          sat_sdpC1 [Occ=Once] :: [a_ado8h]
          [LclId] =
              [x_sdpBT] \u []
                  case x_sdpBT of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpC0 [Occ=Once] -> as_sdpC0;
                  }; } in
        let {
          sat_sdpBX [Occ=Once] :: a_ado8h
          [LclId] =
              [x_sdpBT] \u []
                  case x_sdpBT of {
                    GHC.Base.:| a1_sdpBV [Occ=Once] _ [Occ=Dead] -> a1_sdpBV;
                  }; } in
        let {
          sat_sdpC2 [Occ=Once] :: [a_ado8h]
          [LclId] =
              CCCS :! [sat_sdpBX sat_sdpC1];
        } in  GHC.List.dropWhile p_sdpBS sat_sdpC2;

Data.List.NonEmpty.span
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [p_sdpC3 x_sdpC4]
        let {
          sat_sdpCc [Occ=Once] :: [a_ado8p]
          [LclId] =
              [x_sdpC4] \u []
                  case x_sdpC4 of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpCb [Occ=Once] -> as_sdpCb;
                  }; } in
        let {
          sat_sdpC8 [Occ=Once] :: a_ado8p
          [LclId] =
              [x_sdpC4] \u []
                  case x_sdpC4 of {
                    GHC.Base.:| a1_sdpC6 [Occ=Once] _ [Occ=Dead] -> a1_sdpC6;
                  }; } in
        let {
          sat_sdpCd [Occ=Once] :: [a_ado8p]
          [LclId] =
              CCCS :! [sat_sdpC8 sat_sdpCc];
        } in 
          case GHC.List.$wspan p_sdpC3 sat_sdpCd of {
            (#,#) ww1_sdpCf [Occ=Once] ww2_sdpCg [Occ=Once] ->
                (,) [ww1_sdpCf ww2_sdpCg];
          };

Data.List.NonEmpty.$wbreak [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpCh w1_sdpCi]
        let {
          sat_sdpCt [Occ=Once] :: [a_sdp23]
          [LclId] =
              [w1_sdpCi] \u []
                  case w1_sdpCi of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpCs [Occ=Once] -> as_sdpCs;
                  }; } in
        let {
          sat_sdpCp [Occ=Once] :: a_sdp23
          [LclId] =
              [w1_sdpCi] \u []
                  case w1_sdpCi of {
                    GHC.Base.:| a1_sdpCn [Occ=Once] _ [Occ=Dead] -> a1_sdpCn;
                  }; } in
        let {
          sat_sdpCu [Occ=Once] :: [a_sdp23]
          [LclId] =
              CCCS :! [sat_sdpCp sat_sdpCt]; } in
        let {
          sat_sdpCl [Occ=Once] :: a_sdp23 -> GHC.Types.Bool
          [LclId] =
              [w_sdpCh] \r [x_sdpCj]
                  case w_sdpCh x_sdpCj of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  GHC.List.$wspan sat_sdpCl sat_sdpCu;

Data.List.NonEmpty.break [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpCv w1_sdpCw]
        case Data.List.NonEmpty.$wbreak w_sdpCv w1_sdpCw of {
          (#,#) ww1_sdpCy [Occ=Once] ww2_sdpCz [Occ=Once] ->
              (,) [ww1_sdpCy ww2_sdpCz];
        };

Data.List.NonEmpty.filter
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdpCA x_sdpCB]
        let {
          sat_sdpCJ [Occ=Once] :: [a_ado8C]
          [LclId] =
              [x_sdpCB] \u []
                  case x_sdpCB of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpCI [Occ=Once] -> as_sdpCI;
                  }; } in
        let {
          sat_sdpCF [Occ=Once] :: a_ado8C
          [LclId] =
              [x_sdpCB] \u []
                  case x_sdpCB of {
                    GHC.Base.:| a1_sdpCD [Occ=Once] _ [Occ=Dead] -> a1_sdpCD;
                  }; } in
        let {
          sat_sdpCK [Occ=Once] :: [a_ado8C]
          [LclId] =
              CCCS :! [sat_sdpCF sat_sdpCJ];
        } in  GHC.List.filter p_sdpCA sat_sdpCK;

Data.List.NonEmpty.$wpartition [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpCL w1_sdpCM]
        let {
          $wgo_sdpCN [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: [a_sdp2f] -> (# [a_sdp2f], [a_sdp2f] #)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sdpCL $wgo_sdpCN] \r [w2_sdpCO]
                  case w2_sdpCO of {
                    [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
                    : y_sdpCQ ys_sdpCR [Occ=Once] ->
                        let {
                          w3_sdpCS [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp2f], [a_sdp2f])
                          [LclId] =
                              [$wgo_sdpCN ys_sdpCR] \u []
                                  case $wgo_sdpCN ys_sdpCR of {
                                    (#,#) ww1_sdpCU [Occ=Once] ww2_sdpCV [Occ=Once] ->
                                        (,) [ww1_sdpCU ww2_sdpCV];
                                  };
                        } in 
                          case w_sdpCL y_sdpCQ of {
                            GHC.Types.False ->
                                let {
                                  sat_sdpD4 [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdpCS] \u []
                                          case w3_sdpCS of {
                                            (,) _ [Occ=Dead] fs_sdpD3 [Occ=Once] -> fs_sdpD3;
                                          }; } in
                                let {
                                  sat_sdpD5 [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      CCCS :! [y_sdpCQ sat_sdpD4]; } in
                                let {
                                  sat_sdpD0 [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdpCS] \u []
                                          case w3_sdpCS of {
                                            (,) ts_sdpCY [Occ=Once] _ [Occ=Dead] -> ts_sdpCY;
                                          };
                                } in  (#,#) [sat_sdpD0 sat_sdpD5];
                            GHC.Types.True ->
                                let {
                                  sat_sdpDe [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdpCS] \u []
                                          case w3_sdpCS of {
                                            (,) _ [Occ=Dead] fs_sdpDd [Occ=Once] -> fs_sdpDd;
                                          }; } in
                                let {
                                  sat_sdpD9 [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdpCS] \u []
                                          case w3_sdpCS of {
                                            (,) ts_sdpD7 [Occ=Once] _ [Occ=Dead] -> ts_sdpD7;
                                          }; } in
                                let {
                                  sat_sdpDa [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      CCCS :! [y_sdpCQ sat_sdpD9];
                                } in  (#,#) [sat_sdpDa sat_sdpDe];
                          };
                  }; } in
        let {
          sat_sdpDm [Occ=Once] :: [a_sdp2f]
          [LclId] =
              [w1_sdpCM] \u []
                  case w1_sdpCM of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpDl [Occ=Once] -> as_sdpDl;
                  }; } in
        let {
          sat_sdpDi [Occ=Once] :: a_sdp2f
          [LclId] =
              [w1_sdpCM] \u []
                  case w1_sdpCM of {
                    GHC.Base.:| a1_sdpDg [Occ=Once] _ [Occ=Dead] -> a1_sdpDg;
                  }; } in
        let {
          sat_sdpDn [Occ=Once] :: [a_sdp2f]
          [LclId] =
              CCCS :! [sat_sdpDi sat_sdpDm];
        } in  $wgo_sdpCN sat_sdpDn;

Data.List.NonEmpty.partition [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpDo w1_sdpDp]
        case Data.List.NonEmpty.$wpartition w_sdpDo w1_sdpDp of {
          (#,#) ww1_sdpDr [Occ=Once] ww2_sdpDs [Occ=Once] ->
              (,) [ww1_sdpDr ww2_sdpDs];
        };

Data.List.NonEmpty.cycle [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_sdpDt]
        let {
          xs'_sdpDu [Occ=LoopBreaker] :: [a_sdp2m]
          [LclId] =
              [w_sdpDt xs'_sdpDu] \u []
                  let {
                    sat_sdpDC [Occ=OnceL] :: [a_sdp2m]
                    [LclId] =
                        [w_sdpDt] \u []
                            case w_sdpDt of {
                              GHC.Base.:| _ [Occ=Dead] as_sdpDB [Occ=Once] -> as_sdpDB;
                            }; } in
                  let {
                    sat_sdpDy [Occ=OnceL] :: a_sdp2m
                    [LclId] =
                        [w_sdpDt] \u []
                            case w_sdpDt of {
                              GHC.Base.:| a1_sdpDw [Occ=Once] _ [Occ=Dead] -> a1_sdpDw;
                            }; } in
                  let {
                    sat_sdpDD [Occ=Once] :: [a_sdp2m]
                    [LclId] =
                        CCCS :! [sat_sdpDy sat_sdpDC];
                  } in  GHC.Base.++ sat_sdpDD xs'_sdpDu;
        } in 
          case xs'_sdpDu of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpDG [Occ=Once] as_sdpDH [Occ=Once] ->
                GHC.Base.:| [a1_sdpDG as_sdpDH];
          };

Data.List.NonEmpty.$wtranspose [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
     -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId, Arity=1, Str=<L,U(U(1*U,1*U),1*U)>, Unf=OtherCon []] =
    [] \r [w_sdpDI]
        let {
          ds_sdpDJ [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty [a_sdp2s]
          [LclId] =
              [w_sdpDI] \u []
                  let {
                    sat_sdpE2 [Occ=OnceL] :: [[a_sdp2s]]
                    [LclId] =
                        [w_sdpDI] \u []
                            case w_sdpDI of {
                              GHC.Base.:| _ [Occ=Dead] as_sdpE1 [Occ=Once] ->
                                  GHC.Base.map Data.List.NonEmpty.toList as_sdpE1;
                            }; } in
                  let {
                    sat_sdpDX [Occ=OnceL] :: [a_sdp2s]
                    [LclId] =
                        [w_sdpDI] \u []
                            case w_sdpDI of {
                              GHC.Base.:| a1_sdpDS [Occ=Once!] _ [Occ=Dead] ->
                                  case a1_sdpDS of {
                                    GHC.Base.:| _ [Occ=Dead] as1_sdpDW [Occ=Once] -> as1_sdpDW;
                                  };
                            }; } in
                  let {
                    sat_sdpDQ [Occ=OnceL] :: a_sdp2s
                    [LclId] =
                        [w_sdpDI] \u []
                            case w_sdpDI of {
                              GHC.Base.:| a1_sdpDL [Occ=Once!] _ [Occ=Dead] ->
                                  case a1_sdpDL of {
                                    GHC.Base.:| a2_sdpDO [Occ=Once] _ [Occ=Dead] -> a2_sdpDO;
                                  };
                            }; } in
                  let {
                    sat_sdpDY [Occ=OnceL] :: [a_sdp2s]
                    [LclId] =
                        CCCS :! [sat_sdpDQ sat_sdpDX]; } in
                  let {
                    sat_sdpE3 [Occ=Once] :: [[a_sdp2s]]
                    [LclId] =
                        CCCS :! [sat_sdpDY sat_sdpE2];
                  } in 
                    case Data.OldList.transpose sat_sdpE3 of {
                      [] -> Data.List.NonEmpty.cycle1;
                      : a1_sdpE5 [Occ=Once] as_sdpE6 [Occ=Once] ->
                          GHC.Base.:| [a1_sdpE5 as_sdpE6];
                    }; } in
        let {
          sat_sdpEh [Occ=Once] :: [GHC.Base.NonEmpty a_sdp2s]
          [LclId] =
              [ds_sdpDJ] \u []
                  case ds_sdpDJ of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpEg [Occ=Once] ->
                        GHC.Base.map Data.List.NonEmpty.fromList as_sdpEg;
                  }; } in
        let {
          sat_sdpEd [Occ=Once] :: GHC.Base.NonEmpty a_sdp2s
          [LclId] =
              [ds_sdpDJ] \u []
                  case ds_sdpDJ of {
                    GHC.Base.:| a1_sdpE8 [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdpE8 of {
                          [] -> Data.List.NonEmpty.cycle1;
                          : a2_sdpEb [Occ=Once] as1_sdpEc [Occ=Once] ->
                              GHC.Base.:| [a2_sdpEb as1_sdpEc];
                        };
                  };
        } in  (#,#) [sat_sdpEd sat_sdpEh];

Data.List.NonEmpty.transpose [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
     -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId, Arity=1, Str=<L,U(U(U,U),U)>m, Unf=OtherCon []] =
    [] \r [w_sdpEi]
        case Data.List.NonEmpty.$wtranspose w_sdpEi of {
          (#,#) ww1_sdpEk [Occ=Once] ww2_sdpEl [Occ=Once] ->
              GHC.Base.:| [ww1_sdpEk ww2_sdpEl];
        };

Data.List.NonEmpty.map
  :: forall a b.
     (a -> b) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdpEm ds_sdpEn]
        let {
          sat_sdpEw [Occ=Once] :: [b_ado7C]
          [LclId] =
              [f_sdpEm ds_sdpEn] \u []
                  case ds_sdpEn of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpEv [Occ=Once] ->
                        GHC.Base.map f_sdpEm as_sdpEv;
                  }; } in
        let {
          sat_sdpEs [Occ=Once] :: b_ado7C
          [LclId] =
              [f_sdpEm ds_sdpEn] \u []
                  let {
                    sat_sdpEr [Occ=Once] :: a_ado7B
                    [LclId] =
                        [ds_sdpEn] \u []
                            case ds_sdpEn of {
                              GHC.Base.:| a1_sdpEp [Occ=Once] _ [Occ=Dead] -> a1_sdpEp;
                            };
                  } in  f_sdpEm sat_sdpEr;
        } in  GHC.Base.:| [sat_sdpEs sat_sdpEw];

Data.List.NonEmpty.some1
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     f a -> f (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sdpEx eta_sdpEy]
        let {
          sat_sdpEA [Occ=Once] :: f_ado7n [a_ado7o]
          [LclId] =
              [$dAlternative_sdpEx eta_sdpEy] \u []
                  GHC.Base.many $dAlternative_sdpEx eta_sdpEy;
        } in 
          case GHC.Base.$p1Alternative $dAlternative_sdpEx of sat_sdpEz {
            __DEFAULT ->
                GHC.Base.liftA2 sat_sdpEz GHC.Base.:| eta_sdpEy sat_sdpEA;
          };

Data.List.NonEmpty.intersperse [InlPrag=NOUSERINLINE[0]]
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpEB w1_sdpEC]
        let {
          sat_sdpEP [Occ=Once] :: [a_sdp2C]
          [LclId] =
              [w_sdpEB w1_sdpEC] \u []
                  case w1_sdpEC of {
                    GHC.Base.:| _ [Occ=Dead] bs_sdpEJ [Occ=Once!] ->
                        case bs_sdpEJ of {
                          [] -> [] [];
                          : ipv_sdpEL [Occ=Once] ipv1_sdpEM [Occ=Once] ->
                              let {
                                sat_sdpEN [Occ=Once] :: [a_sdp2C]
                                [LclId] =
                                    [w_sdpEB ipv1_sdpEM] \u []
                                        Data.OldList.prependToAll w_sdpEB ipv1_sdpEM; } in
                              let {
                                sat_sdpEO [Occ=Once] :: [a_sdp2C]
                                [LclId] =
                                    CCCS :! [ipv_sdpEL sat_sdpEN];
                              } in  : [w_sdpEB sat_sdpEO];
                        };
                  }; } in
        let {
          sat_sdpEG [Occ=Once] :: a_sdp2C
          [LclId] =
              [w1_sdpEC] \u []
                  case w1_sdpEC of {
                    GHC.Base.:| b_sdpEE [Occ=Once] _ [Occ=Dead] -> b_sdpEE;
                  };
        } in  GHC.Base.:| [sat_sdpEG sat_sdpEP];

Data.List.NonEmpty.iterate
  :: forall a. (a -> a) -> a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_sdpEQ a1_sdpER]
        let {
          sat_sdpEW [Occ=Once] :: [a_ado7a]
          [LclId] =
              [f_sdpEQ a1_sdpER] \u []
                  let {
                    sat_sdpES [Occ=Once] :: a_ado7a
                    [LclId] =
                        [f_sdpEQ a1_sdpER] \u [] f_sdpEQ a1_sdpER;
                  } in 
                    case GHC.List.$witerate f_sdpEQ sat_sdpES of {
                      (#,#) ww1_sdpEU [Occ=Once] ww2_sdpEV [Occ=Once] ->
                          : [ww1_sdpEU ww2_sdpEV];
                    };
        } in  GHC.Base.:| [a1_sdpER sat_sdpEW];

Data.List.NonEmpty.repeat :: forall a. a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [a1_sdpEX]
        let {
          sat_sdpEY [Occ=Once] :: [a_ado76]
          [LclId] =
              [a1_sdpEX] \u [] GHC.List.repeat a1_sdpEX;
        } in  GHC.Base.:| [a1_sdpEX sat_sdpEY];

Data.List.NonEmpty.groupBy_$sgroupBy [Occ=LoopBreaker]
  :: forall a.
     (a -> a -> GHC.Types.Bool) -> [a] -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eq0_sdpEZ eta_sdpF0]
        case eta_sdpF0 of {
          [] -> [] [];
          : x_sdpF2 xs_sdpF3 [Occ=Once] ->
              let {
                ds_sdpF4 [Dmd=<L,U(1*U,1*U)>] :: ([a_Xdo51], [a_Xdo51])
                [LclId] =
                    [eq0_sdpEZ x_sdpF2 xs_sdpF3] \u []
                        let {
                          sat_sdpF5 [Occ=Once, Dmd=<L,C(U)>] :: a_Xdo51 -> GHC.Types.Bool
                          [LclId] =
                              [eq0_sdpEZ x_sdpF2] \u [] eq0_sdpEZ x_sdpF2;
                        } in 
                          case GHC.List.$wspan sat_sdpF5 xs_sdpF3 of {
                            (#,#) ww1_sdpF7 [Occ=Once] ww2_sdpF8 [Occ=Once] ->
                                (,) [ww1_sdpF7 ww2_sdpF8];
                          }; } in
              let {
                sat_sdpFh [Occ=Once] :: [GHC.Base.NonEmpty a_Xdo51]
                [LclId] =
                    [eq0_sdpEZ ds_sdpF4] \u []
                        case ds_sdpF4 of {
                          (,) _ [Occ=Dead] zs_sdpFg [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdpEZ zs_sdpFg;
                        }; } in
              let {
                sat_sdpFc [Occ=Once] :: [a_Xdo51]
                [LclId] =
                    [ds_sdpF4] \u []
                        case ds_sdpF4 of {
                          (,) ys_sdpFa [Occ=Once] _ [Occ=Dead] -> ys_sdpFa;
                        }; } in
              let {
                sat_sdpFd [Occ=Once] :: GHC.Base.NonEmpty a_Xdo51
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdpF2 sat_sdpFc];
              } in  : [sat_sdpFd sat_sdpFh];
        };

Data.List.NonEmpty.groupBy
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     (a -> a -> GHC.Types.Bool) -> f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpFi eq0_sdpFj eta_sdpFk]
        case Data.Foldable.toList $dFoldable_sdpFi eta_sdpFk of {
          [] -> [] [];
          : x_sdpFm xs_sdpFn [Occ=Once] ->
              let {
                ds_sdpFo [Dmd=<L,U(1*U,1*U)>] :: ([a_ado4Z], [a_ado4Z])
                [LclId] =
                    [eq0_sdpFj x_sdpFm xs_sdpFn] \u []
                        let {
                          sat_sdpFp [Occ=Once, Dmd=<L,C(U)>] :: a_ado4Z -> GHC.Types.Bool
                          [LclId] =
                              [eq0_sdpFj x_sdpFm] \u [] eq0_sdpFj x_sdpFm;
                        } in 
                          case GHC.List.$wspan sat_sdpFp xs_sdpFn of {
                            (#,#) ww1_sdpFr [Occ=Once] ww2_sdpFs [Occ=Once] ->
                                (,) [ww1_sdpFr ww2_sdpFs];
                          }; } in
              let {
                sat_sdpFB [Occ=Once] :: [GHC.Base.NonEmpty a_ado4Z]
                [LclId] =
                    [eq0_sdpFj ds_sdpFo] \u []
                        case ds_sdpFo of {
                          (,) _ [Occ=Dead] zs_sdpFA [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdpFj zs_sdpFA;
                        }; } in
              let {
                sat_sdpFw [Occ=Once] :: [a_ado4Z]
                [LclId] =
                    [ds_sdpFo] \u []
                        case ds_sdpFo of {
                          (,) ys_sdpFu [Occ=Once] _ [Occ=Dead] -> ys_sdpFu;
                        }; } in
              let {
                sat_sdpFx [Occ=Once] :: GHC.Base.NonEmpty a_ado4Z
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdpFm sat_sdpFw];
              } in  : [sat_sdpFx sat_sdpFB];
        };

Data.List.NonEmpty.groupWith
  :: forall (f :: * -> *) b a.
     (Data.Foldable.Foldable f, GHC.Classes.Eq b) =>
     (a -> b) -> f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpFC $dEq_sdpFD f1_sdpFE eta_sdpFF]
        case Data.Foldable.toList $dFoldable_sdpFC eta_sdpFF of {
          [] -> [] [];
          : x_sdpFH xs_sdpFI [Occ=Once] ->
              let {
                eq0_sdpFJ [Dmd=<L,C(C(U))>] :: a_ado5N -> a_ado5N -> GHC.Types.Bool
                [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                    [$dEq_sdpFD f1_sdpFE] \r [x1_sdpFK y_sdpFL]
                        let {
                          sat_sdpFN [Occ=Once] :: b_ado5M
                          [LclId] =
                              [f1_sdpFE y_sdpFL] \u [] f1_sdpFE y_sdpFL; } in
                        let {
                          sat_sdpFM [Occ=Once] :: b_ado5M
                          [LclId] =
                              [f1_sdpFE x1_sdpFK] \u [] f1_sdpFE x1_sdpFK;
                        } in  GHC.Classes.== $dEq_sdpFD sat_sdpFM sat_sdpFN; } in
              let {
                ds_sdpFO [Dmd=<L,U(1*U,1*U)>] :: ([a_ado5N], [a_ado5N])
                [LclId] =
                    [x_sdpFH xs_sdpFI eq0_sdpFJ] \u []
                        let {
                          sat_sdpFP [Occ=Once] :: a_ado5N -> GHC.Types.Bool
                          [LclId] =
                              [x_sdpFH eq0_sdpFJ] \r [eta_B1] eq0_sdpFJ x_sdpFH eta_B1;
                        } in 
                          case GHC.List.$wspan sat_sdpFP xs_sdpFI of {
                            (#,#) ww1_sdpFR [Occ=Once] ww2_sdpFS [Occ=Once] ->
                                (,) [ww1_sdpFR ww2_sdpFS];
                          }; } in
              let {
                sat_sdpG1 [Occ=Once] :: [GHC.Base.NonEmpty a_ado5N]
                [LclId] =
                    [eq0_sdpFJ ds_sdpFO] \u []
                        case ds_sdpFO of {
                          (,) _ [Occ=Dead] zs_sdpG0 [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdpFJ zs_sdpG0;
                        }; } in
              let {
                sat_sdpFW [Occ=Once] :: [a_ado5N]
                [LclId] =
                    [ds_sdpFO] \u []
                        case ds_sdpFO of {
                          (,) ys_sdpFU [Occ=Once] _ [Occ=Dead] -> ys_sdpFU;
                        }; } in
              let {
                sat_sdpFX [Occ=Once] :: GHC.Base.NonEmpty a_ado5N
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdpFH sat_sdpFW];
              } in  : [sat_sdpFX sat_sdpG1];
        };

Data.List.NonEmpty.group
  :: forall (f :: * -> *) a.
     (Data.Foldable.Foldable f, GHC.Classes.Eq a) =>
     f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*U(1*C(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpG2 $dEq_sdpG3 eta_sdpG4]
        let {
          sat_sdpG5 [Occ=Once, Dmd=<L,C(C(U))>]
            :: a_ado6W -> a_ado6W -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdpG3] \u [] GHC.Classes.== $dEq_sdpG3;
        } in 
          Data.List.NonEmpty.groupBy $dFoldable_sdpG2 sat_sdpG5 eta_sdpG4;

Data.List.NonEmpty.isPrefixOf
  :: forall a.
     GHC.Classes.Eq a =>
     [a] -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><S,1*U><L,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdpG6 ds_sdpG7 ds1_sdpG8]
        case ds_sdpG7 of {
          [] -> GHC.Types.True [];
          : y_sdpGa [Occ=Once] ys_sdpGb [Occ=Once] ->
              case ds1_sdpG8 of {
                GHC.Base.:| x_sdpGd [Occ=Once] xs_sdpGe [Occ=Once] ->
                    case GHC.Classes.== $dEq_sdpG6 y_sdpGa x_sdpGd of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True ->
                          Data.OldList.isPrefixOf $dEq_sdpG6 ys_sdpGb xs_sdpGe;
                    };
              };
        };

lvl1_rdpwu :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.!! negative argument"#;

Data.List.NonEmpty.!!1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rdpwu of sat_sdpGg {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sdpGg;
        };

Data.List.NonEmpty.$w!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. a -> [a] -> GHC.Prim.Int# -> a
[GblId, Arity=3, Str=<L,1*U><L,1*U><S,1*U>, Unf=OtherCon []] =
    [] \r [ww_sdpGh ww1_sdpGi ww2_sdpGj]
        case ww2_sdpGj of wild_sdpGk {
          __DEFAULT ->
              case ># [wild_sdpGk 0#] of {
                __DEFAULT -> Data.List.NonEmpty.!!1;
                1# ->
                    case -# [wild_sdpGk 1#] of sat_sdpGm {
                      __DEFAULT -> GHC.List.$w!! ww1_sdpGi sat_sdpGm;
                    };
              };
          0# -> ww_sdpGh;
        };

Data.List.NonEmpty.!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int -> a
[GblId,
 Arity=2,
 Str=<S,1*U(1*U,1*U)><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpGn w1_sdpGo]
        case w_sdpGn of {
          GHC.Base.:| ww1_sdpGq [Occ=Once] ww2_sdpGr [Occ=Once] ->
              case w1_sdpGo of {
                GHC.Types.I# ww4_sdpGt [Occ=Once] ->
                    Data.List.NonEmpty.$w!! ww1_sdpGq ww2_sdpGr ww4_sdpGt;
              };
        };

Data.List.NonEmpty.zip
  :: forall a b.
     GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdpGu ds1_sdpGv]
        let {
          sat_sdpGM [Occ=Once] :: [(a_ado4o, b_ado4p)]
          [LclId] =
              [ds_sdpGu ds1_sdpGv] \u []
                  case ds_sdpGu of {
                    GHC.Base.:| _ [Occ=Dead] xs_sdpGH [Occ=Once] ->
                        let {
                          sat_sdpGL [Occ=Once, Dmd=<L,1*U>] :: [b_ado4p]
                          [LclId] =
                              [ds1_sdpGv] \s []
                                  case ds1_sdpGv of {
                                    GHC.Base.:| _ [Occ=Dead] ys_sdpGK [Occ=Once] -> ys_sdpGK;
                                  };
                        } in  GHC.List.zip xs_sdpGH sat_sdpGL;
                  }; } in
        let {
          sat_sdpGD [Occ=Once] :: b_ado4p
          [LclId] =
              [ds1_sdpGv] \u []
                  case ds1_sdpGv of {
                    GHC.Base.:| y_sdpGB [Occ=Once] _ [Occ=Dead] -> y_sdpGB;
                  }; } in
        let {
          sat_sdpGz [Occ=Once] :: a_ado4o
          [LclId] =
              [ds_sdpGu] \u []
                  case ds_sdpGu of {
                    GHC.Base.:| x_sdpGx [Occ=Once] _ [Occ=Dead] -> x_sdpGx;
                  }; } in
        let {
          sat_sdpGE [Occ=Once] :: (a_ado4o, b_ado4p)
          [LclId] =
              CCCS (,)! [sat_sdpGz sat_sdpGD];
        } in  GHC.Base.:| [sat_sdpGE sat_sdpGM];

Data.List.NonEmpty.zipWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b
     -> GHC.Base.NonEmpty c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpGN w1_sdpGO w2_sdpGP]
        let {
          sat_sdpH6 [Occ=Once] :: [c_sdp3h]
          [LclId] =
              [w_sdpGN w1_sdpGO w2_sdpGP] \u []
                  case w1_sdpGO of {
                    GHC.Base.:| _ [Occ=Dead] xs_sdpH1 [Occ=Once] ->
                        let {
                          sat_sdpH5 [Occ=Once, Dmd=<L,1*U>] :: [b_sdp3g]
                          [LclId] =
                              [w2_sdpGP] \s []
                                  case w2_sdpGP of {
                                    GHC.Base.:| _ [Occ=Dead] ys_sdpH4 [Occ=Once] -> ys_sdpH4;
                                  };
                        } in  GHC.List.zipWith w_sdpGN xs_sdpH1 sat_sdpH5;
                  }; } in
        let {
          sat_sdpGY [Occ=Once] :: c_sdp3h
          [LclId] =
              [w_sdpGN w1_sdpGO w2_sdpGP] \u []
                  let {
                    sat_sdpGX [Occ=Once] :: b_sdp3g
                    [LclId] =
                        [w2_sdpGP] \u []
                            case w2_sdpGP of {
                              GHC.Base.:| y_sdpGV [Occ=Once] _ [Occ=Dead] -> y_sdpGV;
                            }; } in
                  let {
                    sat_sdpGT [Occ=Once] :: a_sdp3f
                    [LclId] =
                        [w1_sdpGO] \u []
                            case w1_sdpGO of {
                              GHC.Base.:| x_sdpGR [Occ=Once] _ [Occ=Dead] -> x_sdpGR;
                            };
                  } in  w_sdpGN sat_sdpGT sat_sdpGX;
        } in  GHC.Base.:| [sat_sdpGY sat_sdpH6];

Data.List.NonEmpty.unzip
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     f (a, b) -> (f a, f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sdpH7 xs_sdpH8]
        let {
          sat_sdpHa [Occ=Once] :: f_ado3Y b_ado40
          [LclId] =
              [$dFunctor_sdpH7 xs_sdpH8] \u []
                  GHC.Base.fmap $dFunctor_sdpH7 Data.Tuple.snd xs_sdpH8; } in
        let {
          sat_sdpH9 [Occ=Once] :: f_ado3Y a_ado3Z
          [LclId] =
              [$dFunctor_sdpH7 xs_sdpH8] \u []
                  GHC.Base.fmap $dFunctor_sdpH7 Data.Tuple.fst xs_sdpH8;
        } in  (,) [sat_sdpH9 sat_sdpHa];

Data.List.NonEmpty.nubBy [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> a -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpHb w1_sdpHc]
        case w1_sdpHc of {
          GHC.Base.:| ww1_sdpHe ww2_sdpHf [Occ=Once] ->
              let {
                sat_sdpHk [Occ=Once] :: [a_sdp3p]
                [LclId] =
                    [w_sdpHb ww1_sdpHe ww2_sdpHf] \u []
                        let {
                          sat_sdpHi [Occ=Once] :: a_sdp3p -> GHC.Types.Bool
                          [LclId] =
                              [w_sdpHb ww1_sdpHe] \r [b_sdpHg]
                                  case w_sdpHb ww1_sdpHe b_sdpHg of {
                                    GHC.Types.False -> GHC.Types.True [];
                                    GHC.Types.True -> GHC.Types.False [];
                                  };
                        } in 
                          case GHC.List.filter sat_sdpHi ww2_sdpHf of sat_sdpHj {
                            __DEFAULT -> Data.OldList.nubBy w_sdpHb sat_sdpHj;
                          };
              } in  GHC.Base.:| [ww1_sdpHe sat_sdpHk];
        };

Data.List.NonEmpty.nub
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(U)),A)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dEq_sdpHl eta_sdpHm]
        case eta_sdpHm of {
          GHC.Base.:| ww1_sdpHo ww2_sdpHp [Occ=Once] ->
              let {
                sat_sdpHv [Occ=Once] :: [a_ado3R]
                [LclId] =
                    [$dEq_sdpHl ww1_sdpHo ww2_sdpHp] \u []
                        let {
                          w_sdpHq [Dmd=<L,C(C1(U))>] :: a_ado3R -> a_ado3R -> GHC.Types.Bool
                          [LclId] =
                              [$dEq_sdpHl] \u [] GHC.Classes.== $dEq_sdpHl; } in
                        let {
                          sat_sdpHt [Occ=Once] :: a_ado3R -> GHC.Types.Bool
                          [LclId] =
                              [ww1_sdpHo w_sdpHq] \r [b_sdpHr]
                                  case w_sdpHq ww1_sdpHo b_sdpHr of {
                                    GHC.Types.False -> GHC.Types.True [];
                                    GHC.Types.True -> GHC.Types.False [];
                                  };
                        } in 
                          case GHC.List.filter sat_sdpHt ww2_sdpHp of sat_sdpHu {
                            __DEFAULT -> Data.OldList.nubBy w_sdpHq sat_sdpHu;
                          };
              } in  GHC.Base.:| [ww1_sdpHo sat_sdpHv];
        };

Data.List.NonEmpty.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.List.NonEmpty.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.List.NonEmpty.$trModule4];

Data.List.NonEmpty.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.List.NonEmpty"#;

Data.List.NonEmpty.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.List.NonEmpty.$trModule2];

Data.List.NonEmpty.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.List.NonEmpty.$trModule3
                                     Data.List.NonEmpty.$trModule1];

Data.List.NonEmpty.groupAllWith
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b) -> [a] -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdpHw eta_sdpHx eta1_sdpHy]
        let {
          sat_sdpHF [Occ=Once] :: [a_ado65]
          [LclId] =
              [$dOrd_sdpHw eta_sdpHx eta1_sdpHy] \u []
                  let {
                    sat_sdpHE [Occ=Once] :: a_ado65 -> a_ado65 -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sdpHw eta_sdpHx] \r [x_sdpHA y_sdpHB]
                            let {
                              sat_sdpHD [Occ=Once] :: b_ado64
                              [LclId] =
                                  [eta_sdpHx y_sdpHB] \u [] eta_sdpHx y_sdpHB; } in
                            let {
                              sat_sdpHC [Occ=Once] :: b_ado64
                              [LclId] =
                                  [eta_sdpHx x_sdpHA] \u [] eta_sdpHx x_sdpHA;
                            } in  GHC.Classes.compare $dOrd_sdpHw sat_sdpHC sat_sdpHD;
                  } in  Data.OldList.sortBy sat_sdpHE eta1_sdpHy; } in
        let {
          sat_sdpHz [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_ado64
          [LclId] =
              [$dOrd_sdpHw] \u [] GHC.Classes.$p1Ord $dOrd_sdpHw;
        } in 
          Data.List.NonEmpty.groupWith
              Data.Foldable.$fFoldable[] sat_sdpHz eta_sdpHx sat_sdpHF;

Data.List.NonEmpty.groupBy1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> a -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpHG w1_sdpHH]
        case w1_sdpHH of {
          GHC.Base.:| ww1_sdpHJ ww2_sdpHK [Occ=Once] ->
              let {
                ds_sdpHL [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp3G], [a_sdp3G])
                [LclId] =
                    [w_sdpHG ww1_sdpHJ ww2_sdpHK] \u []
                        let {
                          sat_sdpHM [Occ=Once, Dmd=<L,C(U)>] :: a_sdp3G -> GHC.Types.Bool
                          [LclId] =
                              [w_sdpHG ww1_sdpHJ] \u [] w_sdpHG ww1_sdpHJ;
                        } in 
                          case GHC.List.$wspan sat_sdpHM ww2_sdpHK of {
                            (#,#) ww4_sdpHO [Occ=Once] ww5_sdpHP [Occ=Once] ->
                                (,) [ww4_sdpHO ww5_sdpHP];
                          }; } in
              let {
                sat_sdpHY [Occ=Once] :: [GHC.Base.NonEmpty a_sdp3G]
                [LclId] =
                    [w_sdpHG ds_sdpHL] \u []
                        case ds_sdpHL of {
                          (,) _ [Occ=Dead] zs_sdpHX [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy w_sdpHG zs_sdpHX;
                        }; } in
              let {
                sat_sdpHT [Occ=Once] :: [a_sdp3G]
                [LclId] =
                    [ds_sdpHL] \u []
                        case ds_sdpHL of {
                          (,) ys_sdpHR [Occ=Once] _ [Occ=Dead] -> ys_sdpHR;
                        }; } in
              let {
                sat_sdpHU [Occ=Once] :: GHC.Base.NonEmpty a_sdp3G
                [LclId] =
                    CCCS GHC.Base.:|! [ww1_sdpHJ sat_sdpHT];
              } in  GHC.Base.:| [sat_sdpHU sat_sdpHY];
        };

Data.List.NonEmpty.group1
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C(U)),A)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dEq_sdpHZ eta_sdpI0]
        case eta_sdpI0 of {
          GHC.Base.:| ww1_sdpI2 ww2_sdpI3 [Occ=Once] ->
              let {
                w_sdpI4 [Dmd=<L,C(C(U))>] :: a_ado6D -> a_ado6D -> GHC.Types.Bool
                [LclId] =
                    [$dEq_sdpHZ] \u [] GHC.Classes.== $dEq_sdpHZ; } in
              let {
                ds_sdpI5 [Dmd=<L,U(1*U,1*U)>] :: ([a_ado6D], [a_ado6D])
                [LclId] =
                    [ww1_sdpI2 ww2_sdpI3 w_sdpI4] \u []
                        let {
                          sat_sdpI6 [Occ=Once, Dmd=<L,C(U)>] :: a_ado6D -> GHC.Types.Bool
                          [LclId] =
                              [ww1_sdpI2 w_sdpI4] \u [] w_sdpI4 ww1_sdpI2;
                        } in 
                          case GHC.List.$wspan sat_sdpI6 ww2_sdpI3 of {
                            (#,#) ww4_sdpI8 [Occ=Once] ww5_sdpI9 [Occ=Once] ->
                                (,) [ww4_sdpI8 ww5_sdpI9];
                          }; } in
              let {
                sat_sdpIi [Occ=Once] :: [GHC.Base.NonEmpty a_ado6D]
                [LclId] =
                    [w_sdpI4 ds_sdpI5] \u []
                        case ds_sdpI5 of {
                          (,) _ [Occ=Dead] zs_sdpIh [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy w_sdpI4 zs_sdpIh;
                        }; } in
              let {
                sat_sdpId [Occ=Once] :: [a_ado6D]
                [LclId] =
                    [ds_sdpI5] \u []
                        case ds_sdpI5 of {
                          (,) ys_sdpIb [Occ=Once] _ [Occ=Dead] -> ys_sdpIb;
                        }; } in
              let {
                sat_sdpIe [Occ=Once] :: GHC.Base.NonEmpty a_ado6D
                [LclId] =
                    CCCS GHC.Base.:|! [ww1_sdpI2 sat_sdpId];
              } in  GHC.Base.:| [sat_sdpIe sat_sdpIi];
        };

Data.List.NonEmpty.$wgroupWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Eq b =>
     (a -> b)
     -> a -> [a] -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,C(U)><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdpIj w1_sdpIk ww_sdpIl ww1_sdpIm]
        let {
          eq_sdpIn [Dmd=<L,C(C(U))>] :: a_sdp3T -> a_sdp3T -> GHC.Types.Bool
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w_sdpIj w1_sdpIk] \r [x_sdpIo y_sdpIp]
                  let {
                    sat_sdpIr [Occ=Once] :: b_sdp3S
                    [LclId] =
                        [w1_sdpIk y_sdpIp] \u [] w1_sdpIk y_sdpIp; } in
                  let {
                    sat_sdpIq [Occ=Once] :: b_sdp3S
                    [LclId] =
                        [w1_sdpIk x_sdpIo] \u [] w1_sdpIk x_sdpIo;
                  } in  GHC.Classes.== w_sdpIj sat_sdpIq sat_sdpIr; } in
        let {
          ds_sdpIs [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp3T], [a_sdp3T])
          [LclId] =
              [ww_sdpIl ww1_sdpIm eq_sdpIn] \u []
                  let {
                    sat_sdpIt [Occ=Once] :: a_sdp3T -> GHC.Types.Bool
                    [LclId] =
                        [ww_sdpIl eq_sdpIn] \r [eta_B1] eq_sdpIn ww_sdpIl eta_B1;
                  } in 
                    case GHC.List.$wspan sat_sdpIt ww1_sdpIm of {
                      (#,#) ww3_sdpIv [Occ=Once] ww4_sdpIw [Occ=Once] ->
                          (,) [ww3_sdpIv ww4_sdpIw];
                    }; } in
        let {
          sat_sdpIF [Occ=Once] :: [GHC.Base.NonEmpty a_sdp3T]
          [LclId] =
              [eq_sdpIn ds_sdpIs] \u []
                  case ds_sdpIs of {
                    (,) _ [Occ=Dead] zs_sdpIE [Occ=Once] ->
                        Data.List.NonEmpty.groupBy_$sgroupBy eq_sdpIn zs_sdpIE;
                  }; } in
        let {
          sat_sdpIA [Occ=Once] :: [a_sdp3T]
          [LclId] =
              [ds_sdpIs] \u []
                  case ds_sdpIs of {
                    (,) ys_sdpIy [Occ=Once] _ [Occ=Dead] -> ys_sdpIy;
                  }; } in
        let {
          sat_sdpIB [Occ=Once] :: GHC.Base.NonEmpty a_sdp3T
          [LclId] =
              CCCS GHC.Base.:|! [ww_sdpIl sat_sdpIA];
        } in  (#,#) [sat_sdpIB sat_sdpIF];

Data.List.NonEmpty.groupWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Eq b =>
     (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,C(U)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpIG w1_sdpIH w2_sdpII]
        case w2_sdpII of {
          GHC.Base.:| ww1_sdpIK [Occ=Once] ww2_sdpIL [Occ=Once] ->
              case
                  Data.List.NonEmpty.$wgroupWith1
                      w_sdpIG w1_sdpIH ww1_sdpIK ww2_sdpIL
              of
              { (#,#) ww4_sdpIN [Occ=Once] ww5_sdpIO [Occ=Once] ->
                    GHC.Base.:| [ww4_sdpIN ww5_sdpIO];
              };
        };

Data.List.NonEmpty.$wgroupAllWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b)
     -> GHC.Base.NonEmpty a
     -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId,
 Arity=3,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpIP w1_sdpIQ w2_sdpIR]
        let {
          sat_sdpJ0 [Occ=Once] :: [a_sdp47]
          [LclId] =
              [w2_sdpIR] \u []
                  case w2_sdpIR of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpIZ [Occ=Once] -> as_sdpIZ;
                  }; } in
        let {
          sat_sdpIW [Occ=Once] :: a_sdp47
          [LclId] =
              [w2_sdpIR] \u []
                  case w2_sdpIR of {
                    GHC.Base.:| a1_sdpIU [Occ=Once] _ [Occ=Dead] -> a1_sdpIU;
                  }; } in
        let {
          sat_sdpJ1 [Occ=Once] :: [a_sdp47]
          [LclId] =
              CCCS :! [sat_sdpIW sat_sdpJ0]; } in
        let {
          sat_sdpIS [Occ=Once] :: a_sdp47 -> a_sdp47 -> GHC.Types.Ordering
          [LclId] =
              [w_sdpIP w1_sdpIQ] \r [eta_B2 eta_B1]
                  Data.Ord.comparing w_sdpIP w1_sdpIQ eta_B2 eta_B1;
        } in 
          case Data.OldList.sortBy sat_sdpIS sat_sdpJ1 of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpJ4 [Occ=Once] as_sdpJ5 [Occ=Once] ->
                let {
                  sat_sdpJ6 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
                    :: GHC.Classes.Eq b_sdp46
                  [LclId] =
                      [w_sdpIP] \u [] GHC.Classes.$p1Ord w_sdpIP;
                } in 
                  Data.List.NonEmpty.$wgroupWith1
                      sat_sdpJ6 w1_sdpIQ a1_sdpJ4 as_sdpJ5;
          };

Data.List.NonEmpty.groupAllWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=3,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpJ7 w1_sdpJ8 w2_sdpJ9]
        case
            Data.List.NonEmpty.$wgroupAllWith1 w_sdpJ7 w1_sdpJ8 w2_sdpJ9
        of
        { (#,#) ww1_sdpJb [Occ=Once] ww2_sdpJc [Occ=Once] ->
              GHC.Base.:| [ww1_sdpJb ww2_sdpJc];
        };

Data.List.NonEmpty.$wxor [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Bool -> [GHC.Types.Bool] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sdpJd ww1_sdpJe]
        let {
          go_sdpJf [Occ=LoopBreaker] :: [GHC.Types.Bool] -> GHC.Types.Bool
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [ww_sdpJd go_sdpJf] \r [ds_sdpJg]
                  case ds_sdpJg of {
                    [] -> ww_sdpJd;
                    : y_sdpJi [Occ=Once!] ys_sdpJj [Occ=Once*] ->
                        case y_sdpJi of {
                          GHC.Types.False -> go_sdpJf ys_sdpJj;
                          GHC.Types.True ->
                              case go_sdpJf ys_sdpJj of {
                                GHC.Types.False -> GHC.Types.True [];
                                GHC.Types.True -> GHC.Types.False [];
                              };
                        };
                  };
        } in  go_sdpJf ww1_sdpJe;

Data.List.NonEmpty.xor [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.NonEmpty GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpJm]
        case w_sdpJm of {
          GHC.Base.:| ww1_sdpJo [Occ=Once] ww2_sdpJp [Occ=Once] ->
              Data.List.NonEmpty.$wxor ww1_sdpJo ww2_sdpJp;
        };

Data.List.NonEmpty.length
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdpJq]
        case ds_sdpJq of {
          GHC.Base.:| _ [Occ=Dead] xs_sdpJt [Occ=Once] ->
              case GHC.List.$wlenAcc xs_sdpJt 0# of ww2_sdpJu {
                __DEFAULT ->
                    case +# [1# ww2_sdpJu] of sat_sdpJv {
                      __DEFAULT -> GHC.Types.I# [sat_sdpJv];
                    };
              };
        };


==================== STG syntax: ====================
2018-03-16 16:08:35.252801131 UTC

Data.List.NonEmpty.nonEmpty
  :: forall a. [a] -> GHC.Base.Maybe (GHC.Base.NonEmpty a)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sdpww]
        case ds_sdpww of {
          [] -> GHC.Base.Nothing [];
          : a1_sdpwy [Occ=Once] as_sdpwz [Occ=Once] ->
              let {
                sat_sdpwA [Occ=Once] :: GHC.Base.NonEmpty a_adod9
                [LclId] =
                    CCCS GHC.Base.:|! [a1_sdpwy as_sdpwz];
              } in  GHC.Base.Just [sat_sdpwA];
        };

Data.List.NonEmpty.uncons
  :: forall a.
     GHC.Base.NonEmpty a -> (a, GHC.Base.Maybe (GHC.Base.NonEmpty a))
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdpwB]
        let {
          sat_sdpwN [Occ=Once] :: GHC.Base.Maybe (GHC.Base.NonEmpty a_adode)
          [LclId] =
              [ds_sdpwB] \u []
                  case ds_sdpwB of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpwI [Occ=Once!] ->
                        case as_sdpwI of {
                          [] -> GHC.Base.Nothing [];
                          : a2_sdpwK [Occ=Once] as1_sdpwL [Occ=Once] ->
                              let {
                                sat_sdpwM [Occ=Once] :: GHC.Base.NonEmpty a_adode
                                [LclId] =
                                    CCCS GHC.Base.:|! [a2_sdpwK as1_sdpwL];
                              } in  GHC.Base.Just [sat_sdpwM];
                        };
                  }; } in
        let {
          sat_sdpwF [Occ=Once] :: a_adode
          [LclId] =
              [ds_sdpwB] \u []
                  case ds_sdpwB of {
                    GHC.Base.:| a1_sdpwD [Occ=Once] _ [Occ=Dead] -> a1_sdpwD;
                  };
        } in  (,) [sat_sdpwF sat_sdpwN];

Data.List.NonEmpty.$wunfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> (b, GHC.Base.Maybe a)) -> a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,1*U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdpwO w1_sdpwP]
        case w_sdpwO w1_sdpwP of {
          (,) b1_sdpwR [Occ=Once] mc_sdpwS [Occ=Once!] ->
              let {
                sat_sdpx3 [Occ=Once] :: [b_sdp0I]
                [LclId] =
                    [w_sdpwO mc_sdpwS] \u []
                        case mc_sdpwS of {
                          GHC.Base.Nothing -> [] [];
                          GHC.Base.Just x_sdpwU [Occ=Once] ->
                              let {
                                go_sdpwV [Occ=LoopBreaker] :: a_sdp0H -> [b_sdp0I]
                                [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                    sat-only [w_sdpwO go_sdpwV] \r [c_sdpwW]
                                        case w_sdpwO c_sdpwW of {
                                          (,) d_sdpwY [Occ=Once] me_sdpwZ [Occ=Once!] ->
                                              let {
                                                sat_sdpx2 [Occ=Once] :: [b_sdp0I]
                                                [LclId] =
                                                    [go_sdpwV me_sdpwZ] \u []
                                                        case me_sdpwZ of {
                                                          GHC.Base.Nothing -> [] [];
                                                          GHC.Base.Just x1_sdpx1 [Occ=Once] ->
                                                              go_sdpwV x1_sdpx1;
                                                        };
                                              } in  : [d_sdpwY sat_sdpx2];
                                        };
                              } in  go_sdpwV x_sdpwU;
                        };
              } in  (#,#) [b1_sdpwR sat_sdpx3];
        };

Data.List.NonEmpty.unfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> (b, GHC.Base.Maybe a)) -> a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdpx4 w1_sdpx5]
        case Data.List.NonEmpty.$wunfoldr w_sdpx4 w1_sdpx5 of {
          (#,#) ww1_sdpx7 [Occ=Once] ww2_sdpx8 [Occ=Once] ->
              GHC.Base.:| [ww1_sdpx7 ww2_sdpx8];
        };

Data.List.NonEmpty.head :: forall a. GHC.Base.NonEmpty a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sdpx9]
        case ds_sdpx9 of {
          GHC.Base.:| a1_sdpxb [Occ=Once] _ [Occ=Dead] -> a1_sdpxb;
        };

Data.List.NonEmpty.tail :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sdpxd]
        case ds_sdpxd of {
          GHC.Base.:| _ [Occ=Dead] as_sdpxg [Occ=Once] -> as_sdpxg;
        };

poly_go_rdpws :: forall a. [a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ds_sdpxh eta_sdpxi]
        case ds_sdpxh of {
          [] -> eta_sdpxi;
          : y_sdpxk [Occ=Once] ys_sdpxl [Occ=Once] ->
              poly_go_rdpws ys_sdpxl y_sdpxk;
        };

Data.List.NonEmpty.last :: forall a. GHC.Base.NonEmpty a -> a
[GblId, Arity=1, Str=<L,U(1*U,1*U)>, Unf=OtherCon []] =
    [] \r [ds_sdpxm]
        let {
          sat_sdpxu [Occ=Once] :: [a_adocF]
          [LclId] =
              [ds_sdpxm] \u []
                  case ds_sdpxm of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpxt [Occ=Once] -> as_sdpxt;
                  }; } in
        let {
          sat_sdpxq [Occ=Once] :: a_adocF
          [LclId] =
              [ds_sdpxm] \u []
                  case ds_sdpxm of {
                    GHC.Base.:| a1_sdpxo [Occ=Once] _ [Occ=Dead] -> a1_sdpxo;
                  }; } in
        let {
          sat_sdpxv [Occ=Once] :: [a_adocF]
          [LclId] =
              CCCS :! [sat_sdpxq sat_sdpxu];
        } in  poly_go_rdpws sat_sdpxv GHC.List.lastError;

Data.List.NonEmpty.init :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sdpxw]
        case ds_sdpxw of {
          GHC.Base.:| a1_sdpxy [Occ=Once] as_sdpxz [Occ=Once] ->
              GHC.List.init1 a1_sdpxy as_sdpxz;
        };

Data.List.NonEmpty.<|
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [a1_sdpxA ds_sdpxB]
        let {
          sat_sdpxJ [Occ=Once] :: [a_adocs]
          [LclId] =
              [ds_sdpxB] \u []
                  case ds_sdpxB of {
                    GHC.Base.:| _ [Occ=Dead] bs_sdpxI [Occ=Once] -> bs_sdpxI;
                  }; } in
        let {
          sat_sdpxF [Occ=Once] :: a_adocs
          [LclId] =
              [ds_sdpxB] \u []
                  case ds_sdpxB of {
                    GHC.Base.:| b_sdpxD [Occ=Once] _ [Occ=Dead] -> b_sdpxD;
                  }; } in
        let {
          sat_sdpxK [Occ=Once] :: [a_adocs]
          [LclId] =
              CCCS :! [sat_sdpxF sat_sdpxJ];
        } in  GHC.Base.:| [a1_sdpxA sat_sdpxK];

Data.List.NonEmpty.cons
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.List.NonEmpty.<| eta_B2 eta_B1;

Data.List.NonEmpty.$wunfold [InlPrag=NOUSERINLINE[0],
                             Occ=LoopBreaker]
  :: forall a b. (a -> (b, GHC.Base.Maybe a)) -> a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S(LS)),C(U(U,1*U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdpxL w1_sdpxM]
        case w_sdpxL w1_sdpxM of {
          (,) b1_sdpxO [Occ=Once*] ds_sdpxP [Occ=Once!] ->
              case ds_sdpxP of {
                GHC.Base.Nothing -> (#,#) [b1_sdpxO GHC.Types.[]];
                GHC.Base.Just c_sdpxR [Occ=Once] ->
                    let {
                      ds1_sdpxS [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty b_sdp0S
                      [LclId] =
                          [w_sdpxL c_sdpxR] \u []
                              case Data.List.NonEmpty.$wunfold w_sdpxL c_sdpxR of {
                                (#,#) ww1_sdpxU [Occ=Once] ww2_sdpxV [Occ=Once] ->
                                    GHC.Base.:| [ww1_sdpxU ww2_sdpxV];
                              }; } in
                    let {
                      sat_sdpy3 [Occ=Once] :: [b_sdp0S]
                      [LclId] =
                          [ds1_sdpxS] \u []
                              case ds1_sdpxS of {
                                GHC.Base.:| _ [Occ=Dead] bs_sdpy2 [Occ=Once] -> bs_sdpy2;
                              }; } in
                    let {
                      sat_sdpxZ [Occ=Once] :: b_sdp0S
                      [LclId] =
                          [ds1_sdpxS] \u []
                              case ds1_sdpxS of {
                                GHC.Base.:| b2_sdpxX [Occ=Once] _ [Occ=Dead] -> b2_sdpxX;
                              }; } in
                    let {
                      sat_sdpy4 [Occ=Once] :: [b_sdp0S]
                      [LclId] =
                          CCCS :! [sat_sdpxZ sat_sdpy3];
                    } in  (#,#) [b1_sdpxO sat_sdpy4];
              };
        };

Data.List.NonEmpty.unfold [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> (b, GHC.Base.Maybe a)) -> a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S(LS)),C(U(U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdpy5 w1_sdpy6]
        case Data.List.NonEmpty.$wunfold w_sdpy5 w1_sdpy6 of {
          (#,#) ww1_sdpy8 [Occ=Once] ww2_sdpy9 [Occ=Once] ->
              GHC.Base.:| [ww1_sdpy8 ww2_sdpy9];
        };

lvl_rdpwt :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.fromList: empty list"#;

Data.List.NonEmpty.cycle1 :: forall a. GHC.Base.NonEmpty a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rdpwt of sat_sdpya {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sdpya;
        };

Data.List.NonEmpty.fromList :: forall a. [a] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sdpyb]
        case ds_sdpyb of {
          [] -> Data.List.NonEmpty.cycle1;
          : a1_sdpyd [Occ=Once] as_sdpye [Occ=Once] ->
              GHC.Base.:| [a1_sdpyd as_sdpye];
        };

Data.List.NonEmpty.reverse [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U(1*U,1*U)>m, Unf=OtherCon []] =
    [] \r [w_sdpyf]
        let {
          sat_sdpyn [Occ=Once] :: [a_sdp0Z]
          [LclId] =
              [w_sdpyf] \u []
                  case w_sdpyf of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpym [Occ=Once] -> as_sdpym;
                  }; } in
        let {
          sat_sdpyj [Occ=Once] :: a_sdp0Z
          [LclId] =
              [w_sdpyf] \u []
                  case w_sdpyf of {
                    GHC.Base.:| a1_sdpyh [Occ=Once] _ [Occ=Dead] -> a1_sdpyh;
                  }; } in
        let {
          sat_sdpyo [Occ=Once] :: [a_sdp0Z]
          [LclId] =
              CCCS :! [sat_sdpyj sat_sdpyn];
        } in 
          case GHC.List.reverse1 sat_sdpyo GHC.Types.[] of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpyr [Occ=Once] as_sdpys [Occ=Once] ->
                GHC.Base.:| [a1_sdpyr as_sdpys];
          };

Data.List.NonEmpty.sortBy
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdpyt eta_sdpyu]
        let {
          sat_sdpyC [Occ=Once] :: [a_ado9j]
          [LclId] =
              [eta_sdpyu] \u []
                  case eta_sdpyu of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpyB [Occ=Once] -> as_sdpyB;
                  }; } in
        let {
          sat_sdpyy [Occ=Once] :: a_ado9j
          [LclId] =
              [eta_sdpyu] \u []
                  case eta_sdpyu of {
                    GHC.Base.:| a1_sdpyw [Occ=Once] _ [Occ=Dead] -> a1_sdpyw;
                  }; } in
        let {
          sat_sdpyD [Occ=Once] :: [a_ado9j]
          [LclId] =
              CCCS :! [sat_sdpyy sat_sdpyC];
        } in 
          case Data.OldList.sortBy f_sdpyt sat_sdpyD of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpyF [Occ=Once] as_sdpyG [Occ=Once] ->
                GHC.Base.:| [a1_sdpyF as_sdpyG];
          };

Data.List.NonEmpty.sortWith [InlPrag=NOUSERINLINE[0]]
  :: forall o a.
     GHC.Classes.Ord o =>
     (a -> o) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpyH w1_sdpyI w2_sdpyJ]
        let {
          sat_sdpyS [Occ=Once] :: [a_sdp16]
          [LclId] =
              [w2_sdpyJ] \u []
                  case w2_sdpyJ of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpyR [Occ=Once] -> as_sdpyR;
                  }; } in
        let {
          sat_sdpyO [Occ=Once] :: a_sdp16
          [LclId] =
              [w2_sdpyJ] \u []
                  case w2_sdpyJ of {
                    GHC.Base.:| a1_sdpyM [Occ=Once] _ [Occ=Dead] -> a1_sdpyM;
                  }; } in
        let {
          sat_sdpyT [Occ=Once] :: [a_sdp16]
          [LclId] =
              CCCS :! [sat_sdpyO sat_sdpyS]; } in
        let {
          sat_sdpyK [Occ=Once] :: a_sdp16 -> a_sdp16 -> GHC.Types.Ordering
          [LclId] =
              [w_sdpyH w1_sdpyI] \r [eta_B2 eta_B1]
                  Data.Ord.comparing w_sdpyH w1_sdpyI eta_B2 eta_B1;
        } in 
          case Data.OldList.sortBy sat_sdpyK sat_sdpyT of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpyW [Occ=Once] as_sdpyX [Occ=Once] ->
                GHC.Base.:| [a1_sdpyW as_sdpyX];
          };

Data.List.NonEmpty.sort [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C(C1(U)),A,A,A,A,A,A)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpyY w1_sdpyZ]
        let {
          sat_sdpz8 [Occ=Once] :: [a_sdp1e]
          [LclId] =
              [w1_sdpyZ] \u []
                  case w1_sdpyZ of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpz7 [Occ=Once] -> as_sdpz7;
                  }; } in
        let {
          sat_sdpz4 [Occ=Once] :: a_sdp1e
          [LclId] =
              [w1_sdpyZ] \u []
                  case w1_sdpyZ of {
                    GHC.Base.:| a1_sdpz2 [Occ=Once] _ [Occ=Dead] -> a1_sdpz2;
                  }; } in
        let {
          sat_sdpz9 [Occ=Once] :: [a_sdp1e]
          [LclId] =
              CCCS :! [sat_sdpz4 sat_sdpz8]; } in
        let {
          sat_sdpz0 [Occ=Once, Dmd=<L,C(C1(U))>]
            :: a_sdp1e -> a_sdp1e -> GHC.Types.Ordering
          [LclId] =
              [w_sdpyY] \u [] GHC.Classes.compare w_sdpyY;
        } in 
          case Data.OldList.sortBy sat_sdpz0 sat_sdpz9 of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpzc [Occ=Once] as_sdpzd [Occ=Once] ->
                GHC.Base.:| [a1_sdpzc as_sdpzd];
          };

Data.List.NonEmpty.inits
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     f a -> GHC.Base.NonEmpty [a]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpze eta_sdpzf]
        let {
          sat_sdpzg [Occ=Once, Dmd=<L,1*U>] :: [a_ado9V]
          [LclId] =
              [$dFoldable_sdpze eta_sdpzf] \s []
                  Data.Foldable.toList $dFoldable_sdpze eta_sdpzf;
        } in 
          case Data.OldList.$winits sat_sdpzg of {
            (#,#) ww1_sdpzi [Occ=Once] ww2_sdpzj [Occ=Once] ->
                GHC.Base.:| [ww1_sdpzi ww2_sdpzj];
          };

Data.List.NonEmpty.tails1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [xs_sdpzk]
        let {
          sat_sdpzo [Occ=Once] :: [[a_sdp1n]]
          [LclId] =
              [xs_sdpzk] \u []
                  case xs_sdpzk of {
                    [] -> [] [];
                    : _ [Occ=Dead] xs'_sdpzn [Occ=Once] ->
                        Data.List.NonEmpty.tails1 xs'_sdpzn;
                  };
        } in  : [xs_sdpzk sat_sdpzo];

Data.List.NonEmpty.tails [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     f a -> GHC.Base.NonEmpty [a]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdpzp w1_sdpzq]
        let {
          sat_sdpzr [Occ=Once] :: [a_sdp1n]
          [LclId] =
              [w_sdpzp w1_sdpzq] \u [] Data.Foldable.toList w_sdpzp w1_sdpzq;
        } in 
          case Data.List.NonEmpty.tails1 sat_sdpzr of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpzu [Occ=Once] as_sdpzv [Occ=Once] ->
                GHC.Base.:| [a1_sdpzu as_sdpzv];
          };

Data.List.NonEmpty.insert
  :: forall (f :: * -> *) a.
     (Data.Foldable.Foldable f, GHC.Classes.Ord a) =>
     a -> f a -> GHC.Base.NonEmpty a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*U(A,1*C(C1(U)),A,A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpzw $dOrd_sdpzx a1_sdpzy eta_sdpzz]
        case Data.Foldable.toList $dFoldable_sdpzw eta_sdpzz of sat_sdpzB {
          __DEFAULT ->
              let {
                sat_sdpzA [Occ=Once, Dmd=<L,C(C1(U))>]
                  :: a_adoav -> a_adoav -> GHC.Types.Ordering
                [LclId] =
                    [$dOrd_sdpzx] \u [] GHC.Classes.compare $dOrd_sdpzx;
              } in 
                case Data.OldList.$winsertBy sat_sdpzA a1_sdpzy sat_sdpzB of {
                  (#,#) ww1_sdpzD [Occ=Once] ww2_sdpzE [Occ=Once] ->
                      GHC.Base.:| [ww1_sdpzD ww2_sdpzE];
                };
        };

Data.List.NonEmpty.scanl
  :: forall (f :: * -> *) b a.
     Data.Foldable.Foldable f =>
     (b -> a -> b) -> b -> f a -> GHC.Base.NonEmpty b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpzF f1_sdpzG z_sdpzH eta_sdpzI]
        let {
          sat_sdpzN [Occ=Once] :: [b_adoaP]
          [LclId] =
              [$dFoldable_sdpzF f1_sdpzG z_sdpzH eta_sdpzI] \u []
                  let {
                    sat_sdpzJ [Occ=Once, Dmd=<L,1*U>] :: [a_adoaQ]
                    [LclId] =
                        [$dFoldable_sdpzF eta_sdpzI] \s []
                            Data.Foldable.toList $dFoldable_sdpzF eta_sdpzI;
                  } in 
                    case GHC.List.$wscanlGo f1_sdpzG z_sdpzH sat_sdpzJ of {
                      (#,#) _ [Occ=Dead] ww2_sdpzM [Occ=Once] -> ww2_sdpzM;
                    };
        } in  GHC.Base.:| [z_sdpzH sat_sdpzN];

Data.List.NonEmpty.scanr
  :: forall (f :: * -> *) a b.
     Data.Foldable.Foldable f =>
     (a -> b -> b) -> b -> f a -> GHC.Base.NonEmpty b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpzO f1_sdpzP z_sdpzQ eta_sdpzR]
        case Data.Foldable.toList $dFoldable_sdpzO eta_sdpzR of sat_sdpzS {
          __DEFAULT ->
              case GHC.List.$wscanr f1_sdpzP z_sdpzQ sat_sdpzS of {
                (#,#) ww1_sdpzU [Occ=Once] ww2_sdpzV [Occ=Once] ->
                    GHC.Base.:| [ww1_sdpzU ww2_sdpzV];
              };
        };

Data.List.NonEmpty.scanl1
  :: forall a.
     (a -> a -> a) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdpzW ds_sdpzX]
        let {
          a1_sdpzY :: a_adobr
          [LclId] =
              [ds_sdpzX] \u []
                  case ds_sdpzX of {
                    GHC.Base.:| a2_sdpA0 [Occ=Once] _ [Occ=Dead] -> a2_sdpA0;
                  }; } in
        let {
          sat_sdpA8 [Occ=Once] :: [a_adobr]
          [LclId] =
              [f_sdpzW ds_sdpzX a1_sdpzY] \u []
                  case ds_sdpzX of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpA4 [Occ=Once] ->
                        case GHC.List.$wscanlGo f_sdpzW a1_sdpzY as_sdpA4 of {
                          (#,#) _ [Occ=Dead] ww2_sdpA7 [Occ=Once] -> ww2_sdpA7;
                        };
                  };
        } in  GHC.Base.:| [a1_sdpzY sat_sdpA8];

Data.List.NonEmpty.scanr1
  :: forall a.
     (a -> a -> a) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdpA9 ds_sdpAa]
        let {
          sat_sdpAi [Occ=Once] :: [a_adobw]
          [LclId] =
              [ds_sdpAa] \u []
                  case ds_sdpAa of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpAh [Occ=Once] -> as_sdpAh;
                  }; } in
        let {
          sat_sdpAe [Occ=Once] :: a_adobw
          [LclId] =
              [ds_sdpAa] \u []
                  case ds_sdpAa of {
                    GHC.Base.:| a1_sdpAc [Occ=Once] _ [Occ=Dead] -> a1_sdpAc;
                  }; } in
        let {
          sat_sdpAj [Occ=Once] :: [a_adobw]
          [LclId] =
              CCCS :! [sat_sdpAe sat_sdpAi];
        } in 
          case GHC.List.scanr1 f_sdpA9 sat_sdpAj of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpAl [Occ=Once] as_sdpAm [Occ=Once] ->
                GHC.Base.:| [a1_sdpAl as_sdpAm];
          };

Data.List.NonEmpty.toList :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_sdpAn]
        let {
          sat_sdpAv [Occ=Once] :: [a_ado7K]
          [LclId] =
              [ds_sdpAn] \u []
                  case ds_sdpAn of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpAu [Occ=Once] -> as_sdpAu;
                  }; } in
        let {
          sat_sdpAr [Occ=Once] :: a_ado7K
          [LclId] =
              [ds_sdpAn] \u []
                  case ds_sdpAn of {
                    GHC.Base.:| a1_sdpAp [Occ=Once] _ [Occ=Dead] -> a1_sdpAp;
                  };
        } in  : [sat_sdpAr sat_sdpAv];

Data.List.NonEmpty.$wtake [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Prim.Int# -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ww_sdpAw w_sdpAx]
        case <# [0# ww_sdpAw] of {
          __DEFAULT -> [] [];
          1# ->
              let {
                sat_sdpAG [Occ=Once] :: [a_sdp1u]
                [LclId] =
                    [w_sdpAx] \u []
                        case w_sdpAx of {
                          GHC.Base.:| _ [Occ=Dead] as_sdpAF [Occ=Once] -> as_sdpAF;
                        }; } in
              let {
                sat_sdpAC [Occ=Once] :: a_sdp1u
                [LclId] =
                    [w_sdpAx] \u []
                        case w_sdpAx of {
                          GHC.Base.:| a1_sdpAA [Occ=Once] _ [Occ=Dead] -> a1_sdpAA;
                        }; } in
              let {
                sat_sdpAH [Occ=Once] :: [a_sdp1u]
                [LclId] =
                    CCCS :! [sat_sdpAC sat_sdpAG];
              } in  GHC.List.$wunsafeTake ww_sdpAw sat_sdpAH;
        };

Data.List.NonEmpty.take [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpAI w1_sdpAJ]
        case w_sdpAI of {
          GHC.Types.I# ww1_sdpAL [Occ=Once] ->
              Data.List.NonEmpty.$wtake ww1_sdpAL w1_sdpAJ;
        };

Data.List.NonEmpty.$wunsafeDrop [InlPrag=NOUSERINLINE[0],
                                 Occ=LoopBreaker]
  :: forall a1. GHC.Prim.Int# -> [a1] -> [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sdpAM w_sdpAN]
        case w_sdpAN of {
          [] -> [] [];
          : _ [Occ=Dead] ipv2_sdpAQ [Occ=Once*] ->
              case ww_sdpAM of ds3_sdpAR {
                __DEFAULT ->
                    case -# [ds3_sdpAR 1#] of sat_sdpAS {
                      __DEFAULT -> Data.List.NonEmpty.$wunsafeDrop sat_sdpAS ipv2_sdpAQ;
                    };
                1# -> ipv2_sdpAQ;
              };
        };

Data.List.NonEmpty.$wdrop [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Prim.Int# -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ww_sdpAT w_sdpAU]
        case <=# [ww_sdpAT 0#] of {
          __DEFAULT ->
              let {
                sat_sdpB3 [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    [w_sdpAU] \u []
                        case w_sdpAU of {
                          GHC.Base.:| _ [Occ=Dead] as_sdpB2 [Occ=Once] -> as_sdpB2;
                        }; } in
              let {
                sat_sdpAZ [Occ=Once] :: a_sdp1K
                [LclId] =
                    [w_sdpAU] \u []
                        case w_sdpAU of {
                          GHC.Base.:| a1_sdpAX [Occ=Once] _ [Occ=Dead] -> a1_sdpAX;
                        }; } in
              let {
                sat_sdpB4 [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    CCCS :! [sat_sdpAZ sat_sdpB3];
              } in  Data.List.NonEmpty.$wunsafeDrop ww_sdpAT sat_sdpB4;
          1# ->
              let {
                sat_sdpBc [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    [w_sdpAU] \u []
                        case w_sdpAU of {
                          GHC.Base.:| _ [Occ=Dead] as_sdpBb [Occ=Once] -> as_sdpBb;
                        }; } in
              let {
                sat_sdpB8 [Occ=Once] :: a_sdp1K
                [LclId] =
                    [w_sdpAU] \u []
                        case w_sdpAU of {
                          GHC.Base.:| a1_sdpB6 [Occ=Once] _ [Occ=Dead] -> a1_sdpB6;
                        };
              } in  : [sat_sdpB8 sat_sdpBc];
        };

Data.List.NonEmpty.drop [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpBd w1_sdpBe]
        case w_sdpBd of {
          GHC.Types.I# ww1_sdpBg [Occ=Once] ->
              Data.List.NonEmpty.$wdrop ww1_sdpBg w1_sdpBe;
        };

Data.List.NonEmpty.splitAt [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpBh w1_sdpBi]
        case w_sdpBh of ww_sdpBj {
          GHC.Types.I# ww1_sdpBk [Occ=Once] ->
              case <=# [ww1_sdpBk 0#] of {
                __DEFAULT ->
                    let {
                      sat_sdpBt [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          [w1_sdpBi] \u []
                              case w1_sdpBi of {
                                GHC.Base.:| _ [Occ=Dead] as_sdpBs [Occ=Once] -> as_sdpBs;
                              }; } in
                    let {
                      sat_sdpBp [Occ=Once] :: a_sdp1S
                      [LclId] =
                          [w1_sdpBi] \u []
                              case w1_sdpBi of {
                                GHC.Base.:| a1_sdpBn [Occ=Once] _ [Occ=Dead] -> a1_sdpBn;
                              }; } in
                    let {
                      sat_sdpBu [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          CCCS :! [sat_sdpBp sat_sdpBt];
                    } in 
                      case GHC.List.$wsplitAt' ww_sdpBj sat_sdpBu of {
                        (#,#) ww3_sdpBw [Occ=Once] ww4_sdpBx [Occ=Once] ->
                            (,) [ww3_sdpBw ww4_sdpBx];
                      };
                1# ->
                    let {
                      sat_sdpBF [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          [w1_sdpBi] \u []
                              case w1_sdpBi of {
                                GHC.Base.:| _ [Occ=Dead] as_sdpBE [Occ=Once] -> as_sdpBE;
                              }; } in
                    let {
                      sat_sdpBB [Occ=Once] :: a_sdp1S
                      [LclId] =
                          [w1_sdpBi] \u []
                              case w1_sdpBi of {
                                GHC.Base.:| a1_sdpBz [Occ=Once] _ [Occ=Dead] -> a1_sdpBz;
                              }; } in
                    let {
                      sat_sdpBG [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          CCCS :! [sat_sdpBB sat_sdpBF];
                    } in  (,) [GHC.Types.[] sat_sdpBG];
              };
        };

Data.List.NonEmpty.takeWhile
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdpBH x_sdpBI]
        let {
          sat_sdpBQ [Occ=Once] :: [a_ado8a]
          [LclId] =
              [x_sdpBI] \u []
                  case x_sdpBI of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpBP [Occ=Once] -> as_sdpBP;
                  }; } in
        let {
          sat_sdpBM [Occ=Once] :: a_ado8a
          [LclId] =
              [x_sdpBI] \u []
                  case x_sdpBI of {
                    GHC.Base.:| a1_sdpBK [Occ=Once] _ [Occ=Dead] -> a1_sdpBK;
                  }; } in
        let {
          sat_sdpBR [Occ=Once] :: [a_ado8a]
          [LclId] =
              CCCS :! [sat_sdpBM sat_sdpBQ];
        } in  GHC.List.takeWhile p_sdpBH sat_sdpBR;

Data.List.NonEmpty.dropWhile
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdpBS x_sdpBT]
        let {
          sat_sdpC1 [Occ=Once] :: [a_ado8h]
          [LclId] =
              [x_sdpBT] \u []
                  case x_sdpBT of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpC0 [Occ=Once] -> as_sdpC0;
                  }; } in
        let {
          sat_sdpBX [Occ=Once] :: a_ado8h
          [LclId] =
              [x_sdpBT] \u []
                  case x_sdpBT of {
                    GHC.Base.:| a1_sdpBV [Occ=Once] _ [Occ=Dead] -> a1_sdpBV;
                  }; } in
        let {
          sat_sdpC2 [Occ=Once] :: [a_ado8h]
          [LclId] =
              CCCS :! [sat_sdpBX sat_sdpC1];
        } in  GHC.List.dropWhile p_sdpBS sat_sdpC2;

Data.List.NonEmpty.span
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [p_sdpC3 x_sdpC4]
        let {
          sat_sdpCc [Occ=Once] :: [a_ado8p]
          [LclId] =
              [x_sdpC4] \u []
                  case x_sdpC4 of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpCb [Occ=Once] -> as_sdpCb;
                  }; } in
        let {
          sat_sdpC8 [Occ=Once] :: a_ado8p
          [LclId] =
              [x_sdpC4] \u []
                  case x_sdpC4 of {
                    GHC.Base.:| a1_sdpC6 [Occ=Once] _ [Occ=Dead] -> a1_sdpC6;
                  }; } in
        let {
          sat_sdpCd [Occ=Once] :: [a_ado8p]
          [LclId] =
              CCCS :! [sat_sdpC8 sat_sdpCc];
        } in 
          case GHC.List.$wspan p_sdpC3 sat_sdpCd of {
            (#,#) ww1_sdpCf [Occ=Once] ww2_sdpCg [Occ=Once] ->
                (,) [ww1_sdpCf ww2_sdpCg];
          };

Data.List.NonEmpty.$wbreak [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpCh w1_sdpCi]
        let {
          sat_sdpCt [Occ=Once] :: [a_sdp23]
          [LclId] =
              [w1_sdpCi] \u []
                  case w1_sdpCi of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpCs [Occ=Once] -> as_sdpCs;
                  }; } in
        let {
          sat_sdpCp [Occ=Once] :: a_sdp23
          [LclId] =
              [w1_sdpCi] \u []
                  case w1_sdpCi of {
                    GHC.Base.:| a1_sdpCn [Occ=Once] _ [Occ=Dead] -> a1_sdpCn;
                  }; } in
        let {
          sat_sdpCu [Occ=Once] :: [a_sdp23]
          [LclId] =
              CCCS :! [sat_sdpCp sat_sdpCt]; } in
        let {
          sat_sdpCl [Occ=Once] :: a_sdp23 -> GHC.Types.Bool
          [LclId] =
              [w_sdpCh] \r [x_sdpCj]
                  case w_sdpCh x_sdpCj of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  GHC.List.$wspan sat_sdpCl sat_sdpCu;

Data.List.NonEmpty.break [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpCv w1_sdpCw]
        case Data.List.NonEmpty.$wbreak w_sdpCv w1_sdpCw of {
          (#,#) ww1_sdpCy [Occ=Once] ww2_sdpCz [Occ=Once] ->
              (,) [ww1_sdpCy ww2_sdpCz];
        };

Data.List.NonEmpty.filter
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdpCA x_sdpCB]
        let {
          sat_sdpCJ [Occ=Once] :: [a_ado8C]
          [LclId] =
              [x_sdpCB] \u []
                  case x_sdpCB of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpCI [Occ=Once] -> as_sdpCI;
                  }; } in
        let {
          sat_sdpCF [Occ=Once] :: a_ado8C
          [LclId] =
              [x_sdpCB] \u []
                  case x_sdpCB of {
                    GHC.Base.:| a1_sdpCD [Occ=Once] _ [Occ=Dead] -> a1_sdpCD;
                  }; } in
        let {
          sat_sdpCK [Occ=Once] :: [a_ado8C]
          [LclId] =
              CCCS :! [sat_sdpCF sat_sdpCJ];
        } in  GHC.List.filter p_sdpCA sat_sdpCK;

Data.List.NonEmpty.$wpartition [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpCL w1_sdpCM]
        let {
          $wgo_sdpCN [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: [a_sdp2f] -> (# [a_sdp2f], [a_sdp2f] #)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sdpCL $wgo_sdpCN] \r [w2_sdpCO]
                  case w2_sdpCO of {
                    [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
                    : y_sdpCQ ys_sdpCR [Occ=Once] ->
                        let {
                          w3_sdpCS [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp2f], [a_sdp2f])
                          [LclId] =
                              [$wgo_sdpCN ys_sdpCR] \u []
                                  case $wgo_sdpCN ys_sdpCR of {
                                    (#,#) ww1_sdpCU [Occ=Once] ww2_sdpCV [Occ=Once] ->
                                        (,) [ww1_sdpCU ww2_sdpCV];
                                  };
                        } in 
                          case w_sdpCL y_sdpCQ of {
                            GHC.Types.False ->
                                let {
                                  sat_sdpD4 [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdpCS] \u []
                                          case w3_sdpCS of {
                                            (,) _ [Occ=Dead] fs_sdpD3 [Occ=Once] -> fs_sdpD3;
                                          }; } in
                                let {
                                  sat_sdpD5 [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      CCCS :! [y_sdpCQ sat_sdpD4]; } in
                                let {
                                  sat_sdpD0 [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdpCS] \u []
                                          case w3_sdpCS of {
                                            (,) ts_sdpCY [Occ=Once] _ [Occ=Dead] -> ts_sdpCY;
                                          };
                                } in  (#,#) [sat_sdpD0 sat_sdpD5];
                            GHC.Types.True ->
                                let {
                                  sat_sdpDe [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdpCS] \u []
                                          case w3_sdpCS of {
                                            (,) _ [Occ=Dead] fs_sdpDd [Occ=Once] -> fs_sdpDd;
                                          }; } in
                                let {
                                  sat_sdpD9 [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdpCS] \u []
                                          case w3_sdpCS of {
                                            (,) ts_sdpD7 [Occ=Once] _ [Occ=Dead] -> ts_sdpD7;
                                          }; } in
                                let {
                                  sat_sdpDa [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      CCCS :! [y_sdpCQ sat_sdpD9];
                                } in  (#,#) [sat_sdpDa sat_sdpDe];
                          };
                  }; } in
        let {
          sat_sdpDm [Occ=Once] :: [a_sdp2f]
          [LclId] =
              [w1_sdpCM] \u []
                  case w1_sdpCM of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpDl [Occ=Once] -> as_sdpDl;
                  }; } in
        let {
          sat_sdpDi [Occ=Once] :: a_sdp2f
          [LclId] =
              [w1_sdpCM] \u []
                  case w1_sdpCM of {
                    GHC.Base.:| a1_sdpDg [Occ=Once] _ [Occ=Dead] -> a1_sdpDg;
                  }; } in
        let {
          sat_sdpDn [Occ=Once] :: [a_sdp2f]
          [LclId] =
              CCCS :! [sat_sdpDi sat_sdpDm];
        } in  $wgo_sdpCN sat_sdpDn;

Data.List.NonEmpty.partition [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpDo w1_sdpDp]
        case Data.List.NonEmpty.$wpartition w_sdpDo w1_sdpDp of {
          (#,#) ww1_sdpDr [Occ=Once] ww2_sdpDs [Occ=Once] ->
              (,) [ww1_sdpDr ww2_sdpDs];
        };

Data.List.NonEmpty.cycle [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_sdpDt]
        let {
          xs'_sdpDu [Occ=LoopBreaker] :: [a_sdp2m]
          [LclId] =
              [w_sdpDt xs'_sdpDu] \u []
                  let {
                    sat_sdpDC [Occ=OnceL] :: [a_sdp2m]
                    [LclId] =
                        [w_sdpDt] \u []
                            case w_sdpDt of {
                              GHC.Base.:| _ [Occ=Dead] as_sdpDB [Occ=Once] -> as_sdpDB;
                            }; } in
                  let {
                    sat_sdpDy [Occ=OnceL] :: a_sdp2m
                    [LclId] =
                        [w_sdpDt] \u []
                            case w_sdpDt of {
                              GHC.Base.:| a1_sdpDw [Occ=Once] _ [Occ=Dead] -> a1_sdpDw;
                            }; } in
                  let {
                    sat_sdpDD [Occ=Once] :: [a_sdp2m]
                    [LclId] =
                        CCCS :! [sat_sdpDy sat_sdpDC];
                  } in  GHC.Base.++ sat_sdpDD xs'_sdpDu;
        } in 
          case xs'_sdpDu of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpDG [Occ=Once] as_sdpDH [Occ=Once] ->
                GHC.Base.:| [a1_sdpDG as_sdpDH];
          };

Data.List.NonEmpty.$wtranspose [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
     -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId, Arity=1, Str=<L,U(U(1*U,1*U),1*U)>, Unf=OtherCon []] =
    [] \r [w_sdpDI]
        let {
          ds_sdpDJ [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty [a_sdp2s]
          [LclId] =
              [w_sdpDI] \u []
                  let {
                    sat_sdpE2 [Occ=OnceL] :: [[a_sdp2s]]
                    [LclId] =
                        [w_sdpDI] \u []
                            case w_sdpDI of {
                              GHC.Base.:| _ [Occ=Dead] as_sdpE1 [Occ=Once] ->
                                  GHC.Base.map Data.List.NonEmpty.toList as_sdpE1;
                            }; } in
                  let {
                    sat_sdpDX [Occ=OnceL] :: [a_sdp2s]
                    [LclId] =
                        [w_sdpDI] \u []
                            case w_sdpDI of {
                              GHC.Base.:| a1_sdpDS [Occ=Once!] _ [Occ=Dead] ->
                                  case a1_sdpDS of {
                                    GHC.Base.:| _ [Occ=Dead] as1_sdpDW [Occ=Once] -> as1_sdpDW;
                                  };
                            }; } in
                  let {
                    sat_sdpDQ [Occ=OnceL] :: a_sdp2s
                    [LclId] =
                        [w_sdpDI] \u []
                            case w_sdpDI of {
                              GHC.Base.:| a1_sdpDL [Occ=Once!] _ [Occ=Dead] ->
                                  case a1_sdpDL of {
                                    GHC.Base.:| a2_sdpDO [Occ=Once] _ [Occ=Dead] -> a2_sdpDO;
                                  };
                            }; } in
                  let {
                    sat_sdpDY [Occ=OnceL] :: [a_sdp2s]
                    [LclId] =
                        CCCS :! [sat_sdpDQ sat_sdpDX]; } in
                  let {
                    sat_sdpE3 [Occ=Once] :: [[a_sdp2s]]
                    [LclId] =
                        CCCS :! [sat_sdpDY sat_sdpE2];
                  } in 
                    case Data.OldList.transpose sat_sdpE3 of {
                      [] -> Data.List.NonEmpty.cycle1;
                      : a1_sdpE5 [Occ=Once] as_sdpE6 [Occ=Once] ->
                          GHC.Base.:| [a1_sdpE5 as_sdpE6];
                    }; } in
        let {
          sat_sdpEh [Occ=Once] :: [GHC.Base.NonEmpty a_sdp2s]
          [LclId] =
              [ds_sdpDJ] \u []
                  case ds_sdpDJ of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpEg [Occ=Once] ->
                        GHC.Base.map Data.List.NonEmpty.fromList as_sdpEg;
                  }; } in
        let {
          sat_sdpEd [Occ=Once] :: GHC.Base.NonEmpty a_sdp2s
          [LclId] =
              [ds_sdpDJ] \u []
                  case ds_sdpDJ of {
                    GHC.Base.:| a1_sdpE8 [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdpE8 of {
                          [] -> Data.List.NonEmpty.cycle1;
                          : a2_sdpEb [Occ=Once] as1_sdpEc [Occ=Once] ->
                              GHC.Base.:| [a2_sdpEb as1_sdpEc];
                        };
                  };
        } in  (#,#) [sat_sdpEd sat_sdpEh];

Data.List.NonEmpty.transpose [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
     -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId, Arity=1, Str=<L,U(U(U,U),U)>m, Unf=OtherCon []] =
    [] \r [w_sdpEi]
        case Data.List.NonEmpty.$wtranspose w_sdpEi of {
          (#,#) ww1_sdpEk [Occ=Once] ww2_sdpEl [Occ=Once] ->
              GHC.Base.:| [ww1_sdpEk ww2_sdpEl];
        };

Data.List.NonEmpty.map
  :: forall a b.
     (a -> b) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdpEm ds_sdpEn]
        let {
          sat_sdpEw [Occ=Once] :: [b_ado7C]
          [LclId] =
              [f_sdpEm ds_sdpEn] \u []
                  case ds_sdpEn of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpEv [Occ=Once] ->
                        GHC.Base.map f_sdpEm as_sdpEv;
                  }; } in
        let {
          sat_sdpEs [Occ=Once] :: b_ado7C
          [LclId] =
              [f_sdpEm ds_sdpEn] \u []
                  let {
                    sat_sdpEr [Occ=Once] :: a_ado7B
                    [LclId] =
                        [ds_sdpEn] \u []
                            case ds_sdpEn of {
                              GHC.Base.:| a1_sdpEp [Occ=Once] _ [Occ=Dead] -> a1_sdpEp;
                            };
                  } in  f_sdpEm sat_sdpEr;
        } in  GHC.Base.:| [sat_sdpEs sat_sdpEw];

Data.List.NonEmpty.some1
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     f a -> f (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sdpEx eta_sdpEy]
        let {
          sat_sdpEA [Occ=Once] :: f_ado7n [a_ado7o]
          [LclId] =
              [$dAlternative_sdpEx eta_sdpEy] \u []
                  GHC.Base.many $dAlternative_sdpEx eta_sdpEy;
        } in 
          case GHC.Base.$p1Alternative $dAlternative_sdpEx of sat_sdpEz {
            __DEFAULT ->
                GHC.Base.liftA2 sat_sdpEz GHC.Base.:| eta_sdpEy sat_sdpEA;
          };

Data.List.NonEmpty.intersperse [InlPrag=NOUSERINLINE[0]]
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpEB w1_sdpEC]
        let {
          sat_sdpEP [Occ=Once] :: [a_sdp2C]
          [LclId] =
              [w_sdpEB w1_sdpEC] \u []
                  case w1_sdpEC of {
                    GHC.Base.:| _ [Occ=Dead] bs_sdpEJ [Occ=Once!] ->
                        case bs_sdpEJ of {
                          [] -> [] [];
                          : ipv_sdpEL [Occ=Once] ipv1_sdpEM [Occ=Once] ->
                              let {
                                sat_sdpEN [Occ=Once] :: [a_sdp2C]
                                [LclId] =
                                    [w_sdpEB ipv1_sdpEM] \u []
                                        Data.OldList.prependToAll w_sdpEB ipv1_sdpEM; } in
                              let {
                                sat_sdpEO [Occ=Once] :: [a_sdp2C]
                                [LclId] =
                                    CCCS :! [ipv_sdpEL sat_sdpEN];
                              } in  : [w_sdpEB sat_sdpEO];
                        };
                  }; } in
        let {
          sat_sdpEG [Occ=Once] :: a_sdp2C
          [LclId] =
              [w1_sdpEC] \u []
                  case w1_sdpEC of {
                    GHC.Base.:| b_sdpEE [Occ=Once] _ [Occ=Dead] -> b_sdpEE;
                  };
        } in  GHC.Base.:| [sat_sdpEG sat_sdpEP];

Data.List.NonEmpty.iterate
  :: forall a. (a -> a) -> a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_sdpEQ a1_sdpER]
        let {
          sat_sdpEW [Occ=Once] :: [a_ado7a]
          [LclId] =
              [f_sdpEQ a1_sdpER] \u []
                  let {
                    sat_sdpES [Occ=Once] :: a_ado7a
                    [LclId] =
                        [f_sdpEQ a1_sdpER] \u [] f_sdpEQ a1_sdpER;
                  } in 
                    case GHC.List.$witerate f_sdpEQ sat_sdpES of {
                      (#,#) ww1_sdpEU [Occ=Once] ww2_sdpEV [Occ=Once] ->
                          : [ww1_sdpEU ww2_sdpEV];
                    };
        } in  GHC.Base.:| [a1_sdpER sat_sdpEW];

Data.List.NonEmpty.repeat :: forall a. a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [a1_sdpEX]
        let {
          sat_sdpEY [Occ=Once] :: [a_ado76]
          [LclId] =
              [a1_sdpEX] \u [] GHC.List.repeat a1_sdpEX;
        } in  GHC.Base.:| [a1_sdpEX sat_sdpEY];

Data.List.NonEmpty.groupBy_$sgroupBy [Occ=LoopBreaker]
  :: forall a.
     (a -> a -> GHC.Types.Bool) -> [a] -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eq0_sdpEZ eta_sdpF0]
        case eta_sdpF0 of {
          [] -> [] [];
          : x_sdpF2 xs_sdpF3 [Occ=Once] ->
              let {
                ds_sdpF4 [Dmd=<L,U(1*U,1*U)>] :: ([a_Xdo51], [a_Xdo51])
                [LclId] =
                    [eq0_sdpEZ x_sdpF2 xs_sdpF3] \u []
                        let {
                          sat_sdpF5 [Occ=Once, Dmd=<L,C(U)>] :: a_Xdo51 -> GHC.Types.Bool
                          [LclId] =
                              [eq0_sdpEZ x_sdpF2] \u [] eq0_sdpEZ x_sdpF2;
                        } in 
                          case GHC.List.$wspan sat_sdpF5 xs_sdpF3 of {
                            (#,#) ww1_sdpF7 [Occ=Once] ww2_sdpF8 [Occ=Once] ->
                                (,) [ww1_sdpF7 ww2_sdpF8];
                          }; } in
              let {
                sat_sdpFh [Occ=Once] :: [GHC.Base.NonEmpty a_Xdo51]
                [LclId] =
                    [eq0_sdpEZ ds_sdpF4] \u []
                        case ds_sdpF4 of {
                          (,) _ [Occ=Dead] zs_sdpFg [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdpEZ zs_sdpFg;
                        }; } in
              let {
                sat_sdpFc [Occ=Once] :: [a_Xdo51]
                [LclId] =
                    [ds_sdpF4] \u []
                        case ds_sdpF4 of {
                          (,) ys_sdpFa [Occ=Once] _ [Occ=Dead] -> ys_sdpFa;
                        }; } in
              let {
                sat_sdpFd [Occ=Once] :: GHC.Base.NonEmpty a_Xdo51
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdpF2 sat_sdpFc];
              } in  : [sat_sdpFd sat_sdpFh];
        };

Data.List.NonEmpty.groupBy
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     (a -> a -> GHC.Types.Bool) -> f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpFi eq0_sdpFj eta_sdpFk]
        case Data.Foldable.toList $dFoldable_sdpFi eta_sdpFk of {
          [] -> [] [];
          : x_sdpFm xs_sdpFn [Occ=Once] ->
              let {
                ds_sdpFo [Dmd=<L,U(1*U,1*U)>] :: ([a_ado4Z], [a_ado4Z])
                [LclId] =
                    [eq0_sdpFj x_sdpFm xs_sdpFn] \u []
                        let {
                          sat_sdpFp [Occ=Once, Dmd=<L,C(U)>] :: a_ado4Z -> GHC.Types.Bool
                          [LclId] =
                              [eq0_sdpFj x_sdpFm] \u [] eq0_sdpFj x_sdpFm;
                        } in 
                          case GHC.List.$wspan sat_sdpFp xs_sdpFn of {
                            (#,#) ww1_sdpFr [Occ=Once] ww2_sdpFs [Occ=Once] ->
                                (,) [ww1_sdpFr ww2_sdpFs];
                          }; } in
              let {
                sat_sdpFB [Occ=Once] :: [GHC.Base.NonEmpty a_ado4Z]
                [LclId] =
                    [eq0_sdpFj ds_sdpFo] \u []
                        case ds_sdpFo of {
                          (,) _ [Occ=Dead] zs_sdpFA [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdpFj zs_sdpFA;
                        }; } in
              let {
                sat_sdpFw [Occ=Once] :: [a_ado4Z]
                [LclId] =
                    [ds_sdpFo] \u []
                        case ds_sdpFo of {
                          (,) ys_sdpFu [Occ=Once] _ [Occ=Dead] -> ys_sdpFu;
                        }; } in
              let {
                sat_sdpFx [Occ=Once] :: GHC.Base.NonEmpty a_ado4Z
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdpFm sat_sdpFw];
              } in  : [sat_sdpFx sat_sdpFB];
        };

Data.List.NonEmpty.groupWith
  :: forall (f :: * -> *) b a.
     (Data.Foldable.Foldable f, GHC.Classes.Eq b) =>
     (a -> b) -> f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpFC $dEq_sdpFD f1_sdpFE eta_sdpFF]
        case Data.Foldable.toList $dFoldable_sdpFC eta_sdpFF of {
          [] -> [] [];
          : x_sdpFH xs_sdpFI [Occ=Once] ->
              let {
                eq0_sdpFJ [Dmd=<L,C(C(U))>] :: a_ado5N -> a_ado5N -> GHC.Types.Bool
                [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                    [$dEq_sdpFD f1_sdpFE] \r [x1_sdpFK y_sdpFL]
                        let {
                          sat_sdpFN [Occ=Once] :: b_ado5M
                          [LclId] =
                              [f1_sdpFE y_sdpFL] \u [] f1_sdpFE y_sdpFL; } in
                        let {
                          sat_sdpFM [Occ=Once] :: b_ado5M
                          [LclId] =
                              [f1_sdpFE x1_sdpFK] \u [] f1_sdpFE x1_sdpFK;
                        } in  GHC.Classes.== $dEq_sdpFD sat_sdpFM sat_sdpFN; } in
              let {
                ds_sdpFO [Dmd=<L,U(1*U,1*U)>] :: ([a_ado5N], [a_ado5N])
                [LclId] =
                    [x_sdpFH xs_sdpFI eq0_sdpFJ] \u []
                        let {
                          sat_sdpFP [Occ=Once] :: a_ado5N -> GHC.Types.Bool
                          [LclId] =
                              [x_sdpFH eq0_sdpFJ] \r [eta_B1] eq0_sdpFJ x_sdpFH eta_B1;
                        } in 
                          case GHC.List.$wspan sat_sdpFP xs_sdpFI of {
                            (#,#) ww1_sdpFR [Occ=Once] ww2_sdpFS [Occ=Once] ->
                                (,) [ww1_sdpFR ww2_sdpFS];
                          }; } in
              let {
                sat_sdpG1 [Occ=Once] :: [GHC.Base.NonEmpty a_ado5N]
                [LclId] =
                    [eq0_sdpFJ ds_sdpFO] \u []
                        case ds_sdpFO of {
                          (,) _ [Occ=Dead] zs_sdpG0 [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdpFJ zs_sdpG0;
                        }; } in
              let {
                sat_sdpFW [Occ=Once] :: [a_ado5N]
                [LclId] =
                    [ds_sdpFO] \u []
                        case ds_sdpFO of {
                          (,) ys_sdpFU [Occ=Once] _ [Occ=Dead] -> ys_sdpFU;
                        }; } in
              let {
                sat_sdpFX [Occ=Once] :: GHC.Base.NonEmpty a_ado5N
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdpFH sat_sdpFW];
              } in  : [sat_sdpFX sat_sdpG1];
        };

Data.List.NonEmpty.group
  :: forall (f :: * -> *) a.
     (Data.Foldable.Foldable f, GHC.Classes.Eq a) =>
     f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*U(1*C(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdpG2 $dEq_sdpG3 eta_sdpG4]
        let {
          sat_sdpG5 [Occ=Once, Dmd=<L,C(C(U))>]
            :: a_ado6W -> a_ado6W -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdpG3] \u [] GHC.Classes.== $dEq_sdpG3;
        } in 
          Data.List.NonEmpty.groupBy $dFoldable_sdpG2 sat_sdpG5 eta_sdpG4;

Data.List.NonEmpty.isPrefixOf
  :: forall a.
     GHC.Classes.Eq a =>
     [a] -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><S,1*U><L,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdpG6 ds_sdpG7 ds1_sdpG8]
        case ds_sdpG7 of {
          [] -> GHC.Types.True [];
          : y_sdpGa [Occ=Once] ys_sdpGb [Occ=Once] ->
              case ds1_sdpG8 of {
                GHC.Base.:| x_sdpGd [Occ=Once] xs_sdpGe [Occ=Once] ->
                    case GHC.Classes.== $dEq_sdpG6 y_sdpGa x_sdpGd of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True ->
                          Data.OldList.isPrefixOf $dEq_sdpG6 ys_sdpGb xs_sdpGe;
                    };
              };
        };

lvl1_rdpwu :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.!! negative argument"#;

Data.List.NonEmpty.!!1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rdpwu of sat_sdpGg {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sdpGg;
        };

Data.List.NonEmpty.$w!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. a -> [a] -> GHC.Prim.Int# -> a
[GblId, Arity=3, Str=<L,1*U><L,1*U><S,1*U>, Unf=OtherCon []] =
    [] \r [ww_sdpGh ww1_sdpGi ww2_sdpGj]
        case ww2_sdpGj of wild_sdpGk {
          __DEFAULT ->
              case ># [wild_sdpGk 0#] of {
                __DEFAULT -> Data.List.NonEmpty.!!1;
                1# ->
                    case -# [wild_sdpGk 1#] of sat_sdpGm {
                      __DEFAULT -> GHC.List.$w!! ww1_sdpGi sat_sdpGm;
                    };
              };
          0# -> ww_sdpGh;
        };

Data.List.NonEmpty.!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int -> a
[GblId,
 Arity=2,
 Str=<S,1*U(1*U,1*U)><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpGn w1_sdpGo]
        case w_sdpGn of {
          GHC.Base.:| ww1_sdpGq [Occ=Once] ww2_sdpGr [Occ=Once] ->
              case w1_sdpGo of {
                GHC.Types.I# ww4_sdpGt [Occ=Once] ->
                    Data.List.NonEmpty.$w!! ww1_sdpGq ww2_sdpGr ww4_sdpGt;
              };
        };

Data.List.NonEmpty.zip
  :: forall a b.
     GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdpGu ds1_sdpGv]
        let {
          sat_sdpGM [Occ=Once] :: [(a_ado4o, b_ado4p)]
          [LclId] =
              [ds_sdpGu ds1_sdpGv] \u []
                  case ds_sdpGu of {
                    GHC.Base.:| _ [Occ=Dead] xs_sdpGH [Occ=Once] ->
                        let {
                          sat_sdpGL [Occ=Once, Dmd=<L,1*U>] :: [b_ado4p]
                          [LclId] =
                              [ds1_sdpGv] \s []
                                  case ds1_sdpGv of {
                                    GHC.Base.:| _ [Occ=Dead] ys_sdpGK [Occ=Once] -> ys_sdpGK;
                                  };
                        } in  GHC.List.zip xs_sdpGH sat_sdpGL;
                  }; } in
        let {
          sat_sdpGD [Occ=Once] :: b_ado4p
          [LclId] =
              [ds1_sdpGv] \u []
                  case ds1_sdpGv of {
                    GHC.Base.:| y_sdpGB [Occ=Once] _ [Occ=Dead] -> y_sdpGB;
                  }; } in
        let {
          sat_sdpGz [Occ=Once] :: a_ado4o
          [LclId] =
              [ds_sdpGu] \u []
                  case ds_sdpGu of {
                    GHC.Base.:| x_sdpGx [Occ=Once] _ [Occ=Dead] -> x_sdpGx;
                  }; } in
        let {
          sat_sdpGE [Occ=Once] :: (a_ado4o, b_ado4p)
          [LclId] =
              CCCS (,)! [sat_sdpGz sat_sdpGD];
        } in  GHC.Base.:| [sat_sdpGE sat_sdpGM];

Data.List.NonEmpty.zipWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b
     -> GHC.Base.NonEmpty c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpGN w1_sdpGO w2_sdpGP]
        let {
          sat_sdpH6 [Occ=Once] :: [c_sdp3h]
          [LclId] =
              [w_sdpGN w1_sdpGO w2_sdpGP] \u []
                  case w1_sdpGO of {
                    GHC.Base.:| _ [Occ=Dead] xs_sdpH1 [Occ=Once] ->
                        let {
                          sat_sdpH5 [Occ=Once, Dmd=<L,1*U>] :: [b_sdp3g]
                          [LclId] =
                              [w2_sdpGP] \s []
                                  case w2_sdpGP of {
                                    GHC.Base.:| _ [Occ=Dead] ys_sdpH4 [Occ=Once] -> ys_sdpH4;
                                  };
                        } in  GHC.List.zipWith w_sdpGN xs_sdpH1 sat_sdpH5;
                  }; } in
        let {
          sat_sdpGY [Occ=Once] :: c_sdp3h
          [LclId] =
              [w_sdpGN w1_sdpGO w2_sdpGP] \u []
                  let {
                    sat_sdpGX [Occ=Once] :: b_sdp3g
                    [LclId] =
                        [w2_sdpGP] \u []
                            case w2_sdpGP of {
                              GHC.Base.:| y_sdpGV [Occ=Once] _ [Occ=Dead] -> y_sdpGV;
                            }; } in
                  let {
                    sat_sdpGT [Occ=Once] :: a_sdp3f
                    [LclId] =
                        [w1_sdpGO] \u []
                            case w1_sdpGO of {
                              GHC.Base.:| x_sdpGR [Occ=Once] _ [Occ=Dead] -> x_sdpGR;
                            };
                  } in  w_sdpGN sat_sdpGT sat_sdpGX;
        } in  GHC.Base.:| [sat_sdpGY sat_sdpH6];

Data.List.NonEmpty.unzip
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     f (a, b) -> (f a, f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sdpH7 xs_sdpH8]
        let {
          sat_sdpHa [Occ=Once] :: f_ado3Y b_ado40
          [LclId] =
              [$dFunctor_sdpH7 xs_sdpH8] \u []
                  GHC.Base.fmap $dFunctor_sdpH7 Data.Tuple.snd xs_sdpH8; } in
        let {
          sat_sdpH9 [Occ=Once] :: f_ado3Y a_ado3Z
          [LclId] =
              [$dFunctor_sdpH7 xs_sdpH8] \u []
                  GHC.Base.fmap $dFunctor_sdpH7 Data.Tuple.fst xs_sdpH8;
        } in  (,) [sat_sdpH9 sat_sdpHa];

Data.List.NonEmpty.nubBy [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> a -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpHb w1_sdpHc]
        case w1_sdpHc of {
          GHC.Base.:| ww1_sdpHe ww2_sdpHf [Occ=Once] ->
              let {
                sat_sdpHk [Occ=Once] :: [a_sdp3p]
                [LclId] =
                    [w_sdpHb ww1_sdpHe ww2_sdpHf] \u []
                        let {
                          sat_sdpHi [Occ=Once] :: a_sdp3p -> GHC.Types.Bool
                          [LclId] =
                              [w_sdpHb ww1_sdpHe] \r [b_sdpHg]
                                  case w_sdpHb ww1_sdpHe b_sdpHg of {
                                    GHC.Types.False -> GHC.Types.True [];
                                    GHC.Types.True -> GHC.Types.False [];
                                  };
                        } in 
                          case GHC.List.filter sat_sdpHi ww2_sdpHf of sat_sdpHj {
                            __DEFAULT -> Data.OldList.nubBy w_sdpHb sat_sdpHj;
                          };
              } in  GHC.Base.:| [ww1_sdpHe sat_sdpHk];
        };

Data.List.NonEmpty.nub
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(U)),A)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dEq_sdpHl eta_sdpHm]
        case eta_sdpHm of {
          GHC.Base.:| ww1_sdpHo ww2_sdpHp [Occ=Once] ->
              let {
                sat_sdpHv [Occ=Once] :: [a_ado3R]
                [LclId] =
                    [$dEq_sdpHl ww1_sdpHo ww2_sdpHp] \u []
                        let {
                          w_sdpHq [Dmd=<L,C(C1(U))>] :: a_ado3R -> a_ado3R -> GHC.Types.Bool
                          [LclId] =
                              [$dEq_sdpHl] \u [] GHC.Classes.== $dEq_sdpHl; } in
                        let {
                          sat_sdpHt [Occ=Once] :: a_ado3R -> GHC.Types.Bool
                          [LclId] =
                              [ww1_sdpHo w_sdpHq] \r [b_sdpHr]
                                  case w_sdpHq ww1_sdpHo b_sdpHr of {
                                    GHC.Types.False -> GHC.Types.True [];
                                    GHC.Types.True -> GHC.Types.False [];
                                  };
                        } in 
                          case GHC.List.filter sat_sdpHt ww2_sdpHp of sat_sdpHu {
                            __DEFAULT -> Data.OldList.nubBy w_sdpHq sat_sdpHu;
                          };
              } in  GHC.Base.:| [ww1_sdpHo sat_sdpHv];
        };

Data.List.NonEmpty.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.List.NonEmpty.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.List.NonEmpty.$trModule4];

Data.List.NonEmpty.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.List.NonEmpty"#;

Data.List.NonEmpty.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.List.NonEmpty.$trModule2];

Data.List.NonEmpty.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.List.NonEmpty.$trModule3
                                     Data.List.NonEmpty.$trModule1];

Data.List.NonEmpty.groupAllWith
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b) -> [a] -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdpHw eta_sdpHx eta1_sdpHy]
        let {
          sat_sdpHF [Occ=Once] :: [a_ado65]
          [LclId] =
              [$dOrd_sdpHw eta_sdpHx eta1_sdpHy] \u []
                  let {
                    sat_sdpHE [Occ=Once] :: a_ado65 -> a_ado65 -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sdpHw eta_sdpHx] \r [x_sdpHA y_sdpHB]
                            let {
                              sat_sdpHD [Occ=Once] :: b_ado64
                              [LclId] =
                                  [eta_sdpHx y_sdpHB] \u [] eta_sdpHx y_sdpHB; } in
                            let {
                              sat_sdpHC [Occ=Once] :: b_ado64
                              [LclId] =
                                  [eta_sdpHx x_sdpHA] \u [] eta_sdpHx x_sdpHA;
                            } in  GHC.Classes.compare $dOrd_sdpHw sat_sdpHC sat_sdpHD;
                  } in  Data.OldList.sortBy sat_sdpHE eta1_sdpHy; } in
        let {
          sat_sdpHz [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_ado64
          [LclId] =
              [$dOrd_sdpHw] \u [] GHC.Classes.$p1Ord $dOrd_sdpHw;
        } in 
          Data.List.NonEmpty.groupWith
              Data.Foldable.$fFoldable[] sat_sdpHz eta_sdpHx sat_sdpHF;

Data.List.NonEmpty.groupBy1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> a -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpHG w1_sdpHH]
        case w1_sdpHH of {
          GHC.Base.:| ww1_sdpHJ ww2_sdpHK [Occ=Once] ->
              let {
                ds_sdpHL [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp3G], [a_sdp3G])
                [LclId] =
                    [w_sdpHG ww1_sdpHJ ww2_sdpHK] \u []
                        let {
                          sat_sdpHM [Occ=Once, Dmd=<L,C(U)>] :: a_sdp3G -> GHC.Types.Bool
                          [LclId] =
                              [w_sdpHG ww1_sdpHJ] \u [] w_sdpHG ww1_sdpHJ;
                        } in 
                          case GHC.List.$wspan sat_sdpHM ww2_sdpHK of {
                            (#,#) ww4_sdpHO [Occ=Once] ww5_sdpHP [Occ=Once] ->
                                (,) [ww4_sdpHO ww5_sdpHP];
                          }; } in
              let {
                sat_sdpHY [Occ=Once] :: [GHC.Base.NonEmpty a_sdp3G]
                [LclId] =
                    [w_sdpHG ds_sdpHL] \u []
                        case ds_sdpHL of {
                          (,) _ [Occ=Dead] zs_sdpHX [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy w_sdpHG zs_sdpHX;
                        }; } in
              let {
                sat_sdpHT [Occ=Once] :: [a_sdp3G]
                [LclId] =
                    [ds_sdpHL] \u []
                        case ds_sdpHL of {
                          (,) ys_sdpHR [Occ=Once] _ [Occ=Dead] -> ys_sdpHR;
                        }; } in
              let {
                sat_sdpHU [Occ=Once] :: GHC.Base.NonEmpty a_sdp3G
                [LclId] =
                    CCCS GHC.Base.:|! [ww1_sdpHJ sat_sdpHT];
              } in  GHC.Base.:| [sat_sdpHU sat_sdpHY];
        };

Data.List.NonEmpty.group1
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C(U)),A)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dEq_sdpHZ eta_sdpI0]
        case eta_sdpI0 of {
          GHC.Base.:| ww1_sdpI2 ww2_sdpI3 [Occ=Once] ->
              let {
                w_sdpI4 [Dmd=<L,C(C(U))>] :: a_ado6D -> a_ado6D -> GHC.Types.Bool
                [LclId] =
                    [$dEq_sdpHZ] \u [] GHC.Classes.== $dEq_sdpHZ; } in
              let {
                ds_sdpI5 [Dmd=<L,U(1*U,1*U)>] :: ([a_ado6D], [a_ado6D])
                [LclId] =
                    [ww1_sdpI2 ww2_sdpI3 w_sdpI4] \u []
                        let {
                          sat_sdpI6 [Occ=Once, Dmd=<L,C(U)>] :: a_ado6D -> GHC.Types.Bool
                          [LclId] =
                              [ww1_sdpI2 w_sdpI4] \u [] w_sdpI4 ww1_sdpI2;
                        } in 
                          case GHC.List.$wspan sat_sdpI6 ww2_sdpI3 of {
                            (#,#) ww4_sdpI8 [Occ=Once] ww5_sdpI9 [Occ=Once] ->
                                (,) [ww4_sdpI8 ww5_sdpI9];
                          }; } in
              let {
                sat_sdpIi [Occ=Once] :: [GHC.Base.NonEmpty a_ado6D]
                [LclId] =
                    [w_sdpI4 ds_sdpI5] \u []
                        case ds_sdpI5 of {
                          (,) _ [Occ=Dead] zs_sdpIh [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy w_sdpI4 zs_sdpIh;
                        }; } in
              let {
                sat_sdpId [Occ=Once] :: [a_ado6D]
                [LclId] =
                    [ds_sdpI5] \u []
                        case ds_sdpI5 of {
                          (,) ys_sdpIb [Occ=Once] _ [Occ=Dead] -> ys_sdpIb;
                        }; } in
              let {
                sat_sdpIe [Occ=Once] :: GHC.Base.NonEmpty a_ado6D
                [LclId] =
                    CCCS GHC.Base.:|! [ww1_sdpI2 sat_sdpId];
              } in  GHC.Base.:| [sat_sdpIe sat_sdpIi];
        };

Data.List.NonEmpty.$wgroupWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Eq b =>
     (a -> b)
     -> a -> [a] -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,C(U)><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdpIj w1_sdpIk ww_sdpIl ww1_sdpIm]
        let {
          eq_sdpIn [Dmd=<L,C(C(U))>] :: a_sdp3T -> a_sdp3T -> GHC.Types.Bool
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w_sdpIj w1_sdpIk] \r [x_sdpIo y_sdpIp]
                  let {
                    sat_sdpIr [Occ=Once] :: b_sdp3S
                    [LclId] =
                        [w1_sdpIk y_sdpIp] \u [] w1_sdpIk y_sdpIp; } in
                  let {
                    sat_sdpIq [Occ=Once] :: b_sdp3S
                    [LclId] =
                        [w1_sdpIk x_sdpIo] \u [] w1_sdpIk x_sdpIo;
                  } in  GHC.Classes.== w_sdpIj sat_sdpIq sat_sdpIr; } in
        let {
          ds_sdpIs [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp3T], [a_sdp3T])
          [LclId] =
              [ww_sdpIl ww1_sdpIm eq_sdpIn] \u []
                  let {
                    sat_sdpIt [Occ=Once] :: a_sdp3T -> GHC.Types.Bool
                    [LclId] =
                        [ww_sdpIl eq_sdpIn] \r [eta_B1] eq_sdpIn ww_sdpIl eta_B1;
                  } in 
                    case GHC.List.$wspan sat_sdpIt ww1_sdpIm of {
                      (#,#) ww3_sdpIv [Occ=Once] ww4_sdpIw [Occ=Once] ->
                          (,) [ww3_sdpIv ww4_sdpIw];
                    }; } in
        let {
          sat_sdpIF [Occ=Once] :: [GHC.Base.NonEmpty a_sdp3T]
          [LclId] =
              [eq_sdpIn ds_sdpIs] \u []
                  case ds_sdpIs of {
                    (,) _ [Occ=Dead] zs_sdpIE [Occ=Once] ->
                        Data.List.NonEmpty.groupBy_$sgroupBy eq_sdpIn zs_sdpIE;
                  }; } in
        let {
          sat_sdpIA [Occ=Once] :: [a_sdp3T]
          [LclId] =
              [ds_sdpIs] \u []
                  case ds_sdpIs of {
                    (,) ys_sdpIy [Occ=Once] _ [Occ=Dead] -> ys_sdpIy;
                  }; } in
        let {
          sat_sdpIB [Occ=Once] :: GHC.Base.NonEmpty a_sdp3T
          [LclId] =
              CCCS GHC.Base.:|! [ww_sdpIl sat_sdpIA];
        } in  (#,#) [sat_sdpIB sat_sdpIF];

Data.List.NonEmpty.groupWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Eq b =>
     (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,C(U)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpIG w1_sdpIH w2_sdpII]
        case w2_sdpII of {
          GHC.Base.:| ww1_sdpIK [Occ=Once] ww2_sdpIL [Occ=Once] ->
              case
                  Data.List.NonEmpty.$wgroupWith1
                      w_sdpIG w1_sdpIH ww1_sdpIK ww2_sdpIL
              of
              { (#,#) ww4_sdpIN [Occ=Once] ww5_sdpIO [Occ=Once] ->
                    GHC.Base.:| [ww4_sdpIN ww5_sdpIO];
              };
        };

Data.List.NonEmpty.$wgroupAllWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b)
     -> GHC.Base.NonEmpty a
     -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId,
 Arity=3,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpIP w1_sdpIQ w2_sdpIR]
        let {
          sat_sdpJ0 [Occ=Once] :: [a_sdp47]
          [LclId] =
              [w2_sdpIR] \u []
                  case w2_sdpIR of {
                    GHC.Base.:| _ [Occ=Dead] as_sdpIZ [Occ=Once] -> as_sdpIZ;
                  }; } in
        let {
          sat_sdpIW [Occ=Once] :: a_sdp47
          [LclId] =
              [w2_sdpIR] \u []
                  case w2_sdpIR of {
                    GHC.Base.:| a1_sdpIU [Occ=Once] _ [Occ=Dead] -> a1_sdpIU;
                  }; } in
        let {
          sat_sdpJ1 [Occ=Once] :: [a_sdp47]
          [LclId] =
              CCCS :! [sat_sdpIW sat_sdpJ0]; } in
        let {
          sat_sdpIS [Occ=Once] :: a_sdp47 -> a_sdp47 -> GHC.Types.Ordering
          [LclId] =
              [w_sdpIP w1_sdpIQ] \r [eta_B2 eta_B1]
                  Data.Ord.comparing w_sdpIP w1_sdpIQ eta_B2 eta_B1;
        } in 
          case Data.OldList.sortBy sat_sdpIS sat_sdpJ1 of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdpJ4 [Occ=Once] as_sdpJ5 [Occ=Once] ->
                let {
                  sat_sdpJ6 [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
                    :: GHC.Classes.Eq b_sdp46
                  [LclId] =
                      [w_sdpIP] \u [] GHC.Classes.$p1Ord w_sdpIP;
                } in 
                  Data.List.NonEmpty.$wgroupWith1
                      sat_sdpJ6 w1_sdpIQ a1_sdpJ4 as_sdpJ5;
          };

Data.List.NonEmpty.groupAllWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=3,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdpJ7 w1_sdpJ8 w2_sdpJ9]
        case
            Data.List.NonEmpty.$wgroupAllWith1 w_sdpJ7 w1_sdpJ8 w2_sdpJ9
        of
        { (#,#) ww1_sdpJb [Occ=Once] ww2_sdpJc [Occ=Once] ->
              GHC.Base.:| [ww1_sdpJb ww2_sdpJc];
        };

Data.List.NonEmpty.$wxor [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Bool -> [GHC.Types.Bool] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sdpJd ww1_sdpJe]
        let {
          go_sdpJf [Occ=LoopBreaker] :: [GHC.Types.Bool] -> GHC.Types.Bool
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [ww_sdpJd go_sdpJf] \r [ds_sdpJg]
                  case ds_sdpJg of {
                    [] -> ww_sdpJd;
                    : y_sdpJi [Occ=Once!] ys_sdpJj [Occ=Once*] ->
                        case y_sdpJi of {
                          GHC.Types.False -> go_sdpJf ys_sdpJj;
                          GHC.Types.True ->
                              case go_sdpJf ys_sdpJj of {
                                GHC.Types.False -> GHC.Types.True [];
                                GHC.Types.True -> GHC.Types.False [];
                              };
                        };
                  };
        } in  go_sdpJf ww1_sdpJe;

Data.List.NonEmpty.xor [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.NonEmpty GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdpJm]
        case w_sdpJm of {
          GHC.Base.:| ww1_sdpJo [Occ=Once] ww2_sdpJp [Occ=Once] ->
              Data.List.NonEmpty.$wxor ww1_sdpJo ww2_sdpJp;
        };

Data.List.NonEmpty.length
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdpJq]
        case ds_sdpJq of {
          GHC.Base.:| _ [Occ=Dead] xs_sdpJt [Occ=Once] ->
              case GHC.List.$wlenAcc xs_sdpJt 0# of ww2_sdpJu {
                __DEFAULT ->
                    case +# [1# ww2_sdpJu] of sat_sdpJv {
                      __DEFAULT -> GHC.Types.I# [sat_sdpJv];
                    };
              };
        };


==================== Pre unarise: ====================
2018-03-16 16:08:38.245543384 UTC

Data.List.NonEmpty.nonEmpty
  :: forall a. [a] -> GHC.Base.Maybe (GHC.Base.NonEmpty a)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sdrND]
        case ds_sdrND of {
          [] -> GHC.Base.Nothing [];
          : a1_sdrNF [Occ=Once] as_sdrNG [Occ=Once] ->
              let {
                sat_sdrNH [Occ=Once] :: GHC.Base.NonEmpty a_adod9
                [LclId] =
                    CCCS GHC.Base.:|! [a1_sdrNF as_sdrNG];
              } in  GHC.Base.Just [sat_sdrNH];
        };

Data.List.NonEmpty.uncons
  :: forall a.
     GHC.Base.NonEmpty a -> (a, GHC.Base.Maybe (GHC.Base.NonEmpty a))
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdrNI]
        let {
          sat_sdrNU [Occ=Once] :: GHC.Base.Maybe (GHC.Base.NonEmpty a_adode)
          [LclId] =
              [ds_sdrNI] \u []
                  case ds_sdrNI of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrNP [Occ=Once!] ->
                        case as_sdrNP of {
                          [] -> GHC.Base.Nothing [];
                          : a2_sdrNR [Occ=Once] as1_sdrNS [Occ=Once] ->
                              let {
                                sat_sdrNT [Occ=Once] :: GHC.Base.NonEmpty a_adode
                                [LclId] =
                                    CCCS GHC.Base.:|! [a2_sdrNR as1_sdrNS];
                              } in  GHC.Base.Just [sat_sdrNT];
                        };
                  }; } in
        let {
          sat_sdrNM [Occ=Once] :: a_adode
          [LclId] =
              [ds_sdrNI] \u []
                  case ds_sdrNI of {
                    GHC.Base.:| a1_sdrNK [Occ=Once] _ [Occ=Dead] -> a1_sdrNK;
                  };
        } in  (,) [sat_sdrNM sat_sdrNU];

Data.List.NonEmpty.$wunfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> (b, GHC.Base.Maybe a)) -> a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,1*U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdrNV w1_sdrNW]
        case w_sdrNV w1_sdrNW of {
          (,) b1_sdrNY [Occ=Once] mc_sdrNZ [Occ=Once!] ->
              let {
                sat_sdrOa [Occ=Once] :: [b_sdp0I]
                [LclId] =
                    [w_sdrNV mc_sdrNZ] \u []
                        case mc_sdrNZ of {
                          GHC.Base.Nothing -> [] [];
                          GHC.Base.Just x_sdrO1 [Occ=Once] ->
                              let {
                                go_sdrO2 [Occ=LoopBreaker] :: a_sdp0H -> [b_sdp0I]
                                [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                    sat-only [w_sdrNV go_sdrO2] \r [c_sdrO3]
                                        case w_sdrNV c_sdrO3 of {
                                          (,) d_sdrO5 [Occ=Once] me_sdrO6 [Occ=Once!] ->
                                              let {
                                                sat_sdrO9 [Occ=Once] :: [b_sdp0I]
                                                [LclId] =
                                                    [go_sdrO2 me_sdrO6] \u []
                                                        case me_sdrO6 of {
                                                          GHC.Base.Nothing -> [] [];
                                                          GHC.Base.Just x1_sdrO8 [Occ=Once] ->
                                                              go_sdrO2 x1_sdrO8;
                                                        };
                                              } in  : [d_sdrO5 sat_sdrO9];
                                        };
                              } in  go_sdrO2 x_sdrO1;
                        };
              } in  (#,#) [b1_sdrNY sat_sdrOa];
        };

Data.List.NonEmpty.unfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> (b, GHC.Base.Maybe a)) -> a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdrOb w1_sdrOc]
        case Data.List.NonEmpty.$wunfoldr w_sdrOb w1_sdrOc of {
          (#,#) ww1_sdrOe [Occ=Once] ww2_sdrOf [Occ=Once] ->
              GHC.Base.:| [ww1_sdrOe ww2_sdrOf];
        };

Data.List.NonEmpty.head :: forall a. GHC.Base.NonEmpty a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sdrOg]
        case ds_sdrOg of {
          GHC.Base.:| a1_sdrOi [Occ=Once] _ [Occ=Dead] -> a1_sdrOi;
        };

Data.List.NonEmpty.tail :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sdrOk]
        case ds_sdrOk of {
          GHC.Base.:| _ [Occ=Dead] as_sdrOn [Occ=Once] -> as_sdrOn;
        };

poly_go_rdpws :: forall a. [a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ds_sdrOo eta_sdrOp]
        case ds_sdrOo of {
          [] -> eta_sdrOp;
          : y_sdrOr [Occ=Once] ys_sdrOs [Occ=Once] ->
              poly_go_rdpws ys_sdrOs y_sdrOr;
        };

Data.List.NonEmpty.last :: forall a. GHC.Base.NonEmpty a -> a
[GblId, Arity=1, Str=<L,U(1*U,1*U)>, Unf=OtherCon []] =
    [] \r [ds_sdrOt]
        let {
          sat_sdrOB [Occ=Once] :: [a_adocF]
          [LclId] =
              [ds_sdrOt] \u []
                  case ds_sdrOt of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrOA [Occ=Once] -> as_sdrOA;
                  }; } in
        let {
          sat_sdrOx [Occ=Once] :: a_adocF
          [LclId] =
              [ds_sdrOt] \u []
                  case ds_sdrOt of {
                    GHC.Base.:| a1_sdrOv [Occ=Once] _ [Occ=Dead] -> a1_sdrOv;
                  }; } in
        let {
          sat_sdrOC [Occ=Once] :: [a_adocF]
          [LclId] =
              CCCS :! [sat_sdrOx sat_sdrOB];
        } in  poly_go_rdpws sat_sdrOC GHC.List.lastError;

Data.List.NonEmpty.init :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sdrOD]
        case ds_sdrOD of {
          GHC.Base.:| a1_sdrOF [Occ=Once] as_sdrOG [Occ=Once] ->
              GHC.List.init1 a1_sdrOF as_sdrOG;
        };

Data.List.NonEmpty.<|
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [a1_sdrOH ds_sdrOI]
        let {
          sat_sdrOQ [Occ=Once] :: [a_adocs]
          [LclId] =
              [ds_sdrOI] \u []
                  case ds_sdrOI of {
                    GHC.Base.:| _ [Occ=Dead] bs_sdrOP [Occ=Once] -> bs_sdrOP;
                  }; } in
        let {
          sat_sdrOM [Occ=Once] :: a_adocs
          [LclId] =
              [ds_sdrOI] \u []
                  case ds_sdrOI of {
                    GHC.Base.:| b_sdrOK [Occ=Once] _ [Occ=Dead] -> b_sdrOK;
                  }; } in
        let {
          sat_sdrOR [Occ=Once] :: [a_adocs]
          [LclId] =
              CCCS :! [sat_sdrOM sat_sdrOQ];
        } in  GHC.Base.:| [a1_sdrOH sat_sdrOR];

Data.List.NonEmpty.cons
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.List.NonEmpty.<| eta_B2 eta_B1;

Data.List.NonEmpty.$wunfold [InlPrag=NOUSERINLINE[0],
                             Occ=LoopBreaker]
  :: forall a b. (a -> (b, GHC.Base.Maybe a)) -> a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S(LS)),C(U(U,1*U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdrOS w1_sdrOT]
        case w_sdrOS w1_sdrOT of {
          (,) b1_sdrOV [Occ=Once*] ds_sdrOW [Occ=Once!] ->
              case ds_sdrOW of {
                GHC.Base.Nothing -> (#,#) [b1_sdrOV GHC.Types.[]];
                GHC.Base.Just c_sdrOY [Occ=Once] ->
                    let {
                      ds1_sdrOZ [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty b_sdp0S
                      [LclId] =
                          [w_sdrOS c_sdrOY] \u []
                              case Data.List.NonEmpty.$wunfold w_sdrOS c_sdrOY of {
                                (#,#) ww1_sdrP1 [Occ=Once] ww2_sdrP2 [Occ=Once] ->
                                    GHC.Base.:| [ww1_sdrP1 ww2_sdrP2];
                              }; } in
                    let {
                      sat_sdrPa [Occ=Once] :: [b_sdp0S]
                      [LclId] =
                          [ds1_sdrOZ] \u []
                              case ds1_sdrOZ of {
                                GHC.Base.:| _ [Occ=Dead] bs_sdrP9 [Occ=Once] -> bs_sdrP9;
                              }; } in
                    let {
                      sat_sdrP6 [Occ=Once] :: b_sdp0S
                      [LclId] =
                          [ds1_sdrOZ] \u []
                              case ds1_sdrOZ of {
                                GHC.Base.:| b2_sdrP4 [Occ=Once] _ [Occ=Dead] -> b2_sdrP4;
                              }; } in
                    let {
                      sat_sdrPb [Occ=Once] :: [b_sdp0S]
                      [LclId] =
                          CCCS :! [sat_sdrP6 sat_sdrPa];
                    } in  (#,#) [b1_sdrOV sat_sdrPb];
              };
        };

Data.List.NonEmpty.unfold [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> (b, GHC.Base.Maybe a)) -> a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S(LS)),C(U(U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdrPc w1_sdrPd]
        case Data.List.NonEmpty.$wunfold w_sdrPc w1_sdrPd of {
          (#,#) ww1_sdrPf [Occ=Once] ww2_sdrPg [Occ=Once] ->
              GHC.Base.:| [ww1_sdrPf ww2_sdrPg];
        };

lvl_rdpwt :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.fromList: empty list"#;

Data.List.NonEmpty.cycle1 :: forall a. GHC.Base.NonEmpty a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rdpwt of sat_sdrPh {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sdrPh;
        };

Data.List.NonEmpty.fromList :: forall a. [a] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sdrPi]
        case ds_sdrPi of {
          [] -> Data.List.NonEmpty.cycle1;
          : a1_sdrPk [Occ=Once] as_sdrPl [Occ=Once] ->
              GHC.Base.:| [a1_sdrPk as_sdrPl];
        };

Data.List.NonEmpty.reverse [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U(1*U,1*U)>m, Unf=OtherCon []] =
    [] \r [w_sdrPm]
        let {
          sat_sdrPu [Occ=Once] :: [a_sdp0Z]
          [LclId] =
              [w_sdrPm] \u []
                  case w_sdrPm of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrPt [Occ=Once] -> as_sdrPt;
                  }; } in
        let {
          sat_sdrPq [Occ=Once] :: a_sdp0Z
          [LclId] =
              [w_sdrPm] \u []
                  case w_sdrPm of {
                    GHC.Base.:| a1_sdrPo [Occ=Once] _ [Occ=Dead] -> a1_sdrPo;
                  }; } in
        let {
          sat_sdrPv [Occ=Once] :: [a_sdp0Z]
          [LclId] =
              CCCS :! [sat_sdrPq sat_sdrPu];
        } in 
          case GHC.List.reverse1 sat_sdrPv GHC.Types.[] of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrPy [Occ=Once] as_sdrPz [Occ=Once] ->
                GHC.Base.:| [a1_sdrPy as_sdrPz];
          };

Data.List.NonEmpty.sortBy
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdrPA eta_sdrPB]
        let {
          sat_sdrPJ [Occ=Once] :: [a_ado9j]
          [LclId] =
              [eta_sdrPB] \u []
                  case eta_sdrPB of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrPI [Occ=Once] -> as_sdrPI;
                  }; } in
        let {
          sat_sdrPF [Occ=Once] :: a_ado9j
          [LclId] =
              [eta_sdrPB] \u []
                  case eta_sdrPB of {
                    GHC.Base.:| a1_sdrPD [Occ=Once] _ [Occ=Dead] -> a1_sdrPD;
                  }; } in
        let {
          sat_sdrPK [Occ=Once] :: [a_ado9j]
          [LclId] =
              CCCS :! [sat_sdrPF sat_sdrPJ];
        } in 
          case Data.OldList.sortBy f_sdrPA sat_sdrPK of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrPM [Occ=Once] as_sdrPN [Occ=Once] ->
                GHC.Base.:| [a1_sdrPM as_sdrPN];
          };

Data.List.NonEmpty.sortWith [InlPrag=NOUSERINLINE[0]]
  :: forall o a.
     GHC.Classes.Ord o =>
     (a -> o) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrPO w1_sdrPP w2_sdrPQ]
        let {
          sat_sdrPZ [Occ=Once] :: [a_sdp16]
          [LclId] =
              [w2_sdrPQ] \u []
                  case w2_sdrPQ of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrPY [Occ=Once] -> as_sdrPY;
                  }; } in
        let {
          sat_sdrPV [Occ=Once] :: a_sdp16
          [LclId] =
              [w2_sdrPQ] \u []
                  case w2_sdrPQ of {
                    GHC.Base.:| a1_sdrPT [Occ=Once] _ [Occ=Dead] -> a1_sdrPT;
                  }; } in
        let {
          sat_sdrQ0 [Occ=Once] :: [a_sdp16]
          [LclId] =
              CCCS :! [sat_sdrPV sat_sdrPZ]; } in
        let {
          sat_sdrPR [Occ=Once] :: a_sdp16 -> a_sdp16 -> GHC.Types.Ordering
          [LclId] =
              [w_sdrPO w1_sdrPP] \r [eta_B2 eta_B1]
                  Data.Ord.comparing w_sdrPO w1_sdrPP eta_B2 eta_B1;
        } in 
          case Data.OldList.sortBy sat_sdrPR sat_sdrQ0 of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrQ3 [Occ=Once] as_sdrQ4 [Occ=Once] ->
                GHC.Base.:| [a1_sdrQ3 as_sdrQ4];
          };

Data.List.NonEmpty.sort [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C(C1(U)),A,A,A,A,A,A)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrQ5 w1_sdrQ6]
        let {
          sat_sdrQf [Occ=Once] :: [a_sdp1e]
          [LclId] =
              [w1_sdrQ6] \u []
                  case w1_sdrQ6 of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrQe [Occ=Once] -> as_sdrQe;
                  }; } in
        let {
          sat_sdrQb [Occ=Once] :: a_sdp1e
          [LclId] =
              [w1_sdrQ6] \u []
                  case w1_sdrQ6 of {
                    GHC.Base.:| a1_sdrQ9 [Occ=Once] _ [Occ=Dead] -> a1_sdrQ9;
                  }; } in
        let {
          sat_sdrQg [Occ=Once] :: [a_sdp1e]
          [LclId] =
              CCCS :! [sat_sdrQb sat_sdrQf]; } in
        let {
          sat_sdrQ7 [Occ=Once, Dmd=<L,C(C1(U))>]
            :: a_sdp1e -> a_sdp1e -> GHC.Types.Ordering
          [LclId] =
              [w_sdrQ5] \u [] GHC.Classes.compare w_sdrQ5;
        } in 
          case Data.OldList.sortBy sat_sdrQ7 sat_sdrQg of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrQj [Occ=Once] as_sdrQk [Occ=Once] ->
                GHC.Base.:| [a1_sdrQj as_sdrQk];
          };

Data.List.NonEmpty.inits
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     f a -> GHC.Base.NonEmpty [a]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrQl eta_sdrQm]
        let {
          sat_sdrQn [Occ=Once, Dmd=<L,1*U>] :: [a_ado9V]
          [LclId] =
              [$dFoldable_sdrQl eta_sdrQm] \s []
                  Data.Foldable.toList $dFoldable_sdrQl eta_sdrQm;
        } in 
          case Data.OldList.$winits sat_sdrQn of {
            (#,#) ww1_sdrQp [Occ=Once] ww2_sdrQq [Occ=Once] ->
                GHC.Base.:| [ww1_sdrQp ww2_sdrQq];
          };

Data.List.NonEmpty.tails1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [xs_sdrQr]
        let {
          sat_sdrQv [Occ=Once] :: [[a_sdp1n]]
          [LclId] =
              [xs_sdrQr] \u []
                  case xs_sdrQr of {
                    [] -> [] [];
                    : _ [Occ=Dead] xs'_sdrQu [Occ=Once] ->
                        Data.List.NonEmpty.tails1 xs'_sdrQu;
                  };
        } in  : [xs_sdrQr sat_sdrQv];

Data.List.NonEmpty.tails [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     f a -> GHC.Base.NonEmpty [a]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdrQw w1_sdrQx]
        let {
          sat_sdrQy [Occ=Once] :: [a_sdp1n]
          [LclId] =
              [w_sdrQw w1_sdrQx] \u [] Data.Foldable.toList w_sdrQw w1_sdrQx;
        } in 
          case Data.List.NonEmpty.tails1 sat_sdrQy of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrQB [Occ=Once] as_sdrQC [Occ=Once] ->
                GHC.Base.:| [a1_sdrQB as_sdrQC];
          };

Data.List.NonEmpty.insert
  :: forall (f :: * -> *) a.
     (Data.Foldable.Foldable f, GHC.Classes.Ord a) =>
     a -> f a -> GHC.Base.NonEmpty a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*U(A,1*C(C1(U)),A,A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrQD $dOrd_sdrQE a1_sdrQF eta_sdrQG]
        case Data.Foldable.toList $dFoldable_sdrQD eta_sdrQG of sat_sdrQI {
          __DEFAULT ->
              let {
                sat_sdrQH [Occ=Once, Dmd=<L,C(C1(U))>]
                  :: a_adoav -> a_adoav -> GHC.Types.Ordering
                [LclId] =
                    [$dOrd_sdrQE] \u [] GHC.Classes.compare $dOrd_sdrQE;
              } in 
                case Data.OldList.$winsertBy sat_sdrQH a1_sdrQF sat_sdrQI of {
                  (#,#) ww1_sdrQK [Occ=Once] ww2_sdrQL [Occ=Once] ->
                      GHC.Base.:| [ww1_sdrQK ww2_sdrQL];
                };
        };

Data.List.NonEmpty.scanl
  :: forall (f :: * -> *) b a.
     Data.Foldable.Foldable f =>
     (b -> a -> b) -> b -> f a -> GHC.Base.NonEmpty b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrQM f1_sdrQN z_sdrQO eta_sdrQP]
        let {
          sat_sdrQU [Occ=Once] :: [b_adoaP]
          [LclId] =
              [$dFoldable_sdrQM f1_sdrQN z_sdrQO eta_sdrQP] \u []
                  let {
                    sat_sdrQQ [Occ=Once, Dmd=<L,1*U>] :: [a_adoaQ]
                    [LclId] =
                        [$dFoldable_sdrQM eta_sdrQP] \s []
                            Data.Foldable.toList $dFoldable_sdrQM eta_sdrQP;
                  } in 
                    case GHC.List.$wscanlGo f1_sdrQN z_sdrQO sat_sdrQQ of {
                      (#,#) _ [Occ=Dead] ww2_sdrQT [Occ=Once] -> ww2_sdrQT;
                    };
        } in  GHC.Base.:| [z_sdrQO sat_sdrQU];

Data.List.NonEmpty.scanr
  :: forall (f :: * -> *) a b.
     Data.Foldable.Foldable f =>
     (a -> b -> b) -> b -> f a -> GHC.Base.NonEmpty b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrQV f1_sdrQW z_sdrQX eta_sdrQY]
        case Data.Foldable.toList $dFoldable_sdrQV eta_sdrQY of sat_sdrQZ {
          __DEFAULT ->
              case GHC.List.$wscanr f1_sdrQW z_sdrQX sat_sdrQZ of {
                (#,#) ww1_sdrR1 [Occ=Once] ww2_sdrR2 [Occ=Once] ->
                    GHC.Base.:| [ww1_sdrR1 ww2_sdrR2];
              };
        };

Data.List.NonEmpty.scanl1
  :: forall a.
     (a -> a -> a) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdrR3 ds_sdrR4]
        let {
          a1_sdrR5 :: a_adobr
          [LclId] =
              [ds_sdrR4] \u []
                  case ds_sdrR4 of {
                    GHC.Base.:| a2_sdrR7 [Occ=Once] _ [Occ=Dead] -> a2_sdrR7;
                  }; } in
        let {
          sat_sdrRf [Occ=Once] :: [a_adobr]
          [LclId] =
              [f_sdrR3 ds_sdrR4 a1_sdrR5] \u []
                  case ds_sdrR4 of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrRb [Occ=Once] ->
                        case GHC.List.$wscanlGo f_sdrR3 a1_sdrR5 as_sdrRb of {
                          (#,#) _ [Occ=Dead] ww2_sdrRe [Occ=Once] -> ww2_sdrRe;
                        };
                  };
        } in  GHC.Base.:| [a1_sdrR5 sat_sdrRf];

Data.List.NonEmpty.scanr1
  :: forall a.
     (a -> a -> a) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdrRg ds_sdrRh]
        let {
          sat_sdrRp [Occ=Once] :: [a_adobw]
          [LclId] =
              [ds_sdrRh] \u []
                  case ds_sdrRh of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrRo [Occ=Once] -> as_sdrRo;
                  }; } in
        let {
          sat_sdrRl [Occ=Once] :: a_adobw
          [LclId] =
              [ds_sdrRh] \u []
                  case ds_sdrRh of {
                    GHC.Base.:| a1_sdrRj [Occ=Once] _ [Occ=Dead] -> a1_sdrRj;
                  }; } in
        let {
          sat_sdrRq [Occ=Once] :: [a_adobw]
          [LclId] =
              CCCS :! [sat_sdrRl sat_sdrRp];
        } in 
          case GHC.List.scanr1 f_sdrRg sat_sdrRq of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrRs [Occ=Once] as_sdrRt [Occ=Once] ->
                GHC.Base.:| [a1_sdrRs as_sdrRt];
          };

Data.List.NonEmpty.toList :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_sdrRu]
        let {
          sat_sdrRC [Occ=Once] :: [a_ado7K]
          [LclId] =
              [ds_sdrRu] \u []
                  case ds_sdrRu of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrRB [Occ=Once] -> as_sdrRB;
                  }; } in
        let {
          sat_sdrRy [Occ=Once] :: a_ado7K
          [LclId] =
              [ds_sdrRu] \u []
                  case ds_sdrRu of {
                    GHC.Base.:| a1_sdrRw [Occ=Once] _ [Occ=Dead] -> a1_sdrRw;
                  };
        } in  : [sat_sdrRy sat_sdrRC];

Data.List.NonEmpty.$wtake [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Prim.Int# -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ww_sdrRD w_sdrRE]
        case <# [0# ww_sdrRD] of {
          __DEFAULT -> [] [];
          1# ->
              let {
                sat_sdrRN [Occ=Once] :: [a_sdp1u]
                [LclId] =
                    [w_sdrRE] \u []
                        case w_sdrRE of {
                          GHC.Base.:| _ [Occ=Dead] as_sdrRM [Occ=Once] -> as_sdrRM;
                        }; } in
              let {
                sat_sdrRJ [Occ=Once] :: a_sdp1u
                [LclId] =
                    [w_sdrRE] \u []
                        case w_sdrRE of {
                          GHC.Base.:| a1_sdrRH [Occ=Once] _ [Occ=Dead] -> a1_sdrRH;
                        }; } in
              let {
                sat_sdrRO [Occ=Once] :: [a_sdp1u]
                [LclId] =
                    CCCS :! [sat_sdrRJ sat_sdrRN];
              } in  GHC.List.$wunsafeTake ww_sdrRD sat_sdrRO;
        };

Data.List.NonEmpty.take [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrRP w1_sdrRQ]
        case w_sdrRP of {
          GHC.Types.I# ww1_sdrRS [Occ=Once] ->
              Data.List.NonEmpty.$wtake ww1_sdrRS w1_sdrRQ;
        };

Data.List.NonEmpty.$wunsafeDrop [InlPrag=NOUSERINLINE[0],
                                 Occ=LoopBreaker]
  :: forall a1. GHC.Prim.Int# -> [a1] -> [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sdrRT w_sdrRU]
        case w_sdrRU of {
          [] -> [] [];
          : _ [Occ=Dead] ipv2_sdrRX [Occ=Once*] ->
              case ww_sdrRT of ds3_sdrRY {
                __DEFAULT ->
                    case -# [ds3_sdrRY 1#] of sat_sdrRZ {
                      __DEFAULT -> Data.List.NonEmpty.$wunsafeDrop sat_sdrRZ ipv2_sdrRX;
                    };
                1# -> ipv2_sdrRX;
              };
        };

Data.List.NonEmpty.$wdrop [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Prim.Int# -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ww_sdrS0 w_sdrS1]
        case <=# [ww_sdrS0 0#] of {
          __DEFAULT ->
              let {
                sat_sdrSa [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    [w_sdrS1] \u []
                        case w_sdrS1 of {
                          GHC.Base.:| _ [Occ=Dead] as_sdrS9 [Occ=Once] -> as_sdrS9;
                        }; } in
              let {
                sat_sdrS6 [Occ=Once] :: a_sdp1K
                [LclId] =
                    [w_sdrS1] \u []
                        case w_sdrS1 of {
                          GHC.Base.:| a1_sdrS4 [Occ=Once] _ [Occ=Dead] -> a1_sdrS4;
                        }; } in
              let {
                sat_sdrSb [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    CCCS :! [sat_sdrS6 sat_sdrSa];
              } in  Data.List.NonEmpty.$wunsafeDrop ww_sdrS0 sat_sdrSb;
          1# ->
              let {
                sat_sdrSj [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    [w_sdrS1] \u []
                        case w_sdrS1 of {
                          GHC.Base.:| _ [Occ=Dead] as_sdrSi [Occ=Once] -> as_sdrSi;
                        }; } in
              let {
                sat_sdrSf [Occ=Once] :: a_sdp1K
                [LclId] =
                    [w_sdrS1] \u []
                        case w_sdrS1 of {
                          GHC.Base.:| a1_sdrSd [Occ=Once] _ [Occ=Dead] -> a1_sdrSd;
                        };
              } in  : [sat_sdrSf sat_sdrSj];
        };

Data.List.NonEmpty.drop [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrSk w1_sdrSl]
        case w_sdrSk of {
          GHC.Types.I# ww1_sdrSn [Occ=Once] ->
              Data.List.NonEmpty.$wdrop ww1_sdrSn w1_sdrSl;
        };

Data.List.NonEmpty.splitAt [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrSo w1_sdrSp]
        case w_sdrSo of ww_sdrSq {
          GHC.Types.I# ww1_sdrSr [Occ=Once] ->
              case <=# [ww1_sdrSr 0#] of {
                __DEFAULT ->
                    let {
                      sat_sdrSA [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          [w1_sdrSp] \u []
                              case w1_sdrSp of {
                                GHC.Base.:| _ [Occ=Dead] as_sdrSz [Occ=Once] -> as_sdrSz;
                              }; } in
                    let {
                      sat_sdrSw [Occ=Once] :: a_sdp1S
                      [LclId] =
                          [w1_sdrSp] \u []
                              case w1_sdrSp of {
                                GHC.Base.:| a1_sdrSu [Occ=Once] _ [Occ=Dead] -> a1_sdrSu;
                              }; } in
                    let {
                      sat_sdrSB [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          CCCS :! [sat_sdrSw sat_sdrSA];
                    } in 
                      case GHC.List.$wsplitAt' ww_sdrSq sat_sdrSB of {
                        (#,#) ww3_sdrSD [Occ=Once] ww4_sdrSE [Occ=Once] ->
                            (,) [ww3_sdrSD ww4_sdrSE];
                      };
                1# ->
                    let {
                      sat_sdrSM [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          [w1_sdrSp] \u []
                              case w1_sdrSp of {
                                GHC.Base.:| _ [Occ=Dead] as_sdrSL [Occ=Once] -> as_sdrSL;
                              }; } in
                    let {
                      sat_sdrSI [Occ=Once] :: a_sdp1S
                      [LclId] =
                          [w1_sdrSp] \u []
                              case w1_sdrSp of {
                                GHC.Base.:| a1_sdrSG [Occ=Once] _ [Occ=Dead] -> a1_sdrSG;
                              }; } in
                    let {
                      sat_sdrSN [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          CCCS :! [sat_sdrSI sat_sdrSM];
                    } in  (,) [GHC.Types.[] sat_sdrSN];
              };
        };

Data.List.NonEmpty.takeWhile
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdrSO x_sdrSP]
        let {
          sat_sdrSX [Occ=Once] :: [a_ado8a]
          [LclId] =
              [x_sdrSP] \u []
                  case x_sdrSP of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrSW [Occ=Once] -> as_sdrSW;
                  }; } in
        let {
          sat_sdrST [Occ=Once] :: a_ado8a
          [LclId] =
              [x_sdrSP] \u []
                  case x_sdrSP of {
                    GHC.Base.:| a1_sdrSR [Occ=Once] _ [Occ=Dead] -> a1_sdrSR;
                  }; } in
        let {
          sat_sdrSY [Occ=Once] :: [a_ado8a]
          [LclId] =
              CCCS :! [sat_sdrST sat_sdrSX];
        } in  GHC.List.takeWhile p_sdrSO sat_sdrSY;

Data.List.NonEmpty.dropWhile
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdrSZ x_sdrT0]
        let {
          sat_sdrT8 [Occ=Once] :: [a_ado8h]
          [LclId] =
              [x_sdrT0] \u []
                  case x_sdrT0 of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrT7 [Occ=Once] -> as_sdrT7;
                  }; } in
        let {
          sat_sdrT4 [Occ=Once] :: a_ado8h
          [LclId] =
              [x_sdrT0] \u []
                  case x_sdrT0 of {
                    GHC.Base.:| a1_sdrT2 [Occ=Once] _ [Occ=Dead] -> a1_sdrT2;
                  }; } in
        let {
          sat_sdrT9 [Occ=Once] :: [a_ado8h]
          [LclId] =
              CCCS :! [sat_sdrT4 sat_sdrT8];
        } in  GHC.List.dropWhile p_sdrSZ sat_sdrT9;

Data.List.NonEmpty.span
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [p_sdrTa x_sdrTb]
        let {
          sat_sdrTj [Occ=Once] :: [a_ado8p]
          [LclId] =
              [x_sdrTb] \u []
                  case x_sdrTb of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrTi [Occ=Once] -> as_sdrTi;
                  }; } in
        let {
          sat_sdrTf [Occ=Once] :: a_ado8p
          [LclId] =
              [x_sdrTb] \u []
                  case x_sdrTb of {
                    GHC.Base.:| a1_sdrTd [Occ=Once] _ [Occ=Dead] -> a1_sdrTd;
                  }; } in
        let {
          sat_sdrTk [Occ=Once] :: [a_ado8p]
          [LclId] =
              CCCS :! [sat_sdrTf sat_sdrTj];
        } in 
          case GHC.List.$wspan p_sdrTa sat_sdrTk of {
            (#,#) ww1_sdrTm [Occ=Once] ww2_sdrTn [Occ=Once] ->
                (,) [ww1_sdrTm ww2_sdrTn];
          };

Data.List.NonEmpty.$wbreak [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrTo w1_sdrTp]
        let {
          sat_sdrTA [Occ=Once] :: [a_sdp23]
          [LclId] =
              [w1_sdrTp] \u []
                  case w1_sdrTp of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrTz [Occ=Once] -> as_sdrTz;
                  }; } in
        let {
          sat_sdrTw [Occ=Once] :: a_sdp23
          [LclId] =
              [w1_sdrTp] \u []
                  case w1_sdrTp of {
                    GHC.Base.:| a1_sdrTu [Occ=Once] _ [Occ=Dead] -> a1_sdrTu;
                  }; } in
        let {
          sat_sdrTB [Occ=Once] :: [a_sdp23]
          [LclId] =
              CCCS :! [sat_sdrTw sat_sdrTA]; } in
        let {
          sat_sdrTs [Occ=Once] :: a_sdp23 -> GHC.Types.Bool
          [LclId] =
              [w_sdrTo] \r [x_sdrTq]
                  case w_sdrTo x_sdrTq of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  GHC.List.$wspan sat_sdrTs sat_sdrTB;

Data.List.NonEmpty.break [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrTC w1_sdrTD]
        case Data.List.NonEmpty.$wbreak w_sdrTC w1_sdrTD of {
          (#,#) ww1_sdrTF [Occ=Once] ww2_sdrTG [Occ=Once] ->
              (,) [ww1_sdrTF ww2_sdrTG];
        };

Data.List.NonEmpty.filter
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdrTH x_sdrTI]
        let {
          sat_sdrTQ [Occ=Once] :: [a_ado8C]
          [LclId] =
              [x_sdrTI] \u []
                  case x_sdrTI of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrTP [Occ=Once] -> as_sdrTP;
                  }; } in
        let {
          sat_sdrTM [Occ=Once] :: a_ado8C
          [LclId] =
              [x_sdrTI] \u []
                  case x_sdrTI of {
                    GHC.Base.:| a1_sdrTK [Occ=Once] _ [Occ=Dead] -> a1_sdrTK;
                  }; } in
        let {
          sat_sdrTR [Occ=Once] :: [a_ado8C]
          [LclId] =
              CCCS :! [sat_sdrTM sat_sdrTQ];
        } in  GHC.List.filter p_sdrTH sat_sdrTR;

Data.List.NonEmpty.$wpartition [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrTS w1_sdrTT]
        let {
          $wgo_sdrTU [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: [a_sdp2f] -> (# [a_sdp2f], [a_sdp2f] #)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sdrTS $wgo_sdrTU] \r [w2_sdrTV]
                  case w2_sdrTV of {
                    [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
                    : y_sdrTX ys_sdrTY [Occ=Once] ->
                        let {
                          w3_sdrTZ [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp2f], [a_sdp2f])
                          [LclId] =
                              [$wgo_sdrTU ys_sdrTY] \u []
                                  case $wgo_sdrTU ys_sdrTY of {
                                    (#,#) ww1_sdrU1 [Occ=Once] ww2_sdrU2 [Occ=Once] ->
                                        (,) [ww1_sdrU1 ww2_sdrU2];
                                  };
                        } in 
                          case w_sdrTS y_sdrTX of {
                            GHC.Types.False ->
                                let {
                                  sat_sdrUb [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdrTZ] \u []
                                          case w3_sdrTZ of {
                                            (,) _ [Occ=Dead] fs_sdrUa [Occ=Once] -> fs_sdrUa;
                                          }; } in
                                let {
                                  sat_sdrUc [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      CCCS :! [y_sdrTX sat_sdrUb]; } in
                                let {
                                  sat_sdrU7 [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdrTZ] \u []
                                          case w3_sdrTZ of {
                                            (,) ts_sdrU5 [Occ=Once] _ [Occ=Dead] -> ts_sdrU5;
                                          };
                                } in  (#,#) [sat_sdrU7 sat_sdrUc];
                            GHC.Types.True ->
                                let {
                                  sat_sdrUl [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdrTZ] \u []
                                          case w3_sdrTZ of {
                                            (,) _ [Occ=Dead] fs_sdrUk [Occ=Once] -> fs_sdrUk;
                                          }; } in
                                let {
                                  sat_sdrUg [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdrTZ] \u []
                                          case w3_sdrTZ of {
                                            (,) ts_sdrUe [Occ=Once] _ [Occ=Dead] -> ts_sdrUe;
                                          }; } in
                                let {
                                  sat_sdrUh [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      CCCS :! [y_sdrTX sat_sdrUg];
                                } in  (#,#) [sat_sdrUh sat_sdrUl];
                          };
                  }; } in
        let {
          sat_sdrUt [Occ=Once] :: [a_sdp2f]
          [LclId] =
              [w1_sdrTT] \u []
                  case w1_sdrTT of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrUs [Occ=Once] -> as_sdrUs;
                  }; } in
        let {
          sat_sdrUp [Occ=Once] :: a_sdp2f
          [LclId] =
              [w1_sdrTT] \u []
                  case w1_sdrTT of {
                    GHC.Base.:| a1_sdrUn [Occ=Once] _ [Occ=Dead] -> a1_sdrUn;
                  }; } in
        let {
          sat_sdrUu [Occ=Once] :: [a_sdp2f]
          [LclId] =
              CCCS :! [sat_sdrUp sat_sdrUt];
        } in  $wgo_sdrTU sat_sdrUu;

Data.List.NonEmpty.partition [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrUv w1_sdrUw]
        case Data.List.NonEmpty.$wpartition w_sdrUv w1_sdrUw of {
          (#,#) ww1_sdrUy [Occ=Once] ww2_sdrUz [Occ=Once] ->
              (,) [ww1_sdrUy ww2_sdrUz];
        };

Data.List.NonEmpty.cycle [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_sdrUA]
        let {
          xs'_sdrUB [Occ=LoopBreaker] :: [a_sdp2m]
          [LclId] =
              [w_sdrUA xs'_sdrUB] \u []
                  let {
                    sat_sdrUJ [Occ=OnceL] :: [a_sdp2m]
                    [LclId] =
                        [w_sdrUA] \u []
                            case w_sdrUA of {
                              GHC.Base.:| _ [Occ=Dead] as_sdrUI [Occ=Once] -> as_sdrUI;
                            }; } in
                  let {
                    sat_sdrUF [Occ=OnceL] :: a_sdp2m
                    [LclId] =
                        [w_sdrUA] \u []
                            case w_sdrUA of {
                              GHC.Base.:| a1_sdrUD [Occ=Once] _ [Occ=Dead] -> a1_sdrUD;
                            }; } in
                  let {
                    sat_sdrUK [Occ=Once] :: [a_sdp2m]
                    [LclId] =
                        CCCS :! [sat_sdrUF sat_sdrUJ];
                  } in  GHC.Base.++ sat_sdrUK xs'_sdrUB;
        } in 
          case xs'_sdrUB of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrUN [Occ=Once] as_sdrUO [Occ=Once] ->
                GHC.Base.:| [a1_sdrUN as_sdrUO];
          };

Data.List.NonEmpty.$wtranspose [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
     -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId, Arity=1, Str=<L,U(U(1*U,1*U),1*U)>, Unf=OtherCon []] =
    [] \r [w_sdrUP]
        let {
          ds_sdrUQ [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty [a_sdp2s]
          [LclId] =
              [w_sdrUP] \u []
                  let {
                    sat_sdrV9 [Occ=OnceL] :: [[a_sdp2s]]
                    [LclId] =
                        [w_sdrUP] \u []
                            case w_sdrUP of {
                              GHC.Base.:| _ [Occ=Dead] as_sdrV8 [Occ=Once] ->
                                  GHC.Base.map Data.List.NonEmpty.toList as_sdrV8;
                            }; } in
                  let {
                    sat_sdrV4 [Occ=OnceL] :: [a_sdp2s]
                    [LclId] =
                        [w_sdrUP] \u []
                            case w_sdrUP of {
                              GHC.Base.:| a1_sdrUZ [Occ=Once!] _ [Occ=Dead] ->
                                  case a1_sdrUZ of {
                                    GHC.Base.:| _ [Occ=Dead] as1_sdrV3 [Occ=Once] -> as1_sdrV3;
                                  };
                            }; } in
                  let {
                    sat_sdrUX [Occ=OnceL] :: a_sdp2s
                    [LclId] =
                        [w_sdrUP] \u []
                            case w_sdrUP of {
                              GHC.Base.:| a1_sdrUS [Occ=Once!] _ [Occ=Dead] ->
                                  case a1_sdrUS of {
                                    GHC.Base.:| a2_sdrUV [Occ=Once] _ [Occ=Dead] -> a2_sdrUV;
                                  };
                            }; } in
                  let {
                    sat_sdrV5 [Occ=OnceL] :: [a_sdp2s]
                    [LclId] =
                        CCCS :! [sat_sdrUX sat_sdrV4]; } in
                  let {
                    sat_sdrVa [Occ=Once] :: [[a_sdp2s]]
                    [LclId] =
                        CCCS :! [sat_sdrV5 sat_sdrV9];
                  } in 
                    case Data.OldList.transpose sat_sdrVa of {
                      [] -> Data.List.NonEmpty.cycle1;
                      : a1_sdrVc [Occ=Once] as_sdrVd [Occ=Once] ->
                          GHC.Base.:| [a1_sdrVc as_sdrVd];
                    }; } in
        let {
          sat_sdrVo [Occ=Once] :: [GHC.Base.NonEmpty a_sdp2s]
          [LclId] =
              [ds_sdrUQ] \u []
                  case ds_sdrUQ of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrVn [Occ=Once] ->
                        GHC.Base.map Data.List.NonEmpty.fromList as_sdrVn;
                  }; } in
        let {
          sat_sdrVk [Occ=Once] :: GHC.Base.NonEmpty a_sdp2s
          [LclId] =
              [ds_sdrUQ] \u []
                  case ds_sdrUQ of {
                    GHC.Base.:| a1_sdrVf [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdrVf of {
                          [] -> Data.List.NonEmpty.cycle1;
                          : a2_sdrVi [Occ=Once] as1_sdrVj [Occ=Once] ->
                              GHC.Base.:| [a2_sdrVi as1_sdrVj];
                        };
                  };
        } in  (#,#) [sat_sdrVk sat_sdrVo];

Data.List.NonEmpty.transpose [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
     -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId, Arity=1, Str=<L,U(U(U,U),U)>m, Unf=OtherCon []] =
    [] \r [w_sdrVp]
        case Data.List.NonEmpty.$wtranspose w_sdrVp of {
          (#,#) ww1_sdrVr [Occ=Once] ww2_sdrVs [Occ=Once] ->
              GHC.Base.:| [ww1_sdrVr ww2_sdrVs];
        };

Data.List.NonEmpty.map
  :: forall a b.
     (a -> b) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdrVt ds_sdrVu]
        let {
          sat_sdrVD [Occ=Once] :: [b_ado7C]
          [LclId] =
              [f_sdrVt ds_sdrVu] \u []
                  case ds_sdrVu of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrVC [Occ=Once] ->
                        GHC.Base.map f_sdrVt as_sdrVC;
                  }; } in
        let {
          sat_sdrVz [Occ=Once] :: b_ado7C
          [LclId] =
              [f_sdrVt ds_sdrVu] \u []
                  let {
                    sat_sdrVy [Occ=Once] :: a_ado7B
                    [LclId] =
                        [ds_sdrVu] \u []
                            case ds_sdrVu of {
                              GHC.Base.:| a1_sdrVw [Occ=Once] _ [Occ=Dead] -> a1_sdrVw;
                            };
                  } in  f_sdrVt sat_sdrVy;
        } in  GHC.Base.:| [sat_sdrVz sat_sdrVD];

Data.List.NonEmpty.some1
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     f a -> f (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sdrVE eta_sdrVF]
        let {
          sat_sdrVH [Occ=Once] :: f_ado7n [a_ado7o]
          [LclId] =
              [$dAlternative_sdrVE eta_sdrVF] \u []
                  GHC.Base.many $dAlternative_sdrVE eta_sdrVF;
        } in 
          case GHC.Base.$p1Alternative $dAlternative_sdrVE of sat_sdrVG {
            __DEFAULT ->
                GHC.Base.liftA2 sat_sdrVG GHC.Base.:| eta_sdrVF sat_sdrVH;
          };

Data.List.NonEmpty.intersperse [InlPrag=NOUSERINLINE[0]]
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrVI w1_sdrVJ]
        let {
          sat_sdrVW [Occ=Once] :: [a_sdp2C]
          [LclId] =
              [w_sdrVI w1_sdrVJ] \u []
                  case w1_sdrVJ of {
                    GHC.Base.:| _ [Occ=Dead] bs_sdrVQ [Occ=Once!] ->
                        case bs_sdrVQ of {
                          [] -> [] [];
                          : ipv_sdrVS [Occ=Once] ipv1_sdrVT [Occ=Once] ->
                              let {
                                sat_sdrVU [Occ=Once] :: [a_sdp2C]
                                [LclId] =
                                    [w_sdrVI ipv1_sdrVT] \u []
                                        Data.OldList.prependToAll w_sdrVI ipv1_sdrVT; } in
                              let {
                                sat_sdrVV [Occ=Once] :: [a_sdp2C]
                                [LclId] =
                                    CCCS :! [ipv_sdrVS sat_sdrVU];
                              } in  : [w_sdrVI sat_sdrVV];
                        };
                  }; } in
        let {
          sat_sdrVN [Occ=Once] :: a_sdp2C
          [LclId] =
              [w1_sdrVJ] \u []
                  case w1_sdrVJ of {
                    GHC.Base.:| b_sdrVL [Occ=Once] _ [Occ=Dead] -> b_sdrVL;
                  };
        } in  GHC.Base.:| [sat_sdrVN sat_sdrVW];

Data.List.NonEmpty.iterate
  :: forall a. (a -> a) -> a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_sdrVX a1_sdrVY]
        let {
          sat_sdrW3 [Occ=Once] :: [a_ado7a]
          [LclId] =
              [f_sdrVX a1_sdrVY] \u []
                  let {
                    sat_sdrVZ [Occ=Once] :: a_ado7a
                    [LclId] =
                        [f_sdrVX a1_sdrVY] \u [] f_sdrVX a1_sdrVY;
                  } in 
                    case GHC.List.$witerate f_sdrVX sat_sdrVZ of {
                      (#,#) ww1_sdrW1 [Occ=Once] ww2_sdrW2 [Occ=Once] ->
                          : [ww1_sdrW1 ww2_sdrW2];
                    };
        } in  GHC.Base.:| [a1_sdrVY sat_sdrW3];

Data.List.NonEmpty.repeat :: forall a. a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [a1_sdrW4]
        let {
          sat_sdrW5 [Occ=Once] :: [a_ado76]
          [LclId] =
              [a1_sdrW4] \u [] GHC.List.repeat a1_sdrW4;
        } in  GHC.Base.:| [a1_sdrW4 sat_sdrW5];

Data.List.NonEmpty.groupBy_$sgroupBy [Occ=LoopBreaker]
  :: forall a.
     (a -> a -> GHC.Types.Bool) -> [a] -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eq0_sdrW6 eta_sdrW7]
        case eta_sdrW7 of {
          [] -> [] [];
          : x_sdrW9 xs_sdrWa [Occ=Once] ->
              let {
                ds_sdrWb [Dmd=<L,U(1*U,1*U)>] :: ([a_Xdo51], [a_Xdo51])
                [LclId] =
                    [eq0_sdrW6 x_sdrW9 xs_sdrWa] \u []
                        let {
                          sat_sdrWc [Occ=Once, Dmd=<L,C(U)>] :: a_Xdo51 -> GHC.Types.Bool
                          [LclId] =
                              [eq0_sdrW6 x_sdrW9] \u [] eq0_sdrW6 x_sdrW9;
                        } in 
                          case GHC.List.$wspan sat_sdrWc xs_sdrWa of {
                            (#,#) ww1_sdrWe [Occ=Once] ww2_sdrWf [Occ=Once] ->
                                (,) [ww1_sdrWe ww2_sdrWf];
                          }; } in
              let {
                sat_sdrWo [Occ=Once] :: [GHC.Base.NonEmpty a_Xdo51]
                [LclId] =
                    [eq0_sdrW6 ds_sdrWb] \u []
                        case ds_sdrWb of {
                          (,) _ [Occ=Dead] zs_sdrWn [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdrW6 zs_sdrWn;
                        }; } in
              let {
                sat_sdrWj [Occ=Once] :: [a_Xdo51]
                [LclId] =
                    [ds_sdrWb] \u []
                        case ds_sdrWb of {
                          (,) ys_sdrWh [Occ=Once] _ [Occ=Dead] -> ys_sdrWh;
                        }; } in
              let {
                sat_sdrWk [Occ=Once] :: GHC.Base.NonEmpty a_Xdo51
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdrW9 sat_sdrWj];
              } in  : [sat_sdrWk sat_sdrWo];
        };

Data.List.NonEmpty.groupBy
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     (a -> a -> GHC.Types.Bool) -> f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrWp eq0_sdrWq eta_sdrWr]
        case Data.Foldable.toList $dFoldable_sdrWp eta_sdrWr of {
          [] -> [] [];
          : x_sdrWt xs_sdrWu [Occ=Once] ->
              let {
                ds_sdrWv [Dmd=<L,U(1*U,1*U)>] :: ([a_ado4Z], [a_ado4Z])
                [LclId] =
                    [eq0_sdrWq x_sdrWt xs_sdrWu] \u []
                        let {
                          sat_sdrWw [Occ=Once, Dmd=<L,C(U)>] :: a_ado4Z -> GHC.Types.Bool
                          [LclId] =
                              [eq0_sdrWq x_sdrWt] \u [] eq0_sdrWq x_sdrWt;
                        } in 
                          case GHC.List.$wspan sat_sdrWw xs_sdrWu of {
                            (#,#) ww1_sdrWy [Occ=Once] ww2_sdrWz [Occ=Once] ->
                                (,) [ww1_sdrWy ww2_sdrWz];
                          }; } in
              let {
                sat_sdrWI [Occ=Once] :: [GHC.Base.NonEmpty a_ado4Z]
                [LclId] =
                    [eq0_sdrWq ds_sdrWv] \u []
                        case ds_sdrWv of {
                          (,) _ [Occ=Dead] zs_sdrWH [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdrWq zs_sdrWH;
                        }; } in
              let {
                sat_sdrWD [Occ=Once] :: [a_ado4Z]
                [LclId] =
                    [ds_sdrWv] \u []
                        case ds_sdrWv of {
                          (,) ys_sdrWB [Occ=Once] _ [Occ=Dead] -> ys_sdrWB;
                        }; } in
              let {
                sat_sdrWE [Occ=Once] :: GHC.Base.NonEmpty a_ado4Z
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdrWt sat_sdrWD];
              } in  : [sat_sdrWE sat_sdrWI];
        };

Data.List.NonEmpty.groupWith
  :: forall (f :: * -> *) b a.
     (Data.Foldable.Foldable f, GHC.Classes.Eq b) =>
     (a -> b) -> f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrWJ $dEq_sdrWK f1_sdrWL eta_sdrWM]
        case Data.Foldable.toList $dFoldable_sdrWJ eta_sdrWM of {
          [] -> [] [];
          : x_sdrWO xs_sdrWP [Occ=Once] ->
              let {
                eq0_sdrWQ [Dmd=<L,C(C(U))>] :: a_ado5N -> a_ado5N -> GHC.Types.Bool
                [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                    [$dEq_sdrWK f1_sdrWL] \r [x1_sdrWR y_sdrWS]
                        let {
                          sat_sdrWU [Occ=Once] :: b_ado5M
                          [LclId] =
                              [f1_sdrWL y_sdrWS] \u [] f1_sdrWL y_sdrWS; } in
                        let {
                          sat_sdrWT [Occ=Once] :: b_ado5M
                          [LclId] =
                              [f1_sdrWL x1_sdrWR] \u [] f1_sdrWL x1_sdrWR;
                        } in  GHC.Classes.== $dEq_sdrWK sat_sdrWT sat_sdrWU; } in
              let {
                ds_sdrWV [Dmd=<L,U(1*U,1*U)>] :: ([a_ado5N], [a_ado5N])
                [LclId] =
                    [x_sdrWO xs_sdrWP eq0_sdrWQ] \u []
                        let {
                          sat_sdrWW [Occ=Once] :: a_ado5N -> GHC.Types.Bool
                          [LclId] =
                              [x_sdrWO eq0_sdrWQ] \r [eta_B1] eq0_sdrWQ x_sdrWO eta_B1;
                        } in 
                          case GHC.List.$wspan sat_sdrWW xs_sdrWP of {
                            (#,#) ww1_sdrWY [Occ=Once] ww2_sdrWZ [Occ=Once] ->
                                (,) [ww1_sdrWY ww2_sdrWZ];
                          }; } in
              let {
                sat_sdrX8 [Occ=Once] :: [GHC.Base.NonEmpty a_ado5N]
                [LclId] =
                    [eq0_sdrWQ ds_sdrWV] \u []
                        case ds_sdrWV of {
                          (,) _ [Occ=Dead] zs_sdrX7 [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdrWQ zs_sdrX7;
                        }; } in
              let {
                sat_sdrX3 [Occ=Once] :: [a_ado5N]
                [LclId] =
                    [ds_sdrWV] \u []
                        case ds_sdrWV of {
                          (,) ys_sdrX1 [Occ=Once] _ [Occ=Dead] -> ys_sdrX1;
                        }; } in
              let {
                sat_sdrX4 [Occ=Once] :: GHC.Base.NonEmpty a_ado5N
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdrWO sat_sdrX3];
              } in  : [sat_sdrX4 sat_sdrX8];
        };

Data.List.NonEmpty.group
  :: forall (f :: * -> *) a.
     (Data.Foldable.Foldable f, GHC.Classes.Eq a) =>
     f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*U(1*C(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrX9 $dEq_sdrXa eta_sdrXb]
        let {
          sat_sdrXc [Occ=Once, Dmd=<L,C(C(U))>]
            :: a_ado6W -> a_ado6W -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdrXa] \u [] GHC.Classes.== $dEq_sdrXa;
        } in 
          Data.List.NonEmpty.groupBy $dFoldable_sdrX9 sat_sdrXc eta_sdrXb;

Data.List.NonEmpty.isPrefixOf
  :: forall a.
     GHC.Classes.Eq a =>
     [a] -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><S,1*U><L,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdrXd ds_sdrXe ds1_sdrXf]
        case ds_sdrXe of {
          [] -> GHC.Types.True [];
          : y_sdrXh [Occ=Once] ys_sdrXi [Occ=Once] ->
              case ds1_sdrXf of {
                GHC.Base.:| x_sdrXk [Occ=Once] xs_sdrXl [Occ=Once] ->
                    case GHC.Classes.== $dEq_sdrXd y_sdrXh x_sdrXk of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True ->
                          Data.OldList.isPrefixOf $dEq_sdrXd ys_sdrXi xs_sdrXl;
                    };
              };
        };

lvl1_rdpwu :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.!! negative argument"#;

Data.List.NonEmpty.!!1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rdpwu of sat_sdrXn {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sdrXn;
        };

Data.List.NonEmpty.$w!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. a -> [a] -> GHC.Prim.Int# -> a
[GblId, Arity=3, Str=<L,1*U><L,1*U><S,1*U>, Unf=OtherCon []] =
    [] \r [ww_sdrXo ww1_sdrXp ww2_sdrXq]
        case ww2_sdrXq of wild_sdrXr {
          __DEFAULT ->
              case ># [wild_sdrXr 0#] of {
                __DEFAULT -> Data.List.NonEmpty.!!1;
                1# ->
                    case -# [wild_sdrXr 1#] of sat_sdrXt {
                      __DEFAULT -> GHC.List.$w!! ww1_sdrXp sat_sdrXt;
                    };
              };
          0# -> ww_sdrXo;
        };

Data.List.NonEmpty.!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int -> a
[GblId,
 Arity=2,
 Str=<S,1*U(1*U,1*U)><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrXu w1_sdrXv]
        case w_sdrXu of {
          GHC.Base.:| ww1_sdrXx [Occ=Once] ww2_sdrXy [Occ=Once] ->
              case w1_sdrXv of {
                GHC.Types.I# ww4_sdrXA [Occ=Once] ->
                    Data.List.NonEmpty.$w!! ww1_sdrXx ww2_sdrXy ww4_sdrXA;
              };
        };

Data.List.NonEmpty.zip
  :: forall a b.
     GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdrXB ds1_sdrXC]
        let {
          sat_sdrXT [Occ=Once] :: [(a_ado4o, b_ado4p)]
          [LclId] =
              [ds_sdrXB ds1_sdrXC] \u []
                  case ds_sdrXB of {
                    GHC.Base.:| _ [Occ=Dead] xs_sdrXO [Occ=Once] ->
                        let {
                          sat_sdrXS [Occ=Once, Dmd=<L,1*U>] :: [b_ado4p]
                          [LclId] =
                              [ds1_sdrXC] \s []
                                  case ds1_sdrXC of {
                                    GHC.Base.:| _ [Occ=Dead] ys_sdrXR [Occ=Once] -> ys_sdrXR;
                                  };
                        } in  GHC.List.zip xs_sdrXO sat_sdrXS;
                  }; } in
        let {
          sat_sdrXK [Occ=Once] :: b_ado4p
          [LclId] =
              [ds1_sdrXC] \u []
                  case ds1_sdrXC of {
                    GHC.Base.:| y_sdrXI [Occ=Once] _ [Occ=Dead] -> y_sdrXI;
                  }; } in
        let {
          sat_sdrXG [Occ=Once] :: a_ado4o
          [LclId] =
              [ds_sdrXB] \u []
                  case ds_sdrXB of {
                    GHC.Base.:| x_sdrXE [Occ=Once] _ [Occ=Dead] -> x_sdrXE;
                  }; } in
        let {
          sat_sdrXL [Occ=Once] :: (a_ado4o, b_ado4p)
          [LclId] =
              CCCS (,)! [sat_sdrXG sat_sdrXK];
        } in  GHC.Base.:| [sat_sdrXL sat_sdrXT];

Data.List.NonEmpty.zipWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b
     -> GHC.Base.NonEmpty c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrXU w1_sdrXV w2_sdrXW]
        let {
          sat_sdrYd [Occ=Once] :: [c_sdp3h]
          [LclId] =
              [w_sdrXU w1_sdrXV w2_sdrXW] \u []
                  case w1_sdrXV of {
                    GHC.Base.:| _ [Occ=Dead] xs_sdrY8 [Occ=Once] ->
                        let {
                          sat_sdrYc [Occ=Once, Dmd=<L,1*U>] :: [b_sdp3g]
                          [LclId] =
                              [w2_sdrXW] \s []
                                  case w2_sdrXW of {
                                    GHC.Base.:| _ [Occ=Dead] ys_sdrYb [Occ=Once] -> ys_sdrYb;
                                  };
                        } in  GHC.List.zipWith w_sdrXU xs_sdrY8 sat_sdrYc;
                  }; } in
        let {
          sat_sdrY5 [Occ=Once] :: c_sdp3h
          [LclId] =
              [w_sdrXU w1_sdrXV w2_sdrXW] \u []
                  let {
                    sat_sdrY4 [Occ=Once] :: b_sdp3g
                    [LclId] =
                        [w2_sdrXW] \u []
                            case w2_sdrXW of {
                              GHC.Base.:| y_sdrY2 [Occ=Once] _ [Occ=Dead] -> y_sdrY2;
                            }; } in
                  let {
                    sat_sdrY0 [Occ=Once] :: a_sdp3f
                    [LclId] =
                        [w1_sdrXV] \u []
                            case w1_sdrXV of {
                              GHC.Base.:| x_sdrXY [Occ=Once] _ [Occ=Dead] -> x_sdrXY;
                            };
                  } in  w_sdrXU sat_sdrY0 sat_sdrY4;
        } in  GHC.Base.:| [sat_sdrY5 sat_sdrYd];

Data.List.NonEmpty.unzip
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     f (a, b) -> (f a, f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sdrYe xs_sdrYf]
        let {
          sat_sdrYh [Occ=Once] :: f_ado3Y b_ado40
          [LclId] =
              [$dFunctor_sdrYe xs_sdrYf] \u []
                  GHC.Base.fmap $dFunctor_sdrYe Data.Tuple.snd xs_sdrYf; } in
        let {
          sat_sdrYg [Occ=Once] :: f_ado3Y a_ado3Z
          [LclId] =
              [$dFunctor_sdrYe xs_sdrYf] \u []
                  GHC.Base.fmap $dFunctor_sdrYe Data.Tuple.fst xs_sdrYf;
        } in  (,) [sat_sdrYg sat_sdrYh];

Data.List.NonEmpty.nubBy [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> a -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrYi w1_sdrYj]
        case w1_sdrYj of {
          GHC.Base.:| ww1_sdrYl ww2_sdrYm [Occ=Once] ->
              let {
                sat_sdrYr [Occ=Once] :: [a_sdp3p]
                [LclId] =
                    [w_sdrYi ww1_sdrYl ww2_sdrYm] \u []
                        let {
                          sat_sdrYp [Occ=Once] :: a_sdp3p -> GHC.Types.Bool
                          [LclId] =
                              [w_sdrYi ww1_sdrYl] \r [b_sdrYn]
                                  case w_sdrYi ww1_sdrYl b_sdrYn of {
                                    GHC.Types.False -> GHC.Types.True [];
                                    GHC.Types.True -> GHC.Types.False [];
                                  };
                        } in 
                          case GHC.List.filter sat_sdrYp ww2_sdrYm of sat_sdrYq {
                            __DEFAULT -> Data.OldList.nubBy w_sdrYi sat_sdrYq;
                          };
              } in  GHC.Base.:| [ww1_sdrYl sat_sdrYr];
        };

Data.List.NonEmpty.nub
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(U)),A)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dEq_sdrYs eta_sdrYt]
        case eta_sdrYt of {
          GHC.Base.:| ww1_sdrYv ww2_sdrYw [Occ=Once] ->
              let {
                sat_sdrYC [Occ=Once] :: [a_ado3R]
                [LclId] =
                    [$dEq_sdrYs ww1_sdrYv ww2_sdrYw] \u []
                        let {
                          w_sdrYx [Dmd=<L,C(C1(U))>] :: a_ado3R -> a_ado3R -> GHC.Types.Bool
                          [LclId] =
                              [$dEq_sdrYs] \u [] GHC.Classes.== $dEq_sdrYs; } in
                        let {
                          sat_sdrYA [Occ=Once] :: a_ado3R -> GHC.Types.Bool
                          [LclId] =
                              [ww1_sdrYv w_sdrYx] \r [b_sdrYy]
                                  case w_sdrYx ww1_sdrYv b_sdrYy of {
                                    GHC.Types.False -> GHC.Types.True [];
                                    GHC.Types.True -> GHC.Types.False [];
                                  };
                        } in 
                          case GHC.List.filter sat_sdrYA ww2_sdrYw of sat_sdrYB {
                            __DEFAULT -> Data.OldList.nubBy w_sdrYx sat_sdrYB;
                          };
              } in  GHC.Base.:| [ww1_sdrYv sat_sdrYC];
        };

Data.List.NonEmpty.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.List.NonEmpty.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.List.NonEmpty.$trModule4];

Data.List.NonEmpty.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.List.NonEmpty"#;

Data.List.NonEmpty.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.List.NonEmpty.$trModule2];

Data.List.NonEmpty.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.List.NonEmpty.$trModule3
                                     Data.List.NonEmpty.$trModule1];

Data.List.NonEmpty.groupAllWith
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b) -> [a] -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdrYD eta_sdrYE eta1_sdrYF]
        let {
          sat_sdrYM [Occ=Once] :: [a_ado65]
          [LclId] =
              [$dOrd_sdrYD eta_sdrYE eta1_sdrYF] \u []
                  let {
                    sat_sdrYL [Occ=Once] :: a_ado65 -> a_ado65 -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sdrYD eta_sdrYE] \r [x_sdrYH y_sdrYI]
                            let {
                              sat_sdrYK [Occ=Once] :: b_ado64
                              [LclId] =
                                  [eta_sdrYE y_sdrYI] \u [] eta_sdrYE y_sdrYI; } in
                            let {
                              sat_sdrYJ [Occ=Once] :: b_ado64
                              [LclId] =
                                  [eta_sdrYE x_sdrYH] \u [] eta_sdrYE x_sdrYH;
                            } in  GHC.Classes.compare $dOrd_sdrYD sat_sdrYJ sat_sdrYK;
                  } in  Data.OldList.sortBy sat_sdrYL eta1_sdrYF; } in
        let {
          sat_sdrYG [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_ado64
          [LclId] =
              [$dOrd_sdrYD] \u [] GHC.Classes.$p1Ord $dOrd_sdrYD;
        } in 
          Data.List.NonEmpty.groupWith
              Data.Foldable.$fFoldable[] sat_sdrYG eta_sdrYE sat_sdrYM;

Data.List.NonEmpty.groupBy1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> a -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrYN w1_sdrYO]
        case w1_sdrYO of {
          GHC.Base.:| ww1_sdrYQ ww2_sdrYR [Occ=Once] ->
              let {
                ds_sdrYS [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp3G], [a_sdp3G])
                [LclId] =
                    [w_sdrYN ww1_sdrYQ ww2_sdrYR] \u []
                        let {
                          sat_sdrYT [Occ=Once, Dmd=<L,C(U)>] :: a_sdp3G -> GHC.Types.Bool
                          [LclId] =
                              [w_sdrYN ww1_sdrYQ] \u [] w_sdrYN ww1_sdrYQ;
                        } in 
                          case GHC.List.$wspan sat_sdrYT ww2_sdrYR of {
                            (#,#) ww4_sdrYV [Occ=Once] ww5_sdrYW [Occ=Once] ->
                                (,) [ww4_sdrYV ww5_sdrYW];
                          }; } in
              let {
                sat_sdrZ5 [Occ=Once] :: [GHC.Base.NonEmpty a_sdp3G]
                [LclId] =
                    [w_sdrYN ds_sdrYS] \u []
                        case ds_sdrYS of {
                          (,) _ [Occ=Dead] zs_sdrZ4 [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy w_sdrYN zs_sdrZ4;
                        }; } in
              let {
                sat_sdrZ0 [Occ=Once] :: [a_sdp3G]
                [LclId] =
                    [ds_sdrYS] \u []
                        case ds_sdrYS of {
                          (,) ys_sdrYY [Occ=Once] _ [Occ=Dead] -> ys_sdrYY;
                        }; } in
              let {
                sat_sdrZ1 [Occ=Once] :: GHC.Base.NonEmpty a_sdp3G
                [LclId] =
                    CCCS GHC.Base.:|! [ww1_sdrYQ sat_sdrZ0];
              } in  GHC.Base.:| [sat_sdrZ1 sat_sdrZ5];
        };

Data.List.NonEmpty.group1
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C(U)),A)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dEq_sdrZ6 eta_sdrZ7]
        case eta_sdrZ7 of {
          GHC.Base.:| ww1_sdrZ9 ww2_sdrZa [Occ=Once] ->
              let {
                w_sdrZb [Dmd=<L,C(C(U))>] :: a_ado6D -> a_ado6D -> GHC.Types.Bool
                [LclId] =
                    [$dEq_sdrZ6] \u [] GHC.Classes.== $dEq_sdrZ6; } in
              let {
                ds_sdrZc [Dmd=<L,U(1*U,1*U)>] :: ([a_ado6D], [a_ado6D])
                [LclId] =
                    [ww1_sdrZ9 ww2_sdrZa w_sdrZb] \u []
                        let {
                          sat_sdrZd [Occ=Once, Dmd=<L,C(U)>] :: a_ado6D -> GHC.Types.Bool
                          [LclId] =
                              [ww1_sdrZ9 w_sdrZb] \u [] w_sdrZb ww1_sdrZ9;
                        } in 
                          case GHC.List.$wspan sat_sdrZd ww2_sdrZa of {
                            (#,#) ww4_sdrZf [Occ=Once] ww5_sdrZg [Occ=Once] ->
                                (,) [ww4_sdrZf ww5_sdrZg];
                          }; } in
              let {
                sat_sdrZp [Occ=Once] :: [GHC.Base.NonEmpty a_ado6D]
                [LclId] =
                    [w_sdrZb ds_sdrZc] \u []
                        case ds_sdrZc of {
                          (,) _ [Occ=Dead] zs_sdrZo [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy w_sdrZb zs_sdrZo;
                        }; } in
              let {
                sat_sdrZk [Occ=Once] :: [a_ado6D]
                [LclId] =
                    [ds_sdrZc] \u []
                        case ds_sdrZc of {
                          (,) ys_sdrZi [Occ=Once] _ [Occ=Dead] -> ys_sdrZi;
                        }; } in
              let {
                sat_sdrZl [Occ=Once] :: GHC.Base.NonEmpty a_ado6D
                [LclId] =
                    CCCS GHC.Base.:|! [ww1_sdrZ9 sat_sdrZk];
              } in  GHC.Base.:| [sat_sdrZl sat_sdrZp];
        };

Data.List.NonEmpty.$wgroupWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Eq b =>
     (a -> b)
     -> a -> [a] -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,C(U)><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdrZq w1_sdrZr ww_sdrZs ww1_sdrZt]
        let {
          eq_sdrZu [Dmd=<L,C(C(U))>] :: a_sdp3T -> a_sdp3T -> GHC.Types.Bool
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w_sdrZq w1_sdrZr] \r [x_sdrZv y_sdrZw]
                  let {
                    sat_sdrZy [Occ=Once] :: b_sdp3S
                    [LclId] =
                        [w1_sdrZr y_sdrZw] \u [] w1_sdrZr y_sdrZw; } in
                  let {
                    sat_sdrZx [Occ=Once] :: b_sdp3S
                    [LclId] =
                        [w1_sdrZr x_sdrZv] \u [] w1_sdrZr x_sdrZv;
                  } in  GHC.Classes.== w_sdrZq sat_sdrZx sat_sdrZy; } in
        let {
          ds_sdrZz [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp3T], [a_sdp3T])
          [LclId] =
              [ww_sdrZs ww1_sdrZt eq_sdrZu] \u []
                  let {
                    sat_sdrZA [Occ=Once] :: a_sdp3T -> GHC.Types.Bool
                    [LclId] =
                        [ww_sdrZs eq_sdrZu] \r [eta_B1] eq_sdrZu ww_sdrZs eta_B1;
                  } in 
                    case GHC.List.$wspan sat_sdrZA ww1_sdrZt of {
                      (#,#) ww3_sdrZC [Occ=Once] ww4_sdrZD [Occ=Once] ->
                          (,) [ww3_sdrZC ww4_sdrZD];
                    }; } in
        let {
          sat_sdrZM [Occ=Once] :: [GHC.Base.NonEmpty a_sdp3T]
          [LclId] =
              [eq_sdrZu ds_sdrZz] \u []
                  case ds_sdrZz of {
                    (,) _ [Occ=Dead] zs_sdrZL [Occ=Once] ->
                        Data.List.NonEmpty.groupBy_$sgroupBy eq_sdrZu zs_sdrZL;
                  }; } in
        let {
          sat_sdrZH [Occ=Once] :: [a_sdp3T]
          [LclId] =
              [ds_sdrZz] \u []
                  case ds_sdrZz of {
                    (,) ys_sdrZF [Occ=Once] _ [Occ=Dead] -> ys_sdrZF;
                  }; } in
        let {
          sat_sdrZI [Occ=Once] :: GHC.Base.NonEmpty a_sdp3T
          [LclId] =
              CCCS GHC.Base.:|! [ww_sdrZs sat_sdrZH];
        } in  (#,#) [sat_sdrZI sat_sdrZM];

Data.List.NonEmpty.groupWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Eq b =>
     (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,C(U)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrZN w1_sdrZO w2_sdrZP]
        case w2_sdrZP of {
          GHC.Base.:| ww1_sdrZR [Occ=Once] ww2_sdrZS [Occ=Once] ->
              case
                  Data.List.NonEmpty.$wgroupWith1
                      w_sdrZN w1_sdrZO ww1_sdrZR ww2_sdrZS
              of
              { (#,#) ww4_sdrZU [Occ=Once] ww5_sdrZV [Occ=Once] ->
                    GHC.Base.:| [ww4_sdrZU ww5_sdrZV];
              };
        };

Data.List.NonEmpty.$wgroupAllWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b)
     -> GHC.Base.NonEmpty a
     -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId,
 Arity=3,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrZW w1_sdrZX w2_sdrZY]
        let {
          sat_sds07 [Occ=Once] :: [a_sdp47]
          [LclId] =
              [w2_sdrZY] \u []
                  case w2_sdrZY of {
                    GHC.Base.:| _ [Occ=Dead] as_sds06 [Occ=Once] -> as_sds06;
                  }; } in
        let {
          sat_sds03 [Occ=Once] :: a_sdp47
          [LclId] =
              [w2_sdrZY] \u []
                  case w2_sdrZY of {
                    GHC.Base.:| a1_sds01 [Occ=Once] _ [Occ=Dead] -> a1_sds01;
                  }; } in
        let {
          sat_sds08 [Occ=Once] :: [a_sdp47]
          [LclId] =
              CCCS :! [sat_sds03 sat_sds07]; } in
        let {
          sat_sdrZZ [Occ=Once] :: a_sdp47 -> a_sdp47 -> GHC.Types.Ordering
          [LclId] =
              [w_sdrZW w1_sdrZX] \r [eta_B2 eta_B1]
                  Data.Ord.comparing w_sdrZW w1_sdrZX eta_B2 eta_B1;
        } in 
          case Data.OldList.sortBy sat_sdrZZ sat_sds08 of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sds0b [Occ=Once] as_sds0c [Occ=Once] ->
                let {
                  sat_sds0d [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
                    :: GHC.Classes.Eq b_sdp46
                  [LclId] =
                      [w_sdrZW] \u [] GHC.Classes.$p1Ord w_sdrZW;
                } in 
                  Data.List.NonEmpty.$wgroupWith1
                      sat_sds0d w1_sdrZX a1_sds0b as_sds0c;
          };

Data.List.NonEmpty.groupAllWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=3,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sds0e w1_sds0f w2_sds0g]
        case
            Data.List.NonEmpty.$wgroupAllWith1 w_sds0e w1_sds0f w2_sds0g
        of
        { (#,#) ww1_sds0i [Occ=Once] ww2_sds0j [Occ=Once] ->
              GHC.Base.:| [ww1_sds0i ww2_sds0j];
        };

Data.List.NonEmpty.$wxor [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Bool -> [GHC.Types.Bool] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sds0k ww1_sds0l]
        let {
          go_sds0m [Occ=LoopBreaker] :: [GHC.Types.Bool] -> GHC.Types.Bool
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [ww_sds0k go_sds0m] \r [ds_sds0n]
                  case ds_sds0n of {
                    [] -> ww_sds0k;
                    : y_sds0p [Occ=Once!] ys_sds0q [Occ=Once*] ->
                        case y_sds0p of {
                          GHC.Types.False -> go_sds0m ys_sds0q;
                          GHC.Types.True ->
                              case go_sds0m ys_sds0q of {
                                GHC.Types.False -> GHC.Types.True [];
                                GHC.Types.True -> GHC.Types.False [];
                              };
                        };
                  };
        } in  go_sds0m ww1_sds0l;

Data.List.NonEmpty.xor [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.NonEmpty GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sds0t]
        case w_sds0t of {
          GHC.Base.:| ww1_sds0v [Occ=Once] ww2_sds0w [Occ=Once] ->
              Data.List.NonEmpty.$wxor ww1_sds0v ww2_sds0w;
        };

Data.List.NonEmpty.length
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sds0x]
        case ds_sds0x of {
          GHC.Base.:| _ [Occ=Dead] xs_sds0A [Occ=Once] ->
              case GHC.List.$wlenAcc xs_sds0A 0# of ww2_sds0B {
                __DEFAULT ->
                    case +# [1# ww2_sds0B] of sat_sds0C {
                      __DEFAULT -> GHC.Types.I# [sat_sds0C];
                    };
              };
        };


==================== STG syntax: ====================
2018-03-16 16:08:38.290328768 UTC

Data.List.NonEmpty.nonEmpty
  :: forall a. [a] -> GHC.Base.Maybe (GHC.Base.NonEmpty a)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sdrND]
        case ds_sdrND of {
          [] -> GHC.Base.Nothing [];
          : a1_sdrNF [Occ=Once] as_sdrNG [Occ=Once] ->
              let {
                sat_sdrNH [Occ=Once] :: GHC.Base.NonEmpty a_adod9
                [LclId] =
                    CCCS GHC.Base.:|! [a1_sdrNF as_sdrNG];
              } in  GHC.Base.Just [sat_sdrNH];
        };

Data.List.NonEmpty.uncons
  :: forall a.
     GHC.Base.NonEmpty a -> (a, GHC.Base.Maybe (GHC.Base.NonEmpty a))
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdrNI]
        let {
          sat_sdrNU [Occ=Once] :: GHC.Base.Maybe (GHC.Base.NonEmpty a_adode)
          [LclId] =
              [ds_sdrNI] \u []
                  case ds_sdrNI of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrNP [Occ=Once!] ->
                        case as_sdrNP of {
                          [] -> GHC.Base.Nothing [];
                          : a2_sdrNR [Occ=Once] as1_sdrNS [Occ=Once] ->
                              let {
                                sat_sdrNT [Occ=Once] :: GHC.Base.NonEmpty a_adode
                                [LclId] =
                                    CCCS GHC.Base.:|! [a2_sdrNR as1_sdrNS];
                              } in  GHC.Base.Just [sat_sdrNT];
                        };
                  }; } in
        let {
          sat_sdrNM [Occ=Once] :: a_adode
          [LclId] =
              [ds_sdrNI] \u []
                  case ds_sdrNI of {
                    GHC.Base.:| a1_sdrNK [Occ=Once] _ [Occ=Dead] -> a1_sdrNK;
                  };
        } in  (,) [sat_sdrNM sat_sdrNU];

Data.List.NonEmpty.$wunfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall a b. (a -> (b, GHC.Base.Maybe a)) -> a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,1*U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdrNV w1_sdrNW]
        case w_sdrNV w1_sdrNW of {
          (,) b1_sdrNY [Occ=Once] mc_sdrNZ [Occ=Once!] ->
              let {
                sat_sdrOa [Occ=Once] :: [b_sdp0I]
                [LclId] =
                    [w_sdrNV mc_sdrNZ] \u []
                        case mc_sdrNZ of {
                          GHC.Base.Nothing -> [] [];
                          GHC.Base.Just x_sdrO1 [Occ=Once] ->
                              let {
                                go_sdrO2 [Occ=LoopBreaker] :: a_sdp0H -> [b_sdp0I]
                                [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
                                    sat-only [w_sdrNV go_sdrO2] \r [c_sdrO3]
                                        case w_sdrNV c_sdrO3 of {
                                          (,) d_sdrO5 [Occ=Once] me_sdrO6 [Occ=Once!] ->
                                              let {
                                                sat_sdrO9 [Occ=Once] :: [b_sdp0I]
                                                [LclId] =
                                                    [go_sdrO2 me_sdrO6] \u []
                                                        case me_sdrO6 of {
                                                          GHC.Base.Nothing -> [] [];
                                                          GHC.Base.Just x1_sdrO8 [Occ=Once] ->
                                                              go_sdrO2 x1_sdrO8;
                                                        };
                                              } in  : [d_sdrO5 sat_sdrO9];
                                        };
                              } in  go_sdrO2 x_sdrO1;
                        };
              } in  (#,#) [b1_sdrNY sat_sdrOa];
        };

Data.List.NonEmpty.unfoldr [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> (b, GHC.Base.Maybe a)) -> a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U(U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdrOb w1_sdrOc]
        case Data.List.NonEmpty.$wunfoldr w_sdrOb w1_sdrOc of {
          (#,#) ww1_sdrOe [Occ=Once] ww2_sdrOf [Occ=Once] ->
              GHC.Base.:| [ww1_sdrOe ww2_sdrOf];
        };

Data.List.NonEmpty.head :: forall a. GHC.Base.NonEmpty a -> a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SL),1*U(1*U,A)>,
 Unf=OtherCon []] =
    [] \r [ds_sdrOg]
        case ds_sdrOg of {
          GHC.Base.:| a1_sdrOi [Occ=Once] _ [Occ=Dead] -> a1_sdrOi;
        };

Data.List.NonEmpty.tail :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sdrOk]
        case ds_sdrOk of {
          GHC.Base.:| _ [Occ=Dead] as_sdrOn [Occ=Once] -> as_sdrOn;
        };

poly_go_rdpws :: forall a. [a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ds_sdrOo eta_sdrOp]
        case ds_sdrOo of {
          [] -> eta_sdrOp;
          : y_sdrOr [Occ=Once] ys_sdrOs [Occ=Once] ->
              poly_go_rdpws ys_sdrOs y_sdrOr;
        };

Data.List.NonEmpty.last :: forall a. GHC.Base.NonEmpty a -> a
[GblId, Arity=1, Str=<L,U(1*U,1*U)>, Unf=OtherCon []] =
    [] \r [ds_sdrOt]
        let {
          sat_sdrOB [Occ=Once] :: [a_adocF]
          [LclId] =
              [ds_sdrOt] \u []
                  case ds_sdrOt of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrOA [Occ=Once] -> as_sdrOA;
                  }; } in
        let {
          sat_sdrOx [Occ=Once] :: a_adocF
          [LclId] =
              [ds_sdrOt] \u []
                  case ds_sdrOt of {
                    GHC.Base.:| a1_sdrOv [Occ=Once] _ [Occ=Dead] -> a1_sdrOv;
                  }; } in
        let {
          sat_sdrOC [Occ=Once] :: [a_adocF]
          [LclId] =
              CCCS :! [sat_sdrOx sat_sdrOB];
        } in  poly_go_rdpws sat_sdrOC GHC.List.lastError;

Data.List.NonEmpty.init :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ds_sdrOD]
        case ds_sdrOD of {
          GHC.Base.:| a1_sdrOF [Occ=Once] as_sdrOG [Occ=Once] ->
              GHC.List.init1 a1_sdrOF as_sdrOG;
        };

Data.List.NonEmpty.<|
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [a1_sdrOH ds_sdrOI]
        let {
          sat_sdrOQ [Occ=Once] :: [a_adocs]
          [LclId] =
              [ds_sdrOI] \u []
                  case ds_sdrOI of {
                    GHC.Base.:| _ [Occ=Dead] bs_sdrOP [Occ=Once] -> bs_sdrOP;
                  }; } in
        let {
          sat_sdrOM [Occ=Once] :: a_adocs
          [LclId] =
              [ds_sdrOI] \u []
                  case ds_sdrOI of {
                    GHC.Base.:| b_sdrOK [Occ=Once] _ [Occ=Dead] -> b_sdrOK;
                  }; } in
        let {
          sat_sdrOR [Occ=Once] :: [a_adocs]
          [LclId] =
              CCCS :! [sat_sdrOM sat_sdrOQ];
        } in  GHC.Base.:| [a1_sdrOH sat_sdrOR];

Data.List.NonEmpty.cons
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] Data.List.NonEmpty.<| eta_B2 eta_B1;

Data.List.NonEmpty.$wunfold [InlPrag=NOUSERINLINE[0],
                             Occ=LoopBreaker]
  :: forall a b. (a -> (b, GHC.Base.Maybe a)) -> a -> (# b, [b] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S(LS)),C(U(U,1*U))><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sdrOS w1_sdrOT]
        case w_sdrOS w1_sdrOT of {
          (,) b1_sdrOV [Occ=Once*] ds_sdrOW [Occ=Once!] ->
              case ds_sdrOW of {
                GHC.Base.Nothing -> (#,#) [b1_sdrOV GHC.Types.[]];
                GHC.Base.Just c_sdrOY [Occ=Once] ->
                    let {
                      ds1_sdrOZ [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty b_sdp0S
                      [LclId] =
                          [w_sdrOS c_sdrOY] \u []
                              case Data.List.NonEmpty.$wunfold w_sdrOS c_sdrOY of {
                                (#,#) ww1_sdrP1 [Occ=Once] ww2_sdrP2 [Occ=Once] ->
                                    GHC.Base.:| [ww1_sdrP1 ww2_sdrP2];
                              }; } in
                    let {
                      sat_sdrPa [Occ=Once] :: [b_sdp0S]
                      [LclId] =
                          [ds1_sdrOZ] \u []
                              case ds1_sdrOZ of {
                                GHC.Base.:| _ [Occ=Dead] bs_sdrP9 [Occ=Once] -> bs_sdrP9;
                              }; } in
                    let {
                      sat_sdrP6 [Occ=Once] :: b_sdp0S
                      [LclId] =
                          [ds1_sdrOZ] \u []
                              case ds1_sdrOZ of {
                                GHC.Base.:| b2_sdrP4 [Occ=Once] _ [Occ=Dead] -> b2_sdrP4;
                              }; } in
                    let {
                      sat_sdrPb [Occ=Once] :: [b_sdp0S]
                      [LclId] =
                          CCCS :! [sat_sdrP6 sat_sdrPa];
                    } in  (#,#) [b1_sdrOV sat_sdrPb];
              };
        };

Data.List.NonEmpty.unfold [InlPrag=NOUSERINLINE[0]]
  :: forall a b.
     (a -> (b, GHC.Base.Maybe a)) -> a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S(LS)),C(U(U,1*U))><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdrPc w1_sdrPd]
        case Data.List.NonEmpty.$wunfold w_sdrPc w1_sdrPd of {
          (#,#) ww1_sdrPf [Occ=Once] ww2_sdrPg [Occ=Once] ->
              GHC.Base.:| [ww1_sdrPf ww2_sdrPg];
        };

lvl_rdpwt :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.fromList: empty list"#;

Data.List.NonEmpty.cycle1 :: forall a. GHC.Base.NonEmpty a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_rdpwt of sat_sdrPh {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sdrPh;
        };

Data.List.NonEmpty.fromList :: forall a. [a] -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [ds_sdrPi]
        case ds_sdrPi of {
          [] -> Data.List.NonEmpty.cycle1;
          : a1_sdrPk [Occ=Once] as_sdrPl [Occ=Once] ->
              GHC.Base.:| [a1_sdrPk as_sdrPl];
        };

Data.List.NonEmpty.reverse [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U(1*U,1*U)>m, Unf=OtherCon []] =
    [] \r [w_sdrPm]
        let {
          sat_sdrPu [Occ=Once] :: [a_sdp0Z]
          [LclId] =
              [w_sdrPm] \u []
                  case w_sdrPm of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrPt [Occ=Once] -> as_sdrPt;
                  }; } in
        let {
          sat_sdrPq [Occ=Once] :: a_sdp0Z
          [LclId] =
              [w_sdrPm] \u []
                  case w_sdrPm of {
                    GHC.Base.:| a1_sdrPo [Occ=Once] _ [Occ=Dead] -> a1_sdrPo;
                  }; } in
        let {
          sat_sdrPv [Occ=Once] :: [a_sdp0Z]
          [LclId] =
              CCCS :! [sat_sdrPq sat_sdrPu];
        } in 
          case GHC.List.reverse1 sat_sdrPv GHC.Types.[] of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrPy [Occ=Once] as_sdrPz [Occ=Once] ->
                GHC.Base.:| [a1_sdrPy as_sdrPz];
          };

Data.List.NonEmpty.sortBy
  :: forall a.
     (a -> a -> GHC.Types.Ordering)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdrPA eta_sdrPB]
        let {
          sat_sdrPJ [Occ=Once] :: [a_ado9j]
          [LclId] =
              [eta_sdrPB] \u []
                  case eta_sdrPB of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrPI [Occ=Once] -> as_sdrPI;
                  }; } in
        let {
          sat_sdrPF [Occ=Once] :: a_ado9j
          [LclId] =
              [eta_sdrPB] \u []
                  case eta_sdrPB of {
                    GHC.Base.:| a1_sdrPD [Occ=Once] _ [Occ=Dead] -> a1_sdrPD;
                  }; } in
        let {
          sat_sdrPK [Occ=Once] :: [a_ado9j]
          [LclId] =
              CCCS :! [sat_sdrPF sat_sdrPJ];
        } in 
          case Data.OldList.sortBy f_sdrPA sat_sdrPK of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrPM [Occ=Once] as_sdrPN [Occ=Once] ->
                GHC.Base.:| [a1_sdrPM as_sdrPN];
          };

Data.List.NonEmpty.sortWith [InlPrag=NOUSERINLINE[0]]
  :: forall o a.
     GHC.Classes.Ord o =>
     (a -> o) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=3,
 Str=<L,U(A,C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrPO w1_sdrPP w2_sdrPQ]
        let {
          sat_sdrPZ [Occ=Once] :: [a_sdp16]
          [LclId] =
              [w2_sdrPQ] \u []
                  case w2_sdrPQ of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrPY [Occ=Once] -> as_sdrPY;
                  }; } in
        let {
          sat_sdrPV [Occ=Once] :: a_sdp16
          [LclId] =
              [w2_sdrPQ] \u []
                  case w2_sdrPQ of {
                    GHC.Base.:| a1_sdrPT [Occ=Once] _ [Occ=Dead] -> a1_sdrPT;
                  }; } in
        let {
          sat_sdrQ0 [Occ=Once] :: [a_sdp16]
          [LclId] =
              CCCS :! [sat_sdrPV sat_sdrPZ]; } in
        let {
          sat_sdrPR [Occ=Once] :: a_sdp16 -> a_sdp16 -> GHC.Types.Ordering
          [LclId] =
              [w_sdrPO w1_sdrPP] \r [eta_B2 eta_B1]
                  Data.Ord.comparing w_sdrPO w1_sdrPP eta_B2 eta_B1;
        } in 
          case Data.OldList.sortBy sat_sdrPR sat_sdrQ0 of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrQ3 [Occ=Once] as_sdrQ4 [Occ=Once] ->
                GHC.Base.:| [a1_sdrQ3 as_sdrQ4];
          };

Data.List.NonEmpty.sort [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Classes.Ord a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C(C1(U)),A,A,A,A,A,A)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrQ5 w1_sdrQ6]
        let {
          sat_sdrQf [Occ=Once] :: [a_sdp1e]
          [LclId] =
              [w1_sdrQ6] \u []
                  case w1_sdrQ6 of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrQe [Occ=Once] -> as_sdrQe;
                  }; } in
        let {
          sat_sdrQb [Occ=Once] :: a_sdp1e
          [LclId] =
              [w1_sdrQ6] \u []
                  case w1_sdrQ6 of {
                    GHC.Base.:| a1_sdrQ9 [Occ=Once] _ [Occ=Dead] -> a1_sdrQ9;
                  }; } in
        let {
          sat_sdrQg [Occ=Once] :: [a_sdp1e]
          [LclId] =
              CCCS :! [sat_sdrQb sat_sdrQf]; } in
        let {
          sat_sdrQ7 [Occ=Once, Dmd=<L,C(C1(U))>]
            :: a_sdp1e -> a_sdp1e -> GHC.Types.Ordering
          [LclId] =
              [w_sdrQ5] \u [] GHC.Classes.compare w_sdrQ5;
        } in 
          case Data.OldList.sortBy sat_sdrQ7 sat_sdrQg of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrQj [Occ=Once] as_sdrQk [Occ=Once] ->
                GHC.Base.:| [a1_sdrQj as_sdrQk];
          };

Data.List.NonEmpty.inits
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     f a -> GHC.Base.NonEmpty [a]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrQl eta_sdrQm]
        let {
          sat_sdrQn [Occ=Once, Dmd=<L,1*U>] :: [a_ado9V]
          [LclId] =
              [$dFoldable_sdrQl eta_sdrQm] \s []
                  Data.Foldable.toList $dFoldable_sdrQl eta_sdrQm;
        } in 
          case Data.OldList.$winits sat_sdrQn of {
            (#,#) ww1_sdrQp [Occ=Once] ww2_sdrQq [Occ=Once] ->
                GHC.Base.:| [ww1_sdrQp ww2_sdrQq];
          };

Data.List.NonEmpty.tails1 [Occ=LoopBreaker]
  :: forall a. [a] -> [[a]]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m2, Unf=OtherCon []] =
    [] \r [xs_sdrQr]
        let {
          sat_sdrQv [Occ=Once] :: [[a_sdp1n]]
          [LclId] =
              [xs_sdrQr] \u []
                  case xs_sdrQr of {
                    [] -> [] [];
                    : _ [Occ=Dead] xs'_sdrQu [Occ=Once] ->
                        Data.List.NonEmpty.tails1 xs'_sdrQu;
                  };
        } in  : [xs_sdrQr sat_sdrQv];

Data.List.NonEmpty.tails [InlPrag=NOUSERINLINE[0]]
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     f a -> GHC.Base.NonEmpty [a]
[GblId,
 Arity=2,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [w_sdrQw w1_sdrQx]
        let {
          sat_sdrQy [Occ=Once] :: [a_sdp1n]
          [LclId] =
              [w_sdrQw w1_sdrQx] \u [] Data.Foldable.toList w_sdrQw w1_sdrQx;
        } in 
          case Data.List.NonEmpty.tails1 sat_sdrQy of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrQB [Occ=Once] as_sdrQC [Occ=Once] ->
                GHC.Base.:| [a1_sdrQB as_sdrQC];
          };

Data.List.NonEmpty.insert
  :: forall (f :: * -> *) a.
     (Data.Foldable.Foldable f, GHC.Classes.Ord a) =>
     a -> f a -> GHC.Base.NonEmpty a
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*U(A,1*C(C1(U)),A,A,A,A,A,A)><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrQD $dOrd_sdrQE a1_sdrQF eta_sdrQG]
        case Data.Foldable.toList $dFoldable_sdrQD eta_sdrQG of sat_sdrQI {
          __DEFAULT ->
              let {
                sat_sdrQH [Occ=Once, Dmd=<L,C(C1(U))>]
                  :: a_adoav -> a_adoav -> GHC.Types.Ordering
                [LclId] =
                    [$dOrd_sdrQE] \u [] GHC.Classes.compare $dOrd_sdrQE;
              } in 
                case Data.OldList.$winsertBy sat_sdrQH a1_sdrQF sat_sdrQI of {
                  (#,#) ww1_sdrQK [Occ=Once] ww2_sdrQL [Occ=Once] ->
                      GHC.Base.:| [ww1_sdrQK ww2_sdrQL];
                };
        };

Data.List.NonEmpty.scanl
  :: forall (f :: * -> *) b a.
     Data.Foldable.Foldable f =>
     (b -> a -> b) -> b -> f a -> GHC.Base.NonEmpty b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrQM f1_sdrQN z_sdrQO eta_sdrQP]
        let {
          sat_sdrQU [Occ=Once] :: [b_adoaP]
          [LclId] =
              [$dFoldable_sdrQM f1_sdrQN z_sdrQO eta_sdrQP] \u []
                  let {
                    sat_sdrQQ [Occ=Once, Dmd=<L,1*U>] :: [a_adoaQ]
                    [LclId] =
                        [$dFoldable_sdrQM eta_sdrQP] \s []
                            Data.Foldable.toList $dFoldable_sdrQM eta_sdrQP;
                  } in 
                    case GHC.List.$wscanlGo f1_sdrQN z_sdrQO sat_sdrQQ of {
                      (#,#) _ [Occ=Dead] ww2_sdrQT [Occ=Once] -> ww2_sdrQT;
                    };
        } in  GHC.Base.:| [z_sdrQO sat_sdrQU];

Data.List.NonEmpty.scanr
  :: forall (f :: * -> *) a b.
     Data.Foldable.Foldable f =>
     (a -> b -> b) -> b -> f a -> GHC.Base.NonEmpty b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrQV f1_sdrQW z_sdrQX eta_sdrQY]
        case Data.Foldable.toList $dFoldable_sdrQV eta_sdrQY of sat_sdrQZ {
          __DEFAULT ->
              case GHC.List.$wscanr f1_sdrQW z_sdrQX sat_sdrQZ of {
                (#,#) ww1_sdrR1 [Occ=Once] ww2_sdrR2 [Occ=Once] ->
                    GHC.Base.:| [ww1_sdrR1 ww2_sdrR2];
              };
        };

Data.List.NonEmpty.scanl1
  :: forall a.
     (a -> a -> a) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdrR3 ds_sdrR4]
        let {
          a1_sdrR5 :: a_adobr
          [LclId] =
              [ds_sdrR4] \u []
                  case ds_sdrR4 of {
                    GHC.Base.:| a2_sdrR7 [Occ=Once] _ [Occ=Dead] -> a2_sdrR7;
                  }; } in
        let {
          sat_sdrRf [Occ=Once] :: [a_adobr]
          [LclId] =
              [f_sdrR3 ds_sdrR4 a1_sdrR5] \u []
                  case ds_sdrR4 of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrRb [Occ=Once] ->
                        case GHC.List.$wscanlGo f_sdrR3 a1_sdrR5 as_sdrRb of {
                          (#,#) _ [Occ=Dead] ww2_sdrRe [Occ=Once] -> ww2_sdrRe;
                        };
                  };
        } in  GHC.Base.:| [a1_sdrR5 sat_sdrRf];

Data.List.NonEmpty.scanr1
  :: forall a.
     (a -> a -> a) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Str=<L,C(C1(U))><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdrRg ds_sdrRh]
        let {
          sat_sdrRp [Occ=Once] :: [a_adobw]
          [LclId] =
              [ds_sdrRh] \u []
                  case ds_sdrRh of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrRo [Occ=Once] -> as_sdrRo;
                  }; } in
        let {
          sat_sdrRl [Occ=Once] :: a_adobw
          [LclId] =
              [ds_sdrRh] \u []
                  case ds_sdrRh of {
                    GHC.Base.:| a1_sdrRj [Occ=Once] _ [Occ=Dead] -> a1_sdrRj;
                  }; } in
        let {
          sat_sdrRq [Occ=Once] :: [a_adobw]
          [LclId] =
              CCCS :! [sat_sdrRl sat_sdrRp];
        } in 
          case GHC.List.scanr1 f_sdrRg sat_sdrRq of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrRs [Occ=Once] as_sdrRt [Occ=Once] ->
                GHC.Base.:| [a1_sdrRs as_sdrRt];
          };

Data.List.NonEmpty.toList :: forall a. GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)>m2,
 Unf=OtherCon []] =
    [] \r [ds_sdrRu]
        let {
          sat_sdrRC [Occ=Once] :: [a_ado7K]
          [LclId] =
              [ds_sdrRu] \u []
                  case ds_sdrRu of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrRB [Occ=Once] -> as_sdrRB;
                  }; } in
        let {
          sat_sdrRy [Occ=Once] :: a_ado7K
          [LclId] =
              [ds_sdrRu] \u []
                  case ds_sdrRu of {
                    GHC.Base.:| a1_sdrRw [Occ=Once] _ [Occ=Dead] -> a1_sdrRw;
                  };
        } in  : [sat_sdrRy sat_sdrRC];

Data.List.NonEmpty.$wtake [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Prim.Int# -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ww_sdrRD w_sdrRE]
        case <# [0# ww_sdrRD] of {
          __DEFAULT -> [] [];
          1# ->
              let {
                sat_sdrRN [Occ=Once] :: [a_sdp1u]
                [LclId] =
                    [w_sdrRE] \u []
                        case w_sdrRE of {
                          GHC.Base.:| _ [Occ=Dead] as_sdrRM [Occ=Once] -> as_sdrRM;
                        }; } in
              let {
                sat_sdrRJ [Occ=Once] :: a_sdp1u
                [LclId] =
                    [w_sdrRE] \u []
                        case w_sdrRE of {
                          GHC.Base.:| a1_sdrRH [Occ=Once] _ [Occ=Dead] -> a1_sdrRH;
                        }; } in
              let {
                sat_sdrRO [Occ=Once] :: [a_sdp1u]
                [LclId] =
                    CCCS :! [sat_sdrRJ sat_sdrRN];
              } in  GHC.List.$wunsafeTake ww_sdrRD sat_sdrRO;
        };

Data.List.NonEmpty.take [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrRP w1_sdrRQ]
        case w_sdrRP of {
          GHC.Types.I# ww1_sdrRS [Occ=Once] ->
              Data.List.NonEmpty.$wtake ww1_sdrRS w1_sdrRQ;
        };

Data.List.NonEmpty.$wunsafeDrop [InlPrag=NOUSERINLINE[0],
                                 Occ=LoopBreaker]
  :: forall a1. GHC.Prim.Int# -> [a1] -> [a1]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sdrRT w_sdrRU]
        case w_sdrRU of {
          [] -> [] [];
          : _ [Occ=Dead] ipv2_sdrRX [Occ=Once*] ->
              case ww_sdrRT of ds3_sdrRY {
                __DEFAULT ->
                    case -# [ds3_sdrRY 1#] of sat_sdrRZ {
                      __DEFAULT -> Data.List.NonEmpty.$wunsafeDrop sat_sdrRZ ipv2_sdrRX;
                    };
                1# -> ipv2_sdrRX;
              };
        };

Data.List.NonEmpty.$wdrop [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Prim.Int# -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [ww_sdrS0 w_sdrS1]
        case <=# [ww_sdrS0 0#] of {
          __DEFAULT ->
              let {
                sat_sdrSa [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    [w_sdrS1] \u []
                        case w_sdrS1 of {
                          GHC.Base.:| _ [Occ=Dead] as_sdrS9 [Occ=Once] -> as_sdrS9;
                        }; } in
              let {
                sat_sdrS6 [Occ=Once] :: a_sdp1K
                [LclId] =
                    [w_sdrS1] \u []
                        case w_sdrS1 of {
                          GHC.Base.:| a1_sdrS4 [Occ=Once] _ [Occ=Dead] -> a1_sdrS4;
                        }; } in
              let {
                sat_sdrSb [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    CCCS :! [sat_sdrS6 sat_sdrSa];
              } in  Data.List.NonEmpty.$wunsafeDrop ww_sdrS0 sat_sdrSb;
          1# ->
              let {
                sat_sdrSj [Occ=Once] :: [a_sdp1K]
                [LclId] =
                    [w_sdrS1] \u []
                        case w_sdrS1 of {
                          GHC.Base.:| _ [Occ=Dead] as_sdrSi [Occ=Once] -> as_sdrSi;
                        }; } in
              let {
                sat_sdrSf [Occ=Once] :: a_sdp1K
                [LclId] =
                    [w_sdrS1] \u []
                        case w_sdrS1 of {
                          GHC.Base.:| a1_sdrSd [Occ=Once] _ [Occ=Dead] -> a1_sdrSd;
                        };
              } in  : [sat_sdrSf sat_sdrSj];
        };

Data.List.NonEmpty.drop [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(U,U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrSk w1_sdrSl]
        case w_sdrSk of {
          GHC.Types.I# ww1_sdrSn [Occ=Once] ->
              Data.List.NonEmpty.$wdrop ww1_sdrSn w1_sdrSl;
        };

Data.List.NonEmpty.splitAt [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrSo w1_sdrSp]
        case w_sdrSo of ww_sdrSq {
          GHC.Types.I# ww1_sdrSr [Occ=Once] ->
              case <=# [ww1_sdrSr 0#] of {
                __DEFAULT ->
                    let {
                      sat_sdrSA [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          [w1_sdrSp] \u []
                              case w1_sdrSp of {
                                GHC.Base.:| _ [Occ=Dead] as_sdrSz [Occ=Once] -> as_sdrSz;
                              }; } in
                    let {
                      sat_sdrSw [Occ=Once] :: a_sdp1S
                      [LclId] =
                          [w1_sdrSp] \u []
                              case w1_sdrSp of {
                                GHC.Base.:| a1_sdrSu [Occ=Once] _ [Occ=Dead] -> a1_sdrSu;
                              }; } in
                    let {
                      sat_sdrSB [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          CCCS :! [sat_sdrSw sat_sdrSA];
                    } in 
                      case GHC.List.$wsplitAt' ww_sdrSq sat_sdrSB of {
                        (#,#) ww3_sdrSD [Occ=Once] ww4_sdrSE [Occ=Once] ->
                            (,) [ww3_sdrSD ww4_sdrSE];
                      };
                1# ->
                    let {
                      sat_sdrSM [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          [w1_sdrSp] \u []
                              case w1_sdrSp of {
                                GHC.Base.:| _ [Occ=Dead] as_sdrSL [Occ=Once] -> as_sdrSL;
                              }; } in
                    let {
                      sat_sdrSI [Occ=Once] :: a_sdp1S
                      [LclId] =
                          [w1_sdrSp] \u []
                              case w1_sdrSp of {
                                GHC.Base.:| a1_sdrSG [Occ=Once] _ [Occ=Dead] -> a1_sdrSG;
                              }; } in
                    let {
                      sat_sdrSN [Occ=Once] :: [a_sdp1S]
                      [LclId] =
                          CCCS :! [sat_sdrSI sat_sdrSM];
                    } in  (,) [GHC.Types.[] sat_sdrSN];
              };
        };

Data.List.NonEmpty.takeWhile
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdrSO x_sdrSP]
        let {
          sat_sdrSX [Occ=Once] :: [a_ado8a]
          [LclId] =
              [x_sdrSP] \u []
                  case x_sdrSP of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrSW [Occ=Once] -> as_sdrSW;
                  }; } in
        let {
          sat_sdrST [Occ=Once] :: a_ado8a
          [LclId] =
              [x_sdrSP] \u []
                  case x_sdrSP of {
                    GHC.Base.:| a1_sdrSR [Occ=Once] _ [Occ=Dead] -> a1_sdrSR;
                  }; } in
        let {
          sat_sdrSY [Occ=Once] :: [a_ado8a]
          [LclId] =
              CCCS :! [sat_sdrST sat_sdrSX];
        } in  GHC.List.takeWhile p_sdrSO sat_sdrSY;

Data.List.NonEmpty.dropWhile
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdrSZ x_sdrT0]
        let {
          sat_sdrT8 [Occ=Once] :: [a_ado8h]
          [LclId] =
              [x_sdrT0] \u []
                  case x_sdrT0 of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrT7 [Occ=Once] -> as_sdrT7;
                  }; } in
        let {
          sat_sdrT4 [Occ=Once] :: a_ado8h
          [LclId] =
              [x_sdrT0] \u []
                  case x_sdrT0 of {
                    GHC.Base.:| a1_sdrT2 [Occ=Once] _ [Occ=Dead] -> a1_sdrT2;
                  }; } in
        let {
          sat_sdrT9 [Occ=Once] :: [a_ado8h]
          [LclId] =
              CCCS :! [sat_sdrT4 sat_sdrT8];
        } in  GHC.List.dropWhile p_sdrSZ sat_sdrT9;

Data.List.NonEmpty.span
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [p_sdrTa x_sdrTb]
        let {
          sat_sdrTj [Occ=Once] :: [a_ado8p]
          [LclId] =
              [x_sdrTb] \u []
                  case x_sdrTb of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrTi [Occ=Once] -> as_sdrTi;
                  }; } in
        let {
          sat_sdrTf [Occ=Once] :: a_ado8p
          [LclId] =
              [x_sdrTb] \u []
                  case x_sdrTb of {
                    GHC.Base.:| a1_sdrTd [Occ=Once] _ [Occ=Dead] -> a1_sdrTd;
                  }; } in
        let {
          sat_sdrTk [Occ=Once] :: [a_ado8p]
          [LclId] =
              CCCS :! [sat_sdrTf sat_sdrTj];
        } in 
          case GHC.List.$wspan p_sdrTa sat_sdrTk of {
            (#,#) ww1_sdrTm [Occ=Once] ww2_sdrTn [Occ=Once] ->
                (,) [ww1_sdrTm ww2_sdrTn];
          };

Data.List.NonEmpty.$wbreak [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrTo w1_sdrTp]
        let {
          sat_sdrTA [Occ=Once] :: [a_sdp23]
          [LclId] =
              [w1_sdrTp] \u []
                  case w1_sdrTp of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrTz [Occ=Once] -> as_sdrTz;
                  }; } in
        let {
          sat_sdrTw [Occ=Once] :: a_sdp23
          [LclId] =
              [w1_sdrTp] \u []
                  case w1_sdrTp of {
                    GHC.Base.:| a1_sdrTu [Occ=Once] _ [Occ=Dead] -> a1_sdrTu;
                  }; } in
        let {
          sat_sdrTB [Occ=Once] :: [a_sdp23]
          [LclId] =
              CCCS :! [sat_sdrTw sat_sdrTA]; } in
        let {
          sat_sdrTs [Occ=Once] :: a_sdp23 -> GHC.Types.Bool
          [LclId] =
              [w_sdrTo] \r [x_sdrTq]
                  case w_sdrTo x_sdrTq of {
                    GHC.Types.False -> GHC.Types.True [];
                    GHC.Types.True -> GHC.Types.False [];
                  };
        } in  GHC.List.$wspan sat_sdrTs sat_sdrTB;

Data.List.NonEmpty.break [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrTC w1_sdrTD]
        case Data.List.NonEmpty.$wbreak w_sdrTC w1_sdrTD of {
          (#,#) ww1_sdrTF [Occ=Once] ww2_sdrTG [Occ=Once] ->
              (,) [ww1_sdrTF ww2_sdrTG];
        };

Data.List.NonEmpty.filter
  :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [p_sdrTH x_sdrTI]
        let {
          sat_sdrTQ [Occ=Once] :: [a_ado8C]
          [LclId] =
              [x_sdrTI] \u []
                  case x_sdrTI of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrTP [Occ=Once] -> as_sdrTP;
                  }; } in
        let {
          sat_sdrTM [Occ=Once] :: a_ado8C
          [LclId] =
              [x_sdrTI] \u []
                  case x_sdrTI of {
                    GHC.Base.:| a1_sdrTK [Occ=Once] _ [Occ=Dead] -> a1_sdrTK;
                  }; } in
        let {
          sat_sdrTR [Occ=Once] :: [a_ado8C]
          [LclId] =
              CCCS :! [sat_sdrTM sat_sdrTQ];
        } in  GHC.List.filter p_sdrTH sat_sdrTR;

Data.List.NonEmpty.$wpartition [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrTS w1_sdrTT]
        let {
          $wgo_sdrTU [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
            :: [a_sdp2f] -> (# [a_sdp2f], [a_sdp2f] #)
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [w_sdrTS $wgo_sdrTU] \r [w2_sdrTV]
                  case w2_sdrTV of {
                    [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
                    : y_sdrTX ys_sdrTY [Occ=Once] ->
                        let {
                          w3_sdrTZ [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp2f], [a_sdp2f])
                          [LclId] =
                              [$wgo_sdrTU ys_sdrTY] \u []
                                  case $wgo_sdrTU ys_sdrTY of {
                                    (#,#) ww1_sdrU1 [Occ=Once] ww2_sdrU2 [Occ=Once] ->
                                        (,) [ww1_sdrU1 ww2_sdrU2];
                                  };
                        } in 
                          case w_sdrTS y_sdrTX of {
                            GHC.Types.False ->
                                let {
                                  sat_sdrUb [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdrTZ] \u []
                                          case w3_sdrTZ of {
                                            (,) _ [Occ=Dead] fs_sdrUa [Occ=Once] -> fs_sdrUa;
                                          }; } in
                                let {
                                  sat_sdrUc [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      CCCS :! [y_sdrTX sat_sdrUb]; } in
                                let {
                                  sat_sdrU7 [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdrTZ] \u []
                                          case w3_sdrTZ of {
                                            (,) ts_sdrU5 [Occ=Once] _ [Occ=Dead] -> ts_sdrU5;
                                          };
                                } in  (#,#) [sat_sdrU7 sat_sdrUc];
                            GHC.Types.True ->
                                let {
                                  sat_sdrUl [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdrTZ] \u []
                                          case w3_sdrTZ of {
                                            (,) _ [Occ=Dead] fs_sdrUk [Occ=Once] -> fs_sdrUk;
                                          }; } in
                                let {
                                  sat_sdrUg [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      [w3_sdrTZ] \u []
                                          case w3_sdrTZ of {
                                            (,) ts_sdrUe [Occ=Once] _ [Occ=Dead] -> ts_sdrUe;
                                          }; } in
                                let {
                                  sat_sdrUh [Occ=Once] :: [a_sdp2f]
                                  [LclId] =
                                      CCCS :! [y_sdrTX sat_sdrUg];
                                } in  (#,#) [sat_sdrUh sat_sdrUl];
                          };
                  }; } in
        let {
          sat_sdrUt [Occ=Once] :: [a_sdp2f]
          [LclId] =
              [w1_sdrTT] \u []
                  case w1_sdrTT of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrUs [Occ=Once] -> as_sdrUs;
                  }; } in
        let {
          sat_sdrUp [Occ=Once] :: a_sdp2f
          [LclId] =
              [w1_sdrTT] \u []
                  case w1_sdrTT of {
                    GHC.Base.:| a1_sdrUn [Occ=Once] _ [Occ=Dead] -> a1_sdrUn;
                  }; } in
        let {
          sat_sdrUu [Occ=Once] :: [a_sdp2f]
          [LclId] =
              CCCS :! [sat_sdrUp sat_sdrUt];
        } in  $wgo_sdrTU sat_sdrUu;

Data.List.NonEmpty.partition [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> GHC.Types.Bool) -> GHC.Base.NonEmpty a -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrUv w1_sdrUw]
        case Data.List.NonEmpty.$wpartition w_sdrUv w1_sdrUw of {
          (#,#) ww1_sdrUy [Occ=Once] ww2_sdrUz [Occ=Once] ->
              (,) [ww1_sdrUy ww2_sdrUz];
        };

Data.List.NonEmpty.cycle [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Str=<L,U(U,U)>m, Unf=OtherCon []] =
    [] \r [w_sdrUA]
        let {
          xs'_sdrUB [Occ=LoopBreaker] :: [a_sdp2m]
          [LclId] =
              [w_sdrUA xs'_sdrUB] \u []
                  let {
                    sat_sdrUJ [Occ=OnceL] :: [a_sdp2m]
                    [LclId] =
                        [w_sdrUA] \u []
                            case w_sdrUA of {
                              GHC.Base.:| _ [Occ=Dead] as_sdrUI [Occ=Once] -> as_sdrUI;
                            }; } in
                  let {
                    sat_sdrUF [Occ=OnceL] :: a_sdp2m
                    [LclId] =
                        [w_sdrUA] \u []
                            case w_sdrUA of {
                              GHC.Base.:| a1_sdrUD [Occ=Once] _ [Occ=Dead] -> a1_sdrUD;
                            }; } in
                  let {
                    sat_sdrUK [Occ=Once] :: [a_sdp2m]
                    [LclId] =
                        CCCS :! [sat_sdrUF sat_sdrUJ];
                  } in  GHC.Base.++ sat_sdrUK xs'_sdrUB;
        } in 
          case xs'_sdrUB of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sdrUN [Occ=Once] as_sdrUO [Occ=Once] ->
                GHC.Base.:| [a1_sdrUN as_sdrUO];
          };

Data.List.NonEmpty.$wtranspose [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
     -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId, Arity=1, Str=<L,U(U(1*U,1*U),1*U)>, Unf=OtherCon []] =
    [] \r [w_sdrUP]
        let {
          ds_sdrUQ [Dmd=<L,U(1*U,1*U)>] :: GHC.Base.NonEmpty [a_sdp2s]
          [LclId] =
              [w_sdrUP] \u []
                  let {
                    sat_sdrV9 [Occ=OnceL] :: [[a_sdp2s]]
                    [LclId] =
                        [w_sdrUP] \u []
                            case w_sdrUP of {
                              GHC.Base.:| _ [Occ=Dead] as_sdrV8 [Occ=Once] ->
                                  GHC.Base.map Data.List.NonEmpty.toList as_sdrV8;
                            }; } in
                  let {
                    sat_sdrV4 [Occ=OnceL] :: [a_sdp2s]
                    [LclId] =
                        [w_sdrUP] \u []
                            case w_sdrUP of {
                              GHC.Base.:| a1_sdrUZ [Occ=Once!] _ [Occ=Dead] ->
                                  case a1_sdrUZ of {
                                    GHC.Base.:| _ [Occ=Dead] as1_sdrV3 [Occ=Once] -> as1_sdrV3;
                                  };
                            }; } in
                  let {
                    sat_sdrUX [Occ=OnceL] :: a_sdp2s
                    [LclId] =
                        [w_sdrUP] \u []
                            case w_sdrUP of {
                              GHC.Base.:| a1_sdrUS [Occ=Once!] _ [Occ=Dead] ->
                                  case a1_sdrUS of {
                                    GHC.Base.:| a2_sdrUV [Occ=Once] _ [Occ=Dead] -> a2_sdrUV;
                                  };
                            }; } in
                  let {
                    sat_sdrV5 [Occ=OnceL] :: [a_sdp2s]
                    [LclId] =
                        CCCS :! [sat_sdrUX sat_sdrV4]; } in
                  let {
                    sat_sdrVa [Occ=Once] :: [[a_sdp2s]]
                    [LclId] =
                        CCCS :! [sat_sdrV5 sat_sdrV9];
                  } in 
                    case Data.OldList.transpose sat_sdrVa of {
                      [] -> Data.List.NonEmpty.cycle1;
                      : a1_sdrVc [Occ=Once] as_sdrVd [Occ=Once] ->
                          GHC.Base.:| [a1_sdrVc as_sdrVd];
                    }; } in
        let {
          sat_sdrVo [Occ=Once] :: [GHC.Base.NonEmpty a_sdp2s]
          [LclId] =
              [ds_sdrUQ] \u []
                  case ds_sdrUQ of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrVn [Occ=Once] ->
                        GHC.Base.map Data.List.NonEmpty.fromList as_sdrVn;
                  }; } in
        let {
          sat_sdrVk [Occ=Once] :: GHC.Base.NonEmpty a_sdp2s
          [LclId] =
              [ds_sdrUQ] \u []
                  case ds_sdrUQ of {
                    GHC.Base.:| a1_sdrVf [Occ=Once!] _ [Occ=Dead] ->
                        case a1_sdrVf of {
                          [] -> Data.List.NonEmpty.cycle1;
                          : a2_sdrVi [Occ=Once] as1_sdrVj [Occ=Once] ->
                              GHC.Base.:| [a2_sdrVi as1_sdrVj];
                        };
                  };
        } in  (#,#) [sat_sdrVk sat_sdrVo];

Data.List.NonEmpty.transpose [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
     -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId, Arity=1, Str=<L,U(U(U,U),U)>m, Unf=OtherCon []] =
    [] \r [w_sdrVp]
        case Data.List.NonEmpty.$wtranspose w_sdrVp of {
          (#,#) ww1_sdrVr [Occ=Once] ww2_sdrVs [Occ=Once] ->
              GHC.Base.:| [ww1_sdrVr ww2_sdrVs];
        };

Data.List.NonEmpty.map
  :: forall a b.
     (a -> b) -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [f_sdrVt ds_sdrVu]
        let {
          sat_sdrVD [Occ=Once] :: [b_ado7C]
          [LclId] =
              [f_sdrVt ds_sdrVu] \u []
                  case ds_sdrVu of {
                    GHC.Base.:| _ [Occ=Dead] as_sdrVC [Occ=Once] ->
                        GHC.Base.map f_sdrVt as_sdrVC;
                  }; } in
        let {
          sat_sdrVz [Occ=Once] :: b_ado7C
          [LclId] =
              [f_sdrVt ds_sdrVu] \u []
                  let {
                    sat_sdrVy [Occ=Once] :: a_ado7B
                    [LclId] =
                        [ds_sdrVu] \u []
                            case ds_sdrVu of {
                              GHC.Base.:| a1_sdrVw [Occ=Once] _ [Occ=Dead] -> a1_sdrVw;
                            };
                  } in  f_sdrVt sat_sdrVy;
        } in  GHC.Base.:| [sat_sdrVz sat_sdrVD];

Data.List.NonEmpty.some1
  :: forall (f :: * -> *) a.
     GHC.Base.Alternative f =>
     f a -> f (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S(LLLC(C(C(S)))LL)LLLL),U(1*U(A,A,A,1*C1(C1(C1(U))),A,A),A,A,A,1*C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dAlternative_sdrVE eta_sdrVF]
        let {
          sat_sdrVH [Occ=Once] :: f_ado7n [a_ado7o]
          [LclId] =
              [$dAlternative_sdrVE eta_sdrVF] \u []
                  GHC.Base.many $dAlternative_sdrVE eta_sdrVF;
        } in 
          case GHC.Base.$p1Alternative $dAlternative_sdrVE of sat_sdrVG {
            __DEFAULT ->
                GHC.Base.liftA2 sat_sdrVG GHC.Base.:| eta_sdrVF sat_sdrVH;
          };

Data.List.NonEmpty.intersperse [InlPrag=NOUSERINLINE[0]]
  :: forall a. a -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrVI w1_sdrVJ]
        let {
          sat_sdrVW [Occ=Once] :: [a_sdp2C]
          [LclId] =
              [w_sdrVI w1_sdrVJ] \u []
                  case w1_sdrVJ of {
                    GHC.Base.:| _ [Occ=Dead] bs_sdrVQ [Occ=Once!] ->
                        case bs_sdrVQ of {
                          [] -> [] [];
                          : ipv_sdrVS [Occ=Once] ipv1_sdrVT [Occ=Once] ->
                              let {
                                sat_sdrVU [Occ=Once] :: [a_sdp2C]
                                [LclId] =
                                    [w_sdrVI ipv1_sdrVT] \u []
                                        Data.OldList.prependToAll w_sdrVI ipv1_sdrVT; } in
                              let {
                                sat_sdrVV [Occ=Once] :: [a_sdp2C]
                                [LclId] =
                                    CCCS :! [ipv_sdrVS sat_sdrVU];
                              } in  : [w_sdrVI sat_sdrVV];
                        };
                  }; } in
        let {
          sat_sdrVN [Occ=Once] :: a_sdp2C
          [LclId] =
              [w1_sdrVJ] \u []
                  case w1_sdrVJ of {
                    GHC.Base.:| b_sdrVL [Occ=Once] _ [Occ=Dead] -> b_sdrVL;
                  };
        } in  GHC.Base.:| [sat_sdrVN sat_sdrVW];

Data.List.NonEmpty.iterate
  :: forall a. (a -> a) -> a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [f_sdrVX a1_sdrVY]
        let {
          sat_sdrW3 [Occ=Once] :: [a_ado7a]
          [LclId] =
              [f_sdrVX a1_sdrVY] \u []
                  let {
                    sat_sdrVZ [Occ=Once] :: a_ado7a
                    [LclId] =
                        [f_sdrVX a1_sdrVY] \u [] f_sdrVX a1_sdrVY;
                  } in 
                    case GHC.List.$witerate f_sdrVX sat_sdrVZ of {
                      (#,#) ww1_sdrW1 [Occ=Once] ww2_sdrW2 [Occ=Once] ->
                          : [ww1_sdrW1 ww2_sdrW2];
                    };
        } in  GHC.Base.:| [a1_sdrVY sat_sdrW3];

Data.List.NonEmpty.repeat :: forall a. a -> GHC.Base.NonEmpty a
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>m, Unf=OtherCon []] =
    [] \r [a1_sdrW4]
        let {
          sat_sdrW5 [Occ=Once] :: [a_ado76]
          [LclId] =
              [a1_sdrW4] \u [] GHC.List.repeat a1_sdrW4;
        } in  GHC.Base.:| [a1_sdrW4 sat_sdrW5];

Data.List.NonEmpty.groupBy_$sgroupBy [Occ=LoopBreaker]
  :: forall a.
     (a -> a -> GHC.Types.Bool) -> [a] -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eq0_sdrW6 eta_sdrW7]
        case eta_sdrW7 of {
          [] -> [] [];
          : x_sdrW9 xs_sdrWa [Occ=Once] ->
              let {
                ds_sdrWb [Dmd=<L,U(1*U,1*U)>] :: ([a_Xdo51], [a_Xdo51])
                [LclId] =
                    [eq0_sdrW6 x_sdrW9 xs_sdrWa] \u []
                        let {
                          sat_sdrWc [Occ=Once, Dmd=<L,C(U)>] :: a_Xdo51 -> GHC.Types.Bool
                          [LclId] =
                              [eq0_sdrW6 x_sdrW9] \u [] eq0_sdrW6 x_sdrW9;
                        } in 
                          case GHC.List.$wspan sat_sdrWc xs_sdrWa of {
                            (#,#) ww1_sdrWe [Occ=Once] ww2_sdrWf [Occ=Once] ->
                                (,) [ww1_sdrWe ww2_sdrWf];
                          }; } in
              let {
                sat_sdrWo [Occ=Once] :: [GHC.Base.NonEmpty a_Xdo51]
                [LclId] =
                    [eq0_sdrW6 ds_sdrWb] \u []
                        case ds_sdrWb of {
                          (,) _ [Occ=Dead] zs_sdrWn [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdrW6 zs_sdrWn;
                        }; } in
              let {
                sat_sdrWj [Occ=Once] :: [a_Xdo51]
                [LclId] =
                    [ds_sdrWb] \u []
                        case ds_sdrWb of {
                          (,) ys_sdrWh [Occ=Once] _ [Occ=Dead] -> ys_sdrWh;
                        }; } in
              let {
                sat_sdrWk [Occ=Once] :: GHC.Base.NonEmpty a_Xdo51
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdrW9 sat_sdrWj];
              } in  : [sat_sdrWk sat_sdrWo];
        };

Data.List.NonEmpty.groupBy
  :: forall (f :: * -> *) a.
     Data.Foldable.Foldable f =>
     (a -> a -> GHC.Types.Bool) -> f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,C(C(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrWp eq0_sdrWq eta_sdrWr]
        case Data.Foldable.toList $dFoldable_sdrWp eta_sdrWr of {
          [] -> [] [];
          : x_sdrWt xs_sdrWu [Occ=Once] ->
              let {
                ds_sdrWv [Dmd=<L,U(1*U,1*U)>] :: ([a_ado4Z], [a_ado4Z])
                [LclId] =
                    [eq0_sdrWq x_sdrWt xs_sdrWu] \u []
                        let {
                          sat_sdrWw [Occ=Once, Dmd=<L,C(U)>] :: a_ado4Z -> GHC.Types.Bool
                          [LclId] =
                              [eq0_sdrWq x_sdrWt] \u [] eq0_sdrWq x_sdrWt;
                        } in 
                          case GHC.List.$wspan sat_sdrWw xs_sdrWu of {
                            (#,#) ww1_sdrWy [Occ=Once] ww2_sdrWz [Occ=Once] ->
                                (,) [ww1_sdrWy ww2_sdrWz];
                          }; } in
              let {
                sat_sdrWI [Occ=Once] :: [GHC.Base.NonEmpty a_ado4Z]
                [LclId] =
                    [eq0_sdrWq ds_sdrWv] \u []
                        case ds_sdrWv of {
                          (,) _ [Occ=Dead] zs_sdrWH [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdrWq zs_sdrWH;
                        }; } in
              let {
                sat_sdrWD [Occ=Once] :: [a_ado4Z]
                [LclId] =
                    [ds_sdrWv] \u []
                        case ds_sdrWv of {
                          (,) ys_sdrWB [Occ=Once] _ [Occ=Dead] -> ys_sdrWB;
                        }; } in
              let {
                sat_sdrWE [Occ=Once] :: GHC.Base.NonEmpty a_ado4Z
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdrWt sat_sdrWD];
              } in  : [sat_sdrWE sat_sdrWI];
        };

Data.List.NonEmpty.groupWith
  :: forall (f :: * -> *) b a.
     (Data.Foldable.Foldable f, GHC.Classes.Eq b) =>
     (a -> b) -> f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,U(C(C1(U)),A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrWJ $dEq_sdrWK f1_sdrWL eta_sdrWM]
        case Data.Foldable.toList $dFoldable_sdrWJ eta_sdrWM of {
          [] -> [] [];
          : x_sdrWO xs_sdrWP [Occ=Once] ->
              let {
                eq0_sdrWQ [Dmd=<L,C(C(U))>] :: a_ado5N -> a_ado5N -> GHC.Types.Bool
                [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                    [$dEq_sdrWK f1_sdrWL] \r [x1_sdrWR y_sdrWS]
                        let {
                          sat_sdrWU [Occ=Once] :: b_ado5M
                          [LclId] =
                              [f1_sdrWL y_sdrWS] \u [] f1_sdrWL y_sdrWS; } in
                        let {
                          sat_sdrWT [Occ=Once] :: b_ado5M
                          [LclId] =
                              [f1_sdrWL x1_sdrWR] \u [] f1_sdrWL x1_sdrWR;
                        } in  GHC.Classes.== $dEq_sdrWK sat_sdrWT sat_sdrWU; } in
              let {
                ds_sdrWV [Dmd=<L,U(1*U,1*U)>] :: ([a_ado5N], [a_ado5N])
                [LclId] =
                    [x_sdrWO xs_sdrWP eq0_sdrWQ] \u []
                        let {
                          sat_sdrWW [Occ=Once] :: a_ado5N -> GHC.Types.Bool
                          [LclId] =
                              [x_sdrWO eq0_sdrWQ] \r [eta_B1] eq0_sdrWQ x_sdrWO eta_B1;
                        } in 
                          case GHC.List.$wspan sat_sdrWW xs_sdrWP of {
                            (#,#) ww1_sdrWY [Occ=Once] ww2_sdrWZ [Occ=Once] ->
                                (,) [ww1_sdrWY ww2_sdrWZ];
                          }; } in
              let {
                sat_sdrX8 [Occ=Once] :: [GHC.Base.NonEmpty a_ado5N]
                [LclId] =
                    [eq0_sdrWQ ds_sdrWV] \u []
                        case ds_sdrWV of {
                          (,) _ [Occ=Dead] zs_sdrX7 [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy eq0_sdrWQ zs_sdrX7;
                        }; } in
              let {
                sat_sdrX3 [Occ=Once] :: [a_ado5N]
                [LclId] =
                    [ds_sdrWV] \u []
                        case ds_sdrWV of {
                          (,) ys_sdrX1 [Occ=Once] _ [Occ=Dead] -> ys_sdrX1;
                        }; } in
              let {
                sat_sdrX4 [Occ=Once] :: GHC.Base.NonEmpty a_ado5N
                [LclId] =
                    CCCS GHC.Base.:|! [x_sdrWO sat_sdrX3];
              } in  : [sat_sdrX4 sat_sdrX8];
        };

Data.List.NonEmpty.group
  :: forall (f :: * -> *) a.
     (Data.Foldable.Foldable f, GHC.Classes.Eq a) =>
     f a -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLLC(S)LLLLLLL),1*U(A,A,A,A,A,A,A,A,1*C1(U),A,A,A,A,A,A,A)><L,1*U(1*C(C(U)),A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dFoldable_sdrX9 $dEq_sdrXa eta_sdrXb]
        let {
          sat_sdrXc [Occ=Once, Dmd=<L,C(C(U))>]
            :: a_ado6W -> a_ado6W -> GHC.Types.Bool
          [LclId] =
              [$dEq_sdrXa] \u [] GHC.Classes.== $dEq_sdrXa;
        } in 
          Data.List.NonEmpty.groupBy $dFoldable_sdrX9 sat_sdrXc eta_sdrXb;

Data.List.NonEmpty.isPrefixOf
  :: forall a.
     GHC.Classes.Eq a =>
     [a] -> GHC.Base.NonEmpty a -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><S,1*U><L,1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [$dEq_sdrXd ds_sdrXe ds1_sdrXf]
        case ds_sdrXe of {
          [] -> GHC.Types.True [];
          : y_sdrXh [Occ=Once] ys_sdrXi [Occ=Once] ->
              case ds1_sdrXf of {
                GHC.Base.:| x_sdrXk [Occ=Once] xs_sdrXl [Occ=Once] ->
                    case GHC.Classes.== $dEq_sdrXd y_sdrXh x_sdrXk of {
                      GHC.Types.False -> GHC.Types.False [];
                      GHC.Types.True ->
                          Data.OldList.isPrefixOf $dEq_sdrXd ys_sdrXi xs_sdrXl;
                    };
              };
        };

lvl1_rdpwu :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NonEmpty.!! negative argument"#;

Data.List.NonEmpty.!!1 :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl1_rdpwu of sat_sdrXn {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sdrXn;
        };

Data.List.NonEmpty.$w!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. a -> [a] -> GHC.Prim.Int# -> a
[GblId, Arity=3, Str=<L,1*U><L,1*U><S,1*U>, Unf=OtherCon []] =
    [] \r [ww_sdrXo ww1_sdrXp ww2_sdrXq]
        case ww2_sdrXq of wild_sdrXr {
          __DEFAULT ->
              case ># [wild_sdrXr 0#] of {
                __DEFAULT -> Data.List.NonEmpty.!!1;
                1# ->
                    case -# [wild_sdrXr 1#] of sat_sdrXt {
                      __DEFAULT -> GHC.List.$w!! ww1_sdrXp sat_sdrXt;
                    };
              };
          0# -> ww_sdrXo;
        };

Data.List.NonEmpty.!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int -> a
[GblId,
 Arity=2,
 Str=<S,1*U(1*U,1*U)><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrXu w1_sdrXv]
        case w_sdrXu of {
          GHC.Base.:| ww1_sdrXx [Occ=Once] ww2_sdrXy [Occ=Once] ->
              case w1_sdrXv of {
                GHC.Types.I# ww4_sdrXA [Occ=Once] ->
                    Data.List.NonEmpty.$w!! ww1_sdrXx ww2_sdrXy ww4_sdrXA;
              };
        };

Data.List.NonEmpty.zip
  :: forall a b.
     GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b -> GHC.Base.NonEmpty (a, b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sdrXB ds1_sdrXC]
        let {
          sat_sdrXT [Occ=Once] :: [(a_ado4o, b_ado4p)]
          [LclId] =
              [ds_sdrXB ds1_sdrXC] \u []
                  case ds_sdrXB of {
                    GHC.Base.:| _ [Occ=Dead] xs_sdrXO [Occ=Once] ->
                        let {
                          sat_sdrXS [Occ=Once, Dmd=<L,1*U>] :: [b_ado4p]
                          [LclId] =
                              [ds1_sdrXC] \s []
                                  case ds1_sdrXC of {
                                    GHC.Base.:| _ [Occ=Dead] ys_sdrXR [Occ=Once] -> ys_sdrXR;
                                  };
                        } in  GHC.List.zip xs_sdrXO sat_sdrXS;
                  }; } in
        let {
          sat_sdrXK [Occ=Once] :: b_ado4p
          [LclId] =
              [ds1_sdrXC] \u []
                  case ds1_sdrXC of {
                    GHC.Base.:| y_sdrXI [Occ=Once] _ [Occ=Dead] -> y_sdrXI;
                  }; } in
        let {
          sat_sdrXG [Occ=Once] :: a_ado4o
          [LclId] =
              [ds_sdrXB] \u []
                  case ds_sdrXB of {
                    GHC.Base.:| x_sdrXE [Occ=Once] _ [Occ=Dead] -> x_sdrXE;
                  }; } in
        let {
          sat_sdrXL [Occ=Once] :: (a_ado4o, b_ado4p)
          [LclId] =
              CCCS (,)! [sat_sdrXG sat_sdrXK];
        } in  GHC.Base.:| [sat_sdrXL sat_sdrXT];

Data.List.NonEmpty.zipWith [InlPrag=NOUSERINLINE[0]]
  :: forall a b c.
     (a -> b -> c)
     -> GHC.Base.NonEmpty a
     -> GHC.Base.NonEmpty b
     -> GHC.Base.NonEmpty c
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U(1*U,1*U)><L,U(1*U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrXU w1_sdrXV w2_sdrXW]
        let {
          sat_sdrYd [Occ=Once] :: [c_sdp3h]
          [LclId] =
              [w_sdrXU w1_sdrXV w2_sdrXW] \u []
                  case w1_sdrXV of {
                    GHC.Base.:| _ [Occ=Dead] xs_sdrY8 [Occ=Once] ->
                        let {
                          sat_sdrYc [Occ=Once, Dmd=<L,1*U>] :: [b_sdp3g]
                          [LclId] =
                              [w2_sdrXW] \s []
                                  case w2_sdrXW of {
                                    GHC.Base.:| _ [Occ=Dead] ys_sdrYb [Occ=Once] -> ys_sdrYb;
                                  };
                        } in  GHC.List.zipWith w_sdrXU xs_sdrY8 sat_sdrYc;
                  }; } in
        let {
          sat_sdrY5 [Occ=Once] :: c_sdp3h
          [LclId] =
              [w_sdrXU w1_sdrXV w2_sdrXW] \u []
                  let {
                    sat_sdrY4 [Occ=Once] :: b_sdp3g
                    [LclId] =
                        [w2_sdrXW] \u []
                            case w2_sdrXW of {
                              GHC.Base.:| y_sdrY2 [Occ=Once] _ [Occ=Dead] -> y_sdrY2;
                            }; } in
                  let {
                    sat_sdrY0 [Occ=Once] :: a_sdp3f
                    [LclId] =
                        [w1_sdrXV] \u []
                            case w1_sdrXV of {
                              GHC.Base.:| x_sdrXY [Occ=Once] _ [Occ=Dead] -> x_sdrXY;
                            };
                  } in  w_sdrXU sat_sdrY0 sat_sdrY4;
        } in  GHC.Base.:| [sat_sdrY5 sat_sdrYd];

Data.List.NonEmpty.unzip
  :: forall (f :: * -> *) a b.
     GHC.Base.Functor f =>
     f (a, b) -> (f a, f b)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U>m,
 Unf=OtherCon []] =
    [] \r [$dFunctor_sdrYe xs_sdrYf]
        let {
          sat_sdrYh [Occ=Once] :: f_ado3Y b_ado40
          [LclId] =
              [$dFunctor_sdrYe xs_sdrYf] \u []
                  GHC.Base.fmap $dFunctor_sdrYe Data.Tuple.snd xs_sdrYf; } in
        let {
          sat_sdrYg [Occ=Once] :: f_ado3Y a_ado3Z
          [LclId] =
              [$dFunctor_sdrYe xs_sdrYf] \u []
                  GHC.Base.fmap $dFunctor_sdrYe Data.Tuple.fst xs_sdrYf;
        } in  (,) [sat_sdrYg sat_sdrYh];

Data.List.NonEmpty.nubBy [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> a -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrYi w1_sdrYj]
        case w1_sdrYj of {
          GHC.Base.:| ww1_sdrYl ww2_sdrYm [Occ=Once] ->
              let {
                sat_sdrYr [Occ=Once] :: [a_sdp3p]
                [LclId] =
                    [w_sdrYi ww1_sdrYl ww2_sdrYm] \u []
                        let {
                          sat_sdrYp [Occ=Once] :: a_sdp3p -> GHC.Types.Bool
                          [LclId] =
                              [w_sdrYi ww1_sdrYl] \r [b_sdrYn]
                                  case w_sdrYi ww1_sdrYl b_sdrYn of {
                                    GHC.Types.False -> GHC.Types.True [];
                                    GHC.Types.True -> GHC.Types.False [];
                                  };
                        } in 
                          case GHC.List.filter sat_sdrYp ww2_sdrYm of sat_sdrYq {
                            __DEFAULT -> Data.OldList.nubBy w_sdrYi sat_sdrYq;
                          };
              } in  GHC.Base.:| [ww1_sdrYl sat_sdrYr];
        };

Data.List.NonEmpty.nub
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C1(U)),A)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dEq_sdrYs eta_sdrYt]
        case eta_sdrYt of {
          GHC.Base.:| ww1_sdrYv ww2_sdrYw [Occ=Once] ->
              let {
                sat_sdrYC [Occ=Once] :: [a_ado3R]
                [LclId] =
                    [$dEq_sdrYs ww1_sdrYv ww2_sdrYw] \u []
                        let {
                          w_sdrYx [Dmd=<L,C(C1(U))>] :: a_ado3R -> a_ado3R -> GHC.Types.Bool
                          [LclId] =
                              [$dEq_sdrYs] \u [] GHC.Classes.== $dEq_sdrYs; } in
                        let {
                          sat_sdrYA [Occ=Once] :: a_ado3R -> GHC.Types.Bool
                          [LclId] =
                              [ww1_sdrYv w_sdrYx] \r [b_sdrYy]
                                  case w_sdrYx ww1_sdrYv b_sdrYy of {
                                    GHC.Types.False -> GHC.Types.True [];
                                    GHC.Types.True -> GHC.Types.False [];
                                  };
                        } in 
                          case GHC.List.filter sat_sdrYA ww2_sdrYw of sat_sdrYB {
                            __DEFAULT -> Data.OldList.nubBy w_sdrYx sat_sdrYB;
                          };
              } in  GHC.Base.:| [ww1_sdrYv sat_sdrYC];
        };

Data.List.NonEmpty.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

Data.List.NonEmpty.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.List.NonEmpty.$trModule4];

Data.List.NonEmpty.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Data.List.NonEmpty"#;

Data.List.NonEmpty.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Data.List.NonEmpty.$trModule2];

Data.List.NonEmpty.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Data.List.NonEmpty.$trModule3
                                     Data.List.NonEmpty.$trModule1];

Data.List.NonEmpty.groupAllWith
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b) -> [a] -> [GHC.Base.NonEmpty a]
[GblId,
 Arity=3,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sdrYD eta_sdrYE eta1_sdrYF]
        let {
          sat_sdrYM [Occ=Once] :: [a_ado65]
          [LclId] =
              [$dOrd_sdrYD eta_sdrYE eta1_sdrYF] \u []
                  let {
                    sat_sdrYL [Occ=Once] :: a_ado65 -> a_ado65 -> GHC.Types.Ordering
                    [LclId] =
                        [$dOrd_sdrYD eta_sdrYE] \r [x_sdrYH y_sdrYI]
                            let {
                              sat_sdrYK [Occ=Once] :: b_ado64
                              [LclId] =
                                  [eta_sdrYE y_sdrYI] \u [] eta_sdrYE y_sdrYI; } in
                            let {
                              sat_sdrYJ [Occ=Once] :: b_ado64
                              [LclId] =
                                  [eta_sdrYE x_sdrYH] \u [] eta_sdrYE x_sdrYH;
                            } in  GHC.Classes.compare $dOrd_sdrYD sat_sdrYJ sat_sdrYK;
                  } in  Data.OldList.sortBy sat_sdrYL eta1_sdrYF; } in
        let {
          sat_sdrYG [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
            :: GHC.Classes.Eq b_ado64
          [LclId] =
              [$dOrd_sdrYD] \u [] GHC.Classes.$p1Ord $dOrd_sdrYD;
        } in 
          Data.List.NonEmpty.groupWith
              Data.Foldable.$fFoldable[] sat_sdrYG eta_sdrYE sat_sdrYM;

Data.List.NonEmpty.groupBy1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (a -> a -> GHC.Types.Bool)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C(U))><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrYN w1_sdrYO]
        case w1_sdrYO of {
          GHC.Base.:| ww1_sdrYQ ww2_sdrYR [Occ=Once] ->
              let {
                ds_sdrYS [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp3G], [a_sdp3G])
                [LclId] =
                    [w_sdrYN ww1_sdrYQ ww2_sdrYR] \u []
                        let {
                          sat_sdrYT [Occ=Once, Dmd=<L,C(U)>] :: a_sdp3G -> GHC.Types.Bool
                          [LclId] =
                              [w_sdrYN ww1_sdrYQ] \u [] w_sdrYN ww1_sdrYQ;
                        } in 
                          case GHC.List.$wspan sat_sdrYT ww2_sdrYR of {
                            (#,#) ww4_sdrYV [Occ=Once] ww5_sdrYW [Occ=Once] ->
                                (,) [ww4_sdrYV ww5_sdrYW];
                          }; } in
              let {
                sat_sdrZ5 [Occ=Once] :: [GHC.Base.NonEmpty a_sdp3G]
                [LclId] =
                    [w_sdrYN ds_sdrYS] \u []
                        case ds_sdrYS of {
                          (,) _ [Occ=Dead] zs_sdrZ4 [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy w_sdrYN zs_sdrZ4;
                        }; } in
              let {
                sat_sdrZ0 [Occ=Once] :: [a_sdp3G]
                [LclId] =
                    [ds_sdrYS] \u []
                        case ds_sdrYS of {
                          (,) ys_sdrYY [Occ=Once] _ [Occ=Dead] -> ys_sdrYY;
                        }; } in
              let {
                sat_sdrZ1 [Occ=Once] :: GHC.Base.NonEmpty a_sdp3G
                [LclId] =
                    CCCS GHC.Base.:|! [ww1_sdrYQ sat_sdrZ0];
              } in  GHC.Base.:| [sat_sdrZ1 sat_sdrZ5];
        };

Data.List.NonEmpty.group1
  :: forall a.
     GHC.Classes.Eq a =>
     GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*C(C(U)),A)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [$dEq_sdrZ6 eta_sdrZ7]
        case eta_sdrZ7 of {
          GHC.Base.:| ww1_sdrZ9 ww2_sdrZa [Occ=Once] ->
              let {
                w_sdrZb [Dmd=<L,C(C(U))>] :: a_ado6D -> a_ado6D -> GHC.Types.Bool
                [LclId] =
                    [$dEq_sdrZ6] \u [] GHC.Classes.== $dEq_sdrZ6; } in
              let {
                ds_sdrZc [Dmd=<L,U(1*U,1*U)>] :: ([a_ado6D], [a_ado6D])
                [LclId] =
                    [ww1_sdrZ9 ww2_sdrZa w_sdrZb] \u []
                        let {
                          sat_sdrZd [Occ=Once, Dmd=<L,C(U)>] :: a_ado6D -> GHC.Types.Bool
                          [LclId] =
                              [ww1_sdrZ9 w_sdrZb] \u [] w_sdrZb ww1_sdrZ9;
                        } in 
                          case GHC.List.$wspan sat_sdrZd ww2_sdrZa of {
                            (#,#) ww4_sdrZf [Occ=Once] ww5_sdrZg [Occ=Once] ->
                                (,) [ww4_sdrZf ww5_sdrZg];
                          }; } in
              let {
                sat_sdrZp [Occ=Once] :: [GHC.Base.NonEmpty a_ado6D]
                [LclId] =
                    [w_sdrZb ds_sdrZc] \u []
                        case ds_sdrZc of {
                          (,) _ [Occ=Dead] zs_sdrZo [Occ=Once] ->
                              Data.List.NonEmpty.groupBy_$sgroupBy w_sdrZb zs_sdrZo;
                        }; } in
              let {
                sat_sdrZk [Occ=Once] :: [a_ado6D]
                [LclId] =
                    [ds_sdrZc] \u []
                        case ds_sdrZc of {
                          (,) ys_sdrZi [Occ=Once] _ [Occ=Dead] -> ys_sdrZi;
                        }; } in
              let {
                sat_sdrZl [Occ=Once] :: GHC.Base.NonEmpty a_ado6D
                [LclId] =
                    CCCS GHC.Base.:|! [ww1_sdrZ9 sat_sdrZk];
              } in  GHC.Base.:| [sat_sdrZl sat_sdrZp];
        };

Data.List.NonEmpty.$wgroupWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Eq b =>
     (a -> b)
     -> a -> [a] -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,C(U)><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sdrZq w1_sdrZr ww_sdrZs ww1_sdrZt]
        let {
          eq_sdrZu [Dmd=<L,C(C(U))>] :: a_sdp3T -> a_sdp3T -> GHC.Types.Bool
          [LclId, Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
              [w_sdrZq w1_sdrZr] \r [x_sdrZv y_sdrZw]
                  let {
                    sat_sdrZy [Occ=Once] :: b_sdp3S
                    [LclId] =
                        [w1_sdrZr y_sdrZw] \u [] w1_sdrZr y_sdrZw; } in
                  let {
                    sat_sdrZx [Occ=Once] :: b_sdp3S
                    [LclId] =
                        [w1_sdrZr x_sdrZv] \u [] w1_sdrZr x_sdrZv;
                  } in  GHC.Classes.== w_sdrZq sat_sdrZx sat_sdrZy; } in
        let {
          ds_sdrZz [Dmd=<L,U(1*U,1*U)>] :: ([a_sdp3T], [a_sdp3T])
          [LclId] =
              [ww_sdrZs ww1_sdrZt eq_sdrZu] \u []
                  let {
                    sat_sdrZA [Occ=Once] :: a_sdp3T -> GHC.Types.Bool
                    [LclId] =
                        [ww_sdrZs eq_sdrZu] \r [eta_B1] eq_sdrZu ww_sdrZs eta_B1;
                  } in 
                    case GHC.List.$wspan sat_sdrZA ww1_sdrZt of {
                      (#,#) ww3_sdrZC [Occ=Once] ww4_sdrZD [Occ=Once] ->
                          (,) [ww3_sdrZC ww4_sdrZD];
                    }; } in
        let {
          sat_sdrZM [Occ=Once] :: [GHC.Base.NonEmpty a_sdp3T]
          [LclId] =
              [eq_sdrZu ds_sdrZz] \u []
                  case ds_sdrZz of {
                    (,) _ [Occ=Dead] zs_sdrZL [Occ=Once] ->
                        Data.List.NonEmpty.groupBy_$sgroupBy eq_sdrZu zs_sdrZL;
                  }; } in
        let {
          sat_sdrZH [Occ=Once] :: [a_sdp3T]
          [LclId] =
              [ds_sdrZz] \u []
                  case ds_sdrZz of {
                    (,) ys_sdrZF [Occ=Once] _ [Occ=Dead] -> ys_sdrZF;
                  }; } in
        let {
          sat_sdrZI [Occ=Once] :: GHC.Base.NonEmpty a_sdp3T
          [LclId] =
              CCCS GHC.Base.:|! [ww_sdrZs sat_sdrZH];
        } in  (#,#) [sat_sdrZI sat_sdrZM];

Data.List.NonEmpty.groupWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Eq b =>
     (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,C(U)><S,1*U(U,1*U)>m,
 Unf=OtherCon []] =
    [] \r [w_sdrZN w1_sdrZO w2_sdrZP]
        case w2_sdrZP of {
          GHC.Base.:| ww1_sdrZR [Occ=Once] ww2_sdrZS [Occ=Once] ->
              case
                  Data.List.NonEmpty.$wgroupWith1
                      w_sdrZN w1_sdrZO ww1_sdrZR ww2_sdrZS
              of
              { (#,#) ww4_sdrZU [Occ=Once] ww5_sdrZV [Occ=Once] ->
                    GHC.Base.:| [ww4_sdrZU ww5_sdrZV];
              };
        };

Data.List.NonEmpty.$wgroupAllWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b)
     -> GHC.Base.NonEmpty a
     -> (# GHC.Base.NonEmpty a, [GHC.Base.NonEmpty a] #)
[GblId,
 Arity=3,
 Str=<L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(1*U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sdrZW w1_sdrZX w2_sdrZY]
        let {
          sat_sds07 [Occ=Once] :: [a_sdp47]
          [LclId] =
              [w2_sdrZY] \u []
                  case w2_sdrZY of {
                    GHC.Base.:| _ [Occ=Dead] as_sds06 [Occ=Once] -> as_sds06;
                  }; } in
        let {
          sat_sds03 [Occ=Once] :: a_sdp47
          [LclId] =
              [w2_sdrZY] \u []
                  case w2_sdrZY of {
                    GHC.Base.:| a1_sds01 [Occ=Once] _ [Occ=Dead] -> a1_sds01;
                  }; } in
        let {
          sat_sds08 [Occ=Once] :: [a_sdp47]
          [LclId] =
              CCCS :! [sat_sds03 sat_sds07]; } in
        let {
          sat_sdrZZ [Occ=Once] :: a_sdp47 -> a_sdp47 -> GHC.Types.Ordering
          [LclId] =
              [w_sdrZW w1_sdrZX] \r [eta_B2 eta_B1]
                  Data.Ord.comparing w_sdrZW w1_sdrZX eta_B2 eta_B1;
        } in 
          case Data.OldList.sortBy sat_sdrZZ sat_sds08 of {
            [] -> Data.List.NonEmpty.cycle1;
            : a1_sds0b [Occ=Once] as_sds0c [Occ=Once] ->
                let {
                  sat_sds0d [Occ=Once, Dmd=<L,U(C(C1(U)),A)>]
                    :: GHC.Classes.Eq b_sdp46
                  [LclId] =
                      [w_sdrZW] \u [] GHC.Classes.$p1Ord w_sdrZW;
                } in 
                  Data.List.NonEmpty.$wgroupWith1
                      sat_sds0d w1_sdrZX a1_sds0b as_sds0c;
          };

Data.List.NonEmpty.groupAllWith1 [InlPrag=NOUSERINLINE[0]]
  :: forall b a.
     GHC.Classes.Ord b =>
     (a -> b)
     -> GHC.Base.NonEmpty a -> GHC.Base.NonEmpty (GHC.Base.NonEmpty a)
[GblId,
 Arity=3,
 Str=<L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,C(U)><L,U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [w_sds0e w1_sds0f w2_sds0g]
        case
            Data.List.NonEmpty.$wgroupAllWith1 w_sds0e w1_sds0f w2_sds0g
        of
        { (#,#) ww1_sds0i [Occ=Once] ww2_sds0j [Occ=Once] ->
              GHC.Base.:| [ww1_sds0i ww2_sds0j];
        };

Data.List.NonEmpty.$wxor [InlPrag=NOUSERINLINE[0]]
  :: GHC.Types.Bool -> [GHC.Types.Bool] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sds0k ww1_sds0l]
        let {
          go_sds0m [Occ=LoopBreaker] :: [GHC.Types.Bool] -> GHC.Types.Bool
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [ww_sds0k go_sds0m] \r [ds_sds0n]
                  case ds_sds0n of {
                    [] -> ww_sds0k;
                    : y_sds0p [Occ=Once!] ys_sds0q [Occ=Once*] ->
                        case y_sds0p of {
                          GHC.Types.False -> go_sds0m ys_sds0q;
                          GHC.Types.True ->
                              case go_sds0m ys_sds0q of {
                                GHC.Types.False -> GHC.Types.True [];
                                GHC.Types.True -> GHC.Types.False [];
                              };
                        };
                  };
        } in  go_sds0m ww1_sds0l;

Data.List.NonEmpty.xor [InlPrag=NOUSERINLINE[0]]
  :: GHC.Base.NonEmpty GHC.Types.Bool -> GHC.Types.Bool
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SS),1*U(U,1*U)>,
 Unf=OtherCon []] =
    [] \r [w_sds0t]
        case w_sds0t of {
          GHC.Base.:| ww1_sds0v [Occ=Once] ww2_sds0w [Occ=Once] ->
              Data.List.NonEmpty.$wxor ww1_sds0v ww2_sds0w;
        };

Data.List.NonEmpty.length
  :: forall a. GHC.Base.NonEmpty a -> GHC.Types.Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LS),1*U(A,1*U)>m,
 Unf=OtherCon []] =
    [] \r [ds_sds0x]
        case ds_sds0x of {
          GHC.Base.:| _ [Occ=Dead] xs_sds0A [Occ=Once] ->
              case GHC.List.$wlenAcc xs_sds0A 0# of ww2_sds0B {
                __DEFAULT ->
                    case +# [1# ww2_sds0B] of sat_sds0C {
                      __DEFAULT -> GHC.Types.I# [sat_sds0C];
                    };
              };
        };

