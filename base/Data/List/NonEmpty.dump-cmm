
==================== Output Cmm ====================
2018-03-16 16:08:35.284354543 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:35.285566823 UTC

[section ""data" . Data.List.NonEmpty.nonEmpty_closure" {
     Data.List.NonEmpty.nonEmpty_closure:
         const Data.List.NonEmpty.nonEmpty_info;
 },
 Data.List.NonEmpty.nonEmpty_entry() //  [R2]
         { info_tbl: [(cdpJH,
                       label: Data.List.NonEmpty.nonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpJH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdpJI; else goto cdpJJ;
       cdpJI: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.nonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpJJ: // global
           I64[Sp - 8] = block_cdpJA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udpJU; else goto cdpJB;
       udpJU: // global
           call _cdpJA(R1) args: 0, res: 0, upd: 0;
       cdpJB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpJA() //  [R1]
         { info_tbl: [(cdpJA,
                       label: block_cdpJA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpJA: // global
           if (R1 & 7 == 1) goto cdpJE; else goto cdpJF;
       cdpJE: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdpJF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdpJT; else goto cdpJS;
       cdpJT: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpJS: // global
           _sdpwy::P64 = P64[R1 + 6];
           _sdpwz::P64 = P64[R1 + 14];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _sdpwy::P64;
           P64[Hp - 16] = _sdpwz::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.287431051 UTC

[section ""data" . Data.List.NonEmpty.uncons_closure" {
     Data.List.NonEmpty.uncons_closure:
         const Data.List.NonEmpty.uncons_info;
 },
 sat_sdpwN_entry() //  [R1]
         { info_tbl: [(cdpK6,
                       label: sat_sdpwN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpK6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdpK7; else goto cdpK8;
       cdpK7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpK8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdpK3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udpKu; else goto cdpK4;
       udpKu: // global
           call _cdpK3(R1) args: 0, res: 0, upd: 0;
       cdpK4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdpK3() //  [R1]
         { info_tbl: [(cdpK3,
                       label: block_cdpK3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpK3: // global
           I64[Sp] = block_cdpKb_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto udpKt; else goto cdpKd;
       udpKt: // global
           call _cdpKb(R1) args: 0, res: 0, upd: 0;
       cdpKd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdpKb() //  [R1]
         { info_tbl: [(cdpKb,
                       label: block_cdpKb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpKb: // global
           if (R1 & 7 == 1) goto cdpKj; else goto cdpKo;
       cdpKj: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdpKo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdpKr; else goto cdpKq;
       cdpKr: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdpKq: // global
           _sdpwK::P64 = P64[R1 + 6];
           _sdpwL::P64 = P64[R1 + 14];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _sdpwK::P64;
           P64[Hp - 16] = _sdpwL::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.uncons_entry() //  [R2]
         { info_tbl: [(cdpKx,
                       label: Data.List.NonEmpty.uncons_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpKx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpKB; else goto cdpKA;
       cdpKB: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.uncons_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpKA: // global
           I64[Hp - 64] = sat_sdpwN_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.290337123 UTC

[section ""data" . Data.List.NonEmpty.$wunfoldr_closure" {
     Data.List.NonEmpty.$wunfoldr_closure:
         const Data.List.NonEmpty.$wunfoldr_info;
 },
 sat_sdpx2_entry() //  [R1]
         { info_tbl: [(cdpLe,
                       label: sat_sdpx2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpLe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdpLf; else goto cdpLg;
       cdpLf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpLg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdpL7_info;
           _sdpwV::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpwV::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udpLn; else goto cdpL8;
       udpLn: // global
           call _cdpL7(R1) args: 0, res: 0, upd: 0;
       cdpL8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdpL7() //  [R1]
         { info_tbl: [(cdpL7,
                       label: block_cdpL7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpL7: // global
           if (R1 & 7 == 1) goto cdpLb; else goto cdpLc;
       cdpLb: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdpLc: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdpwV_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sdpwV_entry() //  [R1, R2]
         { info_tbl: [(cdpLo,
                       label: go_sdpwV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpLo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpLq; else goto cdpLr;
       cdpLq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpLr: // global
           I64[Sp - 16] = block_cdpKZ_info;
           R2 = R2;
           _sdpwV::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdpwV::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpKZ() //  [R1]
         { info_tbl: [(cdpKZ,
                       label: block_cdpKZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpKZ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdpLu; else goto cdpLt;
       cdpLu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpLt: // global
           _sdpwY::P64 = P64[R1 + 7];
           _sdpwZ::P64 = P64[R1 + 15];
           I64[Hp - 48] = sat_sdpx2_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sdpwZ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdpwY::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpx3_entry() //  [R1]
         { info_tbl: [(cdpLz,
                       label: sat_sdpx3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpLz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdpLA; else goto cdpLB;
       cdpLA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpLB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdpKO_info;
           _sdpwO::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpwO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udpLH; else goto cdpKP;
       udpLH: // global
           call _cdpKO(R1) args: 0, res: 0, upd: 0;
       cdpKP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdpKO() //  [R1]
         { info_tbl: [(cdpKO,
                       label: block_cdpKO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpKO: // global
           if (R1 & 7 == 1) goto cdpLw; else goto cdpLx;
       cdpLw: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdpLx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdpLG; else goto cdpLF;
       cdpLG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdpLF: // global
           _sdpwU::P64 = P64[R1 + 6];
           I64[Hp - 8] = go_sdpwV_info;
           P64[Hp] = P64[Sp + 8];
           R2 = _sdpwU::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call go_sdpwV_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wunfoldr_entry() //  [R2, R3]
         { info_tbl: [(cdpLI,
                       label: Data.List.NonEmpty.$wunfoldr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpLI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpLJ; else goto cdpLK;
       cdpLJ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunfoldr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpLK: // global
           I64[Sp - 16] = block_cdpKG_info;
           _sdpwO::P64 = R2;
           R2 = R3;
           R1 = _sdpwO::P64;
           P64[Sp - 8] = _sdpwO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpKG() //  [R1]
         { info_tbl: [(cdpKG,
                       label: block_cdpKG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpKG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdpLN; else goto cdpLM;
       cdpLN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpLM: // global
           _sdpwR::P64 = P64[R1 + 7];
           _sdpwS::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdpx3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdpwS::P64;
           R2 = Hp - 24;
           R1 = _sdpwR::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.293385454 UTC

[section ""data" . Data.List.NonEmpty.unfoldr_closure" {
     Data.List.NonEmpty.unfoldr_closure:
         const Data.List.NonEmpty.unfoldr_info;
 },
 Data.List.NonEmpty.unfoldr_entry() //  [R2, R3]
         { info_tbl: [(cdpLV,
                       label: Data.List.NonEmpty.unfoldr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpLV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdpLW; else goto cdpLX;
       cdpLW: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unfoldr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpLX: // global
           I64[Sp - 8] = block_cdpLS_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wunfoldr_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpLS() //  [R1, R2]
         { info_tbl: [(cdpLS,
                       label: block_cdpLS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpLS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpM0; else goto cdpLZ;
       cdpM0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdpLZ: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.294680493 UTC

[section ""data" . Data.List.NonEmpty.head_closure" {
     Data.List.NonEmpty.head_closure:
         const Data.List.NonEmpty.head_info;
 },
 Data.List.NonEmpty.head_entry() //  [R2]
         { info_tbl: [(cdpM8,
                       label: Data.List.NonEmpty.head_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpM8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdpM9; else goto cdpMa;
       cdpM9: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.head_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpMa: // global
           I64[Sp - 8] = block_cdpM5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udpMe; else goto cdpM6;
       udpMe: // global
           call _cdpM5(R1) args: 0, res: 0, upd: 0;
       cdpM6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpM5() //  [R1]
         { info_tbl: [(cdpM5,
                       label: block_cdpM5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpM5: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.295895618 UTC

[section ""data" . Data.List.NonEmpty.tail_closure" {
     Data.List.NonEmpty.tail_closure:
         const Data.List.NonEmpty.tail_info;
 },
 Data.List.NonEmpty.tail_entry() //  [R2]
         { info_tbl: [(cdpMm,
                       label: Data.List.NonEmpty.tail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpMm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdpMn; else goto cdpMo;
       cdpMn: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.tail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpMo: // global
           I64[Sp - 8] = block_cdpMj_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udpMs; else goto cdpMk;
       udpMs: // global
           call _cdpMj(R1) args: 0, res: 0, upd: 0;
       cdpMk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpMj() //  [R1]
         { info_tbl: [(cdpMj,
                       label: block_cdpMj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpMj: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.297327739 UTC

[section ""data" . poly_go_rdpws_closure" {
     poly_go_rdpws_closure:
         const poly_go_rdpws_info;
 },
 poly_go_rdpws_entry() //  [R2, R3]
         { info_tbl: [(cdpME,
                       label: poly_go_rdpws_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpME: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpMF; else goto udpMN;
       cdpMF: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_go_rdpws_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udpMN: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdpMu() args: 0, res: 0, upd: 0;
     }
 },
 _cdpMu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpMu: // global
           _sdpxh::P64 = P64[Sp];
           I64[Sp] = block_cdpMx_info;
           R1 = _sdpxh::P64;
           if (R1 & 7 != 0) goto udpMP; else goto cdpMy;
       udpMP: // global
           call _cdpMx(R1) args: 0, res: 0, upd: 0;
       cdpMy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpMx() //  [R1]
         { info_tbl: [(cdpMx,
                       label: block_cdpMx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpMx: // global
           if (R1 & 7 == 1) goto cdpMB; else goto cdpMC;
       cdpMB: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdpMC: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cdpMu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.298751475 UTC

[section ""data" . Data.List.NonEmpty.last_closure" {
     Data.List.NonEmpty.last_closure:
         const Data.List.NonEmpty.last_info;
         const 0;
 },
 Data.List.NonEmpty.last_entry() //  [R2]
         { info_tbl: [(cdpMZ,
                       label: Data.List.NonEmpty.last_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpMZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpN3; else goto cdpN2;
       cdpN3: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.last_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpN2: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = GHC.List.lastError_closure;
           R2 = Hp - 14;
           call poly_go_rdpws_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.299865417 UTC

[section ""data" . Data.List.NonEmpty.init_closure" {
     Data.List.NonEmpty.init_closure:
         const Data.List.NonEmpty.init_info;
 },
 Data.List.NonEmpty.init_entry() //  [R2]
         { info_tbl: [(cdpNc,
                       label: Data.List.NonEmpty.init_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpNc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdpNd; else goto cdpNe;
       cdpNd: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.init_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpNe: // global
           I64[Sp - 8] = block_cdpN9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udpNi; else goto cdpNa;
       udpNi: // global
           call _cdpN9(R1) args: 0, res: 0, upd: 0;
       cdpNa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpN9() //  [R1]
         { info_tbl: [(cdpN9,
                       label: block_cdpN9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpN9: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.List.init1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.301104176 UTC

[section ""data" . Data.List.NonEmpty.<|_closure" {
     Data.List.NonEmpty.<|_closure:
         const Data.List.NonEmpty.<|_info;
 },
 Data.List.NonEmpty.<|_entry() //  [R2, R3]
         { info_tbl: [(cdpNr,
                       label: Data.List.NonEmpty.<|_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpNr: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdpNv; else goto cdpNu;
       cdpNv: // global
           HpAlloc = 96;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.<|_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpNu: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 38;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.302176307 UTC

[section ""data" . Data.List.NonEmpty.cons_closure" {
     Data.List.NonEmpty.cons_closure:
         const Data.List.NonEmpty.cons_info;
 },
 Data.List.NonEmpty.cons_entry() //  [R2, R3]
         { info_tbl: [(cdpNA,
                       label: Data.List.NonEmpty.cons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpNA: // global
           R3 = R3;
           R2 = R2;
           call Data.List.NonEmpty.<|_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.303682884 UTC

[section ""data" . Data.List.NonEmpty.$wunfold_closure" {
     Data.List.NonEmpty.$wunfold_closure:
         const Data.List.NonEmpty.$wunfold_info;
 },
 ds1_sdpxS_entry() //  [R1]
         { info_tbl: [(cdpNY,
                       label: ds1_sdpxS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpNY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdpNZ; else goto cdpO0;
       cdpNZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpO0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdpNV_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Data.List.NonEmpty.$wunfold_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdpNV() //  [R1, R2]
         { info_tbl: [(cdpNV,
                       label: block_cdpNV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpNV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpO3; else goto cdpO2;
       cdpO3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdpO2: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wunfold_entry() //  [R2, R3]
         { info_tbl: [(cdpO4,
                       label: Data.List.NonEmpty.$wunfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpO4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdpO5; else goto cdpO6;
       cdpO5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpO6: // global
           I64[Sp - 16] = block_cdpNH_info;
           _sdpxL::P64 = R2;
           R2 = R3;
           R1 = _sdpxL::P64;
           P64[Sp - 8] = _sdpxL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpNH() //  [R1]
         { info_tbl: [(cdpNH,
                       label: block_cdpNH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpNH: // global
           I64[Sp - 8] = block_cdpNL_info;
           _sdpxO::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sdpxO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udpOk; else goto cdpNM;
       udpOk: // global
           call _cdpNL(R1) args: 0, res: 0, upd: 0;
       cdpNM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpNL() //  [R1]
         { info_tbl: [(cdpNL,
                       label: block_cdpNL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpNL: // global
           _sdpxO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdpOb; else goto cdpOf;
       cdpOb: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _sdpxO::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdpOf: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdpOi; else goto cdpOh;
       cdpOi: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpOh: // global
           _sdpxR::P64 = P64[R1 + 6];
           I64[Hp - 96] = ds1_sdpxS_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sdpxR::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cdpNR::P64 = Hp - 96;
           P64[Hp - 48] = _cdpNR::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdpNR::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 14;
           R1 = _sdpxO::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.305984388 UTC

[section ""data" . Data.List.NonEmpty.unfold_closure" {
     Data.List.NonEmpty.unfold_closure:
         const Data.List.NonEmpty.unfold_info;
 },
 Data.List.NonEmpty.unfold_entry() //  [R2, R3]
         { info_tbl: [(cdpOs,
                       label: Data.List.NonEmpty.unfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpOs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdpOt; else goto cdpOu;
       cdpOt: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpOu: // global
           I64[Sp - 8] = block_cdpOp_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wunfold_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpOp() //  [R1, R2]
         { info_tbl: [(cdpOp,
                       label: block_cdpOp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpOp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpOx; else goto cdpOw;
       cdpOx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdpOw: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.307081503 UTC

[section ""cstring" . lvl_rdpwt_bytes" {
     lvl_rdpwt_bytes:
         I8[] [78,111,110,69,109,112,116,121,46,102,114,111,109,76,105,115,116,58,32,101,109,112,116,121,32,108,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.307944787 UTC

[section ""data" . Data.List.NonEmpty.cycle1_closure" {
     Data.List.NonEmpty.cycle1_closure:
         const Data.List.NonEmpty.cycle1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.List.NonEmpty.cycle1_entry() //  [R1]
         { info_tbl: [(cdpOG,
                       label: Data.List.NonEmpty.cycle1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpOG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdpOH; else goto cdpOI;
       cdpOH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpOI: // global
           (_cdpOB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdpOB::I64 == 0) goto cdpOD; else goto cdpOC;
       cdpOD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdpOC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdpOB::I64;
           I64[Sp - 24] = block_cdpOE_info;
           R2 = lvl_rdpwt_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdpOE() //  [R1]
         { info_tbl: [(cdpOE,
                       label: block_cdpOE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpOE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.309387697 UTC

[section ""data" . Data.List.NonEmpty.fromList_closure" {
     Data.List.NonEmpty.fromList_closure:
         const Data.List.NonEmpty.fromList_info;
         const 0;
 },
 Data.List.NonEmpty.fromList_entry() //  [R2]
         { info_tbl: [(cdpOX,
                       label: Data.List.NonEmpty.fromList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpOX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdpOY; else goto cdpOZ;
       cdpOY: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.fromList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpOZ: // global
           I64[Sp - 8] = block_cdpOQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udpP9; else goto cdpOR;
       udpP9: // global
           call _cdpOQ(R1) args: 0, res: 0, upd: 0;
       cdpOR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpOQ() //  [R1]
         { info_tbl: [(cdpOQ,
                       label: block_cdpOQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpOQ: // global
           if (R1 & 7 == 1) goto cdpOU; else goto cdpOV;
       cdpOU: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdpOV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpP8; else goto cdpP7;
       cdpP8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpP7: // global
           _sdpyd::P64 = P64[R1 + 6];
           _sdpye::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyd::P64;
           P64[Hp] = _sdpye::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.311038329 UTC

[section ""data" . Data.List.NonEmpty.reverse_closure" {
     Data.List.NonEmpty.reverse_closure:
         const Data.List.NonEmpty.reverse_info;
         const 0;
 },
 Data.List.NonEmpty.reverse_entry() //  [R2]
         { info_tbl: [(cdpPn,
                       label: Data.List.NonEmpty.reverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpPn: // global
           _sdpyf::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdpPo; else goto cdpPp;
       cdpPp: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpPr; else goto cdpPq;
       cdpPr: // global
           HpAlloc = 72;
           goto cdpPo;
       cdpPo: // global
           R2 = _sdpyf::P64;
           R1 = Data.List.NonEmpty.reverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpPq: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpyf::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpyf::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdpPh_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp - 8;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpPh() //  [R1]
         { info_tbl: [(cdpPh,
                       label: block_cdpPh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpPh: // global
           if (R1 & 7 == 1) goto cdpPk; else goto cdpPl;
       cdpPk: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdpPl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpPA; else goto cdpPz;
       cdpPA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpPz: // global
           _sdpyr::P64 = P64[R1 + 6];
           _sdpys::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyr::P64;
           P64[Hp] = _sdpys::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.312747145 UTC

[section ""data" . Data.List.NonEmpty.sortBy_closure" {
     Data.List.NonEmpty.sortBy_closure:
         const Data.List.NonEmpty.sortBy_info;
         const 0;
 },
 Data.List.NonEmpty.sortBy_entry() //  [R2, R3]
         { info_tbl: [(cdpPO,
                       label: Data.List.NonEmpty.sortBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpPO: // global
           _sdpyu::P64 = R3;
           _sdpyt::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdpPP; else goto cdpPQ;
       cdpPQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpPS; else goto cdpPR;
       cdpPS: // global
           HpAlloc = 72;
           goto cdpPP;
       cdpPP: // global
           R3 = _sdpyu::P64;
           R2 = _sdpyt::P64;
           R1 = Data.List.NonEmpty.sortBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpPR: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpyu::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpyu::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdpPI_info;
           R3 = Hp - 14;
           R2 = _sdpyt::P64;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpPI() //  [R1]
         { info_tbl: [(cdpPI,
                       label: block_cdpPI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpPI: // global
           if (R1 & 7 == 1) goto cdpPL; else goto cdpPM;
       cdpPL: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdpPM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpQ1; else goto cdpQ0;
       cdpQ1: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpQ0: // global
           _sdpyF::P64 = P64[R1 + 6];
           _sdpyG::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyF::P64;
           P64[Hp] = _sdpyG::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.314777079 UTC

[section ""data" . Data.List.NonEmpty.sortWith_closure" {
     Data.List.NonEmpty.sortWith_closure:
         const Data.List.NonEmpty.sortWith_info;
         const 0;
 },
 sat_sdpyK_entry() //  [R1, R2, R3]
         { info_tbl: [(cdpQe,
                       label: sat_sdpyK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpQe: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Ord.comparing_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.sortWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdpQn,
                       label: Data.List.NonEmpty.sortWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpQn: // global
           _sdpyJ::P64 = R4;
           _sdpyI::P64 = R3;
           _sdpyH::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdpQo; else goto cdpQp;
       cdpQp: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdpQr; else goto cdpQq;
       cdpQr: // global
           HpAlloc = 96;
           goto cdpQo;
       cdpQo: // global
           R4 = _sdpyJ::P64;
           R3 = _sdpyI::P64;
           R2 = _sdpyH::P64;
           R1 = Data.List.NonEmpty.sortWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpQq: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpyJ::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpyJ::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdpyK_info;
           P64[Hp - 8] = _sdpyH::P64;
           P64[Hp] = _sdpyI::P64;
           I64[Sp - 8] = block_cdpQh_info;
           R3 = Hp - 38;
           R2 = Hp - 14;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpQh() //  [R1]
         { info_tbl: [(cdpQh,
                       label: block_cdpQh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpQh: // global
           if (R1 & 7 == 1) goto cdpQk; else goto cdpQl;
       cdpQk: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdpQl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpQA; else goto cdpQz;
       cdpQA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpQz: // global
           _sdpyW::P64 = P64[R1 + 6];
           _sdpyX::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyW::P64;
           P64[Hp] = _sdpyX::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.317036395 UTC

[section ""data" . Data.List.NonEmpty.sort_closure" {
     Data.List.NonEmpty.sort_closure:
         const Data.List.NonEmpty.sort_info;
         const 0;
 },
 sat_sdpz0_entry() //  [R1]
         { info_tbl: [(cdpQM,
                       label: sat_sdpz0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpQM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpQN; else goto cdpQO;
       cdpQN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpQO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.sort_entry() //  [R2, R3]
         { info_tbl: [(cdpQV,
                       label: Data.List.NonEmpty.sort_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpQV: // global
           _sdpyZ::P64 = R3;
           _sdpyY::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdpQW; else goto cdpQX;
       cdpQX: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdpQZ; else goto cdpQY;
       cdpQZ: // global
           HpAlloc = 96;
           goto cdpQW;
       cdpQW: // global
           R3 = _sdpyZ::P64;
           R2 = _sdpyY::P64;
           R1 = Data.List.NonEmpty.sort_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpQY: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpyZ::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpyZ::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdpz0_info;
           P64[Hp] = _sdpyY::P64;
           I64[Sp - 8] = block_cdpQP_info;
           R3 = Hp - 38;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpQP() //  [R1]
         { info_tbl: [(cdpQP,
                       label: block_cdpQP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpQP: // global
           if (R1 & 7 == 1) goto cdpQS; else goto cdpQT;
       cdpQS: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdpQT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpR8; else goto cdpR7;
       cdpR8: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpR7: // global
           _sdpzc::P64 = P64[R1 + 6];
           _sdpzd::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpzc::P64;
           P64[Hp] = _sdpzd::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.319498275 UTC

[section ""data" . Data.List.NonEmpty.inits_closure" {
     Data.List.NonEmpty.inits_closure:
         const Data.List.NonEmpty.inits_info;
         const 0;
 },
 sat_sdpzg_entry() //  [R1]
         { info_tbl: [(cdpRh,
                       label: sat_sdpzg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpRh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpRi; else goto cdpRj;
       cdpRi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpRj: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Foldable.toList_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.inits_entry() //  [R2, R3]
         { info_tbl: [(cdpRn,
                       label: Data.List.NonEmpty.inits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpRn: // global
           _sdpzf::P64 = R3;
           _sdpze::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdpRo; else goto cdpRp;
       cdpRp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdpRr; else goto cdpRq;
       cdpRr: // global
           HpAlloc = 32;
           goto cdpRo;
       cdpRo: // global
           R3 = _sdpzf::P64;
           R2 = _sdpze::P64;
           R1 = Data.List.NonEmpty.inits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpRq: // global
           I64[Hp - 24] = sat_sdpzg_info;
           P64[Hp - 8] = _sdpze::P64;
           P64[Hp] = _sdpzf::P64;
           I64[Sp - 8] = block_cdpRk_info;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call Data.OldList.$winits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpRk() //  [R1, R2]
         { info_tbl: [(cdpRk,
                       label: block_cdpRk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpRk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpRu; else goto cdpRt;
       cdpRu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdpRt: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.32389894 UTC

[section ""data" . Data.List.NonEmpty.tails1_closure" {
     Data.List.NonEmpty.tails1_closure:
         const Data.List.NonEmpty.tails1_info;
 },
 sat_sdpzo_entry() //  [R1]
         { info_tbl: [(cdpRK,
                       label: sat_sdpzo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpRK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdpRL; else goto cdpRM;
       cdpRL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpRM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdpRD_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udpRT; else goto cdpRE;
       udpRT: // global
           call _cdpRD(R1) args: 0, res: 0, upd: 0;
       cdpRE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdpRD() //  [R1]
         { info_tbl: [(cdpRD,
                       label: block_cdpRD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpRD: // global
           if (R1 & 7 == 1) goto cdpRH; else goto cdpRI;
       cdpRH: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdpRI: // global
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call Data.List.NonEmpty.tails1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.tails1_entry() //  [R2]
         { info_tbl: [(cdpRV,
                       label: Data.List.NonEmpty.tails1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpRV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdpRZ; else goto cdpRY;
       cdpRZ: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.List.NonEmpty.tails1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpRY: // global
           I64[Hp - 40] = sat_sdpzo_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.325940129 UTC

[section ""data" . Data.List.NonEmpty.tails_closure" {
     Data.List.NonEmpty.tails_closure:
         const Data.List.NonEmpty.tails_info;
         const 0;
 },
 sat_sdpzr_entry() //  [R1]
         { info_tbl: [(cdpS8,
                       label: sat_sdpzr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpS8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdpS9; else goto cdpSa;
       cdpS9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpSa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Foldable.toList_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.tails_entry() //  [R2, R3]
         { info_tbl: [(cdpSh,
                       label: Data.List.NonEmpty.tails_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpSh: // global
           _sdpzq::P64 = R3;
           _sdpzp::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdpSi; else goto cdpSj;
       cdpSj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdpSl; else goto cdpSk;
       cdpSl: // global
           HpAlloc = 32;
           goto cdpSi;
       cdpSi: // global
           R3 = _sdpzq::P64;
           R2 = _sdpzp::P64;
           R1 = Data.List.NonEmpty.tails_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpSk: // global
           I64[Hp - 24] = sat_sdpzr_info;
           P64[Hp - 8] = _sdpzp::P64;
           P64[Hp] = _sdpzq::P64;
           I64[Sp - 8] = block_cdpSb_info;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call Data.List.NonEmpty.tails1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpSb() //  [R1]
         { info_tbl: [(cdpSb,
                       label: block_cdpSb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpSb: // global
           if (R1 & 7 == 1) goto cdpSe; else goto cdpSf;
       cdpSe: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdpSf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpSu; else goto cdpSt;
       cdpSu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpSt: // global
           _sdpzu::P64 = P64[R1 + 6];
           _sdpzv::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpzu::P64;
           P64[Hp] = _sdpzv::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.327935588 UTC

[section ""data" . Data.List.NonEmpty.insert_closure" {
     Data.List.NonEmpty.insert_closure:
         const Data.List.NonEmpty.insert_info;
 },
 sat_sdpzA_entry() //  [R1]
         { info_tbl: [(cdpSH,
                       label: sat_sdpzA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpSH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpSI; else goto cdpSJ;
       cdpSI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpSJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.insert_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdpSK,
                       label: Data.List.NonEmpty.insert_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpSK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdpSO; else goto cdpSP;
       cdpSO: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.insert_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpSP: // global
           I64[Sp - 24] = block_cdpSz_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdpSz() //  [R1]
         { info_tbl: [(cdpSz,
                       label: block_cdpSz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpSz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpSS; else goto cdpSR;
       cdpSS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpSR: // global
           I64[Hp - 16] = sat_sdpzA_info;
           P64[Hp] = P64[Sp + 8];
           _sdpzy::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdpSL_info;
           R4 = R1;
           R3 = _sdpzy::P64;
           R2 = Hp - 16;
           Sp = Sp + 16;
           call Data.OldList.$winsertBy_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpSL() //  [R1, R2]
         { info_tbl: [(cdpSL,
                       label: block_cdpSL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpSL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpSV; else goto cdpSU;
       cdpSV: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdpSU: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.330095837 UTC

[section ""data" . Data.List.NonEmpty.scanl_closure" {
     Data.List.NonEmpty.scanl_closure:
         const Data.List.NonEmpty.scanl_info;
 },
 sat_sdpzJ_entry() //  [R1]
         { info_tbl: [(cdpT8,
                       label: sat_sdpzJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpT8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpT9; else goto cdpTa;
       cdpT9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpTa: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Foldable.toList_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdpzN_entry() //  [R1]
         { info_tbl: [(cdpTd,
                       label: sat_sdpzN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpTd: // global
           _sdpzN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdpTe; else goto cdpTf;
       cdpTf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdpTh; else goto cdpTg;
       cdpTh: // global
           HpAlloc = 32;
           goto cdpTe;
       cdpTe: // global
           R1 = _sdpzN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpTg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpzN::P64;
           _sdpzF::P64 = P64[_sdpzN::P64 + 16];
           _sdpzG::P64 = P64[_sdpzN::P64 + 24];
           _sdpzH::P64 = P64[_sdpzN::P64 + 32];
           _sdpzI::P64 = P64[_sdpzN::P64 + 40];
           I64[Hp - 24] = sat_sdpzJ_info;
           P64[Hp - 8] = _sdpzF::P64;
           P64[Hp] = _sdpzI::P64;
           I64[Sp - 24] = block_cdpTb_info;
           R4 = Hp - 24;
           R3 = _sdpzH::P64;
           R2 = _sdpzG::P64;
           Sp = Sp - 24;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdpTb() //  [R2]
         { info_tbl: [(cdpTb,
                       label: block_cdpTb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpTb: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.scanl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdpTk,
                       label: Data.List.NonEmpty.scanl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpTk: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpTo; else goto cdpTn;
       cdpTo: // global
           HpAlloc = 72;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpTn: // global
           I64[Hp - 64] = sat_sdpzN_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.332047588 UTC

[section ""data" . Data.List.NonEmpty.scanr_closure" {
     Data.List.NonEmpty.scanr_closure:
         const Data.List.NonEmpty.scanr_info;
 },
 Data.List.NonEmpty.scanr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdpTv,
                       label: Data.List.NonEmpty.scanr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpTv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdpTB; else goto cdpTC;
       cdpTB: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpTC: // global
           I64[Sp - 24] = block_cdpTt_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdpTt() //  [R1]
         { info_tbl: [(cdpTt,
                       label: block_cdpTt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpTt: // global
           _sdpzQ::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdpTy_info;
           R4 = R1;
           R3 = _sdpzQ::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpTy() //  [R1, R2]
         { info_tbl: [(cdpTy,
                       label: block_cdpTy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpTy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpTG; else goto cdpTF;
       cdpTG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdpTF: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.333756394 UTC

[section ""data" . Data.List.NonEmpty.scanl1_closure" {
     Data.List.NonEmpty.scanl1_closure:
         const Data.List.NonEmpty.scanl1_info;
 },
 sat_sdpA8_entry() //  [R1]
         { info_tbl: [(cdpTT,
                       label: sat_sdpA8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpTT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdpTX; else goto cdpTY;
       cdpTX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpTY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdpTQ_info;
           _sdpzW::P64 = P64[R1 + 16];
           _sdpzY::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdpzW::P64;
           P64[Sp - 24] = _sdpzY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udpU2; else goto cdpTR;
       udpU2: // global
           call _cdpTQ(R1) args: 0, res: 0, upd: 0;
       cdpTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdpTQ() //  [R1]
         { info_tbl: [(cdpTQ,
                       label: block_cdpTQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpTQ: // global
           _sdpzY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdpTW_info;
           R4 = P64[R1 + 15];
           R3 = _sdpzY::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdpTW() //  [R2]
         { info_tbl: [(cdpTW,
                       label: block_cdpTW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpTW: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.scanl1_entry() //  [R2, R3]
         { info_tbl: [(cdpU4,
                       label: Data.List.NonEmpty.scanl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpU4: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdpU8; else goto cdpU7;
       cdpU8: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpU7: // global
           I64[Hp - 80] = stg_sel_0_upd_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sdpA8_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           _cdpTL::P64 = Hp - 80;
           P64[Hp - 24] = _cdpTL::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _cdpTL::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.33560957 UTC

[section ""data" . Data.List.NonEmpty.scanr1_closure" {
     Data.List.NonEmpty.scanr1_closure:
         const Data.List.NonEmpty.scanr1_info;
         const 0;
 },
 Data.List.NonEmpty.scanr1_entry() //  [R2, R3]
         { info_tbl: [(cdpUm,
                       label: Data.List.NonEmpty.scanr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpUm: // global
           _sdpAa::P64 = R3;
           _sdpA9::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdpUn; else goto cdpUo;
       cdpUo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpUq; else goto cdpUp;
       cdpUq: // global
           HpAlloc = 72;
           goto cdpUn;
       cdpUn: // global
           R3 = _sdpAa::P64;
           R2 = _sdpA9::P64;
           R1 = Data.List.NonEmpty.scanr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpUp: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpAa::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpAa::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdpUg_info;
           R3 = Hp - 14;
           R2 = _sdpA9::P64;
           Sp = Sp - 8;
           call GHC.List.scanr1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpUg() //  [R1]
         { info_tbl: [(cdpUg,
                       label: block_cdpUg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpUg: // global
           if (R1 & 7 == 1) goto cdpUj; else goto cdpUk;
       cdpUj: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdpUk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpUz; else goto cdpUy;
       cdpUz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpUy: // global
           _sdpAl::P64 = P64[R1 + 6];
           _sdpAm::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpAl::P64;
           P64[Hp] = _sdpAm::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.337097072 UTC

[section ""data" . Data.List.NonEmpty.toList_closure" {
     Data.List.NonEmpty.toList_closure:
         const Data.List.NonEmpty.toList_info;
 },
 Data.List.NonEmpty.toList_entry() //  [R2]
         { info_tbl: [(cdpUH,
                       label: Data.List.NonEmpty.toList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpUH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpUL; else goto cdpUK;
       cdpUL: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.toList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpUK: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.338326182 UTC

[section ""data" . Data.List.NonEmpty.$wtake_closure" {
     Data.List.NonEmpty.$wtake_closure:
         const Data.List.NonEmpty.$wtake_info;
 },
 Data.List.NonEmpty.$wtake_entry() //  [R2, R3]
         { info_tbl: [(cdpUV,
                       label: Data.List.NonEmpty.$wtake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpUV: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpUZ; else goto cdpUY;
       cdpUZ: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wtake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpUY: // global
           if (%MO_S_Ge_W64(0, R2)) goto cdpUT; else goto cdpUU;
       cdpUT: // global
           Hp = Hp - 72;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdpUU: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.339507619 UTC

[section ""data" . Data.List.NonEmpty.take_closure" {
     Data.List.NonEmpty.take_closure:
         const Data.List.NonEmpty.take_info;
 },
 Data.List.NonEmpty.take_entry() //  [R2, R3]
         { info_tbl: [(cdpVc,
                       label: Data.List.NonEmpty.take_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpVc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpVd; else goto cdpVe;
       cdpVd: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.take_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpVe: // global
           I64[Sp - 16] = block_cdpV9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udpVi; else goto cdpVa;
       udpVi: // global
           call _cdpV9(R1) args: 0, res: 0, upd: 0;
       cdpVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpV9() //  [R1]
         { info_tbl: [(cdpV9,
                       label: block_cdpV9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpV9: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wtake_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.340902847 UTC

[section ""data" . Data.List.NonEmpty.$wunsafeDrop_closure" {
     Data.List.NonEmpty.$wunsafeDrop_closure:
         const Data.List.NonEmpty.$wunsafeDrop_info;
 },
 Data.List.NonEmpty.$wunsafeDrop_entry() //  [R2, R3]
         { info_tbl: [(cdpVu,
                       label: Data.List.NonEmpty.$wunsafeDrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpVu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdpVv; else goto udpVJ;
       cdpVv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunsafeDrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udpVJ: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdpVk() args: 0, res: 0, upd: 0;
     }
 },
 _cdpVk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpVk: // global
           I64[Sp - 8] = block_cdpVn_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udpVL; else goto cdpVo;
       udpVL: // global
           call _cdpVn(R1) args: 0, res: 0, upd: 0;
       cdpVo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpVn() //  [R1]
         { info_tbl: [(cdpVn,
                       label: block_cdpVn_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpVn: // global
           if (R1 & 7 == 1) goto cdpVr; else goto cdpVs;
       cdpVr: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdpVs: // global
           _sdpAQ::P64 = P64[R1 + 14];
           _sdpAR::I64 = I64[Sp + 8];
           if (_sdpAR::I64 != 1) goto cdpVF; else goto cdpVG;
       cdpVF: // global
           I64[Sp + 8] = _sdpAR::I64 - 1;
           P64[Sp + 16] = _sdpAQ::P64;
           Sp = Sp + 8;
           call _cdpVk() args: 0, res: 0, upd: 0;
       cdpVG: // global
           R1 = _sdpAQ::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.342472479 UTC

[section ""data" . Data.List.NonEmpty.$wdrop_closure" {
     Data.List.NonEmpty.$wdrop_closure:
         const Data.List.NonEmpty.$wdrop_info;
 },
 Data.List.NonEmpty.$wdrop_entry() //  [R2, R3]
         { info_tbl: [(cdpVX,
                       label: Data.List.NonEmpty.$wdrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpVX: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpW1; else goto cdpW0;
       cdpW1: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wdrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpW0: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cdpVV; else goto cdpVW;
       cdpVV: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call Data.List.NonEmpty.$wunsafeDrop_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
       cdpVW: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.343693788 UTC

[section ""data" . Data.List.NonEmpty.drop_closure" {
     Data.List.NonEmpty.drop_closure:
         const Data.List.NonEmpty.drop_info;
 },
 Data.List.NonEmpty.drop_entry() //  [R2, R3]
         { info_tbl: [(cdpWh,
                       label: Data.List.NonEmpty.drop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpWh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpWi; else goto cdpWj;
       cdpWi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.drop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpWj: // global
           I64[Sp - 16] = block_cdpWe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udpWn; else goto cdpWf;
       udpWn: // global
           call _cdpWe(R1) args: 0, res: 0, upd: 0;
       cdpWf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpWe() //  [R1]
         { info_tbl: [(cdpWe,
                       label: block_cdpWe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpWe: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wdrop_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.345216046 UTC

[section ""data" . Data.List.NonEmpty.splitAt_closure" {
     Data.List.NonEmpty.splitAt_closure:
         const Data.List.NonEmpty.splitAt_info;
 },
 Data.List.NonEmpty.splitAt_entry() //  [R2, R3]
         { info_tbl: [(cdpWv,
                       label: Data.List.NonEmpty.splitAt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpWv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpWw; else goto cdpWx;
       cdpWw: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.splitAt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpWx: // global
           I64[Sp - 16] = block_cdpWs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udpWX; else goto cdpWt;
       udpWX: // global
           call _cdpWs(R1) args: 0, res: 0, upd: 0;
       cdpWt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpWs() //  [R1]
         { info_tbl: [(cdpWs,
                       label: block_cdpWs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpWs: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdpWC; else goto cdpWB;
       cdpWC: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpWB: // global
           _sdpBi::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto cdpWN; else goto cdpWW;
       cdpWN: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpBi::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpBi::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           _cdpWI::P64 = Hp - 38;
           Hp = Hp - 24;
           I64[Sp + 8] = block_cdpWJ_info;
           R3 = _cdpWI::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
       cdpWW: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpBi::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpBi::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = Hp - 38;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdpWJ() //  [R1, R2]
         { info_tbl: [(cdpWJ,
                       label: block_cdpWJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpWJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpWQ; else goto cdpWP;
       cdpWQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdpWP: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.347080466 UTC

[section ""data" . Data.List.NonEmpty.takeWhile_closure" {
     Data.List.NonEmpty.takeWhile_closure:
         const Data.List.NonEmpty.takeWhile_info;
 },
 Data.List.NonEmpty.takeWhile_entry() //  [R2, R3]
         { info_tbl: [(cdpX5,
                       label: Data.List.NonEmpty.takeWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpX5: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpX9; else goto cdpX8;
       cdpX9: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.takeWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpX8: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.348200005 UTC

[section ""data" . Data.List.NonEmpty.dropWhile_closure" {
     Data.List.NonEmpty.dropWhile_closure:
         const Data.List.NonEmpty.dropWhile_info;
 },
 Data.List.NonEmpty.dropWhile_entry() //  [R2, R3]
         { info_tbl: [(cdpXh,
                       label: Data.List.NonEmpty.dropWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpXh: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpXl; else goto cdpXk;
       cdpXl: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.dropWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpXk: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.dropWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.349449239 UTC

[section ""data" . Data.List.NonEmpty.span_closure" {
     Data.List.NonEmpty.span_closure:
         const Data.List.NonEmpty.span_info;
 },
 Data.List.NonEmpty.span_entry() //  [R2, R3]
         { info_tbl: [(cdpXw,
                       label: Data.List.NonEmpty.span_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpXw: // global
           _sdpC4::P64 = R3;
           _sdpC3::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdpXx; else goto cdpXy;
       cdpXy: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpXA; else goto cdpXz;
       cdpXA: // global
           HpAlloc = 72;
           goto cdpXx;
       cdpXx: // global
           R3 = _sdpC4::P64;
           R2 = _sdpC3::P64;
           R1 = Data.List.NonEmpty.span_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpXz: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpC4::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpC4::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdpXt_info;
           R3 = Hp - 14;
           R2 = _sdpC3::P64;
           Sp = Sp - 8;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpXt() //  [R1, R2]
         { info_tbl: [(cdpXt,
                       label: block_cdpXt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpXt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpXD; else goto cdpXC;
       cdpXD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdpXC: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.351103094 UTC

[section ""data" . Data.List.NonEmpty.$wbreak_closure" {
     Data.List.NonEmpty.$wbreak_closure:
         const Data.List.NonEmpty.$wbreak_info;
 },
 sat_sdpCl_entry() //  [R1, R2]
         { info_tbl: [(cdpXW,
                       label: sat_sdpCl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpXW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdpXX; else goto cdpXY;
       cdpXX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpXY: // global
           I64[Sp - 8] = block_cdpXQ_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpXQ() //  [R1]
         { info_tbl: [(cdpXQ,
                       label: block_cdpXQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpXQ: // global
           if (R1 & 7 == 1) goto cdpXT; else goto cdpXU;
       cdpXT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdpXU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wbreak_entry() //  [R2, R3]
         { info_tbl: [(cdpY5,
                       label: Data.List.NonEmpty.$wbreak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpY5: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdpY9; else goto cdpY8;
       cdpY9: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wbreak_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpY8: // global
           I64[Hp - 80] = stg_sel_1_upd_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = stg_sel_0_upd_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           I64[Hp - 8] = sat_sdpCl_info;
           P64[Hp] = R2;
           R3 = Hp - 30;
           R2 = Hp - 7;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.3526983 UTC

[section ""data" . Data.List.NonEmpty.break_closure" {
     Data.List.NonEmpty.break_closure:
         const Data.List.NonEmpty.break_info;
 },
 Data.List.NonEmpty.break_entry() //  [R2, R3]
         { info_tbl: [(cdpYh,
                       label: Data.List.NonEmpty.break_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpYh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdpYi; else goto cdpYj;
       cdpYi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.break_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpYj: // global
           I64[Sp - 8] = block_cdpYe_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wbreak_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpYe() //  [R1, R2]
         { info_tbl: [(cdpYe,
                       label: block_cdpYe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpYe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpYm; else goto cdpYl;
       cdpYm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdpYl: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.354140026 UTC

[section ""data" . Data.List.NonEmpty.filter_closure" {
     Data.List.NonEmpty.filter_closure:
         const Data.List.NonEmpty.filter_info;
 },
 Data.List.NonEmpty.filter_entry() //  [R2, R3]
         { info_tbl: [(cdpYu,
                       label: Data.List.NonEmpty.filter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpYu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdpYy; else goto cdpYx;
       cdpYy: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.filter_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpYx: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.356095748 UTC

[section ""data" . Data.List.NonEmpty.$wpartition_closure" {
     Data.List.NonEmpty.$wpartition_closure:
         const Data.List.NonEmpty.$wpartition_info;
 },
 w3_sdpCS_entry() //  [R1]
         { info_tbl: [(cdpYV,
                       label: w3_sdpCS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpYV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdpYW; else goto cdpYX;
       cdpYW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdpYX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdpYS_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo_sdpCN_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdpYS() //  [R1, R2]
         { info_tbl: [(cdpYS,
                       label: block_cdpYS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpYS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpZ0; else goto cdpYZ;
       cdpZ0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdpYZ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_sdpCN_entry() //  [R1, R2]
         { info_tbl: [(cdpZ5,
                       label: $wgo_sdpCN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpZ5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdpZ6; else goto cdpZ7;
       cdpZ6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdpZ7: // global
           I64[Sp - 24] = block_cdpYI_info;
           _sdpCN::P64 = R1;
           _sdpCL::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdpCL::P64;
           P64[Sp - 8] = _sdpCN::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udpZz; else goto cdpYJ;
       udpZz: // global
           call _cdpYI(R1) args: 0, res: 0, upd: 0;
       cdpYJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpYI() //  [R1]
         { info_tbl: [(cdpYI,
                       label: block_cdpYI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpYI: // global
           if (R1 & 7 == 1) goto cdpZ2; else goto cdpZ3;
       cdpZ2: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdpZ3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdpZd; else goto cdpZc;
       cdpZd: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpZc: // global
           _sdpCQ::P64 = P64[R1 + 6];
           _sdpCR::P64 = P64[R1 + 14];
           I64[Hp - 24] = w3_sdpCS_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdpCR::P64;
           I64[Sp] = block_cdpZa_info;
           R2 = _sdpCQ::P64;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdpCQ::P64;
           P64[Sp + 16] = Hp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdpZa() //  [R1]
         { info_tbl: [(cdpZa,
                       label: block_cdpZa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpZa: // global
           _cdpYO::P64 = P64[Sp + 16];
           _sdpCQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdpZl; else goto cdpZu;
       cdpZl: // global
           Hp = Hp + 72;
           _sdpCW::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdpZx; else goto cdpZn;
       cdpZn: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cdpYO::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sdpCQ::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cdpYO::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdpZu: // global
           Hp = Hp + 72;
           _sdpCW::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdpZx; else goto cdpZw;
       cdpZx: // global
           HpAlloc = 72;
           R1 = _sdpCW::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpZw: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cdpYO::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdpYO::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdpCQ::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wpartition_entry() //  [R2, R3]
         { info_tbl: [(cdpZD,
                       label: Data.List.NonEmpty.$wpartition_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpZD: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdpZH; else goto cdpZG;
       cdpZH: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wpartition_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpZG: // global
           I64[Hp - 80] = $wgo_sdpCN_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 14;
           R1 = Hp - 79;
           call $wgo_sdpCN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.360569014 UTC

[section ""data" . Data.List.NonEmpty.partition_closure" {
     Data.List.NonEmpty.partition_closure:
         const Data.List.NonEmpty.partition_info;
 },
 Data.List.NonEmpty.partition_entry() //  [R2, R3]
         { info_tbl: [(cdpZP,
                       label: Data.List.NonEmpty.partition_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpZP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdpZQ; else goto cdpZR;
       cdpZQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.partition_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpZR: // global
           I64[Sp - 8] = block_cdpZM_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wpartition_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdpZM() //  [R1, R2]
         { info_tbl: [(cdpZM,
                       label: block_cdpZM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdpZM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdpZU; else goto cdpZT;
       cdpZU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdpZT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.362281879 UTC

[section ""data" . Data.List.NonEmpty.cycle_closure" {
     Data.List.NonEmpty.cycle_closure:
         const Data.List.NonEmpty.cycle_info;
         const 0;
 },
 xs'_sdpDu_entry() //  [R1]
         { info_tbl: [(cdq06,
                       label: xs'_sdpDu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq06: // global
           _sdpDu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdq07; else goto cdq08;
       cdq08: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdq0a; else goto cdq09;
       cdq0a: // global
           HpAlloc = 72;
           goto cdq07;
       cdq07: // global
           R1 = _sdpDu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq09: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpDu::P64;
           _sdpDt::P64 = P64[_sdpDu::P64 + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpDt::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpDt::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = _sdpDu::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.cycle_entry() //  [R2]
         { info_tbl: [(cdq0i,
                       label: Data.List.NonEmpty.cycle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq0i: // global
           _sdpDt::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdq0j; else goto cdq0k;
       cdq0k: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq0m; else goto cdq0l;
       cdq0m: // global
           HpAlloc = 24;
           goto cdq0j;
       cdq0j: // global
           R2 = _sdpDt::P64;
           R1 = Data.List.NonEmpty.cycle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdq0l: // global
           I64[Hp - 16] = xs'_sdpDu_info;
           P64[Hp] = _sdpDt::P64;
           I64[Sp - 8] = block_cdq0b_info;
           R1 = Hp - 16;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udq0w; else goto cdq0c;
       udq0w: // global
           call _cdq0b(R1) args: 0, res: 0, upd: 0;
       cdq0c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdq0b() //  [R1]
         { info_tbl: [(cdq0b,
                       label: block_cdq0b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq0b: // global
           if (R1 & 7 == 1) goto cdq0f; else goto cdq0g;
       cdq0f: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdq0g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq0v; else goto cdq0u;
       cdq0v: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdq0u: // global
           _sdpDG::P64 = P64[R1 + 6];
           _sdpDH::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpDG::P64;
           P64[Hp] = _sdpDH::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.36576014 UTC

[section ""data" . Data.List.NonEmpty.$wtranspose_closure" {
     Data.List.NonEmpty.$wtranspose_closure:
         const Data.List.NonEmpty.$wtranspose_info;
         const 0;
 },
 sat_sdpE2_entry() //  [R1]
         { info_tbl: [(cdq0M,
                       label: sat_sdpE2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq0M: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdq0N; else goto cdq0O;
       cdq0N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq0O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdq0J_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udq0S; else goto cdq0K;
       udq0S: // global
           call _cdq0J(R1) args: 0, res: 0, upd: 0;
       cdq0K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq0J() //  [R1]
         { info_tbl: [(cdq0J,
                       label: block_cdq0J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq0J: // global
           R3 = P64[R1 + 15];
           R2 = Data.List.NonEmpty.toList_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpDX_entry() //  [R1]
         { info_tbl: [(cdq10,
                       label: sat_sdpDX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq10: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdq14; else goto cdq15;
       cdq14: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq15: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdq0X_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udq1d; else goto cdq0Y;
       udq1d: // global
           call _cdq0X(R1) args: 0, res: 0, upd: 0;
       cdq0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq0X() //  [R1]
         { info_tbl: [(cdq0X,
                       label: block_cdq0X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq0X: // global
           I64[Sp] = block_cdq13_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udq1c; else goto cdq17;
       udq1c: // global
           call _cdq13(R1) args: 0, res: 0, upd: 0;
       cdq17: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq13() //  [R1]
         { info_tbl: [(cdq13,
                       label: block_cdq13_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq13: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpDQ_entry() //  [R1]
         { info_tbl: [(cdq1l,
                       label: sat_sdpDQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq1l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdq1p; else goto cdq1q;
       cdq1p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq1q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdq1i_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udq1y; else goto cdq1j;
       udq1y: // global
           call _cdq1i(R1) args: 0, res: 0, upd: 0;
       cdq1j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq1i() //  [R1]
         { info_tbl: [(cdq1i,
                       label: block_cdq1i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq1i: // global
           I64[Sp] = block_cdq1o_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udq1x; else goto cdq1s;
       udq1x: // global
           call _cdq1o(R1) args: 0, res: 0, upd: 0;
       cdq1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq1o() //  [R1]
         { info_tbl: [(cdq1o,
                       label: block_cdq1o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq1o: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds_sdpDJ_entry() //  [R1]
         { info_tbl: [(cdq1H,
                       label: ds_sdpDJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq1H: // global
           _sdpDJ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdq1I; else goto cdq1J;
       cdq1J: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdq1L; else goto cdq1K;
       cdq1L: // global
           HpAlloc = 120;
           goto cdq1I;
       cdq1I: // global
           R1 = _sdpDJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq1K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpDJ::P64;
           _sdpDI::P64 = P64[_sdpDJ::P64 + 16];
           I64[Hp - 112] = sat_sdpE2_info;
           P64[Hp - 96] = _sdpDI::P64;
           I64[Hp - 88] = sat_sdpDX_info;
           P64[Hp - 72] = _sdpDI::P64;
           I64[Hp - 64] = sat_sdpDQ_info;
           P64[Hp - 48] = _sdpDI::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 112;
           I64[Sp - 24] = block_cdq1B_info;
           R2 = Hp - 14;
           Sp = Sp - 24;
           call Data.OldList.transpose_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdq1B() //  [R1]
         { info_tbl: [(cdq1B,
                       label: block_cdq1B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq1B: // global
           if (R1 & 7 == 1) goto cdq1E; else goto cdq1F;
       cdq1E: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cdq1F: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq1U; else goto cdq1T;
       cdq1U: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdq1T: // global
           _sdpE5::P64 = P64[R1 + 6];
           _sdpE6::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpE5::P64;
           P64[Hp] = _sdpE6::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEh_entry() //  [R1]
         { info_tbl: [(cdq22,
                       label: sat_sdpEh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq22: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdq23; else goto cdq24;
       cdq23: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq24: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdq1Z_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udq28; else goto cdq20;
       udq28: // global
           call _cdq1Z(R1) args: 0, res: 0, upd: 0;
       cdq20: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq1Z() //  [R1]
         { info_tbl: [(cdq1Z,
                       label: block_cdq1Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq1Z: // global
           R3 = P64[R1 + 15];
           R2 = Data.List.NonEmpty.fromList_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEd_entry() //  [R1]
         { info_tbl: [(cdq2g,
                       label: sat_sdpEd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq2g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdq2h; else goto cdq2i;
       cdq2h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq2i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdq2d_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udq2D; else goto cdq2e;
       udq2D: // global
           call _cdq2d(R1) args: 0, res: 0, upd: 0;
       cdq2e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq2d() //  [R1]
         { info_tbl: [(cdq2d,
                       label: block_cdq2d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq2d: // global
           I64[Sp] = block_cdq2l_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udq2C; else goto cdq2n;
       udq2C: // global
           call _cdq2l(R1) args: 0, res: 0, upd: 0;
       cdq2n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq2l() //  [R1]
         { info_tbl: [(cdq2l,
                       label: block_cdq2l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq2l: // global
           if (R1 & 7 == 1) goto cdq2t; else goto cdq2x;
       cdq2t: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cdq2x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq2A; else goto cdq2z;
       cdq2A: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdq2z: // global
           _sdpEb::P64 = P64[R1 + 6];
           _sdpEc::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpEb::P64;
           P64[Hp] = _sdpEc::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wtranspose_entry() //  [R2]
         { info_tbl: [(cdq2E,
                       label: Data.List.NonEmpty.$wtranspose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq2E: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdq2I; else goto cdq2H;
       cdq2I: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wtranspose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdq2H: // global
           I64[Hp - 64] = ds_sdpDJ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdpEh_info;
           _cdq0B::P64 = Hp - 64;
           P64[Hp - 24] = _cdq0B::P64;
           I64[Hp - 16] = sat_sdpEd_info;
           P64[Hp] = _cdq0B::P64;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.370503868 UTC

[section ""data" . Data.List.NonEmpty.transpose_closure" {
     Data.List.NonEmpty.transpose_closure:
         const Data.List.NonEmpty.transpose_info;
         const 0;
 },
 Data.List.NonEmpty.transpose_entry() //  [R2]
         { info_tbl: [(cdq2Q,
                       label: Data.List.NonEmpty.transpose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq2Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdq2R; else goto cdq2S;
       cdq2R: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.transpose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdq2S: // global
           I64[Sp - 8] = block_cdq2N_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wtranspose_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdq2N() //  [R1, R2]
         { info_tbl: [(cdq2N,
                       label: block_cdq2N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq2N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq2V; else goto cdq2U;
       cdq2V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdq2U: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.372211016 UTC

[section ""data" . Data.List.NonEmpty.map_closure" {
     Data.List.NonEmpty.map_closure:
         const Data.List.NonEmpty.map_info;
 },
 sat_sdpEw_entry() //  [R1]
         { info_tbl: [(cdq37,
                       label: sat_sdpEw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq37: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdq38; else goto cdq39;
       cdq38: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq39: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdq34_info;
           _sdpEm::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpEm::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udq3d; else goto cdq35;
       udq3d: // global
           call _cdq34(R1) args: 0, res: 0, upd: 0;
       cdq35: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq34() //  [R1]
         { info_tbl: [(cdq34,
                       label: block_cdq34_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq34: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEs_entry() //  [R1]
         { info_tbl: [(cdq3j,
                       label: sat_sdpEs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq3j: // global
           _sdpEs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdq3k; else goto cdq3l;
       cdq3l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq3n; else goto cdq3m;
       cdq3n: // global
           HpAlloc = 24;
           goto cdq3k;
       cdq3k: // global
           R1 = _sdpEs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq3m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpEs::P64;
           _sdpEm::P64 = P64[_sdpEs::P64 + 16];
           _sdpEn::P64 = P64[_sdpEs::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdpEn::P64;
           R2 = Hp - 16;
           R1 = _sdpEm::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.map_entry() //  [R2, R3]
         { info_tbl: [(cdq3p,
                       label: Data.List.NonEmpty.map_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq3p: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdq3t; else goto cdq3s;
       cdq3t: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.map_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq3s: // global
           I64[Hp - 80] = sat_sdpEw_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sdpEs_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.374602867 UTC

[section ""data" . Data.List.NonEmpty.some1_closure" {
     Data.List.NonEmpty.some1_closure:
         const Data.List.NonEmpty.some1_info;
 },
 sat_sdpEA_entry() //  [R1]
         { info_tbl: [(cdq3C,
                       label: sat_sdpEA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq3C: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdq3D; else goto cdq3E;
       cdq3D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq3E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.many_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.some1_entry() //  [R2, R3]
         { info_tbl: [(cdq3H,
                       label: Data.List.NonEmpty.some1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq3H: // global
           _sdpEy::P64 = R3;
           _sdpEx::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdq3I; else goto cdq3J;
       cdq3J: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdq3L; else goto cdq3K;
       cdq3L: // global
           HpAlloc = 32;
           goto cdq3I;
       cdq3I: // global
           R3 = _sdpEy::P64;
           R2 = _sdpEx::P64;
           R1 = Data.List.NonEmpty.some1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq3K: // global
           I64[Hp - 24] = sat_sdpEA_info;
           P64[Hp - 8] = _sdpEx::P64;
           P64[Hp] = _sdpEy::P64;
           I64[Sp - 24] = block_cdq3F_info;
           R2 = _sdpEx::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sdpEy::P64;
           Sp = Sp - 24;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdq3F() //  [R1]
         { info_tbl: [(cdq3F,
                       label: block_cdq3F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq3F: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = GHC.Base.:|_closure+2;
           _cdq3y::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cdq3y::P64;
           Sp = Sp - 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.376762791 UTC

[section ""data" . Data.List.NonEmpty.intersperse_closure" {
     Data.List.NonEmpty.intersperse_closure:
         const Data.List.NonEmpty.intersperse_info;
 },
 sat_sdpEN_entry() //  [R1]
         { info_tbl: [(cdq4c,
                       label: sat_sdpEN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq4c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdq4d; else goto cdq4e;
       cdq4d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq4e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEP_entry() //  [R1]
         { info_tbl: [(cdq4f,
                       label: sat_sdpEP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq4f: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdq4g; else goto cdq4h;
       cdq4g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq4h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdq3X_info;
           _sdpEB::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpEB::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udq4v; else goto cdq3Y;
       udq4v: // global
           call _cdq3X(R1) args: 0, res: 0, upd: 0;
       cdq3Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq3X() //  [R1]
         { info_tbl: [(cdq3X,
                       label: block_cdq3X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq3X: // global
           I64[Sp] = block_cdq42_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto udq4u; else goto cdq43;
       udq4u: // global
           call _cdq42(R1) args: 0, res: 0, upd: 0;
       cdq43: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq42() //  [R1]
         { info_tbl: [(cdq42,
                       label: block_cdq42_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq42: // global
           if (R1 & 7 == 1) goto cdq4m; else goto cdq4p;
       cdq4m: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdq4p: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdq4s; else goto cdq4r;
       cdq4s: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdq4r: // global
           _sdpEL::P64 = P64[R1 + 6];
           _sdpEM::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sdpEN_info;
           _sdpEB::P64 = P64[Sp + 8];
           P64[Hp - 56] = _sdpEB::P64;
           P64[Hp - 48] = _sdpEM::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sdpEL::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdpEB::P64;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.intersperse_entry() //  [R2, R3]
         { info_tbl: [(cdq4y,
                       label: Data.List.NonEmpty.intersperse_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq4y: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdq4C; else goto cdq4B;
       cdq4C: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.intersperse_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq4B: // global
           I64[Hp - 72] = sat_sdpEP_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.379338992 UTC

[section ""data" . Data.List.NonEmpty.iterate_closure" {
     Data.List.NonEmpty.iterate_closure:
         const Data.List.NonEmpty.iterate_info;
 },
 sat_sdpEW_entry() //  [R1]
         { info_tbl: [(cdq4P,
                       label: sat_sdpEW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq4P: // global
           _sdpEW::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdq4Q; else goto cdq4R;
       cdq4R: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdq4T; else goto cdq4S;
       cdq4T: // global
           HpAlloc = 32;
           goto cdq4Q;
       cdq4Q: // global
           R1 = _sdpEW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq4S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpEW::P64;
           _sdpEQ::P64 = P64[_sdpEW::P64 + 16];
           _sdpER::P64 = P64[_sdpEW::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpEQ::P64;
           P64[Hp] = _sdpER::P64;
           I64[Sp - 24] = block_cdq4M_info;
           R3 = Hp - 24;
           R2 = _sdpEQ::P64;
           Sp = Sp - 24;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdq4M() //  [R1, R2]
         { info_tbl: [(cdq4M,
                       label: block_cdq4M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq4M: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq4W; else goto cdq4V;
       cdq4W: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdq4V: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.iterate_entry() //  [R2, R3]
         { info_tbl: [(cdq4Y,
                       label: Data.List.NonEmpty.iterate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq4Y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdq52; else goto cdq51;
       cdq52: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.iterate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq51: // global
           I64[Hp - 48] = sat_sdpEW_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.381147965 UTC

[section ""data" . Data.List.NonEmpty.repeat_closure" {
     Data.List.NonEmpty.repeat_closure:
         const Data.List.NonEmpty.repeat_info;
 },
 sat_sdpEY_entry() //  [R1]
         { info_tbl: [(cdq5b,
                       label: sat_sdpEY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq5b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdq5c; else goto cdq5d;
       cdq5c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq5d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.repeat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.repeat_entry() //  [R2]
         { info_tbl: [(cdq5f,
                       label: Data.List.NonEmpty.repeat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq5f: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdq5j; else goto cdq5i;
       cdq5j: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.List.NonEmpty.repeat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdq5i: // global
           I64[Hp - 40] = sat_sdpEY_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.383196099 UTC

[section ""data" . Data.List.NonEmpty.groupBy_$sgroupBy_closure" {
     Data.List.NonEmpty.groupBy_$sgroupBy_closure:
         const Data.List.NonEmpty.groupBy_$sgroupBy_info;
 },
 ds_sdpF4_entry() //  [R1]
         { info_tbl: [(cdq5C,
                       label: ds_sdpF4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq5C: // global
           _sdpF4::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdq5D; else goto cdq5E;
       cdq5E: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdq5G; else goto cdq5F;
       cdq5G: // global
           HpAlloc = 32;
           goto cdq5D;
       cdq5D: // global
           R1 = _sdpF4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq5F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpF4::P64;
           _sdpEZ::P64 = P64[_sdpF4::P64 + 16];
           _sdpF2::P64 = P64[_sdpF4::P64 + 24];
           _sdpF3::P64 = P64[_sdpF4::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpEZ::P64;
           P64[Hp] = _sdpF2::P64;
           I64[Sp - 24] = block_cdq5z_info;
           R3 = _sdpF3::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdq5z() //  [R1, R2]
         { info_tbl: [(cdq5z,
                       label: block_cdq5z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq5z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq5J; else goto cdq5I;
       cdq5J: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdq5I: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpFh_entry() //  [R1]
         { info_tbl: [(cdq5R,
                       label: sat_sdpFh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq5R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdq5S; else goto cdq5T;
       cdq5S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq5T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdq5O_info;
           _sdpEZ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpEZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udq5X; else goto cdq5P;
       udq5X: // global
           call _cdq5O(R1) args: 0, res: 0, upd: 0;
       cdq5P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq5O() //  [R1]
         { info_tbl: [(cdq5O,
                       label: block_cdq5O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq5O: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy_$sgroupBy_entry() //  [R2, R3]
         { info_tbl: [(cdq62,
                       label: Data.List.NonEmpty.groupBy_$sgroupBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq62: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdq63; else goto cdq64;
       cdq63: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy_$sgroupBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq64: // global
           I64[Sp - 16] = block_cdq5o_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udq6d; else goto cdq5p;
       udq6d: // global
           call _cdq5o(R1) args: 0, res: 0, upd: 0;
       cdq5p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdq5o() //  [R1]
         { info_tbl: [(cdq5o,
                       label: block_cdq5o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq5o: // global
           if (R1 & 7 == 1) goto cdq5Z; else goto cdq60;
       cdq5Z: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdq60: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdq6c; else goto cdq6b;
       cdq6c: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdq6b: // global
           _sdpF2::P64 = P64[R1 + 6];
           _sdpF3::P64 = P64[R1 + 14];
           I64[Hp - 136] = ds_sdpF4_info;
           _sdpEZ::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdpEZ::P64;
           P64[Hp - 112] = _sdpF2::P64;
           P64[Hp - 104] = _sdpF3::P64;
           I64[Hp - 96] = sat_sdpFh_info;
           P64[Hp - 80] = _sdpEZ::P64;
           _cdq5u::P64 = Hp - 136;
           P64[Hp - 72] = _cdq5u::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdq5u::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpF2::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.386550003 UTC

[section ""data" . Data.List.NonEmpty.groupBy_closure" {
     Data.List.NonEmpty.groupBy_closure:
         const Data.List.NonEmpty.groupBy_info;
 },
 ds_sdpFo_entry() //  [R1]
         { info_tbl: [(cdq6v,
                       label: ds_sdpFo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq6v: // global
           _sdpFo::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdq6w; else goto cdq6x;
       cdq6x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdq6z; else goto cdq6y;
       cdq6z: // global
           HpAlloc = 32;
           goto cdq6w;
       cdq6w: // global
           R1 = _sdpFo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq6y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpFo::P64;
           _sdpFj::P64 = P64[_sdpFo::P64 + 16];
           _sdpFm::P64 = P64[_sdpFo::P64 + 24];
           _sdpFn::P64 = P64[_sdpFo::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpFj::P64;
           P64[Hp] = _sdpFm::P64;
           I64[Sp - 24] = block_cdq6s_info;
           R3 = _sdpFn::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdq6s() //  [R1, R2]
         { info_tbl: [(cdq6s,
                       label: block_cdq6s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq6s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq6C; else goto cdq6B;
       cdq6C: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdq6B: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpFB_entry() //  [R1]
         { info_tbl: [(cdq6K,
                       label: sat_sdpFB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq6K: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdq6L; else goto cdq6M;
       cdq6L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq6M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdq6H_info;
           _sdpFj::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpFj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udq6Q; else goto cdq6I;
       udq6Q: // global
           call _cdq6H(R1) args: 0, res: 0, upd: 0;
       cdq6I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq6H() //  [R1]
         { info_tbl: [(cdq6H,
                       label: block_cdq6H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq6H: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdq6V,
                       label: Data.List.NonEmpty.groupBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq6V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdq6W; else goto cdq6X;
       cdq6W: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq6X: // global
           I64[Sp - 16] = block_cdq6i_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdq6i() //  [R1]
         { info_tbl: [(cdq6i,
                       label: block_cdq6i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq6i: // global
           if (R1 & 7 == 1) goto cdq6S; else goto cdq6T;
       cdq6S: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdq6T: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdq75; else goto cdq74;
       cdq75: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdq74: // global
           _sdpFm::P64 = P64[R1 + 6];
           _sdpFn::P64 = P64[R1 + 14];
           I64[Hp - 136] = ds_sdpFo_info;
           _sdpFj::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdpFj::P64;
           P64[Hp - 112] = _sdpFm::P64;
           P64[Hp - 104] = _sdpFn::P64;
           I64[Hp - 96] = sat_sdpFB_info;
           P64[Hp - 80] = _sdpFj::P64;
           _cdq6n::P64 = Hp - 136;
           P64[Hp - 72] = _cdq6n::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdq6n::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpFm::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.390349409 UTC

[section ""data" . Data.List.NonEmpty.groupWith_closure" {
     Data.List.NonEmpty.groupWith_closure:
         const Data.List.NonEmpty.groupWith_info;
 },
 eq0_sdpFJ_entry() //  [R1, R2, R3]
         { info_tbl: [(cdq7m,
                       label: eq0_sdpFJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq7m: // global
           _sdpFL::P64 = R3;
           _sdpFK::P64 = R2;
           _sdpFJ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdq7n; else goto cdq7o;
       cdq7o: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdq7q; else goto cdq7p;
       cdq7q: // global
           HpAlloc = 64;
           goto cdq7n;
       cdq7n: // global
           R3 = _sdpFL::P64;
           R2 = _sdpFK::P64;
           R1 = _sdpFJ::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq7p: // global
           _sdpFD::P64 = P64[_sdpFJ::P64 + 6];
           _sdpFE::P64 = P64[_sdpFJ::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdpFE::P64;
           P64[Hp - 32] = _sdpFL::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpFE::P64;
           P64[Hp] = _sdpFK::P64;
           R2 = _sdpFD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdpFP_entry() //  [R1, R2]
         { info_tbl: [(cdq7A,
                       label: sat_sdpFP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq7A: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call eq0_sdpFJ_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdpFO_entry() //  [R1]
         { info_tbl: [(cdq7G,
                       label: ds_sdpFO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq7G: // global
           _sdpFO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdq7H; else goto cdq7I;
       cdq7I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq7K; else goto cdq7J;
       cdq7K: // global
           HpAlloc = 24;
           goto cdq7H;
       cdq7H: // global
           R1 = _sdpFO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq7J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpFO::P64;
           _sdpFH::P64 = P64[_sdpFO::P64 + 16];
           _sdpFI::P64 = P64[_sdpFO::P64 + 24];
           _sdpFJ::P64 = P64[_sdpFO::P64 + 32];
           I64[Hp - 16] = sat_sdpFP_info;
           P64[Hp - 8] = _sdpFH::P64;
           P64[Hp] = _sdpFJ::P64;
           I64[Sp - 24] = block_cdq7D_info;
           R3 = _sdpFI::P64;
           R2 = Hp - 15;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdq7D() //  [R1, R2]
         { info_tbl: [(cdq7D,
                       label: block_cdq7D_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq7D: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq7N; else goto cdq7M;
       cdq7N: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdq7M: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpG1_entry() //  [R1]
         { info_tbl: [(cdq7V,
                       label: sat_sdpG1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq7V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdq7W; else goto cdq7X;
       cdq7W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq7X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdq7S_info;
           _sdpFJ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpFJ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udq81; else goto cdq7T;
       udq81: // global
           call _cdq7S(R1) args: 0, res: 0, upd: 0;
       cdq7T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdq7S() //  [R1]
         { info_tbl: [(cdq7S,
                       label: block_cdq7S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq7S: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdq86,
                       label: Data.List.NonEmpty.groupWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq86: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdq87; else goto cdq88;
       cdq87: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq88: // global
           I64[Sp - 24] = block_cdq7a_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdq7a() //  [R1]
         { info_tbl: [(cdq7a,
                       label: block_cdq7a_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq7a: // global
           if (R1 & 7 == 1) goto cdq83; else goto cdq84;
       cdq83: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdq84: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdq8g; else goto cdq8f;
       cdq8g: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdq8f: // global
           _sdpFH::P64 = P64[R1 + 6];
           _sdpFI::P64 = P64[R1 + 14];
           I64[Hp - 160] = eq0_sdpFJ_info;
           P64[Hp - 152] = P64[Sp + 8];
           P64[Hp - 144] = P64[Sp + 16];
           I64[Hp - 136] = ds_sdpFO_info;
           P64[Hp - 120] = _sdpFH::P64;
           P64[Hp - 112] = _sdpFI::P64;
           _cdq7f::P64 = Hp - 158;
           P64[Hp - 104] = _cdq7f::P64;
           I64[Hp - 96] = sat_sdpG1_info;
           P64[Hp - 80] = _cdq7f::P64;
           _cdq7r::P64 = Hp - 136;
           P64[Hp - 72] = _cdq7r::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdq7r::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpFH::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.393852529 UTC

[section ""data" . Data.List.NonEmpty.group_closure" {
     Data.List.NonEmpty.group_closure:
         const Data.List.NonEmpty.group_info;
 },
 sat_sdpG5_entry() //  [R1]
         { info_tbl: [(cdq8p,
                       label: sat_sdpG5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq8p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdq8q; else goto cdq8r;
       cdq8q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq8r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.group_entry() //  [R2, R3, R4]
         { info_tbl: [(cdq8s,
                       label: Data.List.NonEmpty.group_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq8s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdq8w; else goto cdq8v;
       cdq8w: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.group_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq8v: // global
           I64[Hp - 16] = sat_sdpG5_info;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 16;
           R2 = R2;
           call Data.List.NonEmpty.groupBy_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.395467561 UTC

[section ""data" . Data.List.NonEmpty.isPrefixOf_closure" {
     Data.List.NonEmpty.isPrefixOf_closure:
         const Data.List.NonEmpty.isPrefixOf_info;
 },
 Data.List.NonEmpty.isPrefixOf_entry() //  [R2, R3, R4]
         { info_tbl: [(cdq8I,
                       label: Data.List.NonEmpty.isPrefixOf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq8I: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdq8J; else goto cdq8K;
       cdq8J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.isPrefixOf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq8K: // global
           I64[Sp - 24] = block_cdq8B_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udq9a; else goto cdq8C;
       udq9a: // global
           call _cdq8B(R1) args: 0, res: 0, upd: 0;
       cdq8C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdq8B() //  [R1]
         { info_tbl: [(cdq8B,
                       label: block_cdq8B_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq8B: // global
           if (R1 & 7 == 1) goto cdq8F; else goto cdq8G;
       cdq8F: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdq8G: // global
           I64[Sp - 8] = block_cdq8Q_info;
           _sdpGa::P64 = P64[R1 + 6];
           _sdpGb::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdpGb::P64;
           P64[Sp + 16] = _sdpGa::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udq99; else goto cdq8S;
       udq99: // global
           call _cdq8Q(R1) args: 0, res: 0, upd: 0;
       cdq8S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdq8Q() //  [R1]
         { info_tbl: [(cdq8Q,
                       label: block_cdq8Q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq8Q: // global
           I64[Sp] = block_cdq8W_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdq8W() //  [R1]
         { info_tbl: [(cdq8W,
                       label: block_cdq8W_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq8W: // global
           if (R1 & 7 == 1) goto cdq93; else goto cdq97;
       cdq93: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdq97: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.OldList.isPrefixOf_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.397146448 UTC

[section ""cstring" . lvl1_rdpwu_bytes" {
     lvl1_rdpwu_bytes:
         I8[] [78,111,110,69,109,112,116,121,46,33,33,32,110,101,103,97,116,105,118,101,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.398016106 UTC

[section ""data" . Data.List.NonEmpty.!!1_closure" {
     Data.List.NonEmpty.!!1_closure:
         const Data.List.NonEmpty.!!1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.List.NonEmpty.!!1_entry() //  [R1]
         { info_tbl: [(cdq9j,
                       label: Data.List.NonEmpty.!!1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq9j: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdq9k; else goto cdq9l;
       cdq9k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdq9l: // global
           (_cdq9e::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdq9e::I64 == 0) goto cdq9g; else goto cdq9f;
       cdq9g: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdq9f: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdq9e::I64;
           I64[Sp - 24] = block_cdq9h_info;
           R2 = lvl1_rdpwu_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdq9h() //  [R1]
         { info_tbl: [(cdq9h,
                       label: block_cdq9h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq9h: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.399419605 UTC

[section ""data" . Data.List.NonEmpty.$w!!_closure" {
     Data.List.NonEmpty.$w!!_closure:
         const Data.List.NonEmpty.$w!!_info;
         const 0;
 },
 Data.List.NonEmpty.$w!!_entry() //  [R2, R3, R4]
         { info_tbl: [(cdq9x,
                       label: Data.List.NonEmpty.$w!!_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq9x: // global
           if (R4 == 0) goto cdq9w; else goto cdq9v;
       cdq9w: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdq9v: // global
           if (%MO_S_Le_W64(R4, 0)) goto cdq9E; else goto cdq9F;
       cdq9E: // global
           R1 = Data.List.NonEmpty.!!1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdq9F: // global
           _sdpGi::P64 = R3;
           R3 = R4 - 1;
           R2 = _sdpGi::P64;
           call GHC.List.$w!!_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.400621591 UTC

[section ""data" . Data.List.NonEmpty.!!_closure" {
     Data.List.NonEmpty.!!_closure:
         const Data.List.NonEmpty.!!_info;
         const 0;
 },
 Data.List.NonEmpty.!!_entry() //  [R2, R3]
         { info_tbl: [(cdq9Q,
                       label: Data.List.NonEmpty.!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq9Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdq9U; else goto cdq9V;
       cdq9U: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.!!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdq9V: // global
           I64[Sp - 16] = block_cdq9N_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqa3; else goto cdq9O;
       udqa3: // global
           call _cdq9N(R1) args: 0, res: 0, upd: 0;
       cdq9O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdq9N() //  [R1]
         { info_tbl: [(cdq9N,
                       label: block_cdq9N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq9N: // global
           I64[Sp - 8] = block_cdq9T_info;
           _sdpGq::P64 = P64[R1 + 7];
           _sdpGr::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdpGr::P64;
           P64[Sp + 8] = _sdpGq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqa2; else goto cdq9X;
       udqa2: // global
           call _cdq9T(R1) args: 0, res: 0, upd: 0;
       cdq9X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdq9T() //  [R1]
         { info_tbl: [(cdq9T,
                       label: block_cdq9T_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdq9T: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.List.NonEmpty.$w!!_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.402481453 UTC

[section ""data" . Data.List.NonEmpty.zip_closure" {
     Data.List.NonEmpty.zip_closure:
         const Data.List.NonEmpty.zip_info;
 },
 sat_sdpGM_entry() //  [R1]
         { info_tbl: [(cdqaf,
                       label: sat_sdpGM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqaf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqaj; else goto cdqak;
       cdqaj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqak: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqac_info;
           _sdpGv::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sdpGv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqao; else goto cdqad;
       udqao: // global
           call _cdqac(R1) args: 0, res: 0, upd: 0;
       cdqad: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqac() //  [R1]
         { info_tbl: [(cdqac,
                       label: block_cdqac_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqac: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqan; else goto cdqam;
       cdqan: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqam: // global
           _sdpGH::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 16;
           R2 = _sdpGH::P64;
           Sp = Sp + 16;
           call GHC.List.zip_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.zip_entry() //  [R2, R3]
         { info_tbl: [(cdqat,
                       label: Data.List.NonEmpty.zip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqat: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cdqax; else goto cdqaw;
       cdqax: // global
           HpAlloc = 128;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.zip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqaw: // global
           I64[Hp - 120] = sat_sdpGM_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = stg_sel_0_upd_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 120;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.404810621 UTC

[section ""data" . Data.List.NonEmpty.zipWith_closure" {
     Data.List.NonEmpty.zipWith_closure:
         const Data.List.NonEmpty.zipWith_info;
 },
 sat_sdpH6_entry() //  [R1]
         { info_tbl: [(cdqaJ,
                       label: sat_sdpH6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqaJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdqaN; else goto cdqaO;
       cdqaN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqaO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdqaG_info;
           _sdpGN::P64 = P64[R1 + 16];
           _sdpGP::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdpGN::P64;
           P64[Sp - 24] = _sdpGP::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udqaS; else goto cdqaH;
       udqaS: // global
           call _cdqaG(R1) args: 0, res: 0, upd: 0;
       cdqaH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqaG() //  [R1]
         { info_tbl: [(cdqaG,
                       label: block_cdqaG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqaG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqaR; else goto cdqaQ;
       cdqaR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqaQ: // global
           _sdpH1::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 16;
           R3 = _sdpH1::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.List.zipWith_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpGY_entry() //  [R1]
         { info_tbl: [(cdqaZ,
                       label: sat_sdpGY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqaZ: // global
           _sdpGY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdqb0; else goto cdqb1;
       cdqb1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdqb3; else goto cdqb2;
       cdqb3: // global
           HpAlloc = 48;
           goto cdqb0;
       cdqb0: // global
           R1 = _sdpGY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqb2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpGY::P64;
           _sdpGN::P64 = P64[_sdpGY::P64 + 16];
           _sdpGO::P64 = P64[_sdpGY::P64 + 24];
           _sdpGP::P64 = P64[_sdpGY::P64 + 32];
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpGP::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdpGO::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _sdpGN::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.zipWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqb5,
                       label: Data.List.NonEmpty.zipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqb5: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdqb9; else goto cdqb8;
       cdqb9: // global
           HpAlloc = 104;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.zipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqb8: // global
           I64[Hp - 96] = sat_sdpH6_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sdpGY_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.40731064 UTC

[section ""data" . Data.List.NonEmpty.unzip_closure" {
     Data.List.NonEmpty.unzip_closure:
         const Data.List.NonEmpty.unzip_info;
 },
 sat_sdpHa_entry() //  [R1]
         { info_tbl: [(cdqbi,
                       label: sat_sdpHa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqbi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdqbj; else goto cdqbk;
       cdqbj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqbk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Tuple.snd_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdpH9_entry() //  [R1]
         { info_tbl: [(cdqbp,
                       label: sat_sdpH9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqbp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdqbq; else goto cdqbr;
       cdqbq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqbr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Tuple.fst_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.unzip_entry() //  [R2, R3]
         { info_tbl: [(cdqbt,
                       label: Data.List.NonEmpty.unzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqbt: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdqbx; else goto cdqbw;
       cdqbx: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqbw: // global
           I64[Hp - 80] = sat_sdpHa_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sdpH9_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.412730454 UTC

[section ""data" . Data.List.NonEmpty.nubBy_closure" {
     Data.List.NonEmpty.nubBy_closure:
         const Data.List.NonEmpty.nubBy_info;
 },
 sat_sdpHi_entry() //  [R1, R2]
         { info_tbl: [(cdqbW,
                       label: sat_sdpHi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqbW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqbX; else goto cdqbY;
       cdqbX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqbY: // global
           I64[Sp - 8] = block_cdqbQ_info;
           R3 = R2;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqbQ() //  [R1]
         { info_tbl: [(cdqbQ,
                       label: block_cdqbQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqbQ: // global
           if (R1 & 7 == 1) goto cdqbT; else goto cdqbU;
       cdqbT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqbU: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpHk_entry() //  [R1]
         { info_tbl: [(cdqc7,
                       label: sat_sdpHk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqc7: // global
           _sdpHk::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cdqc8; else goto cdqc9;
       cdqc9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqcb; else goto cdqca;
       cdqcb: // global
           HpAlloc = 24;
           goto cdqc8;
       cdqc8: // global
           R1 = _sdpHk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqca: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHk::P64;
           _sdpHb::P64 = P64[_sdpHk::P64 + 16];
           _sdpHe::P64 = P64[_sdpHk::P64 + 24];
           _sdpHf::P64 = P64[_sdpHk::P64 + 32];
           I64[Hp - 16] = sat_sdpHi_info;
           P64[Hp - 8] = _sdpHb::P64;
           P64[Hp] = _sdpHe::P64;
           I64[Sp - 32] = block_cdqc5_info;
           R3 = _sdpHf::P64;
           R2 = Hp - 15;
           P64[Sp - 24] = _sdpHb::P64;
           Sp = Sp - 32;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqc5() //  [R1]
         { info_tbl: [(cdqc5,
                       label: block_cdqc5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqc5: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.OldList.nubBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.nubBy_entry() //  [R2, R3]
         { info_tbl: [(cdqcf,
                       label: Data.List.NonEmpty.nubBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqcf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqch; else goto cdqci;
       cdqch: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.nubBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqci: // global
           I64[Sp - 16] = block_cdqbC_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqcm; else goto cdqbD;
       udqcm: // global
           call _cdqbC(R1) args: 0, res: 0, upd: 0;
       cdqbD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqbC() //  [R1]
         { info_tbl: [(cdqbC,
                       label: block_cdqbC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqbC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqcl; else goto cdqck;
       cdqcl: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqck: // global
           _sdpHe::P64 = P64[R1 + 7];
           _sdpHf::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdpHk_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sdpHe::P64;
           P64[Hp - 24] = _sdpHf::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpHe::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.415872925 UTC

[section ""data" . Data.List.NonEmpty.nub_closure" {
     Data.List.NonEmpty.nub_closure:
         const Data.List.NonEmpty.nub_info;
 },
 w_sdpHq_entry() //  [R1]
         { info_tbl: [(cdqcE,
                       label: w_sdpHq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqcE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqcF; else goto cdqcG;
       cdqcF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqcG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpHt_entry() //  [R1, R2]
         { info_tbl: [(cdqcS,
                       label: sat_sdpHt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqcS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqcT; else goto cdqcU;
       cdqcT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqcU: // global
           I64[Sp - 8] = block_cdqcM_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqcM() //  [R1]
         { info_tbl: [(cdqcM,
                       label: block_cdqcM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqcM: // global
           if (R1 & 7 == 1) goto cdqcP; else goto cdqcQ;
       cdqcP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqcQ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpHv_entry() //  [R1]
         { info_tbl: [(cdqd3,
                       label: sat_sdpHv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqd3: // global
           _sdpHv::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cdqd4; else goto cdqd5;
       cdqd5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdqd7; else goto cdqd6;
       cdqd7: // global
           HpAlloc = 48;
           goto cdqd4;
       cdqd4: // global
           R1 = _sdpHv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqd6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHv::P64;
           _sdpHl::P64 = P64[_sdpHv::P64 + 16];
           _sdpHo::P64 = P64[_sdpHv::P64 + 24];
           _sdpHp::P64 = P64[_sdpHv::P64 + 32];
           I64[Hp - 40] = w_sdpHq_info;
           P64[Hp - 24] = _sdpHl::P64;
           I64[Hp - 16] = sat_sdpHt_info;
           P64[Hp - 8] = _sdpHo::P64;
           _cdqcA::P64 = Hp - 40;
           P64[Hp] = _cdqcA::P64;
           I64[Sp - 32] = block_cdqd1_info;
           R3 = _sdpHp::P64;
           R2 = Hp - 15;
           P64[Sp - 24] = _cdqcA::P64;
           Sp = Sp - 32;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqd1() //  [R1]
         { info_tbl: [(cdqd1,
                       label: block_cdqd1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqd1: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.OldList.nubBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.nub_entry() //  [R2, R3]
         { info_tbl: [(cdqdb,
                       label: Data.List.NonEmpty.nub_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqdb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqdd; else goto cdqde;
       cdqdd: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.nub_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqde: // global
           I64[Sp - 16] = block_cdqcr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqdi; else goto cdqcs;
       udqdi: // global
           call _cdqcr(R1) args: 0, res: 0, upd: 0;
       cdqcs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqcr() //  [R1]
         { info_tbl: [(cdqcr,
                       label: block_cdqcr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqcr: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqdh; else goto cdqdg;
       cdqdh: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqdg: // global
           _sdpHo::P64 = P64[R1 + 7];
           _sdpHp::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdpHv_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sdpHo::P64;
           P64[Hp - 24] = _sdpHp::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpHo::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.418649469 UTC

[section ""cstring" . Data.List.NonEmpty.$trModule4_bytes" {
     Data.List.NonEmpty.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.419334791 UTC

[section ""data" . Data.List.NonEmpty.$trModule3_closure" {
     Data.List.NonEmpty.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.NonEmpty.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.419953011 UTC

[section ""cstring" . Data.List.NonEmpty.$trModule2_bytes" {
     Data.List.NonEmpty.$trModule2_bytes:
         I8[] [68,97,116,97,46,76,105,115,116,46,78,111,110,69,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.42067258 UTC

[section ""data" . Data.List.NonEmpty.$trModule1_closure" {
     Data.List.NonEmpty.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.NonEmpty.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.421280934 UTC

[section ""data" . Data.List.NonEmpty.$trModule_closure" {
     Data.List.NonEmpty.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.List.NonEmpty.$trModule3_closure+1;
         const Data.List.NonEmpty.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.422596808 UTC

[section ""data" . Data.List.NonEmpty.groupAllWith_closure" {
     Data.List.NonEmpty.groupAllWith_closure:
         const Data.List.NonEmpty.groupAllWith_info;
         const 0;
 },
 sat_sdpHE_entry() //  [R1, R2, R3]
         { info_tbl: [(cdqdy,
                       label: sat_sdpHE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqdy: // global
           _sdpHB::P64 = R3;
           _sdpHA::P64 = R2;
           _sdpHE::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqdz; else goto cdqdA;
       cdqdA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqdC; else goto cdqdB;
       cdqdC: // global
           HpAlloc = 64;
           goto cdqdz;
       cdqdz: // global
           R3 = _sdpHB::P64;
           R2 = _sdpHA::P64;
           R1 = _sdpHE::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqdB: // global
           _sdpHw::P64 = P64[_sdpHE::P64 + 6];
           _sdpHx::P64 = P64[_sdpHE::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdpHx::P64;
           P64[Hp - 32] = _sdpHB::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpHx::P64;
           P64[Hp] = _sdpHA::P64;
           R2 = _sdpHw::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdpHF_entry() //  [R1]
         { info_tbl: [(cdqdD,
                       label: sat_sdpHF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqdD: // global
           _sdpHF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdqdE; else goto cdqdF;
       cdqdF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqdH; else goto cdqdG;
       cdqdH: // global
           HpAlloc = 24;
           goto cdqdE;
       cdqdE: // global
           R1 = _sdpHF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqdG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHF::P64;
           _sdpHw::P64 = P64[_sdpHF::P64 + 16];
           _sdpHx::P64 = P64[_sdpHF::P64 + 24];
           _sdpHy::P64 = P64[_sdpHF::P64 + 32];
           I64[Hp - 16] = sat_sdpHE_info;
           P64[Hp - 8] = _sdpHw::P64;
           P64[Hp] = _sdpHx::P64;
           R3 = _sdpHy::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call Data.OldList.sortBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpHz_entry() //  [R1]
         { info_tbl: [(cdqdM,
                       label: sat_sdpHz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqdM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqdN; else goto cdqdO;
       cdqdN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqdO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupAllWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqdP,
                       label: Data.List.NonEmpty.groupAllWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqdP: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqdT; else goto cdqdS;
       cdqdT: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupAllWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqdS: // global
           I64[Hp - 56] = sat_sdpHF_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sdpHz_info;
           P64[Hp] = R2;
           R5 = Hp - 56;
           R4 = R3;
           R3 = Hp - 16;
           R2 = Data.Foldable.$fFoldable[]_closure;
           call Data.List.NonEmpty.groupWith_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.425376022 UTC

[section ""data" . Data.List.NonEmpty.groupBy1_closure" {
     Data.List.NonEmpty.groupBy1_closure:
         const Data.List.NonEmpty.groupBy1_info;
 },
 ds_sdpHL_entry() //  [R1]
         { info_tbl: [(cdqeb,
                       label: ds_sdpHL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqeb: // global
           _sdpHL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqec; else goto cdqed;
       cdqed: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqef; else goto cdqee;
       cdqef: // global
           HpAlloc = 32;
           goto cdqec;
       cdqec: // global
           R1 = _sdpHL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqee: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHL::P64;
           _sdpHG::P64 = P64[_sdpHL::P64 + 16];
           _sdpHJ::P64 = P64[_sdpHL::P64 + 24];
           _sdpHK::P64 = P64[_sdpHL::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpHG::P64;
           P64[Hp] = _sdpHJ::P64;
           I64[Sp - 24] = block_cdqe8_info;
           R3 = _sdpHK::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqe8() //  [R1, R2]
         { info_tbl: [(cdqe8,
                       label: block_cdqe8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqe8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqei; else goto cdqeh;
       cdqei: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqeh: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpHY_entry() //  [R1]
         { info_tbl: [(cdqeq,
                       label: sat_sdpHY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqeq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqer; else goto cdqes;
       cdqer: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqes: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqen_info;
           _sdpHG::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpHG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqew; else goto cdqeo;
       udqew: // global
           call _cdqen(R1) args: 0, res: 0, upd: 0;
       cdqeo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqen() //  [R1]
         { info_tbl: [(cdqen,
                       label: block_cdqen_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqen: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy1_entry() //  [R2, R3]
         { info_tbl: [(cdqex,
                       label: Data.List.NonEmpty.groupBy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqex: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqeB; else goto cdqeC;
       cdqeB: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqeC: // global
           I64[Sp - 16] = block_cdqdY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqeG; else goto cdqdZ;
       udqeG: // global
           call _cdqdY(R1) args: 0, res: 0, upd: 0;
       cdqdZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqdY() //  [R1]
         { info_tbl: [(cdqdY,
                       label: block_cdqdY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqdY: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdqeF; else goto cdqeE;
       cdqeF: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqeE: // global
           _sdpHJ::P64 = P64[R1 + 7];
           _sdpHK::P64 = P64[R1 + 15];
           I64[Hp - 136] = ds_sdpHL_info;
           _sdpHG::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdpHG::P64;
           P64[Hp - 112] = _sdpHJ::P64;
           P64[Hp - 104] = _sdpHK::P64;
           I64[Hp - 96] = sat_sdpHY_info;
           P64[Hp - 80] = _sdpHG::P64;
           _cdqe3::P64 = Hp - 136;
           P64[Hp - 72] = _cdqe3::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdqe3::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpHJ::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.428597829 UTC

[section ""data" . Data.List.NonEmpty.group1_closure" {
     Data.List.NonEmpty.group1_closure:
         const Data.List.NonEmpty.group1_info;
 },
 w_sdpI4_entry() //  [R1]
         { info_tbl: [(cdqeU,
                       label: w_sdpI4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqeU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqeV; else goto cdqeW;
       cdqeV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqeW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sdpI5_entry() //  [R1]
         { info_tbl: [(cdqf5,
                       label: ds_sdpI5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqf5: // global
           _sdpI5::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqf6; else goto cdqf7;
       cdqf7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqf9; else goto cdqf8;
       cdqf9: // global
           HpAlloc = 32;
           goto cdqf6;
       cdqf6: // global
           R1 = _sdpI5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqf8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpI5::P64;
           _sdpI2::P64 = P64[_sdpI5::P64 + 16];
           _sdpI3::P64 = P64[_sdpI5::P64 + 24];
           _sdpI4::P64 = P64[_sdpI5::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpI4::P64;
           P64[Hp] = _sdpI2::P64;
           I64[Sp - 24] = block_cdqf2_info;
           R3 = _sdpI3::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqf2() //  [R1, R2]
         { info_tbl: [(cdqf2,
                       label: block_cdqf2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqf2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqfc; else goto cdqfb;
       cdqfc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqfb: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpIi_entry() //  [R1]
         { info_tbl: [(cdqfk,
                       label: sat_sdpIi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqfk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqfl; else goto cdqfm;
       cdqfl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqfm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqfh_info;
           _sdpI4::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpI4::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqfq; else goto cdqfi;
       udqfq: // global
           call _cdqfh(R1) args: 0, res: 0, upd: 0;
       cdqfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqfh() //  [R1]
         { info_tbl: [(cdqfh,
                       label: block_cdqfh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqfh: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.group1_entry() //  [R2, R3]
         { info_tbl: [(cdqfr,
                       label: Data.List.NonEmpty.group1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqfr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqfv; else goto cdqfw;
       cdqfv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.group1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqfw: // global
           I64[Sp - 16] = block_cdqeL_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqfA; else goto cdqeM;
       udqfA: // global
           call _cdqeL(R1) args: 0, res: 0, upd: 0;
       cdqeM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqeL() //  [R1]
         { info_tbl: [(cdqeL,
                       label: block_cdqeL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqeL: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdqfz; else goto cdqfy;
       cdqfz: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqfy: // global
           _sdpI2::P64 = P64[R1 + 7];
           _sdpI3::P64 = P64[R1 + 15];
           I64[Hp - 160] = w_sdpI4_info;
           P64[Hp - 144] = P64[Sp + 8];
           I64[Hp - 136] = ds_sdpI5_info;
           P64[Hp - 120] = _sdpI2::P64;
           P64[Hp - 112] = _sdpI3::P64;
           _cdqeQ::P64 = Hp - 160;
           P64[Hp - 104] = _cdqeQ::P64;
           I64[Hp - 96] = sat_sdpIi_info;
           P64[Hp - 80] = _cdqeQ::P64;
           _cdqeX::P64 = Hp - 136;
           P64[Hp - 72] = _cdqeX::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdqeX::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpI2::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.432289109 UTC

[section ""data" . Data.List.NonEmpty.$wgroupWith1_closure" {
     Data.List.NonEmpty.$wgroupWith1_closure:
         const Data.List.NonEmpty.$wgroupWith1_info;
 },
 eq_sdpIn_entry() //  [R1, R2, R3]
         { info_tbl: [(cdqfM,
                       label: eq_sdpIn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqfM: // global
           _sdpIp::P64 = R3;
           _sdpIo::P64 = R2;
           _sdpIn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqfN; else goto cdqfO;
       cdqfO: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqfQ; else goto cdqfP;
       cdqfQ: // global
           HpAlloc = 64;
           goto cdqfN;
       cdqfN: // global
           R3 = _sdpIp::P64;
           R2 = _sdpIo::P64;
           R1 = _sdpIn::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqfP: // global
           _sdpIj::P64 = P64[_sdpIn::P64 + 6];
           _sdpIk::P64 = P64[_sdpIn::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdpIk::P64;
           P64[Hp - 32] = _sdpIp::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpIk::P64;
           P64[Hp] = _sdpIo::P64;
           R2 = _sdpIj::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdpIt_entry() //  [R1, R2]
         { info_tbl: [(cdqg0,
                       label: sat_sdpIt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqg0: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call eq_sdpIn_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdpIs_entry() //  [R1]
         { info_tbl: [(cdqg6,
                       label: ds_sdpIs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqg6: // global
           _sdpIs::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqg7; else goto cdqg8;
       cdqg8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqga; else goto cdqg9;
       cdqga: // global
           HpAlloc = 24;
           goto cdqg7;
       cdqg7: // global
           R1 = _sdpIs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqg9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpIs::P64;
           _sdpIl::P64 = P64[_sdpIs::P64 + 16];
           _sdpIm::P64 = P64[_sdpIs::P64 + 24];
           _sdpIn::P64 = P64[_sdpIs::P64 + 32];
           I64[Hp - 16] = sat_sdpIt_info;
           P64[Hp - 8] = _sdpIl::P64;
           P64[Hp] = _sdpIn::P64;
           I64[Sp - 24] = block_cdqg3_info;
           R3 = _sdpIm::P64;
           R2 = Hp - 15;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqg3() //  [R1, R2]
         { info_tbl: [(cdqg3,
                       label: block_cdqg3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqg3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqgd; else goto cdqgc;
       cdqgd: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqgc: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpIF_entry() //  [R1]
         { info_tbl: [(cdqgl,
                       label: sat_sdpIF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqgl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqgm; else goto cdqgn;
       cdqgm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqgn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqgi_info;
           _sdpIn::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpIn::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqgr; else goto cdqgj;
       udqgr: // global
           call _cdqgi(R1) args: 0, res: 0, upd: 0;
       cdqgj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqgi() //  [R1]
         { info_tbl: [(cdqgi,
                       label: block_cdqgi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqgi: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wgroupWith1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdqgu,
                       label: Data.List.NonEmpty.$wgroupWith1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqgu: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdqgy; else goto cdqgx;
       cdqgy: // global
           HpAlloc = 144;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wgroupWith1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqgx: // global
           I64[Hp - 136] = eq_sdpIn_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = ds_sdpIs_info;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           _cdqfF::P64 = Hp - 134;
           P64[Hp - 80] = _cdqfF::P64;
           I64[Hp - 72] = sat_sdpIF_info;
           P64[Hp - 56] = _cdqfF::P64;
           _cdqfR::P64 = Hp - 112;
           P64[Hp - 48] = _cdqfR::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdqfR::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 40;
           R2 = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.435414579 UTC

[section ""data" . Data.List.NonEmpty.groupWith1_closure" {
     Data.List.NonEmpty.groupWith1_closure:
         const Data.List.NonEmpty.groupWith1_info;
 },
 Data.List.NonEmpty.groupWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqgG,
                       label: Data.List.NonEmpty.groupWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqgG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqgM; else goto cdqgN;
       cdqgM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqgN: // global
           I64[Sp - 24] = block_cdqgD_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqgS; else goto cdqgE;
       udqgS: // global
           call _cdqgD(R1) args: 0, res: 0, upd: 0;
       cdqgE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqgD() //  [R1]
         { info_tbl: [(cdqgD,
                       label: block_cdqgD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqgD: // global
           _sdpIH::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdqgJ_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _sdpIH::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wgroupWith1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqgJ() //  [R1, R2]
         { info_tbl: [(cdqgJ,
                       label: block_cdqgJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqgJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqgR; else goto cdqgQ;
       cdqgR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqgQ: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.437782083 UTC

[section ""data" . Data.List.NonEmpty.$wgroupAllWith1_closure" {
     Data.List.NonEmpty.$wgroupAllWith1_closure:
         const Data.List.NonEmpty.$wgroupAllWith1_info;
         const 0;
 },
 sat_sdpIS_entry() //  [R1, R2, R3]
         { info_tbl: [(cdqh5,
                       label: sat_sdpIS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqh5: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Ord.comparing_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpJ6_entry() //  [R1]
         { info_tbl: [(cdqhh,
                       label: sat_sdpJ6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqhh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqhi; else goto cdqhj;
       cdqhi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqhj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wgroupAllWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqho,
                       label: Data.List.NonEmpty.$wgroupAllWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqho: // global
           _sdpIR::P64 = R4;
           _sdpIQ::P64 = R3;
           _sdpIP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqhp; else goto cdqhq;
       cdqhq: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdqhs; else goto cdqhr;
       cdqhs: // global
           HpAlloc = 96;
           goto cdqhp;
       cdqhp: // global
           R4 = _sdpIR::P64;
           R3 = _sdpIQ::P64;
           R2 = _sdpIP::P64;
           R1 = Data.List.NonEmpty.$wgroupAllWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqhr: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpIR::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpIR::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdpIS_info;
           P64[Hp - 8] = _sdpIP::P64;
           P64[Hp] = _sdpIQ::P64;
           I64[Sp - 24] = block_cdqh8_info;
           R3 = Hp - 38;
           R2 = Hp - 14;
           P64[Sp - 16] = _sdpIP::P64;
           P64[Sp - 8] = _sdpIQ::P64;
           Sp = Sp - 24;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqh8() //  [R1]
         { info_tbl: [(cdqh8,
                       label: block_cdqh8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqh8: // global
           if (R1 & 7 == 1) goto cdqhl; else goto cdqhm;
       cdqhl: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqhm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqhx; else goto cdqhw;
       cdqhx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqhw: // global
           _sdpJ4::P64 = P64[R1 + 6];
           _sdpJ5::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sdpJ6_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdpJ5::P64;
           R4 = _sdpJ4::P64;
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.List.NonEmpty.$wgroupWith1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.440003181 UTC

[section ""data" . Data.List.NonEmpty.groupAllWith1_closure" {
     Data.List.NonEmpty.groupAllWith1_closure:
         const Data.List.NonEmpty.groupAllWith1_info;
         const 0;
 },
 Data.List.NonEmpty.groupAllWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqhF,
                       label: Data.List.NonEmpty.groupAllWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqhF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqhG; else goto cdqhH;
       cdqhG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupAllWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqhH: // global
           I64[Sp - 8] = block_cdqhC_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wgroupAllWith1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqhC() //  [R1, R2]
         { info_tbl: [(cdqhC,
                       label: block_cdqhC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqhC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqhK; else goto cdqhJ;
       cdqhK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqhJ: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.441817113 UTC

[section ""data" . Data.List.NonEmpty.$wxor_closure" {
     Data.List.NonEmpty.$wxor_closure:
         const Data.List.NonEmpty.$wxor_info;
 },
 go_sdpJf_entry() //  [R1, R2]
         { info_tbl: [(cdqi1,
                       label: go_sdpJf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqi1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqi2; else goto udqiz;
       cdqi2: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       udqiz: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cdqhR() args: 0, res: 0, upd: 0;
     }
 },
 _cdqhR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqhR: // global
           _sdpJd::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cdqhU_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdpJd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqiB; else goto cdqhV;
       udqiB: // global
           call _cdqhU(R1) args: 0, res: 0, upd: 0;
       cdqhV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqhU() //  [R1]
         { info_tbl: [(cdqhU,
                       label: block_cdqhU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqhU: // global
           if (R1 & 7 == 1) goto cdqhY; else goto cdqhZ;
       cdqhY: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqhZ: // global
           I64[Sp] = block_cdqi9_info;
           _sdpJj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdpJj::P64;
           if (R1 & 7 != 0) goto udqiC; else goto cdqib;
       udqiC: // global
           call _cdqi9(R1) args: 0, res: 0, upd: 0;
       cdqib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqi9() //  [R1]
         { info_tbl: [(cdqi9,
                       label: block_cdqi9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqi9: // global
           _sdpJj::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdqih; else goto cdqim;
       cdqih: // global
           P64[Sp + 16] = _sdpJj::P64;
           Sp = Sp + 8;
           call _cdqhR() args: 0, res: 0, upd: 0;
       cdqim: // global
           I64[Sp + 16] = block_cdqik_info;
           R2 = _sdpJj::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdpJf_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqik() //  [R1]
         { info_tbl: [(cdqik,
                       label: block_cdqik_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqik: // global
           if (R1 & 7 == 1) goto cdqis; else goto cdqiw;
       cdqis: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqiw: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wxor_entry() //  [R2, R3]
         { info_tbl: [(cdqiF,
                       label: Data.List.NonEmpty.$wxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqiF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdqiJ; else goto cdqiI;
       cdqiJ: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqiI: // global
           I64[Hp - 8] = go_sdpJf_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_sdpJf_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.4439915 UTC

[section ""data" . Data.List.NonEmpty.xor_closure" {
     Data.List.NonEmpty.xor_closure:
         const Data.List.NonEmpty.xor_info;
 },
 Data.List.NonEmpty.xor_entry() //  [R2]
         { info_tbl: [(cdqiR,
                       label: Data.List.NonEmpty.xor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqiR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqiS; else goto cdqiT;
       cdqiS: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.xor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqiT: // global
           I64[Sp - 8] = block_cdqiO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqiX; else goto cdqiP;
       udqiX: // global
           call _cdqiO(R1) args: 0, res: 0, upd: 0;
       cdqiP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqiO() //  [R1]
         { info_tbl: [(cdqiO,
                       label: block_cdqiO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqiO: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.List.NonEmpty.$wxor_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.445339349 UTC

[section ""data" . Data.List.NonEmpty.length_closure" {
     Data.List.NonEmpty.length_closure:
         const Data.List.NonEmpty.length_info;
 },
 Data.List.NonEmpty.length_entry() //  [R2]
         { info_tbl: [(cdqj5,
                       label: Data.List.NonEmpty.length_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqj5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqjg; else goto cdqjh;
       cdqjg: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.length_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqjh: // global
           I64[Sp - 8] = block_cdqj2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqjm; else goto cdqj3;
       udqjm: // global
           call _cdqj2(R1) args: 0, res: 0, upd: 0;
       cdqj3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqj2() //  [R1]
         { info_tbl: [(cdqj2,
                       label: block_cdqj2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqj2: // global
           I64[Sp] = block_cdqj8_info;
           R3 = 0;
           R2 = P64[R1 + 15];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqj8() //  [R1]
         { info_tbl: [(cdqj8,
                       label: block_cdqj8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqj8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdqjl; else goto cdqjk;
       cdqjl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdqjk: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.446592317 UTC

[section ""relreadonly" . SdpN4_srt" {
     SdpN4_srt:
         const GHC.List.lastError_closure;
         const Data.List.NonEmpty.last_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.List.NonEmpty.fromList_closure;
         const Data.List.NonEmpty.cycle1_closure;
         const Data.List.NonEmpty.reverse_closure;
         const Data.List.NonEmpty.sortBy_closure;
         const Data.List.NonEmpty.sortWith_closure;
         const Data.List.NonEmpty.sort_closure;
         const Data.OldList.$winits_closure;
         const Data.List.NonEmpty.inits_closure;
         const Data.List.NonEmpty.tails_closure;
         const GHC.List.scanr1_closure;
         const Data.List.NonEmpty.scanr1_closure;
         const Data.List.NonEmpty.cycle_closure;
         const Data.List.NonEmpty.$wtranspose_closure;
         const Data.List.NonEmpty.transpose_closure;
         const GHC.List.$w!!_closure;
         const Data.List.NonEmpty.!!1_closure;
         const Data.List.NonEmpty.!!_closure;
         const Data.List.NonEmpty.$w!!_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const Data.List.NonEmpty.groupAllWith_closure;
         const Data.List.NonEmpty.$wgroupAllWith1_closure;
         const Data.List.NonEmpty.groupAllWith1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.447358106 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:35.448173389 UTC

[section ""data" . Data.List.NonEmpty.nonEmpty_closure" {
     Data.List.NonEmpty.nonEmpty_closure:
         const Data.List.NonEmpty.nonEmpty_info;
 },
 Data.List.NonEmpty.nonEmpty_entry() //  [R2]
         { info_tbl: [(cdqjy,
                       label: Data.List.NonEmpty.nonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqjy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqjz; else goto cdqjA;
       cdqjz: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.nonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqjA: // global
           I64[Sp - 8] = block_cdqjr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqjL; else goto cdqjs;
       udqjL: // global
           call _cdqjr(R1) args: 0, res: 0, upd: 0;
       cdqjs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqjr() //  [R1]
         { info_tbl: [(cdqjr,
                       label: block_cdqjr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqjr: // global
           if (R1 & 7 == 1) goto cdqjv; else goto cdqjw;
       cdqjv: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqjw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdqjK; else goto cdqjJ;
       cdqjK: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqjJ: // global
           _sdpwy::P64 = P64[R1 + 6];
           _sdpwz::P64 = P64[R1 + 14];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _sdpwy::P64;
           P64[Hp - 16] = _sdpwz::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.449954788 UTC

[section ""data" . Data.List.NonEmpty.uncons_closure" {
     Data.List.NonEmpty.uncons_closure:
         const Data.List.NonEmpty.uncons_info;
 },
 sat_sdpwN_entry() //  [R1]
         { info_tbl: [(cdqjX,
                       label: sat_sdpwN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqjX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqjY; else goto cdqjZ;
       cdqjY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqjZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdqjU_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqkl; else goto cdqjV;
       udqkl: // global
           call _cdqjU(R1) args: 0, res: 0, upd: 0;
       cdqjV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqjU() //  [R1]
         { info_tbl: [(cdqjU,
                       label: block_cdqjU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqjU: // global
           I64[Sp] = block_cdqk2_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto udqkk; else goto cdqk4;
       udqkk: // global
           call _cdqk2(R1) args: 0, res: 0, upd: 0;
       cdqk4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqk2() //  [R1]
         { info_tbl: [(cdqk2,
                       label: block_cdqk2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqk2: // global
           if (R1 & 7 == 1) goto cdqka; else goto cdqkf;
       cdqka: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdqkf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdqki; else goto cdqkh;
       cdqki: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqkh: // global
           _sdpwK::P64 = P64[R1 + 6];
           _sdpwL::P64 = P64[R1 + 14];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _sdpwK::P64;
           P64[Hp - 16] = _sdpwL::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.uncons_entry() //  [R2]
         { info_tbl: [(cdqko,
                       label: Data.List.NonEmpty.uncons_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqko: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqks; else goto cdqkr;
       cdqks: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.uncons_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqkr: // global
           I64[Hp - 64] = sat_sdpwN_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.452680308 UTC

[section ""data" . Data.List.NonEmpty.$wunfoldr_closure" {
     Data.List.NonEmpty.$wunfoldr_closure:
         const Data.List.NonEmpty.$wunfoldr_info;
 },
 sat_sdpx2_entry() //  [R1]
         { info_tbl: [(cdql5,
                       label: sat_sdpx2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdql5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdql6; else goto cdql7;
       cdql6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdql7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqkY_info;
           _sdpwV::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpwV::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqle; else goto cdqkZ;
       udqle: // global
           call _cdqkY(R1) args: 0, res: 0, upd: 0;
       cdqkZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqkY() //  [R1]
         { info_tbl: [(cdqkY,
                       label: block_cdqkY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqkY: // global
           if (R1 & 7 == 1) goto cdql2; else goto cdql3;
       cdql2: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdql3: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdpwV_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sdpwV_entry() //  [R1, R2]
         { info_tbl: [(cdqlf,
                       label: go_sdpwV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqlf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqlh; else goto cdqli;
       cdqlh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqli: // global
           I64[Sp - 16] = block_cdqkQ_info;
           R2 = R2;
           _sdpwV::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdpwV::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqkQ() //  [R1]
         { info_tbl: [(cdqkQ,
                       label: block_cdqkQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqkQ: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdqll; else goto cdqlk;
       cdqll: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqlk: // global
           _sdpwY::P64 = P64[R1 + 7];
           _sdpwZ::P64 = P64[R1 + 15];
           I64[Hp - 48] = sat_sdpx2_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sdpwZ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdpwY::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpx3_entry() //  [R1]
         { info_tbl: [(cdqlq,
                       label: sat_sdpx3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqlq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqlr; else goto cdqls;
       cdqlr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqls: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqkF_info;
           _sdpwO::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpwO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqly; else goto cdqkG;
       udqly: // global
           call _cdqkF(R1) args: 0, res: 0, upd: 0;
       cdqkG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqkF() //  [R1]
         { info_tbl: [(cdqkF,
                       label: block_cdqkF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqkF: // global
           if (R1 & 7 == 1) goto cdqln; else goto cdqlo;
       cdqln: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdqlo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdqlx; else goto cdqlw;
       cdqlx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqlw: // global
           _sdpwU::P64 = P64[R1 + 6];
           I64[Hp - 8] = go_sdpwV_info;
           P64[Hp] = P64[Sp + 8];
           R2 = _sdpwU::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call go_sdpwV_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wunfoldr_entry() //  [R2, R3]
         { info_tbl: [(cdqlz,
                       label: Data.List.NonEmpty.$wunfoldr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqlz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqlA; else goto cdqlB;
       cdqlA: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunfoldr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqlB: // global
           I64[Sp - 16] = block_cdqkx_info;
           _sdpwO::P64 = R2;
           R2 = R3;
           R1 = _sdpwO::P64;
           P64[Sp - 8] = _sdpwO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqkx() //  [R1]
         { info_tbl: [(cdqkx,
                       label: block_cdqkx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqkx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqlE; else goto cdqlD;
       cdqlE: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqlD: // global
           _sdpwR::P64 = P64[R1 + 7];
           _sdpwS::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdpx3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdpwS::P64;
           R2 = Hp - 24;
           R1 = _sdpwR::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.455927392 UTC

[section ""data" . Data.List.NonEmpty.unfoldr_closure" {
     Data.List.NonEmpty.unfoldr_closure:
         const Data.List.NonEmpty.unfoldr_info;
 },
 Data.List.NonEmpty.unfoldr_entry() //  [R2, R3]
         { info_tbl: [(cdqlM,
                       label: Data.List.NonEmpty.unfoldr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqlM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqlN; else goto cdqlO;
       cdqlN: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unfoldr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqlO: // global
           I64[Sp - 8] = block_cdqlJ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wunfoldr_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqlJ() //  [R1, R2]
         { info_tbl: [(cdqlJ,
                       label: block_cdqlJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqlJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqlR; else goto cdqlQ;
       cdqlR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqlQ: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.457138866 UTC

[section ""data" . Data.List.NonEmpty.head_closure" {
     Data.List.NonEmpty.head_closure:
         const Data.List.NonEmpty.head_info;
 },
 Data.List.NonEmpty.head_entry() //  [R2]
         { info_tbl: [(cdqlZ,
                       label: Data.List.NonEmpty.head_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqlZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqm0; else goto cdqm1;
       cdqm0: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.head_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqm1: // global
           I64[Sp - 8] = block_cdqlW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqm5; else goto cdqlX;
       udqm5: // global
           call _cdqlW(R1) args: 0, res: 0, upd: 0;
       cdqlX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqlW() //  [R1]
         { info_tbl: [(cdqlW,
                       label: block_cdqlW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqlW: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.458342246 UTC

[section ""data" . Data.List.NonEmpty.tail_closure" {
     Data.List.NonEmpty.tail_closure:
         const Data.List.NonEmpty.tail_info;
 },
 Data.List.NonEmpty.tail_entry() //  [R2]
         { info_tbl: [(cdqmd,
                       label: Data.List.NonEmpty.tail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqmd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqme; else goto cdqmf;
       cdqme: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.tail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqmf: // global
           I64[Sp - 8] = block_cdqma_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqmj; else goto cdqmb;
       udqmj: // global
           call _cdqma(R1) args: 0, res: 0, upd: 0;
       cdqmb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqma() //  [R1]
         { info_tbl: [(cdqma,
                       label: block_cdqma_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqma: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.45962669 UTC

[section ""data" . poly_go_rdpws_closure" {
     poly_go_rdpws_closure:
         const poly_go_rdpws_info;
 },
 poly_go_rdpws_entry() //  [R2, R3]
         { info_tbl: [(cdqmv,
                       label: poly_go_rdpws_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqmv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqmw; else goto udqmE;
       cdqmw: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_go_rdpws_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udqmE: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdqml() args: 0, res: 0, upd: 0;
     }
 },
 _cdqml() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqml: // global
           _sdpxh::P64 = P64[Sp];
           I64[Sp] = block_cdqmo_info;
           R1 = _sdpxh::P64;
           if (R1 & 7 != 0) goto udqmG; else goto cdqmp;
       udqmG: // global
           call _cdqmo(R1) args: 0, res: 0, upd: 0;
       cdqmp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqmo() //  [R1]
         { info_tbl: [(cdqmo,
                       label: block_cdqmo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqmo: // global
           if (R1 & 7 == 1) goto cdqms; else goto cdqmt;
       cdqms: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdqmt: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cdqml() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.460964732 UTC

[section ""data" . Data.List.NonEmpty.last_closure" {
     Data.List.NonEmpty.last_closure:
         const Data.List.NonEmpty.last_info;
         const 0;
 },
 Data.List.NonEmpty.last_entry() //  [R2]
         { info_tbl: [(cdqmQ,
                       label: Data.List.NonEmpty.last_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqmQ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqmU; else goto cdqmT;
       cdqmU: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.last_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqmT: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = GHC.List.lastError_closure;
           R2 = Hp - 14;
           call poly_go_rdpws_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.462112076 UTC

[section ""data" . Data.List.NonEmpty.init_closure" {
     Data.List.NonEmpty.init_closure:
         const Data.List.NonEmpty.init_info;
 },
 Data.List.NonEmpty.init_entry() //  [R2]
         { info_tbl: [(cdqn2,
                       label: Data.List.NonEmpty.init_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqn2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqn3; else goto cdqn4;
       cdqn3: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.init_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqn4: // global
           I64[Sp - 8] = block_cdqmZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqn8; else goto cdqn0;
       udqn8: // global
           call _cdqmZ(R1) args: 0, res: 0, upd: 0;
       cdqn0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqmZ() //  [R1]
         { info_tbl: [(cdqmZ,
                       label: block_cdqmZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqmZ: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.List.init1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.463299747 UTC

[section ""data" . Data.List.NonEmpty.<|_closure" {
     Data.List.NonEmpty.<|_closure:
         const Data.List.NonEmpty.<|_info;
 },
 Data.List.NonEmpty.<|_entry() //  [R2, R3]
         { info_tbl: [(cdqnh,
                       label: Data.List.NonEmpty.<|_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqnh: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdqnl; else goto cdqnk;
       cdqnl: // global
           HpAlloc = 96;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.<|_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqnk: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 38;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.464341927 UTC

[section ""data" . Data.List.NonEmpty.cons_closure" {
     Data.List.NonEmpty.cons_closure:
         const Data.List.NonEmpty.cons_info;
 },
 Data.List.NonEmpty.cons_entry() //  [R2, R3]
         { info_tbl: [(cdqnq,
                       label: Data.List.NonEmpty.cons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqnq: // global
           R3 = R3;
           R2 = R2;
           call Data.List.NonEmpty.<|_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.465735871 UTC

[section ""data" . Data.List.NonEmpty.$wunfold_closure" {
     Data.List.NonEmpty.$wunfold_closure:
         const Data.List.NonEmpty.$wunfold_info;
 },
 ds1_sdpxS_entry() //  [R1]
         { info_tbl: [(cdqnO,
                       label: ds1_sdpxS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqnO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqnP; else goto cdqnQ;
       cdqnP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqnQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdqnL_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Data.List.NonEmpty.$wunfold_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqnL() //  [R1, R2]
         { info_tbl: [(cdqnL,
                       label: block_cdqnL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqnL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqnT; else goto cdqnS;
       cdqnT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqnS: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wunfold_entry() //  [R2, R3]
         { info_tbl: [(cdqnU,
                       label: Data.List.NonEmpty.$wunfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqnU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqnV; else goto cdqnW;
       cdqnV: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqnW: // global
           I64[Sp - 16] = block_cdqnx_info;
           _sdpxL::P64 = R2;
           R2 = R3;
           R1 = _sdpxL::P64;
           P64[Sp - 8] = _sdpxL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqnx() //  [R1]
         { info_tbl: [(cdqnx,
                       label: block_cdqnx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqnx: // global
           I64[Sp - 8] = block_cdqnB_info;
           _sdpxO::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sdpxO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqoa; else goto cdqnC;
       udqoa: // global
           call _cdqnB(R1) args: 0, res: 0, upd: 0;
       cdqnC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqnB() //  [R1]
         { info_tbl: [(cdqnB,
                       label: block_cdqnB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqnB: // global
           _sdpxO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdqo1; else goto cdqo5;
       cdqo1: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _sdpxO::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdqo5: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdqo8; else goto cdqo7;
       cdqo8: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqo7: // global
           _sdpxR::P64 = P64[R1 + 6];
           I64[Hp - 96] = ds1_sdpxS_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sdpxR::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cdqnH::P64 = Hp - 96;
           P64[Hp - 48] = _cdqnH::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdqnH::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 14;
           R1 = _sdpxO::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.467967404 UTC

[section ""data" . Data.List.NonEmpty.unfold_closure" {
     Data.List.NonEmpty.unfold_closure:
         const Data.List.NonEmpty.unfold_info;
 },
 Data.List.NonEmpty.unfold_entry() //  [R2, R3]
         { info_tbl: [(cdqoi,
                       label: Data.List.NonEmpty.unfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqoi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqoj; else goto cdqok;
       cdqoj: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqok: // global
           I64[Sp - 8] = block_cdqof_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wunfold_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqof() //  [R1, R2]
         { info_tbl: [(cdqof,
                       label: block_cdqof_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqof: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqon; else goto cdqom;
       cdqon: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqom: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.46902473 UTC

[section ""cstring" . lvl_rdpwt_bytes" {
     lvl_rdpwt_bytes:
         I8[] [78,111,110,69,109,112,116,121,46,102,114,111,109,76,105,115,116,58,32,101,109,112,116,121,32,108,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.470078148 UTC

[section ""data" . Data.List.NonEmpty.cycle1_closure" {
     Data.List.NonEmpty.cycle1_closure:
         const Data.List.NonEmpty.cycle1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.List.NonEmpty.cycle1_entry() //  [R1]
         { info_tbl: [(cdqow,
                       label: Data.List.NonEmpty.cycle1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqow: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqox; else goto cdqoy;
       cdqox: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqoy: // global
           (_cdqor::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdqor::I64 == 0) goto cdqot; else goto cdqos;
       cdqot: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdqos: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdqor::I64;
           I64[Sp - 24] = block_cdqou_info;
           R2 = lvl_rdpwt_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqou() //  [R1]
         { info_tbl: [(cdqou,
                       label: block_cdqou_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqou: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.471424312 UTC

[section ""data" . Data.List.NonEmpty.fromList_closure" {
     Data.List.NonEmpty.fromList_closure:
         const Data.List.NonEmpty.fromList_info;
         const 0;
 },
 Data.List.NonEmpty.fromList_entry() //  [R2]
         { info_tbl: [(cdqoN,
                       label: Data.List.NonEmpty.fromList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqoN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqoO; else goto cdqoP;
       cdqoO: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.fromList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqoP: // global
           I64[Sp - 8] = block_cdqoG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqoZ; else goto cdqoH;
       udqoZ: // global
           call _cdqoG(R1) args: 0, res: 0, upd: 0;
       cdqoH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqoG() //  [R1]
         { info_tbl: [(cdqoG,
                       label: block_cdqoG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqoG: // global
           if (R1 & 7 == 1) goto cdqoK; else goto cdqoL;
       cdqoK: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqoL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqoY; else goto cdqoX;
       cdqoY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqoX: // global
           _sdpyd::P64 = P64[R1 + 6];
           _sdpye::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyd::P64;
           P64[Hp] = _sdpye::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.472952891 UTC

[section ""data" . Data.List.NonEmpty.reverse_closure" {
     Data.List.NonEmpty.reverse_closure:
         const Data.List.NonEmpty.reverse_info;
         const 0;
 },
 Data.List.NonEmpty.reverse_entry() //  [R2]
         { info_tbl: [(cdqpd,
                       label: Data.List.NonEmpty.reverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqpd: // global
           _sdpyf::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdqpe; else goto cdqpf;
       cdqpf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqph; else goto cdqpg;
       cdqph: // global
           HpAlloc = 72;
           goto cdqpe;
       cdqpe: // global
           R2 = _sdpyf::P64;
           R1 = Data.List.NonEmpty.reverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqpg: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpyf::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpyf::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdqp7_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp - 8;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqp7() //  [R1]
         { info_tbl: [(cdqp7,
                       label: block_cdqp7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqp7: // global
           if (R1 & 7 == 1) goto cdqpa; else goto cdqpb;
       cdqpa: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqpb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqpq; else goto cdqpp;
       cdqpq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqpp: // global
           _sdpyr::P64 = P64[R1 + 6];
           _sdpys::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyr::P64;
           P64[Hp] = _sdpys::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.474687505 UTC

[section ""data" . Data.List.NonEmpty.sortBy_closure" {
     Data.List.NonEmpty.sortBy_closure:
         const Data.List.NonEmpty.sortBy_info;
         const 0;
 },
 Data.List.NonEmpty.sortBy_entry() //  [R2, R3]
         { info_tbl: [(cdqpE,
                       label: Data.List.NonEmpty.sortBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqpE: // global
           _sdpyu::P64 = R3;
           _sdpyt::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdqpF; else goto cdqpG;
       cdqpG: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqpI; else goto cdqpH;
       cdqpI: // global
           HpAlloc = 72;
           goto cdqpF;
       cdqpF: // global
           R3 = _sdpyu::P64;
           R2 = _sdpyt::P64;
           R1 = Data.List.NonEmpty.sortBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqpH: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpyu::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpyu::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdqpy_info;
           R3 = Hp - 14;
           R2 = _sdpyt::P64;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqpy() //  [R1]
         { info_tbl: [(cdqpy,
                       label: block_cdqpy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqpy: // global
           if (R1 & 7 == 1) goto cdqpB; else goto cdqpC;
       cdqpB: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqpC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqpR; else goto cdqpQ;
       cdqpR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqpQ: // global
           _sdpyF::P64 = P64[R1 + 6];
           _sdpyG::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyF::P64;
           P64[Hp] = _sdpyG::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.476509262 UTC

[section ""data" . Data.List.NonEmpty.sortWith_closure" {
     Data.List.NonEmpty.sortWith_closure:
         const Data.List.NonEmpty.sortWith_info;
         const 0;
 },
 sat_sdpyK_entry() //  [R1, R2, R3]
         { info_tbl: [(cdqq4,
                       label: sat_sdpyK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqq4: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Ord.comparing_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.sortWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqqd,
                       label: Data.List.NonEmpty.sortWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqqd: // global
           _sdpyJ::P64 = R4;
           _sdpyI::P64 = R3;
           _sdpyH::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdqqe; else goto cdqqf;
       cdqqf: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdqqh; else goto cdqqg;
       cdqqh: // global
           HpAlloc = 96;
           goto cdqqe;
       cdqqe: // global
           R4 = _sdpyJ::P64;
           R3 = _sdpyI::P64;
           R2 = _sdpyH::P64;
           R1 = Data.List.NonEmpty.sortWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqqg: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpyJ::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpyJ::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdpyK_info;
           P64[Hp - 8] = _sdpyH::P64;
           P64[Hp] = _sdpyI::P64;
           I64[Sp - 8] = block_cdqq7_info;
           R3 = Hp - 38;
           R2 = Hp - 14;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqq7() //  [R1]
         { info_tbl: [(cdqq7,
                       label: block_cdqq7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqq7: // global
           if (R1 & 7 == 1) goto cdqqa; else goto cdqqb;
       cdqqa: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqqb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqqq; else goto cdqqp;
       cdqqq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqqp: // global
           _sdpyW::P64 = P64[R1 + 6];
           _sdpyX::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyW::P64;
           P64[Hp] = _sdpyX::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.478592915 UTC

[section ""data" . Data.List.NonEmpty.sort_closure" {
     Data.List.NonEmpty.sort_closure:
         const Data.List.NonEmpty.sort_info;
         const 0;
 },
 sat_sdpz0_entry() //  [R1]
         { info_tbl: [(cdqqC,
                       label: sat_sdpz0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqqC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqqD; else goto cdqqE;
       cdqqD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqqE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.sort_entry() //  [R2, R3]
         { info_tbl: [(cdqqL,
                       label: Data.List.NonEmpty.sort_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqqL: // global
           _sdpyZ::P64 = R3;
           _sdpyY::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdqqM; else goto cdqqN;
       cdqqN: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdqqP; else goto cdqqO;
       cdqqP: // global
           HpAlloc = 96;
           goto cdqqM;
       cdqqM: // global
           R3 = _sdpyZ::P64;
           R2 = _sdpyY::P64;
           R1 = Data.List.NonEmpty.sort_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqqO: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpyZ::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpyZ::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdpz0_info;
           P64[Hp] = _sdpyY::P64;
           I64[Sp - 8] = block_cdqqF_info;
           R3 = Hp - 38;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqqF() //  [R1]
         { info_tbl: [(cdqqF,
                       label: block_cdqqF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqqF: // global
           if (R1 & 7 == 1) goto cdqqI; else goto cdqqJ;
       cdqqI: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqqJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqqY; else goto cdqqX;
       cdqqY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqqX: // global
           _sdpzc::P64 = P64[R1 + 6];
           _sdpzd::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpzc::P64;
           P64[Hp] = _sdpzd::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.480540964 UTC

[section ""data" . Data.List.NonEmpty.inits_closure" {
     Data.List.NonEmpty.inits_closure:
         const Data.List.NonEmpty.inits_info;
         const 0;
 },
 sat_sdpzg_entry() //  [R1]
         { info_tbl: [(cdqr7,
                       label: sat_sdpzg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqr7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqr8; else goto cdqr9;
       cdqr8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqr9: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Foldable.toList_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.inits_entry() //  [R2, R3]
         { info_tbl: [(cdqrd,
                       label: Data.List.NonEmpty.inits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqrd: // global
           _sdpzf::P64 = R3;
           _sdpze::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdqre; else goto cdqrf;
       cdqrf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqrh; else goto cdqrg;
       cdqrh: // global
           HpAlloc = 32;
           goto cdqre;
       cdqre: // global
           R3 = _sdpzf::P64;
           R2 = _sdpze::P64;
           R1 = Data.List.NonEmpty.inits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqrg: // global
           I64[Hp - 24] = sat_sdpzg_info;
           P64[Hp - 8] = _sdpze::P64;
           P64[Hp] = _sdpzf::P64;
           I64[Sp - 8] = block_cdqra_info;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call Data.OldList.$winits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqra() //  [R1, R2]
         { info_tbl: [(cdqra,
                       label: block_cdqra_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqra: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqrk; else goto cdqrj;
       cdqrk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqrj: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.482371475 UTC

[section ""data" . Data.List.NonEmpty.tails1_closure" {
     Data.List.NonEmpty.tails1_closure:
         const Data.List.NonEmpty.tails1_info;
 },
 sat_sdpzo_entry() //  [R1]
         { info_tbl: [(cdqrA,
                       label: sat_sdpzo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqrA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqrB; else goto cdqrC;
       cdqrB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqrC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdqrt_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqrJ; else goto cdqru;
       udqrJ: // global
           call _cdqrt(R1) args: 0, res: 0, upd: 0;
       cdqru: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqrt() //  [R1]
         { info_tbl: [(cdqrt,
                       label: block_cdqrt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqrt: // global
           if (R1 & 7 == 1) goto cdqrx; else goto cdqry;
       cdqrx: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdqry: // global
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call Data.List.NonEmpty.tails1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.tails1_entry() //  [R2]
         { info_tbl: [(cdqrL,
                       label: Data.List.NonEmpty.tails1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqrL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdqrP; else goto cdqrO;
       cdqrP: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.List.NonEmpty.tails1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqrO: // global
           I64[Hp - 40] = sat_sdpzo_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.484130877 UTC

[section ""data" . Data.List.NonEmpty.tails_closure" {
     Data.List.NonEmpty.tails_closure:
         const Data.List.NonEmpty.tails_info;
         const 0;
 },
 sat_sdpzr_entry() //  [R1]
         { info_tbl: [(cdqrY,
                       label: sat_sdpzr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqrY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqrZ; else goto cdqs0;
       cdqrZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqs0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Foldable.toList_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.tails_entry() //  [R2, R3]
         { info_tbl: [(cdqs7,
                       label: Data.List.NonEmpty.tails_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqs7: // global
           _sdpzq::P64 = R3;
           _sdpzp::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdqs8; else goto cdqs9;
       cdqs9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqsb; else goto cdqsa;
       cdqsb: // global
           HpAlloc = 32;
           goto cdqs8;
       cdqs8: // global
           R3 = _sdpzq::P64;
           R2 = _sdpzp::P64;
           R1 = Data.List.NonEmpty.tails_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqsa: // global
           I64[Hp - 24] = sat_sdpzr_info;
           P64[Hp - 8] = _sdpzp::P64;
           P64[Hp] = _sdpzq::P64;
           I64[Sp - 8] = block_cdqs1_info;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call Data.List.NonEmpty.tails1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqs1() //  [R1]
         { info_tbl: [(cdqs1,
                       label: block_cdqs1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqs1: // global
           if (R1 & 7 == 1) goto cdqs4; else goto cdqs5;
       cdqs4: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqs5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqsk; else goto cdqsj;
       cdqsk: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqsj: // global
           _sdpzu::P64 = P64[R1 + 6];
           _sdpzv::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpzu::P64;
           P64[Hp] = _sdpzv::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.486140369 UTC

[section ""data" . Data.List.NonEmpty.insert_closure" {
     Data.List.NonEmpty.insert_closure:
         const Data.List.NonEmpty.insert_info;
 },
 sat_sdpzA_entry() //  [R1]
         { info_tbl: [(cdqsx,
                       label: sat_sdpzA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqsx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqsy; else goto cdqsz;
       cdqsy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqsz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.insert_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdqsA,
                       label: Data.List.NonEmpty.insert_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqsA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdqsE; else goto cdqsF;
       cdqsE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.insert_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqsF: // global
           I64[Sp - 24] = block_cdqsp_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdqsp() //  [R1]
         { info_tbl: [(cdqsp,
                       label: block_cdqsp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqsp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqsI; else goto cdqsH;
       cdqsI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqsH: // global
           I64[Hp - 16] = sat_sdpzA_info;
           P64[Hp] = P64[Sp + 8];
           _sdpzy::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdqsB_info;
           R4 = R1;
           R3 = _sdpzy::P64;
           R2 = Hp - 16;
           Sp = Sp + 16;
           call Data.OldList.$winsertBy_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqsB() //  [R1, R2]
         { info_tbl: [(cdqsB,
                       label: block_cdqsB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqsB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqsL; else goto cdqsK;
       cdqsL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqsK: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.491100186 UTC

[section ""data" . Data.List.NonEmpty.scanl_closure" {
     Data.List.NonEmpty.scanl_closure:
         const Data.List.NonEmpty.scanl_info;
 },
 sat_sdpzJ_entry() //  [R1]
         { info_tbl: [(cdqsY,
                       label: sat_sdpzJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqsY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqsZ; else goto cdqt0;
       cdqsZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqt0: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Foldable.toList_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdpzN_entry() //  [R1]
         { info_tbl: [(cdqt3,
                       label: sat_sdpzN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqt3: // global
           _sdpzN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqt4; else goto cdqt5;
       cdqt5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqt7; else goto cdqt6;
       cdqt7: // global
           HpAlloc = 32;
           goto cdqt4;
       cdqt4: // global
           R1 = _sdpzN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqt6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpzN::P64;
           _sdpzF::P64 = P64[_sdpzN::P64 + 16];
           _sdpzG::P64 = P64[_sdpzN::P64 + 24];
           _sdpzH::P64 = P64[_sdpzN::P64 + 32];
           _sdpzI::P64 = P64[_sdpzN::P64 + 40];
           I64[Hp - 24] = sat_sdpzJ_info;
           P64[Hp - 8] = _sdpzF::P64;
           P64[Hp] = _sdpzI::P64;
           I64[Sp - 24] = block_cdqt1_info;
           R4 = Hp - 24;
           R3 = _sdpzH::P64;
           R2 = _sdpzG::P64;
           Sp = Sp - 24;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqt1() //  [R2]
         { info_tbl: [(cdqt1,
                       label: block_cdqt1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqt1: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.scanl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdqta,
                       label: Data.List.NonEmpty.scanl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqta: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqte; else goto cdqtd;
       cdqte: // global
           HpAlloc = 72;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqtd: // global
           I64[Hp - 64] = sat_sdpzN_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.493058701 UTC

[section ""data" . Data.List.NonEmpty.scanr_closure" {
     Data.List.NonEmpty.scanr_closure:
         const Data.List.NonEmpty.scanr_info;
 },
 Data.List.NonEmpty.scanr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdqtl,
                       label: Data.List.NonEmpty.scanr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqtl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdqtr; else goto cdqts;
       cdqtr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqts: // global
           I64[Sp - 24] = block_cdqtj_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdqtj() //  [R1]
         { info_tbl: [(cdqtj,
                       label: block_cdqtj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqtj: // global
           _sdpzQ::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdqto_info;
           R4 = R1;
           R3 = _sdpzQ::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqto() //  [R1, R2]
         { info_tbl: [(cdqto,
                       label: block_cdqto_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqto: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqtw; else goto cdqtv;
       cdqtw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqtv: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.494809276 UTC

[section ""data" . Data.List.NonEmpty.scanl1_closure" {
     Data.List.NonEmpty.scanl1_closure:
         const Data.List.NonEmpty.scanl1_info;
 },
 sat_sdpA8_entry() //  [R1]
         { info_tbl: [(cdqtJ,
                       label: sat_sdpA8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqtJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdqtN; else goto cdqtO;
       cdqtN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqtO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdqtG_info;
           _sdpzW::P64 = P64[R1 + 16];
           _sdpzY::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdpzW::P64;
           P64[Sp - 24] = _sdpzY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udqtS; else goto cdqtH;
       udqtS: // global
           call _cdqtG(R1) args: 0, res: 0, upd: 0;
       cdqtH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqtG() //  [R1]
         { info_tbl: [(cdqtG,
                       label: block_cdqtG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqtG: // global
           _sdpzY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdqtM_info;
           R4 = P64[R1 + 15];
           R3 = _sdpzY::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqtM() //  [R2]
         { info_tbl: [(cdqtM,
                       label: block_cdqtM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqtM: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.scanl1_entry() //  [R2, R3]
         { info_tbl: [(cdqtU,
                       label: Data.List.NonEmpty.scanl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqtU: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdqtY; else goto cdqtX;
       cdqtY: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqtX: // global
           I64[Hp - 80] = stg_sel_0_upd_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sdpA8_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           _cdqtB::P64 = Hp - 80;
           P64[Hp - 24] = _cdqtB::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _cdqtB::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.496705059 UTC

[section ""data" . Data.List.NonEmpty.scanr1_closure" {
     Data.List.NonEmpty.scanr1_closure:
         const Data.List.NonEmpty.scanr1_info;
         const 0;
 },
 Data.List.NonEmpty.scanr1_entry() //  [R2, R3]
         { info_tbl: [(cdquc,
                       label: Data.List.NonEmpty.scanr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdquc: // global
           _sdpAa::P64 = R3;
           _sdpA9::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdqud; else goto cdque;
       cdque: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqug; else goto cdquf;
       cdqug: // global
           HpAlloc = 72;
           goto cdqud;
       cdqud: // global
           R3 = _sdpAa::P64;
           R2 = _sdpA9::P64;
           R1 = Data.List.NonEmpty.scanr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdquf: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpAa::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpAa::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdqu6_info;
           R3 = Hp - 14;
           R2 = _sdpA9::P64;
           Sp = Sp - 8;
           call GHC.List.scanr1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqu6() //  [R1]
         { info_tbl: [(cdqu6,
                       label: block_cdqu6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqu6: // global
           if (R1 & 7 == 1) goto cdqu9; else goto cdqua;
       cdqu9: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqua: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqup; else goto cdquo;
       cdqup: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdquo: // global
           _sdpAl::P64 = P64[R1 + 6];
           _sdpAm::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpAl::P64;
           P64[Hp] = _sdpAm::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.498252834 UTC

[section ""data" . Data.List.NonEmpty.toList_closure" {
     Data.List.NonEmpty.toList_closure:
         const Data.List.NonEmpty.toList_info;
 },
 Data.List.NonEmpty.toList_entry() //  [R2]
         { info_tbl: [(cdqux,
                       label: Data.List.NonEmpty.toList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqux: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdquB; else goto cdquA;
       cdquB: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.toList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdquA: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.499386622 UTC

[section ""data" . Data.List.NonEmpty.$wtake_closure" {
     Data.List.NonEmpty.$wtake_closure:
         const Data.List.NonEmpty.$wtake_info;
 },
 Data.List.NonEmpty.$wtake_entry() //  [R2, R3]
         { info_tbl: [(cdquL,
                       label: Data.List.NonEmpty.$wtake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdquL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdquP; else goto cdquO;
       cdquP: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wtake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdquO: // global
           if (%MO_S_Ge_W64(0, R2)) goto cdquJ; else goto cdquK;
       cdquJ: // global
           Hp = Hp - 72;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdquK: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.500564803 UTC

[section ""data" . Data.List.NonEmpty.take_closure" {
     Data.List.NonEmpty.take_closure:
         const Data.List.NonEmpty.take_info;
 },
 Data.List.NonEmpty.take_entry() //  [R2, R3]
         { info_tbl: [(cdqv2,
                       label: Data.List.NonEmpty.take_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqv2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqv3; else goto cdqv4;
       cdqv3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.take_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqv4: // global
           I64[Sp - 16] = block_cdquZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqv8; else goto cdqv0;
       udqv8: // global
           call _cdquZ(R1) args: 0, res: 0, upd: 0;
       cdqv0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdquZ() //  [R1]
         { info_tbl: [(cdquZ,
                       label: block_cdquZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdquZ: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wtake_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.502264968 UTC

[section ""data" . Data.List.NonEmpty.$wunsafeDrop_closure" {
     Data.List.NonEmpty.$wunsafeDrop_closure:
         const Data.List.NonEmpty.$wunsafeDrop_info;
 },
 Data.List.NonEmpty.$wunsafeDrop_entry() //  [R2, R3]
         { info_tbl: [(cdqvk,
                       label: Data.List.NonEmpty.$wunsafeDrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqvk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqvl; else goto udqvz;
       cdqvl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunsafeDrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udqvz: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdqva() args: 0, res: 0, upd: 0;
     }
 },
 _cdqva() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqva: // global
           I64[Sp - 8] = block_cdqvd_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqvB; else goto cdqve;
       udqvB: // global
           call _cdqvd(R1) args: 0, res: 0, upd: 0;
       cdqve: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqvd() //  [R1]
         { info_tbl: [(cdqvd,
                       label: block_cdqvd_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqvd: // global
           if (R1 & 7 == 1) goto cdqvh; else goto cdqvi;
       cdqvh: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqvi: // global
           _sdpAQ::P64 = P64[R1 + 14];
           _sdpAR::I64 = I64[Sp + 8];
           if (_sdpAR::I64 != 1) goto cdqvv; else goto cdqvw;
       cdqvv: // global
           I64[Sp + 8] = _sdpAR::I64 - 1;
           P64[Sp + 16] = _sdpAQ::P64;
           Sp = Sp + 8;
           call _cdqva() args: 0, res: 0, upd: 0;
       cdqvw: // global
           R1 = _sdpAQ::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.503814102 UTC

[section ""data" . Data.List.NonEmpty.$wdrop_closure" {
     Data.List.NonEmpty.$wdrop_closure:
         const Data.List.NonEmpty.$wdrop_info;
 },
 Data.List.NonEmpty.$wdrop_entry() //  [R2, R3]
         { info_tbl: [(cdqvN,
                       label: Data.List.NonEmpty.$wdrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqvN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqvR; else goto cdqvQ;
       cdqvR: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wdrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqvQ: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cdqvL; else goto cdqvM;
       cdqvL: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call Data.List.NonEmpty.$wunsafeDrop_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
       cdqvM: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.50506151 UTC

[section ""data" . Data.List.NonEmpty.drop_closure" {
     Data.List.NonEmpty.drop_closure:
         const Data.List.NonEmpty.drop_info;
 },
 Data.List.NonEmpty.drop_entry() //  [R2, R3]
         { info_tbl: [(cdqw7,
                       label: Data.List.NonEmpty.drop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqw7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqw8; else goto cdqw9;
       cdqw8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.drop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqw9: // global
           I64[Sp - 16] = block_cdqw4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqwd; else goto cdqw5;
       udqwd: // global
           call _cdqw4(R1) args: 0, res: 0, upd: 0;
       cdqw5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqw4() //  [R1]
         { info_tbl: [(cdqw4,
                       label: block_cdqw4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqw4: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wdrop_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.506578064 UTC

[section ""data" . Data.List.NonEmpty.splitAt_closure" {
     Data.List.NonEmpty.splitAt_closure:
         const Data.List.NonEmpty.splitAt_info;
 },
 Data.List.NonEmpty.splitAt_entry() //  [R2, R3]
         { info_tbl: [(cdqwl,
                       label: Data.List.NonEmpty.splitAt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqwl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqwm; else goto cdqwn;
       cdqwm: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.splitAt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqwn: // global
           I64[Sp - 16] = block_cdqwi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqwN; else goto cdqwj;
       udqwN: // global
           call _cdqwi(R1) args: 0, res: 0, upd: 0;
       cdqwj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqwi() //  [R1]
         { info_tbl: [(cdqwi,
                       label: block_cdqwi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqwi: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdqws; else goto cdqwr;
       cdqws: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqwr: // global
           _sdpBi::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto cdqwD; else goto cdqwM;
       cdqwD: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpBi::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpBi::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           _cdqwy::P64 = Hp - 38;
           Hp = Hp - 24;
           I64[Sp + 8] = block_cdqwz_info;
           R3 = _cdqwy::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
       cdqwM: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpBi::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpBi::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = Hp - 38;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdqwz() //  [R1, R2]
         { info_tbl: [(cdqwz,
                       label: block_cdqwz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqwz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqwG; else goto cdqwF;
       cdqwG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqwF: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.50838036 UTC

[section ""data" . Data.List.NonEmpty.takeWhile_closure" {
     Data.List.NonEmpty.takeWhile_closure:
         const Data.List.NonEmpty.takeWhile_info;
 },
 Data.List.NonEmpty.takeWhile_entry() //  [R2, R3]
         { info_tbl: [(cdqwV,
                       label: Data.List.NonEmpty.takeWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqwV: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqwZ; else goto cdqwY;
       cdqwZ: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.takeWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqwY: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.50946915 UTC

[section ""data" . Data.List.NonEmpty.dropWhile_closure" {
     Data.List.NonEmpty.dropWhile_closure:
         const Data.List.NonEmpty.dropWhile_info;
 },
 Data.List.NonEmpty.dropWhile_entry() //  [R2, R3]
         { info_tbl: [(cdqx7,
                       label: Data.List.NonEmpty.dropWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqx7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqxb; else goto cdqxa;
       cdqxb: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.dropWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqxa: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.dropWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.5106578 UTC

[section ""data" . Data.List.NonEmpty.span_closure" {
     Data.List.NonEmpty.span_closure:
         const Data.List.NonEmpty.span_info;
 },
 Data.List.NonEmpty.span_entry() //  [R2, R3]
         { info_tbl: [(cdqxm,
                       label: Data.List.NonEmpty.span_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqxm: // global
           _sdpC4::P64 = R3;
           _sdpC3::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdqxn; else goto cdqxo;
       cdqxo: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqxq; else goto cdqxp;
       cdqxq: // global
           HpAlloc = 72;
           goto cdqxn;
       cdqxn: // global
           R3 = _sdpC4::P64;
           R2 = _sdpC3::P64;
           R1 = Data.List.NonEmpty.span_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqxp: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpC4::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpC4::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdqxj_info;
           R3 = Hp - 14;
           R2 = _sdpC3::P64;
           Sp = Sp - 8;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqxj() //  [R1, R2]
         { info_tbl: [(cdqxj,
                       label: block_cdqxj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqxj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqxt; else goto cdqxs;
       cdqxt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqxs: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.512250886 UTC

[section ""data" . Data.List.NonEmpty.$wbreak_closure" {
     Data.List.NonEmpty.$wbreak_closure:
         const Data.List.NonEmpty.$wbreak_info;
 },
 sat_sdpCl_entry() //  [R1, R2]
         { info_tbl: [(cdqxM,
                       label: sat_sdpCl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqxM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqxN; else goto cdqxO;
       cdqxN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqxO: // global
           I64[Sp - 8] = block_cdqxG_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqxG() //  [R1]
         { info_tbl: [(cdqxG,
                       label: block_cdqxG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqxG: // global
           if (R1 & 7 == 1) goto cdqxJ; else goto cdqxK;
       cdqxJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqxK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wbreak_entry() //  [R2, R3]
         { info_tbl: [(cdqxV,
                       label: Data.List.NonEmpty.$wbreak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqxV: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdqxZ; else goto cdqxY;
       cdqxZ: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wbreak_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqxY: // global
           I64[Hp - 80] = stg_sel_1_upd_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = stg_sel_0_upd_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           I64[Hp - 8] = sat_sdpCl_info;
           P64[Hp] = R2;
           R3 = Hp - 30;
           R2 = Hp - 7;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.513843942 UTC

[section ""data" . Data.List.NonEmpty.break_closure" {
     Data.List.NonEmpty.break_closure:
         const Data.List.NonEmpty.break_info;
 },
 Data.List.NonEmpty.break_entry() //  [R2, R3]
         { info_tbl: [(cdqy7,
                       label: Data.List.NonEmpty.break_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqy7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqy8; else goto cdqy9;
       cdqy8: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.break_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqy9: // global
           I64[Sp - 8] = block_cdqy4_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wbreak_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqy4() //  [R1, R2]
         { info_tbl: [(cdqy4,
                       label: block_cdqy4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqy4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqyc; else goto cdqyb;
       cdqyc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqyb: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.515119747 UTC

[section ""data" . Data.List.NonEmpty.filter_closure" {
     Data.List.NonEmpty.filter_closure:
         const Data.List.NonEmpty.filter_info;
 },
 Data.List.NonEmpty.filter_entry() //  [R2, R3]
         { info_tbl: [(cdqyk,
                       label: Data.List.NonEmpty.filter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqyk: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqyo; else goto cdqyn;
       cdqyo: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.filter_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqyn: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.517102435 UTC

[section ""data" . Data.List.NonEmpty.$wpartition_closure" {
     Data.List.NonEmpty.$wpartition_closure:
         const Data.List.NonEmpty.$wpartition_info;
 },
 w3_sdpCS_entry() //  [R1]
         { info_tbl: [(cdqyL,
                       label: w3_sdpCS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqyL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqyM; else goto cdqyN;
       cdqyM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqyN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdqyI_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo_sdpCN_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqyI() //  [R1, R2]
         { info_tbl: [(cdqyI,
                       label: block_cdqyI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqyI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqyQ; else goto cdqyP;
       cdqyQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqyP: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_sdpCN_entry() //  [R1, R2]
         { info_tbl: [(cdqyV,
                       label: $wgo_sdpCN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqyV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqyW; else goto cdqyX;
       cdqyW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqyX: // global
           I64[Sp - 24] = block_cdqyy_info;
           _sdpCN::P64 = R1;
           _sdpCL::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdpCL::P64;
           P64[Sp - 8] = _sdpCN::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqzp; else goto cdqyz;
       udqzp: // global
           call _cdqyy(R1) args: 0, res: 0, upd: 0;
       cdqyz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqyy() //  [R1]
         { info_tbl: [(cdqyy,
                       label: block_cdqyy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqyy: // global
           if (R1 & 7 == 1) goto cdqyS; else goto cdqyT;
       cdqyS: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdqyT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqz3; else goto cdqz2;
       cdqz3: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqz2: // global
           _sdpCQ::P64 = P64[R1 + 6];
           _sdpCR::P64 = P64[R1 + 14];
           I64[Hp - 24] = w3_sdpCS_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdpCR::P64;
           I64[Sp] = block_cdqz0_info;
           R2 = _sdpCQ::P64;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdpCQ::P64;
           P64[Sp + 16] = Hp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqz0() //  [R1]
         { info_tbl: [(cdqz0,
                       label: block_cdqz0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqz0: // global
           _cdqyE::P64 = P64[Sp + 16];
           _sdpCQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdqzb; else goto cdqzk;
       cdqzb: // global
           Hp = Hp + 72;
           _sdpCW::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdqzn; else goto cdqzd;
       cdqzd: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cdqyE::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sdpCQ::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cdqyE::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdqzk: // global
           Hp = Hp + 72;
           _sdpCW::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdqzn; else goto cdqzm;
       cdqzn: // global
           HpAlloc = 72;
           R1 = _sdpCW::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqzm: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cdqyE::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdqyE::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdpCQ::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wpartition_entry() //  [R2, R3]
         { info_tbl: [(cdqzt,
                       label: Data.List.NonEmpty.$wpartition_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqzt: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdqzx; else goto cdqzw;
       cdqzx: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wpartition_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqzw: // global
           I64[Hp - 80] = $wgo_sdpCN_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 14;
           R1 = Hp - 79;
           call $wgo_sdpCN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.520076035 UTC

[section ""data" . Data.List.NonEmpty.partition_closure" {
     Data.List.NonEmpty.partition_closure:
         const Data.List.NonEmpty.partition_info;
 },
 Data.List.NonEmpty.partition_entry() //  [R2, R3]
         { info_tbl: [(cdqzF,
                       label: Data.List.NonEmpty.partition_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqzF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqzG; else goto cdqzH;
       cdqzG: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.partition_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqzH: // global
           I64[Sp - 8] = block_cdqzC_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wpartition_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqzC() //  [R1, R2]
         { info_tbl: [(cdqzC,
                       label: block_cdqzC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqzC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqzK; else goto cdqzJ;
       cdqzK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqzJ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.521679541 UTC

[section ""data" . Data.List.NonEmpty.cycle_closure" {
     Data.List.NonEmpty.cycle_closure:
         const Data.List.NonEmpty.cycle_info;
         const 0;
 },
 xs'_sdpDu_entry() //  [R1]
         { info_tbl: [(cdqzW,
                       label: xs'_sdpDu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqzW: // global
           _sdpDu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdqzX; else goto cdqzY;
       cdqzY: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqA0; else goto cdqzZ;
       cdqA0: // global
           HpAlloc = 72;
           goto cdqzX;
       cdqzX: // global
           R1 = _sdpDu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqzZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpDu::P64;
           _sdpDt::P64 = P64[_sdpDu::P64 + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpDt::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpDt::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = _sdpDu::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.cycle_entry() //  [R2]
         { info_tbl: [(cdqA8,
                       label: Data.List.NonEmpty.cycle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqA8: // global
           _sdpDt::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdqA9; else goto cdqAa;
       cdqAa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqAc; else goto cdqAb;
       cdqAc: // global
           HpAlloc = 24;
           goto cdqA9;
       cdqA9: // global
           R2 = _sdpDt::P64;
           R1 = Data.List.NonEmpty.cycle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqAb: // global
           I64[Hp - 16] = xs'_sdpDu_info;
           P64[Hp] = _sdpDt::P64;
           I64[Sp - 8] = block_cdqA1_info;
           R1 = Hp - 16;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqAm; else goto cdqA2;
       udqAm: // global
           call _cdqA1(R1) args: 0, res: 0, upd: 0;
       cdqA2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqA1() //  [R1]
         { info_tbl: [(cdqA1,
                       label: block_cdqA1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqA1: // global
           if (R1 & 7 == 1) goto cdqA5; else goto cdqA6;
       cdqA5: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqA6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqAl; else goto cdqAk;
       cdqAl: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqAk: // global
           _sdpDG::P64 = P64[R1 + 6];
           _sdpDH::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpDG::P64;
           P64[Hp] = _sdpDH::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.525007711 UTC

[section ""data" . Data.List.NonEmpty.$wtranspose_closure" {
     Data.List.NonEmpty.$wtranspose_closure:
         const Data.List.NonEmpty.$wtranspose_info;
         const 0;
 },
 sat_sdpE2_entry() //  [R1]
         { info_tbl: [(cdqAC,
                       label: sat_sdpE2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqAC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqAD; else goto cdqAE;
       cdqAD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqAE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdqAz_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqAI; else goto cdqAA;
       udqAI: // global
           call _cdqAz(R1) args: 0, res: 0, upd: 0;
       cdqAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqAz() //  [R1]
         { info_tbl: [(cdqAz,
                       label: block_cdqAz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqAz: // global
           R3 = P64[R1 + 15];
           R2 = Data.List.NonEmpty.toList_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpDX_entry() //  [R1]
         { info_tbl: [(cdqAQ,
                       label: sat_sdpDX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqAQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqAU; else goto cdqAV;
       cdqAU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqAV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdqAN_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqB3; else goto cdqAO;
       udqB3: // global
           call _cdqAN(R1) args: 0, res: 0, upd: 0;
       cdqAO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqAN() //  [R1]
         { info_tbl: [(cdqAN,
                       label: block_cdqAN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqAN: // global
           I64[Sp] = block_cdqAT_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udqB2; else goto cdqAX;
       udqB2: // global
           call _cdqAT(R1) args: 0, res: 0, upd: 0;
       cdqAX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqAT() //  [R1]
         { info_tbl: [(cdqAT,
                       label: block_cdqAT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqAT: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpDQ_entry() //  [R1]
         { info_tbl: [(cdqBb,
                       label: sat_sdpDQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqBb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqBf; else goto cdqBg;
       cdqBf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqBg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdqB8_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqBo; else goto cdqB9;
       udqBo: // global
           call _cdqB8(R1) args: 0, res: 0, upd: 0;
       cdqB9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqB8() //  [R1]
         { info_tbl: [(cdqB8,
                       label: block_cdqB8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqB8: // global
           I64[Sp] = block_cdqBe_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udqBn; else goto cdqBi;
       udqBn: // global
           call _cdqBe(R1) args: 0, res: 0, upd: 0;
       cdqBi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqBe() //  [R1]
         { info_tbl: [(cdqBe,
                       label: block_cdqBe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqBe: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds_sdpDJ_entry() //  [R1]
         { info_tbl: [(cdqBx,
                       label: ds_sdpDJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqBx: // global
           _sdpDJ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqBy; else goto cdqBz;
       cdqBz: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdqBB; else goto cdqBA;
       cdqBB: // global
           HpAlloc = 120;
           goto cdqBy;
       cdqBy: // global
           R1 = _sdpDJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqBA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpDJ::P64;
           _sdpDI::P64 = P64[_sdpDJ::P64 + 16];
           I64[Hp - 112] = sat_sdpE2_info;
           P64[Hp - 96] = _sdpDI::P64;
           I64[Hp - 88] = sat_sdpDX_info;
           P64[Hp - 72] = _sdpDI::P64;
           I64[Hp - 64] = sat_sdpDQ_info;
           P64[Hp - 48] = _sdpDI::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 112;
           I64[Sp - 24] = block_cdqBr_info;
           R2 = Hp - 14;
           Sp = Sp - 24;
           call Data.OldList.transpose_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqBr() //  [R1]
         { info_tbl: [(cdqBr,
                       label: block_cdqBr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqBr: // global
           if (R1 & 7 == 1) goto cdqBu; else goto cdqBv;
       cdqBu: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cdqBv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqBK; else goto cdqBJ;
       cdqBK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqBJ: // global
           _sdpE5::P64 = P64[R1 + 6];
           _sdpE6::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpE5::P64;
           P64[Hp] = _sdpE6::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEh_entry() //  [R1]
         { info_tbl: [(cdqBS,
                       label: sat_sdpEh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqBS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqBT; else goto cdqBU;
       cdqBT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqBU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdqBP_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqBY; else goto cdqBQ;
       udqBY: // global
           call _cdqBP(R1) args: 0, res: 0, upd: 0;
       cdqBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqBP() //  [R1]
         { info_tbl: [(cdqBP,
                       label: block_cdqBP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqBP: // global
           R3 = P64[R1 + 15];
           R2 = Data.List.NonEmpty.fromList_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEd_entry() //  [R1]
         { info_tbl: [(cdqC6,
                       label: sat_sdpEd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqC6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqC7; else goto cdqC8;
       cdqC7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqC8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdqC3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqCt; else goto cdqC4;
       udqCt: // global
           call _cdqC3(R1) args: 0, res: 0, upd: 0;
       cdqC4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqC3() //  [R1]
         { info_tbl: [(cdqC3,
                       label: block_cdqC3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqC3: // global
           I64[Sp] = block_cdqCb_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udqCs; else goto cdqCd;
       udqCs: // global
           call _cdqCb(R1) args: 0, res: 0, upd: 0;
       cdqCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqCb() //  [R1]
         { info_tbl: [(cdqCb,
                       label: block_cdqCb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqCb: // global
           if (R1 & 7 == 1) goto cdqCj; else goto cdqCn;
       cdqCj: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cdqCn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqCq; else goto cdqCp;
       cdqCq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqCp: // global
           _sdpEb::P64 = P64[R1 + 6];
           _sdpEc::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpEb::P64;
           P64[Hp] = _sdpEc::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wtranspose_entry() //  [R2]
         { info_tbl: [(cdqCu,
                       label: Data.List.NonEmpty.$wtranspose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqCu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqCy; else goto cdqCx;
       cdqCy: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wtranspose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqCx: // global
           I64[Hp - 64] = ds_sdpDJ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdpEh_info;
           _cdqAr::P64 = Hp - 64;
           P64[Hp - 24] = _cdqAr::P64;
           I64[Hp - 16] = sat_sdpEd_info;
           P64[Hp] = _cdqAr::P64;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.529545198 UTC

[section ""data" . Data.List.NonEmpty.transpose_closure" {
     Data.List.NonEmpty.transpose_closure:
         const Data.List.NonEmpty.transpose_info;
         const 0;
 },
 Data.List.NonEmpty.transpose_entry() //  [R2]
         { info_tbl: [(cdqCG,
                       label: Data.List.NonEmpty.transpose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqCG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqCH; else goto cdqCI;
       cdqCH: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.transpose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqCI: // global
           I64[Sp - 8] = block_cdqCD_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wtranspose_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqCD() //  [R1, R2]
         { info_tbl: [(cdqCD,
                       label: block_cdqCD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqCD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqCL; else goto cdqCK;
       cdqCL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqCK: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.531122022 UTC

[section ""data" . Data.List.NonEmpty.map_closure" {
     Data.List.NonEmpty.map_closure:
         const Data.List.NonEmpty.map_info;
 },
 sat_sdpEw_entry() //  [R1]
         { info_tbl: [(cdqCX,
                       label: sat_sdpEw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqCX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqCY; else goto cdqCZ;
       cdqCY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqCZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqCU_info;
           _sdpEm::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpEm::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqD3; else goto cdqCV;
       udqD3: // global
           call _cdqCU(R1) args: 0, res: 0, upd: 0;
       cdqCV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqCU() //  [R1]
         { info_tbl: [(cdqCU,
                       label: block_cdqCU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqCU: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEs_entry() //  [R1]
         { info_tbl: [(cdqD9,
                       label: sat_sdpEs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqD9: // global
           _sdpEs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdqDa; else goto cdqDb;
       cdqDb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqDd; else goto cdqDc;
       cdqDd: // global
           HpAlloc = 24;
           goto cdqDa;
       cdqDa: // global
           R1 = _sdpEs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqDc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpEs::P64;
           _sdpEm::P64 = P64[_sdpEs::P64 + 16];
           _sdpEn::P64 = P64[_sdpEs::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdpEn::P64;
           R2 = Hp - 16;
           R1 = _sdpEm::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.map_entry() //  [R2, R3]
         { info_tbl: [(cdqDf,
                       label: Data.List.NonEmpty.map_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqDf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdqDj; else goto cdqDi;
       cdqDj: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.map_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqDi: // global
           I64[Hp - 80] = sat_sdpEw_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sdpEs_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.53314276 UTC

[section ""data" . Data.List.NonEmpty.some1_closure" {
     Data.List.NonEmpty.some1_closure:
         const Data.List.NonEmpty.some1_info;
 },
 sat_sdpEA_entry() //  [R1]
         { info_tbl: [(cdqDs,
                       label: sat_sdpEA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqDs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqDt; else goto cdqDu;
       cdqDt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqDu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.many_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.some1_entry() //  [R2, R3]
         { info_tbl: [(cdqDx,
                       label: Data.List.NonEmpty.some1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqDx: // global
           _sdpEy::P64 = R3;
           _sdpEx::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdqDy; else goto cdqDz;
       cdqDz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqDB; else goto cdqDA;
       cdqDB: // global
           HpAlloc = 32;
           goto cdqDy;
       cdqDy: // global
           R3 = _sdpEy::P64;
           R2 = _sdpEx::P64;
           R1 = Data.List.NonEmpty.some1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqDA: // global
           I64[Hp - 24] = sat_sdpEA_info;
           P64[Hp - 8] = _sdpEx::P64;
           P64[Hp] = _sdpEy::P64;
           I64[Sp - 24] = block_cdqDv_info;
           R2 = _sdpEx::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sdpEy::P64;
           Sp = Sp - 24;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqDv() //  [R1]
         { info_tbl: [(cdqDv,
                       label: block_cdqDv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqDv: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = GHC.Base.:|_closure+2;
           _cdqDo::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cdqDo::P64;
           Sp = Sp - 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.535198884 UTC

[section ""data" . Data.List.NonEmpty.intersperse_closure" {
     Data.List.NonEmpty.intersperse_closure:
         const Data.List.NonEmpty.intersperse_info;
 },
 sat_sdpEN_entry() //  [R1]
         { info_tbl: [(cdqE2,
                       label: sat_sdpEN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqE2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqE3; else goto cdqE4;
       cdqE3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqE4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEP_entry() //  [R1]
         { info_tbl: [(cdqE5,
                       label: sat_sdpEP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqE5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqE6; else goto cdqE7;
       cdqE6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqE7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqDN_info;
           _sdpEB::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpEB::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqEl; else goto cdqDO;
       udqEl: // global
           call _cdqDN(R1) args: 0, res: 0, upd: 0;
       cdqDO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqDN() //  [R1]
         { info_tbl: [(cdqDN,
                       label: block_cdqDN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqDN: // global
           I64[Sp] = block_cdqDS_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto udqEk; else goto cdqDT;
       udqEk: // global
           call _cdqDS(R1) args: 0, res: 0, upd: 0;
       cdqDT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqDS() //  [R1]
         { info_tbl: [(cdqDS,
                       label: block_cdqDS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqDS: // global
           if (R1 & 7 == 1) goto cdqEc; else goto cdqEf;
       cdqEc: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdqEf: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdqEi; else goto cdqEh;
       cdqEi: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqEh: // global
           _sdpEL::P64 = P64[R1 + 6];
           _sdpEM::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sdpEN_info;
           _sdpEB::P64 = P64[Sp + 8];
           P64[Hp - 56] = _sdpEB::P64;
           P64[Hp - 48] = _sdpEM::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sdpEL::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdpEB::P64;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.intersperse_entry() //  [R2, R3]
         { info_tbl: [(cdqEo,
                       label: Data.List.NonEmpty.intersperse_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqEo: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdqEs; else goto cdqEr;
       cdqEs: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.intersperse_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqEr: // global
           I64[Hp - 72] = sat_sdpEP_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.537980116 UTC

[section ""data" . Data.List.NonEmpty.iterate_closure" {
     Data.List.NonEmpty.iterate_closure:
         const Data.List.NonEmpty.iterate_info;
 },
 sat_sdpEW_entry() //  [R1]
         { info_tbl: [(cdqEF,
                       label: sat_sdpEW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqEF: // global
           _sdpEW::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqEG; else goto cdqEH;
       cdqEH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqEJ; else goto cdqEI;
       cdqEJ: // global
           HpAlloc = 32;
           goto cdqEG;
       cdqEG: // global
           R1 = _sdpEW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqEI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpEW::P64;
           _sdpEQ::P64 = P64[_sdpEW::P64 + 16];
           _sdpER::P64 = P64[_sdpEW::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpEQ::P64;
           P64[Hp] = _sdpER::P64;
           I64[Sp - 24] = block_cdqEC_info;
           R3 = Hp - 24;
           R2 = _sdpEQ::P64;
           Sp = Sp - 24;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqEC() //  [R1, R2]
         { info_tbl: [(cdqEC,
                       label: block_cdqEC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqEC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqEM; else goto cdqEL;
       cdqEM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqEL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.iterate_entry() //  [R2, R3]
         { info_tbl: [(cdqEO,
                       label: Data.List.NonEmpty.iterate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqEO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdqES; else goto cdqER;
       cdqES: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.iterate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqER: // global
           I64[Hp - 48] = sat_sdpEW_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.539739948 UTC

[section ""data" . Data.List.NonEmpty.repeat_closure" {
     Data.List.NonEmpty.repeat_closure:
         const Data.List.NonEmpty.repeat_info;
 },
 sat_sdpEY_entry() //  [R1]
         { info_tbl: [(cdqF1,
                       label: sat_sdpEY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqF1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqF2; else goto cdqF3;
       cdqF2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqF3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.repeat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.repeat_entry() //  [R2]
         { info_tbl: [(cdqF5,
                       label: Data.List.NonEmpty.repeat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqF5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdqF9; else goto cdqF8;
       cdqF9: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.List.NonEmpty.repeat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqF8: // global
           I64[Hp - 40] = sat_sdpEY_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.541752892 UTC

[section ""data" . Data.List.NonEmpty.groupBy_$sgroupBy_closure" {
     Data.List.NonEmpty.groupBy_$sgroupBy_closure:
         const Data.List.NonEmpty.groupBy_$sgroupBy_info;
 },
 ds_sdpF4_entry() //  [R1]
         { info_tbl: [(cdqFs,
                       label: ds_sdpF4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqFs: // global
           _sdpF4::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqFt; else goto cdqFu;
       cdqFu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqFw; else goto cdqFv;
       cdqFw: // global
           HpAlloc = 32;
           goto cdqFt;
       cdqFt: // global
           R1 = _sdpF4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqFv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpF4::P64;
           _sdpEZ::P64 = P64[_sdpF4::P64 + 16];
           _sdpF2::P64 = P64[_sdpF4::P64 + 24];
           _sdpF3::P64 = P64[_sdpF4::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpEZ::P64;
           P64[Hp] = _sdpF2::P64;
           I64[Sp - 24] = block_cdqFp_info;
           R3 = _sdpF3::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqFp() //  [R1, R2]
         { info_tbl: [(cdqFp,
                       label: block_cdqFp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqFp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqFz; else goto cdqFy;
       cdqFz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqFy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpFh_entry() //  [R1]
         { info_tbl: [(cdqFH,
                       label: sat_sdpFh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqFH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqFI; else goto cdqFJ;
       cdqFI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqFJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqFE_info;
           _sdpEZ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpEZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqFN; else goto cdqFF;
       udqFN: // global
           call _cdqFE(R1) args: 0, res: 0, upd: 0;
       cdqFF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqFE() //  [R1]
         { info_tbl: [(cdqFE,
                       label: block_cdqFE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqFE: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy_$sgroupBy_entry() //  [R2, R3]
         { info_tbl: [(cdqFS,
                       label: Data.List.NonEmpty.groupBy_$sgroupBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqFS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqFT; else goto cdqFU;
       cdqFT: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy_$sgroupBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqFU: // global
           I64[Sp - 16] = block_cdqFe_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqG3; else goto cdqFf;
       udqG3: // global
           call _cdqFe(R1) args: 0, res: 0, upd: 0;
       cdqFf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqFe() //  [R1]
         { info_tbl: [(cdqFe,
                       label: block_cdqFe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqFe: // global
           if (R1 & 7 == 1) goto cdqFP; else goto cdqFQ;
       cdqFP: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqFQ: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdqG2; else goto cdqG1;
       cdqG2: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqG1: // global
           _sdpF2::P64 = P64[R1 + 6];
           _sdpF3::P64 = P64[R1 + 14];
           I64[Hp - 136] = ds_sdpF4_info;
           _sdpEZ::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdpEZ::P64;
           P64[Hp - 112] = _sdpF2::P64;
           P64[Hp - 104] = _sdpF3::P64;
           I64[Hp - 96] = sat_sdpFh_info;
           P64[Hp - 80] = _sdpEZ::P64;
           _cdqFk::P64 = Hp - 136;
           P64[Hp - 72] = _cdqFk::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdqFk::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpF2::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.544994418 UTC

[section ""data" . Data.List.NonEmpty.groupBy_closure" {
     Data.List.NonEmpty.groupBy_closure:
         const Data.List.NonEmpty.groupBy_info;
 },
 ds_sdpFo_entry() //  [R1]
         { info_tbl: [(cdqGl,
                       label: ds_sdpFo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqGl: // global
           _sdpFo::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqGm; else goto cdqGn;
       cdqGn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqGp; else goto cdqGo;
       cdqGp: // global
           HpAlloc = 32;
           goto cdqGm;
       cdqGm: // global
           R1 = _sdpFo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqGo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpFo::P64;
           _sdpFj::P64 = P64[_sdpFo::P64 + 16];
           _sdpFm::P64 = P64[_sdpFo::P64 + 24];
           _sdpFn::P64 = P64[_sdpFo::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpFj::P64;
           P64[Hp] = _sdpFm::P64;
           I64[Sp - 24] = block_cdqGi_info;
           R3 = _sdpFn::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqGi() //  [R1, R2]
         { info_tbl: [(cdqGi,
                       label: block_cdqGi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqGi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqGs; else goto cdqGr;
       cdqGs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqGr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpFB_entry() //  [R1]
         { info_tbl: [(cdqGA,
                       label: sat_sdpFB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqGA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqGB; else goto cdqGC;
       cdqGB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqGC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqGx_info;
           _sdpFj::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpFj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqGG; else goto cdqGy;
       udqGG: // global
           call _cdqGx(R1) args: 0, res: 0, upd: 0;
       cdqGy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqGx() //  [R1]
         { info_tbl: [(cdqGx,
                       label: block_cdqGx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqGx: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqGL,
                       label: Data.List.NonEmpty.groupBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqGL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqGM; else goto cdqGN;
       cdqGM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqGN: // global
           I64[Sp - 16] = block_cdqG8_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdqG8() //  [R1]
         { info_tbl: [(cdqG8,
                       label: block_cdqG8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqG8: // global
           if (R1 & 7 == 1) goto cdqGI; else goto cdqGJ;
       cdqGI: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqGJ: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdqGV; else goto cdqGU;
       cdqGV: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqGU: // global
           _sdpFm::P64 = P64[R1 + 6];
           _sdpFn::P64 = P64[R1 + 14];
           I64[Hp - 136] = ds_sdpFo_info;
           _sdpFj::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdpFj::P64;
           P64[Hp - 112] = _sdpFm::P64;
           P64[Hp - 104] = _sdpFn::P64;
           I64[Hp - 96] = sat_sdpFB_info;
           P64[Hp - 80] = _sdpFj::P64;
           _cdqGd::P64 = Hp - 136;
           P64[Hp - 72] = _cdqGd::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdqGd::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpFm::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.548569573 UTC

[section ""data" . Data.List.NonEmpty.groupWith_closure" {
     Data.List.NonEmpty.groupWith_closure:
         const Data.List.NonEmpty.groupWith_info;
 },
 eq0_sdpFJ_entry() //  [R1, R2, R3]
         { info_tbl: [(cdqHc,
                       label: eq0_sdpFJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqHc: // global
           _sdpFL::P64 = R3;
           _sdpFK::P64 = R2;
           _sdpFJ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqHd; else goto cdqHe;
       cdqHe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqHg; else goto cdqHf;
       cdqHg: // global
           HpAlloc = 64;
           goto cdqHd;
       cdqHd: // global
           R3 = _sdpFL::P64;
           R2 = _sdpFK::P64;
           R1 = _sdpFJ::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqHf: // global
           _sdpFD::P64 = P64[_sdpFJ::P64 + 6];
           _sdpFE::P64 = P64[_sdpFJ::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdpFE::P64;
           P64[Hp - 32] = _sdpFL::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpFE::P64;
           P64[Hp] = _sdpFK::P64;
           R2 = _sdpFD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdpFP_entry() //  [R1, R2]
         { info_tbl: [(cdqHq,
                       label: sat_sdpFP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqHq: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call eq0_sdpFJ_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdpFO_entry() //  [R1]
         { info_tbl: [(cdqHw,
                       label: ds_sdpFO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqHw: // global
           _sdpFO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqHx; else goto cdqHy;
       cdqHy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqHA; else goto cdqHz;
       cdqHA: // global
           HpAlloc = 24;
           goto cdqHx;
       cdqHx: // global
           R1 = _sdpFO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqHz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpFO::P64;
           _sdpFH::P64 = P64[_sdpFO::P64 + 16];
           _sdpFI::P64 = P64[_sdpFO::P64 + 24];
           _sdpFJ::P64 = P64[_sdpFO::P64 + 32];
           I64[Hp - 16] = sat_sdpFP_info;
           P64[Hp - 8] = _sdpFH::P64;
           P64[Hp] = _sdpFJ::P64;
           I64[Sp - 24] = block_cdqHt_info;
           R3 = _sdpFI::P64;
           R2 = Hp - 15;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqHt() //  [R1, R2]
         { info_tbl: [(cdqHt,
                       label: block_cdqHt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqHt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqHD; else goto cdqHC;
       cdqHD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqHC: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpG1_entry() //  [R1]
         { info_tbl: [(cdqHL,
                       label: sat_sdpG1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqHL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqHM; else goto cdqHN;
       cdqHM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqHN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqHI_info;
           _sdpFJ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpFJ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqHR; else goto cdqHJ;
       udqHR: // global
           call _cdqHI(R1) args: 0, res: 0, upd: 0;
       cdqHJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqHI() //  [R1]
         { info_tbl: [(cdqHI,
                       label: block_cdqHI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqHI: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdqHW,
                       label: Data.List.NonEmpty.groupWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqHW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdqHX; else goto cdqHY;
       cdqHX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqHY: // global
           I64[Sp - 24] = block_cdqH0_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdqH0() //  [R1]
         { info_tbl: [(cdqH0,
                       label: block_cdqH0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqH0: // global
           if (R1 & 7 == 1) goto cdqHT; else goto cdqHU;
       cdqHT: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqHU: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdqI6; else goto cdqI5;
       cdqI6: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqI5: // global
           _sdpFH::P64 = P64[R1 + 6];
           _sdpFI::P64 = P64[R1 + 14];
           I64[Hp - 160] = eq0_sdpFJ_info;
           P64[Hp - 152] = P64[Sp + 8];
           P64[Hp - 144] = P64[Sp + 16];
           I64[Hp - 136] = ds_sdpFO_info;
           P64[Hp - 120] = _sdpFH::P64;
           P64[Hp - 112] = _sdpFI::P64;
           _cdqH5::P64 = Hp - 158;
           P64[Hp - 104] = _cdqH5::P64;
           I64[Hp - 96] = sat_sdpG1_info;
           P64[Hp - 80] = _cdqH5::P64;
           _cdqHh::P64 = Hp - 136;
           P64[Hp - 72] = _cdqHh::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdqHh::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpFH::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.551935674 UTC

[section ""data" . Data.List.NonEmpty.group_closure" {
     Data.List.NonEmpty.group_closure:
         const Data.List.NonEmpty.group_info;
 },
 sat_sdpG5_entry() //  [R1]
         { info_tbl: [(cdqIf,
                       label: sat_sdpG5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqIf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqIg; else goto cdqIh;
       cdqIg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqIh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.group_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqIi,
                       label: Data.List.NonEmpty.group_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqIi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqIm; else goto cdqIl;
       cdqIm: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.group_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqIl: // global
           I64[Hp - 16] = sat_sdpG5_info;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 16;
           R2 = R2;
           call Data.List.NonEmpty.groupBy_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.553751771 UTC

[section ""data" . Data.List.NonEmpty.isPrefixOf_closure" {
     Data.List.NonEmpty.isPrefixOf_closure:
         const Data.List.NonEmpty.isPrefixOf_info;
 },
 Data.List.NonEmpty.isPrefixOf_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqIy,
                       label: Data.List.NonEmpty.isPrefixOf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqIy: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdqIz; else goto cdqIA;
       cdqIz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.isPrefixOf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqIA: // global
           I64[Sp - 24] = block_cdqIr_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqJ0; else goto cdqIs;
       udqJ0: // global
           call _cdqIr(R1) args: 0, res: 0, upd: 0;
       cdqIs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqIr() //  [R1]
         { info_tbl: [(cdqIr,
                       label: block_cdqIr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqIr: // global
           if (R1 & 7 == 1) goto cdqIv; else goto cdqIw;
       cdqIv: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqIw: // global
           I64[Sp - 8] = block_cdqIG_info;
           _sdpGa::P64 = P64[R1 + 6];
           _sdpGb::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdpGb::P64;
           P64[Sp + 16] = _sdpGa::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqIZ; else goto cdqII;
       udqIZ: // global
           call _cdqIG(R1) args: 0, res: 0, upd: 0;
       cdqII: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqIG() //  [R1]
         { info_tbl: [(cdqIG,
                       label: block_cdqIG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqIG: // global
           I64[Sp] = block_cdqIM_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdqIM() //  [R1]
         { info_tbl: [(cdqIM,
                       label: block_cdqIM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqIM: // global
           if (R1 & 7 == 1) goto cdqIT; else goto cdqIX;
       cdqIT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqIX: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.OldList.isPrefixOf_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.555395658 UTC

[section ""cstring" . lvl1_rdpwu_bytes" {
     lvl1_rdpwu_bytes:
         I8[] [78,111,110,69,109,112,116,121,46,33,33,32,110,101,103,97,116,105,118,101,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.556176012 UTC

[section ""data" . Data.List.NonEmpty.!!1_closure" {
     Data.List.NonEmpty.!!1_closure:
         const Data.List.NonEmpty.!!1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.List.NonEmpty.!!1_entry() //  [R1]
         { info_tbl: [(cdqJ9,
                       label: Data.List.NonEmpty.!!1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqJ9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqJa; else goto cdqJb;
       cdqJa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqJb: // global
           (_cdqJ4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdqJ4::I64 == 0) goto cdqJ6; else goto cdqJ5;
       cdqJ6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdqJ5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdqJ4::I64;
           I64[Sp - 24] = block_cdqJ7_info;
           R2 = lvl1_rdpwu_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqJ7() //  [R1]
         { info_tbl: [(cdqJ7,
                       label: block_cdqJ7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqJ7: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.557489847 UTC

[section ""data" . Data.List.NonEmpty.$w!!_closure" {
     Data.List.NonEmpty.$w!!_closure:
         const Data.List.NonEmpty.$w!!_info;
         const 0;
 },
 Data.List.NonEmpty.$w!!_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqJn,
                       label: Data.List.NonEmpty.$w!!_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqJn: // global
           if (R4 == 0) goto cdqJm; else goto cdqJl;
       cdqJm: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdqJl: // global
           if (%MO_S_Le_W64(R4, 0)) goto cdqJu; else goto cdqJv;
       cdqJu: // global
           R1 = Data.List.NonEmpty.!!1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdqJv: // global
           _sdpGi::P64 = R3;
           R3 = R4 - 1;
           R2 = _sdpGi::P64;
           call GHC.List.$w!!_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.558705622 UTC

[section ""data" . Data.List.NonEmpty.!!_closure" {
     Data.List.NonEmpty.!!_closure:
         const Data.List.NonEmpty.!!_info;
         const 0;
 },
 Data.List.NonEmpty.!!_entry() //  [R2, R3]
         { info_tbl: [(cdqJG,
                       label: Data.List.NonEmpty.!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqJG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqJK; else goto cdqJL;
       cdqJK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.!!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqJL: // global
           I64[Sp - 16] = block_cdqJD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqJT; else goto cdqJE;
       udqJT: // global
           call _cdqJD(R1) args: 0, res: 0, upd: 0;
       cdqJE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqJD() //  [R1]
         { info_tbl: [(cdqJD,
                       label: block_cdqJD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqJD: // global
           I64[Sp - 8] = block_cdqJJ_info;
           _sdpGq::P64 = P64[R1 + 7];
           _sdpGr::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdpGr::P64;
           P64[Sp + 8] = _sdpGq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqJS; else goto cdqJN;
       udqJS: // global
           call _cdqJJ(R1) args: 0, res: 0, upd: 0;
       cdqJN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqJJ() //  [R1]
         { info_tbl: [(cdqJJ,
                       label: block_cdqJJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqJJ: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.List.NonEmpty.$w!!_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.560498605 UTC

[section ""data" . Data.List.NonEmpty.zip_closure" {
     Data.List.NonEmpty.zip_closure:
         const Data.List.NonEmpty.zip_info;
 },
 sat_sdpGM_entry() //  [R1]
         { info_tbl: [(cdqK5,
                       label: sat_sdpGM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqK5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqK9; else goto cdqKa;
       cdqK9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqKa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqK2_info;
           _sdpGv::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sdpGv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqKe; else goto cdqK3;
       udqKe: // global
           call _cdqK2(R1) args: 0, res: 0, upd: 0;
       cdqK3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqK2() //  [R1]
         { info_tbl: [(cdqK2,
                       label: block_cdqK2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqK2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqKd; else goto cdqKc;
       cdqKd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqKc: // global
           _sdpGH::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 16;
           R2 = _sdpGH::P64;
           Sp = Sp + 16;
           call GHC.List.zip_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.zip_entry() //  [R2, R3]
         { info_tbl: [(cdqKj,
                       label: Data.List.NonEmpty.zip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqKj: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cdqKn; else goto cdqKm;
       cdqKn: // global
           HpAlloc = 128;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.zip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqKm: // global
           I64[Hp - 120] = sat_sdpGM_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = stg_sel_0_upd_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 120;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.562752303 UTC

[section ""data" . Data.List.NonEmpty.zipWith_closure" {
     Data.List.NonEmpty.zipWith_closure:
         const Data.List.NonEmpty.zipWith_info;
 },
 sat_sdpH6_entry() //  [R1]
         { info_tbl: [(cdqKz,
                       label: sat_sdpH6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqKz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdqKD; else goto cdqKE;
       cdqKD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqKE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdqKw_info;
           _sdpGN::P64 = P64[R1 + 16];
           _sdpGP::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdpGN::P64;
           P64[Sp - 24] = _sdpGP::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udqKI; else goto cdqKx;
       udqKI: // global
           call _cdqKw(R1) args: 0, res: 0, upd: 0;
       cdqKx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqKw() //  [R1]
         { info_tbl: [(cdqKw,
                       label: block_cdqKw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqKw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqKH; else goto cdqKG;
       cdqKH: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqKG: // global
           _sdpH1::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 16;
           R3 = _sdpH1::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.List.zipWith_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpGY_entry() //  [R1]
         { info_tbl: [(cdqKP,
                       label: sat_sdpGY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqKP: // global
           _sdpGY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdqKQ; else goto cdqKR;
       cdqKR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdqKT; else goto cdqKS;
       cdqKT: // global
           HpAlloc = 48;
           goto cdqKQ;
       cdqKQ: // global
           R1 = _sdpGY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqKS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpGY::P64;
           _sdpGN::P64 = P64[_sdpGY::P64 + 16];
           _sdpGO::P64 = P64[_sdpGY::P64 + 24];
           _sdpGP::P64 = P64[_sdpGY::P64 + 32];
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpGP::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdpGO::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _sdpGN::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.zipWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqKV,
                       label: Data.List.NonEmpty.zipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqKV: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdqKZ; else goto cdqKY;
       cdqKZ: // global
           HpAlloc = 104;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.zipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqKY: // global
           I64[Hp - 96] = sat_sdpH6_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sdpGY_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.565111885 UTC

[section ""data" . Data.List.NonEmpty.unzip_closure" {
     Data.List.NonEmpty.unzip_closure:
         const Data.List.NonEmpty.unzip_info;
 },
 sat_sdpHa_entry() //  [R1]
         { info_tbl: [(cdqL8,
                       label: sat_sdpHa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqL8: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdqL9; else goto cdqLa;
       cdqL9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqLa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Tuple.snd_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdpH9_entry() //  [R1]
         { info_tbl: [(cdqLf,
                       label: sat_sdpH9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqLf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdqLg; else goto cdqLh;
       cdqLg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqLh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Tuple.fst_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.unzip_entry() //  [R2, R3]
         { info_tbl: [(cdqLj,
                       label: Data.List.NonEmpty.unzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqLj: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdqLn; else goto cdqLm;
       cdqLn: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqLm: // global
           I64[Hp - 80] = sat_sdpHa_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sdpH9_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.567499168 UTC

[section ""data" . Data.List.NonEmpty.nubBy_closure" {
     Data.List.NonEmpty.nubBy_closure:
         const Data.List.NonEmpty.nubBy_info;
 },
 sat_sdpHi_entry() //  [R1, R2]
         { info_tbl: [(cdqLM,
                       label: sat_sdpHi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqLM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqLN; else goto cdqLO;
       cdqLN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqLO: // global
           I64[Sp - 8] = block_cdqLG_info;
           R3 = R2;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqLG() //  [R1]
         { info_tbl: [(cdqLG,
                       label: block_cdqLG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqLG: // global
           if (R1 & 7 == 1) goto cdqLJ; else goto cdqLK;
       cdqLJ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqLK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpHk_entry() //  [R1]
         { info_tbl: [(cdqLX,
                       label: sat_sdpHk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqLX: // global
           _sdpHk::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cdqLY; else goto cdqLZ;
       cdqLZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqM1; else goto cdqM0;
       cdqM1: // global
           HpAlloc = 24;
           goto cdqLY;
       cdqLY: // global
           R1 = _sdpHk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqM0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHk::P64;
           _sdpHb::P64 = P64[_sdpHk::P64 + 16];
           _sdpHe::P64 = P64[_sdpHk::P64 + 24];
           _sdpHf::P64 = P64[_sdpHk::P64 + 32];
           I64[Hp - 16] = sat_sdpHi_info;
           P64[Hp - 8] = _sdpHb::P64;
           P64[Hp] = _sdpHe::P64;
           I64[Sp - 32] = block_cdqLV_info;
           R3 = _sdpHf::P64;
           R2 = Hp - 15;
           P64[Sp - 24] = _sdpHb::P64;
           Sp = Sp - 32;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqLV() //  [R1]
         { info_tbl: [(cdqLV,
                       label: block_cdqLV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqLV: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.OldList.nubBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.nubBy_entry() //  [R2, R3]
         { info_tbl: [(cdqM5,
                       label: Data.List.NonEmpty.nubBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqM5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqM7; else goto cdqM8;
       cdqM7: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.nubBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqM8: // global
           I64[Sp - 16] = block_cdqLs_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqMc; else goto cdqLt;
       udqMc: // global
           call _cdqLs(R1) args: 0, res: 0, upd: 0;
       cdqLt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqLs() //  [R1]
         { info_tbl: [(cdqLs,
                       label: block_cdqLs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqLs: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqMb; else goto cdqMa;
       cdqMb: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqMa: // global
           _sdpHe::P64 = P64[R1 + 7];
           _sdpHf::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdpHk_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sdpHe::P64;
           P64[Hp - 24] = _sdpHf::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpHe::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.570527441 UTC

[section ""data" . Data.List.NonEmpty.nub_closure" {
     Data.List.NonEmpty.nub_closure:
         const Data.List.NonEmpty.nub_info;
 },
 w_sdpHq_entry() //  [R1]
         { info_tbl: [(cdqMu,
                       label: w_sdpHq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqMu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqMv; else goto cdqMw;
       cdqMv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqMw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpHt_entry() //  [R1, R2]
         { info_tbl: [(cdqMI,
                       label: sat_sdpHt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqMI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqMJ; else goto cdqMK;
       cdqMJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqMK: // global
           I64[Sp - 8] = block_cdqMC_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqMC() //  [R1]
         { info_tbl: [(cdqMC,
                       label: block_cdqMC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqMC: // global
           if (R1 & 7 == 1) goto cdqMF; else goto cdqMG;
       cdqMF: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqMG: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpHv_entry() //  [R1]
         { info_tbl: [(cdqMT,
                       label: sat_sdpHv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqMT: // global
           _sdpHv::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cdqMU; else goto cdqMV;
       cdqMV: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdqMX; else goto cdqMW;
       cdqMX: // global
           HpAlloc = 48;
           goto cdqMU;
       cdqMU: // global
           R1 = _sdpHv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqMW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHv::P64;
           _sdpHl::P64 = P64[_sdpHv::P64 + 16];
           _sdpHo::P64 = P64[_sdpHv::P64 + 24];
           _sdpHp::P64 = P64[_sdpHv::P64 + 32];
           I64[Hp - 40] = w_sdpHq_info;
           P64[Hp - 24] = _sdpHl::P64;
           I64[Hp - 16] = sat_sdpHt_info;
           P64[Hp - 8] = _sdpHo::P64;
           _cdqMq::P64 = Hp - 40;
           P64[Hp] = _cdqMq::P64;
           I64[Sp - 32] = block_cdqMR_info;
           R3 = _sdpHp::P64;
           R2 = Hp - 15;
           P64[Sp - 24] = _cdqMq::P64;
           Sp = Sp - 32;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqMR() //  [R1]
         { info_tbl: [(cdqMR,
                       label: block_cdqMR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqMR: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.OldList.nubBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.nub_entry() //  [R2, R3]
         { info_tbl: [(cdqN1,
                       label: Data.List.NonEmpty.nub_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqN1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqN3; else goto cdqN4;
       cdqN3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.nub_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqN4: // global
           I64[Sp - 16] = block_cdqMh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqN8; else goto cdqMi;
       udqN8: // global
           call _cdqMh(R1) args: 0, res: 0, upd: 0;
       cdqMi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqMh() //  [R1]
         { info_tbl: [(cdqMh,
                       label: block_cdqMh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqMh: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqN7; else goto cdqN6;
       cdqN7: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqN6: // global
           _sdpHo::P64 = P64[R1 + 7];
           _sdpHp::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdpHv_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sdpHo::P64;
           P64[Hp - 24] = _sdpHp::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpHo::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.57294179 UTC

[section ""cstring" . Data.List.NonEmpty.$trModule4_bytes" {
     Data.List.NonEmpty.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.57357981 UTC

[section ""data" . Data.List.NonEmpty.$trModule3_closure" {
     Data.List.NonEmpty.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.NonEmpty.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.576897072 UTC

[section ""cstring" . Data.List.NonEmpty.$trModule2_bytes" {
     Data.List.NonEmpty.$trModule2_bytes:
         I8[] [68,97,116,97,46,76,105,115,116,46,78,111,110,69,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.577478238 UTC

[section ""data" . Data.List.NonEmpty.$trModule1_closure" {
     Data.List.NonEmpty.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.NonEmpty.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.57805507 UTC

[section ""data" . Data.List.NonEmpty.$trModule_closure" {
     Data.List.NonEmpty.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.List.NonEmpty.$trModule3_closure+1;
         const Data.List.NonEmpty.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.579436198 UTC

[section ""data" . Data.List.NonEmpty.groupAllWith_closure" {
     Data.List.NonEmpty.groupAllWith_closure:
         const Data.List.NonEmpty.groupAllWith_info;
         const 0;
 },
 sat_sdpHE_entry() //  [R1, R2, R3]
         { info_tbl: [(cdqNo,
                       label: sat_sdpHE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqNo: // global
           _sdpHB::P64 = R3;
           _sdpHA::P64 = R2;
           _sdpHE::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqNp; else goto cdqNq;
       cdqNq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqNs; else goto cdqNr;
       cdqNs: // global
           HpAlloc = 64;
           goto cdqNp;
       cdqNp: // global
           R3 = _sdpHB::P64;
           R2 = _sdpHA::P64;
           R1 = _sdpHE::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqNr: // global
           _sdpHw::P64 = P64[_sdpHE::P64 + 6];
           _sdpHx::P64 = P64[_sdpHE::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdpHx::P64;
           P64[Hp - 32] = _sdpHB::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpHx::P64;
           P64[Hp] = _sdpHA::P64;
           R2 = _sdpHw::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdpHF_entry() //  [R1]
         { info_tbl: [(cdqNt,
                       label: sat_sdpHF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqNt: // global
           _sdpHF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdqNu; else goto cdqNv;
       cdqNv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqNx; else goto cdqNw;
       cdqNx: // global
           HpAlloc = 24;
           goto cdqNu;
       cdqNu: // global
           R1 = _sdpHF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqNw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHF::P64;
           _sdpHw::P64 = P64[_sdpHF::P64 + 16];
           _sdpHx::P64 = P64[_sdpHF::P64 + 24];
           _sdpHy::P64 = P64[_sdpHF::P64 + 32];
           I64[Hp - 16] = sat_sdpHE_info;
           P64[Hp - 8] = _sdpHw::P64;
           P64[Hp] = _sdpHx::P64;
           R3 = _sdpHy::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call Data.OldList.sortBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpHz_entry() //  [R1]
         { info_tbl: [(cdqNC,
                       label: sat_sdpHz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqNC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqND; else goto cdqNE;
       cdqND: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqNE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupAllWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqNF,
                       label: Data.List.NonEmpty.groupAllWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqNF: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqNJ; else goto cdqNI;
       cdqNJ: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupAllWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqNI: // global
           I64[Hp - 56] = sat_sdpHF_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sdpHz_info;
           P64[Hp] = R2;
           R5 = Hp - 56;
           R4 = R3;
           R3 = Hp - 16;
           R2 = Data.Foldable.$fFoldable[]_closure;
           call Data.List.NonEmpty.groupWith_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.582225245 UTC

[section ""data" . Data.List.NonEmpty.groupBy1_closure" {
     Data.List.NonEmpty.groupBy1_closure:
         const Data.List.NonEmpty.groupBy1_info;
 },
 ds_sdpHL_entry() //  [R1]
         { info_tbl: [(cdqO1,
                       label: ds_sdpHL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqO1: // global
           _sdpHL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqO2; else goto cdqO3;
       cdqO3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqO5; else goto cdqO4;
       cdqO5: // global
           HpAlloc = 32;
           goto cdqO2;
       cdqO2: // global
           R1 = _sdpHL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqO4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHL::P64;
           _sdpHG::P64 = P64[_sdpHL::P64 + 16];
           _sdpHJ::P64 = P64[_sdpHL::P64 + 24];
           _sdpHK::P64 = P64[_sdpHL::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpHG::P64;
           P64[Hp] = _sdpHJ::P64;
           I64[Sp - 24] = block_cdqNY_info;
           R3 = _sdpHK::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqNY() //  [R1, R2]
         { info_tbl: [(cdqNY,
                       label: block_cdqNY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqNY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqO8; else goto cdqO7;
       cdqO8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqO7: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpHY_entry() //  [R1]
         { info_tbl: [(cdqOg,
                       label: sat_sdpHY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqOg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqOh; else goto cdqOi;
       cdqOh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqOi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqOd_info;
           _sdpHG::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpHG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqOm; else goto cdqOe;
       udqOm: // global
           call _cdqOd(R1) args: 0, res: 0, upd: 0;
       cdqOe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqOd() //  [R1]
         { info_tbl: [(cdqOd,
                       label: block_cdqOd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqOd: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy1_entry() //  [R2, R3]
         { info_tbl: [(cdqOn,
                       label: Data.List.NonEmpty.groupBy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqOn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqOr; else goto cdqOs;
       cdqOr: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqOs: // global
           I64[Sp - 16] = block_cdqNO_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqOw; else goto cdqNP;
       udqOw: // global
           call _cdqNO(R1) args: 0, res: 0, upd: 0;
       cdqNP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqNO() //  [R1]
         { info_tbl: [(cdqNO,
                       label: block_cdqNO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqNO: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdqOv; else goto cdqOu;
       cdqOv: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqOu: // global
           _sdpHJ::P64 = P64[R1 + 7];
           _sdpHK::P64 = P64[R1 + 15];
           I64[Hp - 136] = ds_sdpHL_info;
           _sdpHG::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdpHG::P64;
           P64[Hp - 112] = _sdpHJ::P64;
           P64[Hp - 104] = _sdpHK::P64;
           I64[Hp - 96] = sat_sdpHY_info;
           P64[Hp - 80] = _sdpHG::P64;
           _cdqNT::P64 = Hp - 136;
           P64[Hp - 72] = _cdqNT::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdqNT::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpHJ::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.585446244 UTC

[section ""data" . Data.List.NonEmpty.group1_closure" {
     Data.List.NonEmpty.group1_closure:
         const Data.List.NonEmpty.group1_info;
 },
 w_sdpI4_entry() //  [R1]
         { info_tbl: [(cdqOK,
                       label: w_sdpI4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqOK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqOL; else goto cdqOM;
       cdqOL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqOM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sdpI5_entry() //  [R1]
         { info_tbl: [(cdqOV,
                       label: ds_sdpI5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqOV: // global
           _sdpI5::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqOW; else goto cdqOX;
       cdqOX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqOZ; else goto cdqOY;
       cdqOZ: // global
           HpAlloc = 32;
           goto cdqOW;
       cdqOW: // global
           R1 = _sdpI5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqOY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpI5::P64;
           _sdpI2::P64 = P64[_sdpI5::P64 + 16];
           _sdpI3::P64 = P64[_sdpI5::P64 + 24];
           _sdpI4::P64 = P64[_sdpI5::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpI4::P64;
           P64[Hp] = _sdpI2::P64;
           I64[Sp - 24] = block_cdqOS_info;
           R3 = _sdpI3::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqOS() //  [R1, R2]
         { info_tbl: [(cdqOS,
                       label: block_cdqOS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqOS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqP2; else goto cdqP1;
       cdqP2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqP1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpIi_entry() //  [R1]
         { info_tbl: [(cdqPa,
                       label: sat_sdpIi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqPa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqPb; else goto cdqPc;
       cdqPb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqPc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqP7_info;
           _sdpI4::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpI4::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqPg; else goto cdqP8;
       udqPg: // global
           call _cdqP7(R1) args: 0, res: 0, upd: 0;
       cdqP8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqP7() //  [R1]
         { info_tbl: [(cdqP7,
                       label: block_cdqP7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqP7: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.group1_entry() //  [R2, R3]
         { info_tbl: [(cdqPh,
                       label: Data.List.NonEmpty.group1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqPh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqPl; else goto cdqPm;
       cdqPl: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.group1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqPm: // global
           I64[Sp - 16] = block_cdqOB_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udqPq; else goto cdqOC;
       udqPq: // global
           call _cdqOB(R1) args: 0, res: 0, upd: 0;
       cdqOC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqOB() //  [R1]
         { info_tbl: [(cdqOB,
                       label: block_cdqOB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqOB: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdqPp; else goto cdqPo;
       cdqPp: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqPo: // global
           _sdpI2::P64 = P64[R1 + 7];
           _sdpI3::P64 = P64[R1 + 15];
           I64[Hp - 160] = w_sdpI4_info;
           P64[Hp - 144] = P64[Sp + 8];
           I64[Hp - 136] = ds_sdpI5_info;
           P64[Hp - 120] = _sdpI2::P64;
           P64[Hp - 112] = _sdpI3::P64;
           _cdqOG::P64 = Hp - 160;
           P64[Hp - 104] = _cdqOG::P64;
           I64[Hp - 96] = sat_sdpIi_info;
           P64[Hp - 80] = _cdqOG::P64;
           _cdqON::P64 = Hp - 136;
           P64[Hp - 72] = _cdqON::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdqON::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpI2::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.588961663 UTC

[section ""data" . Data.List.NonEmpty.$wgroupWith1_closure" {
     Data.List.NonEmpty.$wgroupWith1_closure:
         const Data.List.NonEmpty.$wgroupWith1_info;
 },
 eq_sdpIn_entry() //  [R1, R2, R3]
         { info_tbl: [(cdqPC,
                       label: eq_sdpIn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqPC: // global
           _sdpIp::P64 = R3;
           _sdpIo::P64 = R2;
           _sdpIn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqPD; else goto cdqPE;
       cdqPE: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdqPG; else goto cdqPF;
       cdqPG: // global
           HpAlloc = 64;
           goto cdqPD;
       cdqPD: // global
           R3 = _sdpIp::P64;
           R2 = _sdpIo::P64;
           R1 = _sdpIn::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqPF: // global
           _sdpIj::P64 = P64[_sdpIn::P64 + 6];
           _sdpIk::P64 = P64[_sdpIn::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdpIk::P64;
           P64[Hp - 32] = _sdpIp::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpIk::P64;
           P64[Hp] = _sdpIo::P64;
           R2 = _sdpIj::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdpIt_entry() //  [R1, R2]
         { info_tbl: [(cdqPQ,
                       label: sat_sdpIt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqPQ: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call eq_sdpIn_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdpIs_entry() //  [R1]
         { info_tbl: [(cdqPW,
                       label: ds_sdpIs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqPW: // global
           _sdpIs::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqPX; else goto cdqPY;
       cdqPY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqQ0; else goto cdqPZ;
       cdqQ0: // global
           HpAlloc = 24;
           goto cdqPX;
       cdqPX: // global
           R1 = _sdpIs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqPZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpIs::P64;
           _sdpIl::P64 = P64[_sdpIs::P64 + 16];
           _sdpIm::P64 = P64[_sdpIs::P64 + 24];
           _sdpIn::P64 = P64[_sdpIs::P64 + 32];
           I64[Hp - 16] = sat_sdpIt_info;
           P64[Hp - 8] = _sdpIl::P64;
           P64[Hp] = _sdpIn::P64;
           I64[Sp - 24] = block_cdqPT_info;
           R3 = _sdpIm::P64;
           R2 = Hp - 15;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdqPT() //  [R1, R2]
         { info_tbl: [(cdqPT,
                       label: block_cdqPT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqPT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqQ3; else goto cdqQ2;
       cdqQ3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdqQ2: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpIF_entry() //  [R1]
         { info_tbl: [(cdqQb,
                       label: sat_sdpIF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqQb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqQc; else goto cdqQd;
       cdqQc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqQd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqQ8_info;
           _sdpIn::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpIn::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqQh; else goto cdqQ9;
       udqQh: // global
           call _cdqQ8(R1) args: 0, res: 0, upd: 0;
       cdqQ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqQ8() //  [R1]
         { info_tbl: [(cdqQ8,
                       label: block_cdqQ8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqQ8: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wgroupWith1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdqQk,
                       label: Data.List.NonEmpty.$wgroupWith1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqQk: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdqQo; else goto cdqQn;
       cdqQo: // global
           HpAlloc = 144;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wgroupWith1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqQn: // global
           I64[Hp - 136] = eq_sdpIn_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = ds_sdpIs_info;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           _cdqPv::P64 = Hp - 134;
           P64[Hp - 80] = _cdqPv::P64;
           I64[Hp - 72] = sat_sdpIF_info;
           P64[Hp - 56] = _cdqPv::P64;
           _cdqPH::P64 = Hp - 112;
           P64[Hp - 48] = _cdqPH::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdqPH::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 40;
           R2 = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.59208935 UTC

[section ""data" . Data.List.NonEmpty.groupWith1_closure" {
     Data.List.NonEmpty.groupWith1_closure:
         const Data.List.NonEmpty.groupWith1_info;
 },
 Data.List.NonEmpty.groupWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqQw,
                       label: Data.List.NonEmpty.groupWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqQw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqQC; else goto cdqQD;
       cdqQC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqQD: // global
           I64[Sp - 24] = block_cdqQt_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqQI; else goto cdqQu;
       udqQI: // global
           call _cdqQt(R1) args: 0, res: 0, upd: 0;
       cdqQu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqQt() //  [R1]
         { info_tbl: [(cdqQt,
                       label: block_cdqQt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqQt: // global
           _sdpIH::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdqQz_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _sdpIH::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wgroupWith1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqQz() //  [R1, R2]
         { info_tbl: [(cdqQz,
                       label: block_cdqQz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqQz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqQH; else goto cdqQG;
       cdqQH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqQG: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.594064223 UTC

[section ""data" . Data.List.NonEmpty.$wgroupAllWith1_closure" {
     Data.List.NonEmpty.$wgroupAllWith1_closure:
         const Data.List.NonEmpty.$wgroupAllWith1_info;
         const 0;
 },
 sat_sdpIS_entry() //  [R1, R2, R3]
         { info_tbl: [(cdqQV,
                       label: sat_sdpIS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqQV: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Ord.comparing_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpJ6_entry() //  [R1]
         { info_tbl: [(cdqR7,
                       label: sat_sdpJ6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqR7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqR8; else goto cdqR9;
       cdqR8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqR9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wgroupAllWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqRe,
                       label: Data.List.NonEmpty.$wgroupAllWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqRe: // global
           _sdpIR::P64 = R4;
           _sdpIQ::P64 = R3;
           _sdpIP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdqRf; else goto cdqRg;
       cdqRg: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdqRi; else goto cdqRh;
       cdqRi: // global
           HpAlloc = 96;
           goto cdqRf;
       cdqRf: // global
           R4 = _sdpIR::P64;
           R3 = _sdpIQ::P64;
           R2 = _sdpIP::P64;
           R1 = Data.List.NonEmpty.$wgroupAllWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqRh: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpIR::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpIR::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdpIS_info;
           P64[Hp - 8] = _sdpIP::P64;
           P64[Hp] = _sdpIQ::P64;
           I64[Sp - 24] = block_cdqQY_info;
           R3 = Hp - 38;
           R2 = Hp - 14;
           P64[Sp - 16] = _sdpIP::P64;
           P64[Sp - 8] = _sdpIQ::P64;
           Sp = Sp - 24;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqQY() //  [R1]
         { info_tbl: [(cdqQY,
                       label: block_cdqQY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqQY: // global
           if (R1 & 7 == 1) goto cdqRb; else goto cdqRc;
       cdqRb: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqRc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqRn; else goto cdqRm;
       cdqRn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqRm: // global
           _sdpJ4::P64 = P64[R1 + 6];
           _sdpJ5::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sdpJ6_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdpJ5::P64;
           R4 = _sdpJ4::P64;
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.List.NonEmpty.$wgroupWith1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.59614816 UTC

[section ""data" . Data.List.NonEmpty.groupAllWith1_closure" {
     Data.List.NonEmpty.groupAllWith1_closure:
         const Data.List.NonEmpty.groupAllWith1_info;
         const 0;
 },
 Data.List.NonEmpty.groupAllWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdqRv,
                       label: Data.List.NonEmpty.groupAllWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqRv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqRw; else goto cdqRx;
       cdqRw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupAllWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqRx: // global
           I64[Sp - 8] = block_cdqRs_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wgroupAllWith1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqRs() //  [R1, R2]
         { info_tbl: [(cdqRs,
                       label: block_cdqRs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqRs: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqRA; else goto cdqRz;
       cdqRA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqRz: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.597939509 UTC

[section ""data" . Data.List.NonEmpty.$wxor_closure" {
     Data.List.NonEmpty.$wxor_closure:
         const Data.List.NonEmpty.$wxor_info;
 },
 go_sdpJf_entry() //  [R1, R2]
         { info_tbl: [(cdqRR,
                       label: go_sdpJf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqRR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqRS; else goto udqSp;
       cdqRS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       udqSp: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cdqRH() args: 0, res: 0, upd: 0;
     }
 },
 _cdqRH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqRH: // global
           _sdpJd::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cdqRK_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdpJd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqSr; else goto cdqRL;
       udqSr: // global
           call _cdqRK(R1) args: 0, res: 0, upd: 0;
       cdqRL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqRK() //  [R1]
         { info_tbl: [(cdqRK,
                       label: block_cdqRK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqRK: // global
           if (R1 & 7 == 1) goto cdqRO; else goto cdqRP;
       cdqRO: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdqRP: // global
           I64[Sp] = block_cdqRZ_info;
           _sdpJj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdpJj::P64;
           if (R1 & 7 != 0) goto udqSs; else goto cdqS1;
       udqSs: // global
           call _cdqRZ(R1) args: 0, res: 0, upd: 0;
       cdqS1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqRZ() //  [R1]
         { info_tbl: [(cdqRZ,
                       label: block_cdqRZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqRZ: // global
           _sdpJj::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdqS7; else goto cdqSc;
       cdqS7: // global
           P64[Sp + 16] = _sdpJj::P64;
           Sp = Sp + 8;
           call _cdqRH() args: 0, res: 0, upd: 0;
       cdqSc: // global
           I64[Sp + 16] = block_cdqSa_info;
           R2 = _sdpJj::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdpJf_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqSa() //  [R1]
         { info_tbl: [(cdqSa,
                       label: block_cdqSa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqSa: // global
           if (R1 & 7 == 1) goto cdqSi; else goto cdqSm;
       cdqSi: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqSm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wxor_entry() //  [R2, R3]
         { info_tbl: [(cdqSv,
                       label: Data.List.NonEmpty.$wxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqSv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdqSz; else goto cdqSy;
       cdqSz: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqSy: // global
           I64[Hp - 8] = go_sdpJf_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_sdpJf_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.600033793 UTC

[section ""data" . Data.List.NonEmpty.xor_closure" {
     Data.List.NonEmpty.xor_closure:
         const Data.List.NonEmpty.xor_info;
 },
 Data.List.NonEmpty.xor_entry() //  [R2]
         { info_tbl: [(cdqSH,
                       label: Data.List.NonEmpty.xor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqSH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqSI; else goto cdqSJ;
       cdqSI: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.xor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqSJ: // global
           I64[Sp - 8] = block_cdqSE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqSN; else goto cdqSF;
       udqSN: // global
           call _cdqSE(R1) args: 0, res: 0, upd: 0;
       cdqSF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqSE() //  [R1]
         { info_tbl: [(cdqSE,
                       label: block_cdqSE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqSE: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.List.NonEmpty.$wxor_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.601526088 UTC

[section ""data" . Data.List.NonEmpty.length_closure" {
     Data.List.NonEmpty.length_closure:
         const Data.List.NonEmpty.length_info;
 },
 Data.List.NonEmpty.length_entry() //  [R2]
         { info_tbl: [(cdqSV,
                       label: Data.List.NonEmpty.length_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqSV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqT6; else goto cdqT7;
       cdqT6: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.length_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqT7: // global
           I64[Sp - 8] = block_cdqSS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqTc; else goto cdqST;
       udqTc: // global
           call _cdqSS(R1) args: 0, res: 0, upd: 0;
       cdqST: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqSS() //  [R1]
         { info_tbl: [(cdqSS,
                       label: block_cdqSS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqSS: // global
           I64[Sp] = block_cdqSY_info;
           R3 = 0;
           R2 = P64[R1 + 15];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqSY() //  [R1]
         { info_tbl: [(cdqSY,
                       label: block_cdqSY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqSY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdqTb; else goto cdqTa;
       cdqTb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdqTa: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.602725146 UTC

[section ""relreadonly" . SdpN4_srt" {
     SdpN4_srt:
         const GHC.List.lastError_closure;
         const Data.List.NonEmpty.last_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.List.NonEmpty.fromList_closure;
         const Data.List.NonEmpty.cycle1_closure;
         const Data.List.NonEmpty.reverse_closure;
         const Data.List.NonEmpty.sortBy_closure;
         const Data.List.NonEmpty.sortWith_closure;
         const Data.List.NonEmpty.sort_closure;
         const Data.OldList.$winits_closure;
         const Data.List.NonEmpty.inits_closure;
         const Data.List.NonEmpty.tails_closure;
         const GHC.List.scanr1_closure;
         const Data.List.NonEmpty.scanr1_closure;
         const Data.List.NonEmpty.cycle_closure;
         const Data.List.NonEmpty.$wtranspose_closure;
         const Data.List.NonEmpty.transpose_closure;
         const GHC.List.$w!!_closure;
         const Data.List.NonEmpty.!!1_closure;
         const Data.List.NonEmpty.!!_closure;
         const Data.List.NonEmpty.$w!!_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const Data.List.NonEmpty.groupAllWith_closure;
         const Data.List.NonEmpty.$wgroupAllWith1_closure;
         const Data.List.NonEmpty.groupAllWith1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.603714187 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:35.60521254 UTC

[section ""data" . Data.List.NonEmpty.nonEmpty_closure" {
     Data.List.NonEmpty.nonEmpty_closure:
         const Data.List.NonEmpty.nonEmpty_info;
 },
 Data.List.NonEmpty.nonEmpty_entry() //  [R2]
         { info_tbl: [(cdqTo,
                       label: Data.List.NonEmpty.nonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqTo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqTp; else goto cdqTq;
       cdqTp: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.nonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqTq: // global
           I64[Sp - 8] = block_cdqTh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqTB; else goto cdqTi;
       udqTB: // global
           call _cdqTh(R1) args: 0, res: 0, upd: 0;
       cdqTi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqTh() //  [R1]
         { info_tbl: [(cdqTh,
                       label: block_cdqTh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqTh: // global
           if (R1 & 7 == 1) goto cdqTl; else goto cdqTm;
       cdqTl: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdqTm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdqTA; else goto cdqTz;
       cdqTA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqTz: // global
           _sdpwy::P64 = P64[R1 + 6];
           _sdpwz::P64 = P64[R1 + 14];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _sdpwy::P64;
           P64[Hp - 16] = _sdpwz::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.612077497 UTC

[section ""data" . Data.List.NonEmpty.uncons_closure" {
     Data.List.NonEmpty.uncons_closure:
         const Data.List.NonEmpty.uncons_info;
 },
 sat_sdpwN_entry() //  [R1]
         { info_tbl: [(cdqU1,
                       label: sat_sdpwN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqU1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqU2; else goto cdqU3;
       cdqU2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqU3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdqTY_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqUp; else goto cdqTZ;
       udqUp: // global
           call _cdqTY(R1) args: 0, res: 0, upd: 0;
       cdqTZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqTY() //  [R1]
         { info_tbl: [(cdqTY,
                       label: block_cdqTY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqTY: // global
           I64[Sp] = block_cdqU6_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto udqUo; else goto cdqU8;
       udqUo: // global
           call _cdqU6(R1) args: 0, res: 0, upd: 0;
       cdqU8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqU6() //  [R1]
         { info_tbl: [(cdqU6,
                       label: block_cdqU6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqU6: // global
           if (R1 & 7 == 1) goto cdqUe; else goto cdqUj;
       cdqUe: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdqUj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdqUm; else goto cdqUl;
       cdqUm: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqUl: // global
           _sdpwK::P64 = P64[R1 + 6];
           _sdpwL::P64 = P64[R1 + 14];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _sdpwK::P64;
           P64[Hp - 16] = _sdpwL::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.uncons_entry() //  [R2]
         { info_tbl: [(cdqUs,
                       label: Data.List.NonEmpty.uncons_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqUs: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqUw; else goto cdqUv;
       cdqUw: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.uncons_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqUv: // global
           I64[Hp - 64] = sat_sdpwN_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.623298351 UTC

[section ""data" . Data.List.NonEmpty.$wunfoldr_closure" {
     Data.List.NonEmpty.$wunfoldr_closure:
         const Data.List.NonEmpty.$wunfoldr_info;
 },
 sat_sdpx2_entry() //  [R1]
         { info_tbl: [(cdqVx,
                       label: sat_sdpx2_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqVx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqVy; else goto cdqVz;
       cdqVy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqVz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqVq_info;
           _sdpwV::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpwV::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqVG; else goto cdqVr;
       udqVG: // global
           call _cdqVq(R1) args: 0, res: 0, upd: 0;
       cdqVr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqVq() //  [R1]
         { info_tbl: [(cdqVq,
                       label: block_cdqVq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqVq: // global
           if (R1 & 7 == 1) goto cdqVu; else goto cdqVv;
       cdqVu: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdqVv: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdpwV_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sdpwV_entry() //  [R1, R2]
         { info_tbl: [(cdqVH,
                       label: go_sdpwV_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqVH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqVJ; else goto cdqVK;
       cdqVJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqVK: // global
           I64[Sp - 16] = block_cdqVi_info;
           R2 = R2;
           _sdpwV::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdpwV::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqVi() //  [R1]
         { info_tbl: [(cdqVi,
                       label: block_cdqVi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqVi: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdqVN; else goto cdqVM;
       cdqVN: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqVM: // global
           _sdpwY::P64 = P64[R1 + 7];
           _sdpwZ::P64 = P64[R1 + 15];
           I64[Hp - 48] = sat_sdpx2_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sdpwZ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdpwY::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpx3_entry() //  [R1]
         { info_tbl: [(cdqVS,
                       label: sat_sdpx3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqVS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdqVT; else goto cdqVU;
       cdqVT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdqVU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdqV7_info;
           _sdpwO::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpwO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udqW0; else goto cdqV8;
       udqW0: // global
           call _cdqV7(R1) args: 0, res: 0, upd: 0;
       cdqV8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdqV7() //  [R1]
         { info_tbl: [(cdqV7,
                       label: block_cdqV7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqV7: // global
           if (R1 & 7 == 1) goto cdqVP; else goto cdqVQ;
       cdqVP: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdqVQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdqVZ; else goto cdqVY;
       cdqVZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdqVY: // global
           _sdpwU::P64 = P64[R1 + 6];
           I64[Hp - 8] = go_sdpwV_info;
           P64[Hp] = P64[Sp + 8];
           R2 = _sdpwU::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call go_sdpwV_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wunfoldr_entry() //  [R2, R3]
         { info_tbl: [(cdqW1,
                       label: Data.List.NonEmpty.$wunfoldr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqW1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqW2; else goto cdqW3;
       cdqW2: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunfoldr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqW3: // global
           I64[Sp - 16] = block_cdqUZ_info;
           _sdpwO::P64 = R2;
           R2 = R3;
           R1 = _sdpwO::P64;
           P64[Sp - 8] = _sdpwO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqUZ() //  [R1]
         { info_tbl: [(cdqUZ,
                       label: block_cdqUZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqUZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdqW6; else goto cdqW5;
       cdqW6: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdqW5: // global
           _sdpwR::P64 = P64[R1 + 7];
           _sdpwS::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdpx3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdpwS::P64;
           R2 = Hp - 24;
           R1 = _sdpwR::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.643538336 UTC

[section ""data" . Data.List.NonEmpty.unfoldr_closure" {
     Data.List.NonEmpty.unfoldr_closure:
         const Data.List.NonEmpty.unfoldr_info;
 },
 Data.List.NonEmpty.unfoldr_entry() //  [R2, R3]
         { info_tbl: [(cdqWV,
                       label: Data.List.NonEmpty.unfoldr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqWV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqWW; else goto cdqWX;
       cdqWW: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unfoldr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqWX: // global
           I64[Sp - 8] = block_cdqWS_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wunfoldr_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdqWS() //  [R1, R2]
         { info_tbl: [(cdqWS,
                       label: block_cdqWS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqWS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdqX0; else goto cdqWZ;
       cdqX0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdqWZ: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.649209927 UTC

[section ""data" . Data.List.NonEmpty.head_closure" {
     Data.List.NonEmpty.head_closure:
         const Data.List.NonEmpty.head_info;
 },
 Data.List.NonEmpty.head_entry() //  [R2]
         { info_tbl: [(cdqXh,
                       label: Data.List.NonEmpty.head_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqXh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqXi; else goto cdqXj;
       cdqXi: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.head_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqXj: // global
           I64[Sp - 8] = block_cdqXe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqXn; else goto cdqXf;
       udqXn: // global
           call _cdqXe(R1) args: 0, res: 0, upd: 0;
       cdqXf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqXe() //  [R1]
         { info_tbl: [(cdqXe,
                       label: block_cdqXe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqXe: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.654840621 UTC

[section ""data" . Data.List.NonEmpty.tail_closure" {
     Data.List.NonEmpty.tail_closure:
         const Data.List.NonEmpty.tail_info;
 },
 Data.List.NonEmpty.tail_entry() //  [R2]
         { info_tbl: [(cdqXE,
                       label: Data.List.NonEmpty.tail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqXE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqXF; else goto cdqXG;
       cdqXF: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.tail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqXG: // global
           I64[Sp - 8] = block_cdqXB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqXK; else goto cdqXC;
       udqXK: // global
           call _cdqXB(R1) args: 0, res: 0, upd: 0;
       cdqXC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqXB() //  [R1]
         { info_tbl: [(cdqXB,
                       label: block_cdqXB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqXB: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.660552019 UTC

[section ""data" . poly_go_rdpws_closure" {
     poly_go_rdpws_closure:
         const poly_go_rdpws_info;
 },
 poly_go_rdpws_entry() //  [R2, R3]
         { info_tbl: [(cdqY7,
                       label: poly_go_rdpws_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqY7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqY8; else goto udqYg;
       cdqY8: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_go_rdpws_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udqYg: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdqXX() args: 0, res: 0, upd: 0;
     }
 },
 _cdqXX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqXX: // global
           _sdpxh::P64 = P64[Sp];
           I64[Sp] = block_cdqY0_info;
           R1 = _sdpxh::P64;
           if (R1 & 7 != 0) goto udqYi; else goto cdqY1;
       udqYi: // global
           call _cdqY0(R1) args: 0, res: 0, upd: 0;
       cdqY1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqY0() //  [R1]
         { info_tbl: [(cdqY0,
                       label: block_cdqY0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqY0: // global
           if (R1 & 7 == 1) goto cdqY4; else goto cdqY5;
       cdqY4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdqY5: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cdqXX() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.667045684 UTC

[section ""data" . Data.List.NonEmpty.last_closure" {
     Data.List.NonEmpty.last_closure:
         const Data.List.NonEmpty.last_info;
         const 0;
 },
 Data.List.NonEmpty.last_entry() //  [R2]
         { info_tbl: [(cdqYH,
                       label: Data.List.NonEmpty.last_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqYH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdqYL; else goto cdqYK;
       cdqYL: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.last_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqYK: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = GHC.List.lastError_closure;
           R2 = Hp - 14;
           call poly_go_rdpws_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.6718489 UTC

[section ""data" . Data.List.NonEmpty.init_closure" {
     Data.List.NonEmpty.init_closure:
         const Data.List.NonEmpty.init_info;
 },
 Data.List.NonEmpty.init_entry() //  [R2]
         { info_tbl: [(cdqYZ,
                       label: Data.List.NonEmpty.init_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqYZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdqZ0; else goto cdqZ1;
       cdqZ0: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.init_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdqZ1: // global
           I64[Sp - 8] = block_cdqYW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udqZ5; else goto cdqYX;
       udqZ5: // global
           call _cdqYW(R1) args: 0, res: 0, upd: 0;
       cdqYX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqYW() //  [R1]
         { info_tbl: [(cdqYW,
                       label: block_cdqYW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqYW: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.List.init1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.677098581 UTC

[section ""data" . Data.List.NonEmpty.<|_closure" {
     Data.List.NonEmpty.<|_closure:
         const Data.List.NonEmpty.<|_info;
 },
 Data.List.NonEmpty.<|_entry() //  [R2, R3]
         { info_tbl: [(cdqZn,
                       label: Data.List.NonEmpty.<|_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqZn: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdqZr; else goto cdqZq;
       cdqZr: // global
           HpAlloc = 96;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.<|_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqZq: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 38;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.681162035 UTC

[section ""data" . Data.List.NonEmpty.cons_closure" {
     Data.List.NonEmpty.cons_closure:
         const Data.List.NonEmpty.cons_info;
 },
 Data.List.NonEmpty.cons_entry() //  [R2, R3]
         { info_tbl: [(cdqZE,
                       label: Data.List.NonEmpty.cons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqZE: // global
           R3 = R3;
           R2 = R2;
           call Data.List.NonEmpty.<|_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.685013086 UTC

[section ""data" . Data.List.NonEmpty.$wunfold_closure" {
     Data.List.NonEmpty.$wunfold_closure:
         const Data.List.NonEmpty.$wunfold_info;
 },
 ds1_sdpxS_entry() //  [R1]
         { info_tbl: [(cdr06,
                       label: ds1_sdpxS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr06: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdr07; else goto cdr08;
       cdr07: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdr08: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdr03_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Data.List.NonEmpty.$wunfold_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdr03() //  [R1, R2]
         { info_tbl: [(cdr03,
                       label: block_cdr03_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr03: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr0b; else goto cdr0a;
       cdr0b: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdr0a: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wunfold_entry() //  [R2, R3]
         { info_tbl: [(cdr0c,
                       label: Data.List.NonEmpty.$wunfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr0c: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdr0d; else goto cdr0e;
       cdr0d: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr0e: // global
           I64[Sp - 16] = block_cdqZP_info;
           _sdpxL::P64 = R2;
           R2 = R3;
           R1 = _sdpxL::P64;
           P64[Sp - 8] = _sdpxL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqZP() //  [R1]
         { info_tbl: [(cdqZP,
                       label: block_cdqZP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqZP: // global
           I64[Sp - 8] = block_cdqZT_info;
           _sdpxO::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sdpxO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udr0s; else goto cdqZU;
       udr0s: // global
           call _cdqZT(R1) args: 0, res: 0, upd: 0;
       cdqZU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdqZT() //  [R1]
         { info_tbl: [(cdqZT,
                       label: block_cdqZT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdqZT: // global
           _sdpxO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdr0j; else goto cdr0n;
       cdr0j: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _sdpxO::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdr0n: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdr0q; else goto cdr0p;
       cdr0q: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdr0p: // global
           _sdpxR::P64 = P64[R1 + 6];
           I64[Hp - 96] = ds1_sdpxS_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sdpxR::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cdqZZ::P64 = Hp - 96;
           P64[Hp - 48] = _cdqZZ::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdqZZ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 14;
           R1 = _sdpxO::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.697583249 UTC

[section ""data" . Data.List.NonEmpty.unfold_closure" {
     Data.List.NonEmpty.unfold_closure:
         const Data.List.NonEmpty.unfold_info;
 },
 Data.List.NonEmpty.unfold_entry() //  [R2, R3]
         { info_tbl: [(cdr11,
                       label: Data.List.NonEmpty.unfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr11: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdr12; else goto cdr13;
       cdr12: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr13: // global
           I64[Sp - 8] = block_cdr0Y_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wunfold_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdr0Y() //  [R1, R2]
         { info_tbl: [(cdr0Y,
                       label: block_cdr0Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr0Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr16; else goto cdr15;
       cdr16: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdr15: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.703522635 UTC

[section ""cstring" . lvl_rdpwt_bytes" {
     lvl_rdpwt_bytes:
         I8[] [78,111,110,69,109,112,116,121,46,102,114,111,109,76,105,115,116,58,32,101,109,112,116,121,32,108,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.706129539 UTC

[section ""data" . Data.List.NonEmpty.cycle1_closure" {
     Data.List.NonEmpty.cycle1_closure:
         const Data.List.NonEmpty.cycle1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.List.NonEmpty.cycle1_entry() //  [R1]
         { info_tbl: [(cdr1p,
                       label: Data.List.NonEmpty.cycle1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr1p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdr1q; else goto cdr1r;
       cdr1q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdr1r: // global
           (_cdr1k::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdr1k::I64 == 0) goto cdr1m; else goto cdr1l;
       cdr1m: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdr1l: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdr1k::I64;
           I64[Sp - 24] = block_cdr1n_info;
           R2 = lvl_rdpwt_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdr1n() //  [R1]
         { info_tbl: [(cdr1n,
                       label: block_cdr1n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr1n: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.714609256 UTC

[section ""data" . Data.List.NonEmpty.fromList_closure" {
     Data.List.NonEmpty.fromList_closure:
         const Data.List.NonEmpty.fromList_info;
         const 0;
 },
 Data.List.NonEmpty.fromList_entry() //  [R2]
         { info_tbl: [(cdr1Q,
                       label: Data.List.NonEmpty.fromList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr1Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdr1R; else goto cdr1S;
       cdr1R: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.fromList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdr1S: // global
           I64[Sp - 8] = block_cdr1J_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udr22; else goto cdr1K;
       udr22: // global
           call _cdr1J(R1) args: 0, res: 0, upd: 0;
       cdr1K: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdr1J() //  [R1]
         { info_tbl: [(cdr1J,
                       label: block_cdr1J_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr1J: // global
           if (R1 & 7 == 1) goto cdr1N; else goto cdr1O;
       cdr1N: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdr1O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr21; else goto cdr20;
       cdr21: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdr20: // global
           _sdpyd::P64 = P64[R1 + 6];
           _sdpye::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyd::P64;
           P64[Hp] = _sdpye::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.721186485 UTC

[section ""data" . Data.List.NonEmpty.reverse_closure" {
     Data.List.NonEmpty.reverse_closure:
         const Data.List.NonEmpty.reverse_info;
         const 0;
 },
 Data.List.NonEmpty.reverse_entry() //  [R2]
         { info_tbl: [(cdr2t,
                       label: Data.List.NonEmpty.reverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr2t: // global
           _sdpyf::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdr2u; else goto cdr2v;
       cdr2v: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdr2x; else goto cdr2w;
       cdr2x: // global
           HpAlloc = 72;
           goto cdr2u;
       cdr2u: // global
           R2 = _sdpyf::P64;
           R1 = Data.List.NonEmpty.reverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdr2w: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpyf::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpyf::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdr2n_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp - 8;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdr2n() //  [R1]
         { info_tbl: [(cdr2n,
                       label: block_cdr2n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr2n: // global
           if (R1 & 7 == 1) goto cdr2q; else goto cdr2r;
       cdr2q: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdr2r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr2G; else goto cdr2F;
       cdr2G: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdr2F: // global
           _sdpyr::P64 = P64[R1 + 6];
           _sdpys::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyr::P64;
           P64[Hp] = _sdpys::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.72886286 UTC

[section ""data" . Data.List.NonEmpty.sortBy_closure" {
     Data.List.NonEmpty.sortBy_closure:
         const Data.List.NonEmpty.sortBy_info;
         const 0;
 },
 Data.List.NonEmpty.sortBy_entry() //  [R2, R3]
         { info_tbl: [(cdr38,
                       label: Data.List.NonEmpty.sortBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr38: // global
           _sdpyu::P64 = R3;
           _sdpyt::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdr39; else goto cdr3a;
       cdr3a: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdr3c; else goto cdr3b;
       cdr3c: // global
           HpAlloc = 72;
           goto cdr39;
       cdr39: // global
           R3 = _sdpyu::P64;
           R2 = _sdpyt::P64;
           R1 = Data.List.NonEmpty.sortBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr3b: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpyu::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpyu::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdr32_info;
           R3 = Hp - 14;
           R2 = _sdpyt::P64;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdr32() //  [R1]
         { info_tbl: [(cdr32,
                       label: block_cdr32_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr32: // global
           if (R1 & 7 == 1) goto cdr35; else goto cdr36;
       cdr35: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdr36: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr3l; else goto cdr3k;
       cdr3l: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdr3k: // global
           _sdpyF::P64 = P64[R1 + 6];
           _sdpyG::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyF::P64;
           P64[Hp] = _sdpyG::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.737233242 UTC

[section ""data" . Data.List.NonEmpty.sortWith_closure" {
     Data.List.NonEmpty.sortWith_closure:
         const Data.List.NonEmpty.sortWith_info;
         const 0;
 },
 sat_sdpyK_entry() //  [R1, R2, R3]
         { info_tbl: [(cdr3M,
                       label: sat_sdpyK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr3M: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Ord.comparing_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.sortWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdr3V,
                       label: Data.List.NonEmpty.sortWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr3V: // global
           _sdpyJ::P64 = R4;
           _sdpyI::P64 = R3;
           _sdpyH::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdr3W; else goto cdr3X;
       cdr3X: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdr3Z; else goto cdr3Y;
       cdr3Z: // global
           HpAlloc = 96;
           goto cdr3W;
       cdr3W: // global
           R4 = _sdpyJ::P64;
           R3 = _sdpyI::P64;
           R2 = _sdpyH::P64;
           R1 = Data.List.NonEmpty.sortWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr3Y: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpyJ::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpyJ::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdpyK_info;
           P64[Hp - 8] = _sdpyH::P64;
           P64[Hp] = _sdpyI::P64;
           I64[Sp - 8] = block_cdr3P_info;
           R3 = Hp - 38;
           R2 = Hp - 14;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdr3P() //  [R1]
         { info_tbl: [(cdr3P,
                       label: block_cdr3P_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr3P: // global
           if (R1 & 7 == 1) goto cdr3S; else goto cdr3T;
       cdr3S: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdr3T: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr48; else goto cdr47;
       cdr48: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdr47: // global
           _sdpyW::P64 = P64[R1 + 6];
           _sdpyX::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpyW::P64;
           P64[Hp] = _sdpyX::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.747414914 UTC

[section ""data" . Data.List.NonEmpty.sort_closure" {
     Data.List.NonEmpty.sort_closure:
         const Data.List.NonEmpty.sort_info;
         const 0;
 },
 sat_sdpz0_entry() //  [R1]
         { info_tbl: [(cdr4B,
                       label: sat_sdpz0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr4B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdr4C; else goto cdr4D;
       cdr4C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdr4D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.sort_entry() //  [R2, R3]
         { info_tbl: [(cdr4K,
                       label: Data.List.NonEmpty.sort_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr4K: // global
           _sdpyZ::P64 = R3;
           _sdpyY::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdr4L; else goto cdr4M;
       cdr4M: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdr4O; else goto cdr4N;
       cdr4O: // global
           HpAlloc = 96;
           goto cdr4L;
       cdr4L: // global
           R3 = _sdpyZ::P64;
           R2 = _sdpyY::P64;
           R1 = Data.List.NonEmpty.sort_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr4N: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpyZ::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpyZ::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdpz0_info;
           P64[Hp] = _sdpyY::P64;
           I64[Sp - 8] = block_cdr4E_info;
           R3 = Hp - 38;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdr4E() //  [R1]
         { info_tbl: [(cdr4E,
                       label: block_cdr4E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr4E: // global
           if (R1 & 7 == 1) goto cdr4H; else goto cdr4I;
       cdr4H: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdr4I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr4X; else goto cdr4W;
       cdr4X: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdr4W: // global
           _sdpzc::P64 = P64[R1 + 6];
           _sdpzd::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpzc::P64;
           P64[Hp] = _sdpzd::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.758422365 UTC

[section ""data" . Data.List.NonEmpty.inits_closure" {
     Data.List.NonEmpty.inits_closure:
         const Data.List.NonEmpty.inits_info;
         const 0;
 },
 sat_sdpzg_entry() //  [R1]
         { info_tbl: [(cdr5o,
                       label: sat_sdpzg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr5o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdr5p; else goto cdr5q;
       cdr5p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdr5q: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Foldable.toList_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.inits_entry() //  [R2, R3]
         { info_tbl: [(cdr5u,
                       label: Data.List.NonEmpty.inits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr5u: // global
           _sdpzf::P64 = R3;
           _sdpze::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdr5v; else goto cdr5w;
       cdr5w: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdr5y; else goto cdr5x;
       cdr5y: // global
           HpAlloc = 32;
           goto cdr5v;
       cdr5v: // global
           R3 = _sdpzf::P64;
           R2 = _sdpze::P64;
           R1 = Data.List.NonEmpty.inits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr5x: // global
           I64[Hp - 24] = sat_sdpzg_info;
           P64[Hp - 8] = _sdpze::P64;
           P64[Hp] = _sdpzf::P64;
           I64[Sp - 8] = block_cdr5r_info;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call Data.OldList.$winits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdr5r() //  [R1, R2]
         { info_tbl: [(cdr5r,
                       label: block_cdr5r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr5r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr5B; else goto cdr5A;
       cdr5B: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdr5A: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.766849646 UTC

[section ""data" . Data.List.NonEmpty.tails1_closure" {
     Data.List.NonEmpty.tails1_closure:
         const Data.List.NonEmpty.tails1_info;
 },
 sat_sdpzo_entry() //  [R1]
         { info_tbl: [(cdr65,
                       label: sat_sdpzo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr65: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdr66; else goto cdr67;
       cdr66: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdr67: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdr5Y_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udr6e; else goto cdr5Z;
       udr6e: // global
           call _cdr5Y(R1) args: 0, res: 0, upd: 0;
       cdr5Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdr5Y() //  [R1]
         { info_tbl: [(cdr5Y,
                       label: block_cdr5Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr5Y: // global
           if (R1 & 7 == 1) goto cdr62; else goto cdr63;
       cdr62: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdr63: // global
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call Data.List.NonEmpty.tails1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.tails1_entry() //  [R2]
         { info_tbl: [(cdr6g,
                       label: Data.List.NonEmpty.tails1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr6g: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdr6k; else goto cdr6j;
       cdr6k: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.List.NonEmpty.tails1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdr6j: // global
           I64[Hp - 40] = sat_sdpzo_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.774925918 UTC

[section ""data" . Data.List.NonEmpty.tails_closure" {
     Data.List.NonEmpty.tails_closure:
         const Data.List.NonEmpty.tails_info;
         const 0;
 },
 sat_sdpzr_entry() //  [R1]
         { info_tbl: [(cdr6K,
                       label: sat_sdpzr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr6K: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdr6L; else goto cdr6M;
       cdr6L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdr6M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Foldable.toList_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.tails_entry() //  [R2, R3]
         { info_tbl: [(cdr6T,
                       label: Data.List.NonEmpty.tails_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr6T: // global
           _sdpzq::P64 = R3;
           _sdpzp::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdr6U; else goto cdr6V;
       cdr6V: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdr6X; else goto cdr6W;
       cdr6X: // global
           HpAlloc = 32;
           goto cdr6U;
       cdr6U: // global
           R3 = _sdpzq::P64;
           R2 = _sdpzp::P64;
           R1 = Data.List.NonEmpty.tails_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr6W: // global
           I64[Hp - 24] = sat_sdpzr_info;
           P64[Hp - 8] = _sdpzp::P64;
           P64[Hp] = _sdpzq::P64;
           I64[Sp - 8] = block_cdr6N_info;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call Data.List.NonEmpty.tails1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdr6N() //  [R1]
         { info_tbl: [(cdr6N,
                       label: block_cdr6N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr6N: // global
           if (R1 & 7 == 1) goto cdr6Q; else goto cdr6R;
       cdr6Q: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdr6R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr76; else goto cdr75;
       cdr76: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdr75: // global
           _sdpzu::P64 = P64[R1 + 6];
           _sdpzv::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpzu::P64;
           P64[Hp] = _sdpzv::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.784149161 UTC

[section ""data" . Data.List.NonEmpty.insert_closure" {
     Data.List.NonEmpty.insert_closure:
         const Data.List.NonEmpty.insert_info;
 },
 sat_sdpzA_entry() //  [R1]
         { info_tbl: [(cdr7A,
                       label: sat_sdpzA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr7A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdr7B; else goto cdr7C;
       cdr7B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdr7C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.insert_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdr7D,
                       label: Data.List.NonEmpty.insert_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr7D: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdr7H; else goto cdr7I;
       cdr7H: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.insert_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr7I: // global
           I64[Sp - 24] = block_cdr7s_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdr7s() //  [R1]
         { info_tbl: [(cdr7s,
                       label: block_cdr7s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr7s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr7L; else goto cdr7K;
       cdr7L: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdr7K: // global
           I64[Hp - 16] = sat_sdpzA_info;
           P64[Hp] = P64[Sp + 8];
           _sdpzy::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdr7E_info;
           R4 = R1;
           R3 = _sdpzy::P64;
           R2 = Hp - 16;
           Sp = Sp + 16;
           call Data.OldList.$winsertBy_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdr7E() //  [R1, R2]
         { info_tbl: [(cdr7E,
                       label: block_cdr7E_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr7E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr7O; else goto cdr7N;
       cdr7O: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdr7N: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.794566849 UTC

[section ""data" . Data.List.NonEmpty.scanl_closure" {
     Data.List.NonEmpty.scanl_closure:
         const Data.List.NonEmpty.scanl_info;
 },
 sat_sdpzJ_entry() //  [R1]
         { info_tbl: [(cdr8i,
                       label: sat_sdpzJ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr8i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdr8j; else goto cdr8k;
       cdr8j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdr8k: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Foldable.toList_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdpzN_entry() //  [R1]
         { info_tbl: [(cdr8n,
                       label: sat_sdpzN_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr8n: // global
           _sdpzN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdr8o; else goto cdr8p;
       cdr8p: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdr8r; else goto cdr8q;
       cdr8r: // global
           HpAlloc = 32;
           goto cdr8o;
       cdr8o: // global
           R1 = _sdpzN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdr8q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpzN::P64;
           _sdpzF::P64 = P64[_sdpzN::P64 + 16];
           _sdpzG::P64 = P64[_sdpzN::P64 + 24];
           _sdpzH::P64 = P64[_sdpzN::P64 + 32];
           _sdpzI::P64 = P64[_sdpzN::P64 + 40];
           I64[Hp - 24] = sat_sdpzJ_info;
           P64[Hp - 8] = _sdpzF::P64;
           P64[Hp] = _sdpzI::P64;
           I64[Sp - 24] = block_cdr8l_info;
           R4 = Hp - 24;
           R3 = _sdpzH::P64;
           R2 = _sdpzG::P64;
           Sp = Sp - 24;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdr8l() //  [R2]
         { info_tbl: [(cdr8l,
                       label: block_cdr8l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr8l: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.scanl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdr8u,
                       label: Data.List.NonEmpty.scanl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr8u: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdr8y; else goto cdr8x;
       cdr8y: // global
           HpAlloc = 72;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr8x: // global
           I64[Hp - 64] = sat_sdpzN_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.805130327 UTC

[section ""data" . Data.List.NonEmpty.scanr_closure" {
     Data.List.NonEmpty.scanr_closure:
         const Data.List.NonEmpty.scanr_info;
 },
 Data.List.NonEmpty.scanr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdr8Z,
                       label: Data.List.NonEmpty.scanr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr8Z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdr95; else goto cdr96;
       cdr95: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr96: // global
           I64[Sp - 24] = block_cdr8X_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdr8X() //  [R1]
         { info_tbl: [(cdr8X,
                       label: block_cdr8X_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr8X: // global
           _sdpzQ::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdr92_info;
           R4 = R1;
           R3 = _sdpzQ::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdr92() //  [R1, R2]
         { info_tbl: [(cdr92,
                       label: block_cdr92_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr92: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdr9a; else goto cdr99;
       cdr9a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdr99: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.813367722 UTC

[section ""data" . Data.List.NonEmpty.scanl1_closure" {
     Data.List.NonEmpty.scanl1_closure:
         const Data.List.NonEmpty.scanl1_info;
 },
 sat_sdpA8_entry() //  [R1]
         { info_tbl: [(cdr9z,
                       label: sat_sdpA8_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr9z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdr9D; else goto cdr9E;
       cdr9D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdr9E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdr9w_info;
           _sdpzW::P64 = P64[R1 + 16];
           _sdpzY::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdpzW::P64;
           P64[Sp - 24] = _sdpzY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udr9I; else goto cdr9x;
       udr9I: // global
           call _cdr9w(R1) args: 0, res: 0, upd: 0;
       cdr9x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdr9w() //  [R1]
         { info_tbl: [(cdr9w,
                       label: block_cdr9w_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr9w: // global
           _sdpzY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdr9C_info;
           R4 = P64[R1 + 15];
           R3 = _sdpzY::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdr9C() //  [R2]
         { info_tbl: [(cdr9C,
                       label: block_cdr9C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr9C: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.scanl1_entry() //  [R2, R3]
         { info_tbl: [(cdr9K,
                       label: Data.List.NonEmpty.scanl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdr9K: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdr9O; else goto cdr9N;
       cdr9O: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdr9N: // global
           I64[Hp - 80] = stg_sel_0_upd_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sdpA8_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           _cdr9r::P64 = Hp - 80;
           P64[Hp - 24] = _cdr9r::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _cdr9r::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.823421038 UTC

[section ""data" . Data.List.NonEmpty.scanr1_closure" {
     Data.List.NonEmpty.scanr1_closure:
         const Data.List.NonEmpty.scanr1_info;
         const 0;
 },
 Data.List.NonEmpty.scanr1_entry() //  [R2, R3]
         { info_tbl: [(cdral,
                       label: Data.List.NonEmpty.scanr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdral: // global
           _sdpAa::P64 = R3;
           _sdpA9::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdram; else goto cdran;
       cdran: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdrap; else goto cdrao;
       cdrap: // global
           HpAlloc = 72;
           goto cdram;
       cdram: // global
           R3 = _sdpAa::P64;
           R2 = _sdpA9::P64;
           R1 = Data.List.NonEmpty.scanr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrao: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpAa::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpAa::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdraf_info;
           R3 = Hp - 14;
           R2 = _sdpA9::P64;
           Sp = Sp - 8;
           call GHC.List.scanr1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdraf() //  [R1]
         { info_tbl: [(cdraf,
                       label: block_cdraf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdraf: // global
           if (R1 & 7 == 1) goto cdrai; else goto cdraj;
       cdrai: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdraj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdray; else goto cdrax;
       cdray: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrax: // global
           _sdpAl::P64 = P64[R1 + 6];
           _sdpAm::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpAl::P64;
           P64[Hp] = _sdpAm::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.830144313 UTC

[section ""data" . Data.List.NonEmpty.toList_closure" {
     Data.List.NonEmpty.toList_closure:
         const Data.List.NonEmpty.toList_info;
 },
 Data.List.NonEmpty.toList_entry() //  [R2]
         { info_tbl: [(cdraU,
                       label: Data.List.NonEmpty.toList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdraU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdraY; else goto cdraX;
       cdraY: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.toList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdraX: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.83465584 UTC

[section ""data" . Data.List.NonEmpty.$wtake_closure" {
     Data.List.NonEmpty.$wtake_closure:
         const Data.List.NonEmpty.$wtake_info;
 },
 Data.List.NonEmpty.$wtake_entry() //  [R2, R3]
         { info_tbl: [(cdrbf,
                       label: Data.List.NonEmpty.$wtake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrbf: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdrbj; else goto cdrbi;
       cdrbj: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wtake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrbi: // global
           if (%MO_S_Ge_W64(0, R2)) goto cdrbd; else goto cdrbe;
       cdrbd: // global
           Hp = Hp - 72;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrbe: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.839475175 UTC

[section ""data" . Data.List.NonEmpty.take_closure" {
     Data.List.NonEmpty.take_closure:
         const Data.List.NonEmpty.take_info;
 },
 Data.List.NonEmpty.take_entry() //  [R2, R3]
         { info_tbl: [(cdrbD,
                       label: Data.List.NonEmpty.take_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrbD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrbE; else goto cdrbF;
       cdrbE: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.take_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrbF: // global
           I64[Sp - 16] = block_cdrbA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udrbJ; else goto cdrbB;
       udrbJ: // global
           call _cdrbA(R1) args: 0, res: 0, upd: 0;
       cdrbB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrbA() //  [R1]
         { info_tbl: [(cdrbA,
                       label: block_cdrbA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrbA: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wtake_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.845270317 UTC

[section ""data" . Data.List.NonEmpty.$wunsafeDrop_closure" {
     Data.List.NonEmpty.$wunsafeDrop_closure:
         const Data.List.NonEmpty.$wunsafeDrop_info;
 },
 Data.List.NonEmpty.$wunsafeDrop_entry() //  [R2, R3]
         { info_tbl: [(cdrc4,
                       label: Data.List.NonEmpty.$wunsafeDrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrc4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrc5; else goto udrcj;
       cdrc5: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunsafeDrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udrcj: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdrbU() args: 0, res: 0, upd: 0;
     }
 },
 _cdrbU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrbU: // global
           I64[Sp - 8] = block_cdrbX_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udrcl; else goto cdrbY;
       udrcl: // global
           call _cdrbX(R1) args: 0, res: 0, upd: 0;
       cdrbY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrbX() //  [R1]
         { info_tbl: [(cdrbX,
                       label: block_cdrbX_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrbX: // global
           if (R1 & 7 == 1) goto cdrc1; else goto cdrc2;
       cdrc1: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrc2: // global
           _sdpAQ::P64 = P64[R1 + 14];
           _sdpAR::I64 = I64[Sp + 8];
           if (_sdpAR::I64 != 1) goto cdrcf; else goto cdrcg;
       cdrcf: // global
           I64[Sp + 8] = _sdpAR::I64 - 1;
           P64[Sp + 16] = _sdpAQ::P64;
           Sp = Sp + 8;
           call _cdrbU() args: 0, res: 0, upd: 0;
       cdrcg: // global
           R1 = _sdpAQ::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.852625854 UTC

[section ""data" . Data.List.NonEmpty.$wdrop_closure" {
     Data.List.NonEmpty.$wdrop_closure:
         const Data.List.NonEmpty.$wdrop_info;
 },
 Data.List.NonEmpty.$wdrop_entry() //  [R2, R3]
         { info_tbl: [(cdrcO,
                       label: Data.List.NonEmpty.$wdrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrcO: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdrcS; else goto cdrcR;
       cdrcS: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wdrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrcR: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cdrcM; else goto cdrcN;
       cdrcM: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call Data.List.NonEmpty.$wunsafeDrop_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
       cdrcN: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.857212885 UTC

[section ""data" . Data.List.NonEmpty.drop_closure" {
     Data.List.NonEmpty.drop_closure:
         const Data.List.NonEmpty.drop_info;
 },
 Data.List.NonEmpty.drop_entry() //  [R2, R3]
         { info_tbl: [(cdrdh,
                       label: Data.List.NonEmpty.drop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrdh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrdi; else goto cdrdj;
       cdrdi: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.drop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrdj: // global
           I64[Sp - 16] = block_cdrde_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udrdn; else goto cdrdf;
       udrdn: // global
           call _cdrde(R1) args: 0, res: 0, upd: 0;
       cdrdf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrde() //  [R1]
         { info_tbl: [(cdrde,
                       label: block_cdrde_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrde: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wdrop_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.863084172 UTC

[section ""data" . Data.List.NonEmpty.splitAt_closure" {
     Data.List.NonEmpty.splitAt_closure:
         const Data.List.NonEmpty.splitAt_info;
 },
 Data.List.NonEmpty.splitAt_entry() //  [R2, R3]
         { info_tbl: [(cdrdE,
                       label: Data.List.NonEmpty.splitAt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrdE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrdF; else goto cdrdG;
       cdrdF: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.splitAt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrdG: // global
           I64[Sp - 16] = block_cdrdB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udre6; else goto cdrdC;
       udre6: // global
           call _cdrdB(R1) args: 0, res: 0, upd: 0;
       cdrdC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrdB() //  [R1]
         { info_tbl: [(cdrdB,
                       label: block_cdrdB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrdB: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdrdL; else goto cdrdK;
       cdrdL: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrdK: // global
           _sdpBi::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto cdrdW; else goto cdre5;
       cdrdW: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpBi::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpBi::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           _cdrdR::P64 = Hp - 38;
           Hp = Hp - 24;
           I64[Sp + 8] = block_cdrdS_info;
           R3 = _cdrdR::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
       cdre5: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpBi::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpBi::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = Hp - 38;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdrdS() //  [R1, R2]
         { info_tbl: [(cdrdS,
                       label: block_cdrdS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrdS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrdZ; else goto cdrdY;
       cdrdZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdrdY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.872131763 UTC

[section ""data" . Data.List.NonEmpty.takeWhile_closure" {
     Data.List.NonEmpty.takeWhile_closure:
         const Data.List.NonEmpty.takeWhile_info;
 },
 Data.List.NonEmpty.takeWhile_entry() //  [R2, R3]
         { info_tbl: [(cdrex,
                       label: Data.List.NonEmpty.takeWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrex: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdreB; else goto cdreA;
       cdreB: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.takeWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdreA: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.876785527 UTC

[section ""data" . Data.List.NonEmpty.dropWhile_closure" {
     Data.List.NonEmpty.dropWhile_closure:
         const Data.List.NonEmpty.dropWhile_info;
 },
 Data.List.NonEmpty.dropWhile_entry() //  [R2, R3]
         { info_tbl: [(cdreP,
                       label: Data.List.NonEmpty.dropWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdreP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdreT; else goto cdreS;
       cdreT: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.dropWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdreS: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.dropWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.880982153 UTC

[section ""data" . Data.List.NonEmpty.span_closure" {
     Data.List.NonEmpty.span_closure:
         const Data.List.NonEmpty.span_info;
 },
 Data.List.NonEmpty.span_entry() //  [R2, R3]
         { info_tbl: [(cdrfa,
                       label: Data.List.NonEmpty.span_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrfa: // global
           _sdpC4::P64 = R3;
           _sdpC3::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdrfb; else goto cdrfc;
       cdrfc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdrfe; else goto cdrfd;
       cdrfe: // global
           HpAlloc = 72;
           goto cdrfb;
       cdrfb: // global
           R3 = _sdpC4::P64;
           R2 = _sdpC3::P64;
           R1 = Data.List.NonEmpty.span_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrfd: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpC4::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpC4::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdrf7_info;
           R3 = Hp - 14;
           R2 = _sdpC3::P64;
           Sp = Sp - 8;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdrf7() //  [R1, R2]
         { info_tbl: [(cdrf7,
                       label: block_cdrf7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrf7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrfh; else goto cdrfg;
       cdrfh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdrfg: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.887718967 UTC

[section ""data" . Data.List.NonEmpty.$wbreak_closure" {
     Data.List.NonEmpty.$wbreak_closure:
         const Data.List.NonEmpty.$wbreak_info;
 },
 sat_sdpCl_entry() //  [R1, R2]
         { info_tbl: [(cdrfL,
                       label: sat_sdpCl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrfL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdrfM; else goto cdrfN;
       cdrfM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdrfN: // global
           I64[Sp - 8] = block_cdrfF_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrfF() //  [R1]
         { info_tbl: [(cdrfF,
                       label: block_cdrfF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrfF: // global
           if (R1 & 7 == 1) goto cdrfI; else goto cdrfJ;
       cdrfI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrfJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wbreak_entry() //  [R2, R3]
         { info_tbl: [(cdrfU,
                       label: Data.List.NonEmpty.$wbreak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrfU: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdrfY; else goto cdrfX;
       cdrfY: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wbreak_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrfX: // global
           I64[Hp - 80] = stg_sel_1_upd_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = stg_sel_0_upd_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           I64[Hp - 8] = sat_sdpCl_info;
           P64[Hp] = R2;
           R3 = Hp - 30;
           R2 = Hp - 7;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.895551639 UTC

[section ""data" . Data.List.NonEmpty.break_closure" {
     Data.List.NonEmpty.break_closure:
         const Data.List.NonEmpty.break_info;
 },
 Data.List.NonEmpty.break_entry() //  [R2, R3]
         { info_tbl: [(cdrgn,
                       label: Data.List.NonEmpty.break_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrgn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdrgo; else goto cdrgp;
       cdrgo: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.break_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrgp: // global
           I64[Sp - 8] = block_cdrgk_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wbreak_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdrgk() //  [R1, R2]
         { info_tbl: [(cdrgk,
                       label: block_cdrgk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrgk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrgs; else goto cdrgr;
       cdrgs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdrgr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.901698622 UTC

[section ""data" . Data.List.NonEmpty.filter_closure" {
     Data.List.NonEmpty.filter_closure:
         const Data.List.NonEmpty.filter_info;
 },
 Data.List.NonEmpty.filter_entry() //  [R2, R3]
         { info_tbl: [(cdrgJ,
                       label: Data.List.NonEmpty.filter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrgJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdrgN; else goto cdrgM;
       cdrgN: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.filter_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrgM: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.906894341 UTC

[section ""data" . Data.List.NonEmpty.$wpartition_closure" {
     Data.List.NonEmpty.$wpartition_closure:
         const Data.List.NonEmpty.$wpartition_info;
 },
 w3_sdpCS_entry() //  [R1]
         { info_tbl: [(cdrhg,
                       label: w3_sdpCS_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrhg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrhh; else goto cdrhi;
       cdrhh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrhi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdrhd_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo_sdpCN_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrhd() //  [R1, R2]
         { info_tbl: [(cdrhd,
                       label: block_cdrhd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrhd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrhl; else goto cdrhk;
       cdrhl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdrhk: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_sdpCN_entry() //  [R1, R2]
         { info_tbl: [(cdrhq,
                       label: $wgo_sdpCN_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrhq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrhr; else goto cdrhs;
       cdrhr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdrhs: // global
           I64[Sp - 24] = block_cdrh3_info;
           _sdpCN::P64 = R1;
           _sdpCL::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdpCL::P64;
           P64[Sp - 8] = _sdpCN::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udrhU; else goto cdrh4;
       udrhU: // global
           call _cdrh3(R1) args: 0, res: 0, upd: 0;
       cdrh4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrh3() //  [R1]
         { info_tbl: [(cdrh3,
                       label: block_cdrh3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrh3: // global
           if (R1 & 7 == 1) goto cdrhn; else goto cdrho;
       cdrhn: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdrho: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdrhy; else goto cdrhx;
       cdrhy: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrhx: // global
           _sdpCQ::P64 = P64[R1 + 6];
           _sdpCR::P64 = P64[R1 + 14];
           I64[Hp - 24] = w3_sdpCS_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdpCR::P64;
           I64[Sp] = block_cdrhv_info;
           R2 = _sdpCQ::P64;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdpCQ::P64;
           P64[Sp + 16] = Hp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrhv() //  [R1]
         { info_tbl: [(cdrhv,
                       label: block_cdrhv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrhv: // global
           _cdrh9::P64 = P64[Sp + 16];
           _sdpCQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdrhG; else goto cdrhP;
       cdrhG: // global
           Hp = Hp + 72;
           _sdpCW::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdrhS; else goto cdrhI;
       cdrhI: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cdrh9::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sdpCQ::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cdrh9::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdrhP: // global
           Hp = Hp + 72;
           _sdpCW::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdrhS; else goto cdrhR;
       cdrhS: // global
           HpAlloc = 72;
           R1 = _sdpCW::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrhR: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cdrh9::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdrh9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdpCQ::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wpartition_entry() //  [R2, R3]
         { info_tbl: [(cdrhY,
                       label: Data.List.NonEmpty.$wpartition_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrhY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdri2; else goto cdri1;
       cdri2: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wpartition_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdri1: // global
           I64[Hp - 80] = $wgo_sdpCN_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 14;
           R1 = Hp - 79;
           call $wgo_sdpCN_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.922832615 UTC

[section ""data" . Data.List.NonEmpty.partition_closure" {
     Data.List.NonEmpty.partition_closure:
         const Data.List.NonEmpty.partition_info;
 },
 Data.List.NonEmpty.partition_entry() //  [R2, R3]
         { info_tbl: [(cdriK,
                       label: Data.List.NonEmpty.partition_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdriK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdriL; else goto cdriM;
       cdriL: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.partition_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdriM: // global
           I64[Sp - 8] = block_cdriH_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wpartition_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdriH() //  [R1, R2]
         { info_tbl: [(cdriH,
                       label: block_cdriH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdriH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdriP; else goto cdriO;
       cdriP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdriO: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.92899539 UTC

[section ""data" . Data.List.NonEmpty.cycle_closure" {
     Data.List.NonEmpty.cycle_closure:
         const Data.List.NonEmpty.cycle_info;
         const 0;
 },
 xs'_sdpDu_entry() //  [R1]
         { info_tbl: [(cdrja,
                       label: xs'_sdpDu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrja: // global
           _sdpDu::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdrjb; else goto cdrjc;
       cdrjc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdrje; else goto cdrjd;
       cdrje: // global
           HpAlloc = 72;
           goto cdrjb;
       cdrjb: // global
           R1 = _sdpDu::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrjd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpDu::P64;
           _sdpDt::P64 = P64[_sdpDu::P64 + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdpDt::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpDt::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = _sdpDu::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.cycle_entry() //  [R2]
         { info_tbl: [(cdrjm,
                       label: Data.List.NonEmpty.cycle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrjm: // global
           _sdpDt::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdrjn; else goto cdrjo;
       cdrjo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrjq; else goto cdrjp;
       cdrjq: // global
           HpAlloc = 24;
           goto cdrjn;
       cdrjn: // global
           R2 = _sdpDt::P64;
           R1 = Data.List.NonEmpty.cycle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdrjp: // global
           I64[Hp - 16] = xs'_sdpDu_info;
           P64[Hp] = _sdpDt::P64;
           I64[Sp - 8] = block_cdrjf_info;
           R1 = Hp - 16;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udrjA; else goto cdrjg;
       udrjA: // global
           call _cdrjf(R1) args: 0, res: 0, upd: 0;
       cdrjg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrjf() //  [R1]
         { info_tbl: [(cdrjf,
                       label: block_cdrjf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrjf: // global
           if (R1 & 7 == 1) goto cdrjj; else goto cdrjk;
       cdrjj: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdrjk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrjz; else goto cdrjy;
       cdrjz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrjy: // global
           _sdpDG::P64 = P64[R1 + 6];
           _sdpDH::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpDG::P64;
           P64[Hp] = _sdpDH::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.939475015 UTC

[section ""data" . Data.List.NonEmpty.$wtranspose_closure" {
     Data.List.NonEmpty.$wtranspose_closure:
         const Data.List.NonEmpty.$wtranspose_info;
         const 0;
 },
 sat_sdpE2_entry() //  [R1]
         { info_tbl: [(cdrk9,
                       label: sat_sdpE2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrk9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrka; else goto cdrkb;
       cdrka: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrkb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdrk6_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udrkf; else goto cdrk7;
       udrkf: // global
           call _cdrk6(R1) args: 0, res: 0, upd: 0;
       cdrk7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrk6() //  [R1]
         { info_tbl: [(cdrk6,
                       label: block_cdrk6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrk6: // global
           R3 = P64[R1 + 15];
           R2 = Data.List.NonEmpty.toList_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpDX_entry() //  [R1]
         { info_tbl: [(cdrkn,
                       label: sat_sdpDX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrkn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrkr; else goto cdrks;
       cdrkr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrks: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdrkk_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udrkA; else goto cdrkl;
       udrkA: // global
           call _cdrkk(R1) args: 0, res: 0, upd: 0;
       cdrkl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrkk() //  [R1]
         { info_tbl: [(cdrkk,
                       label: block_cdrkk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrkk: // global
           I64[Sp] = block_cdrkq_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udrkz; else goto cdrku;
       udrkz: // global
           call _cdrkq(R1) args: 0, res: 0, upd: 0;
       cdrku: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrkq() //  [R1]
         { info_tbl: [(cdrkq,
                       label: block_cdrkq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrkq: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpDQ_entry() //  [R1]
         { info_tbl: [(cdrkI,
                       label: sat_sdpDQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrkI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrkM; else goto cdrkN;
       cdrkM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrkN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdrkF_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udrkV; else goto cdrkG;
       udrkV: // global
           call _cdrkF(R1) args: 0, res: 0, upd: 0;
       cdrkG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrkF() //  [R1]
         { info_tbl: [(cdrkF,
                       label: block_cdrkF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrkF: // global
           I64[Sp] = block_cdrkL_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udrkU; else goto cdrkP;
       udrkU: // global
           call _cdrkL(R1) args: 0, res: 0, upd: 0;
       cdrkP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrkL() //  [R1]
         { info_tbl: [(cdrkL,
                       label: block_cdrkL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrkL: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds_sdpDJ_entry() //  [R1]
         { info_tbl: [(cdrl4,
                       label: ds_sdpDJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrl4: // global
           _sdpDJ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdrl5; else goto cdrl6;
       cdrl6: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdrl8; else goto cdrl7;
       cdrl8: // global
           HpAlloc = 120;
           goto cdrl5;
       cdrl5: // global
           R1 = _sdpDJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrl7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpDJ::P64;
           _sdpDI::P64 = P64[_sdpDJ::P64 + 16];
           I64[Hp - 112] = sat_sdpE2_info;
           P64[Hp - 96] = _sdpDI::P64;
           I64[Hp - 88] = sat_sdpDX_info;
           P64[Hp - 72] = _sdpDI::P64;
           I64[Hp - 64] = sat_sdpDQ_info;
           P64[Hp - 48] = _sdpDI::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 112;
           I64[Sp - 24] = block_cdrkY_info;
           R2 = Hp - 14;
           Sp = Sp - 24;
           call Data.OldList.transpose_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdrkY() //  [R1]
         { info_tbl: [(cdrkY,
                       label: block_cdrkY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrkY: // global
           if (R1 & 7 == 1) goto cdrl1; else goto cdrl2;
       cdrl1: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cdrl2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrlh; else goto cdrlg;
       cdrlh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdrlg: // global
           _sdpE5::P64 = P64[R1 + 6];
           _sdpE6::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpE5::P64;
           P64[Hp] = _sdpE6::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEh_entry() //  [R1]
         { info_tbl: [(cdrlp,
                       label: sat_sdpEh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrlp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrlq; else goto cdrlr;
       cdrlq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrlr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdrlm_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udrlv; else goto cdrln;
       udrlv: // global
           call _cdrlm(R1) args: 0, res: 0, upd: 0;
       cdrln: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrlm() //  [R1]
         { info_tbl: [(cdrlm,
                       label: block_cdrlm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrlm: // global
           R3 = P64[R1 + 15];
           R2 = Data.List.NonEmpty.fromList_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEd_entry() //  [R1]
         { info_tbl: [(cdrlD,
                       label: sat_sdpEd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrlD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrlE; else goto cdrlF;
       cdrlE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrlF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdrlA_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udrm0; else goto cdrlB;
       udrm0: // global
           call _cdrlA(R1) args: 0, res: 0, upd: 0;
       cdrlB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrlA() //  [R1]
         { info_tbl: [(cdrlA,
                       label: block_cdrlA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrlA: // global
           I64[Sp] = block_cdrlI_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udrlZ; else goto cdrlK;
       udrlZ: // global
           call _cdrlI(R1) args: 0, res: 0, upd: 0;
       cdrlK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrlI() //  [R1]
         { info_tbl: [(cdrlI,
                       label: block_cdrlI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrlI: // global
           if (R1 & 7 == 1) goto cdrlQ; else goto cdrlU;
       cdrlQ: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cdrlU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrlX; else goto cdrlW;
       cdrlX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdrlW: // global
           _sdpEb::P64 = P64[R1 + 6];
           _sdpEc::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpEb::P64;
           P64[Hp] = _sdpEc::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wtranspose_entry() //  [R2]
         { info_tbl: [(cdrm1,
                       label: Data.List.NonEmpty.$wtranspose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrm1: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdrm5; else goto cdrm4;
       cdrm5: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wtranspose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdrm4: // global
           I64[Hp - 64] = ds_sdpDJ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdpEh_info;
           _cdrjY::P64 = Hp - 64;
           P64[Hp - 24] = _cdrjY::P64;
           I64[Hp - 16] = sat_sdpEd_info;
           P64[Hp] = _cdrjY::P64;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.971916425 UTC

[section ""data" . Data.List.NonEmpty.transpose_closure" {
     Data.List.NonEmpty.transpose_closure:
         const Data.List.NonEmpty.transpose_info;
         const 0;
 },
 Data.List.NonEmpty.transpose_entry() //  [R2]
         { info_tbl: [(cdrnt,
                       label: Data.List.NonEmpty.transpose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrnt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdrnu; else goto cdrnv;
       cdrnu: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.transpose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdrnv: // global
           I64[Sp - 8] = block_cdrnq_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wtranspose_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdrnq() //  [R1, R2]
         { info_tbl: [(cdrnq,
                       label: block_cdrnq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrnq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrny; else goto cdrnx;
       cdrny: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdrnx: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.978261683 UTC

[section ""data" . Data.List.NonEmpty.map_closure" {
     Data.List.NonEmpty.map_closure:
         const Data.List.NonEmpty.map_info;
 },
 sat_sdpEw_entry() //  [R1]
         { info_tbl: [(cdrnT,
                       label: sat_sdpEw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrnT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdrnU; else goto cdrnV;
       cdrnU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrnV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdrnQ_info;
           _sdpEm::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpEm::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udrnZ; else goto cdrnR;
       udrnZ: // global
           call _cdrnQ(R1) args: 0, res: 0, upd: 0;
       cdrnR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrnQ() //  [R1]
         { info_tbl: [(cdrnQ,
                       label: block_cdrnQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrnQ: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEs_entry() //  [R1]
         { info_tbl: [(cdro5,
                       label: sat_sdpEs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdro5: // global
           _sdpEs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdro6; else goto cdro7;
       cdro7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdro9; else goto cdro8;
       cdro9: // global
           HpAlloc = 24;
           goto cdro6;
       cdro6: // global
           R1 = _sdpEs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdro8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpEs::P64;
           _sdpEm::P64 = P64[_sdpEs::P64 + 16];
           _sdpEn::P64 = P64[_sdpEs::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdpEn::P64;
           R2 = Hp - 16;
           R1 = _sdpEm::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.map_entry() //  [R2, R3]
         { info_tbl: [(cdrob,
                       label: Data.List.NonEmpty.map_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrob: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdrof; else goto cdroe;
       cdrof: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.map_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdroe: // global
           I64[Hp - 80] = sat_sdpEw_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sdpEs_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.988107992 UTC

[section ""data" . Data.List.NonEmpty.some1_closure" {
     Data.List.NonEmpty.some1_closure:
         const Data.List.NonEmpty.some1_info;
 },
 sat_sdpEA_entry() //  [R1]
         { info_tbl: [(cdroH,
                       label: sat_sdpEA_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdroH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdroI; else goto cdroJ;
       cdroI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdroJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.many_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.some1_entry() //  [R2, R3]
         { info_tbl: [(cdroM,
                       label: Data.List.NonEmpty.some1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdroM: // global
           _sdpEy::P64 = R3;
           _sdpEx::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdroN; else goto cdroO;
       cdroO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdroQ; else goto cdroP;
       cdroQ: // global
           HpAlloc = 32;
           goto cdroN;
       cdroN: // global
           R3 = _sdpEy::P64;
           R2 = _sdpEx::P64;
           R1 = Data.List.NonEmpty.some1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdroP: // global
           I64[Hp - 24] = sat_sdpEA_info;
           P64[Hp - 8] = _sdpEx::P64;
           P64[Hp] = _sdpEy::P64;
           I64[Sp - 24] = block_cdroK_info;
           R2 = _sdpEx::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sdpEy::P64;
           Sp = Sp - 24;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdroK() //  [R1]
         { info_tbl: [(cdroK,
                       label: block_cdroK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdroK: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = GHC.Base.:|_closure+2;
           _cdroD::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cdroD::P64;
           Sp = Sp - 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:35.997041846 UTC

[section ""data" . Data.List.NonEmpty.intersperse_closure" {
     Data.List.NonEmpty.intersperse_closure:
         const Data.List.NonEmpty.intersperse_info;
 },
 sat_sdpEN_entry() //  [R1]
         { info_tbl: [(cdrpw,
                       label: sat_sdpEN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrpw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrpx; else goto cdrpy;
       cdrpx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrpy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpEP_entry() //  [R1]
         { info_tbl: [(cdrpz,
                       label: sat_sdpEP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrpz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdrpA; else goto cdrpB;
       cdrpA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrpB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdrph_info;
           _sdpEB::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpEB::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udrpP; else goto cdrpi;
       udrpP: // global
           call _cdrph(R1) args: 0, res: 0, upd: 0;
       cdrpi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrph() //  [R1]
         { info_tbl: [(cdrph,
                       label: block_cdrph_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrph: // global
           I64[Sp] = block_cdrpm_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto udrpO; else goto cdrpn;
       udrpO: // global
           call _cdrpm(R1) args: 0, res: 0, upd: 0;
       cdrpn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrpm() //  [R1]
         { info_tbl: [(cdrpm,
                       label: block_cdrpm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrpm: // global
           if (R1 & 7 == 1) goto cdrpG; else goto cdrpJ;
       cdrpG: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdrpJ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdrpM; else goto cdrpL;
       cdrpM: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdrpL: // global
           _sdpEL::P64 = P64[R1 + 6];
           _sdpEM::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sdpEN_info;
           _sdpEB::P64 = P64[Sp + 8];
           P64[Hp - 56] = _sdpEB::P64;
           P64[Hp - 48] = _sdpEM::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sdpEL::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdpEB::P64;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.intersperse_entry() //  [R2, R3]
         { info_tbl: [(cdrpS,
                       label: Data.List.NonEmpty.intersperse_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrpS: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdrpW; else goto cdrpV;
       cdrpW: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.intersperse_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrpV: // global
           I64[Hp - 72] = sat_sdpEP_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.008690769 UTC

[section ""data" . Data.List.NonEmpty.iterate_closure" {
     Data.List.NonEmpty.iterate_closure:
         const Data.List.NonEmpty.iterate_info;
 },
 sat_sdpEW_entry() //  [R1]
         { info_tbl: [(cdrqC,
                       label: sat_sdpEW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrqC: // global
           _sdpEW::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdrqD; else goto cdrqE;
       cdrqE: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdrqG; else goto cdrqF;
       cdrqG: // global
           HpAlloc = 32;
           goto cdrqD;
       cdrqD: // global
           R1 = _sdpEW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrqF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpEW::P64;
           _sdpEQ::P64 = P64[_sdpEW::P64 + 16];
           _sdpER::P64 = P64[_sdpEW::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpEQ::P64;
           P64[Hp] = _sdpER::P64;
           I64[Sp - 24] = block_cdrqz_info;
           R3 = Hp - 24;
           R2 = _sdpEQ::P64;
           Sp = Sp - 24;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdrqz() //  [R1, R2]
         { info_tbl: [(cdrqz,
                       label: block_cdrqz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrqz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrqJ; else goto cdrqI;
       cdrqJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdrqI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.iterate_entry() //  [R2, R3]
         { info_tbl: [(cdrqL,
                       label: Data.List.NonEmpty.iterate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrqL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdrqP; else goto cdrqO;
       cdrqP: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.iterate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrqO: // global
           I64[Hp - 48] = sat_sdpEW_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.017032646 UTC

[section ""data" . Data.List.NonEmpty.repeat_closure" {
     Data.List.NonEmpty.repeat_closure:
         const Data.List.NonEmpty.repeat_info;
 },
 sat_sdpEY_entry() //  [R1]
         { info_tbl: [(cdrrc,
                       label: sat_sdpEY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrrc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrrd; else goto cdrre;
       cdrrd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrre: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.repeat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.repeat_entry() //  [R2]
         { info_tbl: [(cdrrg,
                       label: Data.List.NonEmpty.repeat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrrg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdrrk; else goto cdrrj;
       cdrrk: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.List.NonEmpty.repeat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdrrj: // global
           I64[Hp - 40] = sat_sdpEY_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.023287161 UTC

[section ""data" . Data.List.NonEmpty.groupBy_$sgroupBy_closure" {
     Data.List.NonEmpty.groupBy_$sgroupBy_closure:
         const Data.List.NonEmpty.groupBy_$sgroupBy_info;
 },
 ds_sdpF4_entry() //  [R1]
         { info_tbl: [(cdrrN,
                       label: ds_sdpF4_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrrN: // global
           _sdpF4::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdrrO; else goto cdrrP;
       cdrrP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdrrR; else goto cdrrQ;
       cdrrR: // global
           HpAlloc = 32;
           goto cdrrO;
       cdrrO: // global
           R1 = _sdpF4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrrQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpF4::P64;
           _sdpEZ::P64 = P64[_sdpF4::P64 + 16];
           _sdpF2::P64 = P64[_sdpF4::P64 + 24];
           _sdpF3::P64 = P64[_sdpF4::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpEZ::P64;
           P64[Hp] = _sdpF2::P64;
           I64[Sp - 24] = block_cdrrK_info;
           R3 = _sdpF3::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdrrK() //  [R1, R2]
         { info_tbl: [(cdrrK,
                       label: block_cdrrK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrrK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrrU; else goto cdrrT;
       cdrrU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdrrT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpFh_entry() //  [R1]
         { info_tbl: [(cdrs2,
                       label: sat_sdpFh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrs2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdrs3; else goto cdrs4;
       cdrs3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrs4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdrrZ_info;
           _sdpEZ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpEZ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udrs8; else goto cdrs0;
       udrs8: // global
           call _cdrrZ(R1) args: 0, res: 0, upd: 0;
       cdrs0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrrZ() //  [R1]
         { info_tbl: [(cdrrZ,
                       label: block_cdrrZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrrZ: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy_$sgroupBy_entry() //  [R2, R3]
         { info_tbl: [(cdrsd,
                       label: Data.List.NonEmpty.groupBy_$sgroupBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrsd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrse; else goto cdrsf;
       cdrse: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy_$sgroupBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrsf: // global
           I64[Sp - 16] = block_cdrrz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udrso; else goto cdrrA;
       udrso: // global
           call _cdrrz(R1) args: 0, res: 0, upd: 0;
       cdrrA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrrz() //  [R1]
         { info_tbl: [(cdrrz,
                       label: block_cdrrz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrrz: // global
           if (R1 & 7 == 1) goto cdrsa; else goto cdrsb;
       cdrsa: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrsb: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdrsn; else goto cdrsm;
       cdrsn: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrsm: // global
           _sdpF2::P64 = P64[R1 + 6];
           _sdpF3::P64 = P64[R1 + 14];
           I64[Hp - 136] = ds_sdpF4_info;
           _sdpEZ::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdpEZ::P64;
           P64[Hp - 112] = _sdpF2::P64;
           P64[Hp - 104] = _sdpF3::P64;
           I64[Hp - 96] = sat_sdpFh_info;
           P64[Hp - 80] = _sdpEZ::P64;
           _cdrrF::P64 = Hp - 136;
           P64[Hp - 72] = _cdrrF::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdrrF::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpF2::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.03912719 UTC

[section ""data" . Data.List.NonEmpty.groupBy_closure" {
     Data.List.NonEmpty.groupBy_closure:
         const Data.List.NonEmpty.groupBy_info;
 },
 ds_sdpFo_entry() //  [R1]
         { info_tbl: [(cdrtc,
                       label: ds_sdpFo_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrtc: // global
           _sdpFo::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdrtd; else goto cdrte;
       cdrte: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdrtg; else goto cdrtf;
       cdrtg: // global
           HpAlloc = 32;
           goto cdrtd;
       cdrtd: // global
           R1 = _sdpFo::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrtf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpFo::P64;
           _sdpFj::P64 = P64[_sdpFo::P64 + 16];
           _sdpFm::P64 = P64[_sdpFo::P64 + 24];
           _sdpFn::P64 = P64[_sdpFo::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpFj::P64;
           P64[Hp] = _sdpFm::P64;
           I64[Sp - 24] = block_cdrt9_info;
           R3 = _sdpFn::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdrt9() //  [R1, R2]
         { info_tbl: [(cdrt9,
                       label: block_cdrt9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrt9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrtj; else goto cdrti;
       cdrtj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdrti: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpFB_entry() //  [R1]
         { info_tbl: [(cdrtr,
                       label: sat_sdpFB_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrtr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdrts; else goto cdrtt;
       cdrts: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrtt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdrto_info;
           _sdpFj::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpFj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udrtx; else goto cdrtp;
       udrtx: // global
           call _cdrto(R1) args: 0, res: 0, upd: 0;
       cdrtp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrto() //  [R1]
         { info_tbl: [(cdrto,
                       label: block_cdrto_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrto: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdrtC,
                       label: Data.List.NonEmpty.groupBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrtC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdrtD; else goto cdrtE;
       cdrtD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrtE: // global
           I64[Sp - 16] = block_cdrsZ_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdrsZ() //  [R1]
         { info_tbl: [(cdrsZ,
                       label: block_cdrsZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrsZ: // global
           if (R1 & 7 == 1) goto cdrtz; else goto cdrtA;
       cdrtz: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrtA: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdrtM; else goto cdrtL;
       cdrtM: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrtL: // global
           _sdpFm::P64 = P64[R1 + 6];
           _sdpFn::P64 = P64[R1 + 14];
           I64[Hp - 136] = ds_sdpFo_info;
           _sdpFj::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdpFj::P64;
           P64[Hp - 112] = _sdpFm::P64;
           P64[Hp - 104] = _sdpFn::P64;
           I64[Hp - 96] = sat_sdpFB_info;
           P64[Hp - 80] = _sdpFj::P64;
           _cdrt4::P64 = Hp - 136;
           P64[Hp - 72] = _cdrt4::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdrt4::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpFm::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.055569997 UTC

[section ""data" . Data.List.NonEmpty.groupWith_closure" {
     Data.List.NonEmpty.groupWith_closure:
         const Data.List.NonEmpty.groupWith_info;
 },
 eq0_sdpFJ_entry() //  [R1, R2, R3]
         { info_tbl: [(cdruy,
                       label: eq0_sdpFJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdruy: // global
           _sdpFL::P64 = R3;
           _sdpFK::P64 = R2;
           _sdpFJ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdruz; else goto cdruA;
       cdruA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdruC; else goto cdruB;
       cdruC: // global
           HpAlloc = 64;
           goto cdruz;
       cdruz: // global
           R3 = _sdpFL::P64;
           R2 = _sdpFK::P64;
           R1 = _sdpFJ::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdruB: // global
           _sdpFD::P64 = P64[_sdpFJ::P64 + 6];
           _sdpFE::P64 = P64[_sdpFJ::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdpFE::P64;
           P64[Hp - 32] = _sdpFL::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpFE::P64;
           P64[Hp] = _sdpFK::P64;
           R2 = _sdpFD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdpFP_entry() //  [R1, R2]
         { info_tbl: [(cdruM,
                       label: sat_sdpFP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdruM: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call eq0_sdpFJ_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdpFO_entry() //  [R1]
         { info_tbl: [(cdruS,
                       label: ds_sdpFO_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdruS: // global
           _sdpFO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdruT; else goto cdruU;
       cdruU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdruW; else goto cdruV;
       cdruW: // global
           HpAlloc = 24;
           goto cdruT;
       cdruT: // global
           R1 = _sdpFO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdruV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpFO::P64;
           _sdpFH::P64 = P64[_sdpFO::P64 + 16];
           _sdpFI::P64 = P64[_sdpFO::P64 + 24];
           _sdpFJ::P64 = P64[_sdpFO::P64 + 32];
           I64[Hp - 16] = sat_sdpFP_info;
           P64[Hp - 8] = _sdpFH::P64;
           P64[Hp] = _sdpFJ::P64;
           I64[Sp - 24] = block_cdruP_info;
           R3 = _sdpFI::P64;
           R2 = Hp - 15;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdruP() //  [R1, R2]
         { info_tbl: [(cdruP,
                       label: block_cdruP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdruP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdruZ; else goto cdruY;
       cdruZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdruY: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpG1_entry() //  [R1]
         { info_tbl: [(cdrv7,
                       label: sat_sdpG1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrv7: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdrv8; else goto cdrv9;
       cdrv8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrv9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdrv4_info;
           _sdpFJ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpFJ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udrvd; else goto cdrv5;
       udrvd: // global
           call _cdrv4(R1) args: 0, res: 0, upd: 0;
       cdrv5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrv4() //  [R1]
         { info_tbl: [(cdrv4,
                       label: block_cdrv4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrv4: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdrvi,
                       label: Data.List.NonEmpty.groupWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrvi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdrvj; else goto cdrvk;
       cdrvj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrvk: // global
           I64[Sp - 24] = block_cdrum_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdrum() //  [R1]
         { info_tbl: [(cdrum,
                       label: block_cdrum_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrum: // global
           if (R1 & 7 == 1) goto cdrvf; else goto cdrvg;
       cdrvf: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrvg: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdrvs; else goto cdrvr;
       cdrvs: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrvr: // global
           _sdpFH::P64 = P64[R1 + 6];
           _sdpFI::P64 = P64[R1 + 14];
           I64[Hp - 160] = eq0_sdpFJ_info;
           P64[Hp - 152] = P64[Sp + 8];
           P64[Hp - 144] = P64[Sp + 16];
           I64[Hp - 136] = ds_sdpFO_info;
           P64[Hp - 120] = _sdpFH::P64;
           P64[Hp - 112] = _sdpFI::P64;
           _cdrur::P64 = Hp - 158;
           P64[Hp - 104] = _cdrur::P64;
           I64[Hp - 96] = sat_sdpG1_info;
           P64[Hp - 80] = _cdrur::P64;
           _cdruD::P64 = Hp - 136;
           P64[Hp - 72] = _cdruD::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdruD::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpFH::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.078692334 UTC

[section ""data" . Data.List.NonEmpty.group_closure" {
     Data.List.NonEmpty.group_closure:
         const Data.List.NonEmpty.group_info;
 },
 sat_sdpG5_entry() //  [R1]
         { info_tbl: [(cdrwh,
                       label: sat_sdpG5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrwh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrwi; else goto cdrwj;
       cdrwi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrwj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.group_entry() //  [R2, R3, R4]
         { info_tbl: [(cdrwk,
                       label: Data.List.NonEmpty.group_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrwk: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrwo; else goto cdrwn;
       cdrwo: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.group_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrwn: // global
           I64[Hp - 16] = sat_sdpG5_info;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 16;
           R2 = R2;
           call Data.List.NonEmpty.groupBy_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.086342828 UTC

[section ""data" . Data.List.NonEmpty.isPrefixOf_closure" {
     Data.List.NonEmpty.isPrefixOf_closure:
         const Data.List.NonEmpty.isPrefixOf_info;
 },
 Data.List.NonEmpty.isPrefixOf_entry() //  [R2, R3, R4]
         { info_tbl: [(cdrwI,
                       label: Data.List.NonEmpty.isPrefixOf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrwI: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdrwJ; else goto cdrwK;
       cdrwJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.isPrefixOf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrwK: // global
           I64[Sp - 24] = block_cdrwB_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udrxa; else goto cdrwC;
       udrxa: // global
           call _cdrwB(R1) args: 0, res: 0, upd: 0;
       cdrwC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrwB() //  [R1]
         { info_tbl: [(cdrwB,
                       label: block_cdrwB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrwB: // global
           if (R1 & 7 == 1) goto cdrwF; else goto cdrwG;
       cdrwF: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrwG: // global
           I64[Sp - 8] = block_cdrwQ_info;
           _sdpGa::P64 = P64[R1 + 6];
           _sdpGb::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdpGb::P64;
           P64[Sp + 16] = _sdpGa::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udrx9; else goto cdrwS;
       udrx9: // global
           call _cdrwQ(R1) args: 0, res: 0, upd: 0;
       cdrwS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrwQ() //  [R1]
         { info_tbl: [(cdrwQ,
                       label: block_cdrwQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrwQ: // global
           I64[Sp] = block_cdrwW_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdrwW() //  [R1]
         { info_tbl: [(cdrwW,
                       label: block_cdrwW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrwW: // global
           if (R1 & 7 == 1) goto cdrx3; else goto cdrx7;
       cdrx3: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrx7: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.OldList.isPrefixOf_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.096445406 UTC

[section ""cstring" . lvl1_rdpwu_bytes" {
     lvl1_rdpwu_bytes:
         I8[] [78,111,110,69,109,112,116,121,46,33,33,32,110,101,103,97,116,105,118,101,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.098641371 UTC

[section ""data" . Data.List.NonEmpty.!!1_closure" {
     Data.List.NonEmpty.!!1_closure:
         const Data.List.NonEmpty.!!1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.List.NonEmpty.!!1_entry() //  [R1]
         { info_tbl: [(cdrxJ,
                       label: Data.List.NonEmpty.!!1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrxJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrxK; else goto cdrxL;
       cdrxK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrxL: // global
           (_cdrxE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdrxE::I64 == 0) goto cdrxG; else goto cdrxF;
       cdrxG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdrxF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdrxE::I64;
           I64[Sp - 24] = block_cdrxH_info;
           R2 = lvl1_rdpwu_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdrxH() //  [R1]
         { info_tbl: [(cdrxH,
                       label: block_cdrxH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrxH: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.104923578 UTC

[section ""data" . Data.List.NonEmpty.$w!!_closure" {
     Data.List.NonEmpty.$w!!_closure:
         const Data.List.NonEmpty.$w!!_info;
         const 0;
 },
 Data.List.NonEmpty.$w!!_entry() //  [R2, R3, R4]
         { info_tbl: [(cdry7,
                       label: Data.List.NonEmpty.$w!!_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdry7: // global
           if (R4 == 0) goto cdry6; else goto cdry5;
       cdry6: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdry5: // global
           if (%MO_S_Le_W64(R4, 0)) goto cdrye; else goto cdryf;
       cdrye: // global
           R1 = Data.List.NonEmpty.!!1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdryf: // global
           _sdpGi::P64 = R3;
           R3 = R4 - 1;
           R2 = _sdpGi::P64;
           call GHC.List.$w!!_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.109155854 UTC

[section ""data" . Data.List.NonEmpty.!!_closure" {
     Data.List.NonEmpty.!!_closure:
         const Data.List.NonEmpty.!!_info;
         const 0;
 },
 Data.List.NonEmpty.!!_entry() //  [R2, R3]
         { info_tbl: [(cdryu,
                       label: Data.List.NonEmpty.!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdryu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdryy; else goto cdryz;
       cdryy: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.!!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdryz: // global
           I64[Sp - 16] = block_cdryr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udryH; else goto cdrys;
       udryH: // global
           call _cdryr(R1) args: 0, res: 0, upd: 0;
       cdrys: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdryr() //  [R1]
         { info_tbl: [(cdryr,
                       label: block_cdryr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdryr: // global
           I64[Sp - 8] = block_cdryx_info;
           _sdpGq::P64 = P64[R1 + 7];
           _sdpGr::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdpGr::P64;
           P64[Sp + 8] = _sdpGq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udryG; else goto cdryB;
       udryG: // global
           call _cdryx(R1) args: 0, res: 0, upd: 0;
       cdryB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdryx() //  [R1]
         { info_tbl: [(cdryx,
                       label: block_cdryx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdryx: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.List.NonEmpty.$w!!_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.116814689 UTC

[section ""data" . Data.List.NonEmpty.zip_closure" {
     Data.List.NonEmpty.zip_closure:
         const Data.List.NonEmpty.zip_info;
 },
 sat_sdpGM_entry() //  [R1]
         { info_tbl: [(cdrz6,
                       label: sat_sdpGM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrz6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdrza; else goto cdrzb;
       cdrza: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrzb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdrz3_info;
           _sdpGv::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sdpGv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udrzf; else goto cdrz4;
       udrzf: // global
           call _cdrz3(R1) args: 0, res: 0, upd: 0;
       cdrz4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrz3() //  [R1]
         { info_tbl: [(cdrz3,
                       label: block_cdrz3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrz3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrze; else goto cdrzd;
       cdrze: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdrzd: // global
           _sdpGH::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 16;
           R2 = _sdpGH::P64;
           Sp = Sp + 16;
           call GHC.List.zip_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.zip_entry() //  [R2, R3]
         { info_tbl: [(cdrzk,
                       label: Data.List.NonEmpty.zip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrzk: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cdrzo; else goto cdrzn;
       cdrzo: // global
           HpAlloc = 128;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.zip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrzn: // global
           I64[Hp - 120] = sat_sdpGM_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = stg_sel_0_upd_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 120;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.126437085 UTC

[section ""data" . Data.List.NonEmpty.zipWith_closure" {
     Data.List.NonEmpty.zipWith_closure:
         const Data.List.NonEmpty.zipWith_info;
 },
 sat_sdpH6_entry() //  [R1]
         { info_tbl: [(cdrzS,
                       label: sat_sdpH6_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrzS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdrzW; else goto cdrzX;
       cdrzW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrzX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdrzP_info;
           _sdpGN::P64 = P64[R1 + 16];
           _sdpGP::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdpGN::P64;
           P64[Sp - 24] = _sdpGP::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udrA1; else goto cdrzQ;
       udrA1: // global
           call _cdrzP(R1) args: 0, res: 0, upd: 0;
       cdrzQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrzP() //  [R1]
         { info_tbl: [(cdrzP,
                       label: block_cdrzP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrzP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrA0; else goto cdrzZ;
       cdrA0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdrzZ: // global
           _sdpH1::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 16;
           R3 = _sdpH1::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.List.zipWith_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpGY_entry() //  [R1]
         { info_tbl: [(cdrA8,
                       label: sat_sdpGY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrA8: // global
           _sdpGY::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdrA9; else goto cdrAa;
       cdrAa: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdrAc; else goto cdrAb;
       cdrAc: // global
           HpAlloc = 48;
           goto cdrA9;
       cdrA9: // global
           R1 = _sdpGY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrAb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpGY::P64;
           _sdpGN::P64 = P64[_sdpGY::P64 + 16];
           _sdpGO::P64 = P64[_sdpGY::P64 + 24];
           _sdpGP::P64 = P64[_sdpGY::P64 + 32];
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdpGP::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdpGO::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _sdpGN::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.zipWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdrAe,
                       label: Data.List.NonEmpty.zipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrAe: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdrAi; else goto cdrAh;
       cdrAi: // global
           HpAlloc = 104;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.zipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrAh: // global
           I64[Hp - 96] = sat_sdpH6_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sdpGY_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.137215615 UTC

[section ""data" . Data.List.NonEmpty.unzip_closure" {
     Data.List.NonEmpty.unzip_closure:
         const Data.List.NonEmpty.unzip_info;
 },
 sat_sdpHa_entry() //  [R1]
         { info_tbl: [(cdrAL,
                       label: sat_sdpHa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrAL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdrAM; else goto cdrAN;
       cdrAM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrAN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Tuple.snd_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdpH9_entry() //  [R1]
         { info_tbl: [(cdrAS,
                       label: sat_sdpH9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrAS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdrAT; else goto cdrAU;
       cdrAT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrAU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Tuple.fst_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.unzip_entry() //  [R2, R3]
         { info_tbl: [(cdrAW,
                       label: Data.List.NonEmpty.unzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrAW: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdrB0; else goto cdrAZ;
       cdrB0: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrAZ: // global
           I64[Hp - 80] = sat_sdpHa_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sdpH9_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.145786341 UTC

[section ""data" . Data.List.NonEmpty.nubBy_closure" {
     Data.List.NonEmpty.nubBy_closure:
         const Data.List.NonEmpty.nubBy_info;
 },
 sat_sdpHi_entry() //  [R1, R2]
         { info_tbl: [(cdrBG,
                       label: sat_sdpHi_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrBG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdrBH; else goto cdrBI;
       cdrBH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdrBI: // global
           I64[Sp - 8] = block_cdrBA_info;
           R3 = R2;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrBA() //  [R1]
         { info_tbl: [(cdrBA,
                       label: block_cdrBA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrBA: // global
           if (R1 & 7 == 1) goto cdrBD; else goto cdrBE;
       cdrBD: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrBE: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpHk_entry() //  [R1]
         { info_tbl: [(cdrBR,
                       label: sat_sdpHk_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrBR: // global
           _sdpHk::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cdrBS; else goto cdrBT;
       cdrBT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrBV; else goto cdrBU;
       cdrBV: // global
           HpAlloc = 24;
           goto cdrBS;
       cdrBS: // global
           R1 = _sdpHk::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrBU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHk::P64;
           _sdpHb::P64 = P64[_sdpHk::P64 + 16];
           _sdpHe::P64 = P64[_sdpHk::P64 + 24];
           _sdpHf::P64 = P64[_sdpHk::P64 + 32];
           I64[Hp - 16] = sat_sdpHi_info;
           P64[Hp - 8] = _sdpHb::P64;
           P64[Hp] = _sdpHe::P64;
           I64[Sp - 32] = block_cdrBP_info;
           R3 = _sdpHf::P64;
           R2 = Hp - 15;
           P64[Sp - 24] = _sdpHb::P64;
           Sp = Sp - 32;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdrBP() //  [R1]
         { info_tbl: [(cdrBP,
                       label: block_cdrBP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrBP: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.OldList.nubBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.nubBy_entry() //  [R2, R3]
         { info_tbl: [(cdrBZ,
                       label: Data.List.NonEmpty.nubBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrBZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrC1; else goto cdrC2;
       cdrC1: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.nubBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrC2: // global
           I64[Sp - 16] = block_cdrBm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udrC6; else goto cdrBn;
       udrC6: // global
           call _cdrBm(R1) args: 0, res: 0, upd: 0;
       cdrBn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrBm() //  [R1]
         { info_tbl: [(cdrBm,
                       label: block_cdrBm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrBm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdrC5; else goto cdrC4;
       cdrC5: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrC4: // global
           _sdpHe::P64 = P64[R1 + 7];
           _sdpHf::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdpHk_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sdpHe::P64;
           P64[Hp - 24] = _sdpHf::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpHe::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.159708049 UTC

[section ""data" . Data.List.NonEmpty.nub_closure" {
     Data.List.NonEmpty.nub_closure:
         const Data.List.NonEmpty.nub_info;
 },
 w_sdpHq_entry() //  [R1]
         { info_tbl: [(cdrCS,
                       label: w_sdpHq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrCS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrCT; else goto cdrCU;
       cdrCT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrCU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpHt_entry() //  [R1, R2]
         { info_tbl: [(cdrD6,
                       label: sat_sdpHt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrD6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdrD7; else goto cdrD8;
       cdrD7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdrD8: // global
           I64[Sp - 8] = block_cdrD0_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrD0() //  [R1]
         { info_tbl: [(cdrD0,
                       label: block_cdrD0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrD0: // global
           if (R1 & 7 == 1) goto cdrD3; else goto cdrD4;
       cdrD3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrD4: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpHv_entry() //  [R1]
         { info_tbl: [(cdrDh,
                       label: sat_sdpHv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrDh: // global
           _sdpHv::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cdrDi; else goto cdrDj;
       cdrDj: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdrDl; else goto cdrDk;
       cdrDl: // global
           HpAlloc = 48;
           goto cdrDi;
       cdrDi: // global
           R1 = _sdpHv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrDk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHv::P64;
           _sdpHl::P64 = P64[_sdpHv::P64 + 16];
           _sdpHo::P64 = P64[_sdpHv::P64 + 24];
           _sdpHp::P64 = P64[_sdpHv::P64 + 32];
           I64[Hp - 40] = w_sdpHq_info;
           P64[Hp - 24] = _sdpHl::P64;
           I64[Hp - 16] = sat_sdpHt_info;
           P64[Hp - 8] = _sdpHo::P64;
           _cdrCO::P64 = Hp - 40;
           P64[Hp] = _cdrCO::P64;
           I64[Sp - 32] = block_cdrDf_info;
           R3 = _sdpHp::P64;
           R2 = Hp - 15;
           P64[Sp - 24] = _cdrCO::P64;
           Sp = Sp - 32;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdrDf() //  [R1]
         { info_tbl: [(cdrDf,
                       label: block_cdrDf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrDf: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.OldList.nubBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.nub_entry() //  [R2, R3]
         { info_tbl: [(cdrDp,
                       label: Data.List.NonEmpty.nub_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrDp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrDr; else goto cdrDs;
       cdrDr: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.nub_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrDs: // global
           I64[Sp - 16] = block_cdrCF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udrDw; else goto cdrCG;
       udrDw: // global
           call _cdrCF(R1) args: 0, res: 0, upd: 0;
       cdrCG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrCF() //  [R1]
         { info_tbl: [(cdrCF,
                       label: block_cdrCF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrCF: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdrDv; else goto cdrDu;
       cdrDv: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrDu: // global
           _sdpHo::P64 = P64[R1 + 7];
           _sdpHp::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdpHv_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sdpHo::P64;
           P64[Hp - 24] = _sdpHp::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdpHo::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.175306189 UTC

[section ""cstring" . Data.List.NonEmpty.$trModule4_bytes" {
     Data.List.NonEmpty.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.177025146 UTC

[section ""data" . Data.List.NonEmpty.$trModule3_closure" {
     Data.List.NonEmpty.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.NonEmpty.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.179081248 UTC

[section ""cstring" . Data.List.NonEmpty.$trModule2_bytes" {
     Data.List.NonEmpty.$trModule2_bytes:
         I8[] [68,97,116,97,46,76,105,115,116,46,78,111,110,69,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.180750289 UTC

[section ""data" . Data.List.NonEmpty.$trModule1_closure" {
     Data.List.NonEmpty.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.NonEmpty.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.18245712 UTC

[section ""data" . Data.List.NonEmpty.$trModule_closure" {
     Data.List.NonEmpty.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.List.NonEmpty.$trModule3_closure+1;
         const Data.List.NonEmpty.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.184970691 UTC

[section ""data" . Data.List.NonEmpty.groupAllWith_closure" {
     Data.List.NonEmpty.groupAllWith_closure:
         const Data.List.NonEmpty.groupAllWith_info;
         const 0;
 },
 sat_sdpHE_entry() //  [R1, R2, R3]
         { info_tbl: [(cdrEp,
                       label: sat_sdpHE_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrEp: // global
           _sdpHB::P64 = R3;
           _sdpHA::P64 = R2;
           _sdpHE::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdrEq; else goto cdrEr;
       cdrEr: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdrEt; else goto cdrEs;
       cdrEt: // global
           HpAlloc = 64;
           goto cdrEq;
       cdrEq: // global
           R3 = _sdpHB::P64;
           R2 = _sdpHA::P64;
           R1 = _sdpHE::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrEs: // global
           _sdpHw::P64 = P64[_sdpHE::P64 + 6];
           _sdpHx::P64 = P64[_sdpHE::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdpHx::P64;
           P64[Hp - 32] = _sdpHB::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpHx::P64;
           P64[Hp] = _sdpHA::P64;
           R2 = _sdpHw::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdpHF_entry() //  [R1]
         { info_tbl: [(cdrEu,
                       label: sat_sdpHF_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrEu: // global
           _sdpHF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdrEv; else goto cdrEw;
       cdrEw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrEy; else goto cdrEx;
       cdrEy: // global
           HpAlloc = 24;
           goto cdrEv;
       cdrEv: // global
           R1 = _sdpHF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrEx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHF::P64;
           _sdpHw::P64 = P64[_sdpHF::P64 + 16];
           _sdpHx::P64 = P64[_sdpHF::P64 + 24];
           _sdpHy::P64 = P64[_sdpHF::P64 + 32];
           I64[Hp - 16] = sat_sdpHE_info;
           P64[Hp - 8] = _sdpHw::P64;
           P64[Hp] = _sdpHx::P64;
           R3 = _sdpHy::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call Data.OldList.sortBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpHz_entry() //  [R1]
         { info_tbl: [(cdrED,
                       label: sat_sdpHz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrED: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrEE; else goto cdrEF;
       cdrEE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrEF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupAllWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdrEG,
                       label: Data.List.NonEmpty.groupAllWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrEG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdrEK; else goto cdrEJ;
       cdrEK: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupAllWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrEJ: // global
           I64[Hp - 56] = sat_sdpHF_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sdpHz_info;
           P64[Hp] = R2;
           R5 = Hp - 56;
           R4 = R3;
           R3 = Hp - 16;
           R2 = Data.Foldable.$fFoldable[]_closure;
           call Data.List.NonEmpty.groupWith_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.196561022 UTC

[section ""data" . Data.List.NonEmpty.groupBy1_closure" {
     Data.List.NonEmpty.groupBy1_closure:
         const Data.List.NonEmpty.groupBy1_info;
 },
 ds_sdpHL_entry() //  [R1]
         { info_tbl: [(cdrFk,
                       label: ds_sdpHL_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrFk: // global
           _sdpHL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdrFl; else goto cdrFm;
       cdrFm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdrFo; else goto cdrFn;
       cdrFo: // global
           HpAlloc = 32;
           goto cdrFl;
       cdrFl: // global
           R1 = _sdpHL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrFn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpHL::P64;
           _sdpHG::P64 = P64[_sdpHL::P64 + 16];
           _sdpHJ::P64 = P64[_sdpHL::P64 + 24];
           _sdpHK::P64 = P64[_sdpHL::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpHG::P64;
           P64[Hp] = _sdpHJ::P64;
           I64[Sp - 24] = block_cdrFh_info;
           R3 = _sdpHK::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdrFh() //  [R1, R2]
         { info_tbl: [(cdrFh,
                       label: block_cdrFh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrFh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrFr; else goto cdrFq;
       cdrFr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdrFq: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpHY_entry() //  [R1]
         { info_tbl: [(cdrFz,
                       label: sat_sdpHY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrFz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdrFA; else goto cdrFB;
       cdrFA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrFB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdrFw_info;
           _sdpHG::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpHG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udrFF; else goto cdrFx;
       udrFF: // global
           call _cdrFw(R1) args: 0, res: 0, upd: 0;
       cdrFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrFw() //  [R1]
         { info_tbl: [(cdrFw,
                       label: block_cdrFw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrFw: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy1_entry() //  [R2, R3]
         { info_tbl: [(cdrFG,
                       label: Data.List.NonEmpty.groupBy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrFG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrFK; else goto cdrFL;
       cdrFK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrFL: // global
           I64[Sp - 16] = block_cdrF7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udrFP; else goto cdrF8;
       udrFP: // global
           call _cdrF7(R1) args: 0, res: 0, upd: 0;
       cdrF8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrF7() //  [R1]
         { info_tbl: [(cdrF7,
                       label: block_cdrF7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrF7: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdrFO; else goto cdrFN;
       cdrFO: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrFN: // global
           _sdpHJ::P64 = P64[R1 + 7];
           _sdpHK::P64 = P64[R1 + 15];
           I64[Hp - 136] = ds_sdpHL_info;
           _sdpHG::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdpHG::P64;
           P64[Hp - 112] = _sdpHJ::P64;
           P64[Hp - 104] = _sdpHK::P64;
           I64[Hp - 96] = sat_sdpHY_info;
           P64[Hp - 80] = _sdpHG::P64;
           _cdrFc::P64 = Hp - 136;
           P64[Hp - 72] = _cdrFc::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdrFc::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpHJ::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.212101703 UTC

[section ""data" . Data.List.NonEmpty.group1_closure" {
     Data.List.NonEmpty.group1_closure:
         const Data.List.NonEmpty.group1_info;
 },
 w_sdpI4_entry() //  [R1]
         { info_tbl: [(cdrGw,
                       label: w_sdpI4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrGw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrGx; else goto cdrGy;
       cdrGx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrGy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sdpI5_entry() //  [R1]
         { info_tbl: [(cdrGH,
                       label: ds_sdpI5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrGH: // global
           _sdpI5::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdrGI; else goto cdrGJ;
       cdrGJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdrGL; else goto cdrGK;
       cdrGL: // global
           HpAlloc = 32;
           goto cdrGI;
       cdrGI: // global
           R1 = _sdpI5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrGK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpI5::P64;
           _sdpI2::P64 = P64[_sdpI5::P64 + 16];
           _sdpI3::P64 = P64[_sdpI5::P64 + 24];
           _sdpI4::P64 = P64[_sdpI5::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpI4::P64;
           P64[Hp] = _sdpI2::P64;
           I64[Sp - 24] = block_cdrGE_info;
           R3 = _sdpI3::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdrGE() //  [R1, R2]
         { info_tbl: [(cdrGE,
                       label: block_cdrGE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrGE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrGO; else goto cdrGN;
       cdrGO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdrGN: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpIi_entry() //  [R1]
         { info_tbl: [(cdrGW,
                       label: sat_sdpIi_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrGW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdrGX; else goto cdrGY;
       cdrGX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrGY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdrGT_info;
           _sdpI4::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpI4::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udrH2; else goto cdrGU;
       udrH2: // global
           call _cdrGT(R1) args: 0, res: 0, upd: 0;
       cdrGU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrGT() //  [R1]
         { info_tbl: [(cdrGT,
                       label: block_cdrGT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrGT: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.group1_entry() //  [R2, R3]
         { info_tbl: [(cdrH3,
                       label: Data.List.NonEmpty.group1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrH3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrH7; else goto cdrH8;
       cdrH7: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.group1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrH8: // global
           I64[Sp - 16] = block_cdrGn_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udrHc; else goto cdrGo;
       udrHc: // global
           call _cdrGn(R1) args: 0, res: 0, upd: 0;
       cdrGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrGn() //  [R1]
         { info_tbl: [(cdrGn,
                       label: block_cdrGn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrGn: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdrHb; else goto cdrHa;
       cdrHb: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrHa: // global
           _sdpI2::P64 = P64[R1 + 7];
           _sdpI3::P64 = P64[R1 + 15];
           I64[Hp - 160] = w_sdpI4_info;
           P64[Hp - 144] = P64[Sp + 8];
           I64[Hp - 136] = ds_sdpI5_info;
           P64[Hp - 120] = _sdpI2::P64;
           P64[Hp - 112] = _sdpI3::P64;
           _cdrGs::P64 = Hp - 160;
           P64[Hp - 104] = _cdrGs::P64;
           I64[Hp - 96] = sat_sdpIi_info;
           P64[Hp - 80] = _cdrGs::P64;
           _cdrGz::P64 = Hp - 136;
           P64[Hp - 72] = _cdrGz::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdrGz::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdpI2::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.228763575 UTC

[section ""data" . Data.List.NonEmpty.$wgroupWith1_closure" {
     Data.List.NonEmpty.$wgroupWith1_closure:
         const Data.List.NonEmpty.$wgroupWith1_info;
 },
 eq_sdpIn_entry() //  [R1, R2, R3]
         { info_tbl: [(cdrHW,
                       label: eq_sdpIn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrHW: // global
           _sdpIp::P64 = R3;
           _sdpIo::P64 = R2;
           _sdpIn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdrHX; else goto cdrHY;
       cdrHY: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdrI0; else goto cdrHZ;
       cdrI0: // global
           HpAlloc = 64;
           goto cdrHX;
       cdrHX: // global
           R3 = _sdpIp::P64;
           R2 = _sdpIo::P64;
           R1 = _sdpIn::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrHZ: // global
           _sdpIj::P64 = P64[_sdpIn::P64 + 6];
           _sdpIk::P64 = P64[_sdpIn::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdpIk::P64;
           P64[Hp - 32] = _sdpIp::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdpIk::P64;
           P64[Hp] = _sdpIo::P64;
           R2 = _sdpIj::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdpIt_entry() //  [R1, R2]
         { info_tbl: [(cdrIa,
                       label: sat_sdpIt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrIa: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call eq_sdpIn_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdpIs_entry() //  [R1]
         { info_tbl: [(cdrIg,
                       label: ds_sdpIs_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrIg: // global
           _sdpIs::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdrIh; else goto cdrIi;
       cdrIi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrIk; else goto cdrIj;
       cdrIk: // global
           HpAlloc = 24;
           goto cdrIh;
       cdrIh: // global
           R1 = _sdpIs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrIj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdpIs::P64;
           _sdpIl::P64 = P64[_sdpIs::P64 + 16];
           _sdpIm::P64 = P64[_sdpIs::P64 + 24];
           _sdpIn::P64 = P64[_sdpIs::P64 + 32];
           I64[Hp - 16] = sat_sdpIt_info;
           P64[Hp - 8] = _sdpIl::P64;
           P64[Hp] = _sdpIn::P64;
           I64[Sp - 24] = block_cdrId_info;
           R3 = _sdpIm::P64;
           R2 = Hp - 15;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdrId() //  [R1, R2]
         { info_tbl: [(cdrId,
                       label: block_cdrId_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrId: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrIn; else goto cdrIm;
       cdrIn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdrIm: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdpIF_entry() //  [R1]
         { info_tbl: [(cdrIv,
                       label: sat_sdpIF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrIv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdrIw; else goto cdrIx;
       cdrIw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrIx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdrIs_info;
           _sdpIn::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdpIn::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udrIB; else goto cdrIt;
       udrIB: // global
           call _cdrIs(R1) args: 0, res: 0, upd: 0;
       cdrIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdrIs() //  [R1]
         { info_tbl: [(cdrIs,
                       label: block_cdrIs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrIs: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wgroupWith1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdrIE,
                       label: Data.List.NonEmpty.$wgroupWith1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrIE: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdrII; else goto cdrIH;
       cdrII: // global
           HpAlloc = 144;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wgroupWith1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrIH: // global
           I64[Hp - 136] = eq_sdpIn_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = ds_sdpIs_info;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           _cdrHP::P64 = Hp - 134;
           P64[Hp - 80] = _cdrHP::P64;
           I64[Hp - 72] = sat_sdpIF_info;
           P64[Hp - 56] = _cdrHP::P64;
           _cdrI1::P64 = Hp - 112;
           P64[Hp - 48] = _cdrI1::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdrI1::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 40;
           R2 = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.245681279 UTC

[section ""data" . Data.List.NonEmpty.groupWith1_closure" {
     Data.List.NonEmpty.groupWith1_closure:
         const Data.List.NonEmpty.groupWith1_info;
 },
 Data.List.NonEmpty.groupWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdrJl,
                       label: Data.List.NonEmpty.groupWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrJl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrJr; else goto cdrJs;
       cdrJr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrJs: // global
           I64[Sp - 24] = block_cdrJi_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udrJx; else goto cdrJj;
       udrJx: // global
           call _cdrJi(R1) args: 0, res: 0, upd: 0;
       cdrJj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrJi() //  [R1]
         { info_tbl: [(cdrJi,
                       label: block_cdrJi_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrJi: // global
           _sdpIH::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdrJo_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _sdpIH::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wgroupWith1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdrJo() //  [R1, R2]
         { info_tbl: [(cdrJo,
                       label: block_cdrJo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrJo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrJw; else goto cdrJv;
       cdrJw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdrJv: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.253655418 UTC

[section ""data" . Data.List.NonEmpty.$wgroupAllWith1_closure" {
     Data.List.NonEmpty.$wgroupAllWith1_closure:
         const Data.List.NonEmpty.$wgroupAllWith1_info;
         const 0;
 },
 sat_sdpIS_entry() //  [R1, R2, R3]
         { info_tbl: [(cdrJX,
                       label: sat_sdpIS_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrJX: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Ord.comparing_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdpJ6_entry() //  [R1]
         { info_tbl: [(cdrK9,
                       label: sat_sdpJ6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrK9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdrKa; else goto cdrKb;
       cdrKa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdrKb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wgroupAllWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdrKg,
                       label: Data.List.NonEmpty.$wgroupAllWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrKg: // global
           _sdpIR::P64 = R4;
           _sdpIQ::P64 = R3;
           _sdpIP::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdrKh; else goto cdrKi;
       cdrKi: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdrKk; else goto cdrKj;
       cdrKk: // global
           HpAlloc = 96;
           goto cdrKh;
       cdrKh: // global
           R4 = _sdpIR::P64;
           R3 = _sdpIQ::P64;
           R2 = _sdpIP::P64;
           R1 = Data.List.NonEmpty.$wgroupAllWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrKj: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdpIR::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdpIR::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdpIS_info;
           P64[Hp - 8] = _sdpIP::P64;
           P64[Hp] = _sdpIQ::P64;
           I64[Sp - 24] = block_cdrK0_info;
           R3 = Hp - 38;
           R2 = Hp - 14;
           P64[Sp - 16] = _sdpIP::P64;
           P64[Sp - 8] = _sdpIQ::P64;
           Sp = Sp - 24;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdrK0() //  [R1]
         { info_tbl: [(cdrK0,
                       label: block_cdrK0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrK0: // global
           if (R1 & 7 == 1) goto cdrKd; else goto cdrKe;
       cdrKd: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdrKe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrKp; else goto cdrKo;
       cdrKp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdrKo: // global
           _sdpJ4::P64 = P64[R1 + 6];
           _sdpJ5::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sdpJ6_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sdpJ5::P64;
           R4 = _sdpJ4::P64;
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.List.NonEmpty.$wgroupWith1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.263975941 UTC

[section ""data" . Data.List.NonEmpty.groupAllWith1_closure" {
     Data.List.NonEmpty.groupAllWith1_closure:
         const Data.List.NonEmpty.groupAllWith1_info;
         const 0;
 },
 Data.List.NonEmpty.groupAllWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdrKS,
                       label: Data.List.NonEmpty.groupAllWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrKS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdrKT; else goto cdrKU;
       cdrKT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupAllWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrKU: // global
           I64[Sp - 8] = block_cdrKP_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wgroupAllWith1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdrKP() //  [R1, R2]
         { info_tbl: [(cdrKP,
                       label: block_cdrKP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrKP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdrKX; else goto cdrKW;
       cdrKX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdrKW: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.270616093 UTC

[section ""data" . Data.List.NonEmpty.$wxor_closure" {
     Data.List.NonEmpty.$wxor_closure:
         const Data.List.NonEmpty.$wxor_info;
 },
 go_sdpJf_entry() //  [R1, R2]
         { info_tbl: [(cdrLn,
                       label: go_sdpJf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrLn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdrLo; else goto udrLV;
       cdrLo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       udrLV: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cdrLd() args: 0, res: 0, upd: 0;
     }
 },
 _cdrLd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrLd: // global
           _sdpJd::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cdrLg_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdpJd::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udrLX; else goto cdrLh;
       udrLX: // global
           call _cdrLg(R1) args: 0, res: 0, upd: 0;
       cdrLh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrLg() //  [R1]
         { info_tbl: [(cdrLg,
                       label: block_cdrLg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrLg: // global
           if (R1 & 7 == 1) goto cdrLk; else goto cdrLl;
       cdrLk: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdrLl: // global
           I64[Sp] = block_cdrLv_info;
           _sdpJj::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sdpJj::P64;
           if (R1 & 7 != 0) goto udrLY; else goto cdrLx;
       udrLY: // global
           call _cdrLv(R1) args: 0, res: 0, upd: 0;
       cdrLx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrLv() //  [R1]
         { info_tbl: [(cdrLv,
                       label: block_cdrLv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrLv: // global
           _sdpJj::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdrLD; else goto cdrLI;
       cdrLD: // global
           P64[Sp + 16] = _sdpJj::P64;
           Sp = Sp + 8;
           call _cdrLd() args: 0, res: 0, upd: 0;
       cdrLI: // global
           I64[Sp + 16] = block_cdrLG_info;
           R2 = _sdpJj::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdpJf_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrLG() //  [R1]
         { info_tbl: [(cdrLG,
                       label: block_cdrLG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrLG: // global
           if (R1 & 7 == 1) goto cdrLO; else goto cdrLS;
       cdrLO: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdrLS: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wxor_entry() //  [R2, R3]
         { info_tbl: [(cdrM1,
                       label: Data.List.NonEmpty.$wxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrM1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdrM5; else goto cdrM4;
       cdrM5: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdrM4: // global
           I64[Hp - 8] = go_sdpJf_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_sdpJf_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.282882266 UTC

[section ""data" . Data.List.NonEmpty.xor_closure" {
     Data.List.NonEmpty.xor_closure:
         const Data.List.NonEmpty.xor_info;
 },
 Data.List.NonEmpty.xor_entry() //  [R2]
         { info_tbl: [(cdrMJ,
                       label: Data.List.NonEmpty.xor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrMJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdrMK; else goto cdrML;
       cdrMK: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.xor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdrML: // global
           I64[Sp - 8] = block_cdrMG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udrMP; else goto cdrMH;
       udrMP: // global
           call _cdrMG(R1) args: 0, res: 0, upd: 0;
       cdrMH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrMG() //  [R1]
         { info_tbl: [(cdrMG,
                       label: block_cdrMG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrMG: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.List.NonEmpty.$wxor_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.289234694 UTC

[section ""data" . Data.List.NonEmpty.length_closure" {
     Data.List.NonEmpty.length_closure:
         const Data.List.NonEmpty.length_info;
 },
 Data.List.NonEmpty.length_entry() //  [R2]
         { info_tbl: [(cdrN6,
                       label: Data.List.NonEmpty.length_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrN6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdrNh; else goto cdrNi;
       cdrNh: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.length_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdrNi: // global
           I64[Sp - 8] = block_cdrN3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udrNn; else goto cdrN4;
       udrNn: // global
           call _cdrN3(R1) args: 0, res: 0, upd: 0;
       cdrN4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdrN3() //  [R1]
         { info_tbl: [(cdrN3,
                       label: block_cdrN3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrN3: // global
           I64[Sp] = block_cdrN9_info;
           R3 = 0;
           R2 = P64[R1 + 15];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdrN9() //  [R1]
         { info_tbl: [(cdrN9,
                       label: block_cdrN9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdrN9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdrNm; else goto cdrNl;
       cdrNm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdrNl: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:36.296182676 UTC

[section ""relreadonly" . SdpN4_srt" {
     SdpN4_srt:
         const GHC.List.lastError_closure;
         const Data.List.NonEmpty.last_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.List.NonEmpty.fromList_closure;
         const Data.List.NonEmpty.cycle1_closure;
         const Data.List.NonEmpty.reverse_closure;
         const Data.List.NonEmpty.sortBy_closure;
         const Data.List.NonEmpty.sortWith_closure;
         const Data.List.NonEmpty.sort_closure;
         const Data.OldList.$winits_closure;
         const Data.List.NonEmpty.inits_closure;
         const Data.List.NonEmpty.tails_closure;
         const GHC.List.scanr1_closure;
         const Data.List.NonEmpty.scanr1_closure;
         const Data.List.NonEmpty.cycle_closure;
         const Data.List.NonEmpty.$wtranspose_closure;
         const Data.List.NonEmpty.transpose_closure;
         const GHC.List.$w!!_closure;
         const Data.List.NonEmpty.!!1_closure;
         const Data.List.NonEmpty.!!_closure;
         const Data.List.NonEmpty.$w!!_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const Data.List.NonEmpty.groupAllWith_closure;
         const Data.List.NonEmpty.$wgroupAllWith1_closure;
         const Data.List.NonEmpty.groupAllWith1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.329209726 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:08:38.331298013 UTC

[section ""data" . Data.List.NonEmpty.nonEmpty_closure" {
     Data.List.NonEmpty.nonEmpty_closure:
         const Data.List.NonEmpty.nonEmpty_info;
 },
 Data.List.NonEmpty.nonEmpty_entry() //  [R2]
         { info_tbl: [(cds0O,
                       label: Data.List.NonEmpty.nonEmpty_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds0O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cds0P; else goto cds0Q;
       cds0P: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.nonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cds0Q: // global
           I64[Sp - 8] = block_cds0H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uds11; else goto cds0I;
       uds11: // global
           call _cds0H(R1) args: 0, res: 0, upd: 0;
       cds0I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cds0H() //  [R1]
         { info_tbl: [(cds0H,
                       label: block_cds0H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds0H: // global
           if (R1 & 7 == 1) goto cds0L; else goto cds0M;
       cds0L: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cds0M: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cds10; else goto cds0Z;
       cds10: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cds0Z: // global
           _sdrNF::P64 = P64[R1 + 6];
           _sdrNG::P64 = P64[R1 + 14];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _sdrNF::P64;
           P64[Hp - 16] = _sdrNG::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.340112223 UTC

[section ""data" . Data.List.NonEmpty.uncons_closure" {
     Data.List.NonEmpty.uncons_closure:
         const Data.List.NonEmpty.uncons_info;
 },
 sat_sdrNU_entry() //  [R1]
         { info_tbl: [(cds1v,
                       label: sat_sdrNU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds1v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cds1w; else goto cds1x;
       cds1w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cds1x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cds1s_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uds1T; else goto cds1t;
       uds1T: // global
           call _cds1s(R1) args: 0, res: 0, upd: 0;
       cds1t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cds1s() //  [R1]
         { info_tbl: [(cds1s,
                       label: block_cds1s_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds1s: // global
           I64[Sp] = block_cds1A_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto uds1S; else goto cds1C;
       uds1S: // global
           call _cds1A(R1) args: 0, res: 0, upd: 0;
       cds1C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cds1A() //  [R1]
         { info_tbl: [(cds1A,
                       label: block_cds1A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds1A: // global
           if (R1 & 7 == 1) goto cds1I; else goto cds1N;
       cds1I: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cds1N: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cds1Q; else goto cds1P;
       cds1Q: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cds1P: // global
           _sdrNR::P64 = P64[R1 + 6];
           _sdrNS::P64 = P64[R1 + 14];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _sdrNR::P64;
           P64[Hp - 16] = _sdrNS::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.uncons_entry() //  [R2]
         { info_tbl: [(cds1W,
                       label: Data.List.NonEmpty.uncons_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds1W: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cds20; else goto cds1Z;
       cds20: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.uncons_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cds1Z: // global
           I64[Hp - 64] = sat_sdrNU_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.370034027 UTC

[section ""data" . Data.List.NonEmpty.$wunfoldr_closure" {
     Data.List.NonEmpty.$wunfoldr_closure:
         const Data.List.NonEmpty.$wunfoldr_info;
 },
 sat_sdrO9_entry() //  [R1]
         { info_tbl: [(cds3a,
                       label: sat_sdrO9_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds3a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cds3b; else goto cds3c;
       cds3b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cds3c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cds33_info;
           _sdrO2::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdrO2::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uds3j; else goto cds34;
       uds3j: // global
           call _cds33(R1) args: 0, res: 0, upd: 0;
       cds34: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cds33() //  [R1]
         { info_tbl: [(cds33,
                       label: block_cds33_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds33: // global
           if (R1 & 7 == 1) goto cds37; else goto cds38;
       cds37: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cds38: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sdrO2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sdrO2_entry() //  [R1, R2]
         { info_tbl: [(cds3k,
                       label: go_sdrO2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds3k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cds3m; else goto cds3n;
       cds3m: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cds3n: // global
           I64[Sp - 16] = block_cds2V_info;
           R2 = R2;
           _sdrO2::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sdrO2::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cds2V() //  [R1]
         { info_tbl: [(cds2V,
                       label: block_cds2V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds2V: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cds3q; else goto cds3p;
       cds3q: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cds3p: // global
           _sdrO5::P64 = P64[R1 + 7];
           _sdrO6::P64 = P64[R1 + 15];
           I64[Hp - 48] = sat_sdrO9_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sdrO6::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdrO5::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdrOa_entry() //  [R1]
         { info_tbl: [(cds3v,
                       label: sat_sdrOa_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds3v: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cds3w; else goto cds3x;
       cds3w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cds3x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cds2K_info;
           _sdrNV::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdrNV::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uds3D; else goto cds2L;
       uds3D: // global
           call _cds2K(R1) args: 0, res: 0, upd: 0;
       cds2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cds2K() //  [R1]
         { info_tbl: [(cds2K,
                       label: block_cds2K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds2K: // global
           if (R1 & 7 == 1) goto cds3s; else goto cds3t;
       cds3s: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cds3t: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cds3C; else goto cds3B;
       cds3C: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cds3B: // global
           _sdrO1::P64 = P64[R1 + 6];
           I64[Hp - 8] = go_sdrO2_info;
           P64[Hp] = P64[Sp + 8];
           R2 = _sdrO1::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call go_sdrO2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wunfoldr_entry() //  [R2, R3]
         { info_tbl: [(cds3E,
                       label: Data.List.NonEmpty.$wunfoldr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds3E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cds3F; else goto cds3G;
       cds3F: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunfoldr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cds3G: // global
           I64[Sp - 16] = block_cds2C_info;
           _sdrNV::P64 = R2;
           R2 = R3;
           R1 = _sdrNV::P64;
           P64[Sp - 8] = _sdrNV::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cds2C() //  [R1]
         { info_tbl: [(cds2C,
                       label: block_cds2C_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds2C: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cds3J; else goto cds3I;
       cds3J: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cds3I: // global
           _sdrNY::P64 = P64[R1 + 7];
           _sdrNZ::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sdrOa_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sdrNZ::P64;
           R2 = Hp - 24;
           R1 = _sdrNY::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.390133346 UTC

[section ""data" . Data.List.NonEmpty.unfoldr_closure" {
     Data.List.NonEmpty.unfoldr_closure:
         const Data.List.NonEmpty.unfoldr_info;
 },
 Data.List.NonEmpty.unfoldr_entry() //  [R2, R3]
         { info_tbl: [(cds4K,
                       label: Data.List.NonEmpty.unfoldr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds4K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cds4L; else goto cds4M;
       cds4L: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unfoldr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cds4M: // global
           I64[Sp - 8] = block_cds4H_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wunfoldr_entry(R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cds4H() //  [R1, R2]
         { info_tbl: [(cds4H,
                       label: block_cds4H_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds4H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cds4P; else goto cds4O;
       cds4P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cds4O: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.395985911 UTC

[section ""data" . Data.List.NonEmpty.head_closure" {
     Data.List.NonEmpty.head_closure:
         const Data.List.NonEmpty.head_info;
 },
 Data.List.NonEmpty.head_entry() //  [R2]
         { info_tbl: [(cds58,
                       label: Data.List.NonEmpty.head_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds58: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cds59; else goto cds5a;
       cds59: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.head_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cds5a: // global
           I64[Sp - 8] = block_cds55_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uds5e; else goto cds56;
       uds5e: // global
           call _cds55(R1) args: 0, res: 0, upd: 0;
       cds56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cds55() //  [R1]
         { info_tbl: [(cds55,
                       label: block_cds55_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds55: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.401414803 UTC

[section ""data" . Data.List.NonEmpty.tail_closure" {
     Data.List.NonEmpty.tail_closure:
         const Data.List.NonEmpty.tail_info;
 },
 Data.List.NonEmpty.tail_entry() //  [R2]
         { info_tbl: [(cds5w,
                       label: Data.List.NonEmpty.tail_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds5w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cds5x; else goto cds5y;
       cds5x: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.tail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cds5y: // global
           I64[Sp - 8] = block_cds5t_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uds5C; else goto cds5u;
       uds5C: // global
           call _cds5t(R1) args: 0, res: 0, upd: 0;
       cds5u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cds5t() //  [R1]
         { info_tbl: [(cds5t,
                       label: block_cds5t_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds5t: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.409236368 UTC

[section ""data" . poly_go_rdpws_closure" {
     poly_go_rdpws_closure:
         const poly_go_rdpws_info;
 },
 poly_go_rdpws_entry() //  [R2, R3]
         { info_tbl: [(cds60,
                       label: poly_go_rdpws_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds60: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cds61; else goto uds69;
       cds61: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_go_rdpws_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uds69: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cds5Q() args: 0, res: 0, upd: 0;
     }
 },
 _cds5Q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds5Q: // global
           _sdrOo::P64 = P64[Sp];
           I64[Sp] = block_cds5T_info;
           R1 = _sdrOo::P64;
           if (R1 & 7 != 0) goto uds6b; else goto cds5U;
       uds6b: // global
           call _cds5T(R1) args: 0, res: 0, upd: 0;
       cds5U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cds5T() //  [R1]
         { info_tbl: [(cds5T,
                       label: block_cds5T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds5T: // global
           if (R1 & 7 == 1) goto cds5X; else goto cds5Y;
       cds5X: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cds5Y: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cds5Q() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.415983871 UTC

[section ""data" . Data.List.NonEmpty.last_closure" {
     Data.List.NonEmpty.last_closure:
         const Data.List.NonEmpty.last_info;
         const 0;
 },
 Data.List.NonEmpty.last_entry() //  [R2]
         { info_tbl: [(cds6B,
                       label: Data.List.NonEmpty.last_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds6B: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cds6F; else goto cds6E;
       cds6F: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.last_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cds6E: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = GHC.List.lastError_closure;
           R2 = Hp - 14;
           call poly_go_rdpws_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.42089995 UTC

[section ""data" . Data.List.NonEmpty.init_closure" {
     Data.List.NonEmpty.init_closure:
         const Data.List.NonEmpty.init_info;
 },
 Data.List.NonEmpty.init_entry() //  [R2]
         { info_tbl: [(cds6X,
                       label: Data.List.NonEmpty.init_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds6X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cds6Y; else goto cds6Z;
       cds6Y: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.init_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cds6Z: // global
           I64[Sp - 8] = block_cds6U_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uds73; else goto cds6V;
       uds73: // global
           call _cds6U(R1) args: 0, res: 0, upd: 0;
       cds6V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cds6U() //  [R1]
         { info_tbl: [(cds6U,
                       label: block_cds6U_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds6U: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.List.init1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.426539403 UTC

[section ""data" . Data.List.NonEmpty.<|_closure" {
     Data.List.NonEmpty.<|_closure:
         const Data.List.NonEmpty.<|_info;
 },
 Data.List.NonEmpty.<|_entry() //  [R2, R3]
         { info_tbl: [(cds7m,
                       label: Data.List.NonEmpty.<|_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds7m: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cds7q; else goto cds7p;
       cds7q: // global
           HpAlloc = 96;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.<|_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cds7p: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 38;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.430680529 UTC

[section ""data" . Data.List.NonEmpty.cons_closure" {
     Data.List.NonEmpty.cons_closure:
         const Data.List.NonEmpty.cons_info;
 },
 Data.List.NonEmpty.cons_entry() //  [R2, R3]
         { info_tbl: [(cds7H,
                       label: Data.List.NonEmpty.cons_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds7H: // global
           R3 = R3;
           R2 = R2;
           call Data.List.NonEmpty.<|_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.434941654 UTC

[section ""data" . Data.List.NonEmpty.$wunfold_closure" {
     Data.List.NonEmpty.$wunfold_closure:
         const Data.List.NonEmpty.$wunfold_info;
 },
 ds1_sdrOZ_entry() //  [R1]
         { info_tbl: [(cds89,
                       label: ds1_sdrOZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds89: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cds8a; else goto cds8b;
       cds8a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cds8b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cds86_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Data.List.NonEmpty.$wunfold_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _cds86() //  [R1, R2]
         { info_tbl: [(cds86,
                       label: block_cds86_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds86: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cds8e; else goto cds8d;
       cds8e: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cds8d: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wunfold_entry() //  [R2, R3]
         { info_tbl: [(cds8f,
                       label: Data.List.NonEmpty.$wunfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds8f: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cds8g; else goto cds8h;
       cds8g: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cds8h: // global
           I64[Sp - 16] = block_cds7S_info;
           _sdrOS::P64 = R2;
           R2 = R3;
           R1 = _sdrOS::P64;
           P64[Sp - 8] = _sdrOS::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cds7S() //  [R1]
         { info_tbl: [(cds7S,
                       label: block_cds7S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds7S: // global
           I64[Sp - 8] = block_cds7W_info;
           _sdrOV::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sdrOV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uds8v; else goto cds7X;
       uds8v: // global
           call _cds7W(R1) args: 0, res: 0, upd: 0;
       cds7X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cds7W() //  [R1]
         { info_tbl: [(cds7W,
                       label: block_cds7W_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds7W: // global
           _sdrOV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cds8m; else goto cds8q;
       cds8m: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _sdrOV::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cds8q: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cds8t; else goto cds8s;
       cds8t: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cds8s: // global
           _sdrOY::P64 = P64[R1 + 6];
           I64[Hp - 96] = ds1_sdrOZ_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sdrOY::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cds82::P64 = Hp - 96;
           P64[Hp - 48] = _cds82::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cds82::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 14;
           R1 = _sdrOV::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.448385208 UTC

[section ""data" . Data.List.NonEmpty.unfold_closure" {
     Data.List.NonEmpty.unfold_closure:
         const Data.List.NonEmpty.unfold_info;
 },
 Data.List.NonEmpty.unfold_entry() //  [R2, R3]
         { info_tbl: [(cds9e,
                       label: Data.List.NonEmpty.unfold_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds9e: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cds9f; else goto cds9g;
       cds9f: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unfold_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cds9g: // global
           I64[Sp - 8] = block_cds9b_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wunfold_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _cds9b() //  [R1, R2]
         { info_tbl: [(cds9b,
                       label: block_cds9b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds9b: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cds9j; else goto cds9i;
       cds9j: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cds9i: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.454048795 UTC

[section ""cstring" . lvl_rdpwt_bytes" {
     lvl_rdpwt_bytes:
         I8[] [78,111,110,69,109,112,116,121,46,102,114,111,109,76,105,115,116,58,32,101,109,112,116,121,32,108,105,115,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.455997789 UTC

[section ""data" . Data.List.NonEmpty.cycle1_closure" {
     Data.List.NonEmpty.cycle1_closure:
         const Data.List.NonEmpty.cycle1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.List.NonEmpty.cycle1_entry() //  [R1]
         { info_tbl: [(cds9E,
                       label: Data.List.NonEmpty.cycle1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds9E: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cds9F; else goto cds9G;
       cds9F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cds9G: // global
           (_cds9z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cds9z::I64 == 0) goto cds9B; else goto cds9A;
       cds9B: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cds9A: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cds9z::I64;
           I64[Sp - 24] = block_cds9C_info;
           R2 = lvl_rdpwt_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cds9C() //  [R1]
         { info_tbl: [(cds9C,
                       label: block_cds9C_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cds9C: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.462174076 UTC

[section ""data" . Data.List.NonEmpty.fromList_closure" {
     Data.List.NonEmpty.fromList_closure:
         const Data.List.NonEmpty.fromList_info;
         const 0;
 },
 Data.List.NonEmpty.fromList_entry() //  [R2]
         { info_tbl: [(cdsa7,
                       label: Data.List.NonEmpty.fromList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsa7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdsa8; else goto cdsa9;
       cdsa8: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.fromList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdsa9: // global
           I64[Sp - 8] = block_cdsa0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udsaj; else goto cdsa1;
       udsaj: // global
           call _cdsa0(R1) args: 0, res: 0, upd: 0;
       cdsa1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsa0() //  [R1]
         { info_tbl: [(cdsa0,
                       label: block_cdsa0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsa0: // global
           if (R1 & 7 == 1) goto cdsa4; else goto cdsa5;
       cdsa4: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdsa5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsai; else goto cdsah;
       cdsai: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsah: // global
           _sdrPk::P64 = P64[R1 + 6];
           _sdrPl::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrPk::P64;
           P64[Hp] = _sdrPl::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.468427499 UTC

[section ""data" . Data.List.NonEmpty.reverse_closure" {
     Data.List.NonEmpty.reverse_closure:
         const Data.List.NonEmpty.reverse_info;
         const 0;
 },
 Data.List.NonEmpty.reverse_entry() //  [R2]
         { info_tbl: [(cdsaM,
                       label: Data.List.NonEmpty.reverse_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsaM: // global
           _sdrPm::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdsaN; else goto cdsaO;
       cdsaO: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdsaQ; else goto cdsaP;
       cdsaQ: // global
           HpAlloc = 72;
           goto cdsaN;
       cdsaN: // global
           R2 = _sdrPm::P64;
           R1 = Data.List.NonEmpty.reverse_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdsaP: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdrPm::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdrPm::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdsaG_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp - 8;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsaG() //  [R1]
         { info_tbl: [(cdsaG,
                       label: block_cdsaG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsaG: // global
           if (R1 & 7 == 1) goto cdsaJ; else goto cdsaK;
       cdsaJ: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdsaK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsaZ; else goto cdsaY;
       cdsaZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsaY: // global
           _sdrPy::P64 = P64[R1 + 6];
           _sdrPz::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrPy::P64;
           P64[Hp] = _sdrPz::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.475265867 UTC

[section ""data" . Data.List.NonEmpty.sortBy_closure" {
     Data.List.NonEmpty.sortBy_closure:
         const Data.List.NonEmpty.sortBy_info;
         const 0;
 },
 Data.List.NonEmpty.sortBy_entry() //  [R2, R3]
         { info_tbl: [(cdsbx,
                       label: Data.List.NonEmpty.sortBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsbx: // global
           _sdrPB::P64 = R3;
           _sdrPA::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdsby; else goto cdsbz;
       cdsbz: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdsbB; else goto cdsbA;
       cdsbB: // global
           HpAlloc = 72;
           goto cdsby;
       cdsby: // global
           R3 = _sdrPB::P64;
           R2 = _sdrPA::P64;
           R1 = Data.List.NonEmpty.sortBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsbA: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdrPB::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdrPB::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdsbr_info;
           R3 = Hp - 14;
           R2 = _sdrPA::P64;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsbr() //  [R1]
         { info_tbl: [(cdsbr,
                       label: block_cdsbr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsbr: // global
           if (R1 & 7 == 1) goto cdsbu; else goto cdsbv;
       cdsbu: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdsbv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsbK; else goto cdsbJ;
       cdsbK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsbJ: // global
           _sdrPM::P64 = P64[R1 + 6];
           _sdrPN::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrPM::P64;
           P64[Hp] = _sdrPN::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.482316554 UTC

[section ""data" . Data.List.NonEmpty.sortWith_closure" {
     Data.List.NonEmpty.sortWith_closure:
         const Data.List.NonEmpty.sortWith_info;
         const 0;
 },
 sat_sdrPR_entry() //  [R1, R2, R3]
         { info_tbl: [(cdscg,
                       label: sat_sdrPR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdscg: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Ord.comparing_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.sortWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdscp,
                       label: Data.List.NonEmpty.sortWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdscp: // global
           _sdrPQ::P64 = R4;
           _sdrPP::P64 = R3;
           _sdrPO::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdscq; else goto cdscr;
       cdscr: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdsct; else goto cdscs;
       cdsct: // global
           HpAlloc = 96;
           goto cdscq;
       cdscq: // global
           R4 = _sdrPQ::P64;
           R3 = _sdrPP::P64;
           R2 = _sdrPO::P64;
           R1 = Data.List.NonEmpty.sortWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdscs: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdrPQ::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdrPQ::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdrPR_info;
           P64[Hp - 8] = _sdrPO::P64;
           P64[Hp] = _sdrPP::P64;
           I64[Sp - 8] = block_cdscj_info;
           R3 = Hp - 38;
           R2 = Hp - 14;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdscj() //  [R1]
         { info_tbl: [(cdscj,
                       label: block_cdscj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdscj: // global
           if (R1 & 7 == 1) goto cdscm; else goto cdscn;
       cdscm: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdscn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdscC; else goto cdscB;
       cdscC: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdscB: // global
           _sdrQ3::P64 = P64[R1 + 6];
           _sdrQ4::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrQ3::P64;
           P64[Hp] = _sdrQ4::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.492067906 UTC

[section ""data" . Data.List.NonEmpty.sort_closure" {
     Data.List.NonEmpty.sort_closure:
         const Data.List.NonEmpty.sort_info;
         const 0;
 },
 sat_sdrQ7_entry() //  [R1]
         { info_tbl: [(cdsdb,
                       label: sat_sdrQ7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsdb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsdc; else goto cdsdd;
       cdsdc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsdd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.sort_entry() //  [R2, R3]
         { info_tbl: [(cdsdk,
                       label: Data.List.NonEmpty.sort_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsdk: // global
           _sdrQ6::P64 = R3;
           _sdrQ5::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdsdl; else goto cdsdm;
       cdsdm: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdsdo; else goto cdsdn;
       cdsdo: // global
           HpAlloc = 96;
           goto cdsdl;
       cdsdl: // global
           R3 = _sdrQ6::P64;
           R2 = _sdrQ5::P64;
           R1 = Data.List.NonEmpty.sort_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsdn: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdrQ6::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdrQ6::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdrQ7_info;
           P64[Hp] = _sdrQ5::P64;
           I64[Sp - 8] = block_cdsde_info;
           R3 = Hp - 38;
           R2 = Hp - 16;
           Sp = Sp - 8;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsde() //  [R1]
         { info_tbl: [(cdsde,
                       label: block_cdsde_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsde: // global
           if (R1 & 7 == 1) goto cdsdh; else goto cdsdi;
       cdsdh: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdsdi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsdx; else goto cdsdw;
       cdsdx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsdw: // global
           _sdrQj::P64 = P64[R1 + 6];
           _sdrQk::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrQj::P64;
           P64[Hp] = _sdrQk::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.50064528 UTC

[section ""data" . Data.List.NonEmpty.inits_closure" {
     Data.List.NonEmpty.inits_closure:
         const Data.List.NonEmpty.inits_info;
         const 0;
 },
 sat_sdrQn_entry() //  [R1]
         { info_tbl: [(cdse5,
                       label: sat_sdrQn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdse5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdse6; else goto cdse7;
       cdse6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdse7: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Foldable.toList_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.inits_entry() //  [R2, R3]
         { info_tbl: [(cdseb,
                       label: Data.List.NonEmpty.inits_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdseb: // global
           _sdrQm::P64 = R3;
           _sdrQl::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdsec; else goto cdsed;
       cdsed: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdsef; else goto cdsee;
       cdsef: // global
           HpAlloc = 32;
           goto cdsec;
       cdsec: // global
           R3 = _sdrQm::P64;
           R2 = _sdrQl::P64;
           R1 = Data.List.NonEmpty.inits_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsee: // global
           I64[Hp - 24] = sat_sdrQn_info;
           P64[Hp - 8] = _sdrQl::P64;
           P64[Hp] = _sdrQm::P64;
           I64[Sp - 8] = block_cdse8_info;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call Data.OldList.$winits_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdse8() //  [R1, R2]
         { info_tbl: [(cdse8,
                       label: block_cdse8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdse8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsei; else goto cdseh;
       cdsei: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdseh: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.509131512 UTC

[section ""data" . Data.List.NonEmpty.tails1_closure" {
     Data.List.NonEmpty.tails1_closure:
         const Data.List.NonEmpty.tails1_info;
 },
 sat_sdrQv_entry() //  [R1]
         { info_tbl: [(cdseQ,
                       label: sat_sdrQv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdseQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdseR; else goto cdseS;
       cdseR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdseS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdseJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udseZ; else goto cdseK;
       udseZ: // global
           call _cdseJ(R1) args: 0, res: 0, upd: 0;
       cdseK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdseJ() //  [R1]
         { info_tbl: [(cdseJ,
                       label: block_cdseJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdseJ: // global
           if (R1 & 7 == 1) goto cdseN; else goto cdseO;
       cdseN: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdseO: // global
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call Data.List.NonEmpty.tails1_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.tails1_entry() //  [R2]
         { info_tbl: [(cdsf1,
                       label: Data.List.NonEmpty.tails1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsf1: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdsf5; else goto cdsf4;
       cdsf5: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.List.NonEmpty.tails1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdsf4: // global
           I64[Hp - 40] = sat_sdrQv_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.517040207 UTC

[section ""data" . Data.List.NonEmpty.tails_closure" {
     Data.List.NonEmpty.tails_closure:
         const Data.List.NonEmpty.tails_info;
         const 0;
 },
 sat_sdrQy_entry() //  [R1]
         { info_tbl: [(cdsfA,
                       label: sat_sdrQy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsfA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsfB; else goto cdsfC;
       cdsfB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsfC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call Data.Foldable.toList_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.tails_entry() //  [R2, R3]
         { info_tbl: [(cdsfJ,
                       label: Data.List.NonEmpty.tails_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsfJ: // global
           _sdrQx::P64 = R3;
           _sdrQw::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdsfK; else goto cdsfL;
       cdsfL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdsfN; else goto cdsfM;
       cdsfN: // global
           HpAlloc = 32;
           goto cdsfK;
       cdsfK: // global
           R3 = _sdrQx::P64;
           R2 = _sdrQw::P64;
           R1 = Data.List.NonEmpty.tails_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsfM: // global
           I64[Hp - 24] = sat_sdrQy_info;
           P64[Hp - 8] = _sdrQw::P64;
           P64[Hp] = _sdrQx::P64;
           I64[Sp - 8] = block_cdsfD_info;
           R2 = Hp - 24;
           Sp = Sp - 8;
           call Data.List.NonEmpty.tails1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsfD() //  [R1]
         { info_tbl: [(cdsfD,
                       label: block_cdsfD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsfD: // global
           if (R1 & 7 == 1) goto cdsfG; else goto cdsfH;
       cdsfG: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdsfH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsfW; else goto cdsfV;
       cdsfW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsfV: // global
           _sdrQB::P64 = P64[R1 + 6];
           _sdrQC::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrQB::P64;
           P64[Hp] = _sdrQC::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.526590968 UTC

[section ""data" . Data.List.NonEmpty.insert_closure" {
     Data.List.NonEmpty.insert_closure:
         const Data.List.NonEmpty.insert_info;
 },
 sat_sdrQH_entry() //  [R1]
         { info_tbl: [(cdsgv,
                       label: sat_sdrQH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsgv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsgw; else goto cdsgx;
       cdsgw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsgx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.compare_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.insert_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdsgy,
                       label: Data.List.NonEmpty.insert_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsgy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdsgC; else goto cdsgD;
       cdsgC: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.insert_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsgD: // global
           I64[Sp - 24] = block_cdsgn_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdsgn() //  [R1]
         { info_tbl: [(cdsgn,
                       label: block_cdsgn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsgn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsgG; else goto cdsgF;
       cdsgG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsgF: // global
           I64[Hp - 16] = sat_sdrQH_info;
           P64[Hp] = P64[Sp + 8];
           _sdrQF::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdsgz_info;
           R4 = R1;
           R3 = _sdrQF::P64;
           R2 = Hp - 16;
           Sp = Sp + 16;
           call Data.OldList.$winsertBy_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsgz() //  [R1, R2]
         { info_tbl: [(cdsgz,
                       label: block_cdsgz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsgz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsgJ; else goto cdsgI;
       cdsgJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdsgI: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.537058731 UTC

[section ""data" . Data.List.NonEmpty.scanl_closure" {
     Data.List.NonEmpty.scanl_closure:
         const Data.List.NonEmpty.scanl_info;
 },
 sat_sdrQQ_entry() //  [R1]
         { info_tbl: [(cdshj,
                       label: sat_sdrQQ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdshj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdshk; else goto cdshl;
       cdshk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdshl: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call Data.Foldable.toList_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 sat_sdrQU_entry() //  [R1]
         { info_tbl: [(cdsho,
                       label: sat_sdrQU_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsho: // global
           _sdrQU::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdshp; else goto cdshq;
       cdshq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdshs; else goto cdshr;
       cdshs: // global
           HpAlloc = 32;
           goto cdshp;
       cdshp: // global
           R1 = _sdrQU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdshr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrQU::P64;
           _sdrQM::P64 = P64[_sdrQU::P64 + 16];
           _sdrQN::P64 = P64[_sdrQU::P64 + 24];
           _sdrQO::P64 = P64[_sdrQU::P64 + 32];
           _sdrQP::P64 = P64[_sdrQU::P64 + 40];
           I64[Hp - 24] = sat_sdrQQ_info;
           P64[Hp - 8] = _sdrQM::P64;
           P64[Hp] = _sdrQP::P64;
           I64[Sp - 24] = block_cdshm_info;
           R4 = Hp - 24;
           R3 = _sdrQO::P64;
           R2 = _sdrQN::P64;
           Sp = Sp - 24;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdshm() //  [R2]
         { info_tbl: [(cdshm,
                       label: block_cdshm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdshm: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.scanl_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdshv,
                       label: Data.List.NonEmpty.scanl_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdshv: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdshz; else goto cdshy;
       cdshz: // global
           HpAlloc = 72;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanl_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdshy: // global
           I64[Hp - 64] = sat_sdrQU_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.549024529 UTC

[section ""data" . Data.List.NonEmpty.scanr_closure" {
     Data.List.NonEmpty.scanr_closure:
         const Data.List.NonEmpty.scanr_info;
 },
 Data.List.NonEmpty.scanr_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdsi6,
                       label: Data.List.NonEmpty.scanr_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsi6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdsic; else goto cdsid;
       cdsic: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanr_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsid: // global
           I64[Sp - 24] = block_cdsi4_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdsi4() //  [R1]
         { info_tbl: [(cdsi4,
                       label: block_cdsi4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsi4: // global
           _sdrQX::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdsi9_info;
           R4 = R1;
           R3 = _sdrQX::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsi9() //  [R1, R2]
         { info_tbl: [(cdsi9,
                       label: block_cdsi9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsi9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsih; else goto cdsig;
       cdsih: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdsig: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.559602344 UTC

[section ""data" . Data.List.NonEmpty.scanl1_closure" {
     Data.List.NonEmpty.scanl1_closure:
         const Data.List.NonEmpty.scanl1_info;
 },
 sat_sdrRf_entry() //  [R1]
         { info_tbl: [(cdsiK,
                       label: sat_sdrRf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsiK: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdsiO; else goto cdsiP;
       cdsiO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsiP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdsiH_info;
           _sdrR3::P64 = P64[R1 + 16];
           _sdrR5::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdrR3::P64;
           P64[Sp - 24] = _sdrR5::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udsiT; else goto cdsiI;
       udsiT: // global
           call _cdsiH(R1) args: 0, res: 0, upd: 0;
       cdsiI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsiH() //  [R1]
         { info_tbl: [(cdsiH,
                       label: block_cdsiH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsiH: // global
           _sdrR5::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdsiN_info;
           R4 = P64[R1 + 15];
           R3 = _sdrR5::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsiN() //  [R2]
         { info_tbl: [(cdsiN,
                       label: block_cdsiN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsiN: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.scanl1_entry() //  [R2, R3]
         { info_tbl: [(cdsiV,
                       label: Data.List.NonEmpty.scanl1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsiV: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdsiZ; else goto cdsiY;
       cdsiZ: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.scanl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsiY: // global
           I64[Hp - 80] = stg_sel_0_upd_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sdrRf_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           _cdsiC::P64 = Hp - 80;
           P64[Hp - 24] = _cdsiC::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _cdsiC::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.572227952 UTC

[section ""data" . Data.List.NonEmpty.scanr1_closure" {
     Data.List.NonEmpty.scanr1_closure:
         const Data.List.NonEmpty.scanr1_info;
         const 0;
 },
 Data.List.NonEmpty.scanr1_entry() //  [R2, R3]
         { info_tbl: [(cdsjC,
                       label: Data.List.NonEmpty.scanr1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsjC: // global
           _sdrRh::P64 = R3;
           _sdrRg::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdsjD; else goto cdsjE;
       cdsjE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdsjG; else goto cdsjF;
       cdsjG: // global
           HpAlloc = 72;
           goto cdsjD;
       cdsjD: // global
           R3 = _sdrRh::P64;
           R2 = _sdrRg::P64;
           R1 = Data.List.NonEmpty.scanr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsjF: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdrRh::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdrRh::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdsjw_info;
           R3 = Hp - 14;
           R2 = _sdrRg::P64;
           Sp = Sp - 8;
           call GHC.List.scanr1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsjw() //  [R1]
         { info_tbl: [(cdsjw,
                       label: block_cdsjw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsjw: // global
           if (R1 & 7 == 1) goto cdsjz; else goto cdsjA;
       cdsjz: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdsjA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsjP; else goto cdsjO;
       cdsjP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsjO: // global
           _sdrRs::P64 = P64[R1 + 6];
           _sdrRt::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrRs::P64;
           P64[Hp] = _sdrRt::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.578829566 UTC

[section ""data" . Data.List.NonEmpty.toList_closure" {
     Data.List.NonEmpty.toList_closure:
         const Data.List.NonEmpty.toList_info;
 },
 Data.List.NonEmpty.toList_entry() //  [R2]
         { info_tbl: [(cdskg,
                       label: Data.List.NonEmpty.toList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdskg: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdskk; else goto cdskj;
       cdskk: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.toList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdskj: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.58306916 UTC

[section ""data" . Data.List.NonEmpty.$wtake_closure" {
     Data.List.NonEmpty.$wtake_closure:
         const Data.List.NonEmpty.$wtake_info;
 },
 Data.List.NonEmpty.$wtake_entry() //  [R2, R3]
         { info_tbl: [(cdskE,
                       label: Data.List.NonEmpty.$wtake_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdskE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdskI; else goto cdskH;
       cdskI: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wtake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdskH: // global
           if (%MO_S_Ge_W64(0, R2)) goto cdskC; else goto cdskD;
       cdskC: // global
           Hp = Hp - 72;
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdskD: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.58763503 UTC

[section ""data" . Data.List.NonEmpty.take_closure" {
     Data.List.NonEmpty.take_closure:
         const Data.List.NonEmpty.take_info;
 },
 Data.List.NonEmpty.take_entry() //  [R2, R3]
         { info_tbl: [(cdsl6,
                       label: Data.List.NonEmpty.take_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsl6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsl7; else goto cdsl8;
       cdsl7: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.take_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsl8: // global
           I64[Sp - 16] = block_cdsl3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udslc; else goto cdsl4;
       udslc: // global
           call _cdsl3(R1) args: 0, res: 0, upd: 0;
       cdsl4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsl3() //  [R1]
         { info_tbl: [(cdsl3,
                       label: block_cdsl3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsl3: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wtake_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.593940328 UTC

[section ""data" . Data.List.NonEmpty.$wunsafeDrop_closure" {
     Data.List.NonEmpty.$wunsafeDrop_closure:
         const Data.List.NonEmpty.$wunsafeDrop_info;
 },
 Data.List.NonEmpty.$wunsafeDrop_entry() //  [R2, R3]
         { info_tbl: [(cdsly,
                       label: Data.List.NonEmpty.$wunsafeDrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsly: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdslz; else goto udslN;
       cdslz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wunsafeDrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udslN: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdslo() args: 0, res: 0, upd: 0;
     }
 },
 _cdslo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdslo: // global
           I64[Sp - 8] = block_cdslr_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udslP; else goto cdsls;
       udslP: // global
           call _cdslr(R1) args: 0, res: 0, upd: 0;
       cdsls: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdslr() //  [R1]
         { info_tbl: [(cdslr,
                       label: block_cdslr_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdslr: // global
           if (R1 & 7 == 1) goto cdslv; else goto cdslw;
       cdslv: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdslw: // global
           _sdrRX::P64 = P64[R1 + 14];
           _sdrRY::I64 = I64[Sp + 8];
           if (_sdrRY::I64 != 1) goto cdslJ; else goto cdslK;
       cdslJ: // global
           I64[Sp + 8] = _sdrRY::I64 - 1;
           P64[Sp + 16] = _sdrRX::P64;
           Sp = Sp + 8;
           call _cdslo() args: 0, res: 0, upd: 0;
       cdslK: // global
           R1 = _sdrRX::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.600881418 UTC

[section ""data" . Data.List.NonEmpty.$wdrop_closure" {
     Data.List.NonEmpty.$wdrop_closure:
         const Data.List.NonEmpty.$wdrop_info;
 },
 Data.List.NonEmpty.$wdrop_entry() //  [R2, R3]
         { info_tbl: [(cdsmk,
                       label: Data.List.NonEmpty.$wdrop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsmk: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdsmo; else goto cdsmn;
       cdsmo: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wdrop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsmn: // global
           if (%MO_S_Gt_W64(R2, 0)) goto cdsmi; else goto cdsmj;
       cdsmi: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call Data.List.NonEmpty.$wunsafeDrop_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
       cdsmj: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.605641275 UTC

[section ""data" . Data.List.NonEmpty.drop_closure" {
     Data.List.NonEmpty.drop_closure:
         const Data.List.NonEmpty.drop_info;
 },
 Data.List.NonEmpty.drop_entry() //  [R2, R3]
         { info_tbl: [(cdsmT,
                       label: Data.List.NonEmpty.drop_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsmT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsmU; else goto cdsmV;
       cdsmU: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.drop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsmV: // global
           I64[Sp - 16] = block_cdsmQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udsmZ; else goto cdsmR;
       udsmZ: // global
           call _cdsmQ(R1) args: 0, res: 0, upd: 0;
       cdsmR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsmQ() //  [R1]
         { info_tbl: [(cdsmQ,
                       label: block_cdsmQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsmQ: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wdrop_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.611900386 UTC

[section ""data" . Data.List.NonEmpty.splitAt_closure" {
     Data.List.NonEmpty.splitAt_closure:
         const Data.List.NonEmpty.splitAt_info;
 },
 Data.List.NonEmpty.splitAt_entry() //  [R2, R3]
         { info_tbl: [(cdsnh,
                       label: Data.List.NonEmpty.splitAt_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsnh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsni; else goto cdsnj;
       cdsni: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.splitAt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsnj: // global
           I64[Sp - 16] = block_cdsne_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udsnJ; else goto cdsnf;
       udsnJ: // global
           call _cdsne(R1) args: 0, res: 0, upd: 0;
       cdsnf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsne() //  [R1]
         { info_tbl: [(cdsne,
                       label: block_cdsne_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsne: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdsno; else goto cdsnn;
       cdsno: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsnn: // global
           _sdrSp::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto cdsnz; else goto cdsnI;
       cdsnz: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdrSp::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdrSp::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           _cdsnu::P64 = Hp - 38;
           Hp = Hp - 24;
           I64[Sp + 8] = block_cdsnv_info;
           R3 = _cdsnu::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
       cdsnI: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdrSp::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdrSp::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = Hp - 38;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cdsnv() //  [R1, R2]
         { info_tbl: [(cdsnv,
                       label: block_cdsnv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsnv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsnC; else goto cdsnB;
       cdsnC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdsnB: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.620909286 UTC

[section ""data" . Data.List.NonEmpty.takeWhile_closure" {
     Data.List.NonEmpty.takeWhile_closure:
         const Data.List.NonEmpty.takeWhile_info;
 },
 Data.List.NonEmpty.takeWhile_entry() //  [R2, R3]
         { info_tbl: [(cdsom,
                       label: Data.List.NonEmpty.takeWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsom: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdsoq; else goto cdsop;
       cdsoq: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.takeWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsop: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.625431951 UTC

[section ""data" . Data.List.NonEmpty.dropWhile_closure" {
     Data.List.NonEmpty.dropWhile_closure:
         const Data.List.NonEmpty.dropWhile_info;
 },
 Data.List.NonEmpty.dropWhile_entry() //  [R2, R3]
         { info_tbl: [(cdsoH,
                       label: Data.List.NonEmpty.dropWhile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsoH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdsoL; else goto cdsoK;
       cdsoL: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.dropWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsoK: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.dropWhile_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.62978818 UTC

[section ""data" . Data.List.NonEmpty.span_closure" {
     Data.List.NonEmpty.span_closure:
         const Data.List.NonEmpty.span_info;
 },
 Data.List.NonEmpty.span_entry() //  [R2, R3]
         { info_tbl: [(cdsp5,
                       label: Data.List.NonEmpty.span_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsp5: // global
           _sdrTb::P64 = R3;
           _sdrTa::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdsp6; else goto cdsp7;
       cdsp7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdsp9; else goto cdsp8;
       cdsp9: // global
           HpAlloc = 72;
           goto cdsp6;
       cdsp6: // global
           R3 = _sdrTb::P64;
           R2 = _sdrTa::P64;
           R1 = Data.List.NonEmpty.span_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsp8: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdrTb::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdrTb::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           I64[Sp - 8] = block_cdsp2_info;
           R3 = Hp - 14;
           R2 = _sdrTa::P64;
           Sp = Sp - 8;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsp2() //  [R1, R2]
         { info_tbl: [(cdsp2,
                       label: block_cdsp2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsp2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdspc; else goto cdspb;
       cdspc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdspb: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.636771961 UTC

[section ""data" . Data.List.NonEmpty.$wbreak_closure" {
     Data.List.NonEmpty.$wbreak_closure:
         const Data.List.NonEmpty.$wbreak_info;
 },
 sat_sdrTs_entry() //  [R1, R2]
         { info_tbl: [(cdspL,
                       label: sat_sdrTs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdspL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdspM; else goto cdspN;
       cdspM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdspN: // global
           I64[Sp - 8] = block_cdspF_info;
           R2 = R2;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdspF() //  [R1]
         { info_tbl: [(cdspF,
                       label: block_cdspF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdspF: // global
           if (R1 & 7 == 1) goto cdspI; else goto cdspJ;
       cdspI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdspJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wbreak_entry() //  [R2, R3]
         { info_tbl: [(cdspU,
                       label: Data.List.NonEmpty.$wbreak_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdspU: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdspY; else goto cdspX;
       cdspY: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wbreak_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdspX: // global
           I64[Hp - 80] = stg_sel_1_upd_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = stg_sel_0_upd_info;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           I64[Hp - 8] = sat_sdrTs_info;
           P64[Hp] = R2;
           R3 = Hp - 30;
           R2 = Hp - 7;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.645869188 UTC

[section ""data" . Data.List.NonEmpty.break_closure" {
     Data.List.NonEmpty.break_closure:
         const Data.List.NonEmpty.break_info;
 },
 Data.List.NonEmpty.break_entry() //  [R2, R3]
         { info_tbl: [(cdsqu,
                       label: Data.List.NonEmpty.break_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsqu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdsqv; else goto cdsqw;
       cdsqv: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.break_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsqw: // global
           I64[Sp - 8] = block_cdsqr_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wbreak_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsqr() //  [R1, R2]
         { info_tbl: [(cdsqr,
                       label: block_cdsqr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsqr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsqz; else goto cdsqy;
       cdsqz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdsqy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.652264547 UTC

[section ""data" . Data.List.NonEmpty.filter_closure" {
     Data.List.NonEmpty.filter_closure:
         const Data.List.NonEmpty.filter_info;
 },
 Data.List.NonEmpty.filter_entry() //  [R2, R3]
         { info_tbl: [(cdsqS,
                       label: Data.List.NonEmpty.filter_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsqS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdsqW; else goto cdsqV;
       cdsqW: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.filter_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsqV: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = R2;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.65759065 UTC

[section ""data" . Data.List.NonEmpty.$wpartition_closure" {
     Data.List.NonEmpty.$wpartition_closure:
         const Data.List.NonEmpty.$wpartition_info;
 },
 w3_sdrTZ_entry() //  [R1]
         { info_tbl: [(cdsrs,
                       label: w3_sdrTZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsrs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdsrt; else goto cdsru;
       cdsrt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsru: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdsrp_info;
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo_sdrTU_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsrp() //  [R1, R2]
         { info_tbl: [(cdsrp,
                       label: block_cdsrp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsrp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsrx; else goto cdsrw;
       cdsrx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdsrw: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_sdrTU_entry() //  [R1, R2]
         { info_tbl: [(cdsrC,
                       label: $wgo_sdrTU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsrC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdsrD; else goto cdsrE;
       cdsrD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdsrE: // global
           I64[Sp - 24] = block_cdsrf_info;
           _sdrTU::P64 = R1;
           _sdrTS::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sdrTS::P64;
           P64[Sp - 8] = _sdrTU::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udss6; else goto cdsrg;
       udss6: // global
           call _cdsrf(R1) args: 0, res: 0, upd: 0;
       cdsrg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsrf() //  [R1]
         { info_tbl: [(cdsrf,
                       label: block_cdsrf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsrf: // global
           if (R1 & 7 == 1) goto cdsrz; else goto cdsrA;
       cdsrz: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdsrA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdsrK; else goto cdsrJ;
       cdsrK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsrJ: // global
           _sdrTX::P64 = P64[R1 + 6];
           _sdrTY::P64 = P64[R1 + 14];
           I64[Hp - 24] = w3_sdrTZ_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sdrTY::P64;
           I64[Sp] = block_cdsrH_info;
           R2 = _sdrTX::P64;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sdrTX::P64;
           P64[Sp + 16] = Hp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsrH() //  [R1]
         { info_tbl: [(cdsrH,
                       label: block_cdsrH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsrH: // global
           _cdsrl::P64 = P64[Sp + 16];
           _sdrTX::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdsrS; else goto cdss1;
       cdsrS: // global
           Hp = Hp + 72;
           _sdrU3::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdss4; else goto cdsrU;
       cdsrU: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cdsrl::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sdrTX::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cdsrl::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cdss1: // global
           Hp = Hp + 72;
           _sdrU3::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdss4; else goto cdss3;
       cdss4: // global
           HpAlloc = 72;
           R1 = _sdrU3::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdss3: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cdsrl::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdsrl::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdrTX::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wpartition_entry() //  [R2, R3]
         { info_tbl: [(cdssa,
                       label: Data.List.NonEmpty.$wpartition_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdssa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdsse; else goto cdssd;
       cdsse: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wpartition_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdssd: // global
           I64[Hp - 80] = $wgo_sdrTU_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R2 = Hp - 14;
           R1 = Hp - 79;
           call $wgo_sdrTU_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.67331738 UTC

[section ""data" . Data.List.NonEmpty.partition_closure" {
     Data.List.NonEmpty.partition_closure:
         const Data.List.NonEmpty.partition_info;
 },
 Data.List.NonEmpty.partition_entry() //  [R2, R3]
         { info_tbl: [(cdste,
                       label: Data.List.NonEmpty.partition_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdste: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdstf; else goto cdstg;
       cdstf: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.partition_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdstg: // global
           I64[Sp - 8] = block_cdstb_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wpartition_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdstb() //  [R1, R2]
         { info_tbl: [(cdstb,
                       label: block_cdstb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdstb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdstj; else goto cdsti;
       cdstj: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdsti: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.679461709 UTC

[section ""data" . Data.List.NonEmpty.cycle_closure" {
     Data.List.NonEmpty.cycle_closure:
         const Data.List.NonEmpty.cycle_info;
         const 0;
 },
 xs'_sdrUB_entry() //  [R1]
         { info_tbl: [(cdstG,
                       label: xs'_sdrUB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdstG: // global
           _sdrUB::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdstH; else goto cdstI;
       cdstI: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdstK; else goto cdstJ;
       cdstK: // global
           HpAlloc = 72;
           goto cdstH;
       cdstH: // global
           R1 = _sdrUB::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdstJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrUB::P64;
           _sdrUA::P64 = P64[_sdrUB::P64 + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sdrUA::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdrUA::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = _sdrUB::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.cycle_entry() //  [R2]
         { info_tbl: [(cdstS,
                       label: Data.List.NonEmpty.cycle_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdstS: // global
           _sdrUA::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdstT; else goto cdstU;
       cdstU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdstW; else goto cdstV;
       cdstW: // global
           HpAlloc = 24;
           goto cdstT;
       cdstT: // global
           R2 = _sdrUA::P64;
           R1 = Data.List.NonEmpty.cycle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdstV: // global
           I64[Hp - 16] = xs'_sdrUB_info;
           P64[Hp] = _sdrUA::P64;
           I64[Sp - 8] = block_cdstL_info;
           R1 = Hp - 16;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udsu6; else goto cdstM;
       udsu6: // global
           call _cdstL(R1) args: 0, res: 0, upd: 0;
       cdstM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdstL() //  [R1]
         { info_tbl: [(cdstL,
                       label: block_cdstL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdstL: // global
           if (R1 & 7 == 1) goto cdstP; else goto cdstQ;
       cdstP: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdstQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsu5; else goto cdsu4;
       cdsu5: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsu4: // global
           _sdrUN::P64 = P64[R1 + 6];
           _sdrUO::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrUN::P64;
           P64[Hp] = _sdrUO::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.690227476 UTC

[section ""data" . Data.List.NonEmpty.$wtranspose_closure" {
     Data.List.NonEmpty.$wtranspose_closure:
         const Data.List.NonEmpty.$wtranspose_info;
         const 0;
 },
 sat_sdrV9_entry() //  [R1]
         { info_tbl: [(cdsuM,
                       label: sat_sdrV9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsuM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdsuN; else goto cdsuO;
       cdsuN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsuO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdsuJ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udsuS; else goto cdsuK;
       udsuS: // global
           call _cdsuJ(R1) args: 0, res: 0, upd: 0;
       cdsuK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsuJ() //  [R1]
         { info_tbl: [(cdsuJ,
                       label: block_cdsuJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsuJ: // global
           R3 = P64[R1 + 15];
           R2 = Data.List.NonEmpty.toList_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrV4_entry() //  [R1]
         { info_tbl: [(cdsv0,
                       label: sat_sdrV4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsv0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdsv4; else goto cdsv5;
       cdsv4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsv5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdsuX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udsvd; else goto cdsuY;
       udsvd: // global
           call _cdsuX(R1) args: 0, res: 0, upd: 0;
       cdsuY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsuX() //  [R1]
         { info_tbl: [(cdsuX,
                       label: block_cdsuX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsuX: // global
           I64[Sp] = block_cdsv3_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udsvc; else goto cdsv7;
       udsvc: // global
           call _cdsv3(R1) args: 0, res: 0, upd: 0;
       cdsv7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsv3() //  [R1]
         { info_tbl: [(cdsv3,
                       label: block_cdsv3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsv3: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrUX_entry() //  [R1]
         { info_tbl: [(cdsvl,
                       label: sat_sdrUX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsvl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdsvp; else goto cdsvq;
       cdsvp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsvq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdsvi_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udsvy; else goto cdsvj;
       udsvy: // global
           call _cdsvi(R1) args: 0, res: 0, upd: 0;
       cdsvj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsvi() //  [R1]
         { info_tbl: [(cdsvi,
                       label: block_cdsvi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsvi: // global
           I64[Sp] = block_cdsvo_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udsvx; else goto cdsvs;
       udsvx: // global
           call _cdsvo(R1) args: 0, res: 0, upd: 0;
       cdsvs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsvo() //  [R1]
         { info_tbl: [(cdsvo,
                       label: block_cdsvo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsvo: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
     }
 },
 ds_sdrUQ_entry() //  [R1]
         { info_tbl: [(cdsvH,
                       label: ds_sdrUQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsvH: // global
           _sdrUQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsvI; else goto cdsvJ;
       cdsvJ: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cdsvL; else goto cdsvK;
       cdsvL: // global
           HpAlloc = 120;
           goto cdsvI;
       cdsvI: // global
           R1 = _sdrUQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsvK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrUQ::P64;
           _sdrUP::P64 = P64[_sdrUQ::P64 + 16];
           I64[Hp - 112] = sat_sdrV9_info;
           P64[Hp - 96] = _sdrUP::P64;
           I64[Hp - 88] = sat_sdrV4_info;
           P64[Hp - 72] = _sdrUP::P64;
           I64[Hp - 64] = sat_sdrUX_info;
           P64[Hp - 48] = _sdrUP::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 112;
           I64[Sp - 24] = block_cdsvB_info;
           R2 = Hp - 14;
           Sp = Sp - 24;
           call Data.OldList.transpose_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsvB() //  [R1]
         { info_tbl: [(cdsvB,
                       label: block_cdsvB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsvB: // global
           if (R1 & 7 == 1) goto cdsvE; else goto cdsvF;
       cdsvE: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cdsvF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsvU; else goto cdsvT;
       cdsvU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdsvT: // global
           _sdrVc::P64 = P64[R1 + 6];
           _sdrVd::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrVc::P64;
           P64[Hp] = _sdrVd::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrVo_entry() //  [R1]
         { info_tbl: [(cdsw2,
                       label: sat_sdrVo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsw2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdsw3; else goto cdsw4;
       cdsw3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsw4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdsvZ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udsw8; else goto cdsw0;
       udsw8: // global
           call _cdsvZ(R1) args: 0, res: 0, upd: 0;
       cdsw0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsvZ() //  [R1]
         { info_tbl: [(cdsvZ,
                       label: block_cdsvZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsvZ: // global
           R3 = P64[R1 + 15];
           R2 = Data.List.NonEmpty.fromList_closure+1;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrVk_entry() //  [R1]
         { info_tbl: [(cdswg,
                       label: sat_sdrVk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdswg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdswh; else goto cdswi;
       cdswh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdswi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cdswd_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udswD; else goto cdswe;
       udswD: // global
           call _cdswd(R1) args: 0, res: 0, upd: 0;
       cdswe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdswd() //  [R1]
         { info_tbl: [(cdswd,
                       label: block_cdswd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdswd: // global
           I64[Sp] = block_cdswl_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto udswC; else goto cdswn;
       udswC: // global
           call _cdswl(R1) args: 0, res: 0, upd: 0;
       cdswn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdswl() //  [R1]
         { info_tbl: [(cdswl,
                       label: block_cdswl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdswl: // global
           if (R1 & 7 == 1) goto cdswt; else goto cdswx;
       cdswt: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cdswx: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdswA; else goto cdswz;
       cdswA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdswz: // global
           _sdrVi::P64 = P64[R1 + 6];
           _sdrVj::P64 = P64[R1 + 14];
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrVi::P64;
           P64[Hp] = _sdrVj::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wtranspose_entry() //  [R2]
         { info_tbl: [(cdswE,
                       label: Data.List.NonEmpty.$wtranspose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdswE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdswI; else goto cdswH;
       cdswI: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wtranspose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdswH: // global
           I64[Hp - 64] = ds_sdrUQ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sdrVo_info;
           _cdsuB::P64 = Hp - 64;
           P64[Hp - 24] = _cdsuB::P64;
           I64[Hp - 16] = sat_sdrVk_info;
           P64[Hp] = _cdsuB::P64;
           R2 = Hp - 40;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.727103017 UTC

[section ""data" . Data.List.NonEmpty.transpose_closure" {
     Data.List.NonEmpty.transpose_closure:
         const Data.List.NonEmpty.transpose_info;
         const 0;
 },
 Data.List.NonEmpty.transpose_entry() //  [R2]
         { info_tbl: [(cdsyv,
                       label: Data.List.NonEmpty.transpose_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsyv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdsyw; else goto cdsyx;
       cdsyw: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.transpose_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdsyx: // global
           I64[Sp - 8] = block_cdsys_info;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wtranspose_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsys() //  [R1, R2]
         { info_tbl: [(cdsys,
                       label: block_cdsys_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsys: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsyA; else goto cdsyz;
       cdsyA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdsyz: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.735452285 UTC

[section ""data" . Data.List.NonEmpty.map_closure" {
     Data.List.NonEmpty.map_closure:
         const Data.List.NonEmpty.map_info;
 },
 sat_sdrVD_entry() //  [R1]
         { info_tbl: [(cdsyX,
                       label: sat_sdrVD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsyX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsyY; else goto cdsyZ;
       cdsyY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsyZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdsyU_info;
           _sdrVt::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdrVt::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udsz3; else goto cdsyV;
       udsz3: // global
           call _cdsyU(R1) args: 0, res: 0, upd: 0;
       cdsyV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsyU() //  [R1]
         { info_tbl: [(cdsyU,
                       label: block_cdsyU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsyU: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrVz_entry() //  [R1]
         { info_tbl: [(cdsz9,
                       label: sat_sdrVz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsz9: // global
           _sdrVz::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdsza; else goto cdszb;
       cdszb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdszd; else goto cdszc;
       cdszd: // global
           HpAlloc = 24;
           goto cdsza;
       cdsza: // global
           R1 = _sdrVz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdszc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrVz::P64;
           _sdrVt::P64 = P64[_sdrVz::P64 + 16];
           _sdrVu::P64 = P64[_sdrVz::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdrVu::P64;
           R2 = Hp - 16;
           R1 = _sdrVt::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.map_entry() //  [R2, R3]
         { info_tbl: [(cdszf,
                       label: Data.List.NonEmpty.map_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdszf: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdszj; else goto cdszi;
       cdszj: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.map_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdszi: // global
           I64[Hp - 80] = sat_sdrVD_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sdrVz_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.748137743 UTC

[section ""data" . Data.List.NonEmpty.some1_closure" {
     Data.List.NonEmpty.some1_closure:
         const Data.List.NonEmpty.some1_info;
 },
 sat_sdrVH_entry() //  [R1]
         { info_tbl: [(cdszS,
                       label: sat_sdrVH_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdszS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdszT; else goto cdszU;
       cdszT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdszU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.many_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.some1_entry() //  [R2, R3]
         { info_tbl: [(cdszX,
                       label: Data.List.NonEmpty.some1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdszX: // global
           _sdrVF::P64 = R3;
           _sdrVE::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cdszY; else goto cdszZ;
       cdszZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdsA1; else goto cdsA0;
       cdsA1: // global
           HpAlloc = 32;
           goto cdszY;
       cdszY: // global
           R3 = _sdrVF::P64;
           R2 = _sdrVE::P64;
           R1 = Data.List.NonEmpty.some1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsA0: // global
           I64[Hp - 24] = sat_sdrVH_info;
           P64[Hp - 8] = _sdrVE::P64;
           P64[Hp] = _sdrVF::P64;
           I64[Sp - 24] = block_cdszV_info;
           R2 = _sdrVE::P64;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sdrVF::P64;
           Sp = Sp - 24;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdszV() //  [R1]
         { info_tbl: [(cdszV,
                       label: block_cdszV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdszV: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_ppp_info;
           P64[Sp] = GHC.Base.:|_closure+2;
           _cdszO::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cdszO::P64;
           Sp = Sp - 8;
           call GHC.Base.liftA2_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.756919946 UTC

[section ""data" . Data.List.NonEmpty.intersperse_closure" {
     Data.List.NonEmpty.intersperse_closure:
         const Data.List.NonEmpty.intersperse_info;
 },
 sat_sdrVU_entry() //  [R1]
         { info_tbl: [(cdsAO,
                       label: sat_sdrVU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsAO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsAP; else goto cdsAQ;
       cdsAP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsAQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Data.OldList.prependToAll_entry(R3,
                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrVW_entry() //  [R1]
         { info_tbl: [(cdsAR,
                       label: sat_sdrVW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsAR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsAS; else goto cdsAT;
       cdsAS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsAT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdsAz_info;
           _sdrVI::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdrVI::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udsB7; else goto cdsAA;
       udsB7: // global
           call _cdsAz(R1) args: 0, res: 0, upd: 0;
       cdsAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsAz() //  [R1]
         { info_tbl: [(cdsAz,
                       label: block_cdsAz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsAz: // global
           I64[Sp] = block_cdsAE_info;
           R1 = P64[R1 + 15];
           if (R1 & 7 != 0) goto udsB6; else goto cdsAF;
       udsB6: // global
           call _cdsAE(R1) args: 0, res: 0, upd: 0;
       cdsAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsAE() //  [R1]
         { info_tbl: [(cdsAE,
                       label: block_cdsAE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsAE: // global
           if (R1 & 7 == 1) goto cdsAY; else goto cdsB1;
       cdsAY: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdsB1: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdsB4; else goto cdsB3;
       cdsB4: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdsB3: // global
           _sdrVS::P64 = P64[R1 + 6];
           _sdrVT::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sdrVU_info;
           _sdrVI::P64 = P64[Sp + 8];
           P64[Hp - 56] = _sdrVI::P64;
           P64[Hp - 48] = _sdrVT::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = _sdrVS::P64;
           P64[Hp - 24] = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sdrVI::P64;
           P64[Hp] = Hp - 38;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.intersperse_entry() //  [R2, R3]
         { info_tbl: [(cdsBa,
                       label: Data.List.NonEmpty.intersperse_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsBa: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdsBe; else goto cdsBd;
       cdsBe: // global
           HpAlloc = 80;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.intersperse_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsBd: // global
           I64[Hp - 72] = sat_sdrVW_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.769979395 UTC

[section ""data" . Data.List.NonEmpty.iterate_closure" {
     Data.List.NonEmpty.iterate_closure:
         const Data.List.NonEmpty.iterate_info;
 },
 sat_sdrW3_entry() //  [R1]
         { info_tbl: [(cdsC5,
                       label: sat_sdrW3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsC5: // global
           _sdrW3::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsC6; else goto cdsC7;
       cdsC7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdsC9; else goto cdsC8;
       cdsC9: // global
           HpAlloc = 32;
           goto cdsC6;
       cdsC6: // global
           R1 = _sdrW3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsC8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrW3::P64;
           _sdrVX::P64 = P64[_sdrW3::P64 + 16];
           _sdrVY::P64 = P64[_sdrW3::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdrVX::P64;
           P64[Hp] = _sdrVY::P64;
           I64[Sp - 24] = block_cdsC2_info;
           R3 = Hp - 24;
           R2 = _sdrVX::P64;
           Sp = Sp - 24;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsC2() //  [R1, R2]
         { info_tbl: [(cdsC2,
                       label: block_cdsC2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsC2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsCc; else goto cdsCb;
       cdsCc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdsCb: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.iterate_entry() //  [R2, R3]
         { info_tbl: [(cdsCe,
                       label: Data.List.NonEmpty.iterate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsCe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdsCi; else goto cdsCh;
       cdsCi: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.iterate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsCh: // global
           I64[Hp - 48] = sat_sdrW3_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.778454165 UTC

[section ""data" . Data.List.NonEmpty.repeat_closure" {
     Data.List.NonEmpty.repeat_closure:
         const Data.List.NonEmpty.repeat_info;
 },
 sat_sdrW5_entry() //  [R1]
         { info_tbl: [(cdsCL,
                       label: sat_sdrW5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsCL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsCM; else goto cdsCN;
       cdsCM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsCN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.repeat_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.repeat_entry() //  [R2]
         { info_tbl: [(cdsCP,
                       label: Data.List.NonEmpty.repeat_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsCP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdsCT; else goto cdsCS;
       cdsCT: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = Data.List.NonEmpty.repeat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdsCS: // global
           I64[Hp - 40] = sat_sdrW5_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.786819685 UTC

[section ""data" . Data.List.NonEmpty.groupBy_$sgroupBy_closure" {
     Data.List.NonEmpty.groupBy_$sgroupBy_closure:
         const Data.List.NonEmpty.groupBy_$sgroupBy_info;
 },
 ds_sdrWb_entry() //  [R1]
         { info_tbl: [(cdsDp,
                       label: ds_sdrWb_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsDp: // global
           _sdrWb::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsDq; else goto cdsDr;
       cdsDr: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdsDt; else goto cdsDs;
       cdsDt: // global
           HpAlloc = 32;
           goto cdsDq;
       cdsDq: // global
           R1 = _sdrWb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsDs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrWb::P64;
           _sdrW6::P64 = P64[_sdrWb::P64 + 16];
           _sdrW9::P64 = P64[_sdrWb::P64 + 24];
           _sdrWa::P64 = P64[_sdrWb::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdrW6::P64;
           P64[Hp] = _sdrW9::P64;
           I64[Sp - 24] = block_cdsDm_info;
           R3 = _sdrWa::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsDm() //  [R1, R2]
         { info_tbl: [(cdsDm,
                       label: block_cdsDm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsDm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsDw; else goto cdsDv;
       cdsDw: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdsDv: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrWo_entry() //  [R1]
         { info_tbl: [(cdsDE,
                       label: sat_sdrWo_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsDE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsDF; else goto cdsDG;
       cdsDF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsDG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdsDB_info;
           _sdrW6::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdrW6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udsDK; else goto cdsDC;
       udsDK: // global
           call _cdsDB(R1) args: 0, res: 0, upd: 0;
       cdsDC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsDB() //  [R1]
         { info_tbl: [(cdsDB,
                       label: block_cdsDB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsDB: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy_$sgroupBy_entry() //  [R2, R3]
         { info_tbl: [(cdsDP,
                       label: Data.List.NonEmpty.groupBy_$sgroupBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsDP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsDQ; else goto cdsDR;
       cdsDQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy_$sgroupBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsDR: // global
           I64[Sp - 16] = block_cdsDb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udsE0; else goto cdsDc;
       udsE0: // global
           call _cdsDb(R1) args: 0, res: 0, upd: 0;
       cdsDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsDb() //  [R1]
         { info_tbl: [(cdsDb,
                       label: block_cdsDb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsDb: // global
           if (R1 & 7 == 1) goto cdsDM; else goto cdsDN;
       cdsDM: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdsDN: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdsDZ; else goto cdsDY;
       cdsDZ: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsDY: // global
           _sdrW9::P64 = P64[R1 + 6];
           _sdrWa::P64 = P64[R1 + 14];
           I64[Hp - 136] = ds_sdrWb_info;
           _sdrW6::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdrW6::P64;
           P64[Hp - 112] = _sdrW9::P64;
           P64[Hp - 104] = _sdrWa::P64;
           I64[Hp - 96] = sat_sdrWo_info;
           P64[Hp - 80] = _sdrW6::P64;
           _cdsDh::P64 = Hp - 136;
           P64[Hp - 72] = _cdsDh::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdsDh::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdrW9::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.802298953 UTC

[section ""data" . Data.List.NonEmpty.groupBy_closure" {
     Data.List.NonEmpty.groupBy_closure:
         const Data.List.NonEmpty.groupBy_info;
 },
 ds_sdrWv_entry() //  [R1]
         { info_tbl: [(cdsF1,
                       label: ds_sdrWv_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsF1: // global
           _sdrWv::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsF2; else goto cdsF3;
       cdsF3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdsF5; else goto cdsF4;
       cdsF5: // global
           HpAlloc = 32;
           goto cdsF2;
       cdsF2: // global
           R1 = _sdrWv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsF4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrWv::P64;
           _sdrWq::P64 = P64[_sdrWv::P64 + 16];
           _sdrWt::P64 = P64[_sdrWv::P64 + 24];
           _sdrWu::P64 = P64[_sdrWv::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdrWq::P64;
           P64[Hp] = _sdrWt::P64;
           I64[Sp - 24] = block_cdsEY_info;
           R3 = _sdrWu::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsEY() //  [R1, R2]
         { info_tbl: [(cdsEY,
                       label: block_cdsEY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsEY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsF8; else goto cdsF7;
       cdsF8: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdsF7: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrWI_entry() //  [R1]
         { info_tbl: [(cdsFg,
                       label: sat_sdrWI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsFg: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsFh; else goto cdsFi;
       cdsFh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsFi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdsFd_info;
           _sdrWq::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdrWq::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udsFm; else goto cdsFe;
       udsFm: // global
           call _cdsFd(R1) args: 0, res: 0, upd: 0;
       cdsFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsFd() //  [R1]
         { info_tbl: [(cdsFd,
                       label: block_cdsFd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsFd: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy_entry() //  [R2, R3, R4]
         { info_tbl: [(cdsFr,
                       label: Data.List.NonEmpty.groupBy_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsFr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsFs; else goto cdsFt;
       cdsFs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsFt: // global
           I64[Sp - 16] = block_cdsEO_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdsEO() //  [R1]
         { info_tbl: [(cdsEO,
                       label: block_cdsEO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsEO: // global
           if (R1 & 7 == 1) goto cdsFo; else goto cdsFp;
       cdsFo: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdsFp: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdsFB; else goto cdsFA;
       cdsFB: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsFA: // global
           _sdrWt::P64 = P64[R1 + 6];
           _sdrWu::P64 = P64[R1 + 14];
           I64[Hp - 136] = ds_sdrWv_info;
           _sdrWq::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdrWq::P64;
           P64[Hp - 112] = _sdrWt::P64;
           P64[Hp - 104] = _sdrWu::P64;
           I64[Hp - 96] = sat_sdrWI_info;
           P64[Hp - 80] = _sdrWq::P64;
           _cdsET::P64 = Hp - 136;
           P64[Hp - 72] = _cdsET::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdsET::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdrWt::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.818064909 UTC

[section ""data" . Data.List.NonEmpty.groupWith_closure" {
     Data.List.NonEmpty.groupWith_closure:
         const Data.List.NonEmpty.groupWith_info;
 },
 eq0_sdrWQ_entry() //  [R1, R2, R3]
         { info_tbl: [(cdsGB,
                       label: eq0_sdrWQ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsGB: // global
           _sdrWS::P64 = R3;
           _sdrWR::P64 = R2;
           _sdrWQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsGC; else goto cdsGD;
       cdsGD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdsGF; else goto cdsGE;
       cdsGF: // global
           HpAlloc = 64;
           goto cdsGC;
       cdsGC: // global
           R3 = _sdrWS::P64;
           R2 = _sdrWR::P64;
           R1 = _sdrWQ::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsGE: // global
           _sdrWK::P64 = P64[_sdrWQ::P64 + 6];
           _sdrWL::P64 = P64[_sdrWQ::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdrWL::P64;
           P64[Hp - 32] = _sdrWS::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdrWL::P64;
           P64[Hp] = _sdrWR::P64;
           R2 = _sdrWK::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdrWW_entry() //  [R1, R2]
         { info_tbl: [(cdsGP,
                       label: sat_sdrWW_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsGP: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call eq0_sdrWQ_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdrWV_entry() //  [R1]
         { info_tbl: [(cdsGV,
                       label: ds_sdrWV_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsGV: // global
           _sdrWV::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsGW; else goto cdsGX;
       cdsGX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsGZ; else goto cdsGY;
       cdsGZ: // global
           HpAlloc = 24;
           goto cdsGW;
       cdsGW: // global
           R1 = _sdrWV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsGY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrWV::P64;
           _sdrWO::P64 = P64[_sdrWV::P64 + 16];
           _sdrWP::P64 = P64[_sdrWV::P64 + 24];
           _sdrWQ::P64 = P64[_sdrWV::P64 + 32];
           I64[Hp - 16] = sat_sdrWW_info;
           P64[Hp - 8] = _sdrWO::P64;
           P64[Hp] = _sdrWQ::P64;
           I64[Sp - 24] = block_cdsGS_info;
           R3 = _sdrWP::P64;
           R2 = Hp - 15;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsGS() //  [R1, R2]
         { info_tbl: [(cdsGS,
                       label: block_cdsGS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsGS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsH2; else goto cdsH1;
       cdsH2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdsH1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrX8_entry() //  [R1]
         { info_tbl: [(cdsHa,
                       label: sat_sdrX8_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsHa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsHb; else goto cdsHc;
       cdsHb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsHc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdsH7_info;
           _sdrWQ::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdrWQ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udsHg; else goto cdsH8;
       udsHg: // global
           call _cdsH7(R1) args: 0, res: 0, upd: 0;
       cdsH8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsH7() //  [R1]
         { info_tbl: [(cdsH7,
                       label: block_cdsH7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsH7: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupWith_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdsHl,
                       label: Data.List.NonEmpty.groupWith_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsHl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdsHm; else goto cdsHn;
       cdsHm: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupWith_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsHn: // global
           I64[Sp - 24] = block_cdsGp_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = R5;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Data.Foldable.toList_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _cdsGp() //  [R1]
         { info_tbl: [(cdsGp,
                       label: block_cdsGp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsGp: // global
           if (R1 & 7 == 1) goto cdsHi; else goto cdsHj;
       cdsHi: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdsHj: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdsHv; else goto cdsHu;
       cdsHv: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsHu: // global
           _sdrWO::P64 = P64[R1 + 6];
           _sdrWP::P64 = P64[R1 + 14];
           I64[Hp - 160] = eq0_sdrWQ_info;
           P64[Hp - 152] = P64[Sp + 8];
           P64[Hp - 144] = P64[Sp + 16];
           I64[Hp - 136] = ds_sdrWV_info;
           P64[Hp - 120] = _sdrWO::P64;
           P64[Hp - 112] = _sdrWP::P64;
           _cdsGu::P64 = Hp - 158;
           P64[Hp - 104] = _cdsGu::P64;
           I64[Hp - 96] = sat_sdrX8_info;
           P64[Hp - 80] = _cdsGu::P64;
           _cdsGG::P64 = Hp - 136;
           P64[Hp - 72] = _cdsGG::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdsGG::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdrWO::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.839666779 UTC

[section ""data" . Data.List.NonEmpty.group_closure" {
     Data.List.NonEmpty.group_closure:
         const Data.List.NonEmpty.group_info;
 },
 sat_sdrXc_entry() //  [R1]
         { info_tbl: [(cdsIC,
                       label: sat_sdrXc_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsIC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsID; else goto cdsIE;
       cdsID: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsIE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.group_entry() //  [R2, R3, R4]
         { info_tbl: [(cdsIF,
                       label: Data.List.NonEmpty.group_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsIF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsIJ; else goto cdsII;
       cdsIJ: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.group_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsII: // global
           I64[Hp - 16] = sat_sdrXc_info;
           P64[Hp] = R3;
           R4 = R4;
           R3 = Hp - 16;
           R2 = R2;
           call Data.List.NonEmpty.groupBy_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.846070184 UTC

[section ""data" . Data.List.NonEmpty.isPrefixOf_closure" {
     Data.List.NonEmpty.isPrefixOf_closure:
         const Data.List.NonEmpty.isPrefixOf_info;
 },
 Data.List.NonEmpty.isPrefixOf_entry() //  [R2, R3, R4]
         { info_tbl: [(cdsJ5,
                       label: Data.List.NonEmpty.isPrefixOf_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsJ5: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cdsJ6; else goto cdsJ7;
       cdsJ6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.isPrefixOf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsJ7: // global
           I64[Sp - 24] = block_cdsIY_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udsJx; else goto cdsIZ;
       udsJx: // global
           call _cdsIY(R1) args: 0, res: 0, upd: 0;
       cdsIZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsIY() //  [R1]
         { info_tbl: [(cdsIY,
                       label: block_cdsIY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsIY: // global
           if (R1 & 7 == 1) goto cdsJ2; else goto cdsJ3;
       cdsJ2: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdsJ3: // global
           I64[Sp - 8] = block_cdsJd_info;
           _sdrXh::P64 = P64[R1 + 6];
           _sdrXi::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sdrXi::P64;
           P64[Sp + 16] = _sdrXh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udsJw; else goto cdsJf;
       udsJw: // global
           call _cdsJd(R1) args: 0, res: 0, upd: 0;
       cdsJf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsJd() //  [R1]
         { info_tbl: [(cdsJd,
                       label: block_cdsJd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsJd: // global
           I64[Sp] = block_cdsJj_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cdsJj() //  [R1]
         { info_tbl: [(cdsJj,
                       label: block_cdsJj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsJj: // global
           if (R1 & 7 == 1) goto cdsJq; else goto cdsJu;
       cdsJq: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdsJu: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Data.OldList.isPrefixOf_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.855599488 UTC

[section ""cstring" . lvl1_rdpwu_bytes" {
     lvl1_rdpwu_bytes:
         I8[] [78,111,110,69,109,112,116,121,46,33,33,32,110,101,103,97,116,105,118,101,32,97,114,103,117,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.857608144 UTC

[section ""data" . Data.List.NonEmpty.!!1_closure" {
     Data.List.NonEmpty.!!1_closure:
         const Data.List.NonEmpty.!!1_info;
         const 0;
         const 0;
         const 0;
 },
 Data.List.NonEmpty.!!1_entry() //  [R1]
         { info_tbl: [(cdsKc,
                       label: Data.List.NonEmpty.!!1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsKc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdsKd; else goto cdsKe;
       cdsKd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsKe: // global
           (_cdsK7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cdsK7::I64 == 0) goto cdsK9; else goto cdsK8;
       cdsK9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cdsK8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cdsK7::I64;
           I64[Sp - 24] = block_cdsKa_info;
           R2 = lvl1_rdpwu_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsKa() //  [R1]
         { info_tbl: [(cdsKa,
                       label: block_cdsKa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsKa: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.863359576 UTC

[section ""data" . Data.List.NonEmpty.$w!!_closure" {
     Data.List.NonEmpty.$w!!_closure:
         const Data.List.NonEmpty.$w!!_info;
         const 0;
 },
 Data.List.NonEmpty.$w!!_entry() //  [R2, R3, R4]
         { info_tbl: [(cdsKC,
                       label: Data.List.NonEmpty.$w!!_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsKC: // global
           if (R4 == 0) goto cdsKB; else goto cdsKA;
       cdsKB: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdsKA: // global
           if (%MO_S_Le_W64(R4, 0)) goto cdsKJ; else goto cdsKK;
       cdsKJ: // global
           R1 = Data.List.NonEmpty.!!1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cdsKK: // global
           _sdrXp::P64 = R3;
           R3 = R4 - 1;
           R2 = _sdrXp::P64;
           call GHC.List.$w!!_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.867803673 UTC

[section ""data" . Data.List.NonEmpty.!!_closure" {
     Data.List.NonEmpty.!!_closure:
         const Data.List.NonEmpty.!!_info;
         const 0;
 },
 Data.List.NonEmpty.!!_entry() //  [R2, R3]
         { info_tbl: [(cdsKZ,
                       label: Data.List.NonEmpty.!!_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsKZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdsL3; else goto cdsL4;
       cdsL3: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.!!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsL4: // global
           I64[Sp - 16] = block_cdsKW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udsLc; else goto cdsKX;
       udsLc: // global
           call _cdsKW(R1) args: 0, res: 0, upd: 0;
       cdsKX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsKW() //  [R1]
         { info_tbl: [(cdsKW,
                       label: block_cdsKW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsKW: // global
           I64[Sp - 8] = block_cdsL2_info;
           _sdrXx::P64 = P64[R1 + 7];
           _sdrXy::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp] = _sdrXy::P64;
           P64[Sp + 8] = _sdrXx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udsLb; else goto cdsL6;
       udsLb: // global
           call _cdsL2(R1) args: 0, res: 0, upd: 0;
       cdsL6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsL2() //  [R1]
         { info_tbl: [(cdsL2,
                       label: block_cdsL2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsL2: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Data.List.NonEmpty.$w!!_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.876355008 UTC

[section ""data" . Data.List.NonEmpty.zip_closure" {
     Data.List.NonEmpty.zip_closure:
         const Data.List.NonEmpty.zip_info;
 },
 sat_sdrXT_entry() //  [R1]
         { info_tbl: [(cdsLD,
                       label: sat_sdrXT_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsLD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsLH; else goto cdsLI;
       cdsLH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsLI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdsLA_info;
           _sdrXC::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sdrXC::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udsLM; else goto cdsLB;
       udsLM: // global
           call _cdsLA(R1) args: 0, res: 0, upd: 0;
       cdsLB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsLA() //  [R1]
         { info_tbl: [(cdsLA,
                       label: block_cdsLA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsLA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsLL; else goto cdsLK;
       cdsLL: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdsLK: // global
           _sdrXO::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 16;
           R2 = _sdrXO::P64;
           Sp = Sp + 16;
           call GHC.List.zip_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.zip_entry() //  [R2, R3]
         { info_tbl: [(cdsLR,
                       label: Data.List.NonEmpty.zip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsLR: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cdsLV; else goto cdsLU;
       cdsLV: // global
           HpAlloc = 128;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.zip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsLU: // global
           I64[Hp - 120] = sat_sdrXT_info;
           P64[Hp - 104] = R2;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = stg_sel_0_upd_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 120;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.885785052 UTC

[section ""data" . Data.List.NonEmpty.zipWith_closure" {
     Data.List.NonEmpty.zipWith_closure:
         const Data.List.NonEmpty.zipWith_info;
 },
 sat_sdrYd_entry() //  [R1]
         { info_tbl: [(cdsMx,
                       label: sat_sdrYd_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsMx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdsMB; else goto cdsMC;
       cdsMB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsMC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdsMu_info;
           _sdrXU::P64 = P64[R1 + 16];
           _sdrXW::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sdrXU::P64;
           P64[Sp - 24] = _sdrXW::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udsMG; else goto cdsMv;
       udsMG: // global
           call _cdsMu(R1) args: 0, res: 0, upd: 0;
       cdsMv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsMu() //  [R1]
         { info_tbl: [(cdsMu,
                       label: block_cdsMu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsMu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsMF; else goto cdsME;
       cdsMF: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdsME: // global
           _sdrY8::P64 = P64[R1 + 15];
           I64[Hp - 16] = stg_sel_1_noupd_info;
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 16;
           R3 = _sdrY8::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.List.zipWith_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrY5_entry() //  [R1]
         { info_tbl: [(cdsMN,
                       label: sat_sdrY5_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsMN: // global
           _sdrY5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdsMO; else goto cdsMP;
       cdsMP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdsMR; else goto cdsMQ;
       cdsMR: // global
           HpAlloc = 48;
           goto cdsMO;
       cdsMO: // global
           R1 = _sdrY5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsMQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrY5::P64;
           _sdrXU::P64 = P64[_sdrY5::P64 + 16];
           _sdrXV::P64 = P64[_sdrY5::P64 + 24];
           _sdrXW::P64 = P64[_sdrY5::P64 + 32];
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sdrXW::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sdrXV::P64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = _sdrXU::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.zipWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdsMT,
                       label: Data.List.NonEmpty.zipWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsMT: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdsMX; else goto cdsMW;
       cdsMX: // global
           HpAlloc = 104;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.zipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsMW: // global
           I64[Hp - 96] = sat_sdrYd_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_sdrY5_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.897065468 UTC

[section ""data" . Data.List.NonEmpty.unzip_closure" {
     Data.List.NonEmpty.unzip_closure:
         const Data.List.NonEmpty.unzip_info;
 },
 sat_sdrYh_entry() //  [R1]
         { info_tbl: [(cdsNz,
                       label: sat_sdrYh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsNz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdsNA; else goto cdsNB;
       cdsNA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsNB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Tuple.snd_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 sat_sdrYg_entry() //  [R1]
         { info_tbl: [(cdsNG,
                       label: sat_sdrYg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsNG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdsNH; else goto cdsNI;
       cdsNH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsNI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Data.Tuple.fst_closure+1;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.unzip_entry() //  [R2, R3]
         { info_tbl: [(cdsNK,
                       label: Data.List.NonEmpty.unzip_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsNK: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cdsNO; else goto cdsNN;
       cdsNO: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.unzip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsNN: // global
           I64[Hp - 80] = sat_sdrYh_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sdrYg_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.90601514 UTC

[section ""data" . Data.List.NonEmpty.nubBy_closure" {
     Data.List.NonEmpty.nubBy_closure:
         const Data.List.NonEmpty.nubBy_info;
 },
 sat_sdrYp_entry() //  [R1, R2]
         { info_tbl: [(cdsOF,
                       label: sat_sdrYp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsOF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdsOG; else goto cdsOH;
       cdsOG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdsOH: // global
           I64[Sp - 8] = block_cdsOz_info;
           R3 = R2;
           R2 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsOz() //  [R1]
         { info_tbl: [(cdsOz,
                       label: block_cdsOz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsOz: // global
           if (R1 & 7 == 1) goto cdsOC; else goto cdsOD;
       cdsOC: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdsOD: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdrYr_entry() //  [R1]
         { info_tbl: [(cdsOQ,
                       label: sat_sdrYr_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsOQ: // global
           _sdrYr::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cdsOR; else goto cdsOS;
       cdsOS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsOU; else goto cdsOT;
       cdsOU: // global
           HpAlloc = 24;
           goto cdsOR;
       cdsOR: // global
           R1 = _sdrYr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsOT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrYr::P64;
           _sdrYi::P64 = P64[_sdrYr::P64 + 16];
           _sdrYl::P64 = P64[_sdrYr::P64 + 24];
           _sdrYm::P64 = P64[_sdrYr::P64 + 32];
           I64[Hp - 16] = sat_sdrYp_info;
           P64[Hp - 8] = _sdrYi::P64;
           P64[Hp] = _sdrYl::P64;
           I64[Sp - 32] = block_cdsOO_info;
           R3 = _sdrYm::P64;
           R2 = Hp - 15;
           P64[Sp - 24] = _sdrYi::P64;
           Sp = Sp - 32;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsOO() //  [R1]
         { info_tbl: [(cdsOO,
                       label: block_cdsOO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsOO: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.OldList.nubBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.nubBy_entry() //  [R2, R3]
         { info_tbl: [(cdsOY,
                       label: Data.List.NonEmpty.nubBy_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsOY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsP0; else goto cdsP1;
       cdsP0: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.nubBy_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsP1: // global
           I64[Sp - 16] = block_cdsOl_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udsP5; else goto cdsOm;
       udsP5: // global
           call _cdsOl(R1) args: 0, res: 0, upd: 0;
       cdsOm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsOl() //  [R1]
         { info_tbl: [(cdsOl,
                       label: block_cdsOl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsOl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdsP4; else goto cdsP3;
       cdsP4: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsP3: // global
           _sdrYl::P64 = P64[R1 + 7];
           _sdrYm::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdrYr_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sdrYl::P64;
           P64[Hp - 24] = _sdrYm::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrYl::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.920973129 UTC

[section ""data" . Data.List.NonEmpty.nub_closure" {
     Data.List.NonEmpty.nub_closure:
         const Data.List.NonEmpty.nub_info;
 },
 w_sdrYx_entry() //  [R1]
         { info_tbl: [(cdsQ0,
                       label: w_sdrYx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsQ0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsQ1; else goto cdsQ2;
       cdsQ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsQ2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrYA_entry() //  [R1, R2]
         { info_tbl: [(cdsQe,
                       label: sat_sdrYA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsQe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdsQf; else goto cdsQg;
       cdsQf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdsQg: // global
           I64[Sp - 8] = block_cdsQ8_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           Sp = Sp - 8;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsQ8() //  [R1]
         { info_tbl: [(cdsQ8,
                       label: block_cdsQ8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsQ8: // global
           if (R1 & 7 == 1) goto cdsQb; else goto cdsQc;
       cdsQb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdsQc: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sdrYC_entry() //  [R1]
         { info_tbl: [(cdsQp,
                       label: sat_sdrYC_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsQp: // global
           _sdrYC::P64 = R1;
           if ((Sp + -32) < SpLim) (likely: False) goto cdsQq; else goto cdsQr;
       cdsQr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdsQt; else goto cdsQs;
       cdsQt: // global
           HpAlloc = 48;
           goto cdsQq;
       cdsQq: // global
           R1 = _sdrYC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsQs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrYC::P64;
           _sdrYs::P64 = P64[_sdrYC::P64 + 16];
           _sdrYv::P64 = P64[_sdrYC::P64 + 24];
           _sdrYw::P64 = P64[_sdrYC::P64 + 32];
           I64[Hp - 40] = w_sdrYx_info;
           P64[Hp - 24] = _sdrYs::P64;
           I64[Hp - 16] = sat_sdrYA_info;
           P64[Hp - 8] = _sdrYv::P64;
           _cdsPW::P64 = Hp - 40;
           P64[Hp] = _cdsPW::P64;
           I64[Sp - 32] = block_cdsQn_info;
           R3 = _sdrYw::P64;
           R2 = Hp - 15;
           P64[Sp - 24] = _cdsPW::P64;
           Sp = Sp - 32;
           call GHC.List.filter_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsQn() //  [R1]
         { info_tbl: [(cdsQn,
                       label: block_cdsQn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsQn: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.OldList.nubBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.nub_entry() //  [R2, R3]
         { info_tbl: [(cdsQx,
                       label: Data.List.NonEmpty.nub_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsQx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsQz; else goto cdsQA;
       cdsQz: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.nub_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsQA: // global
           I64[Sp - 16] = block_cdsPN_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udsQE; else goto cdsPO;
       udsQE: // global
           call _cdsPN(R1) args: 0, res: 0, upd: 0;
       cdsPO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsPN() //  [R1]
         { info_tbl: [(cdsPN,
                       label: block_cdsPN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsPN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdsQD; else goto cdsQC;
       cdsQD: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsQC: // global
           _sdrYv::P64 = P64[R1 + 7];
           _sdrYw::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sdrYC_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sdrYv::P64;
           P64[Hp - 24] = _sdrYw::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sdrYv::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.936323931 UTC

[section ""cstring" . Data.List.NonEmpty.$trModule4_bytes" {
     Data.List.NonEmpty.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.938098593 UTC

[section ""data" . Data.List.NonEmpty.$trModule3_closure" {
     Data.List.NonEmpty.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.NonEmpty.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.939851104 UTC

[section ""cstring" . Data.List.NonEmpty.$trModule2_bytes" {
     Data.List.NonEmpty.$trModule2_bytes:
         I8[] [68,97,116,97,46,76,105,115,116,46,78,111,110,69,109,112,116,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.94221609 UTC

[section ""data" . Data.List.NonEmpty.$trModule1_closure" {
     Data.List.NonEmpty.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Data.List.NonEmpty.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.94395968 UTC

[section ""data" . Data.List.NonEmpty.$trModule_closure" {
     Data.List.NonEmpty.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Data.List.NonEmpty.$trModule3_closure+1;
         const Data.List.NonEmpty.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.946561439 UTC

[section ""data" . Data.List.NonEmpty.groupAllWith_closure" {
     Data.List.NonEmpty.groupAllWith_closure:
         const Data.List.NonEmpty.groupAllWith_info;
         const 0;
 },
 sat_sdrYL_entry() //  [R1, R2, R3]
         { info_tbl: [(cdsRI,
                       label: sat_sdrYL_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsRI: // global
           _sdrYI::P64 = R3;
           _sdrYH::P64 = R2;
           _sdrYL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsRJ; else goto cdsRK;
       cdsRK: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdsRM; else goto cdsRL;
       cdsRM: // global
           HpAlloc = 64;
           goto cdsRJ;
       cdsRJ: // global
           R3 = _sdrYI::P64;
           R2 = _sdrYH::P64;
           R1 = _sdrYL::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsRL: // global
           _sdrYD::P64 = P64[_sdrYL::P64 + 6];
           _sdrYE::P64 = P64[_sdrYL::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdrYE::P64;
           P64[Hp - 32] = _sdrYI::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdrYE::P64;
           P64[Hp] = _sdrYH::P64;
           R2 = _sdrYD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdrYM_entry() //  [R1]
         { info_tbl: [(cdsRN,
                       label: sat_sdrYM_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsRN: // global
           _sdrYM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdsRO; else goto cdsRP;
       cdsRP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsRR; else goto cdsRQ;
       cdsRR: // global
           HpAlloc = 24;
           goto cdsRO;
       cdsRO: // global
           R1 = _sdrYM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsRQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrYM::P64;
           _sdrYD::P64 = P64[_sdrYM::P64 + 16];
           _sdrYE::P64 = P64[_sdrYM::P64 + 24];
           _sdrYF::P64 = P64[_sdrYM::P64 + 32];
           I64[Hp - 16] = sat_sdrYL_info;
           P64[Hp - 8] = _sdrYD::P64;
           P64[Hp] = _sdrYE::P64;
           R3 = _sdrYF::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call Data.OldList.sortBy_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrYG_entry() //  [R1]
         { info_tbl: [(cdsRW,
                       label: sat_sdrYG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsRW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsRX; else goto cdsRY;
       cdsRX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsRY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupAllWith_entry() //  [R2, R3, R4]
         { info_tbl: [(cdsRZ,
                       label: Data.List.NonEmpty.groupAllWith_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsRZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdsS3; else goto cdsS2;
       cdsS3: // global
           HpAlloc = 64;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupAllWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsS2: // global
           I64[Hp - 56] = sat_sdrYM_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           I64[Hp - 16] = sat_sdrYG_info;
           P64[Hp] = R2;
           R5 = Hp - 56;
           R4 = R3;
           R3 = Hp - 16;
           R2 = Data.Foldable.$fFoldable[]_closure;
           call Data.List.NonEmpty.groupWith_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.95886811 UTC

[section ""data" . Data.List.NonEmpty.groupBy1_closure" {
     Data.List.NonEmpty.groupBy1_closure:
         const Data.List.NonEmpty.groupBy1_info;
 },
 ds_sdrYS_entry() //  [R1]
         { info_tbl: [(cdsSL,
                       label: ds_sdrYS_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsSL: // global
           _sdrYS::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsSM; else goto cdsSN;
       cdsSN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdsSP; else goto cdsSO;
       cdsSP: // global
           HpAlloc = 32;
           goto cdsSM;
       cdsSM: // global
           R1 = _sdrYS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsSO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrYS::P64;
           _sdrYN::P64 = P64[_sdrYS::P64 + 16];
           _sdrYQ::P64 = P64[_sdrYS::P64 + 24];
           _sdrYR::P64 = P64[_sdrYS::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdrYN::P64;
           P64[Hp] = _sdrYQ::P64;
           I64[Sp - 24] = block_cdsSI_info;
           R3 = _sdrYR::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsSI() //  [R1, R2]
         { info_tbl: [(cdsSI,
                       label: block_cdsSI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsSI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsSS; else goto cdsSR;
       cdsSS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdsSR: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrZ5_entry() //  [R1]
         { info_tbl: [(cdsT0,
                       label: sat_sdrZ5_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsT0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsT1; else goto cdsT2;
       cdsT1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsT2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdsSX_info;
           _sdrYN::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdrYN::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udsT6; else goto cdsSY;
       udsT6: // global
           call _cdsSX(R1) args: 0, res: 0, upd: 0;
       cdsSY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsSX() //  [R1]
         { info_tbl: [(cdsSX,
                       label: block_cdsSX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsSX: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.groupBy1_entry() //  [R2, R3]
         { info_tbl: [(cdsT7,
                       label: Data.List.NonEmpty.groupBy1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsT7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsTb; else goto cdsTc;
       cdsTb: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupBy1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsTc: // global
           I64[Sp - 16] = block_cdsSy_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udsTg; else goto cdsSz;
       udsTg: // global
           call _cdsSy(R1) args: 0, res: 0, upd: 0;
       cdsSz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsSy() //  [R1]
         { info_tbl: [(cdsSy,
                       label: block_cdsSy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsSy: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdsTf; else goto cdsTe;
       cdsTf: // global
           HpAlloc = 144;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsTe: // global
           _sdrYQ::P64 = P64[R1 + 7];
           _sdrYR::P64 = P64[R1 + 15];
           I64[Hp - 136] = ds_sdrYS_info;
           _sdrYN::P64 = P64[Sp + 8];
           P64[Hp - 120] = _sdrYN::P64;
           P64[Hp - 112] = _sdrYQ::P64;
           P64[Hp - 104] = _sdrYR::P64;
           I64[Hp - 96] = sat_sdrZ5_info;
           P64[Hp - 80] = _sdrYN::P64;
           _cdsSD::P64 = Hp - 136;
           P64[Hp - 72] = _cdsSD::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdsSD::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdrYQ::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.974020481 UTC

[section ""data" . Data.List.NonEmpty.group1_closure" {
     Data.List.NonEmpty.group1_closure:
         const Data.List.NonEmpty.group1_info;
 },
 w_sdrZb_entry() //  [R1]
         { info_tbl: [(cdsU9,
                       label: w_sdrZb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsU9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsUa; else goto cdsUb;
       cdsUa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsUb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.==_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sdrZc_entry() //  [R1]
         { info_tbl: [(cdsUk,
                       label: ds_sdrZc_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsUk: // global
           _sdrZc::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsUl; else goto cdsUm;
       cdsUm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdsUo; else goto cdsUn;
       cdsUo: // global
           HpAlloc = 32;
           goto cdsUl;
       cdsUl: // global
           R1 = _sdrZc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsUn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrZc::P64;
           _sdrZ9::P64 = P64[_sdrZc::P64 + 16];
           _sdrZa::P64 = P64[_sdrZc::P64 + 24];
           _sdrZb::P64 = P64[_sdrZc::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdrZb::P64;
           P64[Hp] = _sdrZ9::P64;
           I64[Sp - 24] = block_cdsUh_info;
           R3 = _sdrZa::P64;
           R2 = Hp - 24;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsUh() //  [R1, R2]
         { info_tbl: [(cdsUh,
                       label: block_cdsUh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsUh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsUr; else goto cdsUq;
       cdsUr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdsUq: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrZp_entry() //  [R1]
         { info_tbl: [(cdsUz,
                       label: sat_sdrZp_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsUz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsUA; else goto cdsUB;
       cdsUA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsUB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdsUw_info;
           _sdrZb::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdrZb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udsUF; else goto cdsUx;
       udsUF: // global
           call _cdsUw(R1) args: 0, res: 0, upd: 0;
       cdsUx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsUw() //  [R1]
         { info_tbl: [(cdsUw,
                       label: block_cdsUw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsUw: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.group1_entry() //  [R2, R3]
         { info_tbl: [(cdsUG,
                       label: Data.List.NonEmpty.group1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsUG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsUK; else goto cdsUL;
       cdsUK: // global
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.group1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsUL: // global
           I64[Sp - 16] = block_cdsU0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udsUP; else goto cdsU1;
       udsUP: // global
           call _cdsU0(R1) args: 0, res: 0, upd: 0;
       cdsU1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsU0() //  [R1]
         { info_tbl: [(cdsU0,
                       label: block_cdsU0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsU0: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cdsUO; else goto cdsUN;
       cdsUO: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsUN: // global
           _sdrZ9::P64 = P64[R1 + 7];
           _sdrZa::P64 = P64[R1 + 15];
           I64[Hp - 160] = w_sdrZb_info;
           P64[Hp - 144] = P64[Sp + 8];
           I64[Hp - 136] = ds_sdrZc_info;
           P64[Hp - 120] = _sdrZ9::P64;
           P64[Hp - 112] = _sdrZa::P64;
           _cdsU5::P64 = Hp - 160;
           P64[Hp - 104] = _cdsU5::P64;
           I64[Hp - 96] = sat_sdrZp_info;
           P64[Hp - 80] = _cdsU5::P64;
           _cdsUc::P64 = Hp - 136;
           P64[Hp - 72] = _cdsUc::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _cdsUc::P64;
           I64[Hp - 40] = GHC.Base.:|_con_info;
           P64[Hp - 32] = _sdrZ9::P64;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:38.991244382 UTC

[section ""data" . Data.List.NonEmpty.$wgroupWith1_closure" {
     Data.List.NonEmpty.$wgroupWith1_closure:
         const Data.List.NonEmpty.$wgroupWith1_info;
 },
 eq_sdrZu_entry() //  [R1, R2, R3]
         { info_tbl: [(cdsVN,
                       label: eq_sdrZu_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsVN: // global
           _sdrZw::P64 = R3;
           _sdrZv::P64 = R2;
           _sdrZu::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsVO; else goto cdsVP;
       cdsVP: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdsVR; else goto cdsVQ;
       cdsVR: // global
           HpAlloc = 64;
           goto cdsVO;
       cdsVO: // global
           R3 = _sdrZw::P64;
           R2 = _sdrZv::P64;
           R1 = _sdrZu::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsVQ: // global
           _sdrZq::P64 = P64[_sdrZu::P64 + 6];
           _sdrZr::P64 = P64[_sdrZu::P64 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sdrZr::P64;
           P64[Hp - 32] = _sdrZw::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sdrZr::P64;
           P64[Hp] = _sdrZv::P64;
           R2 = _sdrZq::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 sat_sdrZA_entry() //  [R1, R2]
         { info_tbl: [(cdsW1,
                       label: sat_sdrZA_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsW1: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           call eq_sdrZu_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 ds_sdrZz_entry() //  [R1]
         { info_tbl: [(cdsW7,
                       label: ds_sdrZz_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsW7: // global
           _sdrZz::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsW8; else goto cdsW9;
       cdsW9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsWb; else goto cdsWa;
       cdsWb: // global
           HpAlloc = 24;
           goto cdsW8;
       cdsW8: // global
           R1 = _sdrZz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsWa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sdrZz::P64;
           _sdrZs::P64 = P64[_sdrZz::P64 + 16];
           _sdrZt::P64 = P64[_sdrZz::P64 + 24];
           _sdrZu::P64 = P64[_sdrZz::P64 + 32];
           I64[Hp - 16] = sat_sdrZA_info;
           P64[Hp - 8] = _sdrZs::P64;
           P64[Hp] = _sdrZu::P64;
           I64[Sp - 24] = block_cdsW4_info;
           R3 = _sdrZt::P64;
           R2 = Hp - 15;
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cdsW4() //  [R1, R2]
         { info_tbl: [(cdsW4,
                       label: block_cdsW4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsW4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsWe; else goto cdsWd;
       cdsWe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cdsWd: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sdrZM_entry() //  [R1]
         { info_tbl: [(cdsWm,
                       label: sat_sdrZM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsWm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdsWn; else goto cdsWo;
       cdsWn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsWo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdsWj_info;
           _sdrZu::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sdrZu::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udsWs; else goto cdsWk;
       udsWs: // global
           call _cdsWj(R1) args: 0, res: 0, upd: 0;
       cdsWk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cdsWj() //  [R1]
         { info_tbl: [(cdsWj,
                       label: block_cdsWj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsWj: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.groupBy_$sgroupBy_entry(R3,
                                                           R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wgroupWith1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(cdsWv,
                       label: Data.List.NonEmpty.$wgroupWith1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsWv: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cdsWz; else goto cdsWy;
       cdsWz: // global
           HpAlloc = 144;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wgroupWith1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsWy: // global
           I64[Hp - 136] = eq_sdrZu_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           I64[Hp - 112] = ds_sdrZz_info;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           _cdsVG::P64 = Hp - 134;
           P64[Hp - 80] = _cdsVG::P64;
           I64[Hp - 72] = sat_sdrZM_info;
           P64[Hp - 56] = _cdsVG::P64;
           _cdsVS::P64 = Hp - 112;
           P64[Hp - 48] = _cdsVS::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cdsVS::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R4;
           P64[Hp] = Hp - 40;
           R2 = Hp - 72;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.00827309 UTC

[section ""data" . Data.List.NonEmpty.groupWith1_closure" {
     Data.List.NonEmpty.groupWith1_closure:
         const Data.List.NonEmpty.groupWith1_info;
 },
 Data.List.NonEmpty.groupWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdsXq,
                       label: Data.List.NonEmpty.groupWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsXq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdsXw; else goto cdsXx;
       cdsXw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsXx: // global
           I64[Sp - 24] = block_cdsXn_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udsXC; else goto cdsXo;
       udsXC: // global
           call _cdsXn(R1) args: 0, res: 0, upd: 0;
       cdsXo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsXn() //  [R1]
         { info_tbl: [(cdsXn,
                       label: block_cdsXn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsXn: // global
           _sdrZO::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cdsXt_info;
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _sdrZO::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Data.List.NonEmpty.$wgroupWith1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsXt() //  [R1, R2]
         { info_tbl: [(cdsXt,
                       label: block_cdsXt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsXt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsXB; else goto cdsXA;
       cdsXB: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdsXA: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.016582344 UTC

[section ""data" . Data.List.NonEmpty.$wgroupAllWith1_closure" {
     Data.List.NonEmpty.$wgroupAllWith1_closure:
         const Data.List.NonEmpty.$wgroupAllWith1_info;
         const 0;
 },
 sat_sdrZZ_entry() //  [R1, R2, R3]
         { info_tbl: [(cdsY5,
                       label: sat_sdrZZ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsY5: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Data.Ord.comparing_entry(R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sds0d_entry() //  [R1]
         { info_tbl: [(cdsYh,
                       label: sat_sds0d_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsYh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdsYi; else goto cdsYj;
       cdsYi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdsYj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Data.List.NonEmpty.$wgroupAllWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdsYo,
                       label: Data.List.NonEmpty.$wgroupAllWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsYo: // global
           _sdrZY::P64 = R4;
           _sdrZX::P64 = R3;
           _sdrZW::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdsYp; else goto cdsYq;
       cdsYq: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cdsYs; else goto cdsYr;
       cdsYs: // global
           HpAlloc = 96;
           goto cdsYp;
       cdsYp: // global
           R4 = _sdrZY::P64;
           R3 = _sdrZX::P64;
           R2 = _sdrZW::P64;
           R1 = Data.List.NonEmpty.$wgroupAllWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsYr: // global
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _sdrZY::P64;
           I64[Hp - 64] = stg_sel_0_upd_info;
           P64[Hp - 48] = _sdrZY::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = sat_sdrZZ_info;
           P64[Hp - 8] = _sdrZW::P64;
           P64[Hp] = _sdrZX::P64;
           I64[Sp - 24] = block_cdsY8_info;
           R3 = Hp - 38;
           R2 = Hp - 14;
           P64[Sp - 16] = _sdrZW::P64;
           P64[Sp - 8] = _sdrZX::P64;
           Sp = Sp - 24;
           call Data.OldList.sortBy_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsY8() //  [R1]
         { info_tbl: [(cdsY8,
                       label: block_cdsY8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsY8: // global
           if (R1 & 7 == 1) goto cdsYl; else goto cdsYm;
       cdsYl: // global
           R1 = Data.List.NonEmpty.cycle1_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdsYm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsYx; else goto cdsYw;
       cdsYx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdsYw: // global
           _sds0b::P64 = P64[R1 + 6];
           _sds0c::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sds0d_info;
           P64[Hp] = P64[Sp + 8];
           R5 = _sds0c::P64;
           R4 = _sds0b::P64;
           R3 = P64[Sp + 16];
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Data.List.NonEmpty.$wgroupWith1_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.027302963 UTC

[section ""data" . Data.List.NonEmpty.groupAllWith1_closure" {
     Data.List.NonEmpty.groupAllWith1_closure:
         const Data.List.NonEmpty.groupAllWith1_info;
         const 0;
 },
 Data.List.NonEmpty.groupAllWith1_entry() //  [R2, R3, R4]
         { info_tbl: [(cdsZ7,
                       label: Data.List.NonEmpty.groupAllWith1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsZ7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdsZ8; else goto cdsZ9;
       cdsZ8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.groupAllWith1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdsZ9: // global
           I64[Sp - 8] = block_cdsZ4_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call Data.List.NonEmpty.$wgroupAllWith1_entry(R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdsZ4() //  [R1, R2]
         { info_tbl: [(cdsZ4,
                       label: block_cdsZ4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsZ4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdsZc; else goto cdsZb;
       cdsZc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cdsZb: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.033871565 UTC

[section ""data" . Data.List.NonEmpty.$wxor_closure" {
     Data.List.NonEmpty.$wxor_closure:
         const Data.List.NonEmpty.$wxor_info;
 },
 go_sds0m_entry() //  [R1, R2]
         { info_tbl: [(cdsZE,
                       label: go_sds0m_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsZE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdsZF; else goto udt0c;
       cdsZF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       udt0c: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cdsZu() args: 0, res: 0, upd: 0;
     }
 },
 _cdsZu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsZu: // global
           _sds0k::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cdsZx_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sds0k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udt0e; else goto cdsZy;
       udt0e: // global
           call _cdsZx(R1) args: 0, res: 0, upd: 0;
       cdsZy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsZx() //  [R1]
         { info_tbl: [(cdsZx,
                       label: block_cdsZx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsZx: // global
           if (R1 & 7 == 1) goto cdsZB; else goto cdsZC;
       cdsZB: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdsZC: // global
           I64[Sp] = block_cdsZM_info;
           _sds0q::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sds0q::P64;
           if (R1 & 7 != 0) goto udt0f; else goto cdsZO;
       udt0f: // global
           call _cdsZM(R1) args: 0, res: 0, upd: 0;
       cdsZO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsZM() //  [R1]
         { info_tbl: [(cdsZM,
                       label: block_cdsZM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsZM: // global
           _sds0q::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cdsZU; else goto cdsZZ;
       cdsZU: // global
           P64[Sp + 16] = _sds0q::P64;
           Sp = Sp + 8;
           call _cdsZu() args: 0, res: 0, upd: 0;
       cdsZZ: // global
           I64[Sp + 16] = block_cdsZX_info;
           R2 = _sds0q::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go_sds0m_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdsZX() //  [R1]
         { info_tbl: [(cdsZX,
                       label: block_cdsZX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdsZX: // global
           if (R1 & 7 == 1) goto cdt05; else goto cdt09;
       cdt05: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdt09: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Data.List.NonEmpty.$wxor_entry() //  [R2, R3]
         { info_tbl: [(cdt0i,
                       label: Data.List.NonEmpty.$wxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdt0i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdt0m; else goto cdt0l;
       cdt0m: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Data.List.NonEmpty.$wxor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdt0l: // global
           I64[Hp - 8] = go_sds0m_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_sds0m_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.046667534 UTC

[section ""data" . Data.List.NonEmpty.xor_closure" {
     Data.List.NonEmpty.xor_closure:
         const Data.List.NonEmpty.xor_info;
 },
 Data.List.NonEmpty.xor_entry() //  [R2]
         { info_tbl: [(cdt16,
                       label: Data.List.NonEmpty.xor_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdt16: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdt17; else goto cdt18;
       cdt17: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.xor_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdt18: // global
           I64[Sp - 8] = block_cdt13_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udt1c; else goto cdt14;
       udt1c: // global
           call _cdt13(R1) args: 0, res: 0, upd: 0;
       cdt14: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdt13() //  [R1]
         { info_tbl: [(cdt13,
                       label: block_cdt13_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdt13: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call Data.List.NonEmpty.$wxor_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.052325378 UTC

[section ""data" . Data.List.NonEmpty.length_closure" {
     Data.List.NonEmpty.length_closure:
         const Data.List.NonEmpty.length_info;
 },
 Data.List.NonEmpty.length_entry() //  [R2]
         { info_tbl: [(cdt1u,
                       label: Data.List.NonEmpty.length_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdt1u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdt1F; else goto cdt1G;
       cdt1F: // global
           R2 = R2;
           R1 = Data.List.NonEmpty.length_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdt1G: // global
           I64[Sp - 8] = block_cdt1r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udt1L; else goto cdt1s;
       udt1L: // global
           call _cdt1r(R1) args: 0, res: 0, upd: 0;
       cdt1s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdt1r() //  [R1]
         { info_tbl: [(cdt1r,
                       label: block_cdt1r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdt1r: // global
           I64[Sp] = block_cdt1x_info;
           R3 = 0;
           R2 = P64[R1 + 15];
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cdt1x() //  [R1]
         { info_tbl: [(cdt1x,
                       label: block_cdt1x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cdt1x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdt1K; else goto cdt1J;
       cdt1K: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdt1J: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:08:39.059661088 UTC

[section ""relreadonly" . Sds6G_srt" {
     Sds6G_srt:
         const GHC.List.lastError_closure;
         const Data.List.NonEmpty.last_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.List.NonEmpty.fromList_closure;
         const Data.List.NonEmpty.cycle1_closure;
         const Data.List.NonEmpty.reverse_closure;
         const Data.List.NonEmpty.sortBy_closure;
         const Data.List.NonEmpty.sortWith_closure;
         const Data.List.NonEmpty.sort_closure;
         const Data.OldList.$winits_closure;
         const Data.List.NonEmpty.inits_closure;
         const Data.List.NonEmpty.tails_closure;
         const GHC.List.scanr1_closure;
         const Data.List.NonEmpty.scanr1_closure;
         const Data.List.NonEmpty.cycle_closure;
         const Data.List.NonEmpty.$wtranspose_closure;
         const Data.List.NonEmpty.transpose_closure;
         const GHC.List.$w!!_closure;
         const Data.List.NonEmpty.!!1_closure;
         const Data.List.NonEmpty.!!_closure;
         const Data.List.NonEmpty.$w!!_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const Data.List.NonEmpty.groupAllWith_closure;
         const Data.List.NonEmpty.$wgroupAllWith1_closure;
         const Data.List.NonEmpty.groupAllWith1_closure;
 }]

