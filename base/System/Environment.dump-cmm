
==================== Output Cmm ====================
2018-03-16 16:07:16.826152966 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:16.826830508 UTC

[section ""cstring" . System.Environment.$trModule4_bytes" {
     System.Environment.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.828452776 UTC

[section ""data" . System.Environment.$trModule3_closure" {
     System.Environment.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.Environment.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.829033049 UTC

[section ""cstring" . System.Environment.$trModule2_bytes" {
     System.Environment.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,69,110,118,105,114,111,110,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.829644788 UTC

[section ""data" . System.Environment.$trModule1_closure" {
     System.Environment.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.Environment.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.830219253 UTC

[section ""data" . System.Environment.$trModule_closure" {
     System.Environment.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.Environment.$trModule3_closure+1;
         const System.Environment.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.83083612 UTC

[section ""cstring" . loc_rcolY_bytes" {
     loc_rcolY_bytes:
         I8[] [117,110,115,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.831680147 UTC

[section ""data" . loc1_rcolZ_closure" {
     loc1_rcolZ_closure:
         const loc1_rcolZ_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rcolZ_entry() //  [R1]
         { info_tbl: [(ccot8,
                       label: loc1_rcolZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccot8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccot9; else goto ccota;
       ccot9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccota: // global
           (_ccot5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccot5::I64 == 0) goto ccot7; else goto ccot6;
       ccot7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccot6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccot5::I64;
           R2 = loc_rcolY_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.832785453 UTC

[section ""data" . System.Environment.setEnv5_closure" {
     System.Environment.setEnv5_closure:
         const System.Environment.setEnv5_info;
         const 0;
 },
 System.Environment.setEnv5_entry() //  [R2]
         { info_tbl: [(ccoth,
                       label: System.Environment.setEnv5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoth: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = loc1_rcolZ_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.833993867 UTC

[section ""data" . System.Environment.setEnv4_closure" {
     System.Environment.setEnv4_closure:
         const System.Environment.setEnv4_info;
         const 0;
 },
 System.Environment.setEnv4_entry() //  [R2]
         { info_tbl: [(ccots,
                       label: System.Environment.setEnv4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccots: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccott; else goto ccotu;
       ccott: // global
           R2 = R2;
           R1 = System.Environment.setEnv4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccotu: // global
           I64[Sp - 8] = block_ccotp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucotQ; else goto ccotq;
       ucotQ: // global
           call _ccotp(R1) args: 0, res: 0, upd: 0;
       ccotq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccotp() //  [R1]
         { info_tbl: [(ccotp,
                       label: block_ccotp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccotp: // global
           (_scomi::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] __hsbase_unsetenv(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_scomi::I64) == 0 :: W32) goto ccotL; else goto ccotF;
       ccotL: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccotF: // global
           (_scomn::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _scomn::I64;
           Sp = Sp + 8;
           call System.Environment.setEnv5_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.835373064 UTC

[section ""data" . System.Environment.unsetEnv1_closure" {
     System.Environment.unsetEnv1_closure:
         const System.Environment.unsetEnv1_info;
         const 0;
 },
 System.Environment.unsetEnv1_entry() //  [R2]
         { info_tbl: [(ccotX,
                       label: System.Environment.unsetEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccotX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccotY; else goto ccotZ;
       ccotY: // global
           R2 = R2;
           R1 = System.Environment.unsetEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccotZ: // global
           I64[Sp - 16] = block_ccotV_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccotV() //  [R1]
         { info_tbl: [(ccotV,
                       label: block_ccotV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccotV: // global
           R4 = System.Environment.setEnv4_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.836484128 UTC

[section ""data" . System.Environment.unsetEnv_closure" {
     System.Environment.unsetEnv_closure:
         const System.Environment.unsetEnv_info;
         const 0;
 },
 System.Environment.unsetEnv_entry() //  [R2]
         { info_tbl: [(ccou5,
                       label: System.Environment.unsetEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccou5: // global
           R2 = R2;
           call System.Environment.unsetEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.837605427 UTC

[section ""data" . lvl_rcom0_closure" {
     lvl_rcom0_closure:
         const lvl_rcom0_info;
 },
 lvl_rcom0_entry() //  [R2, R3]
         { info_tbl: [(ccouf,
                       label: lvl_rcom0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccouf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccouj; else goto ccouk;
       ccouj: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_rcom0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccouk: // global
           I64[Sp - 16] = block_ccouc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucouy; else goto ccoud;
       ucouy: // global
           call _ccouc(R1) args: 0, res: 0, upd: 0;
       ccoud: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccouc() //  [R1]
         { info_tbl: [(ccouc,
                       label: block_ccouc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccouc: // global
           I64[Sp] = block_ccoui_info;
           _scomy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _scomy::I64;
           if (R1 & 7 != 0) goto ucoux; else goto ccoum;
       ucoux: // global
           call _ccoui(R1) args: 0, res: 0, upd: 0;
       ccoum: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoui() //  [R1]
         { info_tbl: [(ccoui,
                       label: block_ccoui_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoui: // global
           call "ccall" arg hints:  [‘signed’,
                                     PtrHint]  result hints:  [] setProgArgv(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.839287725 UTC

[section ""data" . System.Environment.$wlvl_closure" {
     System.Environment.$wlvl_closure:
         const System.Environment.$wlvl_info;
         const 0;
 },
 System.Environment.$wlvl_entry() //  [R2]
         { info_tbl: [(ccouK,
                       label: System.Environment.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccouK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccouL; else goto ccouM;
       ccouL: // global
           R2 = R2;
           R1 = System.Environment.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccouM: // global
           (_scomK::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getenv(R2);
           if (_scomK::I64 == 0) goto ccouJ; else goto ccouI;
       ccouJ: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccouI: // global
           I64[Sp - 16] = block_ccouO_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _scomK::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucov3; else goto ccouP;
       ucov3: // global
           call _ccouO(R1) args: 0, res: 0, upd: 0;
       ccouP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccouO() //  [R1]
         { info_tbl: [(ccouO,
                       label: block_ccouO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccouO: // global
           I64[Sp] = block_ccouT_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccouT() //  [R1]
         { info_tbl: [(ccouT,
                       label: block_ccouT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccouT: // global
           _scomK::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_ccouV_info;
           R3 = _scomK::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccouV() //  [R1]
         { info_tbl: [(ccouV,
                       label: block_ccouV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccouV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccov2; else goto ccov1;
       ccov2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccov1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.840903854 UTC

[section ""data" . System.Environment.getEnv3_closure" {
     System.Environment.getEnv3_closure:
         const System.Environment.getEnv3_info;
         const 0;
 },
 System.Environment.getEnv3_entry() //  [R2]
         { info_tbl: [(ccovb,
                       label: System.Environment.getEnv3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccovb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccovc; else goto ccovd;
       ccovc: // global
           R2 = R2;
           R1 = System.Environment.getEnv3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccovd: // global
           I64[Sp - 8] = block_ccov8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucovh; else goto ccov9;
       ucovh: // global
           call _ccov8(R1) args: 0, res: 0, upd: 0;
       ccov9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccov8() //  [R1]
         { info_tbl: [(ccov8,
                       label: block_ccov8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccov8: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call System.Environment.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.842082764 UTC

[section ""data" . System.Environment.lookupEnv1_closure" {
     System.Environment.lookupEnv1_closure:
         const System.Environment.lookupEnv1_info;
         const 0;
 },
 System.Environment.lookupEnv1_entry() //  [R2]
         { info_tbl: [(ccovo,
                       label: System.Environment.lookupEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccovo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccovp; else goto ccovq;
       ccovp: // global
           R2 = R2;
           R1 = System.Environment.lookupEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccovq: // global
           I64[Sp - 16] = block_ccovm_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccovm() //  [R1]
         { info_tbl: [(ccovm,
                       label: block_ccovm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccovm: // global
           R4 = System.Environment.getEnv3_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.843134026 UTC

[section ""data" . System.Environment.lookupEnv_closure" {
     System.Environment.lookupEnv_closure:
         const System.Environment.lookupEnv_info;
         const 0;
 },
 System.Environment.lookupEnv_entry() //  [R2]
         { info_tbl: [(ccovw,
                       label: System.Environment.lookupEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccovw: // global
           R2 = R2;
           call System.Environment.lookupEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.843862129 UTC

[section ""cstring" . lvl1_rcom1_bytes" {
     lvl1_rcom1_bytes:
         I8[] [103,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.844603879 UTC

[section ""data" . lvl2_rcom2_closure" {
     lvl2_rcom2_closure:
         const lvl2_rcom2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rcom2_entry() //  [R1]
         { info_tbl: [(ccovF,
                       label: lvl2_rcom2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccovF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccovG; else goto ccovH;
       ccovG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccovH: // global
           (_ccovC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccovC::I64 == 0) goto ccovE; else goto ccovD;
       ccovE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccovD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccovC::I64;
           R2 = lvl1_rcom1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.845575227 UTC

[section ""cstring" . lvl3_rcom3_bytes" {
     lvl3_rcom3_bytes:
         I8[] [110,111,32,101,110,118,105,114,111,110,109,101,110,116,32,118,97,114,105,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.846351848 UTC

[section ""data" . lvl4_rcom4_closure" {
     lvl4_rcom4_closure:
         const lvl4_rcom4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rcom4_entry() //  [R1]
         { info_tbl: [(ccovO,
                       label: lvl4_rcom4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccovO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccovP; else goto ccovQ;
       ccovP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccovQ: // global
           (_ccovL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccovL::I64 == 0) goto ccovN; else goto ccovM;
       ccovN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccovM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccovL::I64;
           R2 = lvl3_rcom3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.847623237 UTC

[section ""data" . System.Environment.getEnv2_closure" {
     System.Environment.getEnv2_closure:
         const System.Environment.getEnv2_info;
         const 0;
 },
 sat_scon9_entry() //  [R1]
         { info_tbl: [(ccow1,
                       label: sat_scon9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccow1: // global
           _scon9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccow2; else goto ccow3;
       ccow3: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccow5; else goto ccow4;
       ccow5: // global
           HpAlloc = 72;
           goto ccow2;
       ccow2: // global
           R1 = _scon9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccow4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scon9::P64;
           _scon6::P64 = P64[_scon9::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _scon6::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.NoSuchThing_closure+1;
           P64[Hp - 24] = lvl2_rcom2_closure;
           P64[Hp - 16] = lvl4_rcom4_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getEnv2_entry() //  [R2]
         { info_tbl: [(ccow6,
                       label: System.Environment.getEnv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccow6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccowa; else goto ccow9;
       ccowa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = System.Environment.getEnv2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccow9: // global
           I64[Hp - 16] = sat_scon9_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.849529985 UTC

[section ""data" . System.Environment.getEnv1_closure" {
     System.Environment.getEnv1_closure:
         const System.Environment.getEnv1_info;
         const 0;
 },
 System.Environment.getEnv1_entry() //  [R2]
         { info_tbl: [(ccowq,
                       label: System.Environment.getEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccowq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccowr; else goto ccows;
       ccowr: // global
           R2 = R2;
           R1 = System.Environment.getEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccows: // global
           I64[Sp - 16] = block_ccowf_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccowf() //  [R1]
         { info_tbl: [(ccowf,
                       label: block_ccowf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccowf: // global
           I64[Sp] = block_ccowh_info;
           R4 = System.Environment.getEnv3_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccowh() //  [R1]
         { info_tbl: [(ccowh,
                       label: block_ccowh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccowh: // global
           I64[Sp] = block_ccowj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucowB; else goto ccowk;
       ucowB: // global
           call _ccowj(R1) args: 0, res: 0, upd: 0;
       ccowk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccowj() //  [R1]
         { info_tbl: [(ccowj,
                       label: block_ccowj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccowj: // global
           if (R1 & 7 == 1) goto ccown; else goto ccowo;
       ccown: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call System.Environment.getEnv2_entry(R2) args: 8, res: 0, upd: 8;
       ccowo: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.850977384 UTC

[section ""data" . System.Environment.getEnv_closure" {
     System.Environment.getEnv_closure:
         const System.Environment.getEnv_info;
         const 0;
 },
 System.Environment.getEnv_entry() //  [R2]
         { info_tbl: [(ccowG,
                       label: System.Environment.getEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccowG: // global
           R2 = R2;
           call System.Environment.getEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.852271648 UTC

[section ""data" . System.Environment.getProgName_go_closure" {
     System.Environment.getProgName_go_closure:
         const System.Environment.getProgName_go_info;
 },
 System.Environment.getProgName_go_entry() //  [R2, R3]
         { info_tbl: [(ccowU,
                       label: System.Environment.getProgName_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccowU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccowV; else goto ucoxd;
       ccowV: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.getProgName_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ucoxd: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ccowK() args: 0, res: 0, upd: 0;
     }
 },
 _ccowK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccowK: // global
           I64[Sp - 8] = block_ccowN_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoxg; else goto ccowO;
       ucoxg: // global
           call _ccowN(R1) args: 0, res: 0, upd: 0;
       ccowO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccowN() //  [R1]
         { info_tbl: [(ccowN,
                       label: block_ccowN_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccowN: // global
           if (R1 & 7 == 1) goto ccowR; else goto ccowS;
       ccowR: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccowS: // global
           I64[Sp] = block_ccox2_info;
           _scono::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _scono::P64;
           if (R1 & 7 != 0) goto ucoxh; else goto ccox4;
       ucoxh: // global
           call _ccox2(R1) args: 0, res: 0, upd: 0;
       ccox4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccox2() //  [R1]
         { info_tbl: [(ccox2,
                       label: block_ccox2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccox2: // global
           _scono::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 47) goto ccoxc; else goto ccoxb;
       ccoxc: // global
           P64[Sp + 8] = _scono::P64;
           P64[Sp + 16] = _scono::P64;
           Sp = Sp + 8;
           goto ucoxk;
       ccoxb: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = _scono::P64;
           Sp = Sp + 8;
           goto ucoxk;
       ucoxk: // global
           call _ccowK() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.854551868 UTC

[section ""data" . System.Environment.getProgName1_closure" {
     System.Environment.getProgName1_closure:
         const System.Environment.getProgName1_info;
         const 0;
 },
 sat_scoo1_entry() //  [R1]
         { info_tbl: [(ccoxR,
                       label: sat_scoo1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoxR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoxS; else goto ccoxT;
       ccoxS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoxT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _sconY::P64 = P64[R1 + 16];
           R3 = _sconY::P64;
           R2 = _sconY::P64;
           Sp = Sp - 16;
           call System.Environment.getProgName_go_entry(R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getProgName1_entry() //  []
         { info_tbl: [(ccoxU,
                       label: System.Environment.getProgName1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoxU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccoxV; else goto ccoxW;
       ccoxV: // global
           R1 = System.Environment.getProgName1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccoxW: // global
           I64[Sp - 8] = block_ccoxp_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoxp() //  [R1]
         { info_tbl: [(ccoxp,
                       label: block_ccoxp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoxp: // global
           I64[Sp - 8] = block_ccoxr_info;
           R2 = 8;
           _scony::P64 = R1;
           R1 = 8;
           P64[Sp] = _scony::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoxr() //  [R1]
         { info_tbl: [(ccoxr,
                       label: block_ccoxr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoxr: // global
           _sconF::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getProgArgv(P64[Sp + 8] + 16, _sconF::I64);
           _sconM::I64 = I64[_sconF::I64];
           I64[Sp - 16] = block_ccoxC_info;
           _sconE::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _sconM::I64;
           P64[Sp] = _sconE::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucoy4; else goto ccoxD;
       ucoy4: // global
           call _ccoxC(R1) args: 0, res: 0, upd: 0;
       ccoxD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoxC() //  [R1]
         { info_tbl: [(ccoxC,
                       label: block_ccoxC_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoxC: // global
           I64[Sp] = block_ccoxH_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoxH() //  [R1]
         { info_tbl: [(ccoxH,
                       label: block_ccoxH_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoxH: // global
           _sconV::I64 = I64[I64[Sp + 8]];
           I64[Sp + 8] = block_ccoxJ_info;
           R3 = _sconV::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoxJ() //  [R1]
         { info_tbl: [(ccoxJ,
                       label: block_ccoxJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoxJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoy3; else goto ccoy2;
       ccoy3: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoy2: // global
           _scony::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_scony::P64);
           I64[Hp - 16] = sat_scoo1_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.85675015 UTC

[section ""data" . System.Environment.getProgName_closure" {
     System.Environment.getProgName_closure:
         const System.Environment.getProgName_info;
         const 0;
 },
 System.Environment.getProgName_entry() //  []
         { info_tbl: [(ccoy9,
                       label: System.Environment.getProgName_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoy9: // global
           call System.Environment.getProgName1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.859577526 UTC

[section ""data" . System.Environment.getArgs1_closure" {
     System.Environment.getArgs1_closure:
         const System.Environment.getArgs1_info;
         const 0;
 },
 go_scooA_entry() //  [R1, R2]
         { info_tbl: [(ccoze,
                       label: go_scooA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoze: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccozf; else goto ccozg;
       ccozf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccozg: // global
           I64[Sp - 24] = block_ccoz7_info;
           _scooA::P64 = R1;
           _scoov::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _scoov::P64;
           P64[Sp - 8] = _scooA::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucozD; else goto ccoz8;
       ucozD: // global
           call _ccoz7(R1) args: 0, res: 0, upd: 0;
       ccoz8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoz7() //  [R1]
         { info_tbl: [(ccoz7,
                       label: block_ccoz7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoz7: // global
           if (R1 & 7 == 1) goto ccozb; else goto ccozc;
       ccozb: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccozc: // global
           I64[Sp - 8] = block_ccozm_info;
           _scooF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scooF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucozC; else goto ccozn;
       ucozC: // global
           call _ccozm(R1) args: 0, res: 0, upd: 0;
       ccozn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccozm() //  [R1]
         { info_tbl: [(ccozm,
                       label: block_ccozm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccozm: // global
           I64[Sp] = block_ccozr_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccozr() //  [R1]
         { info_tbl: [(ccozr,
                       label: block_ccozr_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccozr: // global
           I64[Sp + 16] = block_ccozt_info;
           R2 = P64[Sp + 8];
           _scooK::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _scooK::P64;
           Sp = Sp + 16;
           call go_scooA_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccozt() //  [R1]
         { info_tbl: [(ccozt,
                       label: block_ccozt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccozt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccozB; else goto ccozA;
       ccozB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccozA: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.Environment.getArgs1_entry() //  []
         { info_tbl: [(ccozE,
                       label: System.Environment.getArgs1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccozE: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccozF; else goto ccozG;
       ccozF: // global
           R1 = System.Environment.getArgs1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccozG: // global
           I64[Sp - 8] = block_ccoyg_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoyg() //  [R1]
         { info_tbl: [(ccoyg,
                       label: block_ccoyg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoyg: // global
           I64[Sp - 8] = block_ccoyi_info;
           R2 = 8;
           _scoo8::P64 = R1;
           R1 = 8;
           P64[Sp] = _scoo8::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoyi() //  [R1]
         { info_tbl: [(ccoyi,
                       label: block_ccoyi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoyi: // global
           _scoof::I64 = P64[Sp + 8] + 16;
           _scoog::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getProgArgv(_scoof::I64, _scoog::I64);
           _scoom::I64 = %MO_SS_Conv_W32_W64(I32[_scoof::I64]);
           _scoop::I64 = I64[_scoog::I64];
           I64[Sp - 24] = block_ccoyt_info;
           _scooe::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 16] = _scoom::I64;
           I64[Sp - 8] = _scoop::I64;
           P64[Sp] = _scooe::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucoAi; else goto ccoyu;
       ucoAi: // global
           call _ccoyt(R1) args: 0, res: 0, upd: 0;
       ccoyu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoyt() //  [R1]
         { info_tbl: [(ccoyt,
                       label: block_ccoyt_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoyt: // global
           I64[Sp] = block_ccoyy_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoyy() //  [R1]
         { info_tbl: [(ccoyy,
                       label: block_ccoyy_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoyy: // global
           _scoow::I64 = I64[Sp + 8] - 1;
           if (%MO_S_Gt_W64(_scoow::I64, 0)) goto ccoA4; else goto ccoA5;
       ccoA4: // global
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _scoow::I64 - 1;
           I64[Sp + 8] = I64[Sp + 16] + 8;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _ccoyS() args: 0, res: 0, upd: 0;
       ccoA5: // global
           P64[Sp + 16] = R1;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _ccoz0() args: 0, res: 0, upd: 0;
     }
 },
 _ccoyS() //  []
         { info_tbl: [(ccoyS,
                       label: block_ccoyS_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoyS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccozZ; else goto ccozY;
       ccozZ: // global
           HpAlloc = 40;
           I64[Sp] = block_ccoyS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccozY: // global
           _scop6::P64 = P64[Sp + 8];
           _scop8::I64 = I64[Sp + 16];
           if (_scop8::I64 != 0) goto ccoA1; else goto ccoA2;
       ccoA1: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 24] + (_scop8::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scop6::P64;
           I64[Sp + 16] = _scop8::I64 - 1;
           P64[Sp + 8] = Hp - 14;
           call _ccoyS() args: 0, res: 0, upd: 0;
       ccoA2: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _scop6::P64;
           Sp = Sp + 16;
           call _ccozS() args: 0, res: 0, upd: 0;
     }
 },
 _ccozS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccozS: // global
           Hp = Hp + 40;
           _scooX::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccozW; else goto ccozV;
       ccozW: // global
           HpAlloc = 40;
           I64[Sp] = block_ccozR_info;
           R1 = _scooX::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccozV: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 8]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scooX::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           call _ccoz0() args: 0, res: 0, upd: 0;
     }
 },
 _ccozR() //  [R1]
         { info_tbl: [(ccozR,
                       label: block_ccozR_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccozR: // global
           P64[Sp] = R1;
           call _ccozS() args: 0, res: 0, upd: 0;
     }
 },
 _ccoz0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoz0: // global
           Hp = Hp + 16;
           _scooz::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccozO; else goto ccozN;
       ccozO: // global
           HpAlloc = 16;
           I64[Sp] = block_ccoyZ_info;
           R1 = _scooz::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccozN: // global
           I64[Hp - 8] = go_scooA_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccozL_info;
           R2 = _scooz::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_scooA_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoyZ() //  [R1]
         { info_tbl: [(ccoyZ,
                       label: block_ccoyZ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoyZ: // global
           P64[Sp] = R1;
           call _ccoz0() args: 0, res: 0, upd: 0;
     }
 },
 _ccozL() //  [R1]
         { info_tbl: [(ccozL,
                       label: block_ccozL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccozL: // global
           _scoo8::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_scoo8::P64);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.863893312 UTC

[section ""data" . System.Environment.getArgs_closure" {
     System.Environment.getArgs_closure:
         const System.Environment.getArgs_info;
         const 0;
 },
 System.Environment.getArgs_entry() //  []
         { info_tbl: [(ccoAu,
                       label: System.Environment.getArgs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoAu: // global
           call System.Environment.getArgs1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.86719653 UTC

[section ""data" . System.Environment.withArgs2_closure" {
     System.Environment.withArgs2_closure:
         const System.Environment.withArgs2_info;
         const 0;
 },
 sat_scopM_entry() //  [R1, R2]
         { info_tbl: [(ccoB2,
                       label: sat_scopM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoB2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoB3; else goto ccoB4;
       ccoB3: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoB4: // global
           I64[Sp - 24] = block_ccoAY_info;
           _scops::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scops::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoAY() //  [R1]
         { info_tbl: [(ccoAY,
                       label: block_ccoAY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoAY: // global
           _scops::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccoB0_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scops::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoB0() //  []
         { info_tbl: [(ccoB0,
                       label: block_ccoB0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoB0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scopD_entry() //  [R1]
         { info_tbl: [(ccoBc,
                       label: sat_scopD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBc: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqf_entry() //  [R1, R2]
         { info_tbl: [(ccoBD,
                       label: sat_scoqf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoBE; else goto ccoBF;
       ccoBE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoBF: // global
           I64[Sp - 24] = block_ccoBz_info;
           _scops::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scops::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoBz() //  [R1]
         { info_tbl: [(ccoBz,
                       label: block_ccoBz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBz: // global
           _scops::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccoBB_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scops::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoBB() //  []
         { info_tbl: [(ccoBB,
                       label: block_ccoBB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBB: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoq6_entry() //  [R1]
         { info_tbl: [(ccoBN,
                       label: sat_scoq6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBN: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqp_entry() //  [R1]
         { info_tbl: [(ccoBQ,
                       label: sat_scoqp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccoBW; else goto ccoBX;
       ccoBW: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccoBX: // global
           I64[Sp - 32] = block_ccoBl_info;
           _scopg::P64 = P64[R1 + 7];
           _scoph::P64 = P64[R1 + 15];
           _scops::P64 = P64[R1 + 23];
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp - 24] = _scopg::P64;
           P64[Sp - 16] = _scoph::P64;
           P64[Sp - 8] = _scops::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucoC7; else goto ccoBm;
       ucoC7: // global
           call _ccoBl(R1) args: 0, res: 0, upd: 0;
       ccoBm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoBl() //  [R1]
         { info_tbl: [(ccoBl,
                       label: block_ccoBl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBl: // global
           I64[Sp - 8] = block_ccoBq_info;
           _scopY::P64 = P64[R1 + 7];
           R1 = _scopY::P64;
           P64[Sp] = _scopY::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoBq() //  [R1]
         { info_tbl: [(ccoBq,
                       label: block_ccoBq_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBq: // global
           I64[Sp] = block_ccoBs_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoBs() //  [R1]
         { info_tbl: [(ccoBs,
                       label: block_ccoBs_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccoC2; else goto ccoC1;
       ccoC2: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoC1: // global
           I64[Hp - 32] = sat_scoqf_info;
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scoq6_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_ccoBR_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoBR() //  [R1]
         { info_tbl: [(ccoBR,
                       label: block_ccoBR_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBR: // global
           I64[Sp + 16] = block_ccoBT_info;
           _scoqi::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _scoqi::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoBT() //  [R1]
         { info_tbl: [(ccoBT,
                       label: block_ccoBT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBT: // global
           I64[Sp] = block_ccoBV_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoBV() //  []
         { info_tbl: [(ccoBV,
                       label: block_ccoBV_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoBV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqI_entry() //  [R1, R2]
         { info_tbl: [(ccoCr,
                       label: sat_scoqI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoCr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoCs; else goto ccoCt;
       ccoCs: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoCt: // global
           I64[Sp - 24] = block_ccoCn_info;
           _scops::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scops::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoCn() //  [R1]
         { info_tbl: [(ccoCn,
                       label: block_ccoCn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoCn: // global
           _scops::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccoCp_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scops::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoCp() //  []
         { info_tbl: [(ccoCp,
                       label: block_ccoCp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoCp: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqz_entry() //  [R1]
         { info_tbl: [(ccoCB,
                       label: sat_scoqz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoCB: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.Environment.withArgs2_entry() //  [R2, R3]
         { info_tbl: [(ccoCI,
                       label: System.Environment.withArgs2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoCI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccoCJ; else goto ccoCK;
       ccoCJ: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withArgs2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoCK: // global
           I64[Sp - 24] = block_ccoAB_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getProgName1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccoAB() //  [R1]
         { info_tbl: [(ccoAB,
                       label: block_ccoAB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoAB: // global
           I64[Sp - 8] = block_ccoAD_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call System.Environment.getArgs1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccoAD() //  [R1]
         { info_tbl: [(ccoAD,
                       label: block_ccoAD_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoAD: // global
           I64[Sp - 8] = block_ccoAF_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ccoAF() //  [R1]
         { info_tbl: [(ccoAF,
                       label: block_ccoAF_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoAF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccoCP; else goto ccoCO;
       ccoCP: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccoCO: // global
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           _ccoAH::P64 = Hp - 46;
           if (R1 == 0) goto ccoCG; else goto ucoDi;
       ccoCG: // global
           I64[Hp - 24] = sat_scoqp_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _ccoAH::P64;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ucoDi: // global
           if (R1 == 1) goto ccoCH; else goto ccoCF;
       ccoCH: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_ccoC9_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _ccoAH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucoDk; else goto ccoCa;
       ucoDk: // global
           call _ccoC9(R1) args: 0, res: 0, upd: 0;
       ccoCa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccoCF: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_ccoAK_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _ccoAH::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucoDj; else goto ccoAL;
       ucoDj: // global
           call _ccoAK(R1) args: 0, res: 0, upd: 0;
       ccoAL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoC9() //  [R1]
         { info_tbl: [(ccoC9,
                       label: block_ccoC9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoC9: // global
           I64[Sp - 8] = block_ccoCe_info;
           _scoqr::P64 = P64[R1 + 7];
           R1 = _scoqr::P64;
           P64[Sp] = _scoqr::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoCe() //  [R1]
         { info_tbl: [(ccoCe,
                       label: block_ccoCe_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoCe: // global
           I64[Sp] = block_ccoCg_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoCg() //  [R1]
         { info_tbl: [(ccoCg,
                       label: block_ccoCg_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoCg: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccoDd; else goto ccoDc;
       ccoDd: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoDc: // global
           I64[Hp - 32] = sat_scoqI_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scoqz_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_ccoD4_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoD4() //  [R1]
         { info_tbl: [(ccoD4,
                       label: block_ccoD4_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoD4: // global
           _scoqr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccoD6_info;
           _scoqL::P64 = R1;
           R1 = _scoqr::P64;
           P64[Sp + 32] = _scoqL::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoD6() //  [R1]
         { info_tbl: [(ccoD6,
                       label: block_ccoD6_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoD6: // global
           I64[Sp + 16] = block_ccoD8_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoD8() //  []
         { info_tbl: [(ccoD8,
                       label: block_ccoD8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoD8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccoAK() //  [R1]
         { info_tbl: [(ccoAK,
                       label: block_ccoAK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoAK: // global
           I64[Sp - 8] = block_ccoAP_info;
           _scopv::P64 = P64[R1 + 7];
           R1 = _scopv::P64;
           P64[Sp] = _scopv::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoAP() //  [R1]
         { info_tbl: [(ccoAP,
                       label: block_ccoAP_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoAP: // global
           I64[Sp] = block_ccoAR_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoAR() //  [R1]
         { info_tbl: [(ccoAR,
                       label: block_ccoAR_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoAR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccoCZ; else goto ccoCY;
       ccoCZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoCY: // global
           I64[Hp - 32] = sat_scopM_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scopD_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_ccoCQ_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoCQ() //  [R1]
         { info_tbl: [(ccoCQ,
                       label: block_ccoCQ_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoCQ: // global
           _scopv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccoCS_info;
           _scopP::P64 = R1;
           R1 = _scopv::P64;
           P64[Sp + 32] = _scopP::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoCS() //  [R1]
         { info_tbl: [(ccoCS,
                       label: block_ccoCS_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoCS: // global
           I64[Sp + 16] = block_ccoCU_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoCU() //  []
         { info_tbl: [(ccoCU,
                       label: block_ccoCU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoCU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.875007608 UTC

[section ""data" . System.Environment.withArgs1_closure" {
     System.Environment.withArgs1_closure:
         const System.Environment.withArgs1_info;
         const 0;
 },
 System.Environment.withArgs1_entry() //  [R2, R3]
         { info_tbl: [(ccoDs,
                       label: System.Environment.withArgs1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoDs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoDt; else goto ccoDu;
       ccoDt: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withArgs1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoDu: // global
           I64[Sp - 24] = block_ccoDp_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getProgName1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccoDp() //  [R1]
         { info_tbl: [(ccoDp,
                       label: block_ccoDp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoDp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoDx; else goto ccoDw;
       ccoDx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoDw: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = Hp - 14;
           Sp = Sp + 24;
           call System.Environment.withArgs2_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.876311297 UTC

[section ""data" . System.Environment.withArgs_closure" {
     System.Environment.withArgs_closure:
         const System.Environment.withArgs_info;
         const 0;
 },
 System.Environment.withArgs_entry() //  [R2, R3]
         { info_tbl: [(ccoDC,
                       label: System.Environment.withArgs_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoDC: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.withArgs1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.877415186 UTC

[section ""data" . System.Environment.withProgName1_closure" {
     System.Environment.withProgName1_closure:
         const System.Environment.withProgName1_info;
         const 0;
 },
 System.Environment.withProgName1_entry() //  [R2, R3]
         { info_tbl: [(ccoDM,
                       label: System.Environment.withProgName1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoDM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoDN; else goto ccoDO;
       ccoDN: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withProgName1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoDO: // global
           I64[Sp - 24] = block_ccoDJ_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getArgs1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccoDJ() //  [R1]
         { info_tbl: [(ccoDJ,
                       label: block_ccoDJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoDJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoDR; else goto ccoDQ;
       ccoDR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoDQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R3 = P64[Sp + 16];
           R2 = Hp - 14;
           Sp = Sp + 24;
           call System.Environment.withArgs2_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.880325432 UTC

[section ""data" . System.Environment.withProgName_closure" {
     System.Environment.withProgName_closure:
         const System.Environment.withProgName_info;
         const 0;
 },
 System.Environment.withProgName_entry() //  [R2, R3]
         { info_tbl: [(ccoDW,
                       label: System.Environment.withProgName_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoDW: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.withProgName1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.881375623 UTC

[section ""data" . System.Environment.getEnvironment3_closure" {
     System.Environment.getEnvironment3_closure:
         const System.Environment.getEnvironment3_info;
 },
 System.Environment.getEnvironment3_entry() //  [R2]
         { info_tbl: [(ccoE6,
                       label: System.Environment.getEnvironment3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoE6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccoE7; else goto ccoE8;
       ccoE7: // global
           R2 = R2;
           R1 = System.Environment.getEnvironment3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoE8: // global
           I64[Sp - 8] = block_ccoE3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoEg; else goto ccoE4;
       ucoEg: // global
           call _ccoE3(R1) args: 0, res: 0, upd: 0;
       ccoE4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoE3() //  [R1]
         { info_tbl: [(ccoE3,
                       label: block_ccoE3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoE3: // global
           if (I64[R1 + 7] == 61) goto ccoEf; else goto ccoEe;
       ccoEf: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoEe: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.882885497 UTC

[section ""data" . System.Environment.getEnvironment2_closure" {
     System.Environment.getEnvironment2_closure:
         const System.Environment.getEnvironment2_info;
 },
 System.Environment.getEnvironment2_entry() //  [R2]
         { info_tbl: [(ccoEu,
                       label: System.Environment.getEnvironment2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoEu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoEv; else goto ccoEw;
       ccoEv: // global
           R2 = R2;
           R1 = System.Environment.getEnvironment2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoEw: // global
           I64[Sp - 8] = block_ccoEl_info;
           R3 = R2;
           R2 = System.Environment.getEnvironment3_closure+1;
           Sp = Sp - 8;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoEl() //  [R1, R2]
         { info_tbl: [(ccoEl,
                       label: block_ccoEl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoEl: // global
           I64[Sp - 8] = block_ccoEn_info;
           _scorc::P64 = R1;
           R1 = R2;
           P64[Sp] = _scorc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoEK; else goto ccoEo;
       ucoEK: // global
           call _ccoEn(R1) args: 0, res: 0, upd: 0;
       ccoEo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoEn() //  [R1]
         { info_tbl: [(ccoEn,
                       label: block_ccoEn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoEn: // global
           _scorc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccoEr; else goto ccoEs;
       ccoEr: // global
           Hp = Hp + 24;
           _score::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccoEJ; else goto ccoEC;
       ccoEC: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scorc::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoEs: // global
           Hp = Hp + 24;
           _score::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccoEJ; else goto ccoEI;
       ccoEJ: // global
           HpAlloc = 24;
           R1 = _score::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoEI: // global
           _scorg::P64 = P64[_score::P64 + 14];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scorc::P64;
           P64[Hp] = _scorg::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.886257888 UTC

[section ""data" . System.Environment.getEnvironment1_closure" {
     System.Environment.getEnvironment1_closure:
         const System.Environment.getEnvironment1_info;
         const 0;
 },
 go_scorz_entry() //  [R1, R2]
         { info_tbl: [(ccoFD,
                       label: go_scorz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoFD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccoFE; else goto ccoFF;
       ccoFE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoFF: // global
           I64[Sp - 24] = block_ccoFw_info;
           _scorz::P64 = R1;
           _scors::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _scors::P64;
           P64[Sp - 8] = _scorz::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucoG2; else goto ccoFx;
       ucoG2: // global
           call _ccoFw(R1) args: 0, res: 0, upd: 0;
       ccoFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoFw() //  [R1]
         { info_tbl: [(ccoFw,
                       label: block_ccoFw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoFw: // global
           if (R1 & 7 == 1) goto ccoFA; else goto ccoFB;
       ccoFA: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoFB: // global
           I64[Sp - 8] = block_ccoFL_info;
           _scorE::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scorE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoG1; else goto ccoFM;
       ucoG1: // global
           call _ccoFL(R1) args: 0, res: 0, upd: 0;
       ccoFM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoFL() //  [R1]
         { info_tbl: [(ccoFL,
                       label: block_ccoFL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoFL: // global
           I64[Sp] = block_ccoFQ_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoFQ() //  [R1]
         { info_tbl: [(ccoFQ,
                       label: block_ccoFQ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoFQ: // global
           I64[Sp + 16] = block_ccoFS_info;
           R2 = P64[Sp + 8];
           _scorJ::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _scorJ::P64;
           Sp = Sp + 16;
           call go_scorz_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoFS() //  [R1]
         { info_tbl: [(ccoFS,
                       label: block_ccoFS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoFS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoG0; else goto ccoFZ;
       ccoG0: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoFZ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scorR_entry() //  [R1]
         { info_tbl: [(ccoG9,
                       label: sat_scorR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoG9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoGa; else goto ccoGb;
       ccoGa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoGb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = System.Environment.getEnvironment2_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getEnvironment1_entry() //  []
         { info_tbl: [(ccoGf,
                       label: System.Environment.getEnvironment1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoGf: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccoGg; else goto ccoGh;
       ccoGg: // global
           R1 = System.Environment.getEnvironment1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccoGh: // global
           (_scorl::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] __hscore_environ();
           if (_scorl::I64 == 0) goto ccoGe; else goto ccoGd;
       ccoGe: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoGd: // global
           I64[Sp - 16] = block_ccoET_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _scorl::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucoH8; else goto ccoEU;
       ucoH8: // global
           call _ccoET(R1) args: 0, res: 0, upd: 0;
       ccoEU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoET() //  [R1]
         { info_tbl: [(ccoET,
                       label: block_ccoET_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoET: // global
           I64[Sp] = block_ccoEY_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoEY() //  [R1]
         { info_tbl: [(ccoEY,
                       label: block_ccoEY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoEY: // global
           _scorl::I64 = I64[Sp + 8];
           _scors::P64 = R1;
           _scose::I64 = 0;
           goto ccoGJ;
       ccoGJ: // global
           if (I64[_scorl::I64 + (_scose::I64 << 3)] == 0) goto ccoGQ; else goto ccoGP;
       ccoGQ: // global
           if (%MO_S_Gt_W64(_scose::I64, 0)) goto ccoGE; else goto ccoGF;
       ccoGE: // global
           I64[Sp - 16] = _scose::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           P64[Sp] = _scors::P64;
           Sp = Sp - 24;
           call _ccoFh() args: 0, res: 0, upd: 0;
       ccoGF: // global
           P64[Sp] = _scors::P64;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           call _ccoFp() args: 0, res: 0, upd: 0;
       ccoGP: // global
           _scose::I64 = _scose::I64 + 1;
           goto ccoGJ;
     }
 },
 _ccoFh() //  []
         { info_tbl: [(ccoFh,
                       label: block_ccoFh_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoFh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccoGz; else goto ccoGy;
       ccoGz: // global
           HpAlloc = 40;
           I64[Sp] = block_ccoFh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccoGy: // global
           _scos3::P64 = P64[Sp + 16];
           _scos5::I64 = I64[Sp + 8];
           if (_scos5::I64 != 0) goto ccoGB; else goto ccoGC;
       ccoGB: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 32] + (_scos5::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scos3::P64;
           I64[Sp + 8] = _scos5::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _ccoFh() args: 0, res: 0, upd: 0;
       ccoGC: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _scos3::P64;
           Sp = Sp + 16;
           call _ccoGs() args: 0, res: 0, upd: 0;
     }
 },
 _ccoGs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoGs: // global
           Hp = Hp + 40;
           _scorU::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccoGw; else goto ccoGv;
       ccoGw: // global
           HpAlloc = 40;
           I64[Sp] = block_ccoGr_info;
           R1 = _scorU::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoGv: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 16]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scorU::P64;
           P64[Sp + 16] = Hp - 14;
           Sp = Sp + 8;
           call _ccoFp() args: 0, res: 0, upd: 0;
     }
 },
 _ccoGr() //  [R1]
         { info_tbl: [(ccoGr,
                       label: block_ccoGr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoGr: // global
           P64[Sp] = R1;
           call _ccoGs() args: 0, res: 0, upd: 0;
     }
 },
 _ccoFp() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoFp: // global
           Hp = Hp + 16;
           _scory::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto ccoGn; else goto ccoGm;
       ccoGn: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_ccoFo_info;
           R1 = _scory::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoGm: // global
           I64[Hp - 8] = go_scorz_info;
           P64[Hp] = P64[Sp];
           I64[Sp + 8] = block_ccoG3_info;
           R2 = _scory::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_scorz_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoFo() //  [R1]
         { info_tbl: [(ccoFo,
                       label: block_ccoFo_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoFo: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _ccoFp() args: 0, res: 0, upd: 0;
     }
 },
 _ccoG3() //  [R1]
         { info_tbl: [(ccoG3,
                       label: block_ccoG3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoG3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoGq; else goto ccoGp;
       ccoGq: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoGp: // global
           I64[Hp - 16] = sat_scorR_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.890447437 UTC

[section ""data" . System.Environment.getEnvironment_closure" {
     System.Environment.getEnvironment_closure:
         const System.Environment.getEnvironment_info;
         const 0;
 },
 System.Environment.getEnvironment_entry() //  []
         { info_tbl: [(ccoHf,
                       label: System.Environment.getEnvironment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoHf: // global
           call System.Environment.getEnvironment1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.891460609 UTC

[section ""data" . System.Environment.setEnv11_closure" {
     System.Environment.setEnv11_closure:
         const System.Environment.setEnv11_info;
 },
 System.Environment.setEnv11_entry() //  [R2]
         { info_tbl: [(ccoHp,
                       label: System.Environment.setEnv11_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoHp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccoHq; else goto ccoHr;
       ccoHq: // global
           R2 = R2;
           R1 = System.Environment.setEnv11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoHr: // global
           I64[Sp - 8] = block_ccoHm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoHz; else goto ccoHn;
       ucoHz: // global
           call _ccoHm(R1) args: 0, res: 0, upd: 0;
       ccoHn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoHm() //  [R1]
         { info_tbl: [(ccoHm,
                       label: block_ccoHm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoHm: // global
           if (I64[R1 + 7] == 0) goto ccoHy; else goto ccoHx;
       ccoHy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoHx: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.892521986 UTC

[section ""cstring" . lvl5_rcom5_bytes" {
     lvl5_rcom5_bytes:
         I8[] [112,117,116,101,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.893298091 UTC

[section ""data" . lvl6_rcom6_closure" {
     lvl6_rcom6_closure:
         const lvl6_rcom6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rcom6_entry() //  [R1]
         { info_tbl: [(ccoHG,
                       label: lvl6_rcom6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoHG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoHH; else goto ccoHI;
       ccoHH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoHI: // global
           (_ccoHD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccoHD::I64 == 0) goto ccoHF; else goto ccoHE;
       ccoHF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccoHE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccoHD::I64;
           R2 = lvl5_rcom5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.89438004 UTC

[section ""data" . System.Environment.setEnv2_closure" {
     System.Environment.setEnv2_closure:
         const System.Environment.setEnv2_info;
         const 0;
 },
 System.Environment.setEnv2_entry() //  [R2]
         { info_tbl: [(ccoHP,
                       label: System.Environment.setEnv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoHP: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl6_rcom6_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.8951371 UTC

[section ""cstring" . System.Environment.setEnv10_bytes" {
     System.Environment.setEnv10_bytes:
         I8[] [115,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.895902588 UTC

[section ""data" . System.Environment.setEnv9_closure" {
     System.Environment.setEnv9_closure:
         const System.Environment.setEnv9_info;
         const 0;
         const 0;
         const 0;
 },
 System.Environment.setEnv9_entry() //  [R1]
         { info_tbl: [(ccoHY,
                       label: System.Environment.setEnv9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoHY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoHZ; else goto ccoI0;
       ccoHZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoI0: // global
           (_ccoHV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccoHV::I64 == 0) goto ccoHX; else goto ccoHW;
       ccoHX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccoHW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccoHV::I64;
           R2 = System.Environment.setEnv10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.896829979 UTC

[section ""data" . System.Environment.setEnv8_closure" {
     System.Environment.setEnv8_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const System.Environment.setEnv9_closure;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.897726448 UTC

[section ""data" . System.Environment.setEnv7_closure" {
     System.Environment.setEnv7_closure:
         const System.Environment.setEnv7_info;
         const 0;
         const 0;
         const 0;
 },
 System.Environment.setEnv7_entry() //  [R1]
         { info_tbl: [(ccoI7,
                       label: System.Environment.setEnv7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoI7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoI8; else goto ccoI9;
       ccoI8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoI9: // global
           (_ccoI4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccoI4::I64 == 0) goto ccoI6; else goto ccoI5;
       ccoI6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccoI5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccoI4::I64;
           R2 = System.Environment.setEnv8_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.898652511 UTC

[section ""data" . System.Environment.setEnv6_closure" {
     System.Environment.setEnv6_closure:
         const GHC.Types.C#_con_info;
         const 61;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.899253727 UTC

[section ""cstring" . System.Environment.setEnv3_bytes" {
     System.Environment.setEnv3_bytes:
         I8[] [61]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.901059099 UTC

[section ""data" . System.Environment.setEnv1_closure" {
     System.Environment.setEnv1_closure:
         const System.Environment.setEnv1_info;
         const 0;
 },
 sat_scosL_entry() //  [R1]
         { info_tbl: [(ccoIH,
                       label: sat_scosL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoIH: // global
           R3 = P64[R1 + 16];
           R2 = System.Environment.setEnv3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scosM_entry() //  [R1]
         { info_tbl: [(ccoIK,
                       label: sat_scosM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoIK: // global
           _scosM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccoIL; else goto ccoIM;
       ccoIM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoIO; else goto ccoIN;
       ccoIO: // global
           HpAlloc = 24;
           goto ccoIL;
       ccoIL: // global
           R1 = _scosM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoIN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scosM::P64;
           _scosv::P64 = P64[_scosM::P64 + 16];
           _scosz::P64 = P64[_scosM::P64 + 24];
           I64[Hp - 16] = sat_scosL_info;
           P64[Hp] = _scosz::P64;
           R3 = Hp - 16;
           R2 = _scosv::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.setEnv1_entry() //  [R2, R3]
         { info_tbl: [(ccoIT,
                       label: System.Environment.setEnv1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoIT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoIU; else goto ccoIV;
       ccoIU: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.setEnv1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoIV: // global
           I64[Sp - 16] = block_ccoIe_info;
           _scost::P64 = R3;
           R3 = R2;
           R2 = System.Environment.setEnv11_closure+1;
           P64[Sp - 8] = _scost::P64;
           Sp = Sp - 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoIe() //  [R1]
         { info_tbl: [(ccoIe,
                       label: block_ccoIe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoIe: // global
           if (R1 & 7 == 1) goto ucoJM; else goto ccoIR;
       ucoJM: // global
           Sp = Sp + 16;
           call _ccoJI() args: 0, res: 0, upd: 0;
       ccoIR: // global
           I64[Sp - 8] = block_ccoIj_info;
           R4 = R1;
           R3 = System.Environment.setEnv6_closure+1;
           R2 = GHC.Classes.$fEqChar_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoIj() //  [R1]
         { info_tbl: [(ccoIj,
                       label: block_ccoIj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoIj: // global
           if (R1 & 7 == 1) goto ccoJ1; else goto ucoJN;
       ccoJ1: // global
           I64[Sp] = block_ccoIn_info;
           R3 = P64[Sp + 16];
           R2 = System.Environment.setEnv11_closure+1;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 8, upd: 8;
       ucoJN: // global
           Sp = Sp + 24;
           call _ccoJI() args: 0, res: 0, upd: 0;
     }
 },
 _ccoIn() //  [R1]
         { info_tbl: [(ccoIn,
                       label: block_ccoIn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoIn: // global
           if (R1 & 7 == 1) goto ccoJ6; else goto ccoJd;
       ccoJ6: // global
           I64[Sp] = block_ccoJ3_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ccoJd: // global
           I64[Sp] = block_ccoIs_info;
           _scosz::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _scosz::P64;
           if (R1 & 7 != 0) goto ucoJQ; else goto ccoIt;
       ucoJQ: // global
           call _ccoIs(R1) args: 0, res: 0, upd: 0;
       ccoIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoJ3() //  [R1]
         { info_tbl: [(ccoJ3,
                       label: block_ccoJ3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoJ3: // global
           R4 = System.Environment.setEnv4_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccoIs() //  [R1]
         { info_tbl: [(ccoIs,
                       label: block_ccoIs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoIs: // global
           I64[Sp] = block_ccoIx_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoIx() //  [R1]
         { info_tbl: [(ccoIx,
                       label: block_ccoIx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoIx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccoJh; else goto ccoJg;
       ccoJh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoJg: // global
           I64[Hp - 24] = sat_scosM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccoJ9_info;
           R3 = Hp - 24;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoJ9() //  [R1]
         { info_tbl: [(ccoJ9,
                       label: block_ccoJ9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoJ9: // global
           I64[Sp] = block_ccoJb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucoJR; else goto ccoJj;
       ucoJR: // global
           call _ccoJb(R1) args: 0, res: 0, upd: 0;
       ccoJj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoJb() //  [R1]
         { info_tbl: [(ccoJb,
                       label: block_ccoJb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoJb: // global
           (_scosV::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] putenv(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_scosV::I64) == 0 :: W32) goto ccoJB; else goto ccoJv;
       ccoJB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoJv: // global
           (_scot0::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _scot0::I64;
           Sp = Sp + 8;
           call System.Environment.setEnv2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccoJI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoJI: // global
           R1 = System.Environment.setEnv7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.904289987 UTC

[section ""data" . System.Environment.setEnv_closure" {
     System.Environment.setEnv_closure:
         const System.Environment.setEnv_info;
         const 0;
 },
 System.Environment.setEnv_entry() //  [R2, R3]
         { info_tbl: [(ccoJW,
                       label: System.Environment.setEnv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoJW: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.setEnv1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.905050921 UTC

[section ""relreadonly" . Scotk_srt" {
     Scotk_srt:
         const Foreign.C.Error.$wlvl_closure;
         const loc1_rcolZ_closure;
         const System.Environment.setEnv4_closure;
         const System.Environment.setEnv5_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const System.Environment.unsetEnv1_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.IO.Encoding.getFileSystemEncoding1_closure;
         const System.Environment.$wlvl_closure;
         const System.Environment.getEnv3_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const System.Environment.lookupEnv1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl2_rcom2_closure;
         const lvl4_rcom4_closure;
         const System.Environment.getEnv2_closure;
         const System.Environment.getEnv1_closure;
         const System.Environment.getProgName1_closure;
         const System.Environment.getArgs1_closure;
         const GHC.Foreign.withCStringsLen1_closure;
         const System.Environment.withArgs2_closure;
         const System.Environment.withArgs1_closure;
         const System.Environment.withProgName1_closure;
         const System.Environment.getEnvironment1_closure;
         const lvl6_rcom6_closure;
         const System.Environment.setEnv8_closure;
         const GHC.Foreign.newCString1_closure;
         const System.Environment.setEnv1_closure;
         const System.Environment.setEnv2_closure;
         const System.Environment.setEnv7_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.906090204 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:16.906653887 UTC

[section ""cstring" . System.Environment.$trModule4_bytes" {
     System.Environment.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.90725823 UTC

[section ""data" . System.Environment.$trModule3_closure" {
     System.Environment.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.Environment.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.907844837 UTC

[section ""cstring" . System.Environment.$trModule2_bytes" {
     System.Environment.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,69,110,118,105,114,111,110,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.908422339 UTC

[section ""data" . System.Environment.$trModule1_closure" {
     System.Environment.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.Environment.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.909038042 UTC

[section ""data" . System.Environment.$trModule_closure" {
     System.Environment.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.Environment.$trModule3_closure+1;
         const System.Environment.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.909644843 UTC

[section ""cstring" . loc_rcolY_bytes" {
     loc_rcolY_bytes:
         I8[] [117,110,115,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.910470634 UTC

[section ""data" . loc1_rcolZ_closure" {
     loc1_rcolZ_closure:
         const loc1_rcolZ_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rcolZ_entry() //  [R1]
         { info_tbl: [(ccoK5,
                       label: loc1_rcolZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoK5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoK6; else goto ccoK7;
       ccoK6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoK7: // global
           (_ccoK2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccoK2::I64 == 0) goto ccoK4; else goto ccoK3;
       ccoK4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccoK3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccoK2::I64;
           R2 = loc_rcolY_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.911619044 UTC

[section ""data" . System.Environment.setEnv5_closure" {
     System.Environment.setEnv5_closure:
         const System.Environment.setEnv5_info;
         const 0;
 },
 System.Environment.setEnv5_entry() //  [R2]
         { info_tbl: [(ccoKe,
                       label: System.Environment.setEnv5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoKe: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = loc1_rcolZ_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.91277854 UTC

[section ""data" . System.Environment.setEnv4_closure" {
     System.Environment.setEnv4_closure:
         const System.Environment.setEnv4_info;
         const 0;
 },
 System.Environment.setEnv4_entry() //  [R2]
         { info_tbl: [(ccoKo,
                       label: System.Environment.setEnv4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoKo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccoKp; else goto ccoKq;
       ccoKp: // global
           R2 = R2;
           R1 = System.Environment.setEnv4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoKq: // global
           I64[Sp - 8] = block_ccoKl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoKM; else goto ccoKm;
       ucoKM: // global
           call _ccoKl(R1) args: 0, res: 0, upd: 0;
       ccoKm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoKl() //  [R1]
         { info_tbl: [(ccoKl,
                       label: block_ccoKl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoKl: // global
           (_scomi::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] __hsbase_unsetenv(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_scomi::I64) == 0 :: W32) goto ccoKH; else goto ccoKB;
       ccoKH: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoKB: // global
           (_scomn::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _scomn::I64;
           Sp = Sp + 8;
           call System.Environment.setEnv5_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.91415018 UTC

[section ""data" . System.Environment.unsetEnv1_closure" {
     System.Environment.unsetEnv1_closure:
         const System.Environment.unsetEnv1_info;
         const 0;
 },
 System.Environment.unsetEnv1_entry() //  [R2]
         { info_tbl: [(ccoKT,
                       label: System.Environment.unsetEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoKT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoKU; else goto ccoKV;
       ccoKU: // global
           R2 = R2;
           R1 = System.Environment.unsetEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoKV: // global
           I64[Sp - 16] = block_ccoKR_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoKR() //  [R1]
         { info_tbl: [(ccoKR,
                       label: block_ccoKR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoKR: // global
           R4 = System.Environment.setEnv4_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.915302235 UTC

[section ""data" . System.Environment.unsetEnv_closure" {
     System.Environment.unsetEnv_closure:
         const System.Environment.unsetEnv_info;
         const 0;
 },
 System.Environment.unsetEnv_entry() //  [R2]
         { info_tbl: [(ccoL1,
                       label: System.Environment.unsetEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoL1: // global
           R2 = R2;
           call System.Environment.unsetEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.916420513 UTC

[section ""data" . lvl_rcom0_closure" {
     lvl_rcom0_closure:
         const lvl_rcom0_info;
 },
 lvl_rcom0_entry() //  [R2, R3]
         { info_tbl: [(ccoLb,
                       label: lvl_rcom0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoLb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoLf; else goto ccoLg;
       ccoLf: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_rcom0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoLg: // global
           I64[Sp - 16] = block_ccoL8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucoLu; else goto ccoL9;
       ucoLu: // global
           call _ccoL8(R1) args: 0, res: 0, upd: 0;
       ccoL9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoL8() //  [R1]
         { info_tbl: [(ccoL8,
                       label: block_ccoL8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoL8: // global
           I64[Sp] = block_ccoLe_info;
           _scomy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _scomy::I64;
           if (R1 & 7 != 0) goto ucoLt; else goto ccoLi;
       ucoLt: // global
           call _ccoLe(R1) args: 0, res: 0, upd: 0;
       ccoLi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoLe() //  [R1]
         { info_tbl: [(ccoLe,
                       label: block_ccoLe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoLe: // global
           call "ccall" arg hints:  [‘signed’,
                                     PtrHint]  result hints:  [] setProgArgv(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.918423013 UTC

[section ""data" . System.Environment.$wlvl_closure" {
     System.Environment.$wlvl_closure:
         const System.Environment.$wlvl_info;
         const 0;
 },
 System.Environment.$wlvl_entry() //  [R2]
         { info_tbl: [(ccoLG,
                       label: System.Environment.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoLG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoLH; else goto ccoLI;
       ccoLH: // global
           R2 = R2;
           R1 = System.Environment.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoLI: // global
           (_scomK::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getenv(R2);
           if (_scomK::I64 == 0) goto ccoLF; else goto ccoLE;
       ccoLF: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoLE: // global
           I64[Sp - 16] = block_ccoLK_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _scomK::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucoLZ; else goto ccoLL;
       ucoLZ: // global
           call _ccoLK(R1) args: 0, res: 0, upd: 0;
       ccoLL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoLK() //  [R1]
         { info_tbl: [(ccoLK,
                       label: block_ccoLK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoLK: // global
           I64[Sp] = block_ccoLP_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoLP() //  [R1]
         { info_tbl: [(ccoLP,
                       label: block_ccoLP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoLP: // global
           _scomK::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_ccoLR_info;
           R3 = _scomK::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoLR() //  [R1]
         { info_tbl: [(ccoLR,
                       label: block_ccoLR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoLR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccoLY; else goto ccoLX;
       ccoLY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoLX: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.92018699 UTC

[section ""data" . System.Environment.getEnv3_closure" {
     System.Environment.getEnv3_closure:
         const System.Environment.getEnv3_info;
         const 0;
 },
 System.Environment.getEnv3_entry() //  [R2]
         { info_tbl: [(ccoM7,
                       label: System.Environment.getEnv3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoM7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccoM8; else goto ccoM9;
       ccoM8: // global
           R2 = R2;
           R1 = System.Environment.getEnv3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoM9: // global
           I64[Sp - 8] = block_ccoM4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoMd; else goto ccoM5;
       ucoMd: // global
           call _ccoM4(R1) args: 0, res: 0, upd: 0;
       ccoM5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoM4() //  [R1]
         { info_tbl: [(ccoM4,
                       label: block_ccoM4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoM4: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call System.Environment.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.921472325 UTC

[section ""data" . System.Environment.lookupEnv1_closure" {
     System.Environment.lookupEnv1_closure:
         const System.Environment.lookupEnv1_info;
         const 0;
 },
 System.Environment.lookupEnv1_entry() //  [R2]
         { info_tbl: [(ccoMk,
                       label: System.Environment.lookupEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoMk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoMl; else goto ccoMm;
       ccoMl: // global
           R2 = R2;
           R1 = System.Environment.lookupEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoMm: // global
           I64[Sp - 16] = block_ccoMi_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoMi() //  [R1]
         { info_tbl: [(ccoMi,
                       label: block_ccoMi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoMi: // global
           R4 = System.Environment.getEnv3_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.922605763 UTC

[section ""data" . System.Environment.lookupEnv_closure" {
     System.Environment.lookupEnv_closure:
         const System.Environment.lookupEnv_info;
         const 0;
 },
 System.Environment.lookupEnv_entry() //  [R2]
         { info_tbl: [(ccoMs,
                       label: System.Environment.lookupEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoMs: // global
           R2 = R2;
           call System.Environment.lookupEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.923410578 UTC

[section ""cstring" . lvl1_rcom1_bytes" {
     lvl1_rcom1_bytes:
         I8[] [103,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.92417162 UTC

[section ""data" . lvl2_rcom2_closure" {
     lvl2_rcom2_closure:
         const lvl2_rcom2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rcom2_entry() //  [R1]
         { info_tbl: [(ccoMB,
                       label: lvl2_rcom2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoMB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoMC; else goto ccoMD;
       ccoMC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoMD: // global
           (_ccoMy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccoMy::I64 == 0) goto ccoMA; else goto ccoMz;
       ccoMA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccoMz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccoMy::I64;
           R2 = lvl1_rcom1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.925080308 UTC

[section ""cstring" . lvl3_rcom3_bytes" {
     lvl3_rcom3_bytes:
         I8[] [110,111,32,101,110,118,105,114,111,110,109,101,110,116,32,118,97,114,105,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.925841385 UTC

[section ""data" . lvl4_rcom4_closure" {
     lvl4_rcom4_closure:
         const lvl4_rcom4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rcom4_entry() //  [R1]
         { info_tbl: [(ccoMK,
                       label: lvl4_rcom4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoMK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoML; else goto ccoMM;
       ccoML: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoMM: // global
           (_ccoMH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccoMH::I64 == 0) goto ccoMJ; else goto ccoMI;
       ccoMJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccoMI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccoMH::I64;
           R2 = lvl3_rcom3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.928699628 UTC

[section ""data" . System.Environment.getEnv2_closure" {
     System.Environment.getEnv2_closure:
         const System.Environment.getEnv2_info;
         const 0;
 },
 sat_scon9_entry() //  [R1]
         { info_tbl: [(ccoMX,
                       label: sat_scon9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoMX: // global
           _scon9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccoMY; else goto ccoMZ;
       ccoMZ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccoN1; else goto ccoN0;
       ccoN1: // global
           HpAlloc = 72;
           goto ccoMY;
       ccoMY: // global
           R1 = _scon9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoN0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scon9::P64;
           _scon6::P64 = P64[_scon9::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _scon6::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.NoSuchThing_closure+1;
           P64[Hp - 24] = lvl2_rcom2_closure;
           P64[Hp - 16] = lvl4_rcom4_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getEnv2_entry() //  [R2]
         { info_tbl: [(ccoN2,
                       label: System.Environment.getEnv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoN2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoN6; else goto ccoN5;
       ccoN6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = System.Environment.getEnv2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoN5: // global
           I64[Hp - 16] = sat_scon9_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.930674456 UTC

[section ""data" . System.Environment.getEnv1_closure" {
     System.Environment.getEnv1_closure:
         const System.Environment.getEnv1_info;
         const 0;
 },
 System.Environment.getEnv1_entry() //  [R2]
         { info_tbl: [(ccoNm,
                       label: System.Environment.getEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoNm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoNn; else goto ccoNo;
       ccoNn: // global
           R2 = R2;
           R1 = System.Environment.getEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoNo: // global
           I64[Sp - 16] = block_ccoNb_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoNb() //  [R1]
         { info_tbl: [(ccoNb,
                       label: block_ccoNb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoNb: // global
           I64[Sp] = block_ccoNd_info;
           R4 = System.Environment.getEnv3_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoNd() //  [R1]
         { info_tbl: [(ccoNd,
                       label: block_ccoNd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoNd: // global
           I64[Sp] = block_ccoNf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucoNx; else goto ccoNg;
       ucoNx: // global
           call _ccoNf(R1) args: 0, res: 0, upd: 0;
       ccoNg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoNf() //  [R1]
         { info_tbl: [(ccoNf,
                       label: block_ccoNf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoNf: // global
           if (R1 & 7 == 1) goto ccoNj; else goto ccoNk;
       ccoNj: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call System.Environment.getEnv2_entry(R2) args: 8, res: 0, upd: 8;
       ccoNk: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.932107073 UTC

[section ""data" . System.Environment.getEnv_closure" {
     System.Environment.getEnv_closure:
         const System.Environment.getEnv_info;
         const 0;
 },
 System.Environment.getEnv_entry() //  [R2]
         { info_tbl: [(ccoNC,
                       label: System.Environment.getEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoNC: // global
           R2 = R2;
           call System.Environment.getEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.933373954 UTC

[section ""data" . System.Environment.getProgName_go_closure" {
     System.Environment.getProgName_go_closure:
         const System.Environment.getProgName_go_info;
 },
 System.Environment.getProgName_go_entry() //  [R2, R3]
         { info_tbl: [(ccoNQ,
                       label: System.Environment.getProgName_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoNQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoNR; else goto ucoO9;
       ccoNR: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.getProgName_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ucoO9: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ccoNG() args: 0, res: 0, upd: 0;
     }
 },
 _ccoNG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoNG: // global
           I64[Sp - 8] = block_ccoNJ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoOc; else goto ccoNK;
       ucoOc: // global
           call _ccoNJ(R1) args: 0, res: 0, upd: 0;
       ccoNK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoNJ() //  [R1]
         { info_tbl: [(ccoNJ,
                       label: block_ccoNJ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoNJ: // global
           if (R1 & 7 == 1) goto ccoNN; else goto ccoNO;
       ccoNN: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccoNO: // global
           I64[Sp] = block_ccoNY_info;
           _scono::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _scono::P64;
           if (R1 & 7 != 0) goto ucoOd; else goto ccoO0;
       ucoOd: // global
           call _ccoNY(R1) args: 0, res: 0, upd: 0;
       ccoO0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoNY() //  [R1]
         { info_tbl: [(ccoNY,
                       label: block_ccoNY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoNY: // global
           _scono::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 47) goto ccoO8; else goto ccoO7;
       ccoO8: // global
           P64[Sp + 8] = _scono::P64;
           P64[Sp + 16] = _scono::P64;
           Sp = Sp + 8;
           goto ucoOg;
       ccoO7: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = _scono::P64;
           Sp = Sp + 8;
           goto ucoOg;
       ucoOg: // global
           call _ccoNG() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.935558924 UTC

[section ""data" . System.Environment.getProgName1_closure" {
     System.Environment.getProgName1_closure:
         const System.Environment.getProgName1_info;
         const 0;
 },
 sat_scoo1_entry() //  [R1]
         { info_tbl: [(ccoON,
                       label: sat_scoo1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoON: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoOO; else goto ccoOP;
       ccoOO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoOP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _sconY::P64 = P64[R1 + 16];
           R3 = _sconY::P64;
           R2 = _sconY::P64;
           Sp = Sp - 16;
           call System.Environment.getProgName_go_entry(R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getProgName1_entry() //  []
         { info_tbl: [(ccoOQ,
                       label: System.Environment.getProgName1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoOQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccoOR; else goto ccoOS;
       ccoOR: // global
           R1 = System.Environment.getProgName1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccoOS: // global
           I64[Sp - 8] = block_ccoOl_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoOl() //  [R1]
         { info_tbl: [(ccoOl,
                       label: block_ccoOl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoOl: // global
           I64[Sp - 8] = block_ccoOn_info;
           R2 = 8;
           _scony::P64 = R1;
           R1 = 8;
           P64[Sp] = _scony::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoOn() //  [R1]
         { info_tbl: [(ccoOn,
                       label: block_ccoOn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoOn: // global
           _sconF::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getProgArgv(P64[Sp + 8] + 16, _sconF::I64);
           _sconM::I64 = I64[_sconF::I64];
           I64[Sp - 16] = block_ccoOy_info;
           _sconE::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _sconM::I64;
           P64[Sp] = _sconE::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucoP0; else goto ccoOz;
       ucoP0: // global
           call _ccoOy(R1) args: 0, res: 0, upd: 0;
       ccoOz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoOy() //  [R1]
         { info_tbl: [(ccoOy,
                       label: block_ccoOy_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoOy: // global
           I64[Sp] = block_ccoOD_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoOD() //  [R1]
         { info_tbl: [(ccoOD,
                       label: block_ccoOD_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoOD: // global
           _sconV::I64 = I64[I64[Sp + 8]];
           I64[Sp + 8] = block_ccoOF_info;
           R3 = _sconV::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoOF() //  [R1]
         { info_tbl: [(ccoOF,
                       label: block_ccoOF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoOF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoOZ; else goto ccoOY;
       ccoOZ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoOY: // global
           _scony::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_scony::P64);
           I64[Hp - 16] = sat_scoo1_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.937747462 UTC

[section ""data" . System.Environment.getProgName_closure" {
     System.Environment.getProgName_closure:
         const System.Environment.getProgName_info;
         const 0;
 },
 System.Environment.getProgName_entry() //  []
         { info_tbl: [(ccoP5,
                       label: System.Environment.getProgName_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoP5: // global
           call System.Environment.getProgName1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.940305578 UTC

[section ""data" . System.Environment.getArgs1_closure" {
     System.Environment.getArgs1_closure:
         const System.Environment.getArgs1_info;
         const 0;
 },
 go_scooA_entry() //  [R1, R2]
         { info_tbl: [(ccoQa,
                       label: go_scooA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoQa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccoQb; else goto ccoQc;
       ccoQb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoQc: // global
           I64[Sp - 24] = block_ccoQ3_info;
           _scooA::P64 = R1;
           _scoov::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _scoov::P64;
           P64[Sp - 8] = _scooA::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucoQz; else goto ccoQ4;
       ucoQz: // global
           call _ccoQ3(R1) args: 0, res: 0, upd: 0;
       ccoQ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoQ3() //  [R1]
         { info_tbl: [(ccoQ3,
                       label: block_ccoQ3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoQ3: // global
           if (R1 & 7 == 1) goto ccoQ7; else goto ccoQ8;
       ccoQ7: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoQ8: // global
           I64[Sp - 8] = block_ccoQi_info;
           _scooF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scooF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoQy; else goto ccoQj;
       ucoQy: // global
           call _ccoQi(R1) args: 0, res: 0, upd: 0;
       ccoQj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoQi() //  [R1]
         { info_tbl: [(ccoQi,
                       label: block_ccoQi_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoQi: // global
           I64[Sp] = block_ccoQn_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoQn() //  [R1]
         { info_tbl: [(ccoQn,
                       label: block_ccoQn_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoQn: // global
           I64[Sp + 16] = block_ccoQp_info;
           R2 = P64[Sp + 8];
           _scooK::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _scooK::P64;
           Sp = Sp + 16;
           call go_scooA_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoQp() //  [R1]
         { info_tbl: [(ccoQp,
                       label: block_ccoQp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoQp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoQx; else goto ccoQw;
       ccoQx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoQw: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.Environment.getArgs1_entry() //  []
         { info_tbl: [(ccoQA,
                       label: System.Environment.getArgs1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoQA: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccoQB; else goto ccoQC;
       ccoQB: // global
           R1 = System.Environment.getArgs1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccoQC: // global
           I64[Sp - 8] = block_ccoPc_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoPc() //  [R1]
         { info_tbl: [(ccoPc,
                       label: block_ccoPc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoPc: // global
           I64[Sp - 8] = block_ccoPe_info;
           R2 = 8;
           _scoo8::P64 = R1;
           R1 = 8;
           P64[Sp] = _scoo8::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoPe() //  [R1]
         { info_tbl: [(ccoPe,
                       label: block_ccoPe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoPe: // global
           _scoof::I64 = P64[Sp + 8] + 16;
           _scoog::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getProgArgv(_scoof::I64, _scoog::I64);
           _scoom::I64 = %MO_SS_Conv_W32_W64(I32[_scoof::I64]);
           _scoop::I64 = I64[_scoog::I64];
           I64[Sp - 24] = block_ccoPp_info;
           _scooe::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 16] = _scoom::I64;
           I64[Sp - 8] = _scoop::I64;
           P64[Sp] = _scooe::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucoRe; else goto ccoPq;
       ucoRe: // global
           call _ccoPp(R1) args: 0, res: 0, upd: 0;
       ccoPq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoPp() //  [R1]
         { info_tbl: [(ccoPp,
                       label: block_ccoPp_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoPp: // global
           I64[Sp] = block_ccoPu_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoPu() //  [R1]
         { info_tbl: [(ccoPu,
                       label: block_ccoPu_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoPu: // global
           _scoow::I64 = I64[Sp + 8] - 1;
           if (%MO_S_Gt_W64(_scoow::I64, 0)) goto ccoR0; else goto ccoR1;
       ccoR0: // global
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _scoow::I64 - 1;
           I64[Sp + 8] = I64[Sp + 16] + 8;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _ccoPO() args: 0, res: 0, upd: 0;
       ccoR1: // global
           P64[Sp + 16] = R1;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _ccoPW() args: 0, res: 0, upd: 0;
     }
 },
 _ccoPO() //  []
         { info_tbl: [(ccoPO,
                       label: block_ccoPO_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoPO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccoQV; else goto ccoQU;
       ccoQV: // global
           HpAlloc = 40;
           I64[Sp] = block_ccoPO_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccoQU: // global
           _scop6::P64 = P64[Sp + 8];
           _scop8::I64 = I64[Sp + 16];
           if (_scop8::I64 != 0) goto ccoQX; else goto ccoQY;
       ccoQX: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 24] + (_scop8::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scop6::P64;
           I64[Sp + 16] = _scop8::I64 - 1;
           P64[Sp + 8] = Hp - 14;
           call _ccoPO() args: 0, res: 0, upd: 0;
       ccoQY: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _scop6::P64;
           Sp = Sp + 16;
           call _ccoQO() args: 0, res: 0, upd: 0;
     }
 },
 _ccoQO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoQO: // global
           Hp = Hp + 40;
           _scooX::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccoQS; else goto ccoQR;
       ccoQS: // global
           HpAlloc = 40;
           I64[Sp] = block_ccoQN_info;
           R1 = _scooX::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoQR: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 8]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scooX::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           call _ccoPW() args: 0, res: 0, upd: 0;
     }
 },
 _ccoQN() //  [R1]
         { info_tbl: [(ccoQN,
                       label: block_ccoQN_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoQN: // global
           P64[Sp] = R1;
           call _ccoQO() args: 0, res: 0, upd: 0;
     }
 },
 _ccoPW() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoPW: // global
           Hp = Hp + 16;
           _scooz::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccoQK; else goto ccoQJ;
       ccoQK: // global
           HpAlloc = 16;
           I64[Sp] = block_ccoPV_info;
           R1 = _scooz::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoQJ: // global
           I64[Hp - 8] = go_scooA_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccoQH_info;
           R2 = _scooz::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_scooA_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoPV() //  [R1]
         { info_tbl: [(ccoPV,
                       label: block_ccoPV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoPV: // global
           P64[Sp] = R1;
           call _ccoPW() args: 0, res: 0, upd: 0;
     }
 },
 _ccoQH() //  [R1]
         { info_tbl: [(ccoQH,
                       label: block_ccoQH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoQH: // global
           _scoo8::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_scoo8::P64);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.944549266 UTC

[section ""data" . System.Environment.getArgs_closure" {
     System.Environment.getArgs_closure:
         const System.Environment.getArgs_info;
         const 0;
 },
 System.Environment.getArgs_entry() //  []
         { info_tbl: [(ccoRq,
                       label: System.Environment.getArgs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoRq: // global
           call System.Environment.getArgs1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.948037268 UTC

[section ""data" . System.Environment.withArgs2_closure" {
     System.Environment.withArgs2_closure:
         const System.Environment.withArgs2_info;
         const 0;
 },
 sat_scopM_entry() //  [R1, R2]
         { info_tbl: [(ccoRY,
                       label: sat_scopM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoRY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoRZ; else goto ccoS0;
       ccoRZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoS0: // global
           I64[Sp - 24] = block_ccoRU_info;
           _scops::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scops::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoRU() //  [R1]
         { info_tbl: [(ccoRU,
                       label: block_ccoRU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoRU: // global
           _scops::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccoRW_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scops::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoRW() //  []
         { info_tbl: [(ccoRW,
                       label: block_ccoRW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoRW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scopD_entry() //  [R1]
         { info_tbl: [(ccoS8,
                       label: sat_scopD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoS8: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqf_entry() //  [R1, R2]
         { info_tbl: [(ccoSz,
                       label: sat_scoqf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoSA; else goto ccoSB;
       ccoSA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoSB: // global
           I64[Sp - 24] = block_ccoSv_info;
           _scops::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scops::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoSv() //  [R1]
         { info_tbl: [(ccoSv,
                       label: block_ccoSv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSv: // global
           _scops::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccoSx_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scops::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoSx() //  []
         { info_tbl: [(ccoSx,
                       label: block_ccoSx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoq6_entry() //  [R1]
         { info_tbl: [(ccoSJ,
                       label: sat_scoq6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSJ: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqp_entry() //  [R1]
         { info_tbl: [(ccoSM,
                       label: sat_scoqp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccoSS; else goto ccoST;
       ccoSS: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccoST: // global
           I64[Sp - 32] = block_ccoSh_info;
           _scopg::P64 = P64[R1 + 7];
           _scoph::P64 = P64[R1 + 15];
           _scops::P64 = P64[R1 + 23];
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp - 24] = _scopg::P64;
           P64[Sp - 16] = _scoph::P64;
           P64[Sp - 8] = _scops::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucoT3; else goto ccoSi;
       ucoT3: // global
           call _ccoSh(R1) args: 0, res: 0, upd: 0;
       ccoSi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoSh() //  [R1]
         { info_tbl: [(ccoSh,
                       label: block_ccoSh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSh: // global
           I64[Sp - 8] = block_ccoSm_info;
           _scopY::P64 = P64[R1 + 7];
           R1 = _scopY::P64;
           P64[Sp] = _scopY::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoSm() //  [R1]
         { info_tbl: [(ccoSm,
                       label: block_ccoSm_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSm: // global
           I64[Sp] = block_ccoSo_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoSo() //  [R1]
         { info_tbl: [(ccoSo,
                       label: block_ccoSo_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccoSY; else goto ccoSX;
       ccoSY: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoSX: // global
           I64[Hp - 32] = sat_scoqf_info;
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scoq6_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_ccoSN_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoSN() //  [R1]
         { info_tbl: [(ccoSN,
                       label: block_ccoSN_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSN: // global
           I64[Sp + 16] = block_ccoSP_info;
           _scoqi::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _scoqi::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoSP() //  [R1]
         { info_tbl: [(ccoSP,
                       label: block_ccoSP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSP: // global
           I64[Sp] = block_ccoSR_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoSR() //  []
         { info_tbl: [(ccoSR,
                       label: block_ccoSR_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoSR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqI_entry() //  [R1, R2]
         { info_tbl: [(ccoTn,
                       label: sat_scoqI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoTn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoTo; else goto ccoTp;
       ccoTo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoTp: // global
           I64[Sp - 24] = block_ccoTj_info;
           _scops::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scops::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoTj() //  [R1]
         { info_tbl: [(ccoTj,
                       label: block_ccoTj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoTj: // global
           _scops::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccoTl_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scops::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoTl() //  []
         { info_tbl: [(ccoTl,
                       label: block_ccoTl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoTl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqz_entry() //  [R1]
         { info_tbl: [(ccoTx,
                       label: sat_scoqz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoTx: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.Environment.withArgs2_entry() //  [R2, R3]
         { info_tbl: [(ccoTE,
                       label: System.Environment.withArgs2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoTE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccoTF; else goto ccoTG;
       ccoTF: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withArgs2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoTG: // global
           I64[Sp - 24] = block_ccoRx_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getProgName1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccoRx() //  [R1]
         { info_tbl: [(ccoRx,
                       label: block_ccoRx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoRx: // global
           I64[Sp - 8] = block_ccoRz_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call System.Environment.getArgs1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccoRz() //  [R1]
         { info_tbl: [(ccoRz,
                       label: block_ccoRz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoRz: // global
           I64[Sp - 8] = block_ccoRB_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ccoRB() //  [R1]
         { info_tbl: [(ccoRB,
                       label: block_ccoRB_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoRB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccoTL; else goto ccoTK;
       ccoTL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccoTK: // global
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           _ccoRD::P64 = Hp - 46;
           if (R1 == 0) goto ccoTC; else goto ucoUe;
       ccoTC: // global
           I64[Hp - 24] = sat_scoqp_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _ccoRD::P64;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ucoUe: // global
           if (R1 == 1) goto ccoTD; else goto ccoTB;
       ccoTD: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_ccoT5_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _ccoRD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucoUg; else goto ccoT6;
       ucoUg: // global
           call _ccoT5(R1) args: 0, res: 0, upd: 0;
       ccoT6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccoTB: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_ccoRG_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _ccoRD::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucoUf; else goto ccoRH;
       ucoUf: // global
           call _ccoRG(R1) args: 0, res: 0, upd: 0;
       ccoRH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoT5() //  [R1]
         { info_tbl: [(ccoT5,
                       label: block_ccoT5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoT5: // global
           I64[Sp - 8] = block_ccoTa_info;
           _scoqr::P64 = P64[R1 + 7];
           R1 = _scoqr::P64;
           P64[Sp] = _scoqr::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoTa() //  [R1]
         { info_tbl: [(ccoTa,
                       label: block_ccoTa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoTa: // global
           I64[Sp] = block_ccoTc_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoTc() //  [R1]
         { info_tbl: [(ccoTc,
                       label: block_ccoTc_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoTc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccoU9; else goto ccoU8;
       ccoU9: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoU8: // global
           I64[Hp - 32] = sat_scoqI_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scoqz_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_ccoU0_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoU0() //  [R1]
         { info_tbl: [(ccoU0,
                       label: block_ccoU0_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoU0: // global
           _scoqr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccoU2_info;
           _scoqL::P64 = R1;
           R1 = _scoqr::P64;
           P64[Sp + 32] = _scoqL::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoU2() //  [R1]
         { info_tbl: [(ccoU2,
                       label: block_ccoU2_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoU2: // global
           I64[Sp + 16] = block_ccoU4_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoU4() //  []
         { info_tbl: [(ccoU4,
                       label: block_ccoU4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoU4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccoRG() //  [R1]
         { info_tbl: [(ccoRG,
                       label: block_ccoRG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoRG: // global
           I64[Sp - 8] = block_ccoRL_info;
           _scopv::P64 = P64[R1 + 7];
           R1 = _scopv::P64;
           P64[Sp] = _scopv::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoRL() //  [R1]
         { info_tbl: [(ccoRL,
                       label: block_ccoRL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoRL: // global
           I64[Sp] = block_ccoRN_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoRN() //  [R1]
         { info_tbl: [(ccoRN,
                       label: block_ccoRN_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoRN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccoTV; else goto ccoTU;
       ccoTV: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoTU: // global
           I64[Hp - 32] = sat_scopM_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scopD_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_ccoTM_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoTM() //  [R1]
         { info_tbl: [(ccoTM,
                       label: block_ccoTM_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoTM: // global
           _scopv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccoTO_info;
           _scopP::P64 = R1;
           R1 = _scopv::P64;
           P64[Sp + 32] = _scopP::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoTO() //  [R1]
         { info_tbl: [(ccoTO,
                       label: block_ccoTO_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoTO: // global
           I64[Sp + 16] = block_ccoTQ_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoTQ() //  []
         { info_tbl: [(ccoTQ,
                       label: block_ccoTQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoTQ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.955454737 UTC

[section ""data" . System.Environment.withArgs1_closure" {
     System.Environment.withArgs1_closure:
         const System.Environment.withArgs1_info;
         const 0;
 },
 System.Environment.withArgs1_entry() //  [R2, R3]
         { info_tbl: [(ccoUo,
                       label: System.Environment.withArgs1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoUo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoUp; else goto ccoUq;
       ccoUp: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withArgs1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoUq: // global
           I64[Sp - 24] = block_ccoUl_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getProgName1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccoUl() //  [R1]
         { info_tbl: [(ccoUl,
                       label: block_ccoUl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoUl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoUt; else goto ccoUs;
       ccoUt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoUs: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = Hp - 14;
           Sp = Sp + 24;
           call System.Environment.withArgs2_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.95677609 UTC

[section ""data" . System.Environment.withArgs_closure" {
     System.Environment.withArgs_closure:
         const System.Environment.withArgs_info;
         const 0;
 },
 System.Environment.withArgs_entry() //  [R2, R3]
         { info_tbl: [(ccoUy,
                       label: System.Environment.withArgs_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoUy: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.withArgs1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.957974419 UTC

[section ""data" . System.Environment.withProgName1_closure" {
     System.Environment.withProgName1_closure:
         const System.Environment.withProgName1_info;
         const 0;
 },
 System.Environment.withProgName1_entry() //  [R2, R3]
         { info_tbl: [(ccoUI,
                       label: System.Environment.withProgName1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoUI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoUJ; else goto ccoUK;
       ccoUJ: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withProgName1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoUK: // global
           I64[Sp - 24] = block_ccoUF_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getArgs1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccoUF() //  [R1]
         { info_tbl: [(ccoUF,
                       label: block_ccoUF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoUF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoUN; else goto ccoUM;
       ccoUN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoUM: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R3 = P64[Sp + 16];
           R2 = Hp - 14;
           Sp = Sp + 24;
           call System.Environment.withArgs2_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.959252591 UTC

[section ""data" . System.Environment.withProgName_closure" {
     System.Environment.withProgName_closure:
         const System.Environment.withProgName_info;
         const 0;
 },
 System.Environment.withProgName_entry() //  [R2, R3]
         { info_tbl: [(ccoUS,
                       label: System.Environment.withProgName_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoUS: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.withProgName1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.960289709 UTC

[section ""data" . System.Environment.getEnvironment3_closure" {
     System.Environment.getEnvironment3_closure:
         const System.Environment.getEnvironment3_info;
 },
 System.Environment.getEnvironment3_entry() //  [R2]
         { info_tbl: [(ccoV2,
                       label: System.Environment.getEnvironment3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoV2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccoV3; else goto ccoV4;
       ccoV3: // global
           R2 = R2;
           R1 = System.Environment.getEnvironment3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoV4: // global
           I64[Sp - 8] = block_ccoUZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoVc; else goto ccoV0;
       ucoVc: // global
           call _ccoUZ(R1) args: 0, res: 0, upd: 0;
       ccoV0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoUZ() //  [R1]
         { info_tbl: [(ccoUZ,
                       label: block_ccoUZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoUZ: // global
           if (I64[R1 + 7] == 61) goto ccoVb; else goto ccoVa;
       ccoVb: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoVa: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.961846595 UTC

[section ""data" . System.Environment.getEnvironment2_closure" {
     System.Environment.getEnvironment2_closure:
         const System.Environment.getEnvironment2_info;
 },
 System.Environment.getEnvironment2_entry() //  [R2]
         { info_tbl: [(ccoVq,
                       label: System.Environment.getEnvironment2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoVq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoVr; else goto ccoVs;
       ccoVr: // global
           R2 = R2;
           R1 = System.Environment.getEnvironment2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoVs: // global
           I64[Sp - 8] = block_ccoVh_info;
           R3 = R2;
           R2 = System.Environment.getEnvironment3_closure+1;
           Sp = Sp - 8;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoVh() //  [R1, R2]
         { info_tbl: [(ccoVh,
                       label: block_ccoVh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoVh: // global
           I64[Sp - 8] = block_ccoVj_info;
           _scorc::P64 = R1;
           R1 = R2;
           P64[Sp] = _scorc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoVG; else goto ccoVk;
       ucoVG: // global
           call _ccoVj(R1) args: 0, res: 0, upd: 0;
       ccoVk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoVj() //  [R1]
         { info_tbl: [(ccoVj,
                       label: block_ccoVj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoVj: // global
           _scorc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccoVn; else goto ccoVo;
       ccoVn: // global
           Hp = Hp + 24;
           _score::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccoVF; else goto ccoVy;
       ccoVy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scorc::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoVo: // global
           Hp = Hp + 24;
           _score::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccoVF; else goto ccoVE;
       ccoVF: // global
           HpAlloc = 24;
           R1 = _score::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoVE: // global
           _scorg::P64 = P64[_score::P64 + 14];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scorc::P64;
           P64[Hp] = _scorg::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.965318036 UTC

[section ""data" . System.Environment.getEnvironment1_closure" {
     System.Environment.getEnvironment1_closure:
         const System.Environment.getEnvironment1_info;
         const 0;
 },
 go_scorz_entry() //  [R1, R2]
         { info_tbl: [(ccoWz,
                       label: go_scorz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoWz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccoWA; else goto ccoWB;
       ccoWA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoWB: // global
           I64[Sp - 24] = block_ccoWs_info;
           _scorz::P64 = R1;
           _scors::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _scors::P64;
           P64[Sp - 8] = _scorz::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucoWY; else goto ccoWt;
       ucoWY: // global
           call _ccoWs(R1) args: 0, res: 0, upd: 0;
       ccoWt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoWs() //  [R1]
         { info_tbl: [(ccoWs,
                       label: block_ccoWs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoWs: // global
           if (R1 & 7 == 1) goto ccoWw; else goto ccoWx;
       ccoWw: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoWx: // global
           I64[Sp - 8] = block_ccoWH_info;
           _scorE::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scorE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoWX; else goto ccoWI;
       ucoWX: // global
           call _ccoWH(R1) args: 0, res: 0, upd: 0;
       ccoWI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoWH() //  [R1]
         { info_tbl: [(ccoWH,
                       label: block_ccoWH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoWH: // global
           I64[Sp] = block_ccoWM_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoWM() //  [R1]
         { info_tbl: [(ccoWM,
                       label: block_ccoWM_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoWM: // global
           I64[Sp + 16] = block_ccoWO_info;
           R2 = P64[Sp + 8];
           _scorJ::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _scorJ::P64;
           Sp = Sp + 16;
           call go_scorz_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoWO() //  [R1]
         { info_tbl: [(ccoWO,
                       label: block_ccoWO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoWO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoWW; else goto ccoWV;
       ccoWW: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoWV: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scorR_entry() //  [R1]
         { info_tbl: [(ccoX5,
                       label: sat_scorR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoX5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoX6; else goto ccoX7;
       ccoX6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoX7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = System.Environment.getEnvironment2_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getEnvironment1_entry() //  []
         { info_tbl: [(ccoXb,
                       label: System.Environment.getEnvironment1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoXb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccoXc; else goto ccoXd;
       ccoXc: // global
           R1 = System.Environment.getEnvironment1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccoXd: // global
           (_scorl::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] __hscore_environ();
           if (_scorl::I64 == 0) goto ccoXa; else goto ccoX9;
       ccoXa: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoX9: // global
           I64[Sp - 16] = block_ccoVP_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _scorl::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucoY4; else goto ccoVQ;
       ucoY4: // global
           call _ccoVP(R1) args: 0, res: 0, upd: 0;
       ccoVQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoVP() //  [R1]
         { info_tbl: [(ccoVP,
                       label: block_ccoVP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoVP: // global
           I64[Sp] = block_ccoVU_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoVU() //  [R1]
         { info_tbl: [(ccoVU,
                       label: block_ccoVU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoVU: // global
           _scorl::I64 = I64[Sp + 8];
           _scors::P64 = R1;
           _scose::I64 = 0;
           goto ccoXF;
       ccoXF: // global
           if (I64[_scorl::I64 + (_scose::I64 << 3)] == 0) goto ccoXM; else goto ccoXL;
       ccoXM: // global
           if (%MO_S_Gt_W64(_scose::I64, 0)) goto ccoXA; else goto ccoXB;
       ccoXA: // global
           I64[Sp - 16] = _scose::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           P64[Sp] = _scors::P64;
           Sp = Sp - 24;
           call _ccoWd() args: 0, res: 0, upd: 0;
       ccoXB: // global
           P64[Sp] = _scors::P64;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           call _ccoWl() args: 0, res: 0, upd: 0;
       ccoXL: // global
           _scose::I64 = _scose::I64 + 1;
           goto ccoXF;
     }
 },
 _ccoWd() //  []
         { info_tbl: [(ccoWd,
                       label: block_ccoWd_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoWd: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccoXv; else goto ccoXu;
       ccoXv: // global
           HpAlloc = 40;
           I64[Sp] = block_ccoWd_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccoXu: // global
           _scos3::P64 = P64[Sp + 16];
           _scos5::I64 = I64[Sp + 8];
           if (_scos5::I64 != 0) goto ccoXx; else goto ccoXy;
       ccoXx: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 32] + (_scos5::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scos3::P64;
           I64[Sp + 8] = _scos5::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _ccoWd() args: 0, res: 0, upd: 0;
       ccoXy: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _scos3::P64;
           Sp = Sp + 16;
           call _ccoXo() args: 0, res: 0, upd: 0;
     }
 },
 _ccoXo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoXo: // global
           Hp = Hp + 40;
           _scorU::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccoXs; else goto ccoXr;
       ccoXs: // global
           HpAlloc = 40;
           I64[Sp] = block_ccoXn_info;
           R1 = _scorU::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoXr: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 16]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scorU::P64;
           P64[Sp + 16] = Hp - 14;
           Sp = Sp + 8;
           call _ccoWl() args: 0, res: 0, upd: 0;
     }
 },
 _ccoXn() //  [R1]
         { info_tbl: [(ccoXn,
                       label: block_ccoXn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoXn: // global
           P64[Sp] = R1;
           call _ccoXo() args: 0, res: 0, upd: 0;
     }
 },
 _ccoWl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoWl: // global
           Hp = Hp + 16;
           _scory::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto ccoXj; else goto ccoXi;
       ccoXj: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_ccoWk_info;
           R1 = _scory::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoXi: // global
           I64[Hp - 8] = go_scorz_info;
           P64[Hp] = P64[Sp];
           I64[Sp + 8] = block_ccoWZ_info;
           R2 = _scory::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_scorz_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoWk() //  [R1]
         { info_tbl: [(ccoWk,
                       label: block_ccoWk_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoWk: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _ccoWl() args: 0, res: 0, upd: 0;
     }
 },
 _ccoWZ() //  [R1]
         { info_tbl: [(ccoWZ,
                       label: block_ccoWZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoWZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoXm; else goto ccoXl;
       ccoXm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccoXl: // global
           I64[Hp - 16] = sat_scorR_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.969709933 UTC

[section ""data" . System.Environment.getEnvironment_closure" {
     System.Environment.getEnvironment_closure:
         const System.Environment.getEnvironment_info;
         const 0;
 },
 System.Environment.getEnvironment_entry() //  []
         { info_tbl: [(ccoYb,
                       label: System.Environment.getEnvironment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoYb: // global
           call System.Environment.getEnvironment1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.970693943 UTC

[section ""data" . System.Environment.setEnv11_closure" {
     System.Environment.setEnv11_closure:
         const System.Environment.setEnv11_info;
 },
 System.Environment.setEnv11_entry() //  [R2]
         { info_tbl: [(ccoYl,
                       label: System.Environment.setEnv11_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoYl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccoYm; else goto ccoYn;
       ccoYm: // global
           R2 = R2;
           R1 = System.Environment.setEnv11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccoYn: // global
           I64[Sp - 8] = block_ccoYi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucoYv; else goto ccoYj;
       ucoYv: // global
           call _ccoYi(R1) args: 0, res: 0, upd: 0;
       ccoYj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoYi() //  [R1]
         { info_tbl: [(ccoYi,
                       label: block_ccoYi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoYi: // global
           if (I64[R1 + 7] == 0) goto ccoYu; else goto ccoYt;
       ccoYu: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccoYt: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.971813309 UTC

[section ""cstring" . lvl5_rcom5_bytes" {
     lvl5_rcom5_bytes:
         I8[] [112,117,116,101,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.972639938 UTC

[section ""data" . lvl6_rcom6_closure" {
     lvl6_rcom6_closure:
         const lvl6_rcom6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rcom6_entry() //  [R1]
         { info_tbl: [(ccoYC,
                       label: lvl6_rcom6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoYC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoYD; else goto ccoYE;
       ccoYD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoYE: // global
           (_ccoYz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccoYz::I64 == 0) goto ccoYB; else goto ccoYA;
       ccoYB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccoYA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccoYz::I64;
           R2 = lvl5_rcom5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.973833391 UTC

[section ""data" . System.Environment.setEnv2_closure" {
     System.Environment.setEnv2_closure:
         const System.Environment.setEnv2_info;
         const 0;
 },
 System.Environment.setEnv2_entry() //  [R2]
         { info_tbl: [(ccoYL,
                       label: System.Environment.setEnv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoYL: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl6_rcom6_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.974656187 UTC

[section ""cstring" . System.Environment.setEnv10_bytes" {
     System.Environment.setEnv10_bytes:
         I8[] [115,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.975471683 UTC

[section ""data" . System.Environment.setEnv9_closure" {
     System.Environment.setEnv9_closure:
         const System.Environment.setEnv9_info;
         const 0;
         const 0;
         const 0;
 },
 System.Environment.setEnv9_entry() //  [R1]
         { info_tbl: [(ccoYU,
                       label: System.Environment.setEnv9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoYU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoYV; else goto ccoYW;
       ccoYV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoYW: // global
           (_ccoYR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccoYR::I64 == 0) goto ccoYT; else goto ccoYS;
       ccoYT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccoYS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccoYR::I64;
           R2 = System.Environment.setEnv10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.976436841 UTC

[section ""data" . System.Environment.setEnv8_closure" {
     System.Environment.setEnv8_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const System.Environment.setEnv9_closure;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.977311406 UTC

[section ""data" . System.Environment.setEnv7_closure" {
     System.Environment.setEnv7_closure:
         const System.Environment.setEnv7_info;
         const 0;
         const 0;
         const 0;
 },
 System.Environment.setEnv7_entry() //  [R1]
         { info_tbl: [(ccoZ3,
                       label: System.Environment.setEnv7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoZ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccoZ4; else goto ccoZ5;
       ccoZ4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoZ5: // global
           (_ccoZ0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccoZ0::I64 == 0) goto ccoZ2; else goto ccoZ1;
       ccoZ2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccoZ1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccoZ0::I64;
           R2 = System.Environment.setEnv8_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.980092451 UTC

[section ""data" . System.Environment.setEnv6_closure" {
     System.Environment.setEnv6_closure:
         const GHC.Types.C#_con_info;
         const 61;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.980714191 UTC

[section ""cstring" . System.Environment.setEnv3_bytes" {
     System.Environment.setEnv3_bytes:
         I8[] [61]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.983117871 UTC

[section ""data" . System.Environment.setEnv1_closure" {
     System.Environment.setEnv1_closure:
         const System.Environment.setEnv1_info;
         const 0;
 },
 sat_scosL_entry() //  [R1]
         { info_tbl: [(ccoZD,
                       label: sat_scosL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoZD: // global
           R3 = P64[R1 + 16];
           R2 = System.Environment.setEnv3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scosM_entry() //  [R1]
         { info_tbl: [(ccoZG,
                       label: sat_scosM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoZG: // global
           _scosM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccoZH; else goto ccoZI;
       ccoZI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccoZK; else goto ccoZJ;
       ccoZK: // global
           HpAlloc = 24;
           goto ccoZH;
       ccoZH: // global
           R1 = _scosM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccoZJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scosM::P64;
           _scosv::P64 = P64[_scosM::P64 + 16];
           _scosz::P64 = P64[_scosM::P64 + 24];
           I64[Hp - 16] = sat_scosL_info;
           P64[Hp] = _scosz::P64;
           R3 = Hp - 16;
           R2 = _scosv::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.setEnv1_entry() //  [R2, R3]
         { info_tbl: [(ccoZP,
                       label: System.Environment.setEnv1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoZP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccoZQ; else goto ccoZR;
       ccoZQ: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.setEnv1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccoZR: // global
           I64[Sp - 16] = block_ccoZa_info;
           _scost::P64 = R3;
           R3 = R2;
           R2 = System.Environment.setEnv11_closure+1;
           P64[Sp - 8] = _scost::P64;
           Sp = Sp - 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoZa() //  [R1]
         { info_tbl: [(ccoZa,
                       label: block_ccoZa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoZa: // global
           if (R1 & 7 == 1) goto ucp0I; else goto ccoZN;
       ucp0I: // global
           Sp = Sp + 16;
           call _ccp0E() args: 0, res: 0, upd: 0;
       ccoZN: // global
           I64[Sp - 8] = block_ccoZf_info;
           R4 = R1;
           R3 = System.Environment.setEnv6_closure+1;
           R2 = GHC.Classes.$fEqChar_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccoZf() //  [R1]
         { info_tbl: [(ccoZf,
                       label: block_ccoZf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoZf: // global
           if (R1 & 7 == 1) goto ccoZX; else goto ucp0J;
       ccoZX: // global
           I64[Sp] = block_ccoZj_info;
           R3 = P64[Sp + 16];
           R2 = System.Environment.setEnv11_closure+1;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 8, upd: 8;
       ucp0J: // global
           Sp = Sp + 24;
           call _ccp0E() args: 0, res: 0, upd: 0;
     }
 },
 _ccoZj() //  [R1]
         { info_tbl: [(ccoZj,
                       label: block_ccoZj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoZj: // global
           if (R1 & 7 == 1) goto ccp02; else goto ccp09;
       ccp02: // global
           I64[Sp] = block_ccoZZ_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ccp09: // global
           I64[Sp] = block_ccoZo_info;
           _scosz::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _scosz::P64;
           if (R1 & 7 != 0) goto ucp0M; else goto ccoZp;
       ucp0M: // global
           call _ccoZo(R1) args: 0, res: 0, upd: 0;
       ccoZp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoZZ() //  [R1]
         { info_tbl: [(ccoZZ,
                       label: block_ccoZZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoZZ: // global
           R4 = System.Environment.setEnv4_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccoZo() //  [R1]
         { info_tbl: [(ccoZo,
                       label: block_ccoZo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoZo: // global
           I64[Sp] = block_ccoZt_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccoZt() //  [R1]
         { info_tbl: [(ccoZt,
                       label: block_ccoZt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccoZt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccp0d; else goto ccp0c;
       ccp0d: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccp0c: // global
           I64[Hp - 24] = sat_scosM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccp05_info;
           R3 = Hp - 24;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccp05() //  [R1]
         { info_tbl: [(ccp05,
                       label: block_ccp05_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp05: // global
           I64[Sp] = block_ccp07_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucp0N; else goto ccp0f;
       ucp0N: // global
           call _ccp07(R1) args: 0, res: 0, upd: 0;
       ccp0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp07() //  [R1]
         { info_tbl: [(ccp07,
                       label: block_ccp07_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp07: // global
           (_scosV::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] putenv(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_scosV::I64) == 0 :: W32) goto ccp0x; else goto ccp0r;
       ccp0x: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccp0r: // global
           (_scot0::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _scot0::I64;
           Sp = Sp + 8;
           call System.Environment.setEnv2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccp0E() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp0E: // global
           R1 = System.Environment.setEnv7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.986788089 UTC

[section ""data" . System.Environment.setEnv_closure" {
     System.Environment.setEnv_closure:
         const System.Environment.setEnv_info;
         const 0;
 },
 System.Environment.setEnv_entry() //  [R2, R3]
         { info_tbl: [(ccp0S,
                       label: System.Environment.setEnv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp0S: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.setEnv1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.98763829 UTC

[section ""relreadonly" . Scotk_srt" {
     Scotk_srt:
         const Foreign.C.Error.$wlvl_closure;
         const loc1_rcolZ_closure;
         const System.Environment.setEnv4_closure;
         const System.Environment.setEnv5_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const System.Environment.unsetEnv1_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.IO.Encoding.getFileSystemEncoding1_closure;
         const System.Environment.$wlvl_closure;
         const System.Environment.getEnv3_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const System.Environment.lookupEnv1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl2_rcom2_closure;
         const lvl4_rcom4_closure;
         const System.Environment.getEnv2_closure;
         const System.Environment.getEnv1_closure;
         const System.Environment.getProgName1_closure;
         const System.Environment.getArgs1_closure;
         const GHC.Foreign.withCStringsLen1_closure;
         const System.Environment.withArgs2_closure;
         const System.Environment.withArgs1_closure;
         const System.Environment.withProgName1_closure;
         const System.Environment.getEnvironment1_closure;
         const lvl6_rcom6_closure;
         const System.Environment.setEnv8_closure;
         const GHC.Foreign.newCString1_closure;
         const System.Environment.setEnv1_closure;
         const System.Environment.setEnv2_closure;
         const System.Environment.setEnv7_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.988681622 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:16.989893259 UTC

[section ""cstring" . System.Environment.$trModule4_bytes" {
     System.Environment.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.99197451 UTC

[section ""data" . System.Environment.$trModule3_closure" {
     System.Environment.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.Environment.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.994081231 UTC

[section ""cstring" . System.Environment.$trModule2_bytes" {
     System.Environment.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,69,110,118,105,114,111,110,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.995941854 UTC

[section ""data" . System.Environment.$trModule1_closure" {
     System.Environment.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.Environment.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.997936753 UTC

[section ""data" . System.Environment.$trModule_closure" {
     System.Environment.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.Environment.$trModule3_closure+1;
         const System.Environment.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:16.999884161 UTC

[section ""cstring" . loc_rcolY_bytes" {
     loc_rcolY_bytes:
         I8[] [117,110,115,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.001944981 UTC

[section ""data" . loc1_rcolZ_closure" {
     loc1_rcolZ_closure:
         const loc1_rcolZ_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rcolZ_entry() //  [R1]
         { info_tbl: [(ccp17,
                       label: loc1_rcolZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp17: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccp18; else goto ccp19;
       ccp18: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccp19: // global
           (_ccp14::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccp14::I64 == 0) goto ccp16; else goto ccp15;
       ccp16: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccp15: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccp14::I64;
           R2 = loc_rcolY_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.00645982 UTC

[section ""data" . System.Environment.setEnv5_closure" {
     System.Environment.setEnv5_closure:
         const System.Environment.setEnv5_info;
         const 0;
 },
 System.Environment.setEnv5_entry() //  [R2]
         { info_tbl: [(ccp1n,
                       label: System.Environment.setEnv5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp1n: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = loc1_rcolZ_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.01067914 UTC

[section ""data" . System.Environment.setEnv4_closure" {
     System.Environment.setEnv4_closure:
         const System.Environment.setEnv4_info;
         const 0;
 },
 System.Environment.setEnv4_entry() //  [R2]
         { info_tbl: [(ccp1B,
                       label: System.Environment.setEnv4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp1B: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccp1C; else goto ccp1D;
       ccp1C: // global
           R2 = R2;
           R1 = System.Environment.setEnv4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccp1D: // global
           I64[Sp - 8] = block_ccp1y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucp1Z; else goto ccp1z;
       ucp1Z: // global
           call _ccp1y(R1) args: 0, res: 0, upd: 0;
       ccp1z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp1y() //  [R1]
         { info_tbl: [(ccp1y,
                       label: block_ccp1y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp1y: // global
           (_scomi::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] __hsbase_unsetenv(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_scomi::I64) == 0 :: W32) goto ccp1U; else goto ccp1O;
       ccp1U: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccp1O: // global
           (_scomn::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _scomn::I64;
           Sp = Sp + 8;
           call System.Environment.setEnv5_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.018870948 UTC

[section ""data" . System.Environment.unsetEnv1_closure" {
     System.Environment.unsetEnv1_closure:
         const System.Environment.unsetEnv1_info;
         const 0;
 },
 System.Environment.unsetEnv1_entry() //  [R2]
         { info_tbl: [(ccp2g,
                       label: System.Environment.unsetEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp2g: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccp2h; else goto ccp2i;
       ccp2h: // global
           R2 = R2;
           R1 = System.Environment.unsetEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccp2i: // global
           I64[Sp - 16] = block_ccp2e_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp2e() //  [R1]
         { info_tbl: [(ccp2e,
                       label: block_ccp2e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp2e: // global
           R4 = System.Environment.setEnv4_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.024927864 UTC

[section ""data" . System.Environment.unsetEnv_closure" {
     System.Environment.unsetEnv_closure:
         const System.Environment.unsetEnv_info;
         const 0;
 },
 System.Environment.unsetEnv_entry() //  [R2]
         { info_tbl: [(ccp2w,
                       label: System.Environment.unsetEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp2w: // global
           R2 = R2;
           call System.Environment.unsetEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.028758995 UTC

[section ""data" . lvl_rcom0_closure" {
     lvl_rcom0_closure:
         const lvl_rcom0_info;
 },
 lvl_rcom0_entry() //  [R2, R3]
         { info_tbl: [(ccp2K,
                       label: lvl_rcom0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp2K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccp2O; else goto ccp2P;
       ccp2O: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_rcom0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccp2P: // global
           I64[Sp - 16] = block_ccp2H_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucp33; else goto ccp2I;
       ucp33: // global
           call _ccp2H(R1) args: 0, res: 0, upd: 0;
       ccp2I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp2H() //  [R1]
         { info_tbl: [(ccp2H,
                       label: block_ccp2H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp2H: // global
           I64[Sp] = block_ccp2N_info;
           _scomy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _scomy::I64;
           if (R1 & 7 != 0) goto ucp32; else goto ccp2R;
       ucp32: // global
           call _ccp2N(R1) args: 0, res: 0, upd: 0;
       ccp2R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp2N() //  [R1]
         { info_tbl: [(ccp2N,
                       label: block_ccp2N_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp2N: // global
           call "ccall" arg hints:  [‘signed’,
                                     PtrHint]  result hints:  [] setProgArgv(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.037054522 UTC

[section ""data" . System.Environment.$wlvl_closure" {
     System.Environment.$wlvl_closure:
         const System.Environment.$wlvl_info;
         const 0;
 },
 System.Environment.$wlvl_entry() //  [R2]
         { info_tbl: [(ccp3u,
                       label: System.Environment.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp3u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccp3v; else goto ccp3w;
       ccp3v: // global
           R2 = R2;
           R1 = System.Environment.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccp3w: // global
           (_scomK::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getenv(R2);
           if (_scomK::I64 == 0) goto ccp3t; else goto ccp3s;
       ccp3t: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccp3s: // global
           I64[Sp - 16] = block_ccp3y_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _scomK::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucp3N; else goto ccp3z;
       ucp3N: // global
           call _ccp3y(R1) args: 0, res: 0, upd: 0;
       ccp3z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp3y() //  [R1]
         { info_tbl: [(ccp3y,
                       label: block_ccp3y_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp3y: // global
           I64[Sp] = block_ccp3D_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp3D() //  [R1]
         { info_tbl: [(ccp3D,
                       label: block_ccp3D_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp3D: // global
           _scomK::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_ccp3F_info;
           R3 = _scomK::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccp3F() //  [R1]
         { info_tbl: [(ccp3F,
                       label: block_ccp3F_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp3F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccp3M; else goto ccp3L;
       ccp3M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccp3L: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.047289288 UTC

[section ""data" . System.Environment.getEnv3_closure" {
     System.Environment.getEnv3_closure:
         const System.Environment.getEnv3_info;
         const 0;
 },
 System.Environment.getEnv3_entry() //  [R2]
         { info_tbl: [(ccp4c,
                       label: System.Environment.getEnv3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp4c: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccp4d; else goto ccp4e;
       ccp4d: // global
           R2 = R2;
           R1 = System.Environment.getEnv3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccp4e: // global
           I64[Sp - 8] = block_ccp49_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucp4i; else goto ccp4a;
       ucp4i: // global
           call _ccp49(R1) args: 0, res: 0, upd: 0;
       ccp4a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp49() //  [R1]
         { info_tbl: [(ccp49,
                       label: block_ccp49_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp49: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call System.Environment.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.053016452 UTC

[section ""data" . System.Environment.lookupEnv1_closure" {
     System.Environment.lookupEnv1_closure:
         const System.Environment.lookupEnv1_info;
         const 0;
 },
 System.Environment.lookupEnv1_entry() //  [R2]
         { info_tbl: [(ccp4y,
                       label: System.Environment.lookupEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp4y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccp4z; else goto ccp4A;
       ccp4z: // global
           R2 = R2;
           R1 = System.Environment.lookupEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccp4A: // global
           I64[Sp - 16] = block_ccp4w_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp4w() //  [R1]
         { info_tbl: [(ccp4w,
                       label: block_ccp4w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp4w: // global
           R4 = System.Environment.getEnv3_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.059165149 UTC

[section ""data" . System.Environment.lookupEnv_closure" {
     System.Environment.lookupEnv_closure:
         const System.Environment.lookupEnv_info;
         const 0;
 },
 System.Environment.lookupEnv_entry() //  [R2]
         { info_tbl: [(ccp4O,
                       label: System.Environment.lookupEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp4O: // global
           R2 = R2;
           call System.Environment.lookupEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.062493691 UTC

[section ""cstring" . lvl1_rcom1_bytes" {
     lvl1_rcom1_bytes:
         I8[] [103,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.064449806 UTC

[section ""data" . lvl2_rcom2_closure" {
     lvl2_rcom2_closure:
         const lvl2_rcom2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rcom2_entry() //  [R1]
         { info_tbl: [(ccp52,
                       label: lvl2_rcom2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp52: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccp53; else goto ccp54;
       ccp53: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccp54: // global
           (_ccp4Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccp4Z::I64 == 0) goto ccp51; else goto ccp50;
       ccp51: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccp50: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccp4Z::I64;
           R2 = lvl1_rcom1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.068522632 UTC

[section ""cstring" . lvl3_rcom3_bytes" {
     lvl3_rcom3_bytes:
         I8[] [110,111,32,101,110,118,105,114,111,110,109,101,110,116,32,118,97,114,105,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.070618975 UTC

[section ""data" . lvl4_rcom4_closure" {
     lvl4_rcom4_closure:
         const lvl4_rcom4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rcom4_entry() //  [R1]
         { info_tbl: [(ccp5j,
                       label: lvl4_rcom4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp5j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccp5k; else goto ccp5l;
       ccp5k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccp5l: // global
           (_ccp5g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccp5g::I64 == 0) goto ccp5i; else goto ccp5h;
       ccp5i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccp5h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccp5g::I64;
           R2 = lvl3_rcom3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.074895993 UTC

[section ""data" . System.Environment.getEnv2_closure" {
     System.Environment.getEnv2_closure:
         const System.Environment.getEnv2_info;
         const 0;
 },
 sat_scon9_entry() //  [R1]
         { info_tbl: [(ccp5D,
                       label: sat_scon9_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp5D: // global
           _scon9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccp5E; else goto ccp5F;
       ccp5F: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccp5H; else goto ccp5G;
       ccp5H: // global
           HpAlloc = 72;
           goto ccp5E;
       ccp5E: // global
           R1 = _scon9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccp5G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scon9::P64;
           _scon6::P64 = P64[_scon9::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _scon6::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.NoSuchThing_closure+1;
           P64[Hp - 24] = lvl2_rcom2_closure;
           P64[Hp - 16] = lvl4_rcom4_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getEnv2_entry() //  [R2]
         { info_tbl: [(ccp5I,
                       label: System.Environment.getEnv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp5I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccp5M; else goto ccp5L;
       ccp5M: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = System.Environment.getEnv2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccp5L: // global
           I64[Hp - 16] = sat_scon9_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.081629636 UTC

[section ""data" . System.Environment.getEnv1_closure" {
     System.Environment.getEnv1_closure:
         const System.Environment.getEnv1_info;
         const 0;
 },
 System.Environment.getEnv1_entry() //  [R2]
         { info_tbl: [(ccp6b,
                       label: System.Environment.getEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp6b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccp6c; else goto ccp6d;
       ccp6c: // global
           R2 = R2;
           R1 = System.Environment.getEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccp6d: // global
           I64[Sp - 16] = block_ccp60_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp60() //  [R1]
         { info_tbl: [(ccp60,
                       label: block_ccp60_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp60: // global
           I64[Sp] = block_ccp62_info;
           R4 = System.Environment.getEnv3_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccp62() //  [R1]
         { info_tbl: [(ccp62,
                       label: block_ccp62_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp62: // global
           I64[Sp] = block_ccp64_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucp6m; else goto ccp65;
       ucp6m: // global
           call _ccp64(R1) args: 0, res: 0, upd: 0;
       ccp65: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp64() //  [R1]
         { info_tbl: [(ccp64,
                       label: block_ccp64_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp64: // global
           if (R1 & 7 == 1) goto ccp68; else goto ccp69;
       ccp68: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call System.Environment.getEnv2_entry(R2) args: 8, res: 0, upd: 8;
       ccp69: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.091251077 UTC

[section ""data" . System.Environment.getEnv_closure" {
     System.Environment.getEnv_closure:
         const System.Environment.getEnv_info;
         const 0;
 },
 System.Environment.getEnv_entry() //  [R2]
         { info_tbl: [(ccp6J,
                       label: System.Environment.getEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp6J: // global
           R2 = R2;
           call System.Environment.getEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.095247702 UTC

[section ""data" . System.Environment.getProgName_go_closure" {
     System.Environment.getProgName_go_closure:
         const System.Environment.getProgName_go_info;
 },
 System.Environment.getProgName_go_entry() //  [R2, R3]
         { info_tbl: [(ccp71,
                       label: System.Environment.getProgName_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp71: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccp72; else goto ucp7k;
       ccp72: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.getProgName_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ucp7k: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ccp6R() args: 0, res: 0, upd: 0;
     }
 },
 _ccp6R() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp6R: // global
           I64[Sp - 8] = block_ccp6U_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucp7n; else goto ccp6V;
       ucp7n: // global
           call _ccp6U(R1) args: 0, res: 0, upd: 0;
       ccp6V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp6U() //  [R1]
         { info_tbl: [(ccp6U,
                       label: block_ccp6U_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp6U: // global
           if (R1 & 7 == 1) goto ccp6Y; else goto ccp6Z;
       ccp6Y: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccp6Z: // global
           I64[Sp] = block_ccp79_info;
           _scono::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _scono::P64;
           if (R1 & 7 != 0) goto ucp7o; else goto ccp7b;
       ucp7o: // global
           call _ccp79(R1) args: 0, res: 0, upd: 0;
       ccp7b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp79() //  [R1]
         { info_tbl: [(ccp79,
                       label: block_ccp79_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp79: // global
           _scono::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 47) goto ccp7j; else goto ccp7i;
       ccp7j: // global
           P64[Sp + 8] = _scono::P64;
           P64[Sp + 16] = _scono::P64;
           Sp = Sp + 8;
           goto ucp7r;
       ccp7i: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = _scono::P64;
           Sp = Sp + 8;
           goto ucp7r;
       ucp7r: // global
           call _ccp6R() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.104815164 UTC

[section ""data" . System.Environment.getProgName1_closure" {
     System.Environment.getProgName1_closure:
         const System.Environment.getProgName1_info;
         const 0;
 },
 sat_scoo1_entry() //  [R1]
         { info_tbl: [(ccp8i,
                       label: sat_scoo1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp8i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccp8j; else goto ccp8k;
       ccp8j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccp8k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _sconY::P64 = P64[R1 + 16];
           R3 = _sconY::P64;
           R2 = _sconY::P64;
           Sp = Sp - 16;
           call System.Environment.getProgName_go_entry(R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getProgName1_entry() //  []
         { info_tbl: [(ccp8l,
                       label: System.Environment.getProgName1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp8l: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccp8m; else goto ccp8n;
       ccp8m: // global
           R1 = System.Environment.getProgName1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccp8n: // global
           I64[Sp - 8] = block_ccp7Q_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp7Q() //  [R1]
         { info_tbl: [(ccp7Q,
                       label: block_ccp7Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp7Q: // global
           I64[Sp - 8] = block_ccp7S_info;
           R2 = 8;
           _scony::P64 = R1;
           R1 = 8;
           P64[Sp] = _scony::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp7S() //  [R1]
         { info_tbl: [(ccp7S,
                       label: block_ccp7S_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp7S: // global
           _sconF::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getProgArgv(P64[Sp + 8] + 16, _sconF::I64);
           _sconM::I64 = I64[_sconF::I64];
           I64[Sp - 16] = block_ccp83_info;
           _sconE::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _sconM::I64;
           P64[Sp] = _sconE::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucp8v; else goto ccp84;
       ucp8v: // global
           call _ccp83(R1) args: 0, res: 0, upd: 0;
       ccp84: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp83() //  [R1]
         { info_tbl: [(ccp83,
                       label: block_ccp83_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp83: // global
           I64[Sp] = block_ccp88_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp88() //  [R1]
         { info_tbl: [(ccp88,
                       label: block_ccp88_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp88: // global
           _sconV::I64 = I64[I64[Sp + 8]];
           I64[Sp + 8] = block_ccp8a_info;
           R3 = _sconV::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccp8a() //  [R1]
         { info_tbl: [(ccp8a,
                       label: block_ccp8a_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp8a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccp8u; else goto ccp8t;
       ccp8u: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccp8t: // global
           _scony::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_scony::P64);
           I64[Hp - 16] = sat_scoo1_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.119620355 UTC

[section ""data" . System.Environment.getProgName_closure" {
     System.Environment.getProgName_closure:
         const System.Environment.getProgName_info;
         const 0;
 },
 System.Environment.getProgName_entry() //  []
         { info_tbl: [(ccp93,
                       label: System.Environment.getProgName_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp93: // global
           call System.Environment.getProgName1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.124865732 UTC

[section ""data" . System.Environment.getArgs1_closure" {
     System.Environment.getArgs1_closure:
         const System.Environment.getArgs1_info;
         const 0;
 },
 go_scooA_entry() //  [R1, R2]
         { info_tbl: [(ccpac,
                       label: go_scooA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpac: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccpad; else goto ccpae;
       ccpad: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpae: // global
           I64[Sp - 24] = block_ccpa5_info;
           _scooA::P64 = R1;
           _scoov::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _scoov::P64;
           P64[Sp - 8] = _scooA::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucpaB; else goto ccpa6;
       ucpaB: // global
           call _ccpa5(R1) args: 0, res: 0, upd: 0;
       ccpa6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpa5() //  [R1]
         { info_tbl: [(ccpa5,
                       label: block_ccpa5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpa5: // global
           if (R1 & 7 == 1) goto ccpa9; else goto ccpaa;
       ccpa9: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpaa: // global
           I64[Sp - 8] = block_ccpak_info;
           _scooF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scooF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpaA; else goto ccpal;
       ucpaA: // global
           call _ccpak(R1) args: 0, res: 0, upd: 0;
       ccpal: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpak() //  [R1]
         { info_tbl: [(ccpak,
                       label: block_ccpak_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpak: // global
           I64[Sp] = block_ccpap_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpap() //  [R1]
         { info_tbl: [(ccpap,
                       label: block_ccpap_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpap: // global
           I64[Sp + 16] = block_ccpar_info;
           R2 = P64[Sp + 8];
           _scooK::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _scooK::P64;
           Sp = Sp + 16;
           call go_scooA_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpar() //  [R1]
         { info_tbl: [(ccpar,
                       label: block_ccpar_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpar: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccpaz; else goto ccpay;
       ccpaz: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpay: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.Environment.getArgs1_entry() //  []
         { info_tbl: [(ccpaC,
                       label: System.Environment.getArgs1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpaC: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccpaD; else goto ccpaE;
       ccpaD: // global
           R1 = System.Environment.getArgs1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccpaE: // global
           I64[Sp - 8] = block_ccp9e_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp9e() //  [R1]
         { info_tbl: [(ccp9e,
                       label: block_ccp9e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp9e: // global
           I64[Sp - 8] = block_ccp9g_info;
           R2 = 8;
           _scoo8::P64 = R1;
           R1 = 8;
           P64[Sp] = _scoo8::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp9g() //  [R1]
         { info_tbl: [(ccp9g,
                       label: block_ccp9g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp9g: // global
           _scoof::I64 = P64[Sp + 8] + 16;
           _scoog::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getProgArgv(_scoof::I64, _scoog::I64);
           _scoom::I64 = %MO_SS_Conv_W32_W64(I32[_scoof::I64]);
           _scoop::I64 = I64[_scoog::I64];
           I64[Sp - 24] = block_ccp9r_info;
           _scooe::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 16] = _scoom::I64;
           I64[Sp - 8] = _scoop::I64;
           P64[Sp] = _scooe::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucpbg; else goto ccp9s;
       ucpbg: // global
           call _ccp9r(R1) args: 0, res: 0, upd: 0;
       ccp9s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp9r() //  [R1]
         { info_tbl: [(ccp9r,
                       label: block_ccp9r_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp9r: // global
           I64[Sp] = block_ccp9w_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp9w() //  [R1]
         { info_tbl: [(ccp9w,
                       label: block_ccp9w_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp9w: // global
           _scoow::I64 = I64[Sp + 8] - 1;
           if (%MO_S_Gt_W64(_scoow::I64, 0)) goto ccpb2; else goto ccpb3;
       ccpb2: // global
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _scoow::I64 - 1;
           I64[Sp + 8] = I64[Sp + 16] + 8;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _ccp9Q() args: 0, res: 0, upd: 0;
       ccpb3: // global
           P64[Sp + 16] = R1;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _ccp9Y() args: 0, res: 0, upd: 0;
     }
 },
 _ccp9Q() //  []
         { info_tbl: [(ccp9Q,
                       label: block_ccp9Q_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp9Q: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccpaX; else goto ccpaW;
       ccpaX: // global
           HpAlloc = 40;
           I64[Sp] = block_ccp9Q_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccpaW: // global
           _scop6::P64 = P64[Sp + 8];
           _scop8::I64 = I64[Sp + 16];
           if (_scop8::I64 != 0) goto ccpaZ; else goto ccpb0;
       ccpaZ: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 24] + (_scop8::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scop6::P64;
           I64[Sp + 16] = _scop8::I64 - 1;
           P64[Sp + 8] = Hp - 14;
           call _ccp9Q() args: 0, res: 0, upd: 0;
       ccpb0: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _scop6::P64;
           Sp = Sp + 16;
           call _ccpaQ() args: 0, res: 0, upd: 0;
     }
 },
 _ccpaQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpaQ: // global
           Hp = Hp + 40;
           _scooX::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccpaU; else goto ccpaT;
       ccpaU: // global
           HpAlloc = 40;
           I64[Sp] = block_ccpaP_info;
           R1 = _scooX::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpaT: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 8]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scooX::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           call _ccp9Y() args: 0, res: 0, upd: 0;
     }
 },
 _ccpaP() //  [R1]
         { info_tbl: [(ccpaP,
                       label: block_ccpaP_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpaP: // global
           P64[Sp] = R1;
           call _ccpaQ() args: 0, res: 0, upd: 0;
     }
 },
 _ccp9Y() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp9Y: // global
           Hp = Hp + 16;
           _scooz::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccpaM; else goto ccpaL;
       ccpaM: // global
           HpAlloc = 16;
           I64[Sp] = block_ccp9X_info;
           R1 = _scooz::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpaL: // global
           I64[Hp - 8] = go_scooA_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccpaJ_info;
           R2 = _scooz::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_scooA_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccp9X() //  [R1]
         { info_tbl: [(ccp9X,
                       label: block_ccp9X_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccp9X: // global
           P64[Sp] = R1;
           call _ccp9Y() args: 0, res: 0, upd: 0;
     }
 },
 _ccpaJ() //  [R1]
         { info_tbl: [(ccpaJ,
                       label: block_ccpaJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpaJ: // global
           _scoo8::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_scoo8::P64);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.156099245 UTC

[section ""data" . System.Environment.getArgs_closure" {
     System.Environment.getArgs_closure:
         const System.Environment.getArgs_info;
         const 0;
 },
 System.Environment.getArgs_entry() //  []
         { info_tbl: [(ccpcE,
                       label: System.Environment.getArgs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpcE: // global
           call System.Environment.getArgs1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.162434695 UTC

[section ""data" . System.Environment.withArgs2_closure" {
     System.Environment.withArgs2_closure:
         const System.Environment.withArgs2_info;
         const 0;
 },
 sat_scopM_entry() //  [R1, R2]
         { info_tbl: [(ccpdg,
                       label: sat_scopM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpdg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpdh; else goto ccpdi;
       ccpdh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpdi: // global
           I64[Sp - 24] = block_ccpdc_info;
           _scops::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scops::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpdc() //  [R1]
         { info_tbl: [(ccpdc,
                       label: block_ccpdc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpdc: // global
           _scops::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccpde_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scops::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpde() //  []
         { info_tbl: [(ccpde,
                       label: block_ccpde_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpde: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scopD_entry() //  [R1]
         { info_tbl: [(ccpdq,
                       label: sat_scopD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpdq: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqf_entry() //  [R1, R2]
         { info_tbl: [(ccpdR,
                       label: sat_scoqf_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpdR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpdS; else goto ccpdT;
       ccpdS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpdT: // global
           I64[Sp - 24] = block_ccpdN_info;
           _scops::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scops::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpdN() //  [R1]
         { info_tbl: [(ccpdN,
                       label: block_ccpdN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpdN: // global
           _scops::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccpdP_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scops::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpdP() //  []
         { info_tbl: [(ccpdP,
                       label: block_ccpdP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpdP: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoq6_entry() //  [R1]
         { info_tbl: [(ccpe1,
                       label: sat_scoq6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpe1: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqp_entry() //  [R1]
         { info_tbl: [(ccpe4,
                       label: sat_scoqp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpe4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccpea; else goto ccpeb;
       ccpea: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccpeb: // global
           I64[Sp - 32] = block_ccpdz_info;
           _scopg::P64 = P64[R1 + 7];
           _scoph::P64 = P64[R1 + 15];
           _scops::P64 = P64[R1 + 23];
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp - 24] = _scopg::P64;
           P64[Sp - 16] = _scoph::P64;
           P64[Sp - 8] = _scops::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucpel; else goto ccpdA;
       ucpel: // global
           call _ccpdz(R1) args: 0, res: 0, upd: 0;
       ccpdA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpdz() //  [R1]
         { info_tbl: [(ccpdz,
                       label: block_ccpdz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpdz: // global
           I64[Sp - 8] = block_ccpdE_info;
           _scopY::P64 = P64[R1 + 7];
           R1 = _scopY::P64;
           P64[Sp] = _scopY::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpdE() //  [R1]
         { info_tbl: [(ccpdE,
                       label: block_ccpdE_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpdE: // global
           I64[Sp] = block_ccpdG_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpdG() //  [R1]
         { info_tbl: [(ccpdG,
                       label: block_ccpdG_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpdG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccpeg; else goto ccpef;
       ccpeg: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpef: // global
           I64[Hp - 32] = sat_scoqf_info;
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scoq6_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_ccpe5_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpe5() //  [R1]
         { info_tbl: [(ccpe5,
                       label: block_ccpe5_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpe5: // global
           I64[Sp + 16] = block_ccpe7_info;
           _scoqi::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _scoqi::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpe7() //  [R1]
         { info_tbl: [(ccpe7,
                       label: block_ccpe7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpe7: // global
           I64[Sp] = block_ccpe9_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpe9() //  []
         { info_tbl: [(ccpe9,
                       label: block_ccpe9_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpe9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqI_entry() //  [R1, R2]
         { info_tbl: [(ccpeF,
                       label: sat_scoqI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpeF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpeG; else goto ccpeH;
       ccpeG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpeH: // global
           I64[Sp - 24] = block_ccpeB_info;
           _scops::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scops::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpeB() //  [R1]
         { info_tbl: [(ccpeB,
                       label: block_ccpeB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpeB: // global
           _scops::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccpeD_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scops::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpeD() //  []
         { info_tbl: [(ccpeD,
                       label: block_ccpeD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpeD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scoqz_entry() //  [R1]
         { info_tbl: [(ccpeP,
                       label: sat_scoqz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpeP: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.Environment.withArgs2_entry() //  [R2, R3]
         { info_tbl: [(ccpeW,
                       label: System.Environment.withArgs2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpeW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccpeX; else goto ccpeY;
       ccpeX: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withArgs2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccpeY: // global
           I64[Sp - 24] = block_ccpcP_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getProgName1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccpcP() //  [R1]
         { info_tbl: [(ccpcP,
                       label: block_ccpcP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpcP: // global
           I64[Sp - 8] = block_ccpcR_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call System.Environment.getArgs1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccpcR() //  [R1]
         { info_tbl: [(ccpcR,
                       label: block_ccpcR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpcR: // global
           I64[Sp - 8] = block_ccpcT_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ccpcT() //  [R1]
         { info_tbl: [(ccpcT,
                       label: block_ccpcT_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpcT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccpf3; else goto ccpf2;
       ccpf3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccpf2: // global
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           _ccpcV::P64 = Hp - 46;
           if (R1 == 0) goto ccpeU; else goto ucpfw;
       ccpeU: // global
           I64[Hp - 24] = sat_scoqp_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _ccpcV::P64;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ucpfw: // global
           if (R1 == 1) goto ccpeV; else goto ccpeT;
       ccpeV: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_ccpen_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _ccpcV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucpfy; else goto ccpeo;
       ucpfy: // global
           call _ccpen(R1) args: 0, res: 0, upd: 0;
       ccpeo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccpeT: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_ccpcY_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _ccpcV::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucpfx; else goto ccpcZ;
       ucpfx: // global
           call _ccpcY(R1) args: 0, res: 0, upd: 0;
       ccpcZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpen() //  [R1]
         { info_tbl: [(ccpen,
                       label: block_ccpen_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpen: // global
           I64[Sp - 8] = block_ccpes_info;
           _scoqr::P64 = P64[R1 + 7];
           R1 = _scoqr::P64;
           P64[Sp] = _scoqr::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpes() //  [R1]
         { info_tbl: [(ccpes,
                       label: block_ccpes_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpes: // global
           I64[Sp] = block_ccpeu_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpeu() //  [R1]
         { info_tbl: [(ccpeu,
                       label: block_ccpeu_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpeu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccpfr; else goto ccpfq;
       ccpfr: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpfq: // global
           I64[Hp - 32] = sat_scoqI_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scoqz_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_ccpfi_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpfi() //  [R1]
         { info_tbl: [(ccpfi,
                       label: block_ccpfi_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpfi: // global
           _scoqr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccpfk_info;
           _scoqL::P64 = R1;
           R1 = _scoqr::P64;
           P64[Sp + 32] = _scoqL::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpfk() //  [R1]
         { info_tbl: [(ccpfk,
                       label: block_ccpfk_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpfk: // global
           I64[Sp + 16] = block_ccpfm_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpfm() //  []
         { info_tbl: [(ccpfm,
                       label: block_ccpfm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpfm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccpcY() //  [R1]
         { info_tbl: [(ccpcY,
                       label: block_ccpcY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpcY: // global
           I64[Sp - 8] = block_ccpd3_info;
           _scopv::P64 = P64[R1 + 7];
           R1 = _scopv::P64;
           P64[Sp] = _scopv::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpd3() //  [R1]
         { info_tbl: [(ccpd3,
                       label: block_ccpd3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpd3: // global
           I64[Sp] = block_ccpd5_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpd5() //  [R1]
         { info_tbl: [(ccpd5,
                       label: block_ccpd5_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpd5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccpfd; else goto ccpfc;
       ccpfd: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpfc: // global
           I64[Hp - 32] = sat_scopM_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scopD_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_ccpf4_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpf4() //  [R1]
         { info_tbl: [(ccpf4,
                       label: block_ccpf4_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpf4: // global
           _scopv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccpf6_info;
           _scopP::P64 = R1;
           R1 = _scopv::P64;
           P64[Sp + 32] = _scopP::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpf6() //  [R1]
         { info_tbl: [(ccpf6,
                       label: block_ccpf6_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpf6: // global
           I64[Sp + 16] = block_ccpf8_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpf8() //  []
         { info_tbl: [(ccpf8,
                       label: block_ccpf8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpf8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.231111823 UTC

[section ""data" . System.Environment.withArgs1_closure" {
     System.Environment.withArgs1_closure:
         const System.Environment.withArgs1_info;
         const 0;
 },
 System.Environment.withArgs1_entry() //  [R2, R3]
         { info_tbl: [(ccphM,
                       label: System.Environment.withArgs1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccphM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccphN; else goto ccphO;
       ccphN: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withArgs1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccphO: // global
           I64[Sp - 24] = block_ccphJ_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getProgName1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccphJ() //  [R1]
         { info_tbl: [(ccphJ,
                       label: block_ccphJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccphJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccphR; else goto ccphQ;
       ccphR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccphQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = Hp - 14;
           Sp = Sp + 24;
           call System.Environment.withArgs2_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.237025245 UTC

[section ""data" . System.Environment.withArgs_closure" {
     System.Environment.withArgs_closure:
         const System.Environment.withArgs_info;
         const 0;
 },
 System.Environment.withArgs_entry() //  [R2, R3]
         { info_tbl: [(ccpi5,
                       label: System.Environment.withArgs_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpi5: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.withArgs1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.240681839 UTC

[section ""data" . System.Environment.withProgName1_closure" {
     System.Environment.withProgName1_closure:
         const System.Environment.withProgName1_info;
         const 0;
 },
 System.Environment.withProgName1_entry() //  [R2, R3]
         { info_tbl: [(ccpij,
                       label: System.Environment.withProgName1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpij: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpik; else goto ccpil;
       ccpik: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withProgName1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccpil: // global
           I64[Sp - 24] = block_ccpig_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getArgs1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccpig() //  [R1]
         { info_tbl: [(ccpig,
                       label: block_ccpig_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpig: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccpio; else goto ccpin;
       ccpio: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpin: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R3 = P64[Sp + 16];
           R2 = Hp - 14;
           Sp = Sp + 24;
           call System.Environment.withArgs2_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.246553673 UTC

[section ""data" . System.Environment.withProgName_closure" {
     System.Environment.withProgName_closure:
         const System.Environment.withProgName_info;
         const 0;
 },
 System.Environment.withProgName_entry() //  [R2, R3]
         { info_tbl: [(ccpiC,
                       label: System.Environment.withProgName_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpiC: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.withProgName1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.250880243 UTC

[section ""data" . System.Environment.getEnvironment3_closure" {
     System.Environment.getEnvironment3_closure:
         const System.Environment.getEnvironment3_info;
 },
 System.Environment.getEnvironment3_entry() //  [R2]
         { info_tbl: [(ccpiQ,
                       label: System.Environment.getEnvironment3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpiQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccpiR; else goto ccpiS;
       ccpiR: // global
           R2 = R2;
           R1 = System.Environment.getEnvironment3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpiS: // global
           I64[Sp - 8] = block_ccpiN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpj0; else goto ccpiO;
       ucpj0: // global
           call _ccpiN(R1) args: 0, res: 0, upd: 0;
       ccpiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpiN() //  [R1]
         { info_tbl: [(ccpiN,
                       label: block_ccpiN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpiN: // global
           if (I64[R1 + 7] == 61) goto ccpiZ; else goto ccpiY;
       ccpiZ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpiY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.256943836 UTC

[section ""data" . System.Environment.getEnvironment2_closure" {
     System.Environment.getEnvironment2_closure:
         const System.Environment.getEnvironment2_info;
 },
 System.Environment.getEnvironment2_entry() //  [R2]
         { info_tbl: [(ccpjp,
                       label: System.Environment.getEnvironment2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpjp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpjq; else goto ccpjr;
       ccpjq: // global
           R2 = R2;
           R1 = System.Environment.getEnvironment2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpjr: // global
           I64[Sp - 8] = block_ccpjg_info;
           R3 = R2;
           R2 = System.Environment.getEnvironment3_closure+1;
           Sp = Sp - 8;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpjg() //  [R1, R2]
         { info_tbl: [(ccpjg,
                       label: block_ccpjg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpjg: // global
           I64[Sp - 8] = block_ccpji_info;
           _scorc::P64 = R1;
           R1 = R2;
           P64[Sp] = _scorc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpjF; else goto ccpjj;
       ucpjF: // global
           call _ccpji(R1) args: 0, res: 0, upd: 0;
       ccpjj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpji() //  [R1]
         { info_tbl: [(ccpji,
                       label: block_ccpji_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpji: // global
           _scorc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccpjm; else goto ccpjn;
       ccpjm: // global
           Hp = Hp + 24;
           _score::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccpjE; else goto ccpjx;
       ccpjx: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scorc::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpjn: // global
           Hp = Hp + 24;
           _score::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccpjE; else goto ccpjD;
       ccpjE: // global
           HpAlloc = 24;
           R1 = _score::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpjD: // global
           _scorg::P64 = P64[_score::P64 + 14];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scorc::P64;
           P64[Hp] = _scorg::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.266899322 UTC

[section ""data" . System.Environment.getEnvironment1_closure" {
     System.Environment.getEnvironment1_closure:
         const System.Environment.getEnvironment1_info;
         const 0;
 },
 go_scorz_entry() //  [R1, R2]
         { info_tbl: [(ccpkO,
                       label: go_scorz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpkO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccpkP; else goto ccpkQ;
       ccpkP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpkQ: // global
           I64[Sp - 24] = block_ccpkH_info;
           _scorz::P64 = R1;
           _scors::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _scors::P64;
           P64[Sp - 8] = _scorz::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucpld; else goto ccpkI;
       ucpld: // global
           call _ccpkH(R1) args: 0, res: 0, upd: 0;
       ccpkI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpkH() //  [R1]
         { info_tbl: [(ccpkH,
                       label: block_ccpkH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpkH: // global
           if (R1 & 7 == 1) goto ccpkL; else goto ccpkM;
       ccpkL: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpkM: // global
           I64[Sp - 8] = block_ccpkW_info;
           _scorE::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scorE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucplc; else goto ccpkX;
       ucplc: // global
           call _ccpkW(R1) args: 0, res: 0, upd: 0;
       ccpkX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpkW() //  [R1]
         { info_tbl: [(ccpkW,
                       label: block_ccpkW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpkW: // global
           I64[Sp] = block_ccpl1_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpl1() //  [R1]
         { info_tbl: [(ccpl1,
                       label: block_ccpl1_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpl1: // global
           I64[Sp + 16] = block_ccpl3_info;
           R2 = P64[Sp + 8];
           _scorJ::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _scorJ::P64;
           Sp = Sp + 16;
           call go_scorz_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpl3() //  [R1]
         { info_tbl: [(ccpl3,
                       label: block_ccpl3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpl3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccplb; else goto ccpla;
       ccplb: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpla: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scorR_entry() //  [R1]
         { info_tbl: [(ccplk,
                       label: sat_scorR_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccplk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpll; else goto ccplm;
       ccpll: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccplm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = System.Environment.getEnvironment2_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getEnvironment1_entry() //  []
         { info_tbl: [(ccplq,
                       label: System.Environment.getEnvironment1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccplq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccplr; else goto ccpls;
       ccplr: // global
           R1 = System.Environment.getEnvironment1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccpls: // global
           (_scorl::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] __hscore_environ();
           if (_scorl::I64 == 0) goto ccplp; else goto ccplo;
       ccplp: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccplo: // global
           I64[Sp - 16] = block_ccpk4_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _scorl::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucpmj; else goto ccpk5;
       ucpmj: // global
           call _ccpk4(R1) args: 0, res: 0, upd: 0;
       ccpk5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpk4() //  [R1]
         { info_tbl: [(ccpk4,
                       label: block_ccpk4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpk4: // global
           I64[Sp] = block_ccpk9_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpk9() //  [R1]
         { info_tbl: [(ccpk9,
                       label: block_ccpk9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpk9: // global
           _scorl::I64 = I64[Sp + 8];
           _scors::P64 = R1;
           _scose::I64 = 0;
           goto ccplU;
       ccplU: // global
           if (I64[_scorl::I64 + (_scose::I64 << 3)] == 0) goto ccpm1; else goto ccpm0;
       ccpm1: // global
           if (%MO_S_Gt_W64(_scose::I64, 0)) goto ccplP; else goto ccplQ;
       ccplP: // global
           I64[Sp - 16] = _scose::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           P64[Sp] = _scors::P64;
           Sp = Sp - 24;
           call _ccpks() args: 0, res: 0, upd: 0;
       ccplQ: // global
           P64[Sp] = _scors::P64;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           call _ccpkA() args: 0, res: 0, upd: 0;
       ccpm0: // global
           _scose::I64 = _scose::I64 + 1;
           goto ccplU;
     }
 },
 _ccpks() //  []
         { info_tbl: [(ccpks,
                       label: block_ccpks_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpks: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccplK; else goto ccplJ;
       ccplK: // global
           HpAlloc = 40;
           I64[Sp] = block_ccpks_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccplJ: // global
           _scos3::P64 = P64[Sp + 16];
           _scos5::I64 = I64[Sp + 8];
           if (_scos5::I64 != 0) goto ccplM; else goto ccplN;
       ccplM: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 32] + (_scos5::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scos3::P64;
           I64[Sp + 8] = _scos5::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _ccpks() args: 0, res: 0, upd: 0;
       ccplN: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _scos3::P64;
           Sp = Sp + 16;
           call _ccplD() args: 0, res: 0, upd: 0;
     }
 },
 _ccplD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccplD: // global
           Hp = Hp + 40;
           _scorU::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccplH; else goto ccplG;
       ccplH: // global
           HpAlloc = 40;
           I64[Sp] = block_ccplC_info;
           R1 = _scorU::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccplG: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 16]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scorU::P64;
           P64[Sp + 16] = Hp - 14;
           Sp = Sp + 8;
           call _ccpkA() args: 0, res: 0, upd: 0;
     }
 },
 _ccplC() //  [R1]
         { info_tbl: [(ccplC,
                       label: block_ccplC_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccplC: // global
           P64[Sp] = R1;
           call _ccplD() args: 0, res: 0, upd: 0;
     }
 },
 _ccpkA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpkA: // global
           Hp = Hp + 16;
           _scory::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto ccply; else goto ccplx;
       ccply: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_ccpkz_info;
           R1 = _scory::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccplx: // global
           I64[Hp - 8] = go_scorz_info;
           P64[Hp] = P64[Sp];
           I64[Sp + 8] = block_ccple_info;
           R2 = _scory::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_scorz_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpkz() //  [R1]
         { info_tbl: [(ccpkz,
                       label: block_ccpkz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpkz: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _ccpkA() args: 0, res: 0, upd: 0;
     }
 },
 _ccple() //  [R1]
         { info_tbl: [(ccple,
                       label: block_ccple_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccple: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccplB; else goto ccplA;
       ccplB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccplA: // global
           I64[Hp - 16] = sat_scorR_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.297583398 UTC

[section ""data" . System.Environment.getEnvironment_closure" {
     System.Environment.getEnvironment_closure:
         const System.Environment.getEnvironment_info;
         const 0;
 },
 System.Environment.getEnvironment_entry() //  []
         { info_tbl: [(ccpnw,
                       label: System.Environment.getEnvironment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpnw: // global
           call System.Environment.getEnvironment1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.301187206 UTC

[section ""data" . System.Environment.setEnv11_closure" {
     System.Environment.setEnv11_closure:
         const System.Environment.setEnv11_info;
 },
 System.Environment.setEnv11_entry() //  [R2]
         { info_tbl: [(ccpnK,
                       label: System.Environment.setEnv11_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpnK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccpnL; else goto ccpnM;
       ccpnL: // global
           R2 = R2;
           R1 = System.Environment.setEnv11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpnM: // global
           I64[Sp - 8] = block_ccpnH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpnU; else goto ccpnI;
       ucpnU: // global
           call _ccpnH(R1) args: 0, res: 0, upd: 0;
       ccpnI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpnH() //  [R1]
         { info_tbl: [(ccpnH,
                       label: block_ccpnH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpnH: // global
           if (I64[R1 + 7] == 0) goto ccpnT; else goto ccpnS;
       ccpnT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpnS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.306652271 UTC

[section ""cstring" . lvl5_rcom5_bytes" {
     lvl5_rcom5_bytes:
         I8[] [112,117,116,101,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.308388999 UTC

[section ""data" . lvl6_rcom6_closure" {
     lvl6_rcom6_closure:
         const lvl6_rcom6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rcom6_entry() //  [R1]
         { info_tbl: [(ccpod,
                       label: lvl6_rcom6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpod: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpoe; else goto ccpof;
       ccpoe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpof: // global
           (_ccpoa::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccpoa::I64 == 0) goto ccpoc; else goto ccpob;
       ccpoc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccpob: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccpoa::I64;
           R2 = lvl5_rcom5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.312935393 UTC

[section ""data" . System.Environment.setEnv2_closure" {
     System.Environment.setEnv2_closure:
         const System.Environment.setEnv2_info;
         const 0;
 },
 System.Environment.setEnv2_entry() //  [R2]
         { info_tbl: [(ccpot,
                       label: System.Environment.setEnv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpot: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl6_rcom6_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.316321716 UTC

[section ""cstring" . System.Environment.setEnv10_bytes" {
     System.Environment.setEnv10_bytes:
         I8[] [115,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.318314067 UTC

[section ""data" . System.Environment.setEnv9_closure" {
     System.Environment.setEnv9_closure:
         const System.Environment.setEnv9_info;
         const 0;
         const 0;
         const 0;
 },
 System.Environment.setEnv9_entry() //  [R1]
         { info_tbl: [(ccpoH,
                       label: System.Environment.setEnv9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpoH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpoI; else goto ccpoJ;
       ccpoI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpoJ: // global
           (_ccpoE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccpoE::I64 == 0) goto ccpoG; else goto ccpoF;
       ccpoG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccpoF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccpoE::I64;
           R2 = System.Environment.setEnv10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.322828488 UTC

[section ""data" . System.Environment.setEnv8_closure" {
     System.Environment.setEnv8_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const System.Environment.setEnv9_closure;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.324938565 UTC

[section ""data" . System.Environment.setEnv7_closure" {
     System.Environment.setEnv7_closure:
         const System.Environment.setEnv7_info;
         const 0;
         const 0;
         const 0;
 },
 System.Environment.setEnv7_entry() //  [R1]
         { info_tbl: [(ccpoY,
                       label: System.Environment.setEnv7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpoY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpoZ; else goto ccpp0;
       ccpoZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpp0: // global
           (_ccpoV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccpoV::I64 == 0) goto ccpoX; else goto ccpoW;
       ccpoX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccpoW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccpoV::I64;
           R2 = System.Environment.setEnv8_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.329644048 UTC

[section ""data" . System.Environment.setEnv6_closure" {
     System.Environment.setEnv6_closure:
         const GHC.Types.C#_con_info;
         const 61;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.33129026 UTC

[section ""cstring" . System.Environment.setEnv3_bytes" {
     System.Environment.setEnv3_bytes:
         I8[] [61]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.334664702 UTC

[section ""data" . System.Environment.setEnv1_closure" {
     System.Environment.setEnv1_closure:
         const System.Environment.setEnv1_info;
         const 0;
 },
 sat_scosL_entry() //  [R1]
         { info_tbl: [(ccppH,
                       label: sat_scosL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccppH: // global
           R3 = P64[R1 + 16];
           R2 = System.Environment.setEnv3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scosM_entry() //  [R1]
         { info_tbl: [(ccppK,
                       label: sat_scosM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccppK: // global
           _scosM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccppL; else goto ccppM;
       ccppM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccppO; else goto ccppN;
       ccppO: // global
           HpAlloc = 24;
           goto ccppL;
       ccppL: // global
           R1 = _scosM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccppN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scosM::P64;
           _scosv::P64 = P64[_scosM::P64 + 16];
           _scosz::P64 = P64[_scosM::P64 + 24];
           I64[Hp - 16] = sat_scosL_info;
           P64[Hp] = _scosz::P64;
           R3 = Hp - 16;
           R2 = _scosv::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.setEnv1_entry() //  [R2, R3]
         { info_tbl: [(ccppT,
                       label: System.Environment.setEnv1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccppT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccppU; else goto ccppV;
       ccppU: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.setEnv1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccppV: // global
           I64[Sp - 16] = block_ccppe_info;
           _scost::P64 = R3;
           R3 = R2;
           R2 = System.Environment.setEnv11_closure+1;
           P64[Sp - 8] = _scost::P64;
           Sp = Sp - 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccppe() //  [R1]
         { info_tbl: [(ccppe,
                       label: block_ccppe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccppe: // global
           if (R1 & 7 == 1) goto ucpqM; else goto ccppR;
       ucpqM: // global
           Sp = Sp + 16;
           call _ccpqI() args: 0, res: 0, upd: 0;
       ccppR: // global
           I64[Sp - 8] = block_ccppj_info;
           R4 = R1;
           R3 = System.Environment.setEnv6_closure+1;
           R2 = GHC.Classes.$fEqChar_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccppj() //  [R1]
         { info_tbl: [(ccppj,
                       label: block_ccppj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccppj: // global
           if (R1 & 7 == 1) goto ccpq1; else goto ucpqN;
       ccpq1: // global
           I64[Sp] = block_ccppn_info;
           R3 = P64[Sp + 16];
           R2 = System.Environment.setEnv11_closure+1;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 8, upd: 8;
       ucpqN: // global
           Sp = Sp + 24;
           call _ccpqI() args: 0, res: 0, upd: 0;
     }
 },
 _ccppn() //  [R1]
         { info_tbl: [(ccppn,
                       label: block_ccppn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccppn: // global
           if (R1 & 7 == 1) goto ccpq6; else goto ccpqd;
       ccpq6: // global
           I64[Sp] = block_ccpq3_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ccpqd: // global
           I64[Sp] = block_ccpps_info;
           _scosz::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _scosz::P64;
           if (R1 & 7 != 0) goto ucpqQ; else goto ccppt;
       ucpqQ: // global
           call _ccpps(R1) args: 0, res: 0, upd: 0;
       ccppt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpq3() //  [R1]
         { info_tbl: [(ccpq3,
                       label: block_ccpq3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpq3: // global
           R4 = System.Environment.setEnv4_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccpps() //  [R1]
         { info_tbl: [(ccpps,
                       label: block_ccpps_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpps: // global
           I64[Sp] = block_ccppx_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccppx() //  [R1]
         { info_tbl: [(ccppx,
                       label: block_ccppx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccppx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccpqh; else goto ccpqg;
       ccpqh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpqg: // global
           I64[Hp - 24] = sat_scosM_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccpq9_info;
           R3 = Hp - 24;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpq9() //  [R1]
         { info_tbl: [(ccpq9,
                       label: block_ccpq9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpq9: // global
           I64[Sp] = block_ccpqb_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucpqR; else goto ccpqj;
       ucpqR: // global
           call _ccpqb(R1) args: 0, res: 0, upd: 0;
       ccpqj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpqb() //  [R1]
         { info_tbl: [(ccpqb,
                       label: block_ccpqb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpqb: // global
           (_scosV::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] putenv(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_scosV::I64) == 0 :: W32) goto ccpqB; else goto ccpqv;
       ccpqB: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpqv: // global
           (_scot0::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _scot0::I64;
           Sp = Sp + 8;
           call System.Environment.setEnv2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccpqI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpqI: // global
           R1 = System.Environment.setEnv7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.358474412 UTC

[section ""data" . System.Environment.setEnv_closure" {
     System.Environment.setEnv_closure:
         const System.Environment.setEnv_info;
         const 0;
 },
 System.Environment.setEnv_entry() //  [R2, R3]
         { info_tbl: [(ccprJ,
                       label: System.Environment.setEnv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccprJ: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.setEnv1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:17.362231373 UTC

[section ""relreadonly" . Scotk_srt" {
     Scotk_srt:
         const Foreign.C.Error.$wlvl_closure;
         const loc1_rcolZ_closure;
         const System.Environment.setEnv4_closure;
         const System.Environment.setEnv5_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const System.Environment.unsetEnv1_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.IO.Encoding.getFileSystemEncoding1_closure;
         const System.Environment.$wlvl_closure;
         const System.Environment.getEnv3_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const System.Environment.lookupEnv1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl2_rcom2_closure;
         const lvl4_rcom4_closure;
         const System.Environment.getEnv2_closure;
         const System.Environment.getEnv1_closure;
         const System.Environment.getProgName1_closure;
         const System.Environment.getArgs1_closure;
         const GHC.Foreign.withCStringsLen1_closure;
         const System.Environment.withArgs2_closure;
         const System.Environment.withArgs1_closure;
         const System.Environment.withProgName1_closure;
         const System.Environment.getEnvironment1_closure;
         const lvl6_rcom6_closure;
         const System.Environment.setEnv8_closure;
         const GHC.Foreign.newCString1_closure;
         const System.Environment.setEnv1_closure;
         const System.Environment.setEnv2_closure;
         const System.Environment.setEnv7_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.648169247 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:18.649325948 UTC

[section ""cstring" . System.Environment.$trModule4_bytes" {
     System.Environment.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.651018113 UTC

[section ""data" . System.Environment.$trModule3_closure" {
     System.Environment.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.Environment.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.652730151 UTC

[section ""cstring" . System.Environment.$trModule2_bytes" {
     System.Environment.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,69,110,118,105,114,111,110,109,101,110,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.654536025 UTC

[section ""data" . System.Environment.$trModule1_closure" {
     System.Environment.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.Environment.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.656317364 UTC

[section ""data" . System.Environment.$trModule_closure" {
     System.Environment.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.Environment.$trModule3_closure+1;
         const System.Environment.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.658207594 UTC

[section ""cstring" . loc_rcolY_bytes" {
     loc_rcolY_bytes:
         I8[] [117,110,115,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.660212599 UTC

[section ""data" . loc1_rcolZ_closure" {
     loc1_rcolZ_closure:
         const loc1_rcolZ_info;
         const 0;
         const 0;
         const 0;
 },
 loc1_rcolZ_entry() //  [R1]
         { info_tbl: [(ccpyX,
                       label: loc1_rcolZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpyX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpyY; else goto ccpyZ;
       ccpyY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpyZ: // global
           (_ccpyU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccpyU::I64 == 0) goto ccpyW; else goto ccpyV;
       ccpyW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccpyV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccpyU::I64;
           R2 = loc_rcolY_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.664580817 UTC

[section ""data" . System.Environment.setEnv5_closure" {
     System.Environment.setEnv5_closure:
         const System.Environment.setEnv5_info;
         const 0;
 },
 System.Environment.setEnv5_entry() //  [R2]
         { info_tbl: [(ccpze,
                       label: System.Environment.setEnv5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpze: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = loc1_rcolZ_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.668492778 UTC

[section ""data" . System.Environment.setEnv4_closure" {
     System.Environment.setEnv4_closure:
         const System.Environment.setEnv4_info;
         const 0;
 },
 System.Environment.setEnv4_entry() //  [R2]
         { info_tbl: [(ccpzt,
                       label: System.Environment.setEnv4_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpzt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccpzu; else goto ccpzv;
       ccpzu: // global
           R2 = R2;
           R1 = System.Environment.setEnv4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpzv: // global
           I64[Sp - 8] = block_ccpzq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpzR; else goto ccpzr;
       ucpzR: // global
           call _ccpzq(R1) args: 0, res: 0, upd: 0;
       ccpzr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpzq() //  [R1]
         { info_tbl: [(ccpzq,
                       label: block_ccpzq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpzq: // global
           (_scps1::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] __hsbase_unsetenv(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_scps1::I64) == 0 :: W32) goto ccpzM; else goto ccpzG;
       ccpzM: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpzG: // global
           (_scps6::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _scps6::I64;
           Sp = Sp + 8;
           call System.Environment.setEnv5_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.678489774 UTC

[section ""data" . System.Environment.unsetEnv1_closure" {
     System.Environment.unsetEnv1_closure:
         const System.Environment.unsetEnv1_info;
         const 0;
 },
 System.Environment.unsetEnv1_entry() //  [R2]
         { info_tbl: [(ccpAa,
                       label: System.Environment.unsetEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpAa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpAb; else goto ccpAc;
       ccpAb: // global
           R2 = R2;
           R1 = System.Environment.unsetEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpAc: // global
           I64[Sp - 16] = block_ccpA8_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpA8() //  [R1]
         { info_tbl: [(ccpA8,
                       label: block_ccpA8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpA8: // global
           R4 = System.Environment.setEnv4_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.683865991 UTC

[section ""data" . System.Environment.unsetEnv_closure" {
     System.Environment.unsetEnv_closure:
         const System.Environment.unsetEnv_info;
         const 0;
 },
 System.Environment.unsetEnv_entry() //  [R2]
         { info_tbl: [(ccpAr,
                       label: System.Environment.unsetEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpAr: // global
           R2 = R2;
           call System.Environment.unsetEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.687519322 UTC

[section ""data" . lvl_rcom0_closure" {
     lvl_rcom0_closure:
         const lvl_rcom0_info;
 },
 lvl_rcom0_entry() //  [R2, R3]
         { info_tbl: [(ccpAF,
                       label: lvl_rcom0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpAF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpAJ; else goto ccpAK;
       ccpAJ: // global
           R3 = R3;
           R2 = R2;
           R1 = lvl_rcom0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccpAK: // global
           I64[Sp - 16] = block_ccpAC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucpAY; else goto ccpAD;
       ucpAY: // global
           call _ccpAC(R1) args: 0, res: 0, upd: 0;
       ccpAD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpAC() //  [R1]
         { info_tbl: [(ccpAC,
                       label: block_ccpAC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpAC: // global
           I64[Sp] = block_ccpAI_info;
           _scpsh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _scpsh::I64;
           if (R1 & 7 != 0) goto ucpAX; else goto ccpAM;
       ucpAX: // global
           call _ccpAI(R1) args: 0, res: 0, upd: 0;
       ccpAM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpAI() //  [R1]
         { info_tbl: [(ccpAI,
                       label: block_ccpAI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpAI: // global
           call "ccall" arg hints:  [‘signed’,
                                     PtrHint]  result hints:  [] setProgArgv(%MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[Sp + 8])), I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.695330473 UTC

[section ""data" . System.Environment.$wlvl_closure" {
     System.Environment.$wlvl_closure:
         const System.Environment.$wlvl_info;
         const 0;
 },
 System.Environment.$wlvl_entry() //  [R2]
         { info_tbl: [(ccpBs,
                       label: System.Environment.$wlvl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpBs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpBt; else goto ccpBu;
       ccpBt: // global
           R2 = R2;
           R1 = System.Environment.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpBu: // global
           (_scpst::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] getenv(R2);
           if (_scpst::I64 == 0) goto ccpBr; else goto ccpBq;
       ccpBr: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpBq: // global
           I64[Sp - 16] = block_ccpBw_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _scpst::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucpBL; else goto ccpBx;
       ucpBL: // global
           call _ccpBw(R1) args: 0, res: 0, upd: 0;
       ccpBx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpBw() //  [R1]
         { info_tbl: [(ccpBw,
                       label: block_ccpBw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpBw: // global
           I64[Sp] = block_ccpBB_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpBB() //  [R1]
         { info_tbl: [(ccpBB,
                       label: block_ccpBB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpBB: // global
           _scpst::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_ccpBD_info;
           R3 = _scpst::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpBD() //  [R1]
         { info_tbl: [(ccpBD,
                       label: block_ccpBD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpBD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ccpBK; else goto ccpBJ;
       ccpBK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpBJ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.704661063 UTC

[section ""data" . System.Environment.getEnv3_closure" {
     System.Environment.getEnv3_closure:
         const System.Environment.getEnv3_info;
         const 0;
 },
 System.Environment.getEnv3_entry() //  [R2]
         { info_tbl: [(ccpCf,
                       label: System.Environment.getEnv3_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpCf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccpCg; else goto ccpCh;
       ccpCg: // global
           R2 = R2;
           R1 = System.Environment.getEnv3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpCh: // global
           I64[Sp - 8] = block_ccpCc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpCl; else goto ccpCd;
       ucpCl: // global
           call _ccpCc(R1) args: 0, res: 0, upd: 0;
       ccpCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpCc() //  [R1]
         { info_tbl: [(ccpCc,
                       label: block_ccpCc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpCc: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call System.Environment.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.710143565 UTC

[section ""data" . System.Environment.lookupEnv1_closure" {
     System.Environment.lookupEnv1_closure:
         const System.Environment.lookupEnv1_info;
         const 0;
 },
 System.Environment.lookupEnv1_entry() //  [R2]
         { info_tbl: [(ccpCC,
                       label: System.Environment.lookupEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpCC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpCD; else goto ccpCE;
       ccpCD: // global
           R2 = R2;
           R1 = System.Environment.lookupEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpCE: // global
           I64[Sp - 16] = block_ccpCA_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpCA() //  [R1]
         { info_tbl: [(ccpCA,
                       label: block_ccpCA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpCA: // global
           R4 = System.Environment.getEnv3_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.716635066 UTC

[section ""data" . System.Environment.lookupEnv_closure" {
     System.Environment.lookupEnv_closure:
         const System.Environment.lookupEnv_info;
         const 0;
 },
 System.Environment.lookupEnv_entry() //  [R2]
         { info_tbl: [(ccpCT,
                       label: System.Environment.lookupEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpCT: // global
           R2 = R2;
           call System.Environment.lookupEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.719817966 UTC

[section ""cstring" . lvl1_rcom1_bytes" {
     lvl1_rcom1_bytes:
         I8[] [103,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.72176189 UTC

[section ""data" . lvl2_rcom2_closure" {
     lvl2_rcom2_closure:
         const lvl2_rcom2_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_rcom2_entry() //  [R1]
         { info_tbl: [(ccpD7,
                       label: lvl2_rcom2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpD7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpD8; else goto ccpD9;
       ccpD8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpD9: // global
           (_ccpD4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccpD4::I64 == 0) goto ccpD6; else goto ccpD5;
       ccpD6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccpD5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccpD4::I64;
           R2 = lvl1_rcom1_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.725954814 UTC

[section ""cstring" . lvl3_rcom3_bytes" {
     lvl3_rcom3_bytes:
         I8[] [110,111,32,101,110,118,105,114,111,110,109,101,110,116,32,118,97,114,105,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.72788553 UTC

[section ""data" . lvl4_rcom4_closure" {
     lvl4_rcom4_closure:
         const lvl4_rcom4_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rcom4_entry() //  [R1]
         { info_tbl: [(ccpDp,
                       label: lvl4_rcom4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpDp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpDq; else goto ccpDr;
       ccpDq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpDr: // global
           (_ccpDm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccpDm::I64 == 0) goto ccpDo; else goto ccpDn;
       ccpDo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccpDn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccpDm::I64;
           R2 = lvl3_rcom3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.732120638 UTC

[section ""data" . System.Environment.getEnv2_closure" {
     System.Environment.getEnv2_closure:
         const System.Environment.getEnv2_info;
         const 0;
 },
 sat_scpsS_entry() //  [R1]
         { info_tbl: [(ccpDK,
                       label: sat_scpsS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpDK: // global
           _scpsS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccpDL; else goto ccpDM;
       ccpDM: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccpDO; else goto ccpDN;
       ccpDO: // global
           HpAlloc = 72;
           goto ccpDL;
       ccpDL: // global
           R1 = _scpsS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpDN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scpsS::P64;
           _scpsP::P64 = P64[_scpsS::P64 + 16];
           I64[Hp - 64] = GHC.Base.Just_con_info;
           P64[Hp - 56] = _scpsP::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.NoSuchThing_closure+1;
           P64[Hp - 24] = lvl2_rcom2_closure;
           P64[Hp - 16] = lvl4_rcom4_closure;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = Hp - 62;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getEnv2_entry() //  [R2]
         { info_tbl: [(ccpDP,
                       label: System.Environment.getEnv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpDP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccpDT; else goto ccpDS;
       ccpDT: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = System.Environment.getEnv2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpDS: // global
           I64[Hp - 16] = sat_scpsS_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.739134297 UTC

[section ""data" . System.Environment.getEnv1_closure" {
     System.Environment.getEnv1_closure:
         const System.Environment.getEnv1_info;
         const 0;
 },
 System.Environment.getEnv1_entry() //  [R2]
         { info_tbl: [(ccpEu,
                       label: System.Environment.getEnv1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpEu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpEv; else goto ccpEw;
       ccpEv: // global
           R2 = R2;
           R1 = System.Environment.getEnv1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpEw: // global
           I64[Sp - 16] = block_ccpEj_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpEj() //  [R1]
         { info_tbl: [(ccpEj,
                       label: block_ccpEj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpEj: // global
           I64[Sp] = block_ccpEl_info;
           R4 = System.Environment.getEnv3_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpEl() //  [R1]
         { info_tbl: [(ccpEl,
                       label: block_ccpEl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpEl: // global
           I64[Sp] = block_ccpEn_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucpEF; else goto ccpEo;
       ucpEF: // global
           call _ccpEn(R1) args: 0, res: 0, upd: 0;
       ccpEo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpEn() //  [R1]
         { info_tbl: [(ccpEn,
                       label: block_ccpEn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpEn: // global
           if (R1 & 7 == 1) goto ccpEr; else goto ccpEs;
       ccpEr: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call System.Environment.getEnv2_entry(R2) args: 8, res: 0, upd: 8;
       ccpEs: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.748345479 UTC

[section ""data" . System.Environment.getEnv_closure" {
     System.Environment.getEnv_closure:
         const System.Environment.getEnv_info;
         const 0;
 },
 System.Environment.getEnv_entry() //  [R2]
         { info_tbl: [(ccpF5,
                       label: System.Environment.getEnv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpF5: // global
           R2 = R2;
           call System.Environment.getEnv1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.751976487 UTC

[section ""data" . System.Environment.getProgName_go_closure" {
     System.Environment.getProgName_go_closure:
         const System.Environment.getProgName_go_info;
 },
 System.Environment.getProgName_go_entry() //  [R2, R3]
         { info_tbl: [(ccpFn,
                       label: System.Environment.getProgName_go_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpFn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpFo; else goto ucpFG;
       ccpFo: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.getProgName_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ucpFG: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _ccpFd() args: 0, res: 0, upd: 0;
     }
 },
 _ccpFd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpFd: // global
           I64[Sp - 8] = block_ccpFg_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpFJ; else goto ccpFh;
       ucpFJ: // global
           call _ccpFg(R1) args: 0, res: 0, upd: 0;
       ccpFh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpFg() //  [R1]
         { info_tbl: [(ccpFg,
                       label: block_ccpFg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpFg: // global
           if (R1 & 7 == 1) goto ccpFk; else goto ccpFl;
       ccpFk: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccpFl: // global
           I64[Sp] = block_ccpFv_info;
           _scpt7::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _scpt7::P64;
           if (R1 & 7 != 0) goto ucpFK; else goto ccpFx;
       ucpFK: // global
           call _ccpFv(R1) args: 0, res: 0, upd: 0;
       ccpFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpFv() //  [R1]
         { info_tbl: [(ccpFv,
                       label: block_ccpFv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpFv: // global
           _scpt7::P64 = P64[Sp + 16];
           if (I64[R1 + 7] == 47) goto ccpFF; else goto ccpFE;
       ccpFF: // global
           P64[Sp + 8] = _scpt7::P64;
           P64[Sp + 16] = _scpt7::P64;
           Sp = Sp + 8;
           goto ucpFN;
       ccpFE: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = _scpt7::P64;
           Sp = Sp + 8;
           goto ucpFN;
       ucpFN: // global
           call _ccpFd() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.761105432 UTC

[section ""data" . System.Environment.getProgName1_closure" {
     System.Environment.getProgName1_closure:
         const System.Environment.getProgName1_info;
         const 0;
 },
 sat_scptK_entry() //  [R1]
         { info_tbl: [(ccpGG,
                       label: sat_scptK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpGG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpGH; else goto ccpGI;
       ccpGH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpGI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scptH::P64 = P64[R1 + 16];
           R3 = _scptH::P64;
           R2 = _scptH::P64;
           Sp = Sp - 16;
           call System.Environment.getProgName_go_entry(R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getProgName1_entry() //  []
         { info_tbl: [(ccpGJ,
                       label: System.Environment.getProgName1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpGJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccpGK; else goto ccpGL;
       ccpGK: // global
           R1 = System.Environment.getProgName1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccpGL: // global
           I64[Sp - 8] = block_ccpGe_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpGe() //  [R1]
         { info_tbl: [(ccpGe,
                       label: block_ccpGe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpGe: // global
           I64[Sp - 8] = block_ccpGg_info;
           R2 = 8;
           _scpth::P64 = R1;
           R1 = 8;
           P64[Sp] = _scpth::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpGg() //  [R1]
         { info_tbl: [(ccpGg,
                       label: block_ccpGg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpGg: // global
           _scpto::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getProgArgv(P64[Sp + 8] + 16, _scpto::I64);
           _scptv::I64 = I64[_scpto::I64];
           I64[Sp - 16] = block_ccpGr_info;
           _scptn::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _scptv::I64;
           P64[Sp] = _scptn::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucpGT; else goto ccpGs;
       ucpGT: // global
           call _ccpGr(R1) args: 0, res: 0, upd: 0;
       ccpGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpGr() //  [R1]
         { info_tbl: [(ccpGr,
                       label: block_ccpGr_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpGr: // global
           I64[Sp] = block_ccpGw_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpGw() //  [R1]
         { info_tbl: [(ccpGw,
                       label: block_ccpGw_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpGw: // global
           _scptE::I64 = I64[I64[Sp + 8]];
           I64[Sp + 8] = block_ccpGy_info;
           R3 = _scptE::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpGy() //  [R1]
         { info_tbl: [(ccpGy,
                       label: block_ccpGy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpGy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccpGS; else goto ccpGR;
       ccpGS: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpGR: // global
           _scpth::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_scpth::P64);
           I64[Hp - 16] = sat_scptK_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.775598397 UTC

[section ""data" . System.Environment.getProgName_closure" {
     System.Environment.getProgName_closure:
         const System.Environment.getProgName_info;
         const 0;
 },
 System.Environment.getProgName_entry() //  []
         { info_tbl: [(ccpHy,
                       label: System.Environment.getProgName_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpHy: // global
           call System.Environment.getProgName1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.780654675 UTC

[section ""data" . System.Environment.getArgs1_closure" {
     System.Environment.getArgs1_closure:
         const System.Environment.getArgs1_info;
         const 0;
 },
 go_scpuj_entry() //  [R1, R2]
         { info_tbl: [(ccpIH,
                       label: go_scpuj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpIH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccpII; else goto ccpIJ;
       ccpII: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpIJ: // global
           I64[Sp - 24] = block_ccpIA_info;
           _scpuj::P64 = R1;
           _scpue::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _scpue::P64;
           P64[Sp - 8] = _scpuj::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucpJ6; else goto ccpIB;
       ucpJ6: // global
           call _ccpIA(R1) args: 0, res: 0, upd: 0;
       ccpIB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpIA() //  [R1]
         { info_tbl: [(ccpIA,
                       label: block_ccpIA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpIA: // global
           if (R1 & 7 == 1) goto ccpIE; else goto ccpIF;
       ccpIE: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpIF: // global
           I64[Sp - 8] = block_ccpIP_info;
           _scpuo::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scpuo::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpJ5; else goto ccpIQ;
       ucpJ5: // global
           call _ccpIP(R1) args: 0, res: 0, upd: 0;
       ccpIQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpIP() //  [R1]
         { info_tbl: [(ccpIP,
                       label: block_ccpIP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpIP: // global
           I64[Sp] = block_ccpIU_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpIU() //  [R1]
         { info_tbl: [(ccpIU,
                       label: block_ccpIU_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpIU: // global
           I64[Sp + 16] = block_ccpIW_info;
           R2 = P64[Sp + 8];
           _scput::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _scput::P64;
           Sp = Sp + 16;
           call go_scpuj_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpIW() //  [R1]
         { info_tbl: [(ccpIW,
                       label: block_ccpIW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpIW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccpJ4; else goto ccpJ3;
       ccpJ4: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpJ3: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.Environment.getArgs1_entry() //  []
         { info_tbl: [(ccpJ7,
                       label: System.Environment.getArgs1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpJ7: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ccpJ8; else goto ccpJ9;
       ccpJ8: // global
           R1 = System.Environment.getArgs1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccpJ9: // global
           I64[Sp - 8] = block_ccpHJ_info;
           R2 = 4;
           R1 = 4;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpHJ() //  [R1]
         { info_tbl: [(ccpHJ,
                       label: block_ccpHJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpHJ: // global
           I64[Sp - 8] = block_ccpHL_info;
           R2 = 8;
           _scptR::P64 = R1;
           R1 = 8;
           P64[Sp] = _scptR::P64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpHL() //  [R1]
         { info_tbl: [(ccpHL,
                       label: block_ccpHL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpHL: // global
           _scptY::I64 = P64[Sp + 8] + 16;
           _scptZ::I64 = R1 + 16;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] getProgArgv(_scptY::I64, _scptZ::I64);
           _scpu5::I64 = %MO_SS_Conv_W32_W64(I32[_scptY::I64]);
           _scpu8::I64 = I64[_scptZ::I64];
           I64[Sp - 24] = block_ccpHW_info;
           _scptX::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 16] = _scpu5::I64;
           I64[Sp - 8] = _scpu8::I64;
           P64[Sp] = _scptX::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucpJL; else goto ccpHX;
       ucpJL: // global
           call _ccpHW(R1) args: 0, res: 0, upd: 0;
       ccpHX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpHW() //  [R1]
         { info_tbl: [(ccpHW,
                       label: block_ccpHW_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpHW: // global
           I64[Sp] = block_ccpI1_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpI1() //  [R1]
         { info_tbl: [(ccpI1,
                       label: block_ccpI1_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpI1: // global
           _scpuf::I64 = I64[Sp + 8] - 1;
           if (%MO_S_Gt_W64(_scpuf::I64, 0)) goto ccpJx; else goto ccpJy;
       ccpJx: // global
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = _scpuf::I64 - 1;
           I64[Sp + 8] = I64[Sp + 16] + 8;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _ccpIl() args: 0, res: 0, upd: 0;
       ccpJy: // global
           P64[Sp + 16] = R1;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call _ccpIt() args: 0, res: 0, upd: 0;
     }
 },
 _ccpIl() //  []
         { info_tbl: [(ccpIl,
                       label: block_ccpIl_info
                       rep:StackRep [False, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpIl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccpJs; else goto ccpJr;
       ccpJs: // global
           HpAlloc = 40;
           I64[Sp] = block_ccpIl_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccpJr: // global
           _scpuP::P64 = P64[Sp + 8];
           _scpuR::I64 = I64[Sp + 16];
           if (_scpuR::I64 != 0) goto ccpJu; else goto ccpJv;
       ccpJu: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 24] + (_scpuR::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scpuP::P64;
           I64[Sp + 16] = _scpuR::I64 - 1;
           P64[Sp + 8] = Hp - 14;
           call _ccpIl() args: 0, res: 0, upd: 0;
       ccpJv: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _scpuP::P64;
           Sp = Sp + 16;
           call _ccpJl() args: 0, res: 0, upd: 0;
     }
 },
 _ccpJl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpJl: // global
           Hp = Hp + 40;
           _scpuG::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccpJp; else goto ccpJo;
       ccpJp: // global
           HpAlloc = 40;
           I64[Sp] = block_ccpJk_info;
           R1 = _scpuG::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpJo: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 8]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scpuG::P64;
           P64[Sp + 8] = Hp - 14;
           Sp = Sp + 8;
           call _ccpIt() args: 0, res: 0, upd: 0;
     }
 },
 _ccpJk() //  [R1]
         { info_tbl: [(ccpJk,
                       label: block_ccpJk_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpJk: // global
           P64[Sp] = R1;
           call _ccpJl() args: 0, res: 0, upd: 0;
     }
 },
 _ccpIt() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpIt: // global
           Hp = Hp + 16;
           _scpui::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccpJh; else goto ccpJg;
       ccpJh: // global
           HpAlloc = 16;
           I64[Sp] = block_ccpIs_info;
           R1 = _scpui::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpJg: // global
           I64[Hp - 8] = go_scpuj_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = block_ccpJe_info;
           R2 = _scpui::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_scpuj_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpIs() //  [R1]
         { info_tbl: [(ccpIs,
                       label: block_ccpIs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpIs: // global
           P64[Sp] = R1;
           call _ccpIt() args: 0, res: 0, upd: 0;
     }
 },
 _ccpJe() //  [R1]
         { info_tbl: [(ccpJe,
                       label: block_ccpJe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpJe: // global
           _scptR::P64 = P64[Sp + 16];
           call MO_Touch(P64[Sp + 8]);
           call MO_Touch(_scptR::P64);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.811206784 UTC

[section ""data" . System.Environment.getArgs_closure" {
     System.Environment.getArgs_closure:
         const System.Environment.getArgs_info;
         const 0;
 },
 System.Environment.getArgs_entry() //  []
         { info_tbl: [(ccpLw,
                       label: System.Environment.getArgs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpLw: // global
           call System.Environment.getArgs1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.817050235 UTC

[section ""data" . System.Environment.withArgs2_closure" {
     System.Environment.withArgs2_closure:
         const System.Environment.withArgs2_info;
         const 0;
 },
 sat_scpvv_entry() //  [R1, R2]
         { info_tbl: [(ccpM8,
                       label: sat_scpvv_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpM8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpM9; else goto ccpMa;
       ccpM9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpMa: // global
           I64[Sp - 24] = block_ccpM4_info;
           _scpvb::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scpvb::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpM4() //  [R1]
         { info_tbl: [(ccpM4,
                       label: block_ccpM4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpM4: // global
           _scpvb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccpM6_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scpvb::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpM6() //  []
         { info_tbl: [(ccpM6,
                       label: block_ccpM6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpM6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scpvm_entry() //  [R1]
         { info_tbl: [(ccpMi,
                       label: sat_scpvm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMi: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scpvY_entry() //  [R1, R2]
         { info_tbl: [(ccpMJ,
                       label: sat_scpvY_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpMK; else goto ccpML;
       ccpMK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpML: // global
           I64[Sp - 24] = block_ccpMF_info;
           _scpvb::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scpvb::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpMF() //  [R1]
         { info_tbl: [(ccpMF,
                       label: block_ccpMF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMF: // global
           _scpvb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccpMH_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scpvb::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpMH() //  []
         { info_tbl: [(ccpMH,
                       label: block_ccpMH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scpvP_entry() //  [R1]
         { info_tbl: [(ccpMT,
                       label: sat_scpvP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMT: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scpw8_entry() //  [R1]
         { info_tbl: [(ccpMW,
                       label: sat_scpw8_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccpN2; else goto ccpN3;
       ccpN2: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccpN3: // global
           I64[Sp - 32] = block_ccpMr_info;
           _scpuZ::P64 = P64[R1 + 7];
           _scpv0::P64 = P64[R1 + 15];
           _scpvb::P64 = P64[R1 + 23];
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp - 24] = _scpuZ::P64;
           P64[Sp - 16] = _scpv0::P64;
           P64[Sp - 8] = _scpvb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ucpNd; else goto ccpMs;
       ucpNd: // global
           call _ccpMr(R1) args: 0, res: 0, upd: 0;
       ccpMs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpMr() //  [R1]
         { info_tbl: [(ccpMr,
                       label: block_ccpMr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMr: // global
           I64[Sp - 8] = block_ccpMw_info;
           _scpvH::P64 = P64[R1 + 7];
           R1 = _scpvH::P64;
           P64[Sp] = _scpvH::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpMw() //  [R1]
         { info_tbl: [(ccpMw,
                       label: block_ccpMw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMw: // global
           I64[Sp] = block_ccpMy_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpMy() //  [R1]
         { info_tbl: [(ccpMy,
                       label: block_ccpMy_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccpN8; else goto ccpN7;
       ccpN8: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpN7: // global
           I64[Hp - 32] = sat_scpvY_info;
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scpvP_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_ccpMX_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpMX() //  [R1]
         { info_tbl: [(ccpMX,
                       label: block_ccpMX_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMX: // global
           I64[Sp + 16] = block_ccpMZ_info;
           _scpw1::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 24] = _scpw1::P64;
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpMZ() //  [R1]
         { info_tbl: [(ccpMZ,
                       label: block_ccpMZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpMZ: // global
           I64[Sp] = block_ccpN1_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpN1() //  []
         { info_tbl: [(ccpN1,
                       label: block_ccpN1_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpN1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scpwr_entry() //  [R1, R2]
         { info_tbl: [(ccpNx,
                       label: sat_scpwr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpNx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpNy; else goto ccpNz;
       ccpNy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpNz: // global
           I64[Sp - 24] = block_ccpNt_info;
           _scpvb::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp - 16] = _scpvb::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpNt() //  [R1]
         { info_tbl: [(ccpNt,
                       label: block_ccpNt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpNt: // global
           _scpvb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccpNv_info;
           R4 = lvl_rcom0_closure+3;
           R3 = _scpvb::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpNv() //  []
         { info_tbl: [(ccpNv,
                       label: block_ccpNv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpNv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scpwi_entry() //  [R1]
         { info_tbl: [(ccpNH,
                       label: sat_scpwi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpNH: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.Environment.withArgs2_entry() //  [R2, R3]
         { info_tbl: [(ccpNO,
                       label: System.Environment.withArgs2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpNO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccpNP; else goto ccpNQ;
       ccpNP: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withArgs2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccpNQ: // global
           I64[Sp - 24] = block_ccpLH_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getProgName1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccpLH() //  [R1]
         { info_tbl: [(ccpLH,
                       label: block_ccpLH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpLH: // global
           I64[Sp - 8] = block_ccpLJ_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call System.Environment.getArgs1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccpLJ() //  [R1]
         { info_tbl: [(ccpLJ,
                       label: block_ccpLJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpLJ: // global
           I64[Sp - 8] = block_ccpLL_info;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _ccpLL() //  [R1]
         { info_tbl: [(ccpLL,
                       label: block_ccpLL_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpLL: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ccpNV; else goto ccpNU;
       ccpNV: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccpNU: // global
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 8];
           _ccpLN::P64 = Hp - 46;
           if (R1 == 0) goto ccpNM; else goto ucpOo;
       ccpNM: // global
           I64[Hp - 24] = sat_scpw8_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _ccpLN::P64;
           R1 = Hp - 23;
           Sp = Sp + 40;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ucpOo: // global
           if (R1 == 1) goto ccpNN; else goto ccpNL;
       ccpNN: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_ccpNf_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _ccpLN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucpOq; else goto ccpNg;
       ucpOq: // global
           call _ccpNf(R1) args: 0, res: 0, upd: 0;
       ccpNg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccpNL: // global
           Hp = Hp - 32;
           I64[Sp + 8] = block_ccpLQ_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _ccpLN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucpOp; else goto ccpLR;
       ucpOp: // global
           call _ccpLQ(R1) args: 0, res: 0, upd: 0;
       ccpLR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpNf() //  [R1]
         { info_tbl: [(ccpNf,
                       label: block_ccpNf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpNf: // global
           I64[Sp - 8] = block_ccpNk_info;
           _scpwa::P64 = P64[R1 + 7];
           R1 = _scpwa::P64;
           P64[Sp] = _scpwa::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpNk() //  [R1]
         { info_tbl: [(ccpNk,
                       label: block_ccpNk_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpNk: // global
           I64[Sp] = block_ccpNm_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpNm() //  [R1]
         { info_tbl: [(ccpNm,
                       label: block_ccpNm_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpNm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccpOj; else goto ccpOi;
       ccpOj: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpOi: // global
           I64[Hp - 32] = sat_scpwr_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scpwi_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_ccpOa_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpOa() //  [R1]
         { info_tbl: [(ccpOa,
                       label: block_ccpOa_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpOa: // global
           _scpwa::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccpOc_info;
           _scpwu::P64 = R1;
           R1 = _scpwa::P64;
           P64[Sp + 32] = _scpwu::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpOc() //  [R1]
         { info_tbl: [(ccpOc,
                       label: block_ccpOc_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpOc: // global
           I64[Sp + 16] = block_ccpOe_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpOe() //  []
         { info_tbl: [(ccpOe,
                       label: block_ccpOe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpOe: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccpLQ() //  [R1]
         { info_tbl: [(ccpLQ,
                       label: block_ccpLQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpLQ: // global
           I64[Sp - 8] = block_ccpLV_info;
           _scpve::P64 = P64[R1 + 7];
           R1 = _scpve::P64;
           P64[Sp] = _scpve::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpLV() //  [R1]
         { info_tbl: [(ccpLV,
                       label: block_ccpLV_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpLV: // global
           I64[Sp] = block_ccpLX_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpLX() //  [R1]
         { info_tbl: [(ccpLX,
                       label: block_ccpLX_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpLX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccpO5; else goto ccpO4;
       ccpO5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpO4: // global
           I64[Hp - 32] = sat_scpvv_info;
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = sat_scpvm_info;
           P64[Hp] = P64[Sp + 32];
           I64[Sp] = block_ccpNW_info;
           R2 = Hp - 30;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpNW() //  [R1]
         { info_tbl: [(ccpNW,
                       label: block_ccpNW_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpNW: // global
           _scpve::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccpNY_info;
           _scpvy::P64 = R1;
           R1 = _scpve::P64;
           P64[Sp + 32] = _scpvy::P64;
           Sp = Sp + 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpNY() //  [R1]
         { info_tbl: [(ccpNY,
                       label: block_ccpNY_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpNY: // global
           I64[Sp + 16] = block_ccpO0_info;
           R4 = lvl_rcom0_closure+3;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.withCStringsLen1_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpO0() //  []
         { info_tbl: [(ccpO0,
                       label: block_ccpO0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpO0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.884172127 UTC

[section ""data" . System.Environment.withArgs1_closure" {
     System.Environment.withArgs1_closure:
         const System.Environment.withArgs1_info;
         const 0;
 },
 System.Environment.withArgs1_entry() //  [R2, R3]
         { info_tbl: [(ccpRd,
                       label: System.Environment.withArgs1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpRd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpRe; else goto ccpRf;
       ccpRe: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withArgs1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccpRf: // global
           I64[Sp - 24] = block_ccpRa_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getProgName1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccpRa() //  [R1]
         { info_tbl: [(ccpRa,
                       label: block_ccpRa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpRa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccpRi; else goto ccpRh;
       ccpRi: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpRh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R3 = P64[Sp + 16];
           R2 = Hp - 14;
           Sp = Sp + 24;
           call System.Environment.withArgs2_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.890390245 UTC

[section ""data" . System.Environment.withArgs_closure" {
     System.Environment.withArgs_closure:
         const System.Environment.withArgs_info;
         const 0;
 },
 System.Environment.withArgs_entry() //  [R2, R3]
         { info_tbl: [(ccpRy,
                       label: System.Environment.withArgs_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpRy: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.withArgs1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.893968586 UTC

[section ""data" . System.Environment.withProgName1_closure" {
     System.Environment.withProgName1_closure:
         const System.Environment.withProgName1_info;
         const 0;
 },
 System.Environment.withProgName1_entry() //  [R2, R3]
         { info_tbl: [(ccpRM,
                       label: System.Environment.withProgName1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpRM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccpRN; else goto ccpRO;
       ccpRN: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.withProgName1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccpRO: // global
           I64[Sp - 24] = block_ccpRJ_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call System.Environment.getArgs1_entry() args: 8, res: 8, upd: 8;
     }
 },
 _ccpRJ() //  [R1]
         { info_tbl: [(ccpRJ,
                       label: block_ccpRJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpRJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccpRR; else goto ccpRQ;
       ccpRR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpRQ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R3 = P64[Sp + 16];
           R2 = Hp - 14;
           Sp = Sp + 24;
           call System.Environment.withArgs2_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.899707973 UTC

[section ""data" . System.Environment.withProgName_closure" {
     System.Environment.withProgName_closure:
         const System.Environment.withProgName_info;
         const 0;
 },
 System.Environment.withProgName_entry() //  [R2, R3]
         { info_tbl: [(ccpS7,
                       label: System.Environment.withProgName_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpS7: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.withProgName1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.904378921 UTC

[section ""data" . System.Environment.getEnvironment3_closure" {
     System.Environment.getEnvironment3_closure:
         const System.Environment.getEnvironment3_info;
 },
 System.Environment.getEnvironment3_entry() //  [R2]
         { info_tbl: [(ccpSl,
                       label: System.Environment.getEnvironment3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpSl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccpSm; else goto ccpSn;
       ccpSm: // global
           R2 = R2;
           R1 = System.Environment.getEnvironment3_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpSn: // global
           I64[Sp - 8] = block_ccpSi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpSv; else goto ccpSj;
       ucpSv: // global
           call _ccpSi(R1) args: 0, res: 0, upd: 0;
       ccpSj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpSi() //  [R1]
         { info_tbl: [(ccpSi,
                       label: block_ccpSi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpSi: // global
           if (I64[R1 + 7] == 61) goto ccpSu; else goto ccpSt;
       ccpSu: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpSt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.910786735 UTC

[section ""data" . System.Environment.getEnvironment2_closure" {
     System.Environment.getEnvironment2_closure:
         const System.Environment.getEnvironment2_info;
 },
 System.Environment.getEnvironment2_entry() //  [R2]
         { info_tbl: [(ccpSX,
                       label: System.Environment.getEnvironment2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpSX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpSY; else goto ccpSZ;
       ccpSY: // global
           R2 = R2;
           R1 = System.Environment.getEnvironment2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpSZ: // global
           I64[Sp - 8] = block_ccpSO_info;
           R3 = R2;
           R2 = System.Environment.getEnvironment3_closure+1;
           Sp = Sp - 8;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpSO() //  [R1, R2]
         { info_tbl: [(ccpSO,
                       label: block_ccpSO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpSO: // global
           I64[Sp - 8] = block_ccpSQ_info;
           _scpwV::P64 = R1;
           R1 = R2;
           P64[Sp] = _scpwV::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpTd; else goto ccpSR;
       ucpTd: // global
           call _ccpSQ(R1) args: 0, res: 0, upd: 0;
       ccpSR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpSQ() //  [R1]
         { info_tbl: [(ccpSQ,
                       label: block_ccpSQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpSQ: // global
           _scpwV::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccpSU; else goto ccpSV;
       ccpSU: // global
           Hp = Hp + 24;
           _scpwX::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccpTc; else goto ccpT5;
       ccpT5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scpwV::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpSV: // global
           Hp = Hp + 24;
           _scpwX::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccpTc; else goto ccpTb;
       ccpTc: // global
           HpAlloc = 24;
           R1 = _scpwX::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpTb: // global
           _scpwZ::P64 = P64[_scpwX::P64 + 14];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _scpwV::P64;
           P64[Hp] = _scpwZ::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.92104999 UTC

[section ""data" . System.Environment.getEnvironment1_closure" {
     System.Environment.getEnvironment1_closure:
         const System.Environment.getEnvironment1_info;
         const 0;
 },
 go_scpxi_entry() //  [R1, R2]
         { info_tbl: [(ccpUs,
                       label: go_scpxi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpUs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ccpUt; else goto ccpUu;
       ccpUt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpUu: // global
           I64[Sp - 24] = block_ccpUl_info;
           _scpxi::P64 = R1;
           _scpxb::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _scpxb::P64;
           P64[Sp - 8] = _scpxi::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucpUR; else goto ccpUm;
       ucpUR: // global
           call _ccpUl(R1) args: 0, res: 0, upd: 0;
       ccpUm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpUl() //  [R1]
         { info_tbl: [(ccpUl,
                       label: block_ccpUl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpUl: // global
           if (R1 & 7 == 1) goto ccpUp; else goto ccpUq;
       ccpUp: // global
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpUq: // global
           I64[Sp - 8] = block_ccpUA_info;
           _scpxn::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _scpxn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpUQ; else goto ccpUB;
       ucpUQ: // global
           call _ccpUA(R1) args: 0, res: 0, upd: 0;
       ccpUB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpUA() //  [R1]
         { info_tbl: [(ccpUA,
                       label: block_ccpUA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpUA: // global
           I64[Sp] = block_ccpUF_info;
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 16];
           call GHC.Foreign.$wpeekCString_entry(R3,
                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpUF() //  [R1]
         { info_tbl: [(ccpUF,
                       label: block_ccpUF_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpUF: // global
           I64[Sp + 16] = block_ccpUH_info;
           R2 = P64[Sp + 8];
           _scpxs::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _scpxs::P64;
           Sp = Sp + 16;
           call go_scpxi_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpUH() //  [R1]
         { info_tbl: [(ccpUH,
                       label: block_ccpUH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpUH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccpUP; else goto ccpUO;
       ccpUP: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpUO: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_scpxA_entry() //  [R1]
         { info_tbl: [(ccpUY,
                       label: sat_scpxA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpUY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpUZ; else goto ccpV0;
       ccpUZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpV0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = System.Environment.getEnvironment2_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.getEnvironment1_entry() //  []
         { info_tbl: [(ccpV4,
                       label: System.Environment.getEnvironment1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpV4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccpV5; else goto ccpV6;
       ccpV5: // global
           R1 = System.Environment.getEnvironment1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccpV6: // global
           (_scpx4::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] __hscore_environ();
           if (_scpx4::I64 == 0) goto ccpV3; else goto ccpV2;
       ccpV3: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpV2: // global
           I64[Sp - 16] = block_ccpTI_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           I64[Sp - 8] = _scpx4::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucpVX; else goto ccpTJ;
       ucpVX: // global
           call _ccpTI(R1) args: 0, res: 0, upd: 0;
       ccpTJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpTI() //  [R1]
         { info_tbl: [(ccpTI,
                       label: block_ccpTI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpTI: // global
           I64[Sp] = block_ccpTN_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpTN() //  [R1]
         { info_tbl: [(ccpTN,
                       label: block_ccpTN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpTN: // global
           _scpx4::I64 = I64[Sp + 8];
           _scpxb::P64 = R1;
           _scpxX::I64 = 0;
           goto ccpVy;
       ccpVy: // global
           if (I64[_scpx4::I64 + (_scpxX::I64 << 3)] == 0) goto ccpVF; else goto ccpVE;
       ccpVF: // global
           if (%MO_S_Gt_W64(_scpxX::I64, 0)) goto ccpVt; else goto ccpVu;
       ccpVt: // global
           I64[Sp - 16] = _scpxX::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           P64[Sp] = _scpxb::P64;
           Sp = Sp - 24;
           call _ccpU6() args: 0, res: 0, upd: 0;
       ccpVu: // global
           P64[Sp] = _scpxb::P64;
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           call _ccpUe() args: 0, res: 0, upd: 0;
       ccpVE: // global
           _scpxX::I64 = _scpxX::I64 + 1;
           goto ccpVy;
     }
 },
 _ccpU6() //  []
         { info_tbl: [(ccpU6,
                       label: block_ccpU6_info
                       rep:StackRep [True, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpU6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ccpVo; else goto ccpVn;
       ccpVo: // global
           HpAlloc = 40;
           I64[Sp] = block_ccpU6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ccpVn: // global
           _scpxM::P64 = P64[Sp + 16];
           _scpxO::I64 = I64[Sp + 8];
           if (_scpxO::I64 != 0) goto ccpVq; else goto ccpVr;
       ccpVq: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 32] + (_scpxO::I64 << 3)];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scpxM::P64;
           I64[Sp + 8] = _scpxO::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _ccpU6() args: 0, res: 0, upd: 0;
       ccpVr: // global
           Hp = Hp - 40;
           P64[Sp + 16] = _scpxM::P64;
           Sp = Sp + 16;
           call _ccpVh() args: 0, res: 0, upd: 0;
     }
 },
 _ccpVh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpVh: // global
           Hp = Hp + 40;
           _scpxD::P64 = P64[Sp];
           if (Hp > HpLim) (likely: False) goto ccpVl; else goto ccpVk;
       ccpVl: // global
           HpAlloc = 40;
           I64[Sp] = block_ccpVg_info;
           R1 = _scpxD::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpVk: // global
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[I64[Sp + 16]];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _scpxD::P64;
           P64[Sp + 16] = Hp - 14;
           Sp = Sp + 8;
           call _ccpUe() args: 0, res: 0, upd: 0;
     }
 },
 _ccpVg() //  [R1]
         { info_tbl: [(ccpVg,
                       label: block_ccpVg_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpVg: // global
           P64[Sp] = R1;
           call _ccpVh() args: 0, res: 0, upd: 0;
     }
 },
 _ccpUe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpUe: // global
           Hp = Hp + 16;
           _scpxh::P64 = P64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto ccpVc; else goto ccpVb;
       ccpVc: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_ccpUd_info;
           R1 = _scpxh::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpVb: // global
           I64[Hp - 8] = go_scpxi_info;
           P64[Hp] = P64[Sp];
           I64[Sp + 8] = block_ccpUS_info;
           R2 = _scpxh::P64;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call go_scpxi_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpUd() //  [R1]
         { info_tbl: [(ccpUd,
                       label: block_ccpUd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpUd: // global
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _ccpUe() args: 0, res: 0, upd: 0;
     }
 },
 _ccpUS() //  [R1]
         { info_tbl: [(ccpUS,
                       label: block_ccpUS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpUS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccpVf; else goto ccpVe;
       ccpVf: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccpVe: // global
           I64[Hp - 16] = sat_scpxA_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.950524541 UTC

[section ""data" . System.Environment.getEnvironment_closure" {
     System.Environment.getEnvironment_closure:
         const System.Environment.getEnvironment_info;
         const 0;
 },
 System.Environment.getEnvironment_entry() //  []
         { info_tbl: [(ccpXy,
                       label: System.Environment.getEnvironment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpXy: // global
           call System.Environment.getEnvironment1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.953977405 UTC

[section ""data" . System.Environment.setEnv11_closure" {
     System.Environment.setEnv11_closure:
         const System.Environment.setEnv11_info;
 },
 System.Environment.setEnv11_entry() //  [R2]
         { info_tbl: [(ccpXM,
                       label: System.Environment.setEnv11_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpXM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccpXN; else goto ccpXO;
       ccpXN: // global
           R2 = R2;
           R1 = System.Environment.setEnv11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccpXO: // global
           I64[Sp - 8] = block_ccpXJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucpXW; else goto ccpXK;
       ucpXW: // global
           call _ccpXJ(R1) args: 0, res: 0, upd: 0;
       ccpXK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpXJ() //  [R1]
         { info_tbl: [(ccpXJ,
                       label: block_ccpXJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpXJ: // global
           if (I64[R1 + 7] == 0) goto ccpXV; else goto ccpXU;
       ccpXV: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccpXU: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.959282884 UTC

[section ""cstring" . lvl5_rcom5_bytes" {
     lvl5_rcom5_bytes:
         I8[] [112,117,116,101,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.96123398 UTC

[section ""data" . lvl6_rcom6_closure" {
     lvl6_rcom6_closure:
         const lvl6_rcom6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rcom6_entry() //  [R1]
         { info_tbl: [(ccpYi,
                       label: lvl6_rcom6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpYi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpYj; else goto ccpYk;
       ccpYj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpYk: // global
           (_ccpYf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccpYf::I64 == 0) goto ccpYh; else goto ccpYg;
       ccpYh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccpYg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccpYf::I64;
           R2 = lvl5_rcom5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.965899296 UTC

[section ""data" . System.Environment.setEnv2_closure" {
     System.Environment.setEnv2_closure:
         const System.Environment.setEnv2_info;
         const 0;
 },
 System.Environment.setEnv2_entry() //  [R2]
         { info_tbl: [(ccpYz,
                       label: System.Environment.setEnv2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpYz: // global
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(R2));
           R2 = lvl6_rcom6_closure;
           call Foreign.C.Error.$wlvl_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.969052806 UTC

[section ""cstring" . System.Environment.setEnv10_bytes" {
     System.Environment.setEnv10_bytes:
         I8[] [115,101,116,69,110,118]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.970934904 UTC

[section ""data" . System.Environment.setEnv9_closure" {
     System.Environment.setEnv9_closure:
         const System.Environment.setEnv9_info;
         const 0;
         const 0;
         const 0;
 },
 System.Environment.setEnv9_entry() //  [R1]
         { info_tbl: [(ccpYN,
                       label: System.Environment.setEnv9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpYN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpYO; else goto ccpYP;
       ccpYO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpYP: // global
           (_ccpYK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccpYK::I64 == 0) goto ccpYM; else goto ccpYL;
       ccpYM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccpYL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccpYK::I64;
           R2 = System.Environment.setEnv10_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.974884336 UTC

[section ""data" . System.Environment.setEnv8_closure" {
     System.Environment.setEnv8_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.InvalidArgument_closure+1;
         const System.Environment.setEnv9_closure;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.97777812 UTC

[section ""data" . System.Environment.setEnv7_closure" {
     System.Environment.setEnv7_closure:
         const System.Environment.setEnv7_info;
         const 0;
         const 0;
         const 0;
 },
 System.Environment.setEnv7_entry() //  [R1]
         { info_tbl: [(ccpZ5,
                       label: System.Environment.setEnv7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpZ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccpZ6; else goto ccpZ7;
       ccpZ6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpZ7: // global
           (_ccpZ2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccpZ2::I64 == 0) goto ccpZ4; else goto ccpZ3;
       ccpZ4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccpZ3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccpZ2::I64;
           R2 = System.Environment.setEnv8_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.981606107 UTC

[section ""data" . System.Environment.setEnv6_closure" {
     System.Environment.setEnv6_closure:
         const GHC.Types.C#_con_info;
         const 61;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.98332171 UTC

[section ""cstring" . System.Environment.setEnv3_bytes" {
     System.Environment.setEnv3_bytes:
         I8[] [61]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:18.986387276 UTC

[section ""data" . System.Environment.setEnv1_closure" {
     System.Environment.setEnv1_closure:
         const System.Environment.setEnv1_info;
         const 0;
 },
 sat_scpyu_entry() //  [R1]
         { info_tbl: [(ccpZP,
                       label: sat_scpyu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpZP: // global
           R3 = P64[R1 + 16];
           R2 = System.Environment.setEnv3_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_scpyv_entry() //  [R1]
         { info_tbl: [(ccpZS,
                       label: sat_scpyv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpZS: // global
           _scpyv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccpZT; else goto ccpZU;
       ccpZU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccpZW; else goto ccpZV;
       ccpZW: // global
           HpAlloc = 24;
           goto ccpZT;
       ccpZT: // global
           R1 = _scpyv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccpZV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scpyv::P64;
           _scpye::P64 = P64[_scpyv::P64 + 16];
           _scpyi::P64 = P64[_scpyv::P64 + 24];
           I64[Hp - 16] = sat_scpyu_info;
           P64[Hp] = _scpyi::P64;
           R3 = Hp - 16;
           R2 = _scpye::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.Environment.setEnv1_entry() //  [R2, R3]
         { info_tbl: [(ccq01,
                       label: System.Environment.setEnv1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccq01: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccq02; else goto ccq03;
       ccq02: // global
           R3 = R3;
           R2 = R2;
           R1 = System.Environment.setEnv1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccq03: // global
           I64[Sp - 16] = block_ccpZm_info;
           _scpyc::P64 = R3;
           R3 = R2;
           R2 = System.Environment.setEnv11_closure+1;
           P64[Sp - 8] = _scpyc::P64;
           Sp = Sp - 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpZm() //  [R1]
         { info_tbl: [(ccpZm,
                       label: block_ccpZm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpZm: // global
           if (R1 & 7 == 1) goto ucq0U; else goto ccpZZ;
       ucq0U: // global
           Sp = Sp + 16;
           call _ccq0Q() args: 0, res: 0, upd: 0;
       ccpZZ: // global
           I64[Sp - 8] = block_ccpZr_info;
           R4 = R1;
           R3 = System.Environment.setEnv6_closure+1;
           R2 = GHC.Classes.$fEqChar_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccpZr() //  [R1]
         { info_tbl: [(ccpZr,
                       label: block_ccpZr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpZr: // global
           if (R1 & 7 == 1) goto ccq09; else goto ucq0V;
       ccq09: // global
           I64[Sp] = block_ccpZv_info;
           R3 = P64[Sp + 16];
           R2 = System.Environment.setEnv11_closure+1;
           call GHC.List.takeWhile_entry(R3, R2) args: 8, res: 8, upd: 8;
       ucq0V: // global
           Sp = Sp + 24;
           call _ccq0Q() args: 0, res: 0, upd: 0;
     }
 },
 _ccpZv() //  [R1]
         { info_tbl: [(ccpZv,
                       label: block_ccpZv_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpZv: // global
           if (R1 & 7 == 1) goto ccq0e; else goto ccq0l;
       ccq0e: // global
           I64[Sp] = block_ccq0b_info;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
       ccq0l: // global
           I64[Sp] = block_ccpZA_info;
           _scpyi::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding1_closure;
           P64[Sp + 16] = _scpyi::P64;
           if (R1 & 7 != 0) goto ucq0Y; else goto ccpZB;
       ucq0Y: // global
           call _ccpZA(R1) args: 0, res: 0, upd: 0;
       ccpZB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccq0b() //  [R1]
         { info_tbl: [(ccq0b,
                       label: block_ccq0b_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccq0b: // global
           R4 = System.Environment.setEnv4_closure+2;
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccpZA() //  [R1]
         { info_tbl: [(ccpZA,
                       label: block_ccpZA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpZA: // global
           I64[Sp] = block_ccpZF_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccpZF() //  [R1]
         { info_tbl: [(ccpZF,
                       label: block_ccpZF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccpZF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccq0p; else goto ccq0o;
       ccq0p: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccq0o: // global
           I64[Hp - 24] = sat_scpyv_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           I64[Sp + 16] = block_ccq0h_info;
           R3 = Hp - 24;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _ccq0h() //  [R1]
         { info_tbl: [(ccq0h,
                       label: block_ccq0h_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccq0h: // global
           I64[Sp] = block_ccq0j_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ucq0Z; else goto ccq0r;
       ucq0Z: // global
           call _ccq0j(R1) args: 0, res: 0, upd: 0;
       ccq0r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccq0j() //  [R1]
         { info_tbl: [(ccq0j,
                       label: block_ccq0j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccq0j: // global
           (_scpyE::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] putenv(I64[R1 + 7]);
           if (%MO_SS_Conv_W64_W32(_scpyE::I64) == 0 :: W32) goto ccq0J; else goto ccq0D;
       ccq0J: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccq0D: // global
           (_scpyJ::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] __hscore_get_errno();
           R2 = _scpyJ::I64;
           Sp = Sp + 8;
           call System.Environment.setEnv2_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _ccq0Q() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccq0Q: // global
           R1 = System.Environment.setEnv7_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:19.008667927 UTC

[section ""data" . System.Environment.setEnv_closure" {
     System.Environment.setEnv_closure:
         const System.Environment.setEnv_info;
         const 0;
 },
 System.Environment.setEnv_entry() //  [R2, R3]
         { info_tbl: [(ccq23,
                       label: System.Environment.setEnv_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccq23: // global
           R3 = R3;
           R2 = R2;
           call System.Environment.setEnv1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:19.012809606 UTC

[section ""relreadonly" . Scpzh_srt" {
     Scpzh_srt:
         const Foreign.C.Error.$wlvl_closure;
         const loc1_rcolZ_closure;
         const System.Environment.setEnv4_closure;
         const System.Environment.setEnv5_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const System.Environment.unsetEnv1_closure;
         const GHC.Foreign.$wpeekCString_closure;
         const GHC.IO.Encoding.getFileSystemEncoding1_closure;
         const System.Environment.$wlvl_closure;
         const System.Environment.getEnv3_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const System.Environment.lookupEnv1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const lvl2_rcom2_closure;
         const lvl4_rcom4_closure;
         const System.Environment.getEnv2_closure;
         const System.Environment.getEnv1_closure;
         const System.Environment.getProgName1_closure;
         const System.Environment.getArgs1_closure;
         const GHC.Foreign.withCStringsLen1_closure;
         const System.Environment.withArgs2_closure;
         const System.Environment.withArgs1_closure;
         const System.Environment.withProgName1_closure;
         const System.Environment.getEnvironment1_closure;
         const lvl6_rcom6_closure;
         const System.Environment.setEnv8_closure;
         const GHC.Foreign.newCString1_closure;
         const System.Environment.setEnv1_closure;
         const System.Environment.setEnv2_closure;
         const System.Environment.setEnv7_closure;
 }]

