
==================== Output Cmm ====================
2018-03-16 16:06:30.028010258 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:30.028877492 UTC

[section ""data" . System.IO.putChar1_closure" {
     System.IO.putChar1_closure:
         const System.IO.putChar1_info;
         const 0;
 },
 System.IO.putChar1_entry() //  [R2]
         { info_tbl: [(cbyXt,
                       label: System.IO.putChar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyXt: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutChar1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.029937808 UTC

[section ""data" . System.IO.putChar_closure" {
     System.IO.putChar_closure:
         const System.IO.putChar_info;
         const 0;
 },
 System.IO.putChar_entry() //  [R2]
         { info_tbl: [(cbyXB,
                       label: System.IO.putChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyXB: // global
           R2 = R2;
           call System.IO.putChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.030728957 UTC

[section ""data" . System.IO.putStr_closure" {
     System.IO.putStr_closure:
         const System.IO.putStr_info;
         const 0;
 },
 System.IO.putStr_entry() //  [R2]
         { info_tbl: [(cbyXI,
                       label: System.IO.putStr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyXI: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.031597781 UTC

[section ""data" . System.IO.putStrLn_closure" {
     System.IO.putStrLn_closure:
         const System.IO.putStrLn_info;
         const 0;
 },
 System.IO.putStrLn_entry() //  [R2]
         { info_tbl: [(cbyXP,
                       label: System.IO.putStrLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyXP: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutStrLn_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.032718416 UTC

[section ""data" . System.IO.print_closure" {
     System.IO.print_closure:
         const System.IO.print_info;
         const 0;
 },
 sat_sbyQs_entry() //  [R1]
         { info_tbl: [(cbyY0,
                       label: sat_sbyQs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyY0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbyY1; else goto cbyY2;
       cbyY1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbyY2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 System.IO.print_entry() //  [R2, R3]
         { info_tbl: [(cbyY3,
                       label: System.IO.print_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyY3: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbyY7; else goto cbyY6;
       cbyY7: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.print_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbyY6: // global
           I64[Hp - 24] = sat_sbyQs_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = GHC.Types.True_closure+2;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.034086288 UTC

[section ""data" . System.IO.getChar1_closure" {
     System.IO.getChar1_closure:
         const System.IO.getChar1_info;
         const 0;
 },
 System.IO.getChar1_entry() //  []
         { info_tbl: [(cbyYc,
                       label: System.IO.getChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyYc: // global
           R4 = GHC.IO.Handle.Text.hGetChar2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.Text.hGetChar6_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.034911561 UTC

[section ""data" . System.IO.getChar_closure" {
     System.IO.getChar_closure:
         const System.IO.getChar_info;
         const 0;
 },
 System.IO.getChar_entry() //  []
         { info_tbl: [(cbyYj,
                       label: System.IO.getChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyYj: // global
           call System.IO.getChar1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.035719522 UTC

[section ""data" . System.IO.getLine1_closure" {
     System.IO.getLine1_closure:
         const System.IO.getLine1_info;
         const 0;
 },
 System.IO.getLine1_entry() //  []
         { info_tbl: [(cbyYq,
                       label: System.IO.getLine1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyYq: // global
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.036517936 UTC

[section ""data" . System.IO.getLine_closure" {
     System.IO.getLine_closure:
         const System.IO.getLine_info;
         const 0;
 },
 System.IO.getLine_entry() //  []
         { info_tbl: [(cbyYx,
                       label: System.IO.getLine_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyYx: // global
           call System.IO.getLine1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.037332454 UTC

[section ""data" . System.IO.getContents1_closure" {
     System.IO.getContents1_closure:
         const System.IO.getContents1_info;
         const 0;
 },
 System.IO.getContents1_entry() //  []
         { info_tbl: [(cbyYE,
                       label: System.IO.getContents1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyYE: // global
           R2 = GHC.IO.Handle.FD.stdin_closure;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.038160062 UTC

[section ""data" . System.IO.getContents_closure" {
     System.IO.getContents_closure:
         const System.IO.getContents_info;
         const 0;
 },
 System.IO.getContents_entry() //  []
         { info_tbl: [(cbyYL,
                       label: System.IO.getContents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyYL: // global
           call System.IO.getContents1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.038865854 UTC

[section ""data" . System.IO.localeEncoding_closure" {
     System.IO.localeEncoding_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Encoding.initLocaleEncoding_closure;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.03945173 UTC

[section ""data" . System.IO.hReady2_closure" {
     System.IO.hReady2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.040112274 UTC

[section ""data" . System.IO.hReady1_closure" {
     System.IO.hReady1_closure:
         const System.IO.hReady1_info;
         const 0;
 },
 System.IO.hReady1_entry() //  [R2]
         { info_tbl: [(cbyYS,
                       label: System.IO.hReady1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyYS: // global
           R3 = System.IO.hReady2_closure+1;
           R2 = R2;
           call GHC.IO.Handle.Text.hWaitForInput1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.040940968 UTC

[section ""data" . System.IO.hReady_closure" {
     System.IO.hReady_closure:
         const System.IO.hReady_info;
         const 0;
 },
 System.IO.hReady_entry() //  [R2]
         { info_tbl: [(cbyYZ,
                       label: System.IO.hReady_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyYZ: // global
           R2 = R2;
           call System.IO.hReady1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.042084095 UTC

[section ""data" . System.IO.hPrint_closure" {
     System.IO.hPrint_closure:
         const System.IO.hPrint_info;
         const 0;
 },
 sat_sbyQy_entry() //  [R1]
         { info_tbl: [(cbyZa,
                       label: sat_sbyQy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyZa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbyZb; else goto cbyZc;
       cbyZb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbyZc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 System.IO.hPrint_entry() //  [R2, R3, R4]
         { info_tbl: [(cbyZd,
                       label: System.IO.hPrint_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyZd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbyZh; else goto cbyZg;
       cbyZh: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.hPrint_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbyZg: // global
           I64[Hp - 24] = sat_sbyQy_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R4 = GHC.Types.True_closure+2;
           _sbyQw::P64 = R3;
           R3 = Hp - 24;
           R2 = _sbyQw::P64;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.045175908 UTC

[section ""data" . System.IO.appendFile2_closure" {
     System.IO.appendFile2_closure:
         const System.IO.appendFile2_info;
         const 0;
 },
 sat_sbyQR_entry() //  [R1, R2]
         { info_tbl: [(cbyZz,
                       label: sat_sbyQR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyZz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbyZA; else goto cbyZB;
       cbyZA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbyZB: // global
           I64[Sp - 16] = block_cbyZx_info;
           _sbyQM::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyQM::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbyZx() //  []
         { info_tbl: [(cbyZx,
                       label: block_cbyZx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyZx: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyQL_entry() //  [R1]
         { info_tbl: [(cbyZJ,
                       label: sat_sbyQL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyZJ: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyR9_entry() //  [R1, R2]
         { info_tbl: [(cbz01,
                       label: sat_sbyR9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz01: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz02; else goto cbz03;
       cbz02: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbz03: // global
           I64[Sp - 16] = block_cbyZZ_info;
           _sbyR4::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyR4::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbyZZ() //  []
         { info_tbl: [(cbyZZ,
                       label: block_cbyZZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyZZ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyR3_entry() //  [R1]
         { info_tbl: [(cbz0b,
                       label: sat_sbyR3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0b: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRg_entry() //  [R1]
         { info_tbl: [(cbz0i,
                       label: sat_sbyRg_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz0j; else goto cbz0k;
       cbz0j: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbz0k: // global
           I64[Sp - 16] = block_cbyZS_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbyZS() //  [R1]
         { info_tbl: [(cbyZS,
                       label: block_cbyZS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyZS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbz0n; else goto cbz0m;
       cbz0n: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz0m: // global
           I64[Hp - 56] = sat_sbyR9_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyR3_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbz0e_info;
           R2 = Hp - 54;
           _sbyR1::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyR1::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz0e() //  [R1]
         { info_tbl: [(cbz0e,
                       label: block_cbz0e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0e: // global
           I64[Sp] = block_cbz0g_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz0g() //  []
         { info_tbl: [(cbz0g,
                       label: block_cbz0g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0g: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRr_entry() //  [R1, R2]
         { info_tbl: [(cbz0A,
                       label: sat_sbyRr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz0B; else goto cbz0C;
       cbz0B: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbz0C: // global
           I64[Sp - 16] = block_cbz0y_info;
           _sbyRm::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyRm::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz0y() //  []
         { info_tbl: [(cbz0y,
                       label: block_cbz0y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0y: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRl_entry() //  [R1]
         { info_tbl: [(cbz0K,
                       label: sat_sbyRl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0K: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.appendFile2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbz0R,
                       label: System.IO.appendFile2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbz0S; else goto cbz0T;
       cbz0S: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.appendFile2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbz0T: // global
           I64[Sp - 32] = block_cbyZm_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbyZm() //  [R1]
         { info_tbl: [(cbyZm,
                       label: block_cbyZm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyZm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbz0W; else goto cbz0V;
       cbz0W: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbz0V: // global
           _sbyQz::P64 = P64[Sp + 8];
           _sbyQA::P64 = P64[Sp + 16];
           if (R1 == 0) goto cbz0P; else goto ubz1f;
       cbz0P: // global
           I64[Hp - 24] = sat_sbyRg_info;
           P64[Hp - 16] = _sbyQz::P64;
           P64[Hp - 8] = _sbyQA::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ubz1f: // global
           if (R1 == 1) goto cbz0Q; else goto cbz0O;
       cbz0Q: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbz0r_info;
           R3 = _sbyQA::P64;
           R2 = _sbyQz::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       cbz0O: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbyZq_info;
           R3 = _sbyQA::P64;
           R2 = _sbyQz::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz0r() //  [R1]
         { info_tbl: [(cbz0r,
                       label: block_cbz0r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0r: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbz1b; else goto cbz1a;
       cbz1b: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz1a: // global
           I64[Hp - 56] = sat_sbyRr_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyRl_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbz16_info;
           R2 = Hp - 54;
           _sbyRj::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyRj::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz16() //  [R1]
         { info_tbl: [(cbz16,
                       label: block_cbz16_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz16: // global
           I64[Sp] = block_cbz18_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz18() //  []
         { info_tbl: [(cbz18,
                       label: block_cbz18_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz18: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbyZq() //  [R1]
         { info_tbl: [(cbyZq,
                       label: block_cbyZq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbyZq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbz12; else goto cbz11;
       cbz12: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz11: // global
           I64[Hp - 56] = sat_sbyQR_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyQL_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbz0X_info;
           R2 = Hp - 54;
           _sbyQJ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyQJ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz0X() //  [R1]
         { info_tbl: [(cbz0X,
                       label: block_cbz0X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0X: // global
           I64[Sp] = block_cbz0Z_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz0Z() //  []
         { info_tbl: [(cbz0Z,
                       label: block_cbz0Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz0Z: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.051758013 UTC

[section ""data" . System.IO.withFile_closure" {
     System.IO.withFile_closure:
         const System.IO.withFile_info;
         const 0;
 },
 System.IO.withFile_entry() //  [R2, R3, R4]
         { info_tbl: [(cbz1k,
                       label: System.IO.withFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz1k: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.052765317 UTC

[section ""data" . System.IO.appendFile1_closure" {
     System.IO.appendFile1_closure:
         const System.IO.appendFile1_info;
         const 0;
 },
 sat_sbyRC_entry() //  [R1, R2]
         { info_tbl: [(cbz1w,
                       label: sat_sbyRC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz1w: // global
           R3 = P64[R1 + 6];
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.appendFile1_entry() //  [R2, R3]
         { info_tbl: [(cbz1z,
                       label: System.IO.appendFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz1z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbz1D; else goto cbz1C;
       cbz1D: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.appendFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbz1C: // global
           I64[Hp - 8] = sat_sbyRC_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = GHC.IO.IOMode.AppendMode_closure+3;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.054173756 UTC

[section ""data" . System.IO.appendFile_closure" {
     System.IO.appendFile_closure:
         const System.IO.appendFile_info;
         const 0;
 },
 System.IO.appendFile_entry() //  [R2, R3]
         { info_tbl: [(cbz1I,
                       label: System.IO.appendFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz1I: // global
           R3 = R3;
           R2 = R2;
           call System.IO.appendFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.055175989 UTC

[section ""data" . System.IO.writeFile1_closure" {
     System.IO.writeFile1_closure:
         const System.IO.writeFile1_info;
         const 0;
 },
 sat_sbyRH_entry() //  [R1, R2]
         { info_tbl: [(cbz1U,
                       label: sat_sbyRH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz1U: // global
           R3 = P64[R1 + 6];
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.writeFile1_entry() //  [R2, R3]
         { info_tbl: [(cbz1X,
                       label: System.IO.writeFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz1X: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbz21; else goto cbz20;
       cbz21: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.writeFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbz20: // global
           I64[Hp - 8] = sat_sbyRH_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = GHC.IO.IOMode.WriteMode_closure+2;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.056296363 UTC

[section ""data" . System.IO.writeFile_closure" {
     System.IO.writeFile_closure:
         const System.IO.writeFile_info;
         const 0;
 },
 System.IO.writeFile_entry() //  [R2, R3]
         { info_tbl: [(cbz26,
                       label: System.IO.writeFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz26: // global
           R3 = R3;
           R2 = R2;
           call System.IO.writeFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.058876898 UTC

[section ""data" . System.IO.withBinaryFile1_closure" {
     System.IO.withBinaryFile1_closure:
         const System.IO.withBinaryFile1_info;
         const 0;
 },
 sat_sbyS0_entry() //  [R1, R2]
         { info_tbl: [(cbz2q,
                       label: sat_sbyS0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz2q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz2r; else goto cbz2s;
       cbz2r: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbz2s: // global
           I64[Sp - 16] = block_cbz2o_info;
           _sbyRV::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyRV::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz2o() //  []
         { info_tbl: [(cbz2o,
                       label: block_cbz2o_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz2o: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRU_entry() //  [R1]
         { info_tbl: [(cbz2A,
                       label: sat_sbyRU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz2A: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySi_entry() //  [R1, R2]
         { info_tbl: [(cbz2S,
                       label: sat_sbySi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz2S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz2T; else goto cbz2U;
       cbz2T: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbz2U: // global
           I64[Sp - 16] = block_cbz2Q_info;
           _sbySd::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbySd::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz2Q() //  []
         { info_tbl: [(cbz2Q,
                       label: block_cbz2Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz2Q: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySc_entry() //  [R1]
         { info_tbl: [(cbz32,
                       label: sat_sbySc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz32: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySp_entry() //  [R1]
         { info_tbl: [(cbz39,
                       label: sat_sbySp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz39: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz3a; else goto cbz3b;
       cbz3a: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbz3b: // global
           I64[Sp - 16] = block_cbz2J_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz2J() //  [R1]
         { info_tbl: [(cbz2J,
                       label: block_cbz2J_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz2J: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbz3e; else goto cbz3d;
       cbz3e: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz3d: // global
           I64[Hp - 56] = sat_sbySi_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbySc_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbz35_info;
           R2 = Hp - 54;
           _sbySa::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbySa::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz35() //  [R1]
         { info_tbl: [(cbz35,
                       label: block_cbz35_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz35: // global
           I64[Sp] = block_cbz37_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz37() //  []
         { info_tbl: [(cbz37,
                       label: block_cbz37_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz37: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySA_entry() //  [R1, R2]
         { info_tbl: [(cbz3r,
                       label: sat_sbySA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz3r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz3s; else goto cbz3t;
       cbz3s: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbz3t: // global
           I64[Sp - 16] = block_cbz3p_info;
           _sbySv::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbySv::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz3p() //  []
         { info_tbl: [(cbz3p,
                       label: block_cbz3p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz3p: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySu_entry() //  [R1]
         { info_tbl: [(cbz3B,
                       label: sat_sbySu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz3B: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.withBinaryFile1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbz3I,
                       label: System.IO.withBinaryFile1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz3I: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbz3J; else goto cbz3K;
       cbz3J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.withBinaryFile1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbz3K: // global
           I64[Sp - 32] = block_cbz2d_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbz2d() //  [R1]
         { info_tbl: [(cbz2d,
                       label: block_cbz2d_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz2d: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbz3N; else goto cbz3M;
       cbz3N: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbz3M: // global
           _sbyRI::P64 = P64[Sp + 8];
           _sbyRJ::P64 = P64[Sp + 16];
           if (R1 == 0) goto cbz3G; else goto ubz46;
       cbz3G: // global
           I64[Hp - 24] = sat_sbySp_info;
           P64[Hp - 16] = _sbyRI::P64;
           P64[Hp - 8] = _sbyRJ::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ubz46: // global
           if (R1 == 1) goto cbz3H; else goto cbz3F;
       cbz3H: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbz3i_info;
           R3 = _sbyRJ::P64;
           R2 = _sbyRI::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       cbz3F: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbz2h_info;
           R3 = _sbyRJ::P64;
           R2 = _sbyRI::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz3i() //  [R1]
         { info_tbl: [(cbz3i,
                       label: block_cbz3i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz3i: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbz42; else goto cbz41;
       cbz42: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz41: // global
           I64[Hp - 56] = sat_sbySA_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbySu_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbz3X_info;
           R2 = Hp - 54;
           _sbySs::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbySs::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz3X() //  [R1]
         { info_tbl: [(cbz3X,
                       label: block_cbz3X_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz3X: // global
           I64[Sp] = block_cbz3Z_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz3Z() //  []
         { info_tbl: [(cbz3Z,
                       label: block_cbz3Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz3Z: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbz2h() //  [R1]
         { info_tbl: [(cbz2h,
                       label: block_cbz2h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz2h: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbz3T; else goto cbz3S;
       cbz3T: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz3S: // global
           I64[Hp - 56] = sat_sbyS0_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyRU_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbz3O_info;
           R2 = Hp - 54;
           _sbyRS::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyRS::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz3O() //  [R1]
         { info_tbl: [(cbz3O,
                       label: block_cbz3O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz3O: // global
           I64[Sp] = block_cbz3Q_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz3Q() //  []
         { info_tbl: [(cbz3Q,
                       label: block_cbz3Q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz3Q: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.063486085 UTC

[section ""data" . System.IO.withBinaryFile_closure" {
     System.IO.withBinaryFile_closure:
         const System.IO.withBinaryFile_info;
         const 0;
 },
 System.IO.withBinaryFile_entry() //  [R2, R3, R4]
         { info_tbl: [(cbz4b,
                       label: System.IO.withBinaryFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz4b: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call System.IO.withBinaryFile1_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.064433215 UTC

[section ""data" . lvl_rbyQ6_closure" {
     lvl_rbyQ6_closure:
         const lvl_rbyQ6_info;
 },
 lvl_rbyQ6_entry() //  []
         { info_tbl: [(cbz4n,
                       label: lvl_rbyQ6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz4n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbz4o; else goto cbz4p;
       cbz4o: // global
           R1 = lvl_rbyQ6_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbz4p: // global
           I64[Sp - 8] = block_cbz4i_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cbz4i() //  []
         { info_tbl: [(cbz4i,
                       label: block_cbz4i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz4i: // global
           I64[Sp] = block_cbz4k_info;
           R1 = System.IO.hReady2_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz4k() //  [R1]
         { info_tbl: [(cbz4k,
                       label: block_cbz4k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz4k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbz4t; else goto cbz4s;
       cbz4t: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz4s: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.065815162 UTC

[section ""data" . tempCounter_rbxCH_closure" {
     tempCounter_rbxCH_closure:
         const tempCounter_rbxCH_info;
         const 0;
         const 0;
         const 0;
 },
 tempCounter_rbxCH_entry() //  [R1]
         { info_tbl: [(cbz4C,
                       label: tempCounter_rbxCH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz4C: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbz4D; else goto cbz4E;
       cbz4D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbz4E: // global
           (_cbz4x::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbz4x::I64 == 0) goto cbz4z; else goto cbz4y;
       cbz4z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbz4y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbz4x::I64;
           I64[Sp - 24] = block_cbz4A_info;
           Sp = Sp - 24;
           call lvl_rbyQ6_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbz4A() //  [R1]
         { info_tbl: [(cbz4A,
                       label: block_cbz4A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz4A: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.066825182 UTC

[section ""data" . pathSeparatorChar_rbxCK_closure" {
     pathSeparatorChar_rbxCK_closure:
         const GHC.Types.C#_con_info;
         const 47;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.067387923 UTC

[section ""cstring" . System.IO.$trModule4_bytes" {
     System.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.067926802 UTC

[section ""data" . System.IO.$trModule3_closure" {
     System.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.068442761 UTC

[section ""cstring" . System.IO.$trModule2_bytes" {
     System.IO.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.068983159 UTC

[section ""data" . System.IO.$trModule1_closure" {
     System.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.069590186 UTC

[section ""data" . System.IO.$trModule_closure" {
     System.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.IO.$trModule3_closure+1;
         const System.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.070168244 UTC

[section ""data" . $krep_rbyQ7_closure" {
     $krep_rbyQ7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Error.$tcErrno_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.070725818 UTC

[section ""data" . $krep1_rbyQ8_closure" {
     $krep1_rbyQ8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.071274345 UTC

[section ""cstring" . System.IO.$tcOpenNewFileResult2_bytes" {
     System.IO.$tcOpenNewFileResult2_bytes:
         I8[] [79,112,101,110,78,101,119,70,105,108,101,82,101,115,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.071756478 UTC

[section ""data" . System.IO.$tcOpenNewFileResult1_closure" {
     System.IO.$tcOpenNewFileResult1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tcOpenNewFileResult2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.07233235 UTC

[section ""data" . System.IO.$tcOpenNewFileResult_closure" {
     System.IO.$tcOpenNewFileResult_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tcOpenNewFileResult1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9627069439367662246;
         const 2547759174955940786;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.072913185 UTC

[section ""data" . System.IO.$tc'FileExists1_closure" {
     System.IO.$tc'FileExists1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.IO.$tcOpenNewFileResult_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.073513655 UTC

[section ""cstring" . System.IO.$tc'FileExists3_bytes" {
     System.IO.$tc'FileExists3_bytes:
         I8[] [39,70,105,108,101,69,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.074050784 UTC

[section ""data" . System.IO.$tc'FileExists2_closure" {
     System.IO.$tc'FileExists2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'FileExists3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.074564487 UTC

[section ""data" . System.IO.$tc'FileExists_closure" {
     System.IO.$tc'FileExists_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'FileExists2_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 6704133186904346962;
         const 16997416543076271011;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.075129742 UTC

[section ""data" . System.IO.$tc'NewFileCreated1_closure" {
     System.IO.$tc'NewFileCreated1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rbyQ8_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.075648805 UTC

[section ""cstring" . System.IO.$tc'NewFileCreated3_bytes" {
     System.IO.$tc'NewFileCreated3_bytes:
         I8[] [39,78,101,119,70,105,108,101,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.07618071 UTC

[section ""data" . System.IO.$tc'NewFileCreated2_closure" {
     System.IO.$tc'NewFileCreated2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'NewFileCreated3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.076686099 UTC

[section ""data" . System.IO.$tc'NewFileCreated_closure" {
     System.IO.$tc'NewFileCreated_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'NewFileCreated2_closure+1;
         const System.IO.$tc'NewFileCreated1_closure+4;
         const 9070829168557028496;
         const 15570227817593865145;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.077287391 UTC

[section ""data" . System.IO.$tc'OpenNewError1_closure" {
     System.IO.$tc'OpenNewError1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbyQ7_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.077900978 UTC

[section ""cstring" . System.IO.$tc'OpenNewError3_bytes" {
     System.IO.$tc'OpenNewError3_bytes:
         I8[] [39,79,112,101,110,78,101,119,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.078457284 UTC

[section ""data" . System.IO.$tc'OpenNewError2_closure" {
     System.IO.$tc'OpenNewError2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'OpenNewError3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.079036258 UTC

[section ""data" . System.IO.$tc'OpenNewError_closure" {
     System.IO.$tc'OpenNewError_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'OpenNewError2_closure+1;
         const System.IO.$tc'OpenNewError1_closure+4;
         const 300310999495895268;
         const 12582581010413704951;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.079918886 UTC

[section ""data" . lvl1_rbyQ9_closure" {
     lvl1_rbyQ9_closure:
         const lvl1_rbyQ9_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbyQ9_entry() //  [R1]
         { info_tbl: [(cbz4M,
                       label: lvl1_rbyQ9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz4M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz4N; else goto cbz4O;
       cbz4N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbz4O: // global
           (_cbz4J::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbz4J::I64 == 0) goto cbz4L; else goto cbz4K;
       cbz4L: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbz4K: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbz4J::I64;
           R2 = GHC.IO.Exception.FixIOException_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionFixIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.080940009 UTC

[section ""data" . System.IO.fixIO3_closure" {
     System.IO.fixIO3_closure:
         const System.IO.fixIO3_info;
         const 0;
 },
 System.IO.fixIO3_entry() //  []
         { info_tbl: [(cbz4T,
                       label: System.IO.fixIO3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz4T: // global
           R1 = lvl1_rbyQ9_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.082460698 UTC

[section ""data" . System.IO.fixIO2_closure" {
     System.IO.fixIO2_closure:
         const System.IO.fixIO2_info;
         const 0;
 },
 sat_sbySX_entry() //  [R1]
         { info_tbl: [(cbz5i,
                       label: sat_sbySX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz5i: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.fixIO2_entry() //  [R2]
         { info_tbl: [(cbz5l,
                       label: System.IO.fixIO2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz5l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbz5m; else goto cbz5n;
       cbz5m: // global
           R2 = R2;
           R1 = System.IO.fixIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbz5n: // global
           I64[Sp - 8] = block_cbz50_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubz5F; else goto cbz51;
       ubz5F: // global
           call _cbz50(R1) args: 0, res: 0, upd: 0;
       cbz51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz50() //  [R1]
         { info_tbl: [(cbz50,
                       label: block_cbz50_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz50: // global
           I64[Sp - 16] = block_cbz55_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz55() //  [R1]
         { info_tbl: [(cbz55,
                       label: block_cbz55_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz55: // global
           I64[Sp] = block_cbz59_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz59() //  [R1]
         { info_tbl: [(cbz59,
                       label: block_cbz59_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz59: // global
           if (R1 & 7 == 1) goto cbz5r; else goto cbz5z;
       cbz5r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbz5u; else goto cbz5t;
       cbz5u: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz5t: // global
           I64[Hp - 8] = sat_sbySX_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbz5z: // global
           I64[Sp + 16] = block_cbz5x_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz5x() //  []
         { info_tbl: [(cbz5x,
                       label: block_cbz5x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz5x: // global
           R1 = System.IO.fixIO3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.084695448 UTC

[section ""data" . System.IO.fixIO1_closure" {
     System.IO.fixIO1_closure:
         const System.IO.fixIO1_info;
         const 0;
 },
 sat_sbyT6_entry() //  [R1]
         { info_tbl: [(cbz5W,
                       label: sat_sbyT6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz5W: // global
           R1 = P64[R1 + 7];
           call stg_readMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyT7_entry() //  [R1]
         { info_tbl: [(cbz5Z,
                       label: sat_sbyT7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz5Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbz63; else goto cbz62;
       cbz63: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbz62: // global
           _sbyT3::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sbyT6_info;
           P64[Hp] = _sbyT3::P64;
           R2 = System.IO.fixIO2_closure+1;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.fixIO1_entry() //  [R2]
         { info_tbl: [(cbz6a,
                       label: System.IO.fixIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz6a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbz6b; else goto cbz6c;
       cbz6b: // global
           R2 = R2;
           R1 = System.IO.fixIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbz6c: // global
           I64[Sp - 16] = block_cbz5K_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cbz5K() //  [R1]
         { info_tbl: [(cbz5K,
                       label: block_cbz5K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz5K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbz6f; else goto cbz6e;
       cbz6f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz6e: // global
           I64[Hp - 8] = sat_sbyT7_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_cbz64_info;
           R2 = Hp - 7;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz64() //  [R1]
         { info_tbl: [(cbz64,
                       label: block_cbz64_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz64: // global
           I64[Sp] = block_cbz66_info;
           R2 = R1;
           R1 = P64[Sp + 16];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz66() //  [R1]
         { info_tbl: [(cbz66,
                       label: block_cbz66_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz66: // global
           _sbyT3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbz68_info;
           R2 = R1;
           _sbyTd::P64 = R1;
           R1 = _sbyT3::P64;
           P64[Sp + 16] = _sbyTd::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz68() //  []
         { info_tbl: [(cbz68,
                       label: block_cbz68_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz68: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.086687043 UTC

[section ""data" . System.IO.fixIO_closure" {
     System.IO.fixIO_closure:
         const System.IO.fixIO_info;
         const 0;
 },
 System.IO.fixIO_entry() //  [R2]
         { info_tbl: [(cbz6n,
                       label: System.IO.fixIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz6n: // global
           R2 = R2;
           call System.IO.fixIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.087352238 UTC

[section ""cstring" . System.IO.readIO9_bytes" {
     System.IO.readIO9_bytes:
         I8[] [80,114,101,108,117,100,101,46,114,101,97,100,73,79,58,32,110,111,32,112,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.088070523 UTC

[section ""data" . System.IO.readIO8_closure" {
     System.IO.readIO8_closure:
         const System.IO.readIO8_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO8_entry() //  [R1]
         { info_tbl: [(cbz6w,
                       label: System.IO.readIO8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz6w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz6x; else goto cbz6y;
       cbz6x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbz6y: // global
           (_cbz6t::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbz6t::I64 == 0) goto cbz6v; else goto cbz6u;
       cbz6v: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbz6u: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbz6t::I64;
           R2 = System.IO.readIO9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.088924393 UTC

[section ""data" . System.IO.readIO7_closure" {
     System.IO.readIO7_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.Types.[]_closure+1;
         const System.IO.readIO8_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.089755119 UTC

[section ""data" . System.IO.readIO6_closure" {
     System.IO.readIO6_closure:
         const System.IO.readIO6_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO6_entry() //  [R1]
         { info_tbl: [(cbz6F,
                       label: System.IO.readIO6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz6F: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz6G; else goto cbz6H;
       cbz6G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbz6H: // global
           (_cbz6C::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbz6C::I64 == 0) goto cbz6E; else goto cbz6D;
       cbz6E: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbz6D: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbz6C::I64;
           R2 = System.IO.readIO7_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.090625626 UTC

[section ""cstring" . System.IO.readIO5_bytes" {
     System.IO.readIO5_bytes:
         I8[] [80,114,101,108,117,100,101,46,114,101,97,100,73,79,58,32,97,109,98,105,103,117,111,117,115,32,112,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.092740066 UTC

[section ""data" . System.IO.readIO4_closure" {
     System.IO.readIO4_closure:
         const System.IO.readIO4_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO4_entry() //  [R1]
         { info_tbl: [(cbz6O,
                       label: System.IO.readIO4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz6O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz6P; else goto cbz6Q;
       cbz6P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbz6Q: // global
           (_cbz6L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbz6L::I64 == 0) goto cbz6N; else goto cbz6M;
       cbz6N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbz6M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbz6L::I64;
           R2 = System.IO.readIO5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.094208517 UTC

[section ""data" . System.IO.readIO3_closure" {
     System.IO.readIO3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.Types.[]_closure+1;
         const System.IO.readIO4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.094950005 UTC

[section ""data" . System.IO.readIO2_closure" {
     System.IO.readIO2_closure:
         const System.IO.readIO2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO2_entry() //  [R1]
         { info_tbl: [(cbz6X,
                       label: System.IO.readIO2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz6X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz6Y; else goto cbz6Z;
       cbz6Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbz6Z: // global
           (_cbz6U::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbz6U::I64 == 0) goto cbz6W; else goto cbz6V;
       cbz6W: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbz6V: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbz6U::I64;
           R2 = System.IO.readIO3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.09736778 UTC

[section ""data" . System.IO.readIO10_closure" {
     System.IO.readIO10_closure:
         const System.IO.readIO10_info;
         const 0;
 },
 z_sbyTn_entry() //  [R1]
         { info_tbl: [(cbz7k,
                       label: z_sbyTn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz7k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz7l; else goto cbz7m;
       cbz7l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbz7m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call System.IO.readIO10_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyTy_entry() //  [R1]
         { info_tbl: [(cbz7R,
                       label: sat_sbyTy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz7R: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go1_sbyTo_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_sbyTo_entry() //  [R1, R2]
         { info_tbl: [(cbz7Y,
                       label: go1_sbyTo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz7Y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbz7Z; else goto ubz8n;
       cbz7Z: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ubz8n: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cbz7p() args: 0, res: 0, upd: 0;
     }
 },
 _cbz7p() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz7p: // global
           I64[Sp - 16] = block_cbz7s_info;
           R1 = P64[Sp + 8];
           _sbyTo::P64 = P64[Sp];
           P64[Sp - 8] = P64[_sbyTo::P64 + 15];
           P64[Sp + 8] = P64[_sbyTo::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubz8r; else goto cbz7t;
       ubz8r: // global
           call _cbz7s(R1) args: 0, res: 0, upd: 0;
       cbz7t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz7s() //  [R1]
         { info_tbl: [(cbz7s,
                       label: block_cbz7s_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz7s: // global
           if (R1 & 7 == 1) goto cbz7V; else goto cbz7W;
       cbz7V: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbz7W: // global
           I64[Sp] = block_cbz7y_info;
           _sbyTs::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _sbyTs::P64;
           if (R1 & 7 != 0) goto ubz8s; else goto cbz7z;
       ubz8s: // global
           call _cbz7y(R1) args: 0, res: 0, upd: 0;
       cbz7z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz7y() //  [R1]
         { info_tbl: [(cbz7y,
                       label: block_cbz7y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz7y: // global
           I64[Sp - 8] = block_cbz7D_info;
           _sbyTv::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sbyTv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubz8t; else goto cbz7E;
       ubz8t: // global
           call _cbz7D(R1) args: 0, res: 0, upd: 0;
       cbz7E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz7D() //  [R1]
         { info_tbl: [(cbz7D,
                       label: block_cbz7D_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz7D: // global
           if (R1 & 7 == 1) goto cbz87; else goto ubz8o;
       cbz87: // global
           _sbyTv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbz7I_info;
           R1 = _sbyTv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubz8u; else goto cbz7J;
       ubz8u: // global
           call _cbz7I(R1) args: 0, res: 0, upd: 0;
       cbz7J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubz8o: // global
           Sp = Sp + 16;
           call _cbz8k() args: 0, res: 0, upd: 0;
     }
 },
 _cbz7I() //  [R1]
         { info_tbl: [(cbz7I,
                       label: block_cbz7I_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz7I: // global
           if (R1 & 7 == 1) goto cbz89; else goto ubz8p;
       cbz89: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbz8c; else goto cbz8b;
       cbz8c: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz8b: // global
           I64[Hp - 24] = sat_sbyTy_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ubz8p: // global
           Sp = Sp + 8;
           call _cbz8k() args: 0, res: 0, upd: 0;
     }
 },
 _cbz8k() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz8k: // global
           P64[Sp + 16] = P64[Sp];
           Sp = Sp + 8;
           call _cbz7p() args: 0, res: 0, upd: 0;
     }
 },
 System.IO.readIO10_entry() //  [R2]
         { info_tbl: [(cbz8D,
                       label: System.IO.readIO10_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz8D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz8E; else goto cbz8F;
       cbz8E: // global
           R2 = R2;
           R1 = System.IO.readIO10_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbz8F: // global
           I64[Sp - 8] = block_cbz74_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubz8S; else goto cbz75;
       ubz8S: // global
           call _cbz74(R1) args: 0, res: 0, upd: 0;
       cbz75: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz74() //  [R1]
         { info_tbl: [(cbz74,
                       label: block_cbz74_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz74: // global
           if (R1 & 7 == 1) goto cbz8A; else goto cbz8B;
       cbz8A: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbz8B: // global
           I64[Sp - 8] = block_cbz7a_info;
           _sbyTi::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbyTi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubz8R; else goto cbz7b;
       ubz8R: // global
           call _cbz7a(R1) args: 0, res: 0, upd: 0;
       cbz7b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz7a() //  [R1]
         { info_tbl: [(cbz7a,
                       label: block_cbz7a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz7a: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbz8M; else goto cbz8L;
       cbz8M: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbz8L: // global
           _sbyTk::P64 = P64[R1 + 7];
           _sbyTl::P64 = P64[R1 + 15];
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sbyTk::P64;
           P64[Hp - 48] = GHC.Types.[]_closure+1;
           I64[Hp - 40] = z_sbyTn_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = go1_sbyTo_info;
           P64[Hp - 8] = Hp - 62;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbz8I_info;
           R3 = _sbyTl::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 8] = Hp - 15;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz8I() //  [R1]
         { info_tbl: [(cbz8I,
                       label: block_cbz8I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz8I: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sbyTo_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.10112612 UTC

[section ""data" . System.IO.readIO1_closure" {
     System.IO.readIO1_closure:
         const System.IO.readIO1_info;
         const 0;
 },
 System.IO.readIO1_entry() //  [R2, R3]
         { info_tbl: [(cbz8Z,
                       label: System.IO.readIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz8Z: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbz90; else goto cbz91;
       cbz90: // global
           R3 = R3;
           R2 = R2;
           R1 = System.IO.readIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbz91: // global
           I64[Sp - 8] = block_cbz8X_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           P64[Sp - 16] = R3;
           Sp = Sp - 32;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbz8X() //  [R1]
         { info_tbl: [(cbz8X,
                       label: block_cbz8X_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz8X: // global
           I64[Sp] = block_cbz94_info;
           R2 = R1;
           call System.IO.readIO10_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz94() //  [R1]
         { info_tbl: [(cbz94,
                       label: block_cbz94_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz94: // global
           if (R1 & 7 == 1) goto cbz9b; else goto cbz9g;
       cbz9b: // global
           R1 = System.IO.readIO6_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbz9g: // global
           I64[Sp - 8] = block_cbz9e_info;
           _sbyTJ::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sbyTJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubz9u; else goto cbz9h;
       ubz9u: // global
           call _cbz9e(R1) args: 0, res: 0, upd: 0;
       cbz9h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbz9e() //  [R1]
         { info_tbl: [(cbz9e,
                       label: block_cbz9e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz9e: // global
           if (R1 & 7 == 1) goto cbz9n; else goto cbz9r;
       cbz9n: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbz9r: // global
           R1 = System.IO.readIO2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.102664096 UTC

[section ""data" . System.IO.readIO_closure" {
     System.IO.readIO_closure:
         const System.IO.readIO_info;
         const 0;
 },
 System.IO.readIO_entry() //  [R2, R3]
         { info_tbl: [(cbz9z,
                       label: System.IO.readIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz9z: // global
           R3 = R3;
           R2 = R2;
           call System.IO.readIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.103547027 UTC

[section ""data" . System.IO.readLn1_closure" {
     System.IO.readLn1_closure:
         const System.IO.readLn1_info;
         const 0;
 },
 section ""relreadonly" . ubz9M_srtd" {
     ubz9M_srtd:
         const SbyXw_srt+56;
         const 36;
         const 38654705769;
 },
 System.IO.readLn1_entry() //  [R2]
         { info_tbl: [(cbz9I,
                       label: System.IO.readLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz9I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbz9J; else goto cbz9K;
       cbz9J: // global
           R2 = R2;
           R1 = System.IO.readLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbz9K: // global
           I64[Sp - 16] = block_cbz9G_info;
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           _sbyTO::P64 = R2;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           P64[Sp - 8] = _sbyTO::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz9G() //  [R1]
         { info_tbl: [(cbz9G,
                       label: block_cbz9G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz9G: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call System.IO.readIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.104689025 UTC

[section ""data" . System.IO.readLn_closure" {
     System.IO.readLn_closure:
         const System.IO.readLn_info;
         const 0;
 },
 System.IO.readLn_entry() //  [R2]
         { info_tbl: [(cbz9R,
                       label: System.IO.readLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz9R: // global
           R2 = R2;
           call System.IO.readLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.105804418 UTC

[section ""data" . System.IO.readFile1_closure" {
     System.IO.readFile1_closure:
         const System.IO.readFile1_info;
         const 0;
 },
 System.IO.readFile1_entry() //  [R2]
         { info_tbl: [(cbza0,
                       label: System.IO.readFile1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbza0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbza1; else goto cbza2;
       cbza1: // global
           R2 = R2;
           R1 = System.IO.readFile1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbza2: // global
           I64[Sp - 8] = block_cbz9Y_info;
           R3 = GHC.IO.IOMode.ReadMode_closure+1;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbz9Y() //  [R1]
         { info_tbl: [(cbz9Y,
                       label: block_cbz9Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbz9Y: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.106828725 UTC

[section ""data" . System.IO.readFile_closure" {
     System.IO.readFile_closure:
         const System.IO.readFile_info;
         const 0;
 },
 System.IO.readFile_entry() //  [R2]
         { info_tbl: [(cbza8,
                       label: System.IO.readFile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbza8: // global
           R2 = R2;
           call System.IO.readFile1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.107874983 UTC

[section ""data" . System.IO.interact1_closure" {
     System.IO.interact1_closure:
         const System.IO.interact1_info;
         const 0;
 },
 sat_sbyU3_entry() //  [R1]
         { info_tbl: [(cbzal,
                       label: sat_sbyU3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzal: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubzau_srtd" {
     ubzau_srtd:
         const SbyXw_srt;
         const 45;
         const 17592186078273;
 },
 System.IO.interact1_entry() //  [R2]
         { info_tbl: [(cbzao,
                       label: System.IO.interact1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzao: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzap; else goto cbzaq;
       cbzap: // global
           R2 = R2;
           R1 = System.IO.interact1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzaq: // global
           I64[Sp - 16] = block_cbzaf_info;
           _sbyTY::P64 = R2;
           R2 = GHC.IO.Handle.FD.stdin_closure;
           P64[Sp - 8] = _sbyTY::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzaf() //  [R1]
         { info_tbl: [(cbzaf,
                       label: block_cbzaf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzaf: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzat; else goto cbzas;
       cbzat: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzas: // global
           I64[Hp - 24] = sat_sbyU3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.109234906 UTC

[section ""data" . System.IO.interact_closure" {
     System.IO.interact_closure:
         const System.IO.interact_info;
         const 0;
 },
 System.IO.interact_entry() //  [R2]
         { info_tbl: [(cbzaz,
                       label: System.IO.interact_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzaz: // global
           R2 = R2;
           call System.IO.interact1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.109982288 UTC

[section ""cstring" . lvl2_rbyQa_bytes" {
     lvl2_rbyQa_bytes:
         I8[] [98,117,103,32,105,110,32,83,121,115,116,101,109,46,73,79,46,111,112,101,110,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.110742818 UTC

[section ""data" . lvl3_rbyQb_closure" {
     lvl3_rbyQb_closure:
         const lvl3_rbyQb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbyQb_entry() //  [R1]
         { info_tbl: [(cbzaK,
                       label: lvl3_rbyQb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzaK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzaL; else goto cbzaM;
       cbzaL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzaM: // global
           (_cbzaF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzaF::I64 == 0) goto cbzaH; else goto cbzaG;
       cbzaH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzaG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzaF::I64;
           I64[Sp - 24] = block_cbzaI_info;
           R2 = lvl2_rbyQa_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbzaI() //  [R1]
         { info_tbl: [(cbzaI,
                       label: block_cbzaI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzaI: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.111740778 UTC

[section ""data" . lvl4_rbyQc_closure" {
     lvl4_rbyQc_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.112506908 UTC

[section ""data" . lvl5_rbyQd_closure" {
     lvl5_rbyQd_closure:
         const lvl5_rbyQd_info;
 },
 lvl5_rbyQd_entry() //  [R2]
         { info_tbl: [(cbzaX,
                       label: lvl5_rbyQd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzaX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbzaY; else goto cbzaZ;
       cbzaY: // global
           R2 = R2;
           R1 = lvl5_rbyQd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzaZ: // global
           I64[Sp - 8] = block_cbzaU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzb7; else goto cbzaV;
       ubzb7: // global
           call _cbzaU(R1) args: 0, res: 0, upd: 0;
       cbzaV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzaU() //  [R1]
         { info_tbl: [(cbzaU,
                       label: block_cbzaU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzaU: // global
           if (I64[R1 + 7] == 46) goto cbzb6; else goto cbzb5;
       cbzb6: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbzb5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.113991635 UTC

[section ""data" . lvl6_rbyQe_closure" {
     lvl6_rbyQe_closure:
         const lvl6_rbyQe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rbyQe_entry() //  [R1]
         { info_tbl: [(cbzbl,
                       label: lvl6_rbyQe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzbl: // global
           _rbyQe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbzc4; else goto cbzc5;
       cbzc5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzc7; else goto cbzc6;
       cbzc7: // global
           HpAlloc = 16;
           goto cbzc4;
       cbzc4: // global
           R1 = _rbyQe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzc6: // global
           (_cbzbb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbyQe::P64);
           if (_cbzbb::I64 == 0) goto cbzbd; else goto cbzbc;
       cbzbd: // global
           call (I64[I64[_rbyQe::P64]])() args: 8, res: 0, upd: 8;
       cbzbc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzbb::I64;
           (_sbyUc::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_nonblock();
           (_sbyUg::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_noctty();
           (_sbyUk::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_creat();
           (_sbyUo::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_rdwr();
           (_sbyUs::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_excl();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUc::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUg::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUk::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUo::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUs::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.115632426 UTC

[section ""data" . $wlvl_rbyQf_closure" {
     $wlvl_rbyQf_closure:
         const $wlvl_rbyQf_info;
         const 0;
 },
 sat_sbyUN_entry() //  [R1]
         { info_tbl: [(cbzcl,
                       label: sat_sbyUN_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzcl: // global
           _sbyUN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbzcm; else goto cbzcn;
       cbzcn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzcp; else goto cbzco;
       cbzcp: // global
           HpAlloc = 16;
           goto cbzcm;
       cbzcm: // global
           R1 = _sbyUN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzco: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbyUN::P64;
           _sbyUJ::P64 = P64[_sbyUN::P64 + 16];
           _sbyUK::P64 = P64[_sbyUN::P64 + 24];
           _sbyUI::I64 = I64[_sbyUN::P64 + 32];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbyUK::P64;
           R5 = Hp - 6;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = _sbyUI::I64;
           R2 = _sbyUJ::P64;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyUO_entry() //  [R1]
         { info_tbl: [(cbzcq,
                       label: sat_sbyUO_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzcq: // global
           _sbyUO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbzcr; else goto cbzcs;
       cbzcs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbzcu; else goto cbzct;
       cbzcu: // global
           HpAlloc = 40;
           goto cbzcr;
       cbzcr: // global
           R1 = _sbyUO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzct: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbyUO::P64;
           _sbyUJ::P64 = P64[_sbyUO::P64 + 16];
           _sbyUK::P64 = P64[_sbyUO::P64 + 24];
           _sbyUI::I64 = I64[_sbyUO::P64 + 32];
           I64[Hp - 32] = sat_sbyUN_info;
           P64[Hp - 16] = _sbyUJ::P64;
           P64[Hp - 8] = _sbyUK::P64;
           I64[Hp] = _sbyUI::I64;
           R2 = Hp - 32;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rbyQf_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzcv,
                       label: $wlvl_rbyQf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzcv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbzcz; else goto cbzcy;
       cbzcz: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_rbyQf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzcy: // global
           I64[Hp - 32] = sat_sbyUO_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.117661601 UTC

[section ""data" . lvl7_rbyQg_closure" {
     lvl7_rbyQg_closure:
         const lvl7_rbyQg_info;
         const 0;
 },
 lvl7_rbyQg_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzcH,
                       label: lvl7_rbyQg_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzcH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzcI; else goto cbzcJ;
       cbzcI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl7_rbyQg_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzcJ: // global
           I64[Sp - 24] = block_cbzcE_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubzcN; else goto cbzcF;
       ubzcN: // global
           call _cbzcE(R1) args: 0, res: 0, upd: 0;
       cbzcF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzcE() //  [R1]
         { info_tbl: [(cbzcE,
                       label: block_cbzcE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzcE: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call $wlvl_rbyQf_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.119080129 UTC

[section ""data" . lvl8_rbyQh_closure" {
     lvl8_rbyQh_closure:
         const lvl8_rbyQh_info;
 },
 sat_sbyUZ_entry() //  [R1]
         { info_tbl: [(cbzcZ,
                       label: sat_sbyUZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzcZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzd6; else goto cbzd7;
       cbzd6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzd7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbzcW_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubzdb; else goto cbzcX;
       ubzdb: // global
           call _cbzcW(R1) args: 0, res: 0, upd: 0;
       cbzcX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzcW() //  [R1]
         { info_tbl: [(cbzcW,
                       label: block_cbzcW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzcW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzda; else goto cbzd9;
       cbzda: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzd9: // global
           _sbyUY::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbyUY::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_rbyQh_entry() //  [R2]
         { info_tbl: [(cbzdd,
                       label: lvl8_rbyQh_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzdd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbzdh; else goto cbzdg;
       cbzdh: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = lvl8_rbyQh_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzdg: // global
           I64[Hp - 40] = sat_sbyUZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.120770358 UTC

[section ""data" . go_rbyQi_closure" {
     go_rbyQi_closure:
         const go_rbyQi_info;
 },
 go_rbyQi_entry() //  [R2, R3]
         { info_tbl: [(cbzdt,
                       label: go_rbyQi_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzdt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzdu; else goto ubzdC;
       cbzdu: // global
           R3 = R3;
           R2 = R2;
           R1 = go_rbyQi_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubzdC: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbzdj() args: 0, res: 0, upd: 0;
     }
 },
 _cbzdj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzdj: // global
           _sbyV0::P64 = P64[Sp];
           I64[Sp] = block_cbzdm_info;
           R1 = _sbyV0::P64;
           if (R1 & 7 != 0) goto ubzdE; else goto cbzdn;
       ubzdE: // global
           call _cbzdm(R1) args: 0, res: 0, upd: 0;
       cbzdn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzdm() //  [R1]
         { info_tbl: [(cbzdm,
                       label: block_cbzdm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzdm: // global
           if (R1 & 7 == 1) goto cbzdq; else goto cbzdr;
       cbzdq: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbzdr: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cbzdj() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.122001706 UTC

[section ""cstring" . lvl9_rbyQj_bytes" {
     lvl9_rbyQj_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.122533047 UTC

[section ""cstring" . lvl10_rbyQk_bytes" {
     lvl10_rbyQk_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101,39,58,32,84,101,109,112,108,97,116,101,32,115,116,114,105,110,103,32,109,117,115,116,32,110,111,116,32,99,111,110,116,97,105,110,32,112,97,116,104,32,115,101,112,97,114,97,116,111,114,32,99,104,97,114,97,99,116,101,114,115,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.123281359 UTC

[section ""data" . lvl11_rbyQl_closure" {
     lvl11_rbyQl_closure:
         const lvl11_rbyQl_info;
         const 0;
 },
 lvl11_rbyQl_entry() //  [R2]
         { info_tbl: [(cbzdN,
                       label: lvl11_rbyQl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzdN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbzdO; else goto cbzdP;
       cbzdO: // global
           R2 = R2;
           R1 = lvl11_rbyQl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzdP: // global
           I64[Sp - 8] = block_cbzdL_info;
           R3 = R2;
           R2 = lvl10_rbyQk_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzdL() //  [R1]
         { info_tbl: [(cbzdL,
                       label: block_cbzdL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzdL: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.130001108 UTC

[section ""data" . System.IO.openBinaryTempFile5_closure" {
     System.IO.openBinaryTempFile5_closure:
         const System.IO.openBinaryTempFile5_info;
         const 0;
 },
 sat_sbyVl_entry() //  [R1]
         { info_tbl: [(cbzek,
                       label: sat_sbyVl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzek: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzel; else goto cbzem;
       cbzel: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzem: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyVs_entry() //  [R1]
         { info_tbl: [(cbzeB,
                       label: sat_sbyVs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzeB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzeC; else goto cbzeD;
       cbzeC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzeD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyVr_entry() //  [R1]
         { info_tbl: [(cbzeJ,
                       label: sat_sbyVr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzeJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzeK; else goto cbzeL;
       cbzeK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzeL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sbyVf_entry() //  [R1]
         { info_tbl: [(cbzeM,
                       label: ds_sbyVf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzeM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbzeN; else goto cbzeO;
       cbzeN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzeO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbze5_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbze5() //  [R1]
         { info_tbl: [(cbze5,
                       label: block_cbze5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbze5: // global
           I64[Sp] = block_cbze9_info;
           R3 = R1;
           R2 = lvl5_rbyQd_closure+1;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbze9() //  [R1, R2]
         { info_tbl: [(cbze9,
                       label: block_cbze9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbze9: // global
           I64[Sp - 8] = block_cbzeb_info;
           _sbyVi::P64 = R1;
           R1 = R2;
           P64[Sp] = _sbyVi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzf7; else goto cbzec;
       ubzf7: // global
           call _cbzeb(R1) args: 0, res: 0, upd: 0;
       cbzec: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzeb() //  [R1]
         { info_tbl: [(cbzeb,
                       label: block_cbzeb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzeb: // global
           if (R1 & 7 == 1) goto cbzeT; else goto cbzeY;
       cbzeT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbzeW; else goto cbzeV;
       cbzeW: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzeV: // global
           I64[Hp - 40] = sat_sbyVl_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbzeY: // global
           I64[Sp - 8] = block_cbzep_info;
           _sbyVn::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbyVn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzf8; else goto cbzeq;
       ubzf8: // global
           call _cbzep(R1) args: 0, res: 0, upd: 0;
       cbzeq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzep() //  [R1]
         { info_tbl: [(cbzep,
                       label: block_cbzep_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzep: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbzf1; else goto cbzf0;
       cbzf1: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzf0: // global
           if (I64[R1 + 7] == 46) goto cbzf5; else goto cbzf3;
       cbzf5: // global
           I64[Hp - 88] = sat_sbyVs_info;
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = lvl4_rbyQc_closure+1;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = sat_sbyVr_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbzf3: // global
           Hp = Hp - 96;
           R1 = lvl3_rbyQb_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 oflags_sbyVu_entry() //  [R1]
         { info_tbl: [(cbzfg,
                       label: oflags_sbyVu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzfg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbzfh; else goto cbzfi;
       cbzfh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzfi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbzfd_info;
           _sbyVb::P64 = P64[R1 + 16];
           R1 = lvl6_rbyQe_closure;
           P64[Sp - 24] = _sbyVb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubzfT; else goto cbzfe;
       ubzfT: // global
           call _cbzfd(R1) args: 0, res: 0, upd: 0;
       cbzfe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzfd() //  [R1]
         { info_tbl: [(cbzfd,
                       label: block_cbzfd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzfd: // global
           I64[Sp - 8] = block_cbzfl_info;
           _sbyVv::P64 = R1;
           _sbyVw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _sbyVw::I64;
           P64[Sp + 8] = _sbyVv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzfS; else goto cbzfn;
       ubzfS: // global
           call _cbzfl(R1) args: 0, res: 0, upd: 0;
       cbzfn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzfl() //  [R1]
         { info_tbl: [(cbzfl,
                       label: block_cbzfl_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzfl: // global
           if (R1 & 7 == 1) goto cbzft; else goto cbzfN;
       cbzft: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbzfN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzfQ; else goto cbzfP;
       cbzfQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzfP: // global
           _sbyVw::I64 = I64[Sp + 8];
           (_sbyVB::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_binary();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sbyVw::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyVB::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_sbyVH_entry() //  [R1, R2]
         { info_tbl: [(cbzg2,
                       label: lvl12_sbyVH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzg2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzgn; else goto cbzgo;
       cbzgn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzgo: // global
           I64[Sp - 24] = block_cbzfZ_info;
           _sbyVc::P64 = P64[R1 + 6];
           _sbyVu::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbyVc::P64;
           P64[Sp - 8] = _sbyVu::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubzgv; else goto cbzg0;
       ubzgv: // global
           call _cbzfZ(R1) args: 0, res: 0, upd: 0;
       cbzg0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzfZ() //  [R1]
         { info_tbl: [(cbzfZ,
                       label: block_cbzfZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzfZ: // global
           I64[Sp] = block_cbzg5_info;
           _sbyVL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sbyVL::I64;
           if (R1 & 7 != 0) goto ubzgu; else goto cbzg6;
       ubzgu: // global
           call _cbzg5(R1) args: 0, res: 0, upd: 0;
       cbzg6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzg5() //  [R1]
         { info_tbl: [(cbzg5,
                       label: block_cbzg5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzg5: // global
           I64[Sp] = block_cbzga_info;
           _sbyVN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sbyVN::I64;
           if (R1 & 7 != 0) goto ubzgw; else goto cbzgb;
       ubzgw: // global
           call _cbzga(R1) args: 0, res: 0, upd: 0;
       cbzgb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzga() //  [R1]
         { info_tbl: [(cbzga,
                       label: block_cbzga_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzga: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzgt; else goto cbzgs;
       cbzgt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzgs: // global
           (_sbyVT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     signed,]  result hints:  [signed] __hscore_open(I64[Sp + 16], I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyVT::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyVX_entry() //  [R1]
         { info_tbl: [(cbzgF,
                       label: sat_sbyVX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzgF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzgG; else goto cbzgH;
       cbzgG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzgH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.List.lastError_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_rbyQi_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl13_sbyVW_entry() //  [R1]
         { info_tbl: [(cbzgJ,
                       label: lvl13_sbyVW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzgJ: // global
           _sbyVW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbzgK; else goto cbzgL;
       cbzgL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbzgN; else goto cbzgM;
       cbzgN: // global
           HpAlloc = 48;
           goto cbzgK;
       cbzgK: // global
           R1 = _sbyVW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzgM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbyVW::P64;
           _sbyV9::P64 = P64[_sbyVW::P64 + 16];
           I64[Hp - 40] = sat_sbyVX_info;
           P64[Hp - 24] = _sbyV9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R4 = Hp - 14;
           R3 = pathSeparatorChar_rbxCK_closure+1;
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp - 16;
           call GHC.List.elem_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyWv_entry() //  [R1]
         { info_tbl: [(cbzhy,
                       label: sat_sbyWv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzhy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbzhE; else goto cbzhF;
       cbzhE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzhF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbzhv_info;
           _sbyWj::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbyWj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubzhK; else goto cbzhw;
       ubzhK: // global
           call _cbzhv(R1) args: 0, res: 0, upd: 0;
       cbzhw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzhv() //  [R1]
         { info_tbl: [(cbzhv,
                       label: block_cbzhv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzhv: // global
           I64[Sp] = block_cbzhB_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbzhB() //  [R1, R2]
         { info_tbl: [(cbzhB,
                       label: block_cbzhB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzhB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbzhJ; else goto cbzhI;
       cbzhJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbzhI: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyWw_entry() //  [R1]
         { info_tbl: [(cbzhL,
                       label: sat_sbyWw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzhL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzhP; else goto cbzhO;
       cbzhP: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzhO: // global
           _sbyWc::P64 = P64[R1 + 16];
           _sbyWj::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbyWv_info;
           P64[Hp - 8] = _sbyWc::P64;
           P64[Hp] = _sbyWj::P64;
           R3 = Hp - 24;
           R2 = lvl9_rbyQj_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyWx_entry() //  [R1]
         { info_tbl: [(cbzhQ,
                       label: sat_sbyWx_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzhQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzhS; else goto cbzhT;
       cbzhS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzhT: // global
           I64[Sp - 24] = block_cbzhl_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 32]));
           R2 = 0;
           P64[Sp - 16] = P64[R1 + 16];
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzhl() //  [R1, R2]
         { info_tbl: [(cbzhl,
                       label: block_cbzhl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzhl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbzhW; else goto cbzhV;
       cbzhW: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cbzhV: // global
           I64[Hp - 48] = sat_sbyWw_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 filepath_sbyWg_entry() //  [R1]
         { info_tbl: [(cbzhX,
                       label: filepath_sbyWg_info
                       rep:HeapRep 4 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzhX: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbzhY; else goto cbzhZ;
       cbzhY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzhZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cbzh9_info;
           _sbyV9::P64 = P64[R1 + 16];
           _sbyVW::P64 = P64[R1 + 32];
           _sbyWc::P64 = P64[R1 + 40];
           _sbyW7::I64 = I64[R1 + 48];
           R1 = P64[R1 + 24];
           P64[Sp - 48] = _sbyV9::P64;
           P64[Sp - 40] = _sbyVW::P64;
           I64[Sp - 32] = _sbyW7::I64;
           P64[Sp - 24] = _sbyWc::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ubziI; else goto cbzha;
       ubziI: // global
           call _cbzh9(R1) args: 0, res: 0, upd: 0;
       cbzha: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzh9() //  [R1]
         { info_tbl: [(cbzh9,
                       label: block_cbzh9_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzh9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbzi3; else goto cbzi2;
       cbzi3: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzi2: // global
           _sbyWi::P64 = P64[R1 + 7];
           _sbyWj::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sbyWx_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = _sbyWj::P64;
           I64[Hp] = I64[Sp + 24];
           I64[Sp] = block_cbzi0_info;
           R3 = Hp - 32;
           R2 = _sbyWi::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbzi0() //  [R1]
         { info_tbl: [(cbzi0,
                       label: block_cbzi0_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzi0: // global
           _sbyV9::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbzi9; else goto cbzie;
       cbzi9: // global
           R1 = _sbyV9::P64 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbzie: // global
           I64[Sp + 8] = block_cbzic_info;
           _sbyWy::P64 = R1;
           R1 = _sbyV9::P64;
           P64[Sp + 32] = _sbyWy::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubziJ; else goto cbzif;
       ubziJ: // global
           call _cbzic(R1) args: 0, res: 0, upd: 0;
       cbzif: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzic() //  [R1]
         { info_tbl: [(cbzic,
                       label: block_cbzic_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzic: // global
           if (R1 & 7 == 1) goto cbzil; else goto cbziq;
       cbzil: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbziq: // global
           _sbyVW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbzio_info;
           _sbyWB::P64 = R1;
           R1 = _sbyVW::P64;
           P64[Sp + 16] = _sbyWB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubziK; else goto cbzir;
       ubziK: // global
           call _cbzio(R1) args: 0, res: 0, upd: 0;
       cbzir: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzio() //  [R1]
         { info_tbl: [(cbzio,
                       label: block_cbzio_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzio: // global
           _sbyWy::P64 = P64[Sp + 16];
           _sbyWB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbzix; else goto cbziE;
       cbzix: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbziA; else goto cbziz;
       cbziA: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbziz: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = pathSeparatorChar_rbxCK_closure+1;
           P64[Hp] = _sbyWy::P64;
           R3 = Hp - 14;
           R2 = _sbyWB::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbziE: // global
           R3 = _sbyWy::P64;
           R2 = _sbyWB::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.IO.openBinaryTempFile5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbziP,
                       label: System.IO.openBinaryTempFile5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbziP: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbziQ; else goto cbziR;
       cbziQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.openBinaryTempFile5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbziR: // global
           I64[Sp - 48] = block_cbzdX_info;
           _sbyVa::P64 = R4;
           R4 = R4;
           _sbyV9::P64 = R3;
           R3 = pathSeparatorChar_rbxCK_closure+1;
           _sbyV8::P64 = R2;
           R2 = GHC.Classes.$fEqChar_closure;
           P64[Sp - 40] = _sbyV8::P64;
           P64[Sp - 32] = _sbyV9::P64;
           P64[Sp - 24] = _sbyVa::P64;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzdX() //  [R1]
         { info_tbl: [(cbzdX,
                       label: block_cbzdX_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzdX: // global
           _sbyVa::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cbziM; else goto cbziN;
       cbziM: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbziU; else goto cbziT;
       cbziU: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbziT: // global
           I64[Hp - 88] = ds_sbyVf_info;
           P64[Hp - 72] = _sbyVa::P64;
           I64[Hp - 64] = oflags_sbyVu_info;
           P64[Hp - 48] = P64[Sp + 32];
           I64[Hp - 40] = lvl12_sbyVH_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = lvl13_sbyVW_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 38;
           P64[Sp + 40] = Hp - 88;
           Sp = Sp + 8;
           call _cbzgT() args: 0, res: 0, upd: 0;
       cbziN: // global
           R2 = _sbyVa::P64;
           Sp = Sp + 48;
           call lvl11_rbyQl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbzgT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzgT: // global
           (_sbyW7::I64) = call "ccall" arg hints:  []  result hints:  [signed] getpid();
           I64[Sp - 16] = block_cbzgW_info;
           R1 = tempCounter_rbxCH_closure;
           I64[Sp - 8] = _sbyW7::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubzkI; else goto cbzgX;
       ubzkI: // global
           call _cbzgW(R1) args: 0, res: 0, upd: 0;
       cbzgX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzgW() //  [R1]
         { info_tbl: [(cbzgW,
                       label: block_cbzgW_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzgW: // global
           I64[Sp] = block_cbzh1_info;
           R2 = lvl8_rbyQh_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzh1() //  [R1]
         { info_tbl: [(cbzh1,
                       label: block_cbzh1_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzh1: // global
           I64[Sp - 8] = block_cbzh3_info;
           _sbyWc::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp] = _sbyWc::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzh3() //  [R1]
         { info_tbl: [(cbzh3,
                       label: block_cbzh3_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzh3: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbzj7; else goto cbzj6;
       cbzj7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzj6: // global
           I64[Hp - 48] = filepath_sbyWg_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 56];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 8] = block_cbziZ_info;
           R4 = P64[Sp + 48];
           _cbzh5::P64 = Hp - 48;
           R3 = _cbzh5::P64;
           R2 = R1;
           P64[Sp + 16] = _cbzh5::P64;
           Sp = Sp + 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbziZ() //  [R1]
         { info_tbl: [(cbziZ,
                       label: block_cbziZ_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbziZ: // global
           I64[Sp] = block_cbzj1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubzkJ; else goto cbzj9;
       ubzkJ: // global
           call _cbzj1(R1) args: 0, res: 0, upd: 0;
       cbzj9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzj1() //  [R1]
         { info_tbl: [(cbzj1,
                       label: block_cbzj1_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzj1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzjf; else goto cbzje;
       cbzjf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzje: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cbzk6; else goto cbzkr;
       cbzk6: // global
           I64[Hp - 8] = System.IO.NewFileCreated_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 7;
           goto ubzkM;
       cbzkr: // global
           (_sbyXd::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_get_errno();
           Hp = Hp - 16;
           _sbyXe::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyXd::I64));
           if (_sbyXe::I64 != 17) goto ubzkC; else goto cbzkn;
       ubzkC: // global
           I64[Sp] = _sbyXe::I64;
           call _cbzkg() args: 0, res: 0, upd: 0;
       cbzkn: // global
           P64[Sp] = System.IO.FileExists_closure+2;
           goto ubzkM;
       ubzkM: // global
           call _sbyWL() args: 0, res: 0, upd: 0;
     }
 },
 _cbzkg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzkg: // global
           Hp = Hp + 32;
           _sbyXe::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cbzkk; else goto cbzkj;
       cbzkk: // global
           HpAlloc = 32;
           I64[Sp] = block_cbzkd_info;
           R1 = _sbyXe::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbzkj: // global
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = _sbyXe::I64;
           I64[Hp - 8] = System.IO.OpenNewError_con_info;
           P64[Hp] = Hp - 23;
           P64[Sp] = Hp - 5;
           call _sbyWL() args: 0, res: 0, upd: 0;
     }
 },
 _cbzkd() //  [R1]
         { info_tbl: [(cbzkd,
                       label: block_cbzkd_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzkd: // global
           I64[Sp] = R1;
           call _cbzkg() args: 0, res: 0, upd: 0;
     }
 },
 _sbyWL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbyWL: // global
           _sbyWN::P64 = P64[Sp];
           I64[Sp] = block_cbzjl_info;
           R1 = _sbyWN::P64;
           if (R1 & 7 != 0) goto ubzkS; else goto cbzjn;
       ubzkS: // global
           call _cbzjl(R1) args: 0, res: 0, upd: 0;
       cbzjn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzjl() //  [R1]
         { info_tbl: [(cbzjl,
                       label: block_cbzjl_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzjl: // global
           _cbzky::P64 = R1 & 7;
           if (_cbzky::P64 < 3) goto ubzkz; else goto cbzk2;
       ubzkz: // global
           if (_cbzky::P64 < 2) goto cbzjL; else goto ubzkG;
       cbzjL: // global
           I64[Sp] = block_cbzjr_info;
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R2 = P64[R1 + 7];
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       ubzkG: // global
           Sp = Sp + 16;
           call _cbzgT() args: 0, res: 0, upd: 0;
       cbzk2: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[R1 + 5];
           Sp = Sp + 56;
           call lvl7_rbyQg_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbzjr() //  [R1]
         { info_tbl: [(cbzjr,
                       label: block_cbzjr_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzjr: // global
           I64[Sp] = block_cbzjt_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubzkO; else goto cbzju;
       ubzkO: // global
           call _cbzjt(R1) args: 0, res: 0, upd: 0;
       cbzju: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzjt() //  [R1]
         { info_tbl: [(cbzjt,
                       label: block_cbzjt_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzjt: // global
           I64[Sp] = block_cbzjy_info;
           _sbyWU::P64 = P64[R1 + 7];
           _sbyWV::P64 = P64[R1 + 15];
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           P64[Sp + 40] = _sbyWV::P64;
           P64[Sp + 48] = _sbyWU::P64;
           if (R1 & 7 != 0) goto ubzkP; else goto cbzjz;
       ubzkP: // global
           call _cbzjy(R1) args: 0, res: 0, upd: 0;
       cbzjz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzjy() //  [R1]
         { info_tbl: [(cbzjy,
                       label: block_cbzjy_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzjy: // global
           I64[Sp] = block_cbzjD_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzjD() //  [R1]
         { info_tbl: [(cbzjD,
                       label: block_cbzjD_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzjD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzjR; else goto cbzjQ;
       cbzjR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzjQ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           I64[Sp] = block_cbzjG_info;
           R6 = GHC.Types.False_closure+1;
           R5 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbzjG() //  [R1]
         { info_tbl: [(cbzjG,
                       label: block_cbzjG_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzjG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbzjU; else goto cbzjT;
       cbzjU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzjT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.142756314 UTC

[section ""cstring" . System.IO.openBinaryTempFileWithDefaultPermissions4_bytes" {
     System.IO.openBinaryTempFileWithDefaultPermissions4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,84,101,109,112,70,105,108,101,87,105,116,104,68,101,102,97,117,108,116,80,101,114,109,105,115,115,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.143590027 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions3_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions3_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions3_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions3_entry() //  [R1]
         { info_tbl: [(cbzkZ,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzkZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzl0; else goto cbzl1;
       cbzl0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzl1: // global
           (_cbzkW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzkW::I64 == 0) goto cbzkY; else goto cbzkX;
       cbzkY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzkX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzkW::I64;
           R2 = System.IO.openBinaryTempFileWithDefaultPermissions4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.144470361 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions2_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions2_closure:
         const GHC.Word.W32#_con_info;
         const 438;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.145201855 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions1_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions1_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions1_info;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions1_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cbzl6,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzl6: // global
           R6 = System.IO.openBinaryTempFileWithDefaultPermissions2_closure+1;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openBinaryTempFileWithDefaultPermissions3_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.146143299 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions_info;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cbzld,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzld: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openBinaryTempFileWithDefaultPermissions1_entry(R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.146855767 UTC

[section ""cstring" . System.IO.openTempFileWithDefaultPermissions3_bytes" {
     System.IO.openTempFileWithDefaultPermissions3_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101,87,105,116,104,68,101,102,97,117,108,116,80,101,114,109,105,115,115,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.147576154 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions2_closure" {
     System.IO.openTempFileWithDefaultPermissions2_closure:
         const System.IO.openTempFileWithDefaultPermissions2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions2_entry() //  [R1]
         { info_tbl: [(cbzlm,
                       label: System.IO.openTempFileWithDefaultPermissions2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzlm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzln; else goto cbzlo;
       cbzln: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzlo: // global
           (_cbzlj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzlj::I64 == 0) goto cbzll; else goto cbzlk;
       cbzll: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzlk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzlj::I64;
           R2 = System.IO.openTempFileWithDefaultPermissions3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.1485553 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions1_closure" {
     System.IO.openTempFileWithDefaultPermissions1_closure:
         const System.IO.openTempFileWithDefaultPermissions1_info;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions1_entry() //  [R2, R3]
         { info_tbl: [(cbzlt,
                       label: System.IO.openTempFileWithDefaultPermissions1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzlt: // global
           R6 = System.IO.openBinaryTempFileWithDefaultPermissions2_closure+1;
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openTempFileWithDefaultPermissions2_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.149654902 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions_closure" {
     System.IO.openTempFileWithDefaultPermissions_closure:
         const System.IO.openTempFileWithDefaultPermissions_info;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions_entry() //  [R2, R3]
         { info_tbl: [(cbzlA,
                       label: System.IO.openTempFileWithDefaultPermissions_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzlA: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openTempFileWithDefaultPermissions1_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.150381711 UTC

[section ""cstring" . System.IO.openBinaryTempFile4_bytes" {
     System.IO.openBinaryTempFile4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.151073452 UTC

[section ""data" . System.IO.openBinaryTempFile3_closure" {
     System.IO.openBinaryTempFile3_closure:
         const System.IO.openBinaryTempFile3_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openBinaryTempFile3_entry() //  [R1]
         { info_tbl: [(cbzlJ,
                       label: System.IO.openBinaryTempFile3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzlJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzlK; else goto cbzlL;
       cbzlK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzlL: // global
           (_cbzlG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzlG::I64 == 0) goto cbzlI; else goto cbzlH;
       cbzlI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzlH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzlG::I64;
           R2 = System.IO.openBinaryTempFile4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.151992836 UTC

[section ""data" . System.IO.openBinaryTempFile2_closure" {
     System.IO.openBinaryTempFile2_closure:
         const GHC.Word.W32#_con_info;
         const 384;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.152680771 UTC

[section ""data" . System.IO.openBinaryTempFile1_closure" {
     System.IO.openBinaryTempFile1_closure:
         const System.IO.openBinaryTempFile1_info;
         const 0;
 },
 System.IO.openBinaryTempFile1_entry() //  [R2, R3]
         { info_tbl: [(cbzlQ,
                       label: System.IO.openBinaryTempFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzlQ: // global
           R6 = System.IO.openBinaryTempFile2_closure+1;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openBinaryTempFile3_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.153720511 UTC

[section ""data" . System.IO.openBinaryTempFile_closure" {
     System.IO.openBinaryTempFile_closure:
         const System.IO.openBinaryTempFile_info;
         const 0;
 },
 System.IO.openBinaryTempFile_entry() //  [R2, R3]
         { info_tbl: [(cbzlX,
                       label: System.IO.openBinaryTempFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzlX: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openBinaryTempFile1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.154470258 UTC

[section ""cstring" . System.IO.openTempFile3_bytes" {
     System.IO.openTempFile3_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.155169536 UTC

[section ""data" . System.IO.openTempFile2_closure" {
     System.IO.openTempFile2_closure:
         const System.IO.openTempFile2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openTempFile2_entry() //  [R1]
         { info_tbl: [(cbzm6,
                       label: System.IO.openTempFile2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzm6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzm7; else goto cbzm8;
       cbzm7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzm8: // global
           (_cbzm3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzm3::I64 == 0) goto cbzm5; else goto cbzm4;
       cbzm5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzm4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzm3::I64;
           R2 = System.IO.openTempFile3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.156123974 UTC

[section ""data" . System.IO.openTempFile1_closure" {
     System.IO.openTempFile1_closure:
         const System.IO.openTempFile1_info;
         const 0;
 },
 System.IO.openTempFile1_entry() //  [R2, R3]
         { info_tbl: [(cbzmd,
                       label: System.IO.openTempFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzmd: // global
           R6 = System.IO.openBinaryTempFile2_closure+1;
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openTempFile2_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.157011697 UTC

[section ""data" . System.IO.openTempFile_closure" {
     System.IO.openTempFile_closure:
         const System.IO.openTempFile_info;
         const 0;
 },
 System.IO.openTempFile_entry() //  [R2, R3]
         { info_tbl: [(cbzmk,
                       label: System.IO.openTempFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzmk: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openTempFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.159968269 UTC

[section ""data" . System.IO.NewFileCreated_closure" {
     System.IO.NewFileCreated_closure:
         const System.IO.NewFileCreated_info;
 },
 System.IO.NewFileCreated_entry() //  [R2]
         { info_tbl: [(cbzms,
                       label: System.IO.NewFileCreated_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzms: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzmw; else goto cbzmv;
       cbzmw: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = System.IO.NewFileCreated_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzmv: // global
           I64[Hp - 8] = System.IO.NewFileCreated_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.160770476 UTC

[section ""data" . System.IO.FileExists_closure" {
     System.IO.FileExists_closure:
         const System.IO.FileExists_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.161653347 UTC

[section ""data" . System.IO.OpenNewError_closure" {
     System.IO.OpenNewError_closure:
         const System.IO.OpenNewError_info;
 },
 System.IO.OpenNewError_entry() //  [R2]
         { info_tbl: [(cbzmC,
                       label: System.IO.OpenNewError_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzmC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzmG; else goto cbzmF;
       cbzmG: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = System.IO.OpenNewError_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzmF: // global
           I64[Hp - 8] = System.IO.OpenNewError_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.16246366 UTC

[System.IO.NewFileCreated_con_entry() //  [R1]
         { info_tbl: [(cbzmH,
                       label: System.IO.NewFileCreated_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,78,101,119,70,105,108,101,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzmH: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.163188903 UTC

[System.IO.FileExists_con_entry() //  [R1]
         { info_tbl: [(cbzmI,
                       label: System.IO.FileExists_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,70,105,108,101,69,120,105,115,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzmI: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.163879151 UTC

[System.IO.OpenNewError_con_entry() //  [R1]
         { info_tbl: [(cbzmJ,
                       label: System.IO.OpenNewError_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,79,112,101,110,78,101,119,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzmJ: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.164491255 UTC

[section ""relreadonly" . SbyXw_srt" {
     SbyXw_srt:
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutChar1_closure;
         const System.IO.putChar1_closure;
         const GHC.IO.Handle.Text.hPutStr_closure;
         const GHC.IO.Handle.Text.hPutStrLn_closure;
         const System.IO.print_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.hGetChar2_closure;
         const GHC.IO.Handle.Text.hGetChar6_closure;
         const GHC.IO.Handle.FD.stdin_closure;
         const System.IO.getChar1_closure;
         const GHC.IO.Handle.Text.hGetLine2_closure;
         const GHC.IO.Handle.Text.hGetLine4_closure;
         const System.IO.getLine1_closure;
         const GHC.IO.Handle.Text.hGetContents1_closure;
         const System.IO.getContents1_closure;
         const GHC.IO.Handle.Text.hWaitForInput1_closure;
         const System.IO.hReady1_closure;
         const System.IO.hPrint_closure;
         const GHC.IO.Handle.hClose1_closure;
         const GHC.IO.Handle.FD.openFile1_closure;
         const System.IO.appendFile2_closure;
         const System.IO.appendFile1_closure;
         const System.IO.writeFile1_closure;
         const GHC.IO.Handle.FD.openBinaryFile1_closure;
         const System.IO.withBinaryFile1_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
         const lvl1_rbyQ9_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const System.IO.fixIO2_closure;
         const System.IO.fixIO3_closure;
         const System.IO.fixIO1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const System.IO.readIO7_closure;
         const System.IO.readIO3_closure;
         const System.IO.readIO10_closure;
         const GHC.Read.lex1_closure;
         const System.IO.readIO1_closure;
         const System.IO.readIO2_closure;
         const System.IO.readIO6_closure;
         const System.IO.readLn1_closure;
         const System.IO.readFile1_closure;
         const System.IO.interact1_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const $wlvl_rbyQf_closure;
         const lvl7_rbyQg_closure;
         const GHC.IO.failIO1_closure;
         const lvl11_rbyQl_closure;
         const lvl3_rbyQb_closure;
         const lvl6_rbyQe_closure;
         const GHC.List.lastError_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.Handle.FD.fdToHandle5_closure;
         const tempCounter_rbxCH_closure;
         const System.IO.openBinaryTempFile5_closure;
         const System.IO.openBinaryTempFileWithDefaultPermissions3_closure;
         const System.IO.openBinaryTempFileWithDefaultPermissions1_closure;
         const System.IO.openTempFileWithDefaultPermissions2_closure;
         const System.IO.openTempFileWithDefaultPermissions1_closure;
         const System.IO.openBinaryTempFile3_closure;
         const System.IO.openBinaryTempFile1_closure;
         const System.IO.openTempFile2_closure;
         const System.IO.openTempFile1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.165502408 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:30.166078754 UTC

[section ""data" . System.IO.putChar1_closure" {
     System.IO.putChar1_closure:
         const System.IO.putChar1_info;
         const 0;
 },
 System.IO.putChar1_entry() //  [R2]
         { info_tbl: [(cbzmO,
                       label: System.IO.putChar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzmO: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutChar1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.166897494 UTC

[section ""data" . System.IO.putChar_closure" {
     System.IO.putChar_closure:
         const System.IO.putChar_info;
         const 0;
 },
 System.IO.putChar_entry() //  [R2]
         { info_tbl: [(cbzmV,
                       label: System.IO.putChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzmV: // global
           R2 = R2;
           call System.IO.putChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.167683067 UTC

[section ""data" . System.IO.putStr_closure" {
     System.IO.putStr_closure:
         const System.IO.putStr_info;
         const 0;
 },
 System.IO.putStr_entry() //  [R2]
         { info_tbl: [(cbzn2,
                       label: System.IO.putStr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzn2: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.168496275 UTC

[section ""data" . System.IO.putStrLn_closure" {
     System.IO.putStrLn_closure:
         const System.IO.putStrLn_info;
         const 0;
 },
 System.IO.putStrLn_entry() //  [R2]
         { info_tbl: [(cbzn9,
                       label: System.IO.putStrLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzn9: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutStrLn_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.169599906 UTC

[section ""data" . System.IO.print_closure" {
     System.IO.print_closure:
         const System.IO.print_info;
         const 0;
 },
 sat_sbyQs_entry() //  [R1]
         { info_tbl: [(cbznk,
                       label: sat_sbyQs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbznk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbznl; else goto cbznm;
       cbznl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbznm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 System.IO.print_entry() //  [R2, R3]
         { info_tbl: [(cbznn,
                       label: System.IO.print_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbznn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbznr; else goto cbznq;
       cbznr: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.print_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbznq: // global
           I64[Hp - 24] = sat_sbyQs_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = GHC.Types.True_closure+2;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.170790716 UTC

[section ""data" . System.IO.getChar1_closure" {
     System.IO.getChar1_closure:
         const System.IO.getChar1_info;
         const 0;
 },
 System.IO.getChar1_entry() //  []
         { info_tbl: [(cbznw,
                       label: System.IO.getChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbznw: // global
           R4 = GHC.IO.Handle.Text.hGetChar2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.Text.hGetChar6_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.171619583 UTC

[section ""data" . System.IO.getChar_closure" {
     System.IO.getChar_closure:
         const System.IO.getChar_info;
         const 0;
 },
 System.IO.getChar_entry() //  []
         { info_tbl: [(cbznD,
                       label: System.IO.getChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbznD: // global
           call System.IO.getChar1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.17241911 UTC

[section ""data" . System.IO.getLine1_closure" {
     System.IO.getLine1_closure:
         const System.IO.getLine1_info;
         const 0;
 },
 System.IO.getLine1_entry() //  []
         { info_tbl: [(cbznK,
                       label: System.IO.getLine1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbznK: // global
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.173557173 UTC

[section ""data" . System.IO.getLine_closure" {
     System.IO.getLine_closure:
         const System.IO.getLine_info;
         const 0;
 },
 System.IO.getLine_entry() //  []
         { info_tbl: [(cbznR,
                       label: System.IO.getLine_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbznR: // global
           call System.IO.getLine1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.174343562 UTC

[section ""data" . System.IO.getContents1_closure" {
     System.IO.getContents1_closure:
         const System.IO.getContents1_info;
         const 0;
 },
 System.IO.getContents1_entry() //  []
         { info_tbl: [(cbznY,
                       label: System.IO.getContents1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbznY: // global
           R2 = GHC.IO.Handle.FD.stdin_closure;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.175119016 UTC

[section ""data" . System.IO.getContents_closure" {
     System.IO.getContents_closure:
         const System.IO.getContents_info;
         const 0;
 },
 System.IO.getContents_entry() //  []
         { info_tbl: [(cbzo5,
                       label: System.IO.getContents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzo5: // global
           call System.IO.getContents1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.175807213 UTC

[section ""data" . System.IO.localeEncoding_closure" {
     System.IO.localeEncoding_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Encoding.initLocaleEncoding_closure;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.17643193 UTC

[section ""data" . System.IO.hReady2_closure" {
     System.IO.hReady2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.1770717 UTC

[section ""data" . System.IO.hReady1_closure" {
     System.IO.hReady1_closure:
         const System.IO.hReady1_info;
         const 0;
 },
 System.IO.hReady1_entry() //  [R2]
         { info_tbl: [(cbzoc,
                       label: System.IO.hReady1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzoc: // global
           R3 = System.IO.hReady2_closure+1;
           R2 = R2;
           call GHC.IO.Handle.Text.hWaitForInput1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.177942287 UTC

[section ""data" . System.IO.hReady_closure" {
     System.IO.hReady_closure:
         const System.IO.hReady_info;
         const 0;
 },
 System.IO.hReady_entry() //  [R2]
         { info_tbl: [(cbzoj,
                       label: System.IO.hReady_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzoj: // global
           R2 = R2;
           call System.IO.hReady1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.179032943 UTC

[section ""data" . System.IO.hPrint_closure" {
     System.IO.hPrint_closure:
         const System.IO.hPrint_info;
         const 0;
 },
 sat_sbyQy_entry() //  [R1]
         { info_tbl: [(cbzou,
                       label: sat_sbyQy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzou: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbzov; else goto cbzow;
       cbzov: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzow: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 System.IO.hPrint_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzox,
                       label: System.IO.hPrint_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzox: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzoB; else goto cbzoA;
       cbzoB: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.hPrint_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzoA: // global
           I64[Hp - 24] = sat_sbyQy_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R4 = GHC.Types.True_closure+2;
           _sbyQw::P64 = R3;
           R3 = Hp - 24;
           R2 = _sbyQw::P64;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.182123021 UTC

[section ""data" . System.IO.appendFile2_closure" {
     System.IO.appendFile2_closure:
         const System.IO.appendFile2_info;
         const 0;
 },
 sat_sbyQR_entry() //  [R1, R2]
         { info_tbl: [(cbzoT,
                       label: sat_sbyQR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzoT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzoU; else goto cbzoV;
       cbzoU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzoV: // global
           I64[Sp - 16] = block_cbzoR_info;
           _sbyQM::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyQM::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzoR() //  []
         { info_tbl: [(cbzoR,
                       label: block_cbzoR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzoR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyQL_entry() //  [R1]
         { info_tbl: [(cbzp3,
                       label: sat_sbyQL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzp3: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyR9_entry() //  [R1, R2]
         { info_tbl: [(cbzpl,
                       label: sat_sbyR9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzpl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzpm; else goto cbzpn;
       cbzpm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzpn: // global
           I64[Sp - 16] = block_cbzpj_info;
           _sbyR4::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyR4::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzpj() //  []
         { info_tbl: [(cbzpj,
                       label: block_cbzpj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzpj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyR3_entry() //  [R1]
         { info_tbl: [(cbzpv,
                       label: sat_sbyR3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzpv: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRg_entry() //  [R1]
         { info_tbl: [(cbzpC,
                       label: sat_sbyRg_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzpC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzpD; else goto cbzpE;
       cbzpD: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbzpE: // global
           I64[Sp - 16] = block_cbzpc_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzpc() //  [R1]
         { info_tbl: [(cbzpc,
                       label: block_cbzpc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzpc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbzpH; else goto cbzpG;
       cbzpH: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzpG: // global
           I64[Hp - 56] = sat_sbyR9_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyR3_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzpy_info;
           R2 = Hp - 54;
           _sbyR1::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyR1::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzpy() //  [R1]
         { info_tbl: [(cbzpy,
                       label: block_cbzpy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzpy: // global
           I64[Sp] = block_cbzpA_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzpA() //  []
         { info_tbl: [(cbzpA,
                       label: block_cbzpA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzpA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRr_entry() //  [R1, R2]
         { info_tbl: [(cbzpU,
                       label: sat_sbyRr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzpU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzpV; else goto cbzpW;
       cbzpV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzpW: // global
           I64[Sp - 16] = block_cbzpS_info;
           _sbyRm::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyRm::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzpS() //  []
         { info_tbl: [(cbzpS,
                       label: block_cbzpS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzpS: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRl_entry() //  [R1]
         { info_tbl: [(cbzq4,
                       label: sat_sbyRl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzq4: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.appendFile2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzqb,
                       label: System.IO.appendFile2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzqb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbzqc; else goto cbzqd;
       cbzqc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.appendFile2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzqd: // global
           I64[Sp - 32] = block_cbzoG_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbzoG() //  [R1]
         { info_tbl: [(cbzoG,
                       label: block_cbzoG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzoG: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzqg; else goto cbzqf;
       cbzqg: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbzqf: // global
           _sbyQz::P64 = P64[Sp + 8];
           _sbyQA::P64 = P64[Sp + 16];
           if (R1 == 0) goto cbzq9; else goto ubzqz;
       cbzq9: // global
           I64[Hp - 24] = sat_sbyRg_info;
           P64[Hp - 16] = _sbyQz::P64;
           P64[Hp - 8] = _sbyQA::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ubzqz: // global
           if (R1 == 1) goto cbzqa; else goto cbzq8;
       cbzqa: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbzpL_info;
           R3 = _sbyQA::P64;
           R2 = _sbyQz::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       cbzq8: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbzoK_info;
           R3 = _sbyQA::P64;
           R2 = _sbyQz::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzpL() //  [R1]
         { info_tbl: [(cbzpL,
                       label: block_cbzpL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzpL: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbzqv; else goto cbzqu;
       cbzqv: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzqu: // global
           I64[Hp - 56] = sat_sbyRr_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyRl_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzqq_info;
           R2 = Hp - 54;
           _sbyRj::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyRj::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzqq() //  [R1]
         { info_tbl: [(cbzqq,
                       label: block_cbzqq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzqq: // global
           I64[Sp] = block_cbzqs_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzqs() //  []
         { info_tbl: [(cbzqs,
                       label: block_cbzqs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzqs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbzoK() //  [R1]
         { info_tbl: [(cbzoK,
                       label: block_cbzoK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzoK: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbzqm; else goto cbzql;
       cbzqm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzql: // global
           I64[Hp - 56] = sat_sbyQR_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyQL_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzqh_info;
           R2 = Hp - 54;
           _sbyQJ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyQJ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzqh() //  [R1]
         { info_tbl: [(cbzqh,
                       label: block_cbzqh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzqh: // global
           I64[Sp] = block_cbzqj_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzqj() //  []
         { info_tbl: [(cbzqj,
                       label: block_cbzqj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzqj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.187098585 UTC

[section ""data" . System.IO.withFile_closure" {
     System.IO.withFile_closure:
         const System.IO.withFile_info;
         const 0;
 },
 System.IO.withFile_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzqE,
                       label: System.IO.withFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzqE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.188116096 UTC

[section ""data" . System.IO.appendFile1_closure" {
     System.IO.appendFile1_closure:
         const System.IO.appendFile1_info;
         const 0;
 },
 sat_sbyRC_entry() //  [R1, R2]
         { info_tbl: [(cbzqQ,
                       label: sat_sbyRC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzqQ: // global
           R3 = P64[R1 + 6];
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.appendFile1_entry() //  [R2, R3]
         { info_tbl: [(cbzqT,
                       label: System.IO.appendFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzqT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzqX; else goto cbzqW;
       cbzqX: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.appendFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzqW: // global
           I64[Hp - 8] = sat_sbyRC_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = GHC.IO.IOMode.AppendMode_closure+3;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.189191514 UTC

[section ""data" . System.IO.appendFile_closure" {
     System.IO.appendFile_closure:
         const System.IO.appendFile_info;
         const 0;
 },
 System.IO.appendFile_entry() //  [R2, R3]
         { info_tbl: [(cbzr2,
                       label: System.IO.appendFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzr2: // global
           R3 = R3;
           R2 = R2;
           call System.IO.appendFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.190298754 UTC

[section ""data" . System.IO.writeFile1_closure" {
     System.IO.writeFile1_closure:
         const System.IO.writeFile1_info;
         const 0;
 },
 sat_sbyRH_entry() //  [R1, R2]
         { info_tbl: [(cbzre,
                       label: sat_sbyRH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzre: // global
           R3 = P64[R1 + 6];
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.writeFile1_entry() //  [R2, R3]
         { info_tbl: [(cbzrh,
                       label: System.IO.writeFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzrh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzrl; else goto cbzrk;
       cbzrl: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.writeFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzrk: // global
           I64[Hp - 8] = sat_sbyRH_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = GHC.IO.IOMode.WriteMode_closure+2;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.191436359 UTC

[section ""data" . System.IO.writeFile_closure" {
     System.IO.writeFile_closure:
         const System.IO.writeFile_info;
         const 0;
 },
 System.IO.writeFile_entry() //  [R2, R3]
         { info_tbl: [(cbzrq,
                       label: System.IO.writeFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzrq: // global
           R3 = R3;
           R2 = R2;
           call System.IO.writeFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.194127031 UTC

[section ""data" . System.IO.withBinaryFile1_closure" {
     System.IO.withBinaryFile1_closure:
         const System.IO.withBinaryFile1_info;
         const 0;
 },
 sat_sbyS0_entry() //  [R1, R2]
         { info_tbl: [(cbzrK,
                       label: sat_sbyS0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzrK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzrL; else goto cbzrM;
       cbzrL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzrM: // global
           I64[Sp - 16] = block_cbzrI_info;
           _sbyRV::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyRV::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzrI() //  []
         { info_tbl: [(cbzrI,
                       label: block_cbzrI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzrI: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRU_entry() //  [R1]
         { info_tbl: [(cbzrU,
                       label: sat_sbyRU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzrU: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySi_entry() //  [R1, R2]
         { info_tbl: [(cbzsc,
                       label: sat_sbySi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzsc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzsd; else goto cbzse;
       cbzsd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzse: // global
           I64[Sp - 16] = block_cbzsa_info;
           _sbySd::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbySd::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzsa() //  []
         { info_tbl: [(cbzsa,
                       label: block_cbzsa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzsa: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySc_entry() //  [R1]
         { info_tbl: [(cbzsm,
                       label: sat_sbySc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzsm: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySp_entry() //  [R1]
         { info_tbl: [(cbzst,
                       label: sat_sbySp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzst: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzsu; else goto cbzsv;
       cbzsu: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbzsv: // global
           I64[Sp - 16] = block_cbzs3_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzs3() //  [R1]
         { info_tbl: [(cbzs3,
                       label: block_cbzs3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzs3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbzsy; else goto cbzsx;
       cbzsy: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzsx: // global
           I64[Hp - 56] = sat_sbySi_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbySc_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzsp_info;
           R2 = Hp - 54;
           _sbySa::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbySa::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzsp() //  [R1]
         { info_tbl: [(cbzsp,
                       label: block_cbzsp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzsp: // global
           I64[Sp] = block_cbzsr_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzsr() //  []
         { info_tbl: [(cbzsr,
                       label: block_cbzsr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzsr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySA_entry() //  [R1, R2]
         { info_tbl: [(cbzsL,
                       label: sat_sbySA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzsL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzsM; else goto cbzsN;
       cbzsM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzsN: // global
           I64[Sp - 16] = block_cbzsJ_info;
           _sbySv::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbySv::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzsJ() //  []
         { info_tbl: [(cbzsJ,
                       label: block_cbzsJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzsJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySu_entry() //  [R1]
         { info_tbl: [(cbzsV,
                       label: sat_sbySu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzsV: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.withBinaryFile1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzt2,
                       label: System.IO.withBinaryFile1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzt2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbzt3; else goto cbzt4;
       cbzt3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.withBinaryFile1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzt4: // global
           I64[Sp - 32] = block_cbzrx_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbzrx() //  [R1]
         { info_tbl: [(cbzrx,
                       label: block_cbzrx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzrx: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzt7; else goto cbzt6;
       cbzt7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbzt6: // global
           _sbyRI::P64 = P64[Sp + 8];
           _sbyRJ::P64 = P64[Sp + 16];
           if (R1 == 0) goto cbzt0; else goto ubztq;
       cbzt0: // global
           I64[Hp - 24] = sat_sbySp_info;
           P64[Hp - 16] = _sbyRI::P64;
           P64[Hp - 8] = _sbyRJ::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ubztq: // global
           if (R1 == 1) goto cbzt1; else goto cbzsZ;
       cbzt1: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbzsC_info;
           R3 = _sbyRJ::P64;
           R2 = _sbyRI::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       cbzsZ: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbzrB_info;
           R3 = _sbyRJ::P64;
           R2 = _sbyRI::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzsC() //  [R1]
         { info_tbl: [(cbzsC,
                       label: block_cbzsC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzsC: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbztm; else goto cbztl;
       cbztm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbztl: // global
           I64[Hp - 56] = sat_sbySA_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbySu_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzth_info;
           R2 = Hp - 54;
           _sbySs::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbySs::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzth() //  [R1]
         { info_tbl: [(cbzth,
                       label: block_cbzth_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzth: // global
           I64[Sp] = block_cbztj_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbztj() //  []
         { info_tbl: [(cbztj,
                       label: block_cbztj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbztj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbzrB() //  [R1]
         { info_tbl: [(cbzrB,
                       label: block_cbzrB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzrB: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbztd; else goto cbztc;
       cbztd: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbztc: // global
           I64[Hp - 56] = sat_sbyS0_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyRU_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzt8_info;
           R2 = Hp - 54;
           _sbyRS::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyRS::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzt8() //  [R1]
         { info_tbl: [(cbzt8,
                       label: block_cbzt8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzt8: // global
           I64[Sp] = block_cbzta_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzta() //  []
         { info_tbl: [(cbzta,
                       label: block_cbzta_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzta: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.198857903 UTC

[section ""data" . System.IO.withBinaryFile_closure" {
     System.IO.withBinaryFile_closure:
         const System.IO.withBinaryFile_info;
         const 0;
 },
 System.IO.withBinaryFile_entry() //  [R2, R3, R4]
         { info_tbl: [(cbztv,
                       label: System.IO.withBinaryFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbztv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call System.IO.withBinaryFile1_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.199837406 UTC

[section ""data" . lvl_rbyQ6_closure" {
     lvl_rbyQ6_closure:
         const lvl_rbyQ6_info;
 },
 lvl_rbyQ6_entry() //  []
         { info_tbl: [(cbztH,
                       label: lvl_rbyQ6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbztH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbztI; else goto cbztJ;
       cbztI: // global
           R1 = lvl_rbyQ6_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbztJ: // global
           I64[Sp - 8] = block_cbztC_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cbztC() //  []
         { info_tbl: [(cbztC,
                       label: block_cbztC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbztC: // global
           I64[Sp] = block_cbztE_info;
           R1 = System.IO.hReady2_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbztE() //  [R1]
         { info_tbl: [(cbztE,
                       label: block_cbztE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbztE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbztN; else goto cbztM;
       cbztN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbztM: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.201109773 UTC

[section ""data" . tempCounter_rbxCH_closure" {
     tempCounter_rbxCH_closure:
         const tempCounter_rbxCH_info;
         const 0;
         const 0;
         const 0;
 },
 tempCounter_rbxCH_entry() //  [R1]
         { info_tbl: [(cbztW,
                       label: tempCounter_rbxCH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbztW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbztX; else goto cbztY;
       cbztX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbztY: // global
           (_cbztR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbztR::I64 == 0) goto cbztT; else goto cbztS;
       cbztT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbztS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbztR::I64;
           I64[Sp - 24] = block_cbztU_info;
           Sp = Sp - 24;
           call lvl_rbyQ6_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbztU() //  [R1]
         { info_tbl: [(cbztU,
                       label: block_cbztU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbztU: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.202353179 UTC

[section ""data" . pathSeparatorChar_rbxCK_closure" {
     pathSeparatorChar_rbxCK_closure:
         const GHC.Types.C#_con_info;
         const 47;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.202863606 UTC

[section ""cstring" . System.IO.$trModule4_bytes" {
     System.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.203394146 UTC

[section ""data" . System.IO.$trModule3_closure" {
     System.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.203904419 UTC

[section ""cstring" . System.IO.$trModule2_bytes" {
     System.IO.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.204432398 UTC

[section ""data" . System.IO.$trModule1_closure" {
     System.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.204960093 UTC

[section ""data" . System.IO.$trModule_closure" {
     System.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.IO.$trModule3_closure+1;
         const System.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.205649121 UTC

[section ""data" . $krep_rbyQ7_closure" {
     $krep_rbyQ7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Error.$tcErrno_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.20625167 UTC

[section ""data" . $krep1_rbyQ8_closure" {
     $krep1_rbyQ8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.206788123 UTC

[section ""cstring" . System.IO.$tcOpenNewFileResult2_bytes" {
     System.IO.$tcOpenNewFileResult2_bytes:
         I8[] [79,112,101,110,78,101,119,70,105,108,101,82,101,115,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.209045172 UTC

[section ""data" . System.IO.$tcOpenNewFileResult1_closure" {
     System.IO.$tcOpenNewFileResult1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tcOpenNewFileResult2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.209654943 UTC

[section ""data" . System.IO.$tcOpenNewFileResult_closure" {
     System.IO.$tcOpenNewFileResult_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tcOpenNewFileResult1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9627069439367662246;
         const 2547759174955940786;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.210249171 UTC

[section ""data" . System.IO.$tc'FileExists1_closure" {
     System.IO.$tc'FileExists1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.IO.$tcOpenNewFileResult_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.210799534 UTC

[section ""cstring" . System.IO.$tc'FileExists3_bytes" {
     System.IO.$tc'FileExists3_bytes:
         I8[] [39,70,105,108,101,69,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.211345849 UTC

[section ""data" . System.IO.$tc'FileExists2_closure" {
     System.IO.$tc'FileExists2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'FileExists3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.211918908 UTC

[section ""data" . System.IO.$tc'FileExists_closure" {
     System.IO.$tc'FileExists_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'FileExists2_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 6704133186904346962;
         const 16997416543076271011;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.212502257 UTC

[section ""data" . System.IO.$tc'NewFileCreated1_closure" {
     System.IO.$tc'NewFileCreated1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rbyQ8_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.213064742 UTC

[section ""cstring" . System.IO.$tc'NewFileCreated3_bytes" {
     System.IO.$tc'NewFileCreated3_bytes:
         I8[] [39,78,101,119,70,105,108,101,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.213691673 UTC

[section ""data" . System.IO.$tc'NewFileCreated2_closure" {
     System.IO.$tc'NewFileCreated2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'NewFileCreated3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.21427256 UTC

[section ""data" . System.IO.$tc'NewFileCreated_closure" {
     System.IO.$tc'NewFileCreated_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'NewFileCreated2_closure+1;
         const System.IO.$tc'NewFileCreated1_closure+4;
         const 9070829168557028496;
         const 15570227817593865145;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.214813551 UTC

[section ""data" . System.IO.$tc'OpenNewError1_closure" {
     System.IO.$tc'OpenNewError1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbyQ7_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.215307879 UTC

[section ""cstring" . System.IO.$tc'OpenNewError3_bytes" {
     System.IO.$tc'OpenNewError3_bytes:
         I8[] [39,79,112,101,110,78,101,119,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.215833472 UTC

[section ""data" . System.IO.$tc'OpenNewError2_closure" {
     System.IO.$tc'OpenNewError2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'OpenNewError3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.216341422 UTC

[section ""data" . System.IO.$tc'OpenNewError_closure" {
     System.IO.$tc'OpenNewError_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'OpenNewError2_closure+1;
         const System.IO.$tc'OpenNewError1_closure+4;
         const 300310999495895268;
         const 12582581010413704951;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.217309966 UTC

[section ""data" . lvl1_rbyQ9_closure" {
     lvl1_rbyQ9_closure:
         const lvl1_rbyQ9_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbyQ9_entry() //  [R1]
         { info_tbl: [(cbzu6,
                       label: lvl1_rbyQ9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzu6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzu7; else goto cbzu8;
       cbzu7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzu8: // global
           (_cbzu3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzu3::I64 == 0) goto cbzu5; else goto cbzu4;
       cbzu5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzu4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzu3::I64;
           R2 = GHC.IO.Exception.FixIOException_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionFixIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.218388785 UTC

[section ""data" . System.IO.fixIO3_closure" {
     System.IO.fixIO3_closure:
         const System.IO.fixIO3_info;
         const 0;
 },
 System.IO.fixIO3_entry() //  []
         { info_tbl: [(cbzud,
                       label: System.IO.fixIO3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzud: // global
           R1 = lvl1_rbyQ9_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.219694742 UTC

[section ""data" . System.IO.fixIO2_closure" {
     System.IO.fixIO2_closure:
         const System.IO.fixIO2_info;
         const 0;
 },
 sat_sbySX_entry() //  [R1]
         { info_tbl: [(cbzuC,
                       label: sat_sbySX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzuC: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.fixIO2_entry() //  [R2]
         { info_tbl: [(cbzuF,
                       label: System.IO.fixIO2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzuF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzuG; else goto cbzuH;
       cbzuG: // global
           R2 = R2;
           R1 = System.IO.fixIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzuH: // global
           I64[Sp - 8] = block_cbzuk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzuZ; else goto cbzul;
       ubzuZ: // global
           call _cbzuk(R1) args: 0, res: 0, upd: 0;
       cbzul: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzuk() //  [R1]
         { info_tbl: [(cbzuk,
                       label: block_cbzuk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzuk: // global
           I64[Sp - 16] = block_cbzup_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzup() //  [R1]
         { info_tbl: [(cbzup,
                       label: block_cbzup_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzup: // global
           I64[Sp] = block_cbzut_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzut() //  [R1]
         { info_tbl: [(cbzut,
                       label: block_cbzut_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzut: // global
           if (R1 & 7 == 1) goto cbzuL; else goto cbzuT;
       cbzuL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzuO; else goto cbzuN;
       cbzuO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzuN: // global
           I64[Hp - 8] = sat_sbySX_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbzuT: // global
           I64[Sp + 16] = block_cbzuR_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzuR() //  []
         { info_tbl: [(cbzuR,
                       label: block_cbzuR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzuR: // global
           R1 = System.IO.fixIO3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.222212311 UTC

[section ""data" . System.IO.fixIO1_closure" {
     System.IO.fixIO1_closure:
         const System.IO.fixIO1_info;
         const 0;
 },
 sat_sbyT6_entry() //  [R1]
         { info_tbl: [(cbzvg,
                       label: sat_sbyT6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzvg: // global
           R1 = P64[R1 + 7];
           call stg_readMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyT7_entry() //  [R1]
         { info_tbl: [(cbzvj,
                       label: sat_sbyT7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzvj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzvn; else goto cbzvm;
       cbzvn: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbzvm: // global
           _sbyT3::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sbyT6_info;
           P64[Hp] = _sbyT3::P64;
           R2 = System.IO.fixIO2_closure+1;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.fixIO1_entry() //  [R2]
         { info_tbl: [(cbzvu,
                       label: System.IO.fixIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzvu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzvv; else goto cbzvw;
       cbzvv: // global
           R2 = R2;
           R1 = System.IO.fixIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzvw: // global
           I64[Sp - 16] = block_cbzv4_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cbzv4() //  [R1]
         { info_tbl: [(cbzv4,
                       label: block_cbzv4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzv4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzvz; else goto cbzvy;
       cbzvz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzvy: // global
           I64[Hp - 8] = sat_sbyT7_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_cbzvo_info;
           R2 = Hp - 7;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzvo() //  [R1]
         { info_tbl: [(cbzvo,
                       label: block_cbzvo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzvo: // global
           I64[Sp] = block_cbzvq_info;
           R2 = R1;
           R1 = P64[Sp + 16];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzvq() //  [R1]
         { info_tbl: [(cbzvq,
                       label: block_cbzvq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzvq: // global
           _sbyT3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbzvs_info;
           R2 = R1;
           _sbyTd::P64 = R1;
           R1 = _sbyT3::P64;
           P64[Sp + 16] = _sbyTd::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzvs() //  []
         { info_tbl: [(cbzvs,
                       label: block_cbzvs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzvs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.224043615 UTC

[section ""data" . System.IO.fixIO_closure" {
     System.IO.fixIO_closure:
         const System.IO.fixIO_info;
         const 0;
 },
 System.IO.fixIO_entry() //  [R2]
         { info_tbl: [(cbzvH,
                       label: System.IO.fixIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzvH: // global
           R2 = R2;
           call System.IO.fixIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.224735095 UTC

[section ""cstring" . System.IO.readIO9_bytes" {
     System.IO.readIO9_bytes:
         I8[] [80,114,101,108,117,100,101,46,114,101,97,100,73,79,58,32,110,111,32,112,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.22548009 UTC

[section ""data" . System.IO.readIO8_closure" {
     System.IO.readIO8_closure:
         const System.IO.readIO8_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO8_entry() //  [R1]
         { info_tbl: [(cbzvQ,
                       label: System.IO.readIO8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzvQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzvR; else goto cbzvS;
       cbzvR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzvS: // global
           (_cbzvN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzvN::I64 == 0) goto cbzvP; else goto cbzvO;
       cbzvP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzvO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzvN::I64;
           R2 = System.IO.readIO9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.226350084 UTC

[section ""data" . System.IO.readIO7_closure" {
     System.IO.readIO7_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.Types.[]_closure+1;
         const System.IO.readIO8_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.227083206 UTC

[section ""data" . System.IO.readIO6_closure" {
     System.IO.readIO6_closure:
         const System.IO.readIO6_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO6_entry() //  [R1]
         { info_tbl: [(cbzvZ,
                       label: System.IO.readIO6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzvZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzw0; else goto cbzw1;
       cbzw0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzw1: // global
           (_cbzvW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzvW::I64 == 0) goto cbzvY; else goto cbzvX;
       cbzvY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzvX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzvW::I64;
           R2 = System.IO.readIO7_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.227950565 UTC

[section ""cstring" . System.IO.readIO5_bytes" {
     System.IO.readIO5_bytes:
         I8[] [80,114,101,108,117,100,101,46,114,101,97,100,73,79,58,32,97,109,98,105,103,117,111,117,115,32,112,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.228634001 UTC

[section ""data" . System.IO.readIO4_closure" {
     System.IO.readIO4_closure:
         const System.IO.readIO4_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO4_entry() //  [R1]
         { info_tbl: [(cbzw8,
                       label: System.IO.readIO4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzw8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzw9; else goto cbzwa;
       cbzw9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzwa: // global
           (_cbzw5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzw5::I64 == 0) goto cbzw7; else goto cbzw6;
       cbzw7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzw6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzw5::I64;
           R2 = System.IO.readIO5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.229596618 UTC

[section ""data" . System.IO.readIO3_closure" {
     System.IO.readIO3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.Types.[]_closure+1;
         const System.IO.readIO4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.230339724 UTC

[section ""data" . System.IO.readIO2_closure" {
     System.IO.readIO2_closure:
         const System.IO.readIO2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO2_entry() //  [R1]
         { info_tbl: [(cbzwh,
                       label: System.IO.readIO2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzwh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzwi; else goto cbzwj;
       cbzwi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzwj: // global
           (_cbzwe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzwe::I64 == 0) goto cbzwg; else goto cbzwf;
       cbzwg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzwf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzwe::I64;
           R2 = System.IO.readIO3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.23274252 UTC

[section ""data" . System.IO.readIO10_closure" {
     System.IO.readIO10_closure:
         const System.IO.readIO10_info;
         const 0;
 },
 z_sbyTn_entry() //  [R1]
         { info_tbl: [(cbzwE,
                       label: z_sbyTn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzwE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzwF; else goto cbzwG;
       cbzwF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzwG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call System.IO.readIO10_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyTy_entry() //  [R1]
         { info_tbl: [(cbzxb,
                       label: sat_sbyTy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzxb: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go1_sbyTo_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_sbyTo_entry() //  [R1, R2]
         { info_tbl: [(cbzxi,
                       label: go1_sbyTo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzxi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbzxj; else goto ubzxH;
       cbzxj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ubzxH: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cbzwJ() args: 0, res: 0, upd: 0;
     }
 },
 _cbzwJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzwJ: // global
           I64[Sp - 16] = block_cbzwM_info;
           R1 = P64[Sp + 8];
           _sbyTo::P64 = P64[Sp];
           P64[Sp - 8] = P64[_sbyTo::P64 + 15];
           P64[Sp + 8] = P64[_sbyTo::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubzxL; else goto cbzwN;
       ubzxL: // global
           call _cbzwM(R1) args: 0, res: 0, upd: 0;
       cbzwN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzwM() //  [R1]
         { info_tbl: [(cbzwM,
                       label: block_cbzwM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzwM: // global
           if (R1 & 7 == 1) goto cbzxf; else goto cbzxg;
       cbzxf: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbzxg: // global
           I64[Sp] = block_cbzwS_info;
           _sbyTs::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _sbyTs::P64;
           if (R1 & 7 != 0) goto ubzxM; else goto cbzwT;
       ubzxM: // global
           call _cbzwS(R1) args: 0, res: 0, upd: 0;
       cbzwT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzwS() //  [R1]
         { info_tbl: [(cbzwS,
                       label: block_cbzwS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzwS: // global
           I64[Sp - 8] = block_cbzwX_info;
           _sbyTv::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sbyTv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzxN; else goto cbzwY;
       ubzxN: // global
           call _cbzwX(R1) args: 0, res: 0, upd: 0;
       cbzwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzwX() //  [R1]
         { info_tbl: [(cbzwX,
                       label: block_cbzwX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzwX: // global
           if (R1 & 7 == 1) goto cbzxr; else goto ubzxI;
       cbzxr: // global
           _sbyTv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbzx2_info;
           R1 = _sbyTv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubzxO; else goto cbzx3;
       ubzxO: // global
           call _cbzx2(R1) args: 0, res: 0, upd: 0;
       cbzx3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubzxI: // global
           Sp = Sp + 16;
           call _cbzxE() args: 0, res: 0, upd: 0;
     }
 },
 _cbzx2() //  [R1]
         { info_tbl: [(cbzx2,
                       label: block_cbzx2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzx2: // global
           if (R1 & 7 == 1) goto cbzxt; else goto ubzxJ;
       cbzxt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzxw; else goto cbzxv;
       cbzxw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzxv: // global
           I64[Hp - 24] = sat_sbyTy_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ubzxJ: // global
           Sp = Sp + 8;
           call _cbzxE() args: 0, res: 0, upd: 0;
     }
 },
 _cbzxE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzxE: // global
           P64[Sp + 16] = P64[Sp];
           Sp = Sp + 8;
           call _cbzwJ() args: 0, res: 0, upd: 0;
     }
 },
 System.IO.readIO10_entry() //  [R2]
         { info_tbl: [(cbzxX,
                       label: System.IO.readIO10_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzxX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzxY; else goto cbzxZ;
       cbzxY: // global
           R2 = R2;
           R1 = System.IO.readIO10_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzxZ: // global
           I64[Sp - 8] = block_cbzwo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzyc; else goto cbzwp;
       ubzyc: // global
           call _cbzwo(R1) args: 0, res: 0, upd: 0;
       cbzwp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzwo() //  [R1]
         { info_tbl: [(cbzwo,
                       label: block_cbzwo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzwo: // global
           if (R1 & 7 == 1) goto cbzxU; else goto cbzxV;
       cbzxU: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbzxV: // global
           I64[Sp - 8] = block_cbzwu_info;
           _sbyTi::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbyTi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzyb; else goto cbzwv;
       ubzyb: // global
           call _cbzwu(R1) args: 0, res: 0, upd: 0;
       cbzwv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzwu() //  [R1]
         { info_tbl: [(cbzwu,
                       label: block_cbzwu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzwu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbzy6; else goto cbzy5;
       cbzy6: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzy5: // global
           _sbyTk::P64 = P64[R1 + 7];
           _sbyTl::P64 = P64[R1 + 15];
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sbyTk::P64;
           P64[Hp - 48] = GHC.Types.[]_closure+1;
           I64[Hp - 40] = z_sbyTn_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = go1_sbyTo_info;
           P64[Hp - 8] = Hp - 62;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzy2_info;
           R3 = _sbyTl::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 8] = Hp - 15;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzy2() //  [R1]
         { info_tbl: [(cbzy2,
                       label: block_cbzy2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzy2: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sbyTo_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.237154683 UTC

[section ""data" . System.IO.readIO1_closure" {
     System.IO.readIO1_closure:
         const System.IO.readIO1_info;
         const 0;
 },
 System.IO.readIO1_entry() //  [R2, R3]
         { info_tbl: [(cbzyj,
                       label: System.IO.readIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzyj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbzyk; else goto cbzyl;
       cbzyk: // global
           R3 = R3;
           R2 = R2;
           R1 = System.IO.readIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzyl: // global
           I64[Sp - 8] = block_cbzyh_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           P64[Sp - 16] = R3;
           Sp = Sp - 32;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbzyh() //  [R1]
         { info_tbl: [(cbzyh,
                       label: block_cbzyh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzyh: // global
           I64[Sp] = block_cbzyo_info;
           R2 = R1;
           call System.IO.readIO10_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzyo() //  [R1]
         { info_tbl: [(cbzyo,
                       label: block_cbzyo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzyo: // global
           if (R1 & 7 == 1) goto cbzyv; else goto cbzyA;
       cbzyv: // global
           R1 = System.IO.readIO6_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbzyA: // global
           I64[Sp - 8] = block_cbzyy_info;
           _sbyTJ::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sbyTJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzyO; else goto cbzyB;
       ubzyO: // global
           call _cbzyy(R1) args: 0, res: 0, upd: 0;
       cbzyB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzyy() //  [R1]
         { info_tbl: [(cbzyy,
                       label: block_cbzyy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzyy: // global
           if (R1 & 7 == 1) goto cbzyH; else goto cbzyL;
       cbzyH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbzyL: // global
           R1 = System.IO.readIO2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.238756424 UTC

[section ""data" . System.IO.readIO_closure" {
     System.IO.readIO_closure:
         const System.IO.readIO_info;
         const 0;
 },
 System.IO.readIO_entry() //  [R2, R3]
         { info_tbl: [(cbzyT,
                       label: System.IO.readIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzyT: // global
           R3 = R3;
           R2 = R2;
           call System.IO.readIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.239654718 UTC

[section ""data" . System.IO.readLn1_closure" {
     System.IO.readLn1_closure:
         const System.IO.readLn1_info;
         const 0;
 },
 section ""relreadonly" . ubzz6_srtd" {
     ubzz6_srtd:
         const SbyXw_srt+56;
         const 36;
         const 38654705769;
 },
 System.IO.readLn1_entry() //  [R2]
         { info_tbl: [(cbzz2,
                       label: System.IO.readLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzz2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzz3; else goto cbzz4;
       cbzz3: // global
           R2 = R2;
           R1 = System.IO.readLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzz4: // global
           I64[Sp - 16] = block_cbzz0_info;
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           _sbyTO::P64 = R2;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           P64[Sp - 8] = _sbyTO::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzz0() //  [R1]
         { info_tbl: [(cbzz0,
                       label: block_cbzz0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzz0: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call System.IO.readIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.240759337 UTC

[section ""data" . System.IO.readLn_closure" {
     System.IO.readLn_closure:
         const System.IO.readLn_info;
         const 0;
 },
 System.IO.readLn_entry() //  [R2]
         { info_tbl: [(cbzzb,
                       label: System.IO.readLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzzb: // global
           R2 = R2;
           call System.IO.readLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.241747243 UTC

[section ""data" . System.IO.readFile1_closure" {
     System.IO.readFile1_closure:
         const System.IO.readFile1_info;
         const 0;
 },
 System.IO.readFile1_entry() //  [R2]
         { info_tbl: [(cbzzk,
                       label: System.IO.readFile1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzzk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbzzl; else goto cbzzm;
       cbzzl: // global
           R2 = R2;
           R1 = System.IO.readFile1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzzm: // global
           I64[Sp - 8] = block_cbzzi_info;
           R3 = GHC.IO.IOMode.ReadMode_closure+1;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzzi() //  [R1]
         { info_tbl: [(cbzzi,
                       label: block_cbzzi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzzi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.242792605 UTC

[section ""data" . System.IO.readFile_closure" {
     System.IO.readFile_closure:
         const System.IO.readFile_info;
         const 0;
 },
 System.IO.readFile_entry() //  [R2]
         { info_tbl: [(cbzzs,
                       label: System.IO.readFile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzzs: // global
           R2 = R2;
           call System.IO.readFile1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.243875123 UTC

[section ""data" . System.IO.interact1_closure" {
     System.IO.interact1_closure:
         const System.IO.interact1_info;
         const 0;
 },
 sat_sbyU3_entry() //  [R1]
         { info_tbl: [(cbzzF,
                       label: sat_sbyU3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzzF: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubzzO_srtd" {
     ubzzO_srtd:
         const SbyXw_srt;
         const 45;
         const 17592186078273;
 },
 System.IO.interact1_entry() //  [R2]
         { info_tbl: [(cbzzI,
                       label: System.IO.interact1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzzI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzzJ; else goto cbzzK;
       cbzzJ: // global
           R2 = R2;
           R1 = System.IO.interact1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzzK: // global
           I64[Sp - 16] = block_cbzzz_info;
           _sbyTY::P64 = R2;
           R2 = GHC.IO.Handle.FD.stdin_closure;
           P64[Sp - 8] = _sbyTY::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzzz() //  [R1]
         { info_tbl: [(cbzzz,
                       label: block_cbzzz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzzz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzzN; else goto cbzzM;
       cbzzN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzzM: // global
           I64[Hp - 24] = sat_sbyU3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.245219691 UTC

[section ""data" . System.IO.interact_closure" {
     System.IO.interact_closure:
         const System.IO.interact_info;
         const 0;
 },
 System.IO.interact_entry() //  [R2]
         { info_tbl: [(cbzzT,
                       label: System.IO.interact_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzzT: // global
           R2 = R2;
           call System.IO.interact1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.245965177 UTC

[section ""cstring" . lvl2_rbyQa_bytes" {
     lvl2_rbyQa_bytes:
         I8[] [98,117,103,32,105,110,32,83,121,115,116,101,109,46,73,79,46,111,112,101,110,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.246743112 UTC

[section ""data" . lvl3_rbyQb_closure" {
     lvl3_rbyQb_closure:
         const lvl3_rbyQb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbyQb_entry() //  [R1]
         { info_tbl: [(cbzA4,
                       label: lvl3_rbyQb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzA4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzA5; else goto cbzA6;
       cbzA5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzA6: // global
           (_cbzzZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzzZ::I64 == 0) goto cbzA1; else goto cbzA0;
       cbzA1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzA0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzzZ::I64;
           I64[Sp - 24] = block_cbzA2_info;
           R2 = lvl2_rbyQa_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbzA2() //  [R1]
         { info_tbl: [(cbzA2,
                       label: block_cbzA2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzA2: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.247732323 UTC

[section ""data" . lvl4_rbyQc_closure" {
     lvl4_rbyQc_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.24851794 UTC

[section ""data" . lvl5_rbyQd_closure" {
     lvl5_rbyQd_closure:
         const lvl5_rbyQd_info;
 },
 lvl5_rbyQd_entry() //  [R2]
         { info_tbl: [(cbzAh,
                       label: lvl5_rbyQd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzAh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbzAi; else goto cbzAj;
       cbzAi: // global
           R2 = R2;
           R1 = lvl5_rbyQd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzAj: // global
           I64[Sp - 8] = block_cbzAe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzAr; else goto cbzAf;
       ubzAr: // global
           call _cbzAe(R1) args: 0, res: 0, upd: 0;
       cbzAf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzAe() //  [R1]
         { info_tbl: [(cbzAe,
                       label: block_cbzAe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzAe: // global
           if (I64[R1 + 7] == 46) goto cbzAq; else goto cbzAp;
       cbzAq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbzAp: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.249964801 UTC

[section ""data" . lvl6_rbyQe_closure" {
     lvl6_rbyQe_closure:
         const lvl6_rbyQe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rbyQe_entry() //  [R1]
         { info_tbl: [(cbzAF,
                       label: lvl6_rbyQe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzAF: // global
           _rbyQe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbzBo; else goto cbzBp;
       cbzBp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzBr; else goto cbzBq;
       cbzBr: // global
           HpAlloc = 16;
           goto cbzBo;
       cbzBo: // global
           R1 = _rbyQe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzBq: // global
           (_cbzAv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbyQe::P64);
           if (_cbzAv::I64 == 0) goto cbzAx; else goto cbzAw;
       cbzAx: // global
           call (I64[I64[_rbyQe::P64]])() args: 8, res: 0, upd: 8;
       cbzAw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzAv::I64;
           (_sbyUc::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_nonblock();
           (_sbyUg::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_noctty();
           (_sbyUk::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_creat();
           (_sbyUo::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_rdwr();
           (_sbyUs::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_excl();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUc::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUg::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUk::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUo::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUs::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.251603604 UTC

[section ""data" . $wlvl_rbyQf_closure" {
     $wlvl_rbyQf_closure:
         const $wlvl_rbyQf_info;
         const 0;
 },
 sat_sbyUN_entry() //  [R1]
         { info_tbl: [(cbzBF,
                       label: sat_sbyUN_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzBF: // global
           _sbyUN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbzBG; else goto cbzBH;
       cbzBH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzBJ; else goto cbzBI;
       cbzBJ: // global
           HpAlloc = 16;
           goto cbzBG;
       cbzBG: // global
           R1 = _sbyUN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzBI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbyUN::P64;
           _sbyUJ::P64 = P64[_sbyUN::P64 + 16];
           _sbyUK::P64 = P64[_sbyUN::P64 + 24];
           _sbyUI::I64 = I64[_sbyUN::P64 + 32];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbyUK::P64;
           R5 = Hp - 6;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = _sbyUI::I64;
           R2 = _sbyUJ::P64;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyUO_entry() //  [R1]
         { info_tbl: [(cbzBK,
                       label: sat_sbyUO_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzBK: // global
           _sbyUO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbzBL; else goto cbzBM;
       cbzBM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbzBO; else goto cbzBN;
       cbzBO: // global
           HpAlloc = 40;
           goto cbzBL;
       cbzBL: // global
           R1 = _sbyUO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzBN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbyUO::P64;
           _sbyUJ::P64 = P64[_sbyUO::P64 + 16];
           _sbyUK::P64 = P64[_sbyUO::P64 + 24];
           _sbyUI::I64 = I64[_sbyUO::P64 + 32];
           I64[Hp - 32] = sat_sbyUN_info;
           P64[Hp - 16] = _sbyUJ::P64;
           P64[Hp - 8] = _sbyUK::P64;
           I64[Hp] = _sbyUI::I64;
           R2 = Hp - 32;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rbyQf_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzBP,
                       label: $wlvl_rbyQf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzBP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbzBT; else goto cbzBS;
       cbzBT: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_rbyQf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzBS: // global
           I64[Hp - 32] = sat_sbyUO_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.254980912 UTC

[section ""data" . lvl7_rbyQg_closure" {
     lvl7_rbyQg_closure:
         const lvl7_rbyQg_info;
         const 0;
 },
 lvl7_rbyQg_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzC1,
                       label: lvl7_rbyQg_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzC1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzC2; else goto cbzC3;
       cbzC2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl7_rbyQg_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzC3: // global
           I64[Sp - 24] = block_cbzBY_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubzC7; else goto cbzBZ;
       ubzC7: // global
           call _cbzBY(R1) args: 0, res: 0, upd: 0;
       cbzBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzBY() //  [R1]
         { info_tbl: [(cbzBY,
                       label: block_cbzBY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzBY: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call $wlvl_rbyQf_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.25640191 UTC

[section ""data" . lvl8_rbyQh_closure" {
     lvl8_rbyQh_closure:
         const lvl8_rbyQh_info;
 },
 sat_sbyUZ_entry() //  [R1]
         { info_tbl: [(cbzCj,
                       label: sat_sbyUZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzCj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzCq; else goto cbzCr;
       cbzCq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzCr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbzCg_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubzCv; else goto cbzCh;
       ubzCv: // global
           call _cbzCg(R1) args: 0, res: 0, upd: 0;
       cbzCh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzCg() //  [R1]
         { info_tbl: [(cbzCg,
                       label: block_cbzCg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzCg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzCu; else goto cbzCt;
       cbzCu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzCt: // global
           _sbyUY::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbyUY::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_rbyQh_entry() //  [R2]
         { info_tbl: [(cbzCx,
                       label: lvl8_rbyQh_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzCx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbzCB; else goto cbzCA;
       cbzCB: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = lvl8_rbyQh_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzCA: // global
           I64[Hp - 40] = sat_sbyUZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.258404111 UTC

[section ""data" . go_rbyQi_closure" {
     go_rbyQi_closure:
         const go_rbyQi_info;
 },
 go_rbyQi_entry() //  [R2, R3]
         { info_tbl: [(cbzCN,
                       label: go_rbyQi_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzCN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzCO; else goto ubzCW;
       cbzCO: // global
           R3 = R3;
           R2 = R2;
           R1 = go_rbyQi_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubzCW: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbzCD() args: 0, res: 0, upd: 0;
     }
 },
 _cbzCD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzCD: // global
           _sbyV0::P64 = P64[Sp];
           I64[Sp] = block_cbzCG_info;
           R1 = _sbyV0::P64;
           if (R1 & 7 != 0) goto ubzCY; else goto cbzCH;
       ubzCY: // global
           call _cbzCG(R1) args: 0, res: 0, upd: 0;
       cbzCH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzCG() //  [R1]
         { info_tbl: [(cbzCG,
                       label: block_cbzCG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzCG: // global
           if (R1 & 7 == 1) goto cbzCK; else goto cbzCL;
       cbzCK: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbzCL: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cbzCD() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.259552597 UTC

[section ""cstring" . lvl9_rbyQj_bytes" {
     lvl9_rbyQj_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.260117616 UTC

[section ""cstring" . lvl10_rbyQk_bytes" {
     lvl10_rbyQk_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101,39,58,32,84,101,109,112,108,97,116,101,32,115,116,114,105,110,103,32,109,117,115,116,32,110,111,116,32,99,111,110,116,97,105,110,32,112,97,116,104,32,115,101,112,97,114,97,116,111,114,32,99,104,97,114,97,99,116,101,114,115,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.26079639 UTC

[section ""data" . lvl11_rbyQl_closure" {
     lvl11_rbyQl_closure:
         const lvl11_rbyQl_info;
         const 0;
 },
 lvl11_rbyQl_entry() //  [R2]
         { info_tbl: [(cbzD7,
                       label: lvl11_rbyQl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzD7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbzD8; else goto cbzD9;
       cbzD8: // global
           R2 = R2;
           R1 = lvl11_rbyQl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzD9: // global
           I64[Sp - 8] = block_cbzD5_info;
           R3 = R2;
           R2 = lvl10_rbyQk_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzD5() //  [R1]
         { info_tbl: [(cbzD5,
                       label: block_cbzD5_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzD5: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.267443118 UTC

[section ""data" . System.IO.openBinaryTempFile5_closure" {
     System.IO.openBinaryTempFile5_closure:
         const System.IO.openBinaryTempFile5_info;
         const 0;
 },
 sat_sbyVl_entry() //  [R1]
         { info_tbl: [(cbzDE,
                       label: sat_sbyVl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzDE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzDF; else goto cbzDG;
       cbzDF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzDG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyVs_entry() //  [R1]
         { info_tbl: [(cbzDV,
                       label: sat_sbyVs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzDV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzDW; else goto cbzDX;
       cbzDW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzDX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyVr_entry() //  [R1]
         { info_tbl: [(cbzE3,
                       label: sat_sbyVr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzE3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzE4; else goto cbzE5;
       cbzE4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzE5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sbyVf_entry() //  [R1]
         { info_tbl: [(cbzE6,
                       label: ds_sbyVf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzE6: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbzE7; else goto cbzE8;
       cbzE7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzE8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbzDp_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbzDp() //  [R1]
         { info_tbl: [(cbzDp,
                       label: block_cbzDp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzDp: // global
           I64[Sp] = block_cbzDt_info;
           R3 = R1;
           R2 = lvl5_rbyQd_closure+1;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbzDt() //  [R1, R2]
         { info_tbl: [(cbzDt,
                       label: block_cbzDt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzDt: // global
           I64[Sp - 8] = block_cbzDv_info;
           _sbyVi::P64 = R1;
           R1 = R2;
           P64[Sp] = _sbyVi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzEr; else goto cbzDw;
       ubzEr: // global
           call _cbzDv(R1) args: 0, res: 0, upd: 0;
       cbzDw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzDv() //  [R1]
         { info_tbl: [(cbzDv,
                       label: block_cbzDv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzDv: // global
           if (R1 & 7 == 1) goto cbzEd; else goto cbzEi;
       cbzEd: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbzEg; else goto cbzEf;
       cbzEg: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzEf: // global
           I64[Hp - 40] = sat_sbyVl_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbzEi: // global
           I64[Sp - 8] = block_cbzDJ_info;
           _sbyVn::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbyVn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzEs; else goto cbzDK;
       ubzEs: // global
           call _cbzDJ(R1) args: 0, res: 0, upd: 0;
       cbzDK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzDJ() //  [R1]
         { info_tbl: [(cbzDJ,
                       label: block_cbzDJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzDJ: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbzEl; else goto cbzEk;
       cbzEl: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzEk: // global
           if (I64[R1 + 7] == 46) goto cbzEp; else goto cbzEn;
       cbzEp: // global
           I64[Hp - 88] = sat_sbyVs_info;
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = lvl4_rbyQc_closure+1;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = sat_sbyVr_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbzEn: // global
           Hp = Hp - 96;
           R1 = lvl3_rbyQb_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 oflags_sbyVu_entry() //  [R1]
         { info_tbl: [(cbzEA,
                       label: oflags_sbyVu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzEA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbzEB; else goto cbzEC;
       cbzEB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzEC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbzEx_info;
           _sbyVb::P64 = P64[R1 + 16];
           R1 = lvl6_rbyQe_closure;
           P64[Sp - 24] = _sbyVb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubzFd; else goto cbzEy;
       ubzFd: // global
           call _cbzEx(R1) args: 0, res: 0, upd: 0;
       cbzEy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzEx() //  [R1]
         { info_tbl: [(cbzEx,
                       label: block_cbzEx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzEx: // global
           I64[Sp - 8] = block_cbzEF_info;
           _sbyVv::P64 = R1;
           _sbyVw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _sbyVw::I64;
           P64[Sp + 8] = _sbyVv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzFc; else goto cbzEH;
       ubzFc: // global
           call _cbzEF(R1) args: 0, res: 0, upd: 0;
       cbzEH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzEF() //  [R1]
         { info_tbl: [(cbzEF,
                       label: block_cbzEF_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzEF: // global
           if (R1 & 7 == 1) goto cbzEN; else goto cbzF7;
       cbzEN: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbzF7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzFa; else goto cbzF9;
       cbzFa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzF9: // global
           _sbyVw::I64 = I64[Sp + 8];
           (_sbyVB::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_binary();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sbyVw::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyVB::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_sbyVH_entry() //  [R1, R2]
         { info_tbl: [(cbzFm,
                       label: lvl12_sbyVH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzFm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzFH; else goto cbzFI;
       cbzFH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzFI: // global
           I64[Sp - 24] = block_cbzFj_info;
           _sbyVc::P64 = P64[R1 + 6];
           _sbyVu::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbyVc::P64;
           P64[Sp - 8] = _sbyVu::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubzFP; else goto cbzFk;
       ubzFP: // global
           call _cbzFj(R1) args: 0, res: 0, upd: 0;
       cbzFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzFj() //  [R1]
         { info_tbl: [(cbzFj,
                       label: block_cbzFj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzFj: // global
           I64[Sp] = block_cbzFp_info;
           _sbyVL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sbyVL::I64;
           if (R1 & 7 != 0) goto ubzFO; else goto cbzFq;
       ubzFO: // global
           call _cbzFp(R1) args: 0, res: 0, upd: 0;
       cbzFq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzFp() //  [R1]
         { info_tbl: [(cbzFp,
                       label: block_cbzFp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzFp: // global
           I64[Sp] = block_cbzFu_info;
           _sbyVN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sbyVN::I64;
           if (R1 & 7 != 0) goto ubzFQ; else goto cbzFv;
       ubzFQ: // global
           call _cbzFu(R1) args: 0, res: 0, upd: 0;
       cbzFv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzFu() //  [R1]
         { info_tbl: [(cbzFu,
                       label: block_cbzFu_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzFu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzFN; else goto cbzFM;
       cbzFN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzFM: // global
           (_sbyVT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     signed,]  result hints:  [signed] __hscore_open(I64[Sp + 16], I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyVT::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyVX_entry() //  [R1]
         { info_tbl: [(cbzFZ,
                       label: sat_sbyVX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzFZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzG0; else goto cbzG1;
       cbzG0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzG1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.List.lastError_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_rbyQi_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl13_sbyVW_entry() //  [R1]
         { info_tbl: [(cbzG3,
                       label: lvl13_sbyVW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzG3: // global
           _sbyVW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbzG4; else goto cbzG5;
       cbzG5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbzG7; else goto cbzG6;
       cbzG7: // global
           HpAlloc = 48;
           goto cbzG4;
       cbzG4: // global
           R1 = _sbyVW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzG6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbyVW::P64;
           _sbyV9::P64 = P64[_sbyVW::P64 + 16];
           I64[Hp - 40] = sat_sbyVX_info;
           P64[Hp - 24] = _sbyV9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R4 = Hp - 14;
           R3 = pathSeparatorChar_rbxCK_closure+1;
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp - 16;
           call GHC.List.elem_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyWv_entry() //  [R1]
         { info_tbl: [(cbzGS,
                       label: sat_sbyWv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzGS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbzGY; else goto cbzGZ;
       cbzGY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzGZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbzGP_info;
           _sbyWj::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbyWj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubzH4; else goto cbzGQ;
       ubzH4: // global
           call _cbzGP(R1) args: 0, res: 0, upd: 0;
       cbzGQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzGP() //  [R1]
         { info_tbl: [(cbzGP,
                       label: block_cbzGP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzGP: // global
           I64[Sp] = block_cbzGV_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbzGV() //  [R1, R2]
         { info_tbl: [(cbzGV,
                       label: block_cbzGV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzGV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbzH3; else goto cbzH2;
       cbzH3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbzH2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyWw_entry() //  [R1]
         { info_tbl: [(cbzH5,
                       label: sat_sbyWw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzH5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzH9; else goto cbzH8;
       cbzH9: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzH8: // global
           _sbyWc::P64 = P64[R1 + 16];
           _sbyWj::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbyWv_info;
           P64[Hp - 8] = _sbyWc::P64;
           P64[Hp] = _sbyWj::P64;
           R3 = Hp - 24;
           R2 = lvl9_rbyQj_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyWx_entry() //  [R1]
         { info_tbl: [(cbzHa,
                       label: sat_sbyWx_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzHa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzHc; else goto cbzHd;
       cbzHc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzHd: // global
           I64[Sp - 24] = block_cbzGF_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 32]));
           R2 = 0;
           P64[Sp - 16] = P64[R1 + 16];
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzGF() //  [R1, R2]
         { info_tbl: [(cbzGF,
                       label: block_cbzGF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzGF: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbzHg; else goto cbzHf;
       cbzHg: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cbzHf: // global
           I64[Hp - 48] = sat_sbyWw_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 filepath_sbyWg_entry() //  [R1]
         { info_tbl: [(cbzHh,
                       label: filepath_sbyWg_info
                       rep:HeapRep 4 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzHh: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbzHi; else goto cbzHj;
       cbzHi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzHj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cbzGt_info;
           _sbyV9::P64 = P64[R1 + 16];
           _sbyVW::P64 = P64[R1 + 32];
           _sbyWc::P64 = P64[R1 + 40];
           _sbyW7::I64 = I64[R1 + 48];
           R1 = P64[R1 + 24];
           P64[Sp - 48] = _sbyV9::P64;
           P64[Sp - 40] = _sbyVW::P64;
           I64[Sp - 32] = _sbyW7::I64;
           P64[Sp - 24] = _sbyWc::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ubzI2; else goto cbzGu;
       ubzI2: // global
           call _cbzGt(R1) args: 0, res: 0, upd: 0;
       cbzGu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzGt() //  [R1]
         { info_tbl: [(cbzGt,
                       label: block_cbzGt_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzGt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbzHn; else goto cbzHm;
       cbzHn: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzHm: // global
           _sbyWi::P64 = P64[R1 + 7];
           _sbyWj::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sbyWx_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = _sbyWj::P64;
           I64[Hp] = I64[Sp + 24];
           I64[Sp] = block_cbzHk_info;
           R3 = Hp - 32;
           R2 = _sbyWi::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbzHk() //  [R1]
         { info_tbl: [(cbzHk,
                       label: block_cbzHk_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzHk: // global
           _sbyV9::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbzHt; else goto cbzHy;
       cbzHt: // global
           R1 = _sbyV9::P64 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbzHy: // global
           I64[Sp + 8] = block_cbzHw_info;
           _sbyWy::P64 = R1;
           R1 = _sbyV9::P64;
           P64[Sp + 32] = _sbyWy::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubzI3; else goto cbzHz;
       ubzI3: // global
           call _cbzHw(R1) args: 0, res: 0, upd: 0;
       cbzHz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzHw() //  [R1]
         { info_tbl: [(cbzHw,
                       label: block_cbzHw_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzHw: // global
           if (R1 & 7 == 1) goto cbzHF; else goto cbzHK;
       cbzHF: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbzHK: // global
           _sbyVW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbzHI_info;
           _sbyWB::P64 = R1;
           R1 = _sbyVW::P64;
           P64[Sp + 16] = _sbyWB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubzI4; else goto cbzHL;
       ubzI4: // global
           call _cbzHI(R1) args: 0, res: 0, upd: 0;
       cbzHL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbzHI() //  [R1]
         { info_tbl: [(cbzHI,
                       label: block_cbzHI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzHI: // global
           _sbyWy::P64 = P64[Sp + 16];
           _sbyWB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbzHR; else goto cbzHY;
       cbzHR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbzHU; else goto cbzHT;
       cbzHU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbzHT: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = pathSeparatorChar_rbxCK_closure+1;
           P64[Hp] = _sbyWy::P64;
           R3 = Hp - 14;
           R2 = _sbyWB::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbzHY: // global
           R3 = _sbyWy::P64;
           R2 = _sbyWB::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.IO.openBinaryTempFile5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbzI9,
                       label: System.IO.openBinaryTempFile5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzI9: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbzIa; else goto cbzIb;
       cbzIa: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.openBinaryTempFile5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzIb: // global
           I64[Sp - 48] = block_cbzDh_info;
           _sbyVa::P64 = R4;
           R4 = R4;
           _sbyV9::P64 = R3;
           R3 = pathSeparatorChar_rbxCK_closure+1;
           _sbyV8::P64 = R2;
           R2 = GHC.Classes.$fEqChar_closure;
           P64[Sp - 40] = _sbyV8::P64;
           P64[Sp - 32] = _sbyV9::P64;
           P64[Sp - 24] = _sbyVa::P64;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzDh() //  [R1]
         { info_tbl: [(cbzDh,
                       label: block_cbzDh_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzDh: // global
           _sbyVa::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cbzI6; else goto cbzI7;
       cbzI6: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbzIe; else goto cbzId;
       cbzIe: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzId: // global
           I64[Hp - 88] = ds_sbyVf_info;
           P64[Hp - 72] = _sbyVa::P64;
           I64[Hp - 64] = oflags_sbyVu_info;
           P64[Hp - 48] = P64[Sp + 32];
           I64[Hp - 40] = lvl12_sbyVH_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = lvl13_sbyVW_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 38;
           P64[Sp + 40] = Hp - 88;
           Sp = Sp + 8;
           call _cbzGd() args: 0, res: 0, upd: 0;
       cbzI7: // global
           R2 = _sbyVa::P64;
           Sp = Sp + 48;
           call lvl11_rbyQl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbzGd() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzGd: // global
           (_sbyW7::I64) = call "ccall" arg hints:  []  result hints:  [signed] getpid();
           I64[Sp - 16] = block_cbzGg_info;
           R1 = tempCounter_rbxCH_closure;
           I64[Sp - 8] = _sbyW7::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubzK2; else goto cbzGh;
       ubzK2: // global
           call _cbzGg(R1) args: 0, res: 0, upd: 0;
       cbzGh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzGg() //  [R1]
         { info_tbl: [(cbzGg,
                       label: block_cbzGg_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzGg: // global
           I64[Sp] = block_cbzGl_info;
           R2 = lvl8_rbyQh_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzGl() //  [R1]
         { info_tbl: [(cbzGl,
                       label: block_cbzGl_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzGl: // global
           I64[Sp - 8] = block_cbzGn_info;
           _sbyWc::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp] = _sbyWc::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzGn() //  [R1]
         { info_tbl: [(cbzGn,
                       label: block_cbzGn_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzGn: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbzIr; else goto cbzIq;
       cbzIr: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzIq: // global
           I64[Hp - 48] = filepath_sbyWg_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 56];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 8] = block_cbzIj_info;
           R4 = P64[Sp + 48];
           _cbzGp::P64 = Hp - 48;
           R3 = _cbzGp::P64;
           R2 = R1;
           P64[Sp + 16] = _cbzGp::P64;
           Sp = Sp + 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzIj() //  [R1]
         { info_tbl: [(cbzIj,
                       label: block_cbzIj_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzIj: // global
           I64[Sp] = block_cbzIl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubzK3; else goto cbzIt;
       ubzK3: // global
           call _cbzIl(R1) args: 0, res: 0, upd: 0;
       cbzIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzIl() //  [R1]
         { info_tbl: [(cbzIl,
                       label: block_cbzIl_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzIl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzIz; else goto cbzIy;
       cbzIz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzIy: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cbzJq; else goto cbzJL;
       cbzJq: // global
           I64[Hp - 8] = System.IO.NewFileCreated_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 7;
           goto ubzK6;
       cbzJL: // global
           (_sbyXd::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_get_errno();
           Hp = Hp - 16;
           _sbyXe::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyXd::I64));
           if (_sbyXe::I64 != 17) goto ubzJW; else goto cbzJH;
       ubzJW: // global
           I64[Sp] = _sbyXe::I64;
           call _cbzJA() args: 0, res: 0, upd: 0;
       cbzJH: // global
           P64[Sp] = System.IO.FileExists_closure+2;
           goto ubzK6;
       ubzK6: // global
           call _sbyWL() args: 0, res: 0, upd: 0;
     }
 },
 _cbzJA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzJA: // global
           Hp = Hp + 32;
           _sbyXe::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cbzJE; else goto cbzJD;
       cbzJE: // global
           HpAlloc = 32;
           I64[Sp] = block_cbzJx_info;
           R1 = _sbyXe::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbzJD: // global
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = _sbyXe::I64;
           I64[Hp - 8] = System.IO.OpenNewError_con_info;
           P64[Hp] = Hp - 23;
           P64[Sp] = Hp - 5;
           call _sbyWL() args: 0, res: 0, upd: 0;
     }
 },
 _cbzJx() //  [R1]
         { info_tbl: [(cbzJx,
                       label: block_cbzJx_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzJx: // global
           I64[Sp] = R1;
           call _cbzJA() args: 0, res: 0, upd: 0;
     }
 },
 _sbyWL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbyWL: // global
           _sbyWN::P64 = P64[Sp];
           I64[Sp] = block_cbzIF_info;
           R1 = _sbyWN::P64;
           if (R1 & 7 != 0) goto ubzKc; else goto cbzIH;
       ubzKc: // global
           call _cbzIF(R1) args: 0, res: 0, upd: 0;
       cbzIH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzIF() //  [R1]
         { info_tbl: [(cbzIF,
                       label: block_cbzIF_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzIF: // global
           _cbzJS::P64 = R1 & 7;
           if (_cbzJS::P64 < 3) goto ubzJT; else goto cbzJm;
       ubzJT: // global
           if (_cbzJS::P64 < 2) goto cbzJ5; else goto ubzK0;
       cbzJ5: // global
           I64[Sp] = block_cbzIL_info;
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R2 = P64[R1 + 7];
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       ubzK0: // global
           Sp = Sp + 16;
           call _cbzGd() args: 0, res: 0, upd: 0;
       cbzJm: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[R1 + 5];
           Sp = Sp + 56;
           call lvl7_rbyQg_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbzIL() //  [R1]
         { info_tbl: [(cbzIL,
                       label: block_cbzIL_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzIL: // global
           I64[Sp] = block_cbzIN_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubzK8; else goto cbzIO;
       ubzK8: // global
           call _cbzIN(R1) args: 0, res: 0, upd: 0;
       cbzIO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzIN() //  [R1]
         { info_tbl: [(cbzIN,
                       label: block_cbzIN_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzIN: // global
           I64[Sp] = block_cbzIS_info;
           _sbyWU::P64 = P64[R1 + 7];
           _sbyWV::P64 = P64[R1 + 15];
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           P64[Sp + 40] = _sbyWV::P64;
           P64[Sp + 48] = _sbyWU::P64;
           if (R1 & 7 != 0) goto ubzK9; else goto cbzIT;
       ubzK9: // global
           call _cbzIS(R1) args: 0, res: 0, upd: 0;
       cbzIT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzIS() //  [R1]
         { info_tbl: [(cbzIS,
                       label: block_cbzIS_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzIS: // global
           I64[Sp] = block_cbzIX_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzIX() //  [R1]
         { info_tbl: [(cbzIX,
                       label: block_cbzIX_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzIX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzJb; else goto cbzJa;
       cbzJb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzJa: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           I64[Sp] = block_cbzJ0_info;
           R6 = GHC.Types.False_closure+1;
           R5 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbzJ0() //  [R1]
         { info_tbl: [(cbzJ0,
                       label: block_cbzJ0_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzJ0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbzJe; else goto cbzJd;
       cbzJe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzJd: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.280045855 UTC

[section ""cstring" . System.IO.openBinaryTempFileWithDefaultPermissions4_bytes" {
     System.IO.openBinaryTempFileWithDefaultPermissions4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,84,101,109,112,70,105,108,101,87,105,116,104,68,101,102,97,117,108,116,80,101,114,109,105,115,115,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.280881996 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions3_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions3_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions3_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions3_entry() //  [R1]
         { info_tbl: [(cbzKj,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzKj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzKk; else goto cbzKl;
       cbzKk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzKl: // global
           (_cbzKg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzKg::I64 == 0) goto cbzKi; else goto cbzKh;
       cbzKi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzKh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzKg::I64;
           R2 = System.IO.openBinaryTempFileWithDefaultPermissions4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.281952069 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions2_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions2_closure:
         const GHC.Word.W32#_con_info;
         const 438;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.282650045 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions1_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions1_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions1_info;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions1_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cbzKq,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzKq: // global
           R6 = System.IO.openBinaryTempFileWithDefaultPermissions2_closure+1;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openBinaryTempFileWithDefaultPermissions3_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.283573468 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions_info;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cbzKx,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzKx: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openBinaryTempFileWithDefaultPermissions1_entry(R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.284288159 UTC

[section ""cstring" . System.IO.openTempFileWithDefaultPermissions3_bytes" {
     System.IO.openTempFileWithDefaultPermissions3_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101,87,105,116,104,68,101,102,97,117,108,116,80,101,114,109,105,115,115,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.285043444 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions2_closure" {
     System.IO.openTempFileWithDefaultPermissions2_closure:
         const System.IO.openTempFileWithDefaultPermissions2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions2_entry() //  [R1]
         { info_tbl: [(cbzKG,
                       label: System.IO.openTempFileWithDefaultPermissions2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzKG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzKH; else goto cbzKI;
       cbzKH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzKI: // global
           (_cbzKD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzKD::I64 == 0) goto cbzKF; else goto cbzKE;
       cbzKF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzKE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzKD::I64;
           R2 = System.IO.openTempFileWithDefaultPermissions3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.286119161 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions1_closure" {
     System.IO.openTempFileWithDefaultPermissions1_closure:
         const System.IO.openTempFileWithDefaultPermissions1_info;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions1_entry() //  [R2, R3]
         { info_tbl: [(cbzKN,
                       label: System.IO.openTempFileWithDefaultPermissions1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzKN: // global
           R6 = System.IO.openBinaryTempFileWithDefaultPermissions2_closure+1;
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openTempFileWithDefaultPermissions2_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.286991696 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions_closure" {
     System.IO.openTempFileWithDefaultPermissions_closure:
         const System.IO.openTempFileWithDefaultPermissions_info;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions_entry() //  [R2, R3]
         { info_tbl: [(cbzKU,
                       label: System.IO.openTempFileWithDefaultPermissions_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzKU: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openTempFileWithDefaultPermissions1_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.287686513 UTC

[section ""cstring" . System.IO.openBinaryTempFile4_bytes" {
     System.IO.openBinaryTempFile4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.288386819 UTC

[section ""data" . System.IO.openBinaryTempFile3_closure" {
     System.IO.openBinaryTempFile3_closure:
         const System.IO.openBinaryTempFile3_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openBinaryTempFile3_entry() //  [R1]
         { info_tbl: [(cbzL3,
                       label: System.IO.openBinaryTempFile3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzL3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzL4; else goto cbzL5;
       cbzL4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzL5: // global
           (_cbzL0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzL0::I64 == 0) goto cbzL2; else goto cbzL1;
       cbzL2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzL1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzL0::I64;
           R2 = System.IO.openBinaryTempFile4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.289311295 UTC

[section ""data" . System.IO.openBinaryTempFile2_closure" {
     System.IO.openBinaryTempFile2_closure:
         const GHC.Word.W32#_con_info;
         const 384;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.29001129 UTC

[section ""data" . System.IO.openBinaryTempFile1_closure" {
     System.IO.openBinaryTempFile1_closure:
         const System.IO.openBinaryTempFile1_info;
         const 0;
 },
 System.IO.openBinaryTempFile1_entry() //  [R2, R3]
         { info_tbl: [(cbzLa,
                       label: System.IO.openBinaryTempFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzLa: // global
           R6 = System.IO.openBinaryTempFile2_closure+1;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openBinaryTempFile3_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.290930172 UTC

[section ""data" . System.IO.openBinaryTempFile_closure" {
     System.IO.openBinaryTempFile_closure:
         const System.IO.openBinaryTempFile_info;
         const 0;
 },
 System.IO.openBinaryTempFile_entry() //  [R2, R3]
         { info_tbl: [(cbzLh,
                       label: System.IO.openBinaryTempFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzLh: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openBinaryTempFile1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.291613274 UTC

[section ""cstring" . System.IO.openTempFile3_bytes" {
     System.IO.openTempFile3_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.292321039 UTC

[section ""data" . System.IO.openTempFile2_closure" {
     System.IO.openTempFile2_closure:
         const System.IO.openTempFile2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openTempFile2_entry() //  [R1]
         { info_tbl: [(cbzLq,
                       label: System.IO.openTempFile2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzLq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzLr; else goto cbzLs;
       cbzLr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzLs: // global
           (_cbzLn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzLn::I64 == 0) goto cbzLp; else goto cbzLo;
       cbzLp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzLo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzLn::I64;
           R2 = System.IO.openTempFile3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.293442871 UTC

[section ""data" . System.IO.openTempFile1_closure" {
     System.IO.openTempFile1_closure:
         const System.IO.openTempFile1_info;
         const 0;
 },
 System.IO.openTempFile1_entry() //  [R2, R3]
         { info_tbl: [(cbzLx,
                       label: System.IO.openTempFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzLx: // global
           R6 = System.IO.openBinaryTempFile2_closure+1;
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openTempFile2_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.294342749 UTC

[section ""data" . System.IO.openTempFile_closure" {
     System.IO.openTempFile_closure:
         const System.IO.openTempFile_info;
         const 0;
 },
 System.IO.openTempFile_entry() //  [R2, R3]
         { info_tbl: [(cbzLE,
                       label: System.IO.openTempFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzLE: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openTempFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.295258149 UTC

[section ""data" . System.IO.NewFileCreated_closure" {
     System.IO.NewFileCreated_closure:
         const System.IO.NewFileCreated_info;
 },
 System.IO.NewFileCreated_entry() //  [R2]
         { info_tbl: [(cbzLM,
                       label: System.IO.NewFileCreated_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzLM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzLQ; else goto cbzLP;
       cbzLQ: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = System.IO.NewFileCreated_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzLP: // global
           I64[Hp - 8] = System.IO.NewFileCreated_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.296068308 UTC

[section ""data" . System.IO.FileExists_closure" {
     System.IO.FileExists_closure:
         const System.IO.FileExists_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.296766673 UTC

[section ""data" . System.IO.OpenNewError_closure" {
     System.IO.OpenNewError_closure:
         const System.IO.OpenNewError_info;
 },
 System.IO.OpenNewError_entry() //  [R2]
         { info_tbl: [(cbzLW,
                       label: System.IO.OpenNewError_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzLW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzM0; else goto cbzLZ;
       cbzM0: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = System.IO.OpenNewError_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzLZ: // global
           I64[Hp - 8] = System.IO.OpenNewError_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.297680316 UTC

[System.IO.NewFileCreated_con_entry() //  [R1]
         { info_tbl: [(cbzM1,
                       label: System.IO.NewFileCreated_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,78,101,119,70,105,108,101,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzM1: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.298387822 UTC

[System.IO.FileExists_con_entry() //  [R1]
         { info_tbl: [(cbzM3,
                       label: System.IO.FileExists_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,70,105,108,101,69,120,105,115,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzM3: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.299100366 UTC

[System.IO.OpenNewError_con_entry() //  [R1]
         { info_tbl: [(cbzM5,
                       label: System.IO.OpenNewError_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,79,112,101,110,78,101,119,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzM5: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.299748058 UTC

[section ""relreadonly" . SbyXw_srt" {
     SbyXw_srt:
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutChar1_closure;
         const System.IO.putChar1_closure;
         const GHC.IO.Handle.Text.hPutStr_closure;
         const GHC.IO.Handle.Text.hPutStrLn_closure;
         const System.IO.print_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.hGetChar2_closure;
         const GHC.IO.Handle.Text.hGetChar6_closure;
         const GHC.IO.Handle.FD.stdin_closure;
         const System.IO.getChar1_closure;
         const GHC.IO.Handle.Text.hGetLine2_closure;
         const GHC.IO.Handle.Text.hGetLine4_closure;
         const System.IO.getLine1_closure;
         const GHC.IO.Handle.Text.hGetContents1_closure;
         const System.IO.getContents1_closure;
         const GHC.IO.Handle.Text.hWaitForInput1_closure;
         const System.IO.hReady1_closure;
         const System.IO.hPrint_closure;
         const GHC.IO.Handle.hClose1_closure;
         const GHC.IO.Handle.FD.openFile1_closure;
         const System.IO.appendFile2_closure;
         const System.IO.appendFile1_closure;
         const System.IO.writeFile1_closure;
         const GHC.IO.Handle.FD.openBinaryFile1_closure;
         const System.IO.withBinaryFile1_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
         const lvl1_rbyQ9_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const System.IO.fixIO2_closure;
         const System.IO.fixIO3_closure;
         const System.IO.fixIO1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const System.IO.readIO7_closure;
         const System.IO.readIO3_closure;
         const System.IO.readIO10_closure;
         const GHC.Read.lex1_closure;
         const System.IO.readIO1_closure;
         const System.IO.readIO2_closure;
         const System.IO.readIO6_closure;
         const System.IO.readLn1_closure;
         const System.IO.readFile1_closure;
         const System.IO.interact1_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const $wlvl_rbyQf_closure;
         const lvl7_rbyQg_closure;
         const GHC.IO.failIO1_closure;
         const lvl11_rbyQl_closure;
         const lvl3_rbyQb_closure;
         const lvl6_rbyQe_closure;
         const GHC.List.lastError_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.Handle.FD.fdToHandle5_closure;
         const tempCounter_rbxCH_closure;
         const System.IO.openBinaryTempFile5_closure;
         const System.IO.openBinaryTempFileWithDefaultPermissions3_closure;
         const System.IO.openBinaryTempFileWithDefaultPermissions1_closure;
         const System.IO.openTempFileWithDefaultPermissions2_closure;
         const System.IO.openTempFileWithDefaultPermissions1_closure;
         const System.IO.openBinaryTempFile3_closure;
         const System.IO.openBinaryTempFile1_closure;
         const System.IO.openTempFile2_closure;
         const System.IO.openTempFile1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.300934479 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:30.30218239 UTC

[section ""data" . System.IO.putChar1_closure" {
     System.IO.putChar1_closure:
         const System.IO.putChar1_info;
         const 0;
 },
 System.IO.putChar1_entry() //  [R2]
         { info_tbl: [(cbzMb,
                       label: System.IO.putChar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzMb: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutChar1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.305757385 UTC

[section ""data" . System.IO.putChar_closure" {
     System.IO.putChar_closure:
         const System.IO.putChar_info;
         const 0;
 },
 System.IO.putChar_entry() //  [R2]
         { info_tbl: [(cbzMm,
                       label: System.IO.putChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzMm: // global
           R2 = R2;
           call System.IO.putChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.310720774 UTC

[section ""data" . System.IO.putStr_closure" {
     System.IO.putStr_closure:
         const System.IO.putStr_info;
         const 0;
 },
 System.IO.putStr_entry() //  [R2]
         { info_tbl: [(cbzMx,
                       label: System.IO.putStr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzMx: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.314120244 UTC

[section ""data" . System.IO.putStrLn_closure" {
     System.IO.putStrLn_closure:
         const System.IO.putStrLn_info;
         const 0;
 },
 System.IO.putStrLn_entry() //  [R2]
         { info_tbl: [(cbzMI,
                       label: System.IO.putStrLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzMI: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutStrLn_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.317545711 UTC

[section ""data" . System.IO.print_closure" {
     System.IO.print_closure:
         const System.IO.print_info;
         const 0;
 },
 sat_sbyQs_entry() //  [R1]
         { info_tbl: [(cbzMX,
                       label: sat_sbyQs_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzMX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbzMY; else goto cbzMZ;
       cbzMY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzMZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 System.IO.print_entry() //  [R2, R3]
         { info_tbl: [(cbzN0,
                       label: System.IO.print_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzN0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzN4; else goto cbzN3;
       cbzN4: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.print_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzN3: // global
           I64[Hp - 24] = sat_sbyQs_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = GHC.Types.True_closure+2;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.323185067 UTC

[section ""data" . System.IO.getChar1_closure" {
     System.IO.getChar1_closure:
         const System.IO.getChar1_info;
         const 0;
 },
 System.IO.getChar1_entry() //  []
         { info_tbl: [(cbzNi,
                       label: System.IO.getChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzNi: // global
           R4 = GHC.IO.Handle.Text.hGetChar2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.Text.hGetChar6_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.326602028 UTC

[section ""data" . System.IO.getChar_closure" {
     System.IO.getChar_closure:
         const System.IO.getChar_info;
         const 0;
 },
 System.IO.getChar_entry() //  []
         { info_tbl: [(cbzNt,
                       label: System.IO.getChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzNt: // global
           call System.IO.getChar1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.33047236 UTC

[section ""data" . System.IO.getLine1_closure" {
     System.IO.getLine1_closure:
         const System.IO.getLine1_info;
         const 0;
 },
 System.IO.getLine1_entry() //  []
         { info_tbl: [(cbzNE,
                       label: System.IO.getLine1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzNE: // global
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.333797238 UTC

[section ""data" . System.IO.getLine_closure" {
     System.IO.getLine_closure:
         const System.IO.getLine_info;
         const 0;
 },
 System.IO.getLine_entry() //  []
         { info_tbl: [(cbzNP,
                       label: System.IO.getLine_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzNP: // global
           call System.IO.getLine1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.33688253 UTC

[section ""data" . System.IO.getContents1_closure" {
     System.IO.getContents1_closure:
         const System.IO.getContents1_info;
         const 0;
 },
 System.IO.getContents1_entry() //  []
         { info_tbl: [(cbzO0,
                       label: System.IO.getContents1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzO0: // global
           R2 = GHC.IO.Handle.FD.stdin_closure;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.341490632 UTC

[section ""data" . System.IO.getContents_closure" {
     System.IO.getContents_closure:
         const System.IO.getContents_info;
         const 0;
 },
 System.IO.getContents_entry() //  []
         { info_tbl: [(cbzOb,
                       label: System.IO.getContents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzOb: // global
           call System.IO.getContents1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.3445358 UTC

[section ""data" . System.IO.localeEncoding_closure" {
     System.IO.localeEncoding_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Encoding.initLocaleEncoding_closure;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.346222108 UTC

[section ""data" . System.IO.hReady2_closure" {
     System.IO.hReady2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.348047825 UTC

[section ""data" . System.IO.hReady1_closure" {
     System.IO.hReady1_closure:
         const System.IO.hReady1_info;
         const 0;
 },
 System.IO.hReady1_entry() //  [R2]
         { info_tbl: [(cbzOo,
                       label: System.IO.hReady1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzOo: // global
           R3 = System.IO.hReady2_closure+1;
           R2 = R2;
           call GHC.IO.Handle.Text.hWaitForInput1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.351399471 UTC

[section ""data" . System.IO.hReady_closure" {
     System.IO.hReady_closure:
         const System.IO.hReady_info;
         const 0;
 },
 System.IO.hReady_entry() //  [R2]
         { info_tbl: [(cbzOz,
                       label: System.IO.hReady_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzOz: // global
           R2 = R2;
           call System.IO.hReady1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.355223703 UTC

[section ""data" . System.IO.hPrint_closure" {
     System.IO.hPrint_closure:
         const System.IO.hPrint_info;
         const 0;
 },
 sat_sbyQy_entry() //  [R1]
         { info_tbl: [(cbzOO,
                       label: sat_sbyQy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzOO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbzOP; else goto cbzOQ;
       cbzOP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzOQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 System.IO.hPrint_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzOR,
                       label: System.IO.hPrint_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzOR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzOV; else goto cbzOU;
       cbzOV: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.hPrint_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzOU: // global
           I64[Hp - 24] = sat_sbyQy_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R4 = GHC.Types.True_closure+2;
           _sbyQw::P64 = R3;
           R3 = Hp - 24;
           R2 = _sbyQw::P64;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.362841514 UTC

[section ""data" . System.IO.appendFile2_closure" {
     System.IO.appendFile2_closure:
         const System.IO.appendFile2_info;
         const 0;
 },
 sat_sbyQR_entry() //  [R1, R2]
         { info_tbl: [(cbzPm,
                       label: sat_sbyQR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzPm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzPn; else goto cbzPo;
       cbzPn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzPo: // global
           I64[Sp - 16] = block_cbzPk_info;
           _sbyQM::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyQM::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzPk() //  []
         { info_tbl: [(cbzPk,
                       label: block_cbzPk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzPk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyQL_entry() //  [R1]
         { info_tbl: [(cbzPw,
                       label: sat_sbyQL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzPw: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyR9_entry() //  [R1, R2]
         { info_tbl: [(cbzPO,
                       label: sat_sbyR9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzPO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzPP; else goto cbzPQ;
       cbzPP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzPQ: // global
           I64[Sp - 16] = block_cbzPM_info;
           _sbyR4::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyR4::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzPM() //  []
         { info_tbl: [(cbzPM,
                       label: block_cbzPM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzPM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyR3_entry() //  [R1]
         { info_tbl: [(cbzPY,
                       label: sat_sbyR3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzPY: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRg_entry() //  [R1]
         { info_tbl: [(cbzQ5,
                       label: sat_sbyRg_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzQ6; else goto cbzQ7;
       cbzQ6: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbzQ7: // global
           I64[Sp - 16] = block_cbzPF_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzPF() //  [R1]
         { info_tbl: [(cbzPF,
                       label: block_cbzPF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzPF: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbzQa; else goto cbzQ9;
       cbzQa: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzQ9: // global
           I64[Hp - 56] = sat_sbyR9_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyR3_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzQ1_info;
           R2 = Hp - 54;
           _sbyR1::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyR1::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzQ1() //  [R1]
         { info_tbl: [(cbzQ1,
                       label: block_cbzQ1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQ1: // global
           I64[Sp] = block_cbzQ3_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzQ3() //  []
         { info_tbl: [(cbzQ3,
                       label: block_cbzQ3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQ3: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRr_entry() //  [R1, R2]
         { info_tbl: [(cbzQn,
                       label: sat_sbyRr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzQo; else goto cbzQp;
       cbzQo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzQp: // global
           I64[Sp - 16] = block_cbzQl_info;
           _sbyRm::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyRm::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzQl() //  []
         { info_tbl: [(cbzQl,
                       label: block_cbzQl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRl_entry() //  [R1]
         { info_tbl: [(cbzQx,
                       label: sat_sbyRl_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQx: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.appendFile2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzQE,
                       label: System.IO.appendFile2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbzQF; else goto cbzQG;
       cbzQF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.appendFile2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzQG: // global
           I64[Sp - 32] = block_cbzP9_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbzP9() //  [R1]
         { info_tbl: [(cbzP9,
                       label: block_cbzP9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzP9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzQJ; else goto cbzQI;
       cbzQJ: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbzQI: // global
           _sbyQz::P64 = P64[Sp + 8];
           _sbyQA::P64 = P64[Sp + 16];
           if (R1 == 0) goto cbzQC; else goto ubzR2;
       cbzQC: // global
           I64[Hp - 24] = sat_sbyRg_info;
           P64[Hp - 16] = _sbyQz::P64;
           P64[Hp - 8] = _sbyQA::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ubzR2: // global
           if (R1 == 1) goto cbzQD; else goto cbzQB;
       cbzQD: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbzQe_info;
           R3 = _sbyQA::P64;
           R2 = _sbyQz::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       cbzQB: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbzPd_info;
           R3 = _sbyQA::P64;
           R2 = _sbyQz::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzQe() //  [R1]
         { info_tbl: [(cbzQe,
                       label: block_cbzQe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbzQY; else goto cbzQX;
       cbzQY: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzQX: // global
           I64[Hp - 56] = sat_sbyRr_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyRl_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzQT_info;
           R2 = Hp - 54;
           _sbyRj::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyRj::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzQT() //  [R1]
         { info_tbl: [(cbzQT,
                       label: block_cbzQT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQT: // global
           I64[Sp] = block_cbzQV_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzQV() //  []
         { info_tbl: [(cbzQV,
                       label: block_cbzQV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbzPd() //  [R1]
         { info_tbl: [(cbzPd,
                       label: block_cbzPd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzPd: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbzQP; else goto cbzQO;
       cbzQP: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzQO: // global
           I64[Hp - 56] = sat_sbyQR_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyQL_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzQK_info;
           R2 = Hp - 54;
           _sbyQJ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyQJ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzQK() //  [R1]
         { info_tbl: [(cbzQK,
                       label: block_cbzQK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQK: // global
           I64[Sp] = block_cbzQM_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzQM() //  []
         { info_tbl: [(cbzQM,
                       label: block_cbzQM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzQM: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.40147606 UTC

[section ""data" . System.IO.withFile_closure" {
     System.IO.withFile_closure:
         const System.IO.withFile_info;
         const 0;
 },
 System.IO.withFile_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzSp,
                       label: System.IO.withFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzSp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.40507196 UTC

[section ""data" . System.IO.appendFile1_closure" {
     System.IO.appendFile1_closure:
         const System.IO.appendFile1_info;
         const 0;
 },
 sat_sbyRC_entry() //  [R1, R2]
         { info_tbl: [(cbzSF,
                       label: sat_sbyRC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzSF: // global
           R3 = P64[R1 + 6];
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.appendFile1_entry() //  [R2, R3]
         { info_tbl: [(cbzSI,
                       label: System.IO.appendFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzSI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzSM; else goto cbzSL;
       cbzSM: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.appendFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzSL: // global
           I64[Hp - 8] = sat_sbyRC_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = GHC.IO.IOMode.AppendMode_closure+3;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.411217341 UTC

[section ""data" . System.IO.appendFile_closure" {
     System.IO.appendFile_closure:
         const System.IO.appendFile_info;
         const 0;
 },
 System.IO.appendFile_entry() //  [R2, R3]
         { info_tbl: [(cbzSY,
                       label: System.IO.appendFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzSY: // global
           R3 = R3;
           R2 = R2;
           call System.IO.appendFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.414773269 UTC

[section ""data" . System.IO.writeFile1_closure" {
     System.IO.writeFile1_closure:
         const System.IO.writeFile1_info;
         const 0;
 },
 sat_sbyRH_entry() //  [R1, R2]
         { info_tbl: [(cbzTe,
                       label: sat_sbyRH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzTe: // global
           R3 = P64[R1 + 6];
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.writeFile1_entry() //  [R2, R3]
         { info_tbl: [(cbzTh,
                       label: System.IO.writeFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzTh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzTl; else goto cbzTk;
       cbzTl: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.writeFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzTk: // global
           I64[Hp - 8] = sat_sbyRH_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = GHC.IO.IOMode.WriteMode_closure+2;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.42200964 UTC

[section ""data" . System.IO.writeFile_closure" {
     System.IO.writeFile_closure:
         const System.IO.writeFile_info;
         const 0;
 },
 System.IO.writeFile_entry() //  [R2, R3]
         { info_tbl: [(cbzTx,
                       label: System.IO.writeFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzTx: // global
           R3 = R3;
           R2 = R2;
           call System.IO.writeFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.427343745 UTC

[section ""data" . System.IO.withBinaryFile1_closure" {
     System.IO.withBinaryFile1_closure:
         const System.IO.withBinaryFile1_info;
         const 0;
 },
 sat_sbyS0_entry() //  [R1, R2]
         { info_tbl: [(cbzTV,
                       label: sat_sbyS0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzTV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzTW; else goto cbzTX;
       cbzTW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzTX: // global
           I64[Sp - 16] = block_cbzTT_info;
           _sbyRV::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbyRV::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzTT() //  []
         { info_tbl: [(cbzTT,
                       label: block_cbzTT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzTT: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyRU_entry() //  [R1]
         { info_tbl: [(cbzU5,
                       label: sat_sbyRU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzU5: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySi_entry() //  [R1, R2]
         { info_tbl: [(cbzUn,
                       label: sat_sbySi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzUn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzUo; else goto cbzUp;
       cbzUo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzUp: // global
           I64[Sp - 16] = block_cbzUl_info;
           _sbySd::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbySd::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzUl() //  []
         { info_tbl: [(cbzUl,
                       label: block_cbzUl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzUl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySc_entry() //  [R1]
         { info_tbl: [(cbzUx,
                       label: sat_sbySc_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzUx: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySp_entry() //  [R1]
         { info_tbl: [(cbzUE,
                       label: sat_sbySp_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzUE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzUF; else goto cbzUG;
       cbzUF: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbzUG: // global
           I64[Sp - 16] = block_cbzUe_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzUe() //  [R1]
         { info_tbl: [(cbzUe,
                       label: block_cbzUe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzUe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbzUJ; else goto cbzUI;
       cbzUJ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzUI: // global
           I64[Hp - 56] = sat_sbySi_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbySc_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzUA_info;
           R2 = Hp - 54;
           _sbySa::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbySa::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzUA() //  [R1]
         { info_tbl: [(cbzUA,
                       label: block_cbzUA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzUA: // global
           I64[Sp] = block_cbzUC_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzUC() //  []
         { info_tbl: [(cbzUC,
                       label: block_cbzUC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzUC: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySA_entry() //  [R1, R2]
         { info_tbl: [(cbzUW,
                       label: sat_sbySA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzUW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzUX; else goto cbzUY;
       cbzUX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzUY: // global
           I64[Sp - 16] = block_cbzUU_info;
           _sbySv::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbySv::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzUU() //  []
         { info_tbl: [(cbzUU,
                       label: block_cbzUU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzUU: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbySu_entry() //  [R1]
         { info_tbl: [(cbzV6,
                       label: sat_sbySu_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzV6: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.withBinaryFile1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzVd,
                       label: System.IO.withBinaryFile1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzVd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbzVe; else goto cbzVf;
       cbzVe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.withBinaryFile1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbzVf: // global
           I64[Sp - 32] = block_cbzTI_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbzTI() //  [R1]
         { info_tbl: [(cbzTI,
                       label: block_cbzTI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzTI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbzVi; else goto cbzVh;
       cbzVi: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbzVh: // global
           _sbyRI::P64 = P64[Sp + 8];
           _sbyRJ::P64 = P64[Sp + 16];
           if (R1 == 0) goto cbzVb; else goto ubzVB;
       cbzVb: // global
           I64[Hp - 24] = sat_sbySp_info;
           P64[Hp - 16] = _sbyRI::P64;
           P64[Hp - 8] = _sbyRJ::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ubzVB: // global
           if (R1 == 1) goto cbzVc; else goto cbzVa;
       cbzVc: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbzUN_info;
           R3 = _sbyRJ::P64;
           R2 = _sbyRI::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       cbzVa: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbzTM_info;
           R3 = _sbyRJ::P64;
           R2 = _sbyRI::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzUN() //  [R1]
         { info_tbl: [(cbzUN,
                       label: block_cbzUN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzUN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbzVx; else goto cbzVw;
       cbzVx: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzVw: // global
           I64[Hp - 56] = sat_sbySA_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbySu_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzVs_info;
           R2 = Hp - 54;
           _sbySs::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbySs::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzVs() //  [R1]
         { info_tbl: [(cbzVs,
                       label: block_cbzVs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzVs: // global
           I64[Sp] = block_cbzVu_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzVu() //  []
         { info_tbl: [(cbzVu,
                       label: block_cbzVu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzVu: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbzTM() //  [R1]
         { info_tbl: [(cbzTM,
                       label: block_cbzTM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzTM: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbzVo; else goto cbzVn;
       cbzVo: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzVn: // global
           I64[Hp - 56] = sat_sbyS0_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbyRU_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbzVj_info;
           R2 = Hp - 54;
           _sbyRS::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbyRS::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzVj() //  [R1]
         { info_tbl: [(cbzVj,
                       label: block_cbzVj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzVj: // global
           I64[Sp] = block_cbzVl_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzVl() //  []
         { info_tbl: [(cbzVl,
                       label: block_cbzVl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzVl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.466779309 UTC

[section ""data" . System.IO.withBinaryFile_closure" {
     System.IO.withBinaryFile_closure:
         const System.IO.withBinaryFile_info;
         const 0;
 },
 System.IO.withBinaryFile_entry() //  [R2, R3, R4]
         { info_tbl: [(cbzWY,
                       label: System.IO.withBinaryFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzWY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call System.IO.withBinaryFile1_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.470371235 UTC

[section ""data" . lvl_rbyQ6_closure" {
     lvl_rbyQ6_closure:
         const lvl_rbyQ6_info;
 },
 lvl_rbyQ6_entry() //  []
         { info_tbl: [(cbzXe,
                       label: lvl_rbyQ6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzXe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbzXf; else goto cbzXg;
       cbzXf: // global
           R1 = lvl_rbyQ6_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbzXg: // global
           I64[Sp - 8] = block_cbzX9_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cbzX9() //  []
         { info_tbl: [(cbzX9,
                       label: block_cbzX9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzX9: // global
           I64[Sp] = block_cbzXb_info;
           R1 = System.IO.hReady2_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzXb() //  [R1]
         { info_tbl: [(cbzXb,
                       label: block_cbzXb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzXb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzXk; else goto cbzXj;
       cbzXk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzXj: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.477029063 UTC

[section ""data" . tempCounter_rbxCH_closure" {
     tempCounter_rbxCH_closure:
         const tempCounter_rbxCH_info;
         const 0;
         const 0;
         const 0;
 },
 tempCounter_rbxCH_entry() //  [R1]
         { info_tbl: [(cbzXF,
                       label: tempCounter_rbxCH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzXF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzXG; else goto cbzXH;
       cbzXG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzXH: // global
           (_cbzXA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzXA::I64 == 0) goto cbzXC; else goto cbzXB;
       cbzXC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzXB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzXA::I64;
           I64[Sp - 24] = block_cbzXD_info;
           Sp = Sp - 24;
           call lvl_rbyQ6_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbzXD() //  [R1]
         { info_tbl: [(cbzXD,
                       label: block_cbzXD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzXD: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.482594319 UTC

[section ""data" . pathSeparatorChar_rbxCK_closure" {
     pathSeparatorChar_rbxCK_closure:
         const GHC.Types.C#_con_info;
         const 47;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.484827379 UTC

[section ""cstring" . System.IO.$trModule4_bytes" {
     System.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.486501228 UTC

[section ""data" . System.IO.$trModule3_closure" {
     System.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.488050629 UTC

[section ""cstring" . System.IO.$trModule2_bytes" {
     System.IO.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.490145361 UTC

[section ""data" . System.IO.$trModule1_closure" {
     System.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.491794345 UTC

[section ""data" . System.IO.$trModule_closure" {
     System.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.IO.$trModule3_closure+1;
         const System.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.493491582 UTC

[section ""data" . $krep_rbyQ7_closure" {
     $krep_rbyQ7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Error.$tcErrno_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.495192267 UTC

[section ""data" . $krep1_rbyQ8_closure" {
     $krep1_rbyQ8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.496869259 UTC

[section ""cstring" . System.IO.$tcOpenNewFileResult2_bytes" {
     System.IO.$tcOpenNewFileResult2_bytes:
         I8[] [79,112,101,110,78,101,119,70,105,108,101,82,101,115,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.498598934 UTC

[section ""data" . System.IO.$tcOpenNewFileResult1_closure" {
     System.IO.$tcOpenNewFileResult1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tcOpenNewFileResult2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.500225818 UTC

[section ""data" . System.IO.$tcOpenNewFileResult_closure" {
     System.IO.$tcOpenNewFileResult_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tcOpenNewFileResult1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9627069439367662246;
         const 2547759174955940786;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.502015264 UTC

[section ""data" . System.IO.$tc'FileExists1_closure" {
     System.IO.$tc'FileExists1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.IO.$tcOpenNewFileResult_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.50367744 UTC

[section ""cstring" . System.IO.$tc'FileExists3_bytes" {
     System.IO.$tc'FileExists3_bytes:
         I8[] [39,70,105,108,101,69,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.50566681 UTC

[section ""data" . System.IO.$tc'FileExists2_closure" {
     System.IO.$tc'FileExists2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'FileExists3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.507313214 UTC

[section ""data" . System.IO.$tc'FileExists_closure" {
     System.IO.$tc'FileExists_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'FileExists2_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 6704133186904346962;
         const 16997416543076271011;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.509627152 UTC

[section ""data" . System.IO.$tc'NewFileCreated1_closure" {
     System.IO.$tc'NewFileCreated1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rbyQ8_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.51130482 UTC

[section ""cstring" . System.IO.$tc'NewFileCreated3_bytes" {
     System.IO.$tc'NewFileCreated3_bytes:
         I8[] [39,78,101,119,70,105,108,101,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.512916664 UTC

[section ""data" . System.IO.$tc'NewFileCreated2_closure" {
     System.IO.$tc'NewFileCreated2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'NewFileCreated3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.514578432 UTC

[section ""data" . System.IO.$tc'NewFileCreated_closure" {
     System.IO.$tc'NewFileCreated_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'NewFileCreated2_closure+1;
         const System.IO.$tc'NewFileCreated1_closure+4;
         const 9070829168557028496;
         const 15570227817593865145;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.516324763 UTC

[section ""data" . System.IO.$tc'OpenNewError1_closure" {
     System.IO.$tc'OpenNewError1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbyQ7_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.518044377 UTC

[section ""cstring" . System.IO.$tc'OpenNewError3_bytes" {
     System.IO.$tc'OpenNewError3_bytes:
         I8[] [39,79,112,101,110,78,101,119,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.519633412 UTC

[section ""data" . System.IO.$tc'OpenNewError2_closure" {
     System.IO.$tc'OpenNewError2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'OpenNewError3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.52184333 UTC

[section ""data" . System.IO.$tc'OpenNewError_closure" {
     System.IO.$tc'OpenNewError_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'OpenNewError2_closure+1;
         const System.IO.$tc'OpenNewError1_closure+4;
         const 300310999495895268;
         const 12582581010413704951;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.523951313 UTC

[section ""data" . lvl1_rbyQ9_closure" {
     lvl1_rbyQ9_closure:
         const lvl1_rbyQ9_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbyQ9_entry() //  [R1]
         { info_tbl: [(cbzYo,
                       label: lvl1_rbyQ9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzYo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbzYp; else goto cbzYq;
       cbzYp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbzYq: // global
           (_cbzYl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbzYl::I64 == 0) goto cbzYn; else goto cbzYm;
       cbzYn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbzYm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbzYl::I64;
           R2 = GHC.IO.Exception.FixIOException_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionFixIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.528019773 UTC

[section ""data" . System.IO.fixIO3_closure" {
     System.IO.fixIO3_closure:
         const System.IO.fixIO3_info;
         const 0;
 },
 System.IO.fixIO3_entry() //  []
         { info_tbl: [(cbzYC,
                       label: System.IO.fixIO3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzYC: // global
           R1 = lvl1_rbyQ9_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.531971847 UTC

[section ""data" . System.IO.fixIO2_closure" {
     System.IO.fixIO2_closure:
         const System.IO.fixIO2_info;
         const 0;
 },
 sat_sbySX_entry() //  [R1]
         { info_tbl: [(cbzZ5,
                       label: sat_sbySX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzZ5: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.fixIO2_entry() //  [R2]
         { info_tbl: [(cbzZ8,
                       label: System.IO.fixIO2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzZ8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbzZ9; else goto cbzZa;
       cbzZ9: // global
           R2 = R2;
           R1 = System.IO.fixIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbzZa: // global
           I64[Sp - 8] = block_cbzYN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubzZs; else goto cbzYO;
       ubzZs: // global
           call _cbzYN(R1) args: 0, res: 0, upd: 0;
       cbzYO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzYN() //  [R1]
         { info_tbl: [(cbzYN,
                       label: block_cbzYN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzYN: // global
           I64[Sp - 16] = block_cbzYS_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzYS() //  [R1]
         { info_tbl: [(cbzYS,
                       label: block_cbzYS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzYS: // global
           I64[Sp] = block_cbzYW_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbzYW() //  [R1]
         { info_tbl: [(cbzYW,
                       label: block_cbzYW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzYW: // global
           if (R1 & 7 == 1) goto cbzZe; else goto cbzZm;
       cbzZe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbzZh; else goto cbzZg;
       cbzZh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbzZg: // global
           I64[Hp - 8] = sat_sbySX_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbzZm: // global
           I64[Sp + 16] = block_cbzZk_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbzZk() //  []
         { info_tbl: [(cbzZk,
                       label: block_cbzZk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzZk: // global
           R1 = System.IO.fixIO3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.5456909 UTC

[section ""data" . System.IO.fixIO1_closure" {
     System.IO.fixIO1_closure:
         const System.IO.fixIO1_info;
         const 0;
 },
 sat_sbyT6_entry() //  [R1]
         { info_tbl: [(cbA0a,
                       label: sat_sbyT6_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA0a: // global
           R1 = P64[R1 + 7];
           call stg_readMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyT7_entry() //  [R1]
         { info_tbl: [(cbA0d,
                       label: sat_sbyT7_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA0d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbA0h; else goto cbA0g;
       cbA0h: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbA0g: // global
           _sbyT3::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sbyT6_info;
           P64[Hp] = _sbyT3::P64;
           R2 = System.IO.fixIO2_closure+1;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.fixIO1_entry() //  [R2]
         { info_tbl: [(cbA0o,
                       label: System.IO.fixIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA0o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbA0p; else goto cbA0q;
       cbA0p: // global
           R2 = R2;
           R1 = System.IO.fixIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbA0q: // global
           I64[Sp - 16] = block_cbzZY_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cbzZY() //  [R1]
         { info_tbl: [(cbzZY,
                       label: block_cbzZY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbzZY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbA0t; else goto cbA0s;
       cbA0t: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbA0s: // global
           I64[Hp - 8] = sat_sbyT7_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_cbA0i_info;
           R2 = Hp - 7;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbA0i() //  [R1]
         { info_tbl: [(cbA0i,
                       label: block_cbA0i_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA0i: // global
           I64[Sp] = block_cbA0k_info;
           R2 = R1;
           R1 = P64[Sp + 16];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbA0k() //  [R1]
         { info_tbl: [(cbA0k,
                       label: block_cbA0k_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA0k: // global
           _sbyT3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbA0m_info;
           R2 = R1;
           _sbyTd::P64 = R1;
           R1 = _sbyT3::P64;
           P64[Sp + 16] = _sbyTd::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbA0m() //  []
         { info_tbl: [(cbA0m,
                       label: block_cbA0m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA0m: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.559088747 UTC

[section ""data" . System.IO.fixIO_closure" {
     System.IO.fixIO_closure:
         const System.IO.fixIO_info;
         const 0;
 },
 System.IO.fixIO_entry() //  [R2]
         { info_tbl: [(cbA0Z,
                       label: System.IO.fixIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA0Z: // global
           R2 = R2;
           call System.IO.fixIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.562494586 UTC

[section ""cstring" . System.IO.readIO9_bytes" {
     System.IO.readIO9_bytes:
         I8[] [80,114,101,108,117,100,101,46,114,101,97,100,73,79,58,32,110,111,32,112,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.564312242 UTC

[section ""data" . System.IO.readIO8_closure" {
     System.IO.readIO8_closure:
         const System.IO.readIO8_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO8_entry() //  [R1]
         { info_tbl: [(cbA1d,
                       label: System.IO.readIO8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA1d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbA1e; else goto cbA1f;
       cbA1e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbA1f: // global
           (_cbA1a::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbA1a::I64 == 0) goto cbA1c; else goto cbA1b;
       cbA1c: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbA1b: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbA1a::I64;
           R2 = System.IO.readIO9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.568183306 UTC

[section ""data" . System.IO.readIO7_closure" {
     System.IO.readIO7_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.Types.[]_closure+1;
         const System.IO.readIO8_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.570166035 UTC

[section ""data" . System.IO.readIO6_closure" {
     System.IO.readIO6_closure:
         const System.IO.readIO6_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO6_entry() //  [R1]
         { info_tbl: [(cbA1u,
                       label: System.IO.readIO6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA1u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbA1v; else goto cbA1w;
       cbA1v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbA1w: // global
           (_cbA1r::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbA1r::I64 == 0) goto cbA1t; else goto cbA1s;
       cbA1t: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbA1s: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbA1r::I64;
           R2 = System.IO.readIO7_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.574697514 UTC

[section ""cstring" . System.IO.readIO5_bytes" {
     System.IO.readIO5_bytes:
         I8[] [80,114,101,108,117,100,101,46,114,101,97,100,73,79,58,32,97,109,98,105,103,117,111,117,115,32,112,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.576587333 UTC

[section ""data" . System.IO.readIO4_closure" {
     System.IO.readIO4_closure:
         const System.IO.readIO4_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO4_entry() //  [R1]
         { info_tbl: [(cbA1L,
                       label: System.IO.readIO4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA1L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbA1M; else goto cbA1N;
       cbA1M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbA1N: // global
           (_cbA1I::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbA1I::I64 == 0) goto cbA1K; else goto cbA1J;
       cbA1K: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbA1J: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbA1I::I64;
           R2 = System.IO.readIO5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.580811312 UTC

[section ""data" . System.IO.readIO3_closure" {
     System.IO.readIO3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.Types.[]_closure+1;
         const System.IO.readIO4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.582822875 UTC

[section ""data" . System.IO.readIO2_closure" {
     System.IO.readIO2_closure:
         const System.IO.readIO2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO2_entry() //  [R1]
         { info_tbl: [(cbA22,
                       label: System.IO.readIO2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA22: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbA23; else goto cbA24;
       cbA23: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbA24: // global
           (_cbA1Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbA1Z::I64 == 0) goto cbA21; else goto cbA20;
       cbA21: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbA20: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbA1Z::I64;
           R2 = System.IO.readIO3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.588248709 UTC

[section ""data" . System.IO.readIO10_closure" {
     System.IO.readIO10_closure:
         const System.IO.readIO10_info;
         const 0;
 },
 z_sbyTn_entry() //  [R1]
         { info_tbl: [(cbA2w,
                       label: z_sbyTn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA2w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbA2x; else goto cbA2y;
       cbA2x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbA2y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call System.IO.readIO10_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyTy_entry() //  [R1]
         { info_tbl: [(cbA33,
                       label: sat_sbyTy_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA33: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go1_sbyTo_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_sbyTo_entry() //  [R1, R2]
         { info_tbl: [(cbA3a,
                       label: go1_sbyTo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA3a: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbA3b; else goto ubA3z;
       cbA3b: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ubA3z: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cbA2B() args: 0, res: 0, upd: 0;
     }
 },
 _cbA2B() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA2B: // global
           I64[Sp - 16] = block_cbA2E_info;
           R1 = P64[Sp + 8];
           _sbyTo::P64 = P64[Sp];
           P64[Sp - 8] = P64[_sbyTo::P64 + 15];
           P64[Sp + 8] = P64[_sbyTo::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubA3D; else goto cbA2F;
       ubA3D: // global
           call _cbA2E(R1) args: 0, res: 0, upd: 0;
       cbA2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbA2E() //  [R1]
         { info_tbl: [(cbA2E,
                       label: block_cbA2E_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA2E: // global
           if (R1 & 7 == 1) goto cbA37; else goto cbA38;
       cbA37: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbA38: // global
           I64[Sp] = block_cbA2K_info;
           _sbyTs::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _sbyTs::P64;
           if (R1 & 7 != 0) goto ubA3E; else goto cbA2L;
       ubA3E: // global
           call _cbA2K(R1) args: 0, res: 0, upd: 0;
       cbA2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbA2K() //  [R1]
         { info_tbl: [(cbA2K,
                       label: block_cbA2K_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA2K: // global
           I64[Sp - 8] = block_cbA2P_info;
           _sbyTv::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sbyTv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubA3F; else goto cbA2Q;
       ubA3F: // global
           call _cbA2P(R1) args: 0, res: 0, upd: 0;
       cbA2Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbA2P() //  [R1]
         { info_tbl: [(cbA2P,
                       label: block_cbA2P_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA2P: // global
           if (R1 & 7 == 1) goto cbA3j; else goto ubA3A;
       cbA3j: // global
           _sbyTv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbA2U_info;
           R1 = _sbyTv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubA3G; else goto cbA2V;
       ubA3G: // global
           call _cbA2U(R1) args: 0, res: 0, upd: 0;
       cbA2V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubA3A: // global
           Sp = Sp + 16;
           call _cbA3w() args: 0, res: 0, upd: 0;
     }
 },
 _cbA2U() //  [R1]
         { info_tbl: [(cbA2U,
                       label: block_cbA2U_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA2U: // global
           if (R1 & 7 == 1) goto cbA3l; else goto ubA3B;
       cbA3l: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbA3o; else goto cbA3n;
       cbA3o: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbA3n: // global
           I64[Hp - 24] = sat_sbyTy_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ubA3B: // global
           Sp = Sp + 8;
           call _cbA3w() args: 0, res: 0, upd: 0;
     }
 },
 _cbA3w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA3w: // global
           P64[Sp + 16] = P64[Sp];
           Sp = Sp + 8;
           call _cbA2B() args: 0, res: 0, upd: 0;
     }
 },
 System.IO.readIO10_entry() //  [R2]
         { info_tbl: [(cbA3P,
                       label: System.IO.readIO10_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA3P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbA3Q; else goto cbA3R;
       cbA3Q: // global
           R2 = R2;
           R1 = System.IO.readIO10_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbA3R: // global
           I64[Sp - 8] = block_cbA2g_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubA44; else goto cbA2h;
       ubA44: // global
           call _cbA2g(R1) args: 0, res: 0, upd: 0;
       cbA2h: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbA2g() //  [R1]
         { info_tbl: [(cbA2g,
                       label: block_cbA2g_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA2g: // global
           if (R1 & 7 == 1) goto cbA3M; else goto cbA3N;
       cbA3M: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbA3N: // global
           I64[Sp - 8] = block_cbA2m_info;
           _sbyTi::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbyTi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubA43; else goto cbA2n;
       ubA43: // global
           call _cbA2m(R1) args: 0, res: 0, upd: 0;
       cbA2n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbA2m() //  [R1]
         { info_tbl: [(cbA2m,
                       label: block_cbA2m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA2m: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbA3Y; else goto cbA3X;
       cbA3Y: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbA3X: // global
           _sbyTk::P64 = P64[R1 + 7];
           _sbyTl::P64 = P64[R1 + 15];
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sbyTk::P64;
           P64[Hp - 48] = GHC.Types.[]_closure+1;
           I64[Hp - 40] = z_sbyTn_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = go1_sbyTo_info;
           P64[Hp - 8] = Hp - 62;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbA3U_info;
           R3 = _sbyTl::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 8] = Hp - 15;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbA3U() //  [R1]
         { info_tbl: [(cbA3U,
                       label: block_cbA3U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA3U: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sbyTo_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.613803324 UTC

[section ""data" . System.IO.readIO1_closure" {
     System.IO.readIO1_closure:
         const System.IO.readIO1_info;
         const 0;
 },
 System.IO.readIO1_entry() //  [R2, R3]
         { info_tbl: [(cbA5g,
                       label: System.IO.readIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA5g: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbA5h; else goto cbA5i;
       cbA5h: // global
           R3 = R3;
           R2 = R2;
           R1 = System.IO.readIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbA5i: // global
           I64[Sp - 8] = block_cbA5e_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           P64[Sp - 16] = R3;
           Sp = Sp - 32;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbA5e() //  [R1]
         { info_tbl: [(cbA5e,
                       label: block_cbA5e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA5e: // global
           I64[Sp] = block_cbA5l_info;
           R2 = R1;
           call System.IO.readIO10_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbA5l() //  [R1]
         { info_tbl: [(cbA5l,
                       label: block_cbA5l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA5l: // global
           if (R1 & 7 == 1) goto cbA5s; else goto cbA5x;
       cbA5s: // global
           R1 = System.IO.readIO6_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbA5x: // global
           I64[Sp - 8] = block_cbA5v_info;
           _sbyTJ::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sbyTJ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubA5L; else goto cbA5y;
       ubA5L: // global
           call _cbA5v(R1) args: 0, res: 0, upd: 0;
       cbA5y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbA5v() //  [R1]
         { info_tbl: [(cbA5v,
                       label: block_cbA5v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA5v: // global
           if (R1 & 7 == 1) goto cbA5E; else goto cbA5I;
       cbA5E: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbA5I: // global
           R1 = System.IO.readIO2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.623194418 UTC

[section ""data" . System.IO.readIO_closure" {
     System.IO.readIO_closure:
         const System.IO.readIO_info;
         const 0;
 },
 System.IO.readIO_entry() //  [R2, R3]
         { info_tbl: [(cbA6a,
                       label: System.IO.readIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA6a: // global
           R3 = R3;
           R2 = R2;
           call System.IO.readIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.626653792 UTC

[section ""data" . System.IO.readLn1_closure" {
     System.IO.readLn1_closure:
         const System.IO.readLn1_info;
         const 0;
 },
 section ""relreadonly" . ubA6r_srtd" {
     ubA6r_srtd:
         const SbyXw_srt+56;
         const 36;
         const 38654705769;
 },
 System.IO.readLn1_entry() //  [R2]
         { info_tbl: [(cbA6n,
                       label: System.IO.readLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA6n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbA6o; else goto cbA6p;
       cbA6o: // global
           R2 = R2;
           R1 = System.IO.readLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbA6p: // global
           I64[Sp - 16] = block_cbA6l_info;
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           _sbyTO::P64 = R2;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           P64[Sp - 8] = _sbyTO::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbA6l() //  [R1]
         { info_tbl: [(cbA6l,
                       label: block_cbA6l_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA6l: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call System.IO.readIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.632798038 UTC

[section ""data" . System.IO.readLn_closure" {
     System.IO.readLn_closure:
         const System.IO.readLn_info;
         const 0;
 },
 System.IO.readLn_entry() //  [R2]
         { info_tbl: [(cbA6F,
                       label: System.IO.readLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA6F: // global
           R2 = R2;
           call System.IO.readLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.636288962 UTC

[section ""data" . System.IO.readFile1_closure" {
     System.IO.readFile1_closure:
         const System.IO.readFile1_info;
         const 0;
 },
 System.IO.readFile1_entry() //  [R2]
         { info_tbl: [(cbA6S,
                       label: System.IO.readFile1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA6S: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbA6T; else goto cbA6U;
       cbA6T: // global
           R2 = R2;
           R1 = System.IO.readFile1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbA6U: // global
           I64[Sp - 8] = block_cbA6Q_info;
           R3 = GHC.IO.IOMode.ReadMode_closure+1;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbA6Q() //  [R1]
         { info_tbl: [(cbA6Q,
                       label: block_cbA6Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA6Q: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.641553849 UTC

[section ""data" . System.IO.readFile_closure" {
     System.IO.readFile_closure:
         const System.IO.readFile_info;
         const 0;
 },
 System.IO.readFile_entry() //  [R2]
         { info_tbl: [(cbA78,
                       label: System.IO.readFile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA78: // global
           R2 = R2;
           call System.IO.readFile1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.645751354 UTC

[section ""data" . System.IO.interact1_closure" {
     System.IO.interact1_closure:
         const System.IO.interact1_info;
         const 0;
 },
 sat_sbyU3_entry() //  [R1]
         { info_tbl: [(cbA7p,
                       label: sat_sbyU3_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA7p: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubA7y_srtd" {
     ubA7y_srtd:
         const SbyXw_srt;
         const 45;
         const 17592186078273;
 },
 System.IO.interact1_entry() //  [R2]
         { info_tbl: [(cbA7s,
                       label: System.IO.interact1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA7s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbA7t; else goto cbA7u;
       cbA7t: // global
           R2 = R2;
           R1 = System.IO.interact1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbA7u: // global
           I64[Sp - 16] = block_cbA7j_info;
           _sbyTY::P64 = R2;
           R2 = GHC.IO.Handle.FD.stdin_closure;
           P64[Sp - 8] = _sbyTY::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbA7j() //  [R1]
         { info_tbl: [(cbA7j,
                       label: block_cbA7j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA7j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbA7x; else goto cbA7w;
       cbA7x: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbA7w: // global
           I64[Hp - 24] = sat_sbyU3_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.65382691 UTC

[section ""data" . System.IO.interact_closure" {
     System.IO.interact_closure:
         const System.IO.interact_info;
         const 0;
 },
 System.IO.interact_entry() //  [R2]
         { info_tbl: [(cbA7Q,
                       label: System.IO.interact_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA7Q: // global
           R2 = R2;
           call System.IO.interact1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.656912966 UTC

[section ""cstring" . lvl2_rbyQa_bytes" {
     lvl2_rbyQa_bytes:
         I8[] [98,117,103,32,105,110,32,83,121,115,116,101,109,46,73,79,46,111,112,101,110,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.658900994 UTC

[section ""data" . lvl3_rbyQb_closure" {
     lvl3_rbyQb_closure:
         const lvl3_rbyQb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbyQb_entry() //  [R1]
         { info_tbl: [(cbA86,
                       label: lvl3_rbyQb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA86: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbA87; else goto cbA88;
       cbA87: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbA88: // global
           (_cbA81::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbA81::I64 == 0) goto cbA83; else goto cbA82;
       cbA83: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbA82: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbA81::I64;
           I64[Sp - 24] = block_cbA84_info;
           R2 = lvl2_rbyQa_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbA84() //  [R1]
         { info_tbl: [(cbA84,
                       label: block_cbA84_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA84: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.664186901 UTC

[section ""data" . lvl4_rbyQc_closure" {
     lvl4_rbyQc_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.666522561 UTC

[section ""data" . lvl5_rbyQd_closure" {
     lvl5_rbyQd_closure:
         const lvl5_rbyQd_info;
 },
 lvl5_rbyQd_entry() //  [R2]
         { info_tbl: [(cbA8u,
                       label: lvl5_rbyQd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA8u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbA8v; else goto cbA8w;
       cbA8v: // global
           R2 = R2;
           R1 = lvl5_rbyQd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbA8w: // global
           I64[Sp - 8] = block_cbA8r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubA8E; else goto cbA8s;
       ubA8E: // global
           call _cbA8r(R1) args: 0, res: 0, upd: 0;
       cbA8s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbA8r() //  [R1]
         { info_tbl: [(cbA8r,
                       label: block_cbA8r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA8r: // global
           if (I64[R1 + 7] == 46) goto cbA8D; else goto cbA8C;
       cbA8D: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbA8C: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.672236404 UTC

[section ""data" . lvl6_rbyQe_closure" {
     lvl6_rbyQe_closure:
         const lvl6_rbyQe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rbyQe_entry() //  [R1]
         { info_tbl: [(cbA93,
                       label: lvl6_rbyQe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbA93: // global
           _rbyQe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbA9M; else goto cbA9N;
       cbA9N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbA9P; else goto cbA9O;
       cbA9P: // global
           HpAlloc = 16;
           goto cbA9M;
       cbA9M: // global
           R1 = _rbyQe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbA9O: // global
           (_cbA8T::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbyQe::P64);
           if (_cbA8T::I64 == 0) goto cbA8V; else goto cbA8U;
       cbA8V: // global
           call (I64[I64[_rbyQe::P64]])() args: 8, res: 0, upd: 8;
       cbA8U: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbA8T::I64;
           (_sbyUc::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_nonblock();
           (_sbyUg::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_noctty();
           (_sbyUk::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_creat();
           (_sbyUo::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_rdwr();
           (_sbyUs::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_excl();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUc::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUg::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUk::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUo::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyUs::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.677729111 UTC

[section ""data" . $wlvl_rbyQf_closure" {
     $wlvl_rbyQf_closure:
         const $wlvl_rbyQf_info;
         const 0;
 },
 sat_sbyUN_entry() //  [R1]
         { info_tbl: [(cbAak,
                       label: sat_sbyUN_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAak: // global
           _sbyUN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbAal; else goto cbAam;
       cbAam: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAao; else goto cbAan;
       cbAao: // global
           HpAlloc = 16;
           goto cbAal;
       cbAal: // global
           R1 = _sbyUN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAan: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbyUN::P64;
           _sbyUJ::P64 = P64[_sbyUN::P64 + 16];
           _sbyUK::P64 = P64[_sbyUN::P64 + 24];
           _sbyUI::I64 = I64[_sbyUN::P64 + 32];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbyUK::P64;
           R5 = Hp - 6;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = _sbyUI::I64;
           R2 = _sbyUJ::P64;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyUO_entry() //  [R1]
         { info_tbl: [(cbAap,
                       label: sat_sbyUO_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAap: // global
           _sbyUO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbAaq; else goto cbAar;
       cbAar: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbAat; else goto cbAas;
       cbAat: // global
           HpAlloc = 40;
           goto cbAaq;
       cbAaq: // global
           R1 = _sbyUO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAas: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbyUO::P64;
           _sbyUJ::P64 = P64[_sbyUO::P64 + 16];
           _sbyUK::P64 = P64[_sbyUO::P64 + 24];
           _sbyUI::I64 = I64[_sbyUO::P64 + 32];
           I64[Hp - 32] = sat_sbyUN_info;
           P64[Hp - 16] = _sbyUJ::P64;
           P64[Hp - 8] = _sbyUK::P64;
           I64[Hp] = _sbyUI::I64;
           R2 = Hp - 32;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rbyQf_entry() //  [R2, R3, R4]
         { info_tbl: [(cbAau,
                       label: $wlvl_rbyQf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAau: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbAay; else goto cbAax;
       cbAay: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_rbyQf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAax: // global
           I64[Hp - 32] = sat_sbyUO_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.687090574 UTC

[section ""data" . lvl7_rbyQg_closure" {
     lvl7_rbyQg_closure:
         const lvl7_rbyQg_info;
         const 0;
 },
 lvl7_rbyQg_entry() //  [R2, R3, R4]
         { info_tbl: [(cbAaS,
                       label: lvl7_rbyQg_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAaS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbAaT; else goto cbAaU;
       cbAaT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl7_rbyQg_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAaU: // global
           I64[Sp - 24] = block_cbAaP_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubAaY; else goto cbAaQ;
       ubAaY: // global
           call _cbAaP(R1) args: 0, res: 0, upd: 0;
       cbAaQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAaP() //  [R1]
         { info_tbl: [(cbAaP,
                       label: block_cbAaP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAaP: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call $wlvl_rbyQf_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.692756399 UTC

[section ""data" . lvl8_rbyQh_closure" {
     lvl8_rbyQh_closure:
         const lvl8_rbyQh_info;
 },
 sat_sbyUZ_entry() //  [R1]
         { info_tbl: [(cbAbj,
                       label: sat_sbyUZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAbj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbAbq; else goto cbAbr;
       cbAbq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAbr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbAbg_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubAbv; else goto cbAbh;
       ubAbv: // global
           call _cbAbg(R1) args: 0, res: 0, upd: 0;
       cbAbh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAbg() //  [R1]
         { info_tbl: [(cbAbg,
                       label: block_cbAbg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAbg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAbu; else goto cbAbt;
       cbAbu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbAbt: // global
           _sbyUY::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbyUY::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_rbyQh_entry() //  [R2]
         { info_tbl: [(cbAbx,
                       label: lvl8_rbyQh_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAbx: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbAbB; else goto cbAbA;
       cbAbB: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = lvl8_rbyQh_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAbA: // global
           I64[Hp - 40] = sat_sbyUZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.700306901 UTC

[section ""data" . go_rbyQi_closure" {
     go_rbyQi_closure:
         const go_rbyQi_info;
 },
 go_rbyQi_entry() //  [R2, R3]
         { info_tbl: [(cbAc3,
                       label: go_rbyQi_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAc3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAc4; else goto ubAcc;
       cbAc4: // global
           R3 = R3;
           R2 = R2;
           R1 = go_rbyQi_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubAcc: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbAbT() args: 0, res: 0, upd: 0;
     }
 },
 _cbAbT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAbT: // global
           _sbyV0::P64 = P64[Sp];
           I64[Sp] = block_cbAbW_info;
           R1 = _sbyV0::P64;
           if (R1 & 7 != 0) goto ubAce; else goto cbAbX;
       ubAce: // global
           call _cbAbW(R1) args: 0, res: 0, upd: 0;
       cbAbX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAbW() //  [R1]
         { info_tbl: [(cbAbW,
                       label: block_cbAbW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAbW: // global
           if (R1 & 7 == 1) goto cbAc0; else goto cbAc1;
       cbAc0: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbAc1: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cbAbT() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.706950868 UTC

[section ""cstring" . lvl9_rbyQj_bytes" {
     lvl9_rbyQj_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.708588186 UTC

[section ""cstring" . lvl10_rbyQk_bytes" {
     lvl10_rbyQk_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101,39,58,32,84,101,109,112,108,97,116,101,32,115,116,114,105,110,103,32,109,117,115,116,32,110,111,116,32,99,111,110,116,97,105,110,32,112,97,116,104,32,115,101,112,97,114,97,116,111,114,32,99,104,97,114,97,99,116,101,114,115,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.7105586 UTC

[section ""data" . lvl11_rbyQl_closure" {
     lvl11_rbyQl_closure:
         const lvl11_rbyQl_info;
         const 0;
 },
 lvl11_rbyQl_entry() //  [R2]
         { info_tbl: [(cbAcG,
                       label: lvl11_rbyQl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAcG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbAcH; else goto cbAcI;
       cbAcH: // global
           R2 = R2;
           R1 = lvl11_rbyQl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAcI: // global
           I64[Sp - 8] = block_cbAcE_info;
           R3 = R2;
           R2 = lvl10_rbyQk_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAcE() //  [R1]
         { info_tbl: [(cbAcE,
                       label: block_cbAcE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAcE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.722262971 UTC

[section ""data" . System.IO.openBinaryTempFile5_closure" {
     System.IO.openBinaryTempFile5_closure:
         const System.IO.openBinaryTempFile5_info;
         const 0;
 },
 sat_sbyVl_entry() //  [R1]
         { info_tbl: [(cbAdl,
                       label: sat_sbyVl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAdl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAdm; else goto cbAdn;
       cbAdm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAdn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyVs_entry() //  [R1]
         { info_tbl: [(cbAdC,
                       label: sat_sbyVs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAdC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAdD; else goto cbAdE;
       cbAdD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAdE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyVr_entry() //  [R1]
         { info_tbl: [(cbAdK,
                       label: sat_sbyVr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAdK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAdL; else goto cbAdM;
       cbAdL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAdM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sbyVf_entry() //  [R1]
         { info_tbl: [(cbAdN,
                       label: ds_sbyVf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAdN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbAdO; else goto cbAdP;
       cbAdO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAdP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbAd6_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbAd6() //  [R1]
         { info_tbl: [(cbAd6,
                       label: block_cbAd6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAd6: // global
           I64[Sp] = block_cbAda_info;
           R3 = R1;
           R2 = lvl5_rbyQd_closure+1;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbAda() //  [R1, R2]
         { info_tbl: [(cbAda,
                       label: block_cbAda_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAda: // global
           I64[Sp - 8] = block_cbAdc_info;
           _sbyVi::P64 = R1;
           R1 = R2;
           P64[Sp] = _sbyVi::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubAe8; else goto cbAdd;
       ubAe8: // global
           call _cbAdc(R1) args: 0, res: 0, upd: 0;
       cbAdd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAdc() //  [R1]
         { info_tbl: [(cbAdc,
                       label: block_cbAdc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAdc: // global
           if (R1 & 7 == 1) goto cbAdU; else goto cbAdZ;
       cbAdU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbAdX; else goto cbAdW;
       cbAdX: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbAdW: // global
           I64[Hp - 40] = sat_sbyVl_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbAdZ: // global
           I64[Sp - 8] = block_cbAdq_info;
           _sbyVn::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbyVn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubAe9; else goto cbAdr;
       ubAe9: // global
           call _cbAdq(R1) args: 0, res: 0, upd: 0;
       cbAdr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAdq() //  [R1]
         { info_tbl: [(cbAdq,
                       label: block_cbAdq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAdq: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbAe2; else goto cbAe1;
       cbAe2: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbAe1: // global
           if (I64[R1 + 7] == 46) goto cbAe6; else goto cbAe4;
       cbAe6: // global
           I64[Hp - 88] = sat_sbyVs_info;
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = lvl4_rbyQc_closure+1;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = sat_sbyVr_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbAe4: // global
           Hp = Hp - 96;
           R1 = lvl3_rbyQb_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 oflags_sbyVu_entry() //  [R1]
         { info_tbl: [(cbAeh,
                       label: oflags_sbyVu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAeh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbAei; else goto cbAej;
       cbAei: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAej: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbAee_info;
           _sbyVb::P64 = P64[R1 + 16];
           R1 = lvl6_rbyQe_closure;
           P64[Sp - 24] = _sbyVb::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubAeU; else goto cbAef;
       ubAeU: // global
           call _cbAee(R1) args: 0, res: 0, upd: 0;
       cbAef: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAee() //  [R1]
         { info_tbl: [(cbAee,
                       label: block_cbAee_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAee: // global
           I64[Sp - 8] = block_cbAem_info;
           _sbyVv::P64 = R1;
           _sbyVw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _sbyVw::I64;
           P64[Sp + 8] = _sbyVv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubAeT; else goto cbAeo;
       ubAeT: // global
           call _cbAem(R1) args: 0, res: 0, upd: 0;
       cbAeo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAem() //  [R1]
         { info_tbl: [(cbAem,
                       label: block_cbAem_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAem: // global
           if (R1 & 7 == 1) goto cbAeu; else goto cbAeO;
       cbAeu: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbAeO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAeR; else goto cbAeQ;
       cbAeR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbAeQ: // global
           _sbyVw::I64 = I64[Sp + 8];
           (_sbyVB::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_binary();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sbyVw::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyVB::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_sbyVH_entry() //  [R1, R2]
         { info_tbl: [(cbAf3,
                       label: lvl12_sbyVH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAf3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbAfo; else goto cbAfp;
       cbAfo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAfp: // global
           I64[Sp - 24] = block_cbAf0_info;
           _sbyVc::P64 = P64[R1 + 6];
           _sbyVu::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbyVc::P64;
           P64[Sp - 8] = _sbyVu::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubAfw; else goto cbAf1;
       ubAfw: // global
           call _cbAf0(R1) args: 0, res: 0, upd: 0;
       cbAf1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAf0() //  [R1]
         { info_tbl: [(cbAf0,
                       label: block_cbAf0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAf0: // global
           I64[Sp] = block_cbAf6_info;
           _sbyVL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sbyVL::I64;
           if (R1 & 7 != 0) goto ubAfv; else goto cbAf7;
       ubAfv: // global
           call _cbAf6(R1) args: 0, res: 0, upd: 0;
       cbAf7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAf6() //  [R1]
         { info_tbl: [(cbAf6,
                       label: block_cbAf6_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAf6: // global
           I64[Sp] = block_cbAfb_info;
           _sbyVN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sbyVN::I64;
           if (R1 & 7 != 0) goto ubAfx; else goto cbAfc;
       ubAfx: // global
           call _cbAfb(R1) args: 0, res: 0, upd: 0;
       cbAfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAfb() //  [R1]
         { info_tbl: [(cbAfb,
                       label: block_cbAfb_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAfb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAfu; else goto cbAft;
       cbAfu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAft: // global
           (_sbyVT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     signed,]  result hints:  [signed] __hscore_open(I64[Sp + 16], I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyVT::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyVX_entry() //  [R1]
         { info_tbl: [(cbAfG,
                       label: sat_sbyVX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAfG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAfH; else goto cbAfI;
       cbAfH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAfI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.List.lastError_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_rbyQi_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl13_sbyVW_entry() //  [R1]
         { info_tbl: [(cbAfK,
                       label: lvl13_sbyVW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAfK: // global
           _sbyVW::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbAfL; else goto cbAfM;
       cbAfM: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbAfO; else goto cbAfN;
       cbAfO: // global
           HpAlloc = 48;
           goto cbAfL;
       cbAfL: // global
           R1 = _sbyVW::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAfN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbyVW::P64;
           _sbyV9::P64 = P64[_sbyVW::P64 + 16];
           I64[Hp - 40] = sat_sbyVX_info;
           P64[Hp - 24] = _sbyV9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R4 = Hp - 14;
           R3 = pathSeparatorChar_rbxCK_closure+1;
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp - 16;
           call GHC.List.elem_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyWv_entry() //  [R1]
         { info_tbl: [(cbAgz,
                       label: sat_sbyWv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAgz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbAgF; else goto cbAgG;
       cbAgF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAgG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbAgw_info;
           _sbyWj::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbyWj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubAgL; else goto cbAgx;
       ubAgL: // global
           call _cbAgw(R1) args: 0, res: 0, upd: 0;
       cbAgx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAgw() //  [R1]
         { info_tbl: [(cbAgw,
                       label: block_cbAgw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAgw: // global
           I64[Sp] = block_cbAgC_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbAgC() //  [R1, R2]
         { info_tbl: [(cbAgC,
                       label: block_cbAgC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAgC: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbAgK; else goto cbAgJ;
       cbAgK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbAgJ: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbyWw_entry() //  [R1]
         { info_tbl: [(cbAgM,
                       label: sat_sbyWw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAgM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbAgQ; else goto cbAgP;
       cbAgQ: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAgP: // global
           _sbyWc::P64 = P64[R1 + 16];
           _sbyWj::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbyWv_info;
           P64[Hp - 8] = _sbyWc::P64;
           P64[Hp] = _sbyWj::P64;
           R3 = Hp - 24;
           R2 = lvl9_rbyQj_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbyWx_entry() //  [R1]
         { info_tbl: [(cbAgR,
                       label: sat_sbyWx_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAgR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbAgT; else goto cbAgU;
       cbAgT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAgU: // global
           I64[Sp - 24] = block_cbAgm_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 32]));
           R2 = 0;
           P64[Sp - 16] = P64[R1 + 16];
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAgm() //  [R1, R2]
         { info_tbl: [(cbAgm,
                       label: block_cbAgm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAgm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbAgX; else goto cbAgW;
       cbAgX: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cbAgW: // global
           I64[Hp - 48] = sat_sbyWw_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 filepath_sbyWg_entry() //  [R1]
         { info_tbl: [(cbAgY,
                       label: filepath_sbyWg_info
                       rep:HeapRep 4 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAgY: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbAgZ; else goto cbAh0;
       cbAgZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAh0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cbAga_info;
           _sbyV9::P64 = P64[R1 + 16];
           _sbyVW::P64 = P64[R1 + 32];
           _sbyWc::P64 = P64[R1 + 40];
           _sbyW7::I64 = I64[R1 + 48];
           R1 = P64[R1 + 24];
           P64[Sp - 48] = _sbyV9::P64;
           P64[Sp - 40] = _sbyVW::P64;
           I64[Sp - 32] = _sbyW7::I64;
           P64[Sp - 24] = _sbyWc::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ubAhJ; else goto cbAgb;
       ubAhJ: // global
           call _cbAga(R1) args: 0, res: 0, upd: 0;
       cbAgb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAga() //  [R1]
         { info_tbl: [(cbAga,
                       label: block_cbAga_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAga: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbAh4; else goto cbAh3;
       cbAh4: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbAh3: // global
           _sbyWi::P64 = P64[R1 + 7];
           _sbyWj::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sbyWx_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = _sbyWj::P64;
           I64[Hp] = I64[Sp + 24];
           I64[Sp] = block_cbAh1_info;
           R3 = Hp - 32;
           R2 = _sbyWi::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbAh1() //  [R1]
         { info_tbl: [(cbAh1,
                       label: block_cbAh1_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAh1: // global
           _sbyV9::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbAha; else goto cbAhf;
       cbAha: // global
           R1 = _sbyV9::P64 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbAhf: // global
           I64[Sp + 8] = block_cbAhd_info;
           _sbyWy::P64 = R1;
           R1 = _sbyV9::P64;
           P64[Sp + 32] = _sbyWy::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubAhK; else goto cbAhg;
       ubAhK: // global
           call _cbAhd(R1) args: 0, res: 0, upd: 0;
       cbAhg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAhd() //  [R1]
         { info_tbl: [(cbAhd,
                       label: block_cbAhd_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAhd: // global
           if (R1 & 7 == 1) goto cbAhm; else goto cbAhr;
       cbAhm: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbAhr: // global
           _sbyVW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbAhp_info;
           _sbyWB::P64 = R1;
           R1 = _sbyVW::P64;
           P64[Sp + 16] = _sbyWB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubAhL; else goto cbAhs;
       ubAhL: // global
           call _cbAhp(R1) args: 0, res: 0, upd: 0;
       cbAhs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAhp() //  [R1]
         { info_tbl: [(cbAhp,
                       label: block_cbAhp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAhp: // global
           _sbyWy::P64 = P64[Sp + 16];
           _sbyWB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbAhy; else goto cbAhF;
       cbAhy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbAhB; else goto cbAhA;
       cbAhB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbAhA: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = pathSeparatorChar_rbxCK_closure+1;
           P64[Hp] = _sbyWy::P64;
           R3 = Hp - 14;
           R2 = _sbyWB::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbAhF: // global
           R3 = _sbyWy::P64;
           R2 = _sbyWB::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.IO.openBinaryTempFile5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbAhQ,
                       label: System.IO.openBinaryTempFile5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAhQ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbAhR; else goto cbAhS;
       cbAhR: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.openBinaryTempFile5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAhS: // global
           I64[Sp - 48] = block_cbAcY_info;
           _sbyVa::P64 = R4;
           R4 = R4;
           _sbyV9::P64 = R3;
           R3 = pathSeparatorChar_rbxCK_closure+1;
           _sbyV8::P64 = R2;
           R2 = GHC.Classes.$fEqChar_closure;
           P64[Sp - 40] = _sbyV8::P64;
           P64[Sp - 32] = _sbyV9::P64;
           P64[Sp - 24] = _sbyVa::P64;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAcY() //  [R1]
         { info_tbl: [(cbAcY,
                       label: block_cbAcY_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAcY: // global
           _sbyVa::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cbAhN; else goto cbAhO;
       cbAhN: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbAhV; else goto cbAhU;
       cbAhV: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAhU: // global
           I64[Hp - 88] = ds_sbyVf_info;
           P64[Hp - 72] = _sbyVa::P64;
           I64[Hp - 64] = oflags_sbyVu_info;
           P64[Hp - 48] = P64[Sp + 32];
           I64[Hp - 40] = lvl12_sbyVH_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = lvl13_sbyVW_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 38;
           P64[Sp + 40] = Hp - 88;
           Sp = Sp + 8;
           call _cbAfU() args: 0, res: 0, upd: 0;
       cbAhO: // global
           R2 = _sbyVa::P64;
           Sp = Sp + 48;
           call lvl11_rbyQl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbAfU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAfU: // global
           (_sbyW7::I64) = call "ccall" arg hints:  []  result hints:  [signed] getpid();
           I64[Sp - 16] = block_cbAfX_info;
           R1 = tempCounter_rbxCH_closure;
           I64[Sp - 8] = _sbyW7::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubAjJ; else goto cbAfY;
       ubAjJ: // global
           call _cbAfX(R1) args: 0, res: 0, upd: 0;
       cbAfY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAfX() //  [R1]
         { info_tbl: [(cbAfX,
                       label: block_cbAfX_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAfX: // global
           I64[Sp] = block_cbAg2_info;
           R2 = lvl8_rbyQh_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAg2() //  [R1]
         { info_tbl: [(cbAg2,
                       label: block_cbAg2_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAg2: // global
           I64[Sp - 8] = block_cbAg4_info;
           _sbyWc::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp] = _sbyWc::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAg4() //  [R1]
         { info_tbl: [(cbAg4,
                       label: block_cbAg4_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAg4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbAi8; else goto cbAi7;
       cbAi8: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAi7: // global
           I64[Hp - 48] = filepath_sbyWg_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 56];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 8] = block_cbAi0_info;
           R4 = P64[Sp + 48];
           _cbAg6::P64 = Hp - 48;
           R3 = _cbAg6::P64;
           R2 = R1;
           P64[Sp + 16] = _cbAg6::P64;
           Sp = Sp + 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAi0() //  [R1]
         { info_tbl: [(cbAi0,
                       label: block_cbAi0_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAi0: // global
           I64[Sp] = block_cbAi2_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubAjK; else goto cbAia;
       ubAjK: // global
           call _cbAi2(R1) args: 0, res: 0, upd: 0;
       cbAia: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAi2() //  [R1]
         { info_tbl: [(cbAi2,
                       label: block_cbAi2_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAi2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAig; else goto cbAif;
       cbAig: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAif: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cbAj7; else goto cbAjs;
       cbAj7: // global
           I64[Hp - 8] = System.IO.NewFileCreated_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 7;
           goto ubAjN;
       cbAjs: // global
           (_sbyXd::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_get_errno();
           Hp = Hp - 16;
           _sbyXe::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbyXd::I64));
           if (_sbyXe::I64 != 17) goto ubAjD; else goto cbAjo;
       ubAjD: // global
           I64[Sp] = _sbyXe::I64;
           call _cbAjh() args: 0, res: 0, upd: 0;
       cbAjo: // global
           P64[Sp] = System.IO.FileExists_closure+2;
           goto ubAjN;
       ubAjN: // global
           call _sbyWL() args: 0, res: 0, upd: 0;
     }
 },
 _cbAjh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAjh: // global
           Hp = Hp + 32;
           _sbyXe::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cbAjl; else goto cbAjk;
       cbAjl: // global
           HpAlloc = 32;
           I64[Sp] = block_cbAje_info;
           R1 = _sbyXe::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbAjk: // global
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = _sbyXe::I64;
           I64[Hp - 8] = System.IO.OpenNewError_con_info;
           P64[Hp] = Hp - 23;
           P64[Sp] = Hp - 5;
           call _sbyWL() args: 0, res: 0, upd: 0;
     }
 },
 _cbAje() //  [R1]
         { info_tbl: [(cbAje,
                       label: block_cbAje_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAje: // global
           I64[Sp] = R1;
           call _cbAjh() args: 0, res: 0, upd: 0;
     }
 },
 _sbyWL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbyWL: // global
           _sbyWN::P64 = P64[Sp];
           I64[Sp] = block_cbAim_info;
           R1 = _sbyWN::P64;
           if (R1 & 7 != 0) goto ubAjT; else goto cbAio;
       ubAjT: // global
           call _cbAim(R1) args: 0, res: 0, upd: 0;
       cbAio: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAim() //  [R1]
         { info_tbl: [(cbAim,
                       label: block_cbAim_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAim: // global
           _cbAjz::P64 = R1 & 7;
           if (_cbAjz::P64 < 3) goto ubAjA; else goto cbAj3;
       ubAjA: // global
           if (_cbAjz::P64 < 2) goto cbAiM; else goto ubAjH;
       cbAiM: // global
           I64[Sp] = block_cbAis_info;
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R2 = P64[R1 + 7];
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       ubAjH: // global
           Sp = Sp + 16;
           call _cbAfU() args: 0, res: 0, upd: 0;
       cbAj3: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[R1 + 5];
           Sp = Sp + 56;
           call lvl7_rbyQg_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbAis() //  [R1]
         { info_tbl: [(cbAis,
                       label: block_cbAis_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAis: // global
           I64[Sp] = block_cbAiu_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubAjP; else goto cbAiv;
       ubAjP: // global
           call _cbAiu(R1) args: 0, res: 0, upd: 0;
       cbAiv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAiu() //  [R1]
         { info_tbl: [(cbAiu,
                       label: block_cbAiu_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAiu: // global
           I64[Sp] = block_cbAiz_info;
           _sbyWU::P64 = P64[R1 + 7];
           _sbyWV::P64 = P64[R1 + 15];
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           P64[Sp + 40] = _sbyWV::P64;
           P64[Sp + 48] = _sbyWU::P64;
           if (R1 & 7 != 0) goto ubAjQ; else goto cbAiA;
       ubAjQ: // global
           call _cbAiz(R1) args: 0, res: 0, upd: 0;
       cbAiA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAiz() //  [R1]
         { info_tbl: [(cbAiz,
                       label: block_cbAiz_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAiz: // global
           I64[Sp] = block_cbAiE_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAiE() //  [R1]
         { info_tbl: [(cbAiE,
                       label: block_cbAiE_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAiE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAiS; else goto cbAiR;
       cbAiS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAiR: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           I64[Sp] = block_cbAiH_info;
           R6 = GHC.Types.False_closure+1;
           R5 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbAiH() //  [R1]
         { info_tbl: [(cbAiH,
                       label: block_cbAiH_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAiH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbAiV; else goto cbAiU;
       cbAiV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAiU: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.810189832 UTC

[section ""cstring" . System.IO.openBinaryTempFileWithDefaultPermissions4_bytes" {
     System.IO.openBinaryTempFileWithDefaultPermissions4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,84,101,109,112,70,105,108,101,87,105,116,104,68,101,102,97,117,108,116,80,101,114,109,105,115,115,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.812143538 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions3_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions3_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions3_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions3_entry() //  [R1]
         { info_tbl: [(cbAnB,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAnB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAnC; else goto cbAnD;
       cbAnC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAnD: // global
           (_cbAny::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbAny::I64 == 0) goto cbAnA; else goto cbAnz;
       cbAnA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbAnz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbAny::I64;
           R2 = System.IO.openBinaryTempFileWithDefaultPermissions4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.816512703 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions2_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions2_closure:
         const GHC.Word.W32#_con_info;
         const 438;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.818445503 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions1_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions1_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions1_info;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions1_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cbAnQ,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAnQ: // global
           R6 = System.IO.openBinaryTempFileWithDefaultPermissions2_closure+1;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openBinaryTempFileWithDefaultPermissions3_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.822004952 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions_info;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cbAo1,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAo1: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openBinaryTempFileWithDefaultPermissions1_entry(R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.825357386 UTC

[section ""cstring" . System.IO.openTempFileWithDefaultPermissions3_bytes" {
     System.IO.openTempFileWithDefaultPermissions3_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101,87,105,116,104,68,101,102,97,117,108,116,80,101,114,109,105,115,115,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.827224104 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions2_closure" {
     System.IO.openTempFileWithDefaultPermissions2_closure:
         const System.IO.openTempFileWithDefaultPermissions2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions2_entry() //  [R1]
         { info_tbl: [(cbAof,
                       label: System.IO.openTempFileWithDefaultPermissions2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAof: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAog; else goto cbAoh;
       cbAog: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAoh: // global
           (_cbAoc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbAoc::I64 == 0) goto cbAoe; else goto cbAod;
       cbAoe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbAod: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbAoc::I64;
           R2 = System.IO.openTempFileWithDefaultPermissions3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.831232524 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions1_closure" {
     System.IO.openTempFileWithDefaultPermissions1_closure:
         const System.IO.openTempFileWithDefaultPermissions1_info;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions1_entry() //  [R2, R3]
         { info_tbl: [(cbAot,
                       label: System.IO.openTempFileWithDefaultPermissions1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAot: // global
           R6 = System.IO.openBinaryTempFileWithDefaultPermissions2_closure+1;
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openTempFileWithDefaultPermissions2_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.835174467 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions_closure" {
     System.IO.openTempFileWithDefaultPermissions_closure:
         const System.IO.openTempFileWithDefaultPermissions_info;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions_entry() //  [R2, R3]
         { info_tbl: [(cbAoE,
                       label: System.IO.openTempFileWithDefaultPermissions_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAoE: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openTempFileWithDefaultPermissions1_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.838948815 UTC

[section ""cstring" . System.IO.openBinaryTempFile4_bytes" {
     System.IO.openBinaryTempFile4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.840821158 UTC

[section ""data" . System.IO.openBinaryTempFile3_closure" {
     System.IO.openBinaryTempFile3_closure:
         const System.IO.openBinaryTempFile3_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openBinaryTempFile3_entry() //  [R1]
         { info_tbl: [(cbAoS,
                       label: System.IO.openBinaryTempFile3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAoS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAoT; else goto cbAoU;
       cbAoT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAoU: // global
           (_cbAoP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbAoP::I64 == 0) goto cbAoR; else goto cbAoQ;
       cbAoR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbAoQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbAoP::I64;
           R2 = System.IO.openBinaryTempFile4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.844818095 UTC

[section ""data" . System.IO.openBinaryTempFile2_closure" {
     System.IO.openBinaryTempFile2_closure:
         const GHC.Word.W32#_con_info;
         const 384;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.846755649 UTC

[section ""data" . System.IO.openBinaryTempFile1_closure" {
     System.IO.openBinaryTempFile1_closure:
         const System.IO.openBinaryTempFile1_info;
         const 0;
 },
 System.IO.openBinaryTempFile1_entry() //  [R2, R3]
         { info_tbl: [(cbAp7,
                       label: System.IO.openBinaryTempFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAp7: // global
           R6 = System.IO.openBinaryTempFile2_closure+1;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openBinaryTempFile3_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.850908392 UTC

[section ""data" . System.IO.openBinaryTempFile_closure" {
     System.IO.openBinaryTempFile_closure:
         const System.IO.openBinaryTempFile_info;
         const 0;
 },
 System.IO.openBinaryTempFile_entry() //  [R2, R3]
         { info_tbl: [(cbApi,
                       label: System.IO.openBinaryTempFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbApi: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openBinaryTempFile1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.854170832 UTC

[section ""cstring" . System.IO.openTempFile3_bytes" {
     System.IO.openTempFile3_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.856019704 UTC

[section ""data" . System.IO.openTempFile2_closure" {
     System.IO.openTempFile2_closure:
         const System.IO.openTempFile2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openTempFile2_entry() //  [R1]
         { info_tbl: [(cbApw,
                       label: System.IO.openTempFile2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbApw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbApx; else goto cbApy;
       cbApx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbApy: // global
           (_cbApt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbApt::I64 == 0) goto cbApv; else goto cbApu;
       cbApv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbApu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbApt::I64;
           R2 = System.IO.openTempFile3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.860182778 UTC

[section ""data" . System.IO.openTempFile1_closure" {
     System.IO.openTempFile1_closure:
         const System.IO.openTempFile1_info;
         const 0;
 },
 System.IO.openTempFile1_entry() //  [R2, R3]
         { info_tbl: [(cbApK,
                       label: System.IO.openTempFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbApK: // global
           R6 = System.IO.openBinaryTempFile2_closure+1;
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openTempFile2_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.86379045 UTC

[section ""data" . System.IO.openTempFile_closure" {
     System.IO.openTempFile_closure:
         const System.IO.openTempFile_info;
         const 0;
 },
 System.IO.openTempFile_entry() //  [R2, R3]
         { info_tbl: [(cbApV,
                       label: System.IO.openTempFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbApV: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openTempFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.867218022 UTC

[section ""data" . System.IO.NewFileCreated_closure" {
     System.IO.NewFileCreated_closure:
         const System.IO.NewFileCreated_info;
 },
 System.IO.NewFileCreated_entry() //  [R2]
         { info_tbl: [(cbAq7,
                       label: System.IO.NewFileCreated_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAq7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAqb; else goto cbAqa;
       cbAqb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = System.IO.NewFileCreated_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAqa: // global
           I64[Hp - 8] = System.IO.NewFileCreated_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.871424741 UTC

[section ""data" . System.IO.FileExists_closure" {
     System.IO.FileExists_closure:
         const System.IO.FileExists_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.873439062 UTC

[section ""data" . System.IO.OpenNewError_closure" {
     System.IO.OpenNewError_closure:
         const System.IO.OpenNewError_info;
 },
 System.IO.OpenNewError_entry() //  [R2]
         { info_tbl: [(cbAqn,
                       label: System.IO.OpenNewError_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAqn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAqr; else goto cbAqq;
       cbAqr: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = System.IO.OpenNewError_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAqq: // global
           I64[Hp - 8] = System.IO.OpenNewError_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.876963837 UTC

[System.IO.NewFileCreated_con_entry() //  [R1]
         { info_tbl: [(cbAqx,
                       label: System.IO.NewFileCreated_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,78,101,119,70,105,108,101,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAqx: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.880659146 UTC

[System.IO.FileExists_con_entry() //  [R1]
         { info_tbl: [(cbAqD,
                       label: System.IO.FileExists_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,70,105,108,101,69,120,105,115,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAqD: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.883893724 UTC

[System.IO.OpenNewError_con_entry() //  [R1]
         { info_tbl: [(cbAqJ,
                       label: System.IO.OpenNewError_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,79,112,101,110,78,101,119,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAqJ: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:30.887012499 UTC

[section ""relreadonly" . SbyXw_srt" {
     SbyXw_srt:
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutChar1_closure;
         const System.IO.putChar1_closure;
         const GHC.IO.Handle.Text.hPutStr_closure;
         const GHC.IO.Handle.Text.hPutStrLn_closure;
         const System.IO.print_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.hGetChar2_closure;
         const GHC.IO.Handle.Text.hGetChar6_closure;
         const GHC.IO.Handle.FD.stdin_closure;
         const System.IO.getChar1_closure;
         const GHC.IO.Handle.Text.hGetLine2_closure;
         const GHC.IO.Handle.Text.hGetLine4_closure;
         const System.IO.getLine1_closure;
         const GHC.IO.Handle.Text.hGetContents1_closure;
         const System.IO.getContents1_closure;
         const GHC.IO.Handle.Text.hWaitForInput1_closure;
         const System.IO.hReady1_closure;
         const System.IO.hPrint_closure;
         const GHC.IO.Handle.hClose1_closure;
         const GHC.IO.Handle.FD.openFile1_closure;
         const System.IO.appendFile2_closure;
         const System.IO.appendFile1_closure;
         const System.IO.writeFile1_closure;
         const GHC.IO.Handle.FD.openBinaryFile1_closure;
         const System.IO.withBinaryFile1_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
         const lvl1_rbyQ9_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const System.IO.fixIO2_closure;
         const System.IO.fixIO3_closure;
         const System.IO.fixIO1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const System.IO.readIO7_closure;
         const System.IO.readIO3_closure;
         const System.IO.readIO10_closure;
         const GHC.Read.lex1_closure;
         const System.IO.readIO1_closure;
         const System.IO.readIO2_closure;
         const System.IO.readIO6_closure;
         const System.IO.readLn1_closure;
         const System.IO.readFile1_closure;
         const System.IO.interact1_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const $wlvl_rbyQf_closure;
         const lvl7_rbyQg_closure;
         const GHC.IO.failIO1_closure;
         const lvl11_rbyQl_closure;
         const lvl3_rbyQb_closure;
         const lvl6_rbyQe_closure;
         const GHC.List.lastError_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.Handle.FD.fdToHandle5_closure;
         const tempCounter_rbxCH_closure;
         const System.IO.openBinaryTempFile5_closure;
         const System.IO.openBinaryTempFileWithDefaultPermissions3_closure;
         const System.IO.openBinaryTempFileWithDefaultPermissions1_closure;
         const System.IO.openTempFileWithDefaultPermissions2_closure;
         const System.IO.openTempFileWithDefaultPermissions1_closure;
         const System.IO.openBinaryTempFile3_closure;
         const System.IO.openBinaryTempFile1_closure;
         const System.IO.openTempFile2_closure;
         const System.IO.openTempFile1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.472033133 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:32.47373338 UTC

[section ""data" . System.IO.putChar1_closure" {
     System.IO.putChar1_closure:
         const System.IO.putChar1_info;
         const 0;
 },
 System.IO.putChar1_entry() //  [R2]
         { info_tbl: [(cbAxW,
                       label: System.IO.putChar1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAxW: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutChar1_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.478940547 UTC

[section ""data" . System.IO.putChar_closure" {
     System.IO.putChar_closure:
         const System.IO.putChar_info;
         const 0;
 },
 System.IO.putChar_entry() //  [R2]
         { info_tbl: [(cbAy8,
                       label: System.IO.putChar_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAy8: // global
           R2 = R2;
           call System.IO.putChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.483768208 UTC

[section ""data" . System.IO.putStr_closure" {
     System.IO.putStr_closure:
         const System.IO.putStr_info;
         const 0;
 },
 System.IO.putStr_entry() //  [R2]
         { info_tbl: [(cbAyj,
                       label: System.IO.putStr_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAyj: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.487741199 UTC

[section ""data" . System.IO.putStrLn_closure" {
     System.IO.putStrLn_closure:
         const System.IO.putStrLn_info;
         const 0;
 },
 System.IO.putStrLn_entry() //  [R2]
         { info_tbl: [(cbAyu,
                       label: System.IO.putStrLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAyu: // global
           R3 = R2;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutStrLn_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.491472098 UTC

[section ""data" . System.IO.print_closure" {
     System.IO.print_closure:
         const System.IO.print_info;
         const 0;
 },
 sat_sbAqV_entry() //  [R1]
         { info_tbl: [(cbAyJ,
                       label: sat_sbAqV_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAyJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbAyK; else goto cbAyL;
       cbAyK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAyL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 System.IO.print_entry() //  [R2, R3]
         { info_tbl: [(cbAyM,
                       label: System.IO.print_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAyM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbAyQ; else goto cbAyP;
       cbAyQ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.print_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAyP: // global
           I64[Hp - 24] = sat_sbAqV_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R4 = GHC.Types.True_closure+2;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.499562273 UTC

[section ""data" . System.IO.getChar1_closure" {
     System.IO.getChar1_closure:
         const System.IO.getChar1_info;
         const 0;
 },
 System.IO.getChar1_entry() //  []
         { info_tbl: [(cbAz9,
                       label: System.IO.getChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAz9: // global
           R4 = GHC.IO.Handle.Text.hGetChar2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.Text.hGetChar6_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.503392031 UTC

[section ""data" . System.IO.getChar_closure" {
     System.IO.getChar_closure:
         const System.IO.getChar_info;
         const 0;
 },
 System.IO.getChar_entry() //  []
         { info_tbl: [(cbAzl,
                       label: System.IO.getChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAzl: // global
           call System.IO.getChar1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.507014581 UTC

[section ""data" . System.IO.getLine1_closure" {
     System.IO.getLine1_closure:
         const System.IO.getLine1_info;
         const 0;
 },
 System.IO.getLine1_entry() //  []
         { info_tbl: [(cbAzw,
                       label: System.IO.getLine1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAzw: // global
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.531259802 UTC

[section ""data" . System.IO.getLine_closure" {
     System.IO.getLine_closure:
         const System.IO.getLine_info;
         const 0;
 },
 System.IO.getLine_entry() //  []
         { info_tbl: [(cbAzI,
                       label: System.IO.getLine_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAzI: // global
           call System.IO.getLine1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.535739698 UTC

[section ""data" . System.IO.getContents1_closure" {
     System.IO.getContents1_closure:
         const System.IO.getContents1_info;
         const 0;
 },
 System.IO.getContents1_entry() //  []
         { info_tbl: [(cbAzT,
                       label: System.IO.getContents1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAzT: // global
           R2 = GHC.IO.Handle.FD.stdin_closure;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.539816392 UTC

[section ""data" . System.IO.getContents_closure" {
     System.IO.getContents_closure:
         const System.IO.getContents_info;
         const 0;
 },
 System.IO.getContents_entry() //  []
         { info_tbl: [(cbAA4,
                       label: System.IO.getContents_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAA4: // global
           call System.IO.getContents1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.542897829 UTC

[section ""data" . System.IO.localeEncoding_closure" {
     System.IO.localeEncoding_closure:
         const stg_IND_STATIC_info;
         const GHC.IO.Encoding.initLocaleEncoding_closure;
         const 0;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.544608124 UTC

[section ""data" . System.IO.hReady2_closure" {
     System.IO.hReady2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.5464813 UTC

[section ""data" . System.IO.hReady1_closure" {
     System.IO.hReady1_closure:
         const System.IO.hReady1_info;
         const 0;
 },
 System.IO.hReady1_entry() //  [R2]
         { info_tbl: [(cbAAh,
                       label: System.IO.hReady1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAAh: // global
           R3 = System.IO.hReady2_closure+1;
           R2 = R2;
           call GHC.IO.Handle.Text.hWaitForInput1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.550197204 UTC

[section ""data" . System.IO.hReady_closure" {
     System.IO.hReady_closure:
         const System.IO.hReady_info;
         const 0;
 },
 System.IO.hReady_entry() //  [R2]
         { info_tbl: [(cbAAs,
                       label: System.IO.hReady_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAAs: // global
           R2 = R2;
           call System.IO.hReady1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.553880825 UTC

[section ""data" . System.IO.hPrint_closure" {
     System.IO.hPrint_closure:
         const System.IO.hPrint_info;
         const 0;
 },
 sat_sbAr1_entry() //  [R1]
         { info_tbl: [(cbAAH,
                       label: sat_sbAr1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAAH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbAAI; else goto cbAAJ;
       cbAAI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAAJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 System.IO.hPrint_entry() //  [R2, R3, R4]
         { info_tbl: [(cbAAK,
                       label: System.IO.hPrint_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAAK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbAAO; else goto cbAAN;
       cbAAO: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.hPrint_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAAN: // global
           I64[Hp - 24] = sat_sbAr1_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R4 = GHC.Types.True_closure+2;
           _sbAqZ::P64 = R3;
           R3 = Hp - 24;
           R2 = _sbAqZ::P64;
           R1 = GHC.IO.Handle.Text.hPutStr'_closure+4;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.561993663 UTC

[section ""data" . System.IO.appendFile2_closure" {
     System.IO.appendFile2_closure:
         const System.IO.appendFile2_info;
         const 0;
 },
 sat_sbArk_entry() //  [R1, R2]
         { info_tbl: [(cbABk,
                       label: sat_sbArk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbABk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbABl; else goto cbABm;
       cbABl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbABm: // global
           I64[Sp - 16] = block_cbABi_info;
           _sbArf::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbArf::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbABi() //  []
         { info_tbl: [(cbABi,
                       label: block_cbABi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbABi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbAre_entry() //  [R1]
         { info_tbl: [(cbABu,
                       label: sat_sbAre_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbABu: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbArC_entry() //  [R1, R2]
         { info_tbl: [(cbABM,
                       label: sat_sbArC_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbABM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbABN; else goto cbABO;
       cbABN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbABO: // global
           I64[Sp - 16] = block_cbABK_info;
           _sbArx::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbArx::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbABK() //  []
         { info_tbl: [(cbABK,
                       label: block_cbABK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbABK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbArw_entry() //  [R1]
         { info_tbl: [(cbABW,
                       label: sat_sbArw_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbABW: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbArJ_entry() //  [R1]
         { info_tbl: [(cbAC3,
                       label: sat_sbArJ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAC3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAC4; else goto cbAC5;
       cbAC4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbAC5: // global
           I64[Sp - 16] = block_cbABD_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbABD() //  [R1]
         { info_tbl: [(cbABD,
                       label: block_cbABD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbABD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbAC8; else goto cbAC7;
       cbAC8: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAC7: // global
           I64[Hp - 56] = sat_sbArC_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbArw_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbABZ_info;
           R2 = Hp - 54;
           _sbAru::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbAru::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbABZ() //  [R1]
         { info_tbl: [(cbABZ,
                       label: block_cbABZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbABZ: // global
           I64[Sp] = block_cbAC1_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAC1() //  []
         { info_tbl: [(cbAC1,
                       label: block_cbAC1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAC1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbArU_entry() //  [R1, R2]
         { info_tbl: [(cbACl,
                       label: sat_sbArU_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbACl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbACm; else goto cbACn;
       cbACm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbACn: // global
           I64[Sp - 16] = block_cbACj_info;
           _sbArP::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbArP::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbACj() //  []
         { info_tbl: [(cbACj,
                       label: block_cbACj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbACj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbArO_entry() //  [R1]
         { info_tbl: [(cbACv,
                       label: sat_sbArO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbACv: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.appendFile2_entry() //  [R2, R3, R4]
         { info_tbl: [(cbACC,
                       label: System.IO.appendFile2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbACC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbACD; else goto cbACE;
       cbACD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.appendFile2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbACE: // global
           I64[Sp - 32] = block_cbAB7_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbAB7() //  [R1]
         { info_tbl: [(cbAB7,
                       label: block_cbAB7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAB7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbACH; else goto cbACG;
       cbACH: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbACG: // global
           _sbAr2::P64 = P64[Sp + 8];
           _sbAr3::P64 = P64[Sp + 16];
           if (R1 == 0) goto cbACA; else goto ubAD0;
       cbACA: // global
           I64[Hp - 24] = sat_sbArJ_info;
           P64[Hp - 16] = _sbAr2::P64;
           P64[Hp - 8] = _sbAr3::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ubAD0: // global
           if (R1 == 1) goto cbACB; else goto cbACz;
       cbACB: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbACc_info;
           R3 = _sbAr3::P64;
           R2 = _sbAr2::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
       cbACz: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbABb_info;
           R3 = _sbAr3::P64;
           R2 = _sbAr2::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbACc() //  [R1]
         { info_tbl: [(cbACc,
                       label: block_cbACc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbACc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbACW; else goto cbACV;
       cbACW: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbACV: // global
           I64[Hp - 56] = sat_sbArU_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbArO_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbACR_info;
           R2 = Hp - 54;
           _sbArM::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbArM::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbACR() //  [R1]
         { info_tbl: [(cbACR,
                       label: block_cbACR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbACR: // global
           I64[Sp] = block_cbACT_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbACT() //  []
         { info_tbl: [(cbACT,
                       label: block_cbACT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbACT: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbABb() //  [R1]
         { info_tbl: [(cbABb,
                       label: block_cbABb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbABb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbACN; else goto cbACM;
       cbACN: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbACM: // global
           I64[Hp - 56] = sat_sbArk_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbAre_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbACI_info;
           R2 = Hp - 54;
           _sbArc::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbArc::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbACI() //  [R1]
         { info_tbl: [(cbACI,
                       label: block_cbACI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbACI: // global
           I64[Sp] = block_cbACK_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbACK() //  []
         { info_tbl: [(cbACK,
                       label: block_cbACK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbACK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.602186634 UTC

[section ""data" . System.IO.withFile_closure" {
     System.IO.withFile_closure:
         const System.IO.withFile_info;
         const 0;
 },
 System.IO.withFile_entry() //  [R2, R3, R4]
         { info_tbl: [(cbAEK,
                       label: System.IO.withFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAEK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.605863272 UTC

[section ""data" . System.IO.appendFile1_closure" {
     System.IO.appendFile1_closure:
         const System.IO.appendFile1_info;
         const 0;
 },
 sat_sbAs5_entry() //  [R1, R2]
         { info_tbl: [(cbAF0,
                       label: sat_sbAs5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAF0: // global
           R3 = P64[R1 + 6];
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.appendFile1_entry() //  [R2, R3]
         { info_tbl: [(cbAF3,
                       label: System.IO.appendFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAF3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAF7; else goto cbAF6;
       cbAF7: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.appendFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAF6: // global
           I64[Hp - 8] = sat_sbAs5_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = GHC.IO.IOMode.AppendMode_closure+3;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.611183044 UTC

[section ""data" . System.IO.appendFile_closure" {
     System.IO.appendFile_closure:
         const System.IO.appendFile_info;
         const 0;
 },
 System.IO.appendFile_entry() //  [R2, R3]
         { info_tbl: [(cbAFl,
                       label: System.IO.appendFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAFl: // global
           R3 = R3;
           R2 = R2;
           call System.IO.appendFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.615206277 UTC

[section ""data" . System.IO.writeFile1_closure" {
     System.IO.writeFile1_closure:
         const System.IO.writeFile1_info;
         const 0;
 },
 sat_sbAsa_entry() //  [R1, R2]
         { info_tbl: [(cbAFB,
                       label: sat_sbAsa_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAFB: // global
           R3 = P64[R1 + 6];
           R2 = R2;
           call GHC.IO.Handle.Text.hPutStr_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.writeFile1_entry() //  [R2, R3]
         { info_tbl: [(cbAFE,
                       label: System.IO.writeFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAFE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAFI; else goto cbAFH;
       cbAFI: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.writeFile1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAFH: // global
           I64[Hp - 8] = sat_sbAsa_info;
           P64[Hp] = R3;
           R4 = Hp - 6;
           R3 = GHC.IO.IOMode.WriteMode_closure+2;
           R2 = R2;
           call System.IO.appendFile2_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.620567246 UTC

[section ""data" . System.IO.writeFile_closure" {
     System.IO.writeFile_closure:
         const System.IO.writeFile_info;
         const 0;
 },
 System.IO.writeFile_entry() //  [R2, R3]
         { info_tbl: [(cbAFW,
                       label: System.IO.writeFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAFW: // global
           R3 = R3;
           R2 = R2;
           call System.IO.writeFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.625962456 UTC

[section ""data" . System.IO.withBinaryFile1_closure" {
     System.IO.withBinaryFile1_closure:
         const System.IO.withBinaryFile1_info;
         const 0;
 },
 sat_sbAst_entry() //  [R1, R2]
         { info_tbl: [(cbAGk,
                       label: sat_sbAst_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAGk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAGl; else goto cbAGm;
       cbAGl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAGm: // global
           I64[Sp - 16] = block_cbAGi_info;
           _sbAso::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbAso::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAGi() //  []
         { info_tbl: [(cbAGi,
                       label: block_cbAGi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAGi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbAsn_entry() //  [R1]
         { info_tbl: [(cbAGu,
                       label: sat_sbAsn_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAGu: // global
           R1 = P64[R1 + 7];
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbAsL_entry() //  [R1, R2]
         { info_tbl: [(cbAGM,
                       label: sat_sbAsL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAGM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAGN; else goto cbAGO;
       cbAGN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAGO: // global
           I64[Sp - 16] = block_cbAGK_info;
           _sbAsG::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbAsG::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAGK() //  []
         { info_tbl: [(cbAGK,
                       label: block_cbAGK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAGK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbAsF_entry() //  [R1]
         { info_tbl: [(cbAGW,
                       label: sat_sbAsF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAGW: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbAsS_entry() //  [R1]
         { info_tbl: [(cbAH3,
                       label: sat_sbAsS_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAH3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAH4; else goto cbAH5;
       cbAH4: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbAH5: // global
           I64[Sp - 16] = block_cbAGD_info;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAGD() //  [R1]
         { info_tbl: [(cbAGD,
                       label: block_cbAGD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAGD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbAH8; else goto cbAH7;
       cbAH8: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAH7: // global
           I64[Hp - 56] = sat_sbAsL_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbAsF_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbAGZ_info;
           R2 = Hp - 54;
           _sbAsD::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbAsD::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAGZ() //  [R1]
         { info_tbl: [(cbAGZ,
                       label: block_cbAGZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAGZ: // global
           I64[Sp] = block_cbAH1_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAH1() //  []
         { info_tbl: [(cbAH1,
                       label: block_cbAH1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAH1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbAt3_entry() //  [R1, R2]
         { info_tbl: [(cbAHl,
                       label: sat_sbAt3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAHl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAHm; else goto cbAHn;
       cbAHm: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAHn: // global
           I64[Sp - 16] = block_cbAHj_info;
           _sbAsY::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _sbAsY::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAHj() //  []
         { info_tbl: [(cbAHj,
                       label: block_cbAHj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAHj: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbAsX_entry() //  [R1]
         { info_tbl: [(cbAHv,
                       label: sat_sbAsX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAHv: // global
           R1 = P64[R1 + 7];
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.withBinaryFile1_entry() //  [R2, R3, R4]
         { info_tbl: [(cbAHC,
                       label: System.IO.withBinaryFile1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAHC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbAHD; else goto cbAHE;
       cbAHD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.withBinaryFile1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAHE: // global
           I64[Sp - 32] = block_cbAG7_info;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _cbAG7() //  [R1]
         { info_tbl: [(cbAG7,
                       label: block_cbAG7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAG7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbAHH; else goto cbAHG;
       cbAHH: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbAHG: // global
           _sbAsb::P64 = P64[Sp + 8];
           _sbAsc::P64 = P64[Sp + 16];
           if (R1 == 0) goto cbAHA; else goto ubAI0;
       cbAHA: // global
           I64[Hp - 24] = sat_sbAsS_info;
           P64[Hp - 16] = _sbAsb::P64;
           P64[Hp - 8] = _sbAsc::P64;
           P64[Hp] = P64[Sp + 24];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       ubAI0: // global
           if (R1 == 1) goto cbAHB; else goto cbAHz;
       cbAHB: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbAHc_info;
           R3 = _sbAsc::P64;
           R2 = _sbAsb::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
       cbAHz: // global
           Hp = Hp - 32;
           I64[Sp + 16] = block_cbAGb_info;
           R3 = _sbAsc::P64;
           R2 = _sbAsb::P64;
           Sp = Sp + 16;
           call GHC.IO.Handle.FD.openBinaryFile1_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAHc() //  [R1]
         { info_tbl: [(cbAHc,
                       label: block_cbAHc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAHc: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbAHW; else goto cbAHV;
       cbAHW: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAHV: // global
           I64[Hp - 56] = sat_sbAt3_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbAsX_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbAHR_info;
           R2 = Hp - 54;
           _sbAsV::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbAsV::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAHR() //  [R1]
         { info_tbl: [(cbAHR,
                       label: block_cbAHR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAHR: // global
           I64[Sp] = block_cbAHT_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAHT() //  []
         { info_tbl: [(cbAHT,
                       label: block_cbAHT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAHT: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cbAGb() //  [R1]
         { info_tbl: [(cbAGb,
                       label: block_cbAGb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAGb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cbAHN; else goto cbAHM;
       cbAHN: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAHM: // global
           I64[Hp - 56] = sat_sbAst_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_sbAsn_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbAHI_info;
           R2 = Hp - 54;
           _sbAsl::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _sbAsl::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAHI() //  [R1]
         { info_tbl: [(cbAHI,
                       label: block_cbAHI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAHI: // global
           I64[Sp] = block_cbAHK_info;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.IO.Handle.hClose1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAHK() //  []
         { info_tbl: [(cbAHK,
                       label: block_cbAHK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAHK: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.664590617 UTC

[section ""data" . System.IO.withBinaryFile_closure" {
     System.IO.withBinaryFile_closure:
         const System.IO.withBinaryFile_info;
         const 0;
 },
 System.IO.withBinaryFile_entry() //  [R2, R3, R4]
         { info_tbl: [(cbAJK,
                       label: System.IO.withBinaryFile_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAJK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call System.IO.withBinaryFile1_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.668162768 UTC

[section ""data" . lvl_rbyQ6_closure" {
     lvl_rbyQ6_closure:
         const lvl_rbyQ6_info;
 },
 lvl_rbyQ6_entry() //  []
         { info_tbl: [(cbAK0,
                       label: lvl_rbyQ6_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAK0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbAK1; else goto cbAK2;
       cbAK1: // global
           R1 = lvl_rbyQ6_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbAK2: // global
           I64[Sp - 8] = block_cbAJV_info;
           Sp = Sp - 8;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cbAJV() //  []
         { info_tbl: [(cbAJV,
                       label: block_cbAJV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAJV: // global
           I64[Sp] = block_cbAJX_info;
           R1 = System.IO.hReady2_closure+1;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAJX() //  [R1]
         { info_tbl: [(cbAJX,
                       label: block_cbAJX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAJX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAK6; else goto cbAK5;
       cbAK6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAK5: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.675721003 UTC

[section ""data" . tempCounter_rbxCH_closure" {
     tempCounter_rbxCH_closure:
         const tempCounter_rbxCH_info;
         const 0;
         const 0;
         const 0;
 },
 tempCounter_rbxCH_entry() //  [R1]
         { info_tbl: [(cbAKu,
                       label: tempCounter_rbxCH_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAKu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbAKv; else goto cbAKw;
       cbAKv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAKw: // global
           (_cbAKp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbAKp::I64 == 0) goto cbAKr; else goto cbAKq;
       cbAKr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbAKq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbAKp::I64;
           I64[Sp - 24] = block_cbAKs_info;
           Sp = Sp - 24;
           call lvl_rbyQ6_entry() args: 8, res: 8, upd: 24;
     }
 },
 _cbAKs() //  [R1]
         { info_tbl: [(cbAKs,
                       label: block_cbAKs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAKs: // global
           R1 = R1 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.681051199 UTC

[section ""data" . pathSeparatorChar_rbxCK_closure" {
     pathSeparatorChar_rbxCK_closure:
         const GHC.Types.C#_con_info;
         const 47;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.68268981 UTC

[section ""cstring" . System.IO.$trModule4_bytes" {
     System.IO.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.684307887 UTC

[section ""data" . System.IO.$trModule3_closure" {
     System.IO.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.686140094 UTC

[section ""cstring" . System.IO.$trModule2_bytes" {
     System.IO.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,73,79]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.687728939 UTC

[section ""data" . System.IO.$trModule1_closure" {
     System.IO.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.68990062 UTC

[section ""data" . System.IO.$trModule_closure" {
     System.IO.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.IO.$trModule3_closure+1;
         const System.IO.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.691551953 UTC

[section ""data" . $krep_rbyQ7_closure" {
     $krep_rbyQ7_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Error.$tcErrno_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.693257015 UTC

[section ""data" . $krep1_rbyQ8_closure" {
     $krep1_rbyQ8_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.C.Types.$tcCInt_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.694956709 UTC

[section ""cstring" . System.IO.$tcOpenNewFileResult2_bytes" {
     System.IO.$tcOpenNewFileResult2_bytes:
         I8[] [79,112,101,110,78,101,119,70,105,108,101,82,101,115,117,108,116]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.69660976 UTC

[section ""data" . System.IO.$tcOpenNewFileResult1_closure" {
     System.IO.$tcOpenNewFileResult1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tcOpenNewFileResult2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.698255999 UTC

[section ""data" . System.IO.$tcOpenNewFileResult_closure" {
     System.IO.$tcOpenNewFileResult_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tcOpenNewFileResult1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9627069439367662246;
         const 2547759174955940786;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.700512437 UTC

[section ""data" . System.IO.$tc'FileExists1_closure" {
     System.IO.$tc'FileExists1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const System.IO.$tcOpenNewFileResult_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.702817954 UTC

[section ""cstring" . System.IO.$tc'FileExists3_bytes" {
     System.IO.$tc'FileExists3_bytes:
         I8[] [39,70,105,108,101,69,120,105,115,116,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.704467291 UTC

[section ""data" . System.IO.$tc'FileExists2_closure" {
     System.IO.$tc'FileExists2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'FileExists3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.70621859 UTC

[section ""data" . System.IO.$tc'FileExists_closure" {
     System.IO.$tc'FileExists_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'FileExists2_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 6704133186904346962;
         const 16997416543076271011;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.708005621 UTC

[section ""data" . System.IO.$tc'NewFileCreated1_closure" {
     System.IO.$tc'NewFileCreated1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep1_rbyQ8_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.709821001 UTC

[section ""cstring" . System.IO.$tc'NewFileCreated3_bytes" {
     System.IO.$tc'NewFileCreated3_bytes:
         I8[] [39,78,101,119,70,105,108,101,67,114,101,97,116,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.711376476 UTC

[section ""data" . System.IO.$tc'NewFileCreated2_closure" {
     System.IO.$tc'NewFileCreated2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'NewFileCreated3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.712936938 UTC

[section ""data" . System.IO.$tc'NewFileCreated_closure" {
     System.IO.$tc'NewFileCreated_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'NewFileCreated2_closure+1;
         const System.IO.$tc'NewFileCreated1_closure+4;
         const 9070829168557028496;
         const 15570227817593865145;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.71514569 UTC

[section ""data" . System.IO.$tc'OpenNewError1_closure" {
     System.IO.$tc'OpenNewError1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_rbyQ7_closure+1;
         const System.IO.$tc'FileExists1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.716804226 UTC

[section ""cstring" . System.IO.$tc'OpenNewError3_bytes" {
     System.IO.$tc'OpenNewError3_bytes:
         I8[] [39,79,112,101,110,78,101,119,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.718440262 UTC

[section ""data" . System.IO.$tc'OpenNewError2_closure" {
     System.IO.$tc'OpenNewError2_closure:
         const GHC.Types.TrNameS_con_info;
         const System.IO.$tc'OpenNewError3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.720185097 UTC

[section ""data" . System.IO.$tc'OpenNewError_closure" {
     System.IO.$tc'OpenNewError_closure:
         const GHC.Types.TyCon_con_info;
         const System.IO.$trModule_closure+1;
         const System.IO.$tc'OpenNewError2_closure+1;
         const System.IO.$tc'OpenNewError1_closure+4;
         const 300310999495895268;
         const 12582581010413704951;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.722331364 UTC

[section ""data" . lvl1_rbyQ9_closure" {
     lvl1_rbyQ9_closure:
         const lvl1_rbyQ9_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_rbyQ9_entry() //  [R1]
         { info_tbl: [(cbALf,
                       label: lvl1_rbyQ9_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbALf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbALg; else goto cbALh;
       cbALg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbALh: // global
           (_cbALc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbALc::I64 == 0) goto cbALe; else goto cbALd;
       cbALe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbALd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbALc::I64;
           R2 = GHC.IO.Exception.FixIOException_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionFixIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.726799556 UTC

[section ""data" . System.IO.fixIO3_closure" {
     System.IO.fixIO3_closure:
         const System.IO.fixIO3_info;
         const 0;
 },
 System.IO.fixIO3_entry() //  []
         { info_tbl: [(cbALv,
                       label: System.IO.fixIO3_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbALv: // global
           R1 = lvl1_rbyQ9_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.730996701 UTC

[section ""data" . System.IO.fixIO2_closure" {
     System.IO.fixIO2_closure:
         const System.IO.fixIO2_info;
         const 0;
 },
 sat_sbAtq_entry() //  [R1]
         { info_tbl: [(cbALY,
                       label: sat_sbAtq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbALY: // global
           R1 = P64[R1 + 7];
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.fixIO2_entry() //  [R2]
         { info_tbl: [(cbAM1,
                       label: System.IO.fixIO2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAM1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbAM2; else goto cbAM3;
       cbAM2: // global
           R2 = R2;
           R1 = System.IO.fixIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAM3: // global
           I64[Sp - 8] = block_cbALG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubAMl; else goto cbALH;
       ubAMl: // global
           call _cbALG(R1) args: 0, res: 0, upd: 0;
       cbALH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbALG() //  [R1]
         { info_tbl: [(cbALG,
                       label: block_cbALG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbALG: // global
           I64[Sp - 16] = block_cbALL_info;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Exception.$p1Exception_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbALL() //  [R1]
         { info_tbl: [(cbALL,
                       label: block_cbALL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbALL: // global
           I64[Sp] = block_cbALP_info;
           R3 = GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
           R2 = R1;
           call Data.Typeable.Internal.sameTypeRep_entry(R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbALP() //  [R1]
         { info_tbl: [(cbALP,
                       label: block_cbALP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbALP: // global
           if (R1 & 7 == 1) goto cbAM7; else goto cbAMf;
       cbAM7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAMa; else goto cbAM9;
       cbAMa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAM9: // global
           I64[Hp - 8] = sat_sbAtq_info;
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbAMf: // global
           I64[Sp + 16] = block_cbAMd_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAMd() //  []
         { info_tbl: [(cbAMd,
                       label: block_cbAMd_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAMd: // global
           R1 = System.IO.fixIO3_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.743616236 UTC

[section ""data" . System.IO.fixIO1_closure" {
     System.IO.fixIO1_closure:
         const System.IO.fixIO1_info;
         const 0;
 },
 sat_sbAtz_entry() //  [R1]
         { info_tbl: [(cbAN8,
                       label: sat_sbAtz_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAN8: // global
           R1 = P64[R1 + 7];
           call stg_readMVar#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbAtA_entry() //  [R1]
         { info_tbl: [(cbANb,
                       label: sat_sbAtA_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbANb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbANf; else goto cbANe;
       cbANf: // global
           HpAlloc = 16;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbANe: // global
           _sbAtw::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_sbAtz_info;
           P64[Hp] = _sbAtw::P64;
           R2 = System.IO.fixIO2_closure+1;
           R1 = Hp - 7;
           call stg_catch#(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 System.IO.fixIO1_entry() //  [R2]
         { info_tbl: [(cbANm,
                       label: System.IO.fixIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbANm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbANn; else goto cbANo;
       cbANn: // global
           R2 = R2;
           R1 = System.IO.fixIO1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbANo: // global
           I64[Sp - 16] = block_cbAMW_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_newMVar#() args: 8, res: 8, upd: 8;
     }
 },
 _cbAMW() //  [R1]
         { info_tbl: [(cbAMW,
                       label: block_cbAMW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAMW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbANr; else goto cbANq;
       cbANr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbANq: // global
           I64[Hp - 8] = sat_sbAtA_info;
           P64[Hp] = R1;
           I64[Sp - 8] = block_cbANg_info;
           R2 = Hp - 7;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.IO.Unsafe.unsafeDupableInterleaveIO_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbANg() //  [R1]
         { info_tbl: [(cbANg,
                       label: block_cbANg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbANg: // global
           I64[Sp] = block_cbANi_info;
           R2 = R1;
           R1 = P64[Sp + 16];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbANi() //  [R1]
         { info_tbl: [(cbANi,
                       label: block_cbANi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbANi: // global
           _sbAtw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbANk_info;
           R2 = R1;
           _sbAtG::P64 = R1;
           R1 = _sbAtw::P64;
           P64[Sp + 16] = _sbAtG::P64;
           Sp = Sp + 8;
           call stg_putMVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbANk() //  []
         { info_tbl: [(cbANk,
                       label: block_cbANk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbANk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.75706135 UTC

[section ""data" . System.IO.fixIO_closure" {
     System.IO.fixIO_closure:
         const System.IO.fixIO_info;
         const 0;
 },
 System.IO.fixIO_entry() //  [R2]
         { info_tbl: [(cbAO3,
                       label: System.IO.fixIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAO3: // global
           R2 = R2;
           call System.IO.fixIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.760225888 UTC

[section ""cstring" . System.IO.readIO9_bytes" {
     System.IO.readIO9_bytes:
         I8[] [80,114,101,108,117,100,101,46,114,101,97,100,73,79,58,32,110,111,32,112,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.762849563 UTC

[section ""data" . System.IO.readIO8_closure" {
     System.IO.readIO8_closure:
         const System.IO.readIO8_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO8_entry() //  [R1]
         { info_tbl: [(cbAOh,
                       label: System.IO.readIO8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAOh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAOi; else goto cbAOj;
       cbAOi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAOj: // global
           (_cbAOe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbAOe::I64 == 0) goto cbAOg; else goto cbAOf;
       cbAOg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbAOf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbAOe::I64;
           R2 = System.IO.readIO9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.766735394 UTC

[section ""data" . System.IO.readIO7_closure" {
     System.IO.readIO7_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.Types.[]_closure+1;
         const System.IO.readIO8_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.76871664 UTC

[section ""data" . System.IO.readIO6_closure" {
     System.IO.readIO6_closure:
         const System.IO.readIO6_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO6_entry() //  [R1]
         { info_tbl: [(cbAOz,
                       label: System.IO.readIO6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAOz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAOA; else goto cbAOB;
       cbAOA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAOB: // global
           (_cbAOw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbAOw::I64 == 0) goto cbAOy; else goto cbAOx;
       cbAOy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbAOx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbAOw::I64;
           R2 = System.IO.readIO7_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.772570922 UTC

[section ""cstring" . System.IO.readIO5_bytes" {
     System.IO.readIO5_bytes:
         I8[] [80,114,101,108,117,100,101,46,114,101,97,100,73,79,58,32,97,109,98,105,103,117,111,117,115,32,112,97,114,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.774434406 UTC

[section ""data" . System.IO.readIO4_closure" {
     System.IO.readIO4_closure:
         const System.IO.readIO4_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO4_entry() //  [R1]
         { info_tbl: [(cbAOR,
                       label: System.IO.readIO4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAOR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAOS; else goto cbAOT;
       cbAOS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAOT: // global
           (_cbAOO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbAOO::I64 == 0) goto cbAOQ; else goto cbAOP;
       cbAOQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbAOP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbAOO::I64;
           R2 = System.IO.readIO5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.778555081 UTC

[section ""data" . System.IO.readIO3_closure" {
     System.IO.readIO3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.UserError_closure+1;
         const GHC.Types.[]_closure+1;
         const System.IO.readIO4_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.780598151 UTC

[section ""data" . System.IO.readIO2_closure" {
     System.IO.readIO2_closure:
         const System.IO.readIO2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.readIO2_entry() //  [R1]
         { info_tbl: [(cbAP9,
                       label: System.IO.readIO2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAP9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAPa; else goto cbAPb;
       cbAPa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAPb: // global
           (_cbAP6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbAP6::I64 == 0) goto cbAP8; else goto cbAP7;
       cbAP8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbAP7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbAP6::I64;
           R2 = System.IO.readIO3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.786145561 UTC

[section ""data" . System.IO.readIO10_closure" {
     System.IO.readIO10_closure:
         const System.IO.readIO10_info;
         const 0;
 },
 z_sbAtQ_entry() //  [R1]
         { info_tbl: [(cbAPE,
                       label: z_sbAtQ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAPE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAPF; else goto cbAPG;
       cbAPF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAPG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call System.IO.readIO10_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbAu1_entry() //  [R1]
         { info_tbl: [(cbAQb,
                       label: sat_sbAu1_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAQb: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go1_sbAtR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 go1_sbAtR_entry() //  [R1, R2]
         { info_tbl: [(cbAQi,
                       label: go1_sbAtR_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAQi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbAQj; else goto ubAQH;
       cbAQj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ubAQH: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cbAPJ() args: 0, res: 0, upd: 0;
     }
 },
 _cbAPJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAPJ: // global
           I64[Sp - 16] = block_cbAPM_info;
           R1 = P64[Sp + 8];
           _sbAtR::P64 = P64[Sp];
           P64[Sp - 8] = P64[_sbAtR::P64 + 15];
           P64[Sp + 8] = P64[_sbAtR::P64 + 7];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubAQL; else goto cbAPN;
       ubAQL: // global
           call _cbAPM(R1) args: 0, res: 0, upd: 0;
       cbAPN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAPM() //  [R1]
         { info_tbl: [(cbAPM,
                       label: block_cbAPM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAPM: // global
           if (R1 & 7 == 1) goto cbAQf; else goto cbAQg;
       cbAQf: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbAQg: // global
           I64[Sp] = block_cbAPS_info;
           _sbAtV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 8] = _sbAtV::P64;
           if (R1 & 7 != 0) goto ubAQM; else goto cbAPT;
       ubAQM: // global
           call _cbAPS(R1) args: 0, res: 0, upd: 0;
       cbAPT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAPS() //  [R1]
         { info_tbl: [(cbAPS,
                       label: block_cbAPS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAPS: // global
           I64[Sp - 8] = block_cbAPX_info;
           _sbAtY::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sbAtY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubAQN; else goto cbAPY;
       ubAQN: // global
           call _cbAPX(R1) args: 0, res: 0, upd: 0;
       cbAPY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAPX() //  [R1]
         { info_tbl: [(cbAPX,
                       label: block_cbAPX_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAPX: // global
           if (R1 & 7 == 1) goto cbAQr; else goto ubAQI;
       cbAQr: // global
           _sbAtY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbAQ2_info;
           R1 = _sbAtY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubAQO; else goto cbAQ3;
       ubAQO: // global
           call _cbAQ2(R1) args: 0, res: 0, upd: 0;
       cbAQ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ubAQI: // global
           Sp = Sp + 16;
           call _cbAQE() args: 0, res: 0, upd: 0;
     }
 },
 _cbAQ2() //  [R1]
         { info_tbl: [(cbAQ2,
                       label: block_cbAQ2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAQ2: // global
           if (R1 & 7 == 1) goto cbAQt; else goto ubAQJ;
       cbAQt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbAQw; else goto cbAQv;
       cbAQw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAQv: // global
           I64[Hp - 24] = sat_sbAu1_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ubAQJ: // global
           Sp = Sp + 8;
           call _cbAQE() args: 0, res: 0, upd: 0;
     }
 },
 _cbAQE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAQE: // global
           P64[Sp + 16] = P64[Sp];
           Sp = Sp + 8;
           call _cbAPJ() args: 0, res: 0, upd: 0;
     }
 },
 System.IO.readIO10_entry() //  [R2]
         { info_tbl: [(cbAQX,
                       label: System.IO.readIO10_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAQX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAQY; else goto cbAQZ;
       cbAQY: // global
           R2 = R2;
           R1 = System.IO.readIO10_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAQZ: // global
           I64[Sp - 8] = block_cbAPo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubARc; else goto cbAPp;
       ubARc: // global
           call _cbAPo(R1) args: 0, res: 0, upd: 0;
       cbAPp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAPo() //  [R1]
         { info_tbl: [(cbAPo,
                       label: block_cbAPo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAPo: // global
           if (R1 & 7 == 1) goto cbAQU; else goto cbAQV;
       cbAQU: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbAQV: // global
           I64[Sp - 8] = block_cbAPu_info;
           _sbAtL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbAtL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubARb; else goto cbAPv;
       ubARb: // global
           call _cbAPu(R1) args: 0, res: 0, upd: 0;
       cbAPv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAPu() //  [R1]
         { info_tbl: [(cbAPu,
                       label: block_cbAPu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAPu: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cbAR6; else goto cbAR5;
       cbAR6: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAR5: // global
           _sbAtN::P64 = P64[R1 + 7];
           _sbAtO::P64 = P64[R1 + 15];
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sbAtN::P64;
           P64[Hp - 48] = GHC.Types.[]_closure+1;
           I64[Hp - 40] = z_sbAtQ_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = go1_sbAtR_info;
           P64[Hp - 8] = Hp - 62;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_cbAR2_info;
           R3 = _sbAtO::P64;
           R2 = GHC.Read.lex1_closure;
           P64[Sp + 8] = Hp - 15;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAR2() //  [R1]
         { info_tbl: [(cbAR2,
                       label: block_cbAR2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAR2: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call go1_sbAtR_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.811566179 UTC

[section ""data" . System.IO.readIO1_closure" {
     System.IO.readIO1_closure:
         const System.IO.readIO1_info;
         const 0;
 },
 System.IO.readIO1_entry() //  [R2, R3]
         { info_tbl: [(cbASD,
                       label: System.IO.readIO1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbASD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbASE; else goto cbASF;
       cbASE: // global
           R3 = R3;
           R2 = R2;
           R1 = System.IO.readIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbASF: // global
           I64[Sp - 8] = block_cbASB_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = Text.ParserCombinators.ReadPrec.minPrec_closure;
           P64[Sp - 16] = R3;
           Sp = Sp - 32;
           call GHC.Read.readsPrec_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _cbASB() //  [R1]
         { info_tbl: [(cbASB,
                       label: block_cbASB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbASB: // global
           I64[Sp] = block_cbASI_info;
           R2 = R1;
           call System.IO.readIO10_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbASI() //  [R1]
         { info_tbl: [(cbASI,
                       label: block_cbASI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbASI: // global
           if (R1 & 7 == 1) goto cbASP; else goto cbASU;
       cbASP: // global
           R1 = System.IO.readIO6_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       cbASU: // global
           I64[Sp - 8] = block_cbASS_info;
           _sbAuc::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sbAuc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubAT8; else goto cbASV;
       ubAT8: // global
           call _cbASS(R1) args: 0, res: 0, upd: 0;
       cbASV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbASS() //  [R1]
         { info_tbl: [(cbASS,
                       label: block_cbASS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbASS: // global
           if (R1 & 7 == 1) goto cbAT1; else goto cbAT5;
       cbAT1: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbAT5: // global
           R1 = System.IO.readIO2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.820924661 UTC

[section ""data" . System.IO.readIO_closure" {
     System.IO.readIO_closure:
         const System.IO.readIO_info;
         const 0;
 },
 System.IO.readIO_entry() //  [R2, R3]
         { info_tbl: [(cbATC,
                       label: System.IO.readIO_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbATC: // global
           R3 = R3;
           R2 = R2;
           call System.IO.readIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.824387476 UTC

[section ""data" . System.IO.readLn1_closure" {
     System.IO.readLn1_closure:
         const System.IO.readLn1_info;
         const 0;
 },
 section ""relreadonly" . ubATT_srtd" {
     ubATT_srtd:
         const SbAxZ_srt+56;
         const 36;
         const 38654705769;
 },
 System.IO.readLn1_entry() //  [R2]
         { info_tbl: [(cbATP,
                       label: System.IO.readLn1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbATP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbATQ; else goto cbATR;
       cbATQ: // global
           R2 = R2;
           R1 = System.IO.readLn1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbATR: // global
           I64[Sp - 16] = block_cbATN_info;
           R4 = GHC.IO.Handle.Text.hGetLine2_closure+2;
           R3 = GHC.IO.Handle.FD.stdin_closure;
           _sbAuh::P64 = R2;
           R2 = GHC.IO.Handle.Text.hGetLine4_closure;
           P64[Sp - 8] = _sbAuh::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Internals.wantReadableHandle_1_entry(R4,
                                                                   R3,
                                                                   R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbATN() //  [R1]
         { info_tbl: [(cbATN,
                       label: block_cbATN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbATN: // global
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call System.IO.readIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.830395059 UTC

[section ""data" . System.IO.readLn_closure" {
     System.IO.readLn_closure:
         const System.IO.readLn_info;
         const 0;
 },
 System.IO.readLn_entry() //  [R2]
         { info_tbl: [(cbAU9,
                       label: System.IO.readLn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAU9: // global
           R2 = R2;
           call System.IO.readLn1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.834351894 UTC

[section ""data" . System.IO.readFile1_closure" {
     System.IO.readFile1_closure:
         const System.IO.readFile1_info;
         const 0;
 },
 System.IO.readFile1_entry() //  [R2]
         { info_tbl: [(cbAUm,
                       label: System.IO.readFile1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAUm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbAUn; else goto cbAUo;
       cbAUn: // global
           R2 = R2;
           R1 = System.IO.readFile1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAUo: // global
           I64[Sp - 8] = block_cbAUk_info;
           R3 = GHC.IO.IOMode.ReadMode_closure+1;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.openFile1_entry(R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAUk() //  [R1]
         { info_tbl: [(cbAUk,
                       label: block_cbAUk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAUk: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.839927363 UTC

[section ""data" . System.IO.readFile_closure" {
     System.IO.readFile_closure:
         const System.IO.readFile_info;
         const 0;
 },
 System.IO.readFile_entry() //  [R2]
         { info_tbl: [(cbAUE,
                       label: System.IO.readFile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAUE: // global
           R2 = R2;
           call System.IO.readFile1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.843487847 UTC

[section ""data" . System.IO.interact1_closure" {
     System.IO.interact1_closure:
         const System.IO.interact1_info;
         const 0;
 },
 sat_sbAuw_entry() //  [R1]
         { info_tbl: [(cbAUV,
                       label: sat_sbAuw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAUV: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . ubAV4_srtd" {
     ubAV4_srtd:
         const SbAxZ_srt;
         const 45;
         const 17592186078273;
 },
 System.IO.interact1_entry() //  [R2]
         { info_tbl: [(cbAUY,
                       label: System.IO.interact1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAUY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAUZ; else goto cbAV0;
       cbAUZ: // global
           R2 = R2;
           R1 = System.IO.interact1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAV0: // global
           I64[Sp - 16] = block_cbAUP_info;
           _sbAur::P64 = R2;
           R2 = GHC.IO.Handle.FD.stdin_closure;
           P64[Sp - 8] = _sbAur::P64;
           Sp = Sp - 16;
           call GHC.IO.Handle.Text.hGetContents1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbAUP() //  [R1]
         { info_tbl: [(cbAUP,
                       label: block_cbAUP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAUP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbAV3; else goto cbAV2;
       cbAV3: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbAV2: // global
           I64[Hp - 24] = sat_sbAuw_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R4 = GHC.Types.False_closure+1;
           R3 = Hp - 24;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           Sp = Sp + 16;
           call GHC.IO.Handle.Text.hPutStr'_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.851399596 UTC

[section ""data" . System.IO.interact_closure" {
     System.IO.interact_closure:
         const System.IO.interact_info;
         const 0;
 },
 System.IO.interact_entry() //  [R2]
         { info_tbl: [(cbAVp,
                       label: System.IO.interact_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAVp: // global
           R2 = R2;
           call System.IO.interact1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.854913956 UTC

[section ""cstring" . lvl2_rbyQa_bytes" {
     lvl2_rbyQa_bytes:
         I8[] [98,117,103,32,105,110,32,83,121,115,116,101,109,46,73,79,46,111,112,101,110,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.856768206 UTC

[section ""data" . lvl3_rbyQb_closure" {
     lvl3_rbyQb_closure:
         const lvl3_rbyQb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rbyQb_entry() //  [R1]
         { info_tbl: [(cbAVF,
                       label: lvl3_rbyQb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAVF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbAVG; else goto cbAVH;
       cbAVG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAVH: // global
           (_cbAVA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbAVA::I64 == 0) goto cbAVC; else goto cbAVB;
       cbAVC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbAVB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbAVA::I64;
           I64[Sp - 24] = block_cbAVD_info;
           R2 = lvl2_rbyQa_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbAVD() //  [R1]
         { info_tbl: [(cbAVD,
                       label: block_cbAVD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAVD: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.862179018 UTC

[section ""data" . lvl4_rbyQc_closure" {
     lvl4_rbyQc_closure:
         const GHC.Types.C#_con_info;
         const 46;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.864089052 UTC

[section ""data" . lvl5_rbyQd_closure" {
     lvl5_rbyQd_closure:
         const lvl5_rbyQd_info;
 },
 lvl5_rbyQd_entry() //  [R2]
         { info_tbl: [(cbAW5,
                       label: lvl5_rbyQd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAW5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbAW6; else goto cbAW7;
       cbAW6: // global
           R2 = R2;
           R1 = lvl5_rbyQd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAW7: // global
           I64[Sp - 8] = block_cbAW2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubAWf; else goto cbAW3;
       ubAWf: // global
           call _cbAW2(R1) args: 0, res: 0, upd: 0;
       cbAW3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAW2() //  [R1]
         { info_tbl: [(cbAW2,
                       label: block_cbAW2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAW2: // global
           if (I64[R1 + 7] == 46) goto cbAWe; else goto cbAWd;
       cbAWe: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cbAWd: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.870848579 UTC

[section ""data" . lvl6_rbyQe_closure" {
     lvl6_rbyQe_closure:
         const lvl6_rbyQe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_rbyQe_entry() //  [R1]
         { info_tbl: [(cbAWH,
                       label: lvl6_rbyQe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAWH: // global
           _rbyQe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbAXq; else goto cbAXr;
       cbAXr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAXt; else goto cbAXs;
       cbAXt: // global
           HpAlloc = 16;
           goto cbAXq;
       cbAXq: // global
           R1 = _rbyQe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAXs: // global
           (_cbAWx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbyQe::P64);
           if (_cbAWx::I64 == 0) goto cbAWz; else goto cbAWy;
       cbAWz: // global
           call (I64[I64[_rbyQe::P64]])() args: 8, res: 0, upd: 8;
       cbAWy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbAWx::I64;
           (_sbAuF::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_nonblock();
           (_sbAuJ::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_noctty();
           (_sbAuN::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_creat();
           (_sbAuR::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_rdwr();
           (_sbAuV::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_excl();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbAuF::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbAuJ::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbAuN::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbAuR::I64)) | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbAuV::I64));
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.876185454 UTC

[section ""data" . $wlvl_rbyQf_closure" {
     $wlvl_rbyQf_closure:
         const $wlvl_rbyQf_info;
         const 0;
 },
 sat_sbAvg_entry() //  [R1]
         { info_tbl: [(cbAY0,
                       label: sat_sbAvg_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAY0: // global
           _sbAvg::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbAY1; else goto cbAY2;
       cbAY2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAY4; else goto cbAY3;
       cbAY4: // global
           HpAlloc = 16;
           goto cbAY1;
       cbAY1: // global
           R1 = _sbAvg::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAY3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbAvg::P64;
           _sbAvc::P64 = P64[_sbAvg::P64 + 16];
           _sbAvd::P64 = P64[_sbAvg::P64 + 24];
           _sbAvb::I64 = I64[_sbAvg::P64 + 32];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _sbAvd::P64;
           R5 = Hp - 6;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = _sbAvb::I64;
           R2 = _sbAvc::P64;
           Sp = Sp - 16;
           call Foreign.C.Error.$werrnoToIOError_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbAvh_entry() //  [R1]
         { info_tbl: [(cbAY5,
                       label: sat_sbAvh_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAY5: // global
           _sbAvh::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbAY6; else goto cbAY7;
       cbAY7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbAY9; else goto cbAY8;
       cbAY9: // global
           HpAlloc = 40;
           goto cbAY6;
       cbAY6: // global
           R1 = _sbAvh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAY8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbAvh::P64;
           _sbAvc::P64 = P64[_sbAvh::P64 + 16];
           _sbAvd::P64 = P64[_sbAvh::P64 + 24];
           _sbAvb::I64 = I64[_sbAvh::P64 + 32];
           I64[Hp - 32] = sat_sbAvg_info;
           P64[Hp - 16] = _sbAvc::P64;
           P64[Hp - 8] = _sbAvd::P64;
           I64[Hp] = _sbAvb::I64;
           R2 = Hp - 32;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wlvl_rbyQf_entry() //  [R2, R3, R4]
         { info_tbl: [(cbAYa,
                       label: $wlvl_rbyQf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAYa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbAYe; else goto cbAYd;
       cbAYe: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $wlvl_rbyQf_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAYd: // global
           I64[Hp - 32] = sat_sbAvh_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           I64[Hp] = R2;
           R1 = Hp - 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.884712532 UTC

[section ""data" . lvl7_rbyQg_closure" {
     lvl7_rbyQg_closure:
         const lvl7_rbyQg_info;
         const 0;
 },
 lvl7_rbyQg_entry() //  [R2, R3, R4]
         { info_tbl: [(cbAYE,
                       label: lvl7_rbyQg_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAYE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbAYF; else goto cbAYG;
       cbAYF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl7_rbyQg_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbAYG: // global
           I64[Sp - 24] = block_cbAYB_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubAYK; else goto cbAYC;
       ubAYK: // global
           call _cbAYB(R1) args: 0, res: 0, upd: 0;
       cbAYC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAYB() //  [R1]
         { info_tbl: [(cbAYB,
                       label: block_cbAYB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAYB: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 24;
           call $wlvl_rbyQf_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.891001793 UTC

[section ""data" . lvl8_rbyQh_closure" {
     lvl8_rbyQh_closure:
         const lvl8_rbyQh_info;
 },
 sat_sbAvs_entry() //  [R1]
         { info_tbl: [(cbAZ6,
                       label: sat_sbAvs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAZ6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbAZd; else goto cbAZe;
       cbAZd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbAZe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbAZ3_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubAZi; else goto cbAZ4;
       ubAZi: // global
           call _cbAZ3(R1) args: 0, res: 0, upd: 0;
       cbAZ4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbAZ3() //  [R1]
         { info_tbl: [(cbAZ3,
                       label: block_cbAZ3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAZ3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbAZh; else goto cbAZg;
       cbAZh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbAZg: // global
           _sbAvr::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sbAvr::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl8_rbyQh_entry() //  [R2]
         { info_tbl: [(cbAZk,
                       label: lvl8_rbyQh_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAZk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbAZo; else goto cbAZn;
       cbAZo: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = lvl8_rbyQh_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbAZn: // global
           I64[Hp - 40] = sat_sbAvs_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.898901821 UTC

[section ""data" . go_rbyQi_closure" {
     go_rbyQi_closure:
         const go_rbyQi_info;
 },
 go_rbyQi_entry() //  [R2, R3]
         { info_tbl: [(cbAZV,
                       label: go_rbyQi_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAZV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbAZW; else goto ubB04;
       cbAZW: // global
           R3 = R3;
           R2 = R2;
           R1 = go_rbyQi_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ubB04: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cbAZL() args: 0, res: 0, upd: 0;
     }
 },
 _cbAZL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAZL: // global
           _sbAvt::P64 = P64[Sp];
           I64[Sp] = block_cbAZO_info;
           R1 = _sbAvt::P64;
           if (R1 & 7 != 0) goto ubB06; else goto cbAZP;
       ubB06: // global
           call _cbAZO(R1) args: 0, res: 0, upd: 0;
       cbAZP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbAZO() //  [R1]
         { info_tbl: [(cbAZO,
                       label: block_cbAZO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbAZO: // global
           if (R1 & 7 == 1) goto cbAZS; else goto cbAZT;
       cbAZS: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cbAZT: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cbAZL() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.905876672 UTC

[section ""cstring" . lvl9_rbyQj_bytes" {
     lvl9_rbyQj_bytes:
         I8[] [45]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.907510409 UTC

[section ""cstring" . lvl10_rbyQk_bytes" {
     lvl10_rbyQk_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101,39,58,32,84,101,109,112,108,97,116,101,32,115,116,114,105,110,103,32,109,117,115,116,32,110,111,116,32,99,111,110,116,97,105,110,32,112,97,116,104,32,115,101,112,97,114,97,116,111,114,32,99,104,97,114,97,99,116,101,114,115,58,32]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.90950341 UTC

[section ""data" . lvl11_rbyQl_closure" {
     lvl11_rbyQl_closure:
         const lvl11_rbyQl_info;
         const 0;
 },
 lvl11_rbyQl_entry() //  [R2]
         { info_tbl: [(cbB0z,
                       label: lvl11_rbyQl_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB0z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cbB0A; else goto cbB0B;
       cbB0A: // global
           R2 = R2;
           R1 = lvl11_rbyQl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbB0B: // global
           I64[Sp - 8] = block_cbB0x_info;
           R3 = R2;
           R2 = lvl10_rbyQk_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbB0x() //  [R1]
         { info_tbl: [(cbB0x,
                       label: block_cbB0x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB0x: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.IO.failIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:32.920578178 UTC

[section ""data" . System.IO.openBinaryTempFile5_closure" {
     System.IO.openBinaryTempFile5_closure:
         const System.IO.openBinaryTempFile5_info;
         const 0;
 },
 sat_sbAvO_entry() //  [R1]
         { info_tbl: [(cbB1f,
                       label: sat_sbAvO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB1f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbB1g; else goto cbB1h;
       cbB1g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB1h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbAvV_entry() //  [R1]
         { info_tbl: [(cbB1w,
                       label: sat_sbAvV_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB1w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbB1x; else goto cbB1y;
       cbB1x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB1y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbAvU_entry() //  [R1]
         { info_tbl: [(cbB1E,
                       label: sat_sbAvU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB1E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbB1F; else goto cbB1G;
       cbB1F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB1G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.reverse_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 ds_sbAvI_entry() //  [R1]
         { info_tbl: [(cbB1H,
                       label: ds_sbAvI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB1H: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbB1I; else goto cbB1J;
       cbB1I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB1J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cbB10_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbB10() //  [R1]
         { info_tbl: [(cbB10,
                       label: block_cbB10_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB10: // global
           I64[Sp] = block_cbB14_info;
           R3 = R1;
           R2 = lvl5_rbyQd_closure+1;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbB14() //  [R1, R2]
         { info_tbl: [(cbB14,
                       label: block_cbB14_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB14: // global
           I64[Sp - 8] = block_cbB16_info;
           _sbAvL::P64 = R1;
           R1 = R2;
           P64[Sp] = _sbAvL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubB22; else goto cbB17;
       ubB22: // global
           call _cbB16(R1) args: 0, res: 0, upd: 0;
       cbB17: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbB16() //  [R1]
         { info_tbl: [(cbB16,
                       label: block_cbB16_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB16: // global
           if (R1 & 7 == 1) goto cbB1O; else goto cbB1T;
       cbB1O: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbB1R; else goto cbB1Q;
       cbB1R: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbB1Q: // global
           I64[Hp - 40] = sat_sbAvO_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbB1T: // global
           I64[Sp - 8] = block_cbB1k_info;
           _sbAvQ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sbAvQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubB23; else goto cbB1l;
       ubB23: // global
           call _cbB1k(R1) args: 0, res: 0, upd: 0;
       cbB1l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbB1k() //  [R1]
         { info_tbl: [(cbB1k,
                       label: block_cbB1k_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB1k: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbB1W; else goto cbB1V;
       cbB1W: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbB1V: // global
           if (I64[R1 + 7] == 46) goto cbB20; else goto cbB1Y;
       cbB20: // global
           I64[Hp - 88] = sat_sbAvV_info;
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = lvl4_rbyQc_closure+1;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = sat_sbAvU_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 62;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cbB1Y: // global
           Hp = Hp - 96;
           R1 = lvl3_rbyQb_closure;
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 oflags_sbAvX_entry() //  [R1]
         { info_tbl: [(cbB2b,
                       label: oflags_sbAvX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB2b: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cbB2c; else goto cbB2d;
       cbB2c: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB2d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbB28_info;
           _sbAvE::P64 = P64[R1 + 16];
           R1 = lvl6_rbyQe_closure;
           P64[Sp - 24] = _sbAvE::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubB2O; else goto cbB29;
       ubB2O: // global
           call _cbB28(R1) args: 0, res: 0, upd: 0;
       cbB29: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbB28() //  [R1]
         { info_tbl: [(cbB28,
                       label: block_cbB28_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB28: // global
           I64[Sp - 8] = block_cbB2g_info;
           _sbAvY::P64 = R1;
           _sbAvZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _sbAvZ::I64;
           P64[Sp + 8] = _sbAvY::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ubB2N; else goto cbB2i;
       ubB2N: // global
           call _cbB2g(R1) args: 0, res: 0, upd: 0;
       cbB2i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbB2g() //  [R1]
         { info_tbl: [(cbB2g,
                       label: block_cbB2g_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB2g: // global
           if (R1 & 7 == 1) goto cbB2o; else goto cbB2I;
       cbB2o: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbB2I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbB2L; else goto cbB2K;
       cbB2L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbB2K: // global
           _sbAvZ::I64 = I64[Sp + 8];
           (_sbAw4::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_o_binary();
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _sbAvZ::I64 | %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbAw4::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 lvl12_sbAwa_entry() //  [R1, R2]
         { info_tbl: [(cbB2X,
                       label: lvl12_sbAwa_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB2X: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbB3i; else goto cbB3j;
       cbB3i: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbB3j: // global
           I64[Sp - 24] = block_cbB2U_info;
           _sbAvF::P64 = P64[R1 + 6];
           _sbAvX::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 16] = _sbAvF::P64;
           P64[Sp - 8] = _sbAvX::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ubB3q; else goto cbB2V;
       ubB3q: // global
           call _cbB2U(R1) args: 0, res: 0, upd: 0;
       cbB2V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB2U() //  [R1]
         { info_tbl: [(cbB2U,
                       label: block_cbB2U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB2U: // global
           I64[Sp] = block_cbB30_info;
           _sbAwe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sbAwe::I64;
           if (R1 & 7 != 0) goto ubB3p; else goto cbB31;
       ubB3p: // global
           call _cbB30(R1) args: 0, res: 0, upd: 0;
       cbB31: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB30() //  [R1]
         { info_tbl: [(cbB30,
                       label: block_cbB30_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB30: // global
           I64[Sp] = block_cbB35_info;
           _sbAwg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sbAwg::I64;
           if (R1 & 7 != 0) goto ubB3r; else goto cbB36;
       ubB3r: // global
           call _cbB35(R1) args: 0, res: 0, upd: 0;
       cbB36: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB35() //  [R1]
         { info_tbl: [(cbB35,
                       label: block_cbB35_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB35: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbB3o; else goto cbB3n;
       cbB3o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbB3n: // global
           (_sbAwm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     signed,]  result hints:  [signed] __hscore_open(I64[Sp + 16], I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbAwm::I64));
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbAwq_entry() //  [R1]
         { info_tbl: [(cbB3A,
                       label: sat_sbAwq_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB3A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbB3B; else goto cbB3C;
       cbB3B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB3C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.List.lastError_closure;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_rbyQi_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 lvl13_sbAwp_entry() //  [R1]
         { info_tbl: [(cbB3E,
                       label: lvl13_sbAwp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB3E: // global
           _sbAwp::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cbB3F; else goto cbB3G;
       cbB3G: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cbB3I; else goto cbB3H;
       cbB3I: // global
           HpAlloc = 48;
           goto cbB3F;
       cbB3F: // global
           R1 = _sbAwp::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB3H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sbAwp::P64;
           _sbAvC::P64 = P64[_sbAwp::P64 + 16];
           I64[Hp - 40] = sat_sbAwq_info;
           P64[Hp - 24] = _sbAvC::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = GHC.Types.[]_closure+1;
           R4 = Hp - 14;
           R3 = pathSeparatorChar_rbxCK_closure+1;
           R2 = GHC.Classes.$fEqChar_closure;
           Sp = Sp - 16;
           call GHC.List.elem_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbAwY_entry() //  [R1]
         { info_tbl: [(cbB4t,
                       label: sat_sbAwY_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB4t: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cbB4z; else goto cbB4A;
       cbB4z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB4A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cbB4q_info;
           _sbAwM::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sbAwM::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ubB4F; else goto cbB4r;
       ubB4F: // global
           call _cbB4q(R1) args: 0, res: 0, upd: 0;
       cbB4r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbB4q() //  [R1]
         { info_tbl: [(cbB4q,
                       label: block_cbB4q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB4q: // global
           I64[Sp] = block_cbB4w_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[R1 + 7];
           R2 = 0;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbB4w() //  [R1, R2]
         { info_tbl: [(cbB4w,
                       label: block_cbB4w_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB4w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbB4E; else goto cbB4D;
       cbB4E: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cbB4D: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = P64[Sp + 8];
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sbAwZ_entry() //  [R1]
         { info_tbl: [(cbB4G,
                       label: sat_sbAwZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB4G: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cbB4K; else goto cbB4J;
       cbB4K: // global
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB4J: // global
           _sbAwF::P64 = P64[R1 + 16];
           _sbAwM::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sbAwY_info;
           P64[Hp - 8] = _sbAwF::P64;
           P64[Hp] = _sbAwM::P64;
           R3 = Hp - 24;
           R2 = lvl9_rbyQj_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sbAx0_entry() //  [R1]
         { info_tbl: [(cbB4L,
                       label: sat_sbAx0_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB4L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cbB4N; else goto cbB4O;
       cbB4N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB4O: // global
           I64[Sp - 24] = block_cbB4g_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 32]));
           R2 = 0;
           P64[Sp - 16] = P64[R1 + 16];
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbB4g() //  [R1, R2]
         { info_tbl: [(cbB4g,
                       label: block_cbB4g_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB4g: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbB4R; else goto cbB4Q;
       cbB4R: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cbB4Q: // global
           I64[Hp - 48] = sat_sbAwZ_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 48;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 filepath_sbAwJ_entry() //  [R1]
         { info_tbl: [(cbB4S,
                       label: filepath_sbAwJ_info
                       rep:HeapRep 4 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB4S: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cbB4T; else goto cbB4U;
       cbB4T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbB4U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 56] = block_cbB44_info;
           _sbAvC::P64 = P64[R1 + 16];
           _sbAwp::P64 = P64[R1 + 32];
           _sbAwF::P64 = P64[R1 + 40];
           _sbAwA::I64 = I64[R1 + 48];
           R1 = P64[R1 + 24];
           P64[Sp - 48] = _sbAvC::P64;
           P64[Sp - 40] = _sbAwp::P64;
           I64[Sp - 32] = _sbAwA::I64;
           P64[Sp - 24] = _sbAwF::P64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ubB5D; else goto cbB45;
       ubB5D: // global
           call _cbB44(R1) args: 0, res: 0, upd: 0;
       cbB45: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbB44() //  [R1]
         { info_tbl: [(cbB44,
                       label: block_cbB44_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB44: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cbB4Y; else goto cbB4X;
       cbB4Y: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbB4X: // global
           _sbAwL::P64 = P64[R1 + 7];
           _sbAwM::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sbAx0_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = _sbAwM::P64;
           I64[Hp] = I64[Sp + 24];
           I64[Sp] = block_cbB4V_info;
           R3 = Hp - 32;
           R2 = _sbAwL::P64;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cbB4V() //  [R1]
         { info_tbl: [(cbB4V,
                       label: block_cbB4V_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB4V: // global
           _sbAvC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbB54; else goto cbB59;
       cbB54: // global
           R1 = _sbAvC::P64 & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbB59: // global
           I64[Sp + 8] = block_cbB57_info;
           _sbAx1::P64 = R1;
           R1 = _sbAvC::P64;
           P64[Sp + 32] = _sbAx1::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubB5E; else goto cbB5a;
       ubB5E: // global
           call _cbB57(R1) args: 0, res: 0, upd: 0;
       cbB5a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbB57() //  [R1]
         { info_tbl: [(cbB57,
                       label: block_cbB57_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB57: // global
           if (R1 & 7 == 1) goto cbB5g; else goto cbB5l;
       cbB5g: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cbB5l: // global
           _sbAwp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cbB5j_info;
           _sbAx4::P64 = R1;
           R1 = _sbAwp::P64;
           P64[Sp + 16] = _sbAx4::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ubB5F; else goto cbB5m;
       ubB5F: // global
           call _cbB5j(R1) args: 0, res: 0, upd: 0;
       cbB5m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _cbB5j() //  [R1]
         { info_tbl: [(cbB5j,
                       label: block_cbB5j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB5j: // global
           _sbAx1::P64 = P64[Sp + 16];
           _sbAx4::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cbB5s; else goto cbB5z;
       cbB5s: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbB5v; else goto cbB5u;
       cbB5v: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cbB5u: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = pathSeparatorChar_rbxCK_closure+1;
           P64[Hp] = _sbAx1::P64;
           R3 = Hp - 14;
           R2 = _sbAx4::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
       cbB5z: // global
           R3 = _sbAx1::P64;
           R2 = _sbAx4::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 System.IO.openBinaryTempFile5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(cbB5K,
                       label: System.IO.openBinaryTempFile5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB5K: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cbB5L; else goto cbB5M;
       cbB5L: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = System.IO.openBinaryTempFile5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbB5M: // global
           I64[Sp - 48] = block_cbB0S_info;
           _sbAvD::P64 = R4;
           R4 = R4;
           _sbAvC::P64 = R3;
           R3 = pathSeparatorChar_rbxCK_closure+1;
           _sbAvB::P64 = R2;
           R2 = GHC.Classes.$fEqChar_closure;
           P64[Sp - 40] = _sbAvB::P64;
           P64[Sp - 32] = _sbAvC::P64;
           P64[Sp - 24] = _sbAvD::P64;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 48;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbB0S() //  [R1]
         { info_tbl: [(cbB0S,
                       label: block_cbB0S_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB0S: // global
           _sbAvD::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cbB5H; else goto cbB5I;
       cbB5H: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cbB5P; else goto cbB5O;
       cbB5P: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbB5O: // global
           I64[Hp - 88] = ds_sbAvI_info;
           P64[Hp - 72] = _sbAvD::P64;
           I64[Hp - 64] = oflags_sbAvX_info;
           P64[Hp - 48] = P64[Sp + 32];
           I64[Hp - 40] = lvl12_sbAwa_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = lvl13_sbAwp_info;
           P64[Hp] = P64[Sp + 16];
           P64[Sp + 24] = Hp - 16;
           P64[Sp + 32] = Hp - 38;
           P64[Sp + 40] = Hp - 88;
           Sp = Sp + 8;
           call _cbB3O() args: 0, res: 0, upd: 0;
       cbB5I: // global
           R2 = _sbAvD::P64;
           Sp = Sp + 48;
           call lvl11_rbyQl_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbB3O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB3O: // global
           (_sbAwA::I64) = call "ccall" arg hints:  []  result hints:  [signed] getpid();
           I64[Sp - 16] = block_cbB3R_info;
           R1 = tempCounter_rbxCH_closure;
           I64[Sp - 8] = _sbAwA::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ubB7D; else goto cbB3S;
       ubB7D: // global
           call _cbB3R(R1) args: 0, res: 0, upd: 0;
       cbB3S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB3R() //  [R1]
         { info_tbl: [(cbB3R,
                       label: block_cbB3R_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB3R: // global
           I64[Sp] = block_cbB3W_info;
           R2 = lvl8_rbyQh_closure+1;
           R1 = P64[R1 + 7];
           call stg_atomicModifyMutVar#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB3W() //  [R1]
         { info_tbl: [(cbB3W,
                       label: block_cbB3W_info
                       rep:StackRep [True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB3W: // global
           I64[Sp - 8] = block_cbB3Y_info;
           _sbAwF::P64 = R1;
           R1 = GHC.IO.Encoding.getFileSystemEncoding_closure;
           P64[Sp] = _sbAwF::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB3Y() //  [R1]
         { info_tbl: [(cbB3Y,
                       label: block_cbB3Y_info
                       rep:StackRep [False, True, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB3Y: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cbB62; else goto cbB61;
       cbB62: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbB61: // global
           I64[Hp - 48] = filepath_sbAwJ_info;
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 56];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = I64[Sp + 16];
           I64[Sp + 8] = block_cbB5U_info;
           R4 = P64[Sp + 48];
           _cbB40::P64 = Hp - 48;
           R3 = _cbB40::P64;
           R2 = R1;
           P64[Sp + 16] = _cbB40::P64;
           Sp = Sp + 8;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cbB5U() //  [R1]
         { info_tbl: [(cbB5U,
                       label: block_cbB5U_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB5U: // global
           I64[Sp] = block_cbB5W_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubB7E; else goto cbB64;
       ubB7E: // global
           call _cbB5W(R1) args: 0, res: 0, upd: 0;
       cbB64: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB5W() //  [R1]
         { info_tbl: [(cbB5W,
                       label: block_cbB5W_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB5W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbB6a; else goto cbB69;
       cbB6a: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbB69: // global
           if (%MO_S_Ge_W64(I64[R1 + 7], 0)) goto cbB71; else goto cbB7m;
       cbB71: // global
           I64[Hp - 8] = System.IO.NewFileCreated_con_info;
           P64[Hp] = R1;
           P64[Sp] = Hp - 7;
           goto ubB7H;
       cbB7m: // global
           (_sbAxG::I64) = call "ccall" arg hints:  []  result hints:  [signed] __hscore_get_errno();
           Hp = Hp - 16;
           _sbAxH::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(_sbAxG::I64));
           if (_sbAxH::I64 != 17) goto ubB7x; else goto cbB7i;
       ubB7x: // global
           I64[Sp] = _sbAxH::I64;
           call _cbB7b() args: 0, res: 0, upd: 0;
       cbB7i: // global
           P64[Sp] = System.IO.FileExists_closure+2;
           goto ubB7H;
       ubB7H: // global
           call _sbAxe() args: 0, res: 0, upd: 0;
     }
 },
 _cbB7b() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB7b: // global
           Hp = Hp + 32;
           _sbAxH::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cbB7f; else goto cbB7e;
       cbB7f: // global
           HpAlloc = 32;
           I64[Sp] = block_cbB78_info;
           R1 = _sbAxH::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cbB7e: // global
           I64[Hp - 24] = GHC.Int.I32#_con_info;
           I64[Hp - 16] = _sbAxH::I64;
           I64[Hp - 8] = System.IO.OpenNewError_con_info;
           P64[Hp] = Hp - 23;
           P64[Sp] = Hp - 5;
           call _sbAxe() args: 0, res: 0, upd: 0;
     }
 },
 _cbB78() //  [R1]
         { info_tbl: [(cbB78,
                       label: block_cbB78_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB78: // global
           I64[Sp] = R1;
           call _cbB7b() args: 0, res: 0, upd: 0;
     }
 },
 _sbAxe() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       sbAxe: // global
           _sbAxg::P64 = P64[Sp];
           I64[Sp] = block_cbB6g_info;
           R1 = _sbAxg::P64;
           if (R1 & 7 != 0) goto ubB7N; else goto cbB6i;
       ubB7N: // global
           call _cbB6g(R1) args: 0, res: 0, upd: 0;
       cbB6i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB6g() //  [R1]
         { info_tbl: [(cbB6g,
                       label: block_cbB6g_info
                       rep:StackRep [False, False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB6g: // global
           _cbB7t::P64 = R1 & 7;
           if (_cbB7t::P64 < 3) goto ubB7u; else goto cbB6X;
       ubB7u: // global
           if (_cbB7t::P64 < 2) goto cbB6G; else goto ubB7B;
       cbB6G: // global
           I64[Sp] = block_cbB6m_info;
           R5 = GHC.Types.True_closure+2;
           R4 = GHC.Base.Nothing_closure+1;
           R3 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R2 = P64[R1 + 7];
           call GHC.IO.FD.$wmkFD_entry(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 8, upd: 8;
       ubB7B: // global
           Sp = Sp + 16;
           call _cbB3O() args: 0, res: 0, upd: 0;
       cbB6X: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[R1 + 5];
           Sp = Sp + 56;
           call lvl7_rbyQg_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 _cbB6m() //  [R1]
         { info_tbl: [(cbB6m,
                       label: block_cbB6m_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB6m: // global
           I64[Sp] = block_cbB6o_info;
           R1 = R1;
           if (R1 & 7 != 0) goto ubB7J; else goto cbB6p;
       ubB7J: // global
           call _cbB6o(R1) args: 0, res: 0, upd: 0;
       cbB6p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB6o() //  [R1]
         { info_tbl: [(cbB6o,
                       label: block_cbB6o_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB6o: // global
           I64[Sp] = block_cbB6t_info;
           _sbAxn::P64 = P64[R1 + 7];
           _sbAxo::P64 = P64[R1 + 15];
           R1 = GHC.IO.Encoding.getLocaleEncoding1_closure;
           P64[Sp + 40] = _sbAxo::P64;
           P64[Sp + 48] = _sbAxn::P64;
           if (R1 & 7 != 0) goto ubB7K; else goto cbB6u;
       ubB7K: // global
           call _cbB6t(R1) args: 0, res: 0, upd: 0;
       cbB6u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB6t() //  [R1]
         { info_tbl: [(cbB6t,
                       label: block_cbB6t_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB6t: // global
           I64[Sp] = block_cbB6y_info;
           R1 = P64[R1 + 7];
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cbB6y() //  [R1]
         { info_tbl: [(cbB6y,
                       label: block_cbB6y_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB6y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbB6M; else goto cbB6L;
       cbB6M: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbB6L: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           I64[Sp] = block_cbB6B_info;
           R6 = GHC.Types.False_closure+1;
           R5 = GHC.IO.IOMode.ReadWriteMode_closure+4;
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 40];
           R2 = P64[Sp + 48];
           P64[Sp - 8] = Hp - 6;
           Sp = Sp - 8;
           call GHC.IO.Handle.FD.fdToHandle5_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 16, res: 8, upd: 8;
     }
 },
 _cbB6B() //  [R1]
         { info_tbl: [(cbB6B,
                       label: block_cbB6B_info
                       rep:StackRep [False, True, True, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbB6B: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cbB6P; else goto cbB6O;
       cbB6P: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cbB6O: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.009442757 UTC

[section ""cstring" . System.IO.openBinaryTempFileWithDefaultPermissions4_bytes" {
     System.IO.openBinaryTempFileWithDefaultPermissions4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,84,101,109,112,70,105,108,101,87,105,116,104,68,101,102,97,117,108,116,80,101,114,109,105,115,115,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.011344916 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions3_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions3_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions3_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions3_entry() //  [R1]
         { info_tbl: [(cbBcM,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBcM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbBcN; else goto cbBcO;
       cbBcN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbBcO: // global
           (_cbBcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbBcJ::I64 == 0) goto cbBcL; else goto cbBcK;
       cbBcL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbBcK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbBcJ::I64;
           R2 = System.IO.openBinaryTempFileWithDefaultPermissions4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.015209427 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions2_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions2_closure:
         const GHC.Word.W32#_con_info;
         const 438;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.017007478 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions1_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions1_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions1_info;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions1_entry() //  [R2,
                                                                  R3]
         { info_tbl: [(cbBd2,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBd2: // global
           R6 = System.IO.openBinaryTempFileWithDefaultPermissions2_closure+1;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openBinaryTempFileWithDefaultPermissions3_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.020480592 UTC

[section ""data" . System.IO.openBinaryTempFileWithDefaultPermissions_closure" {
     System.IO.openBinaryTempFileWithDefaultPermissions_closure:
         const System.IO.openBinaryTempFileWithDefaultPermissions_info;
         const 0;
 },
 System.IO.openBinaryTempFileWithDefaultPermissions_entry() //  [R2,
                                                                 R3]
         { info_tbl: [(cbBde,
                       label: System.IO.openBinaryTempFileWithDefaultPermissions_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBde: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openBinaryTempFileWithDefaultPermissions1_entry(R3,
                                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.024917811 UTC

[section ""cstring" . System.IO.openTempFileWithDefaultPermissions3_bytes" {
     System.IO.openTempFileWithDefaultPermissions3_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101,87,105,116,104,68,101,102,97,117,108,116,80,101,114,109,105,115,115,105,111,110,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.026970531 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions2_closure" {
     System.IO.openTempFileWithDefaultPermissions2_closure:
         const System.IO.openTempFileWithDefaultPermissions2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions2_entry() //  [R1]
         { info_tbl: [(cbBds,
                       label: System.IO.openTempFileWithDefaultPermissions2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBds: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbBdt; else goto cbBdu;
       cbBdt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbBdu: // global
           (_cbBdp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbBdp::I64 == 0) goto cbBdr; else goto cbBdq;
       cbBdr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbBdq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbBdp::I64;
           R2 = System.IO.openTempFileWithDefaultPermissions3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.031647365 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions1_closure" {
     System.IO.openTempFileWithDefaultPermissions1_closure:
         const System.IO.openTempFileWithDefaultPermissions1_info;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions1_entry() //  [R2, R3]
         { info_tbl: [(cbBdH,
                       label: System.IO.openTempFileWithDefaultPermissions1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBdH: // global
           R6 = System.IO.openBinaryTempFileWithDefaultPermissions2_closure+1;
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openTempFileWithDefaultPermissions2_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.035681305 UTC

[section ""data" . System.IO.openTempFileWithDefaultPermissions_closure" {
     System.IO.openTempFileWithDefaultPermissions_closure:
         const System.IO.openTempFileWithDefaultPermissions_info;
         const 0;
 },
 System.IO.openTempFileWithDefaultPermissions_entry() //  [R2, R3]
         { info_tbl: [(cbBdT,
                       label: System.IO.openTempFileWithDefaultPermissions_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBdT: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openTempFileWithDefaultPermissions1_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.038984818 UTC

[section ""cstring" . System.IO.openBinaryTempFile4_bytes" {
     System.IO.openBinaryTempFile4_bytes:
         I8[] [111,112,101,110,66,105,110,97,114,121,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.040854827 UTC

[section ""data" . System.IO.openBinaryTempFile3_closure" {
     System.IO.openBinaryTempFile3_closure:
         const System.IO.openBinaryTempFile3_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openBinaryTempFile3_entry() //  [R1]
         { info_tbl: [(cbBe7,
                       label: System.IO.openBinaryTempFile3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBe7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbBe8; else goto cbBe9;
       cbBe8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbBe9: // global
           (_cbBe4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbBe4::I64 == 0) goto cbBe6; else goto cbBe5;
       cbBe6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbBe5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbBe4::I64;
           R2 = System.IO.openBinaryTempFile4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.044758578 UTC

[section ""data" . System.IO.openBinaryTempFile2_closure" {
     System.IO.openBinaryTempFile2_closure:
         const GHC.Word.W32#_con_info;
         const 384;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.047005611 UTC

[section ""data" . System.IO.openBinaryTempFile1_closure" {
     System.IO.openBinaryTempFile1_closure:
         const System.IO.openBinaryTempFile1_info;
         const 0;
 },
 System.IO.openBinaryTempFile1_entry() //  [R2, R3]
         { info_tbl: [(cbBen,
                       label: System.IO.openBinaryTempFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBen: // global
           R6 = System.IO.openBinaryTempFile2_closure+1;
           R5 = GHC.Types.True_closure+2;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openBinaryTempFile3_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.050659402 UTC

[section ""data" . System.IO.openBinaryTempFile_closure" {
     System.IO.openBinaryTempFile_closure:
         const System.IO.openBinaryTempFile_info;
         const 0;
 },
 System.IO.openBinaryTempFile_entry() //  [R2, R3]
         { info_tbl: [(cbBez,
                       label: System.IO.openBinaryTempFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBez: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openBinaryTempFile1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.053857733 UTC

[section ""cstring" . System.IO.openTempFile3_bytes" {
     System.IO.openTempFile3_bytes:
         I8[] [111,112,101,110,84,101,109,112,70,105,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.055702099 UTC

[section ""data" . System.IO.openTempFile2_closure" {
     System.IO.openTempFile2_closure:
         const System.IO.openTempFile2_info;
         const 0;
         const 0;
         const 0;
 },
 System.IO.openTempFile2_entry() //  [R1]
         { info_tbl: [(cbBeN,
                       label: System.IO.openTempFile2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBeN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cbBeO; else goto cbBeP;
       cbBeO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbBeP: // global
           (_cbBeK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cbBeK::I64 == 0) goto cbBeM; else goto cbBeL;
       cbBeM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cbBeL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbBeK::I64;
           R2 = System.IO.openTempFile3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.06054752 UTC

[section ""data" . System.IO.openTempFile1_closure" {
     System.IO.openTempFile1_closure:
         const System.IO.openTempFile1_info;
         const 0;
 },
 System.IO.openTempFile1_entry() //  [R2, R3]
         { info_tbl: [(cbBf2,
                       label: System.IO.openTempFile1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBf2: // global
           R6 = System.IO.openBinaryTempFile2_closure+1;
           R5 = GHC.Types.False_closure+1;
           R4 = R3;
           R3 = R2;
           R2 = System.IO.openTempFile2_closure;
           call System.IO.openBinaryTempFile5_entry(R6,
                                                    R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.064104701 UTC

[section ""data" . System.IO.openTempFile_closure" {
     System.IO.openTempFile_closure:
         const System.IO.openTempFile_info;
         const 0;
 },
 System.IO.openTempFile_entry() //  [R2, R3]
         { info_tbl: [(cbBfe,
                       label: System.IO.openTempFile_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBfe: // global
           R3 = R3;
           R2 = R2;
           call System.IO.openTempFile1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.067441509 UTC

[section ""data" . System.IO.NewFileCreated_closure" {
     System.IO.NewFileCreated_closure:
         const System.IO.NewFileCreated_info;
 },
 System.IO.NewFileCreated_entry() //  [R2]
         { info_tbl: [(cbBfq,
                       label: System.IO.NewFileCreated_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBfq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbBfu; else goto cbBft;
       cbBfu: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = System.IO.NewFileCreated_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbBft: // global
           I64[Hp - 8] = System.IO.NewFileCreated_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.071312048 UTC

[section ""data" . System.IO.FileExists_closure" {
     System.IO.FileExists_closure:
         const System.IO.FileExists_con_info;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.073076452 UTC

[section ""data" . System.IO.OpenNewError_closure" {
     System.IO.OpenNewError_closure:
         const System.IO.OpenNewError_info;
 },
 System.IO.OpenNewError_entry() //  [R2]
         { info_tbl: [(cbBfH,
                       label: System.IO.OpenNewError_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBfH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cbBfL; else goto cbBfK;
       cbBfL: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = System.IO.OpenNewError_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbBfK: // global
           I64[Hp - 8] = System.IO.OpenNewError_con_info;
           P64[Hp] = R2;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.076668825 UTC

[System.IO.NewFileCreated_con_entry() //  [R1]
         { info_tbl: [(cbBfS,
                       label: System.IO.NewFileCreated_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,78,101,119,70,105,108,101,67,114,101,97,116,101,100]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBfS: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.079806742 UTC

[System.IO.FileExists_con_entry() //  [R1]
         { info_tbl: [(cbBfZ,
                       label: System.IO.FileExists_con_info
                       rep:HeapRep 1 nonptrs {
                             Con {tag: 1
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,70,105,108,101,69,120,105,115,116,115]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBfZ: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.083384108 UTC

[System.IO.OpenNewError_con_entry() //  [R1]
         { info_tbl: [(cbBg6,
                       label: System.IO.OpenNewError_con_info
                       rep:HeapRep 1 ptrs {
                             Con {tag: 2
                                  descr:[98,97,115,101,58,83,121,115,116,101,109,46,73,79,46,79,112,101,110,78,101,119,69,114,114,111,114]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cbBg6: // global
           R1 = R1 + 3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:33.086513691 UTC

[section ""relreadonly" . SbAxZ_srt" {
     SbAxZ_srt:
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.IO.Handle.Text.hPutChar1_closure;
         const System.IO.putChar1_closure;
         const GHC.IO.Handle.Text.hPutStr_closure;
         const GHC.IO.Handle.Text.hPutStrLn_closure;
         const System.IO.print_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.Internals.wantReadableHandle_1_closure;
         const GHC.IO.Handle.Text.hGetChar2_closure;
         const GHC.IO.Handle.Text.hGetChar6_closure;
         const GHC.IO.Handle.FD.stdin_closure;
         const System.IO.getChar1_closure;
         const GHC.IO.Handle.Text.hGetLine2_closure;
         const GHC.IO.Handle.Text.hGetLine4_closure;
         const System.IO.getLine1_closure;
         const GHC.IO.Handle.Text.hGetContents1_closure;
         const System.IO.getContents1_closure;
         const GHC.IO.Handle.Text.hWaitForInput1_closure;
         const System.IO.hReady1_closure;
         const System.IO.hPrint_closure;
         const GHC.IO.Handle.hClose1_closure;
         const GHC.IO.Handle.FD.openFile1_closure;
         const System.IO.appendFile2_closure;
         const System.IO.appendFile1_closure;
         const System.IO.writeFile1_closure;
         const GHC.IO.Handle.FD.openBinaryFile1_closure;
         const System.IO.withBinaryFile1_closure;
         const GHC.IO.Exception.$fExceptionFixIOException_$ctoException_closure;
         const lvl1_rbyQ9_closure;
         const Data.Typeable.Internal.sameTypeRep_closure;
         const GHC.IO.Exception.$fExceptionBlockedIndefinitelyOnMVar3_closure;
         const System.IO.fixIO2_closure;
         const System.IO.fixIO3_closure;
         const System.IO.fixIO1_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const System.IO.readIO7_closure;
         const System.IO.readIO3_closure;
         const System.IO.readIO10_closure;
         const GHC.Read.lex1_closure;
         const System.IO.readIO1_closure;
         const System.IO.readIO2_closure;
         const System.IO.readIO6_closure;
         const System.IO.readLn1_closure;
         const System.IO.readFile1_closure;
         const System.IO.interact1_closure;
         const GHC.IO.Handle.Text.hPutStr'_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Foreign.C.Error.$werrnoToIOError_closure;
         const $wlvl_rbyQf_closure;
         const lvl7_rbyQg_closure;
         const GHC.IO.failIO1_closure;
         const lvl11_rbyQl_closure;
         const lvl3_rbyQb_closure;
         const lvl6_rbyQe_closure;
         const GHC.List.lastError_closure;
         const GHC.IO.Encoding.getFileSystemEncoding_closure;
         const GHC.IO.Encoding.getLocaleEncoding1_closure;
         const GHC.IO.FD.$wmkFD_closure;
         const GHC.IO.Handle.FD.fdToHandle5_closure;
         const tempCounter_rbxCH_closure;
         const System.IO.openBinaryTempFile5_closure;
         const System.IO.openBinaryTempFileWithDefaultPermissions3_closure;
         const System.IO.openBinaryTempFileWithDefaultPermissions1_closure;
         const System.IO.openTempFileWithDefaultPermissions2_closure;
         const System.IO.openTempFileWithDefaultPermissions1_closure;
         const System.IO.openBinaryTempFile3_closure;
         const System.IO.openBinaryTempFile1_closure;
         const System.IO.openTempFile2_closure;
         const System.IO.openTempFile1_closure;
 }]

