
==================== Output Cmm ====================
2018-03-16 16:07:31.293230747 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:31.293832272 UTC

[section ""cstring" . System.CPUTime.Posix.Times.$trModule4_bytes" {
     System.CPUTime.Posix.Times.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.294407402 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule3_closure" {
     System.CPUTime.Posix.Times.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.CPUTime.Posix.Times.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.295061636 UTC

[section ""cstring" . System.CPUTime.Posix.Times.$trModule2_bytes" {
     System.CPUTime.Posix.Times.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,67,80,85,84,105,109,101,46,80,111,115,105,120,46,84,105,109,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.295603863 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule1_closure" {
     System.CPUTime.Posix.Times.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.CPUTime.Posix.Times.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.2962054 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule_closure" {
     System.CPUTime.Posix.Times.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.CPUTime.Posix.Times.$trModule3_closure+1;
         const System.CPUTime.Posix.Times.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.297117111 UTC

[section ""data" . System.CPUTime.Posix.Times.clockTicks_closure" {
     System.CPUTime.Posix.Times.clockTicks_closure:
         const System.CPUTime.Posix.Times.clockTicks_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.clockTicks_entry() //  [R1]
         { info_tbl: [(ccCwJ,
                       label: System.CPUTime.Posix.Times.clockTicks_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCwJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCwK; else goto ccCwL;
       ccCwK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCwL: // global
           (_ccCwF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCwF::I64 == 0) goto ccCwH; else goto ccCwG;
       ccCwH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCwG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCwF::I64;
           (_scCw3::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] clk_tck();
           R2 = _scCw3::I64;
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.298169461 UTC

[section ""data" . sat_scCw5_closure" {
     sat_scCw5_closure:
         const GHC.Types.I#_con_info;
         const 465;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.29878533 UTC

[section ""data" . sat_scCw6_closure" {
     sat_scCw6_closure:
         const :_con_info;
         const sat_scCw5_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.299393234 UTC

[section ""data" . sat_scCw4_closure" {
     sat_scCw4_closure:
         const GHC.Types.I#_con_info;
         const 1420103680;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.299966936 UTC

[section ""data" . sat_scCw7_closure" {
     sat_scCw7_closure:
         const :_con_info;
         const sat_scCw4_closure+1;
         const sat_scCw6_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.300735099 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime2_closure" {
     System.CPUTime.Posix.Times.getCPUTime2_closure:
         const System.CPUTime.Posix.Times.getCPUTime2_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime2_entry() //  [R1]
         { info_tbl: [(ccCwS,
                       label: System.CPUTime.Posix.Times.getCPUTime2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCwS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCwT; else goto ccCwU;
       ccCwT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCwU: // global
           (_ccCwP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCwP::I64 == 0) goto ccCwR; else goto ccCwQ;
       ccCwR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCwQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCwP::I64;
           R3 = sat_scCw7_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.301927578 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision2_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision2_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision2_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision2_entry() //  [R1]
         { info_tbl: [(ccCx4,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCx4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccCx5; else goto ccCx6;
       ccCx5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCx6: // global
           (_ccCwZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCwZ::I64 == 0) goto ccCx1; else goto ccCx0;
       ccCx1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCx0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCwZ::I64;
           I64[Sp - 24] = block_ccCx2_info;
           R3 = System.CPUTime.Posix.Times.clockTicks_closure;
           R2 = System.CPUTime.Posix.Times.getCPUTime2_closure;
           Sp = Sp - 24;
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCx2() //  [R1, R2]
         { info_tbl: [(ccCx2,
                       label: block_ccCx2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCx2: // global
           R4 = R2;
           R3 = R1;
           R2 = GHC.Real.$fIntegralInteger_closure;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.303105293 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision1_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision1_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision1_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision1_entry() //  []
         { info_tbl: [(ccCxc,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCxc: // global
           R1 = System.CPUTime.Posix.Times.getCpuTimePrecision2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.303957832 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision_entry() //  []
         { info_tbl: [(ccCxj,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCxj: // global
           call System.CPUTime.Posix.Times.getCpuTimePrecision1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.304817243 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime3_closure" {
     System.CPUTime.Posix.Times.getCPUTime3_closure:
         const System.CPUTime.Posix.Times.getCPUTime3_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime3_entry() //  [R1]
         { info_tbl: [(ccCxs,
                       label: System.CPUTime.Posix.Times.getCPUTime3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCxs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCxt; else goto ccCxu;
       ccCxt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCxu: // global
           (_ccCxp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCxp::I64 == 0) goto ccCxr; else goto ccCxq;
       ccCxr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCxq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCxp::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.306693792 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime1_closure" {
     System.CPUTime.Posix.Times.getCPUTime1_closure:
         const System.CPUTime.Posix.Times.getCPUTime1_info;
         const 0;
 },
 sat_scCwB_entry() //  [R1]
         { info_tbl: [(ccCxT,
                       label: sat_scCwB_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCxT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCxU; else goto ccCxV;
       ccCxU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCxV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccCxO_info;
           R3 = System.CPUTime.Posix.Times.getCPUTime3_closure;
           R2 = System.CPUTime.Posix.Times.clockTicks_closure;
           I64[Sp - 32] = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCxO() //  [R1]
         { info_tbl: [(ccCxO,
                       label: block_ccCxO_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCxO: // global
           if (R1 == 1) goto ccCxS; else goto ccCxR;
       ccCxS: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccCxR: // global
           I64[Sp] = block_ccCxY_info;
           R2 = I64[Sp + 16];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCxY() //  [R1]
         { info_tbl: [(ccCxY,
                       label: block_ccCxY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCxY: // global
           _scCwq::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_ccCy2_info;
           R2 = _scCwq::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCy2() //  [R1]
         { info_tbl: [(ccCy2,
                       label: block_ccCy2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCy2: // global
           _scCwy::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCy6_info;
           R3 = _scCwy::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCy6() //  [R1]
         { info_tbl: [(ccCy6,
                       label: block_ccCy6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCy6: // global
           I64[Sp] = block_ccCya_info;
           R3 = System.CPUTime.Posix.Times.getCPUTime2_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCya() //  [R1]
         { info_tbl: [(ccCya,
                       label: block_ccCya_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCya: // global
           R3 = System.CPUTime.Posix.Times.clockTicks_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 System.CPUTime.Posix.Times.getCPUTime1_entry() //  []
         { info_tbl: [(ccCym,
                       label: System.CPUTime.Posix.Times.getCPUTime1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCym: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccCyn; else goto ccCyo;
       ccCyn: // global
           R1 = System.CPUTime.Posix.Times.getCPUTime1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccCyo: // global
           I64[Sp - 8] = block_ccCxz_info;
           R1 = 32;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccCxz() //  [R1]
         { info_tbl: [(ccCxz,
                       label: block_ccCxz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCxz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccCyr; else goto ccCyq;
       ccCyr: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccCyq: // global
           _scCwj::I64 = R1 + 16;
           (_scCwn::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] times(_scCwj::I64);
           _scCwq::I64 = I64[_scCwj::I64];
           _scCwu::I64 = I64[_scCwj::I64 + 8];
           call MO_Touch(R1);
           I64[Hp - 24] = sat_scCwB_info;
           I64[Hp - 8] = _scCwq::I64;
           I64[Hp] = _scCwu::I64;
           R1 = Hp - 24;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.308967748 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime_closure" {
     System.CPUTime.Posix.Times.getCPUTime_closure:
         const System.CPUTime.Posix.Times.getCPUTime_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime_entry() //  []
         { info_tbl: [(ccCyw,
                       label: System.CPUTime.Posix.Times.getCPUTime_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCyw: // global
           call System.CPUTime.Posix.Times.getCPUTime1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.309740129 UTC

[section ""relreadonly" . ScCwV_srt" {
     ScCwV_srt:
         const sat_scCw7_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$w$s$cround_closure;
         const System.CPUTime.Posix.Times.clockTicks_closure;
         const System.CPUTime.Posix.Times.getCPUTime2_closure;
         const System.CPUTime.Posix.Times.getCpuTimePrecision2_closure;
         const System.CPUTime.Posix.Times.getCpuTimePrecision1_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.divZeroError_closure;
         const System.CPUTime.Posix.Times.getCPUTime3_closure;
         const System.CPUTime.Posix.Times.getCPUTime1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.310388608 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:31.31090859 UTC

[section ""cstring" . System.CPUTime.Posix.Times.$trModule4_bytes" {
     System.CPUTime.Posix.Times.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.311505412 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule3_closure" {
     System.CPUTime.Posix.Times.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.CPUTime.Posix.Times.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.312111015 UTC

[section ""cstring" . System.CPUTime.Posix.Times.$trModule2_bytes" {
     System.CPUTime.Posix.Times.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,67,80,85,84,105,109,101,46,80,111,115,105,120,46,84,105,109,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.312686355 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule1_closure" {
     System.CPUTime.Posix.Times.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.CPUTime.Posix.Times.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.31332364 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule_closure" {
     System.CPUTime.Posix.Times.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.CPUTime.Posix.Times.$trModule3_closure+1;
         const System.CPUTime.Posix.Times.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.314154765 UTC

[section ""data" . System.CPUTime.Posix.Times.clockTicks_closure" {
     System.CPUTime.Posix.Times.clockTicks_closure:
         const System.CPUTime.Posix.Times.clockTicks_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.clockTicks_entry() //  [R1]
         { info_tbl: [(ccCyG,
                       label: System.CPUTime.Posix.Times.clockTicks_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCyG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCyH; else goto ccCyI;
       ccCyH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCyI: // global
           (_ccCyC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCyC::I64 == 0) goto ccCyE; else goto ccCyD;
       ccCyE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCyD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCyC::I64;
           (_scCw3::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] clk_tck();
           R2 = _scCw3::I64;
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.315139466 UTC

[section ""data" . sat_scCw5_closure" {
     sat_scCw5_closure:
         const GHC.Types.I#_con_info;
         const 465;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.31574475 UTC

[section ""data" . sat_scCw6_closure" {
     sat_scCw6_closure:
         const :_con_info;
         const sat_scCw5_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.316315396 UTC

[section ""data" . sat_scCw4_closure" {
     sat_scCw4_closure:
         const GHC.Types.I#_con_info;
         const 1420103680;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.316917621 UTC

[section ""data" . sat_scCw7_closure" {
     sat_scCw7_closure:
         const :_con_info;
         const sat_scCw4_closure+1;
         const sat_scCw6_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.318137029 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime2_closure" {
     System.CPUTime.Posix.Times.getCPUTime2_closure:
         const System.CPUTime.Posix.Times.getCPUTime2_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime2_entry() //  [R1]
         { info_tbl: [(ccCyP,
                       label: System.CPUTime.Posix.Times.getCPUTime2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCyP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCyQ; else goto ccCyR;
       ccCyQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCyR: // global
           (_ccCyM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCyM::I64 == 0) goto ccCyO; else goto ccCyN;
       ccCyO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCyN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCyM::I64;
           R3 = sat_scCw7_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.319358445 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision2_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision2_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision2_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision2_entry() //  [R1]
         { info_tbl: [(ccCz0,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCz0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccCz1; else goto ccCz2;
       ccCz1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCz2: // global
           (_ccCyV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCyV::I64 == 0) goto ccCyX; else goto ccCyW;
       ccCyX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCyW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCyV::I64;
           I64[Sp - 24] = block_ccCyY_info;
           R3 = System.CPUTime.Posix.Times.clockTicks_closure;
           R2 = System.CPUTime.Posix.Times.getCPUTime2_closure;
           Sp = Sp - 24;
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCyY() //  [R1, R2]
         { info_tbl: [(ccCyY,
                       label: block_ccCyY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCyY: // global
           R4 = R2;
           R3 = R1;
           R2 = GHC.Real.$fIntegralInteger_closure;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.320577521 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision1_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision1_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision1_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision1_entry() //  []
         { info_tbl: [(ccCz8,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCz8: // global
           R1 = System.CPUTime.Posix.Times.getCpuTimePrecision2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.321431609 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision_entry() //  []
         { info_tbl: [(ccCzf,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCzf: // global
           call System.CPUTime.Posix.Times.getCpuTimePrecision1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.322354286 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime3_closure" {
     System.CPUTime.Posix.Times.getCPUTime3_closure:
         const System.CPUTime.Posix.Times.getCPUTime3_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime3_entry() //  [R1]
         { info_tbl: [(ccCzo,
                       label: System.CPUTime.Posix.Times.getCPUTime3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCzo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCzp; else goto ccCzq;
       ccCzp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCzq: // global
           (_ccCzl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCzl::I64 == 0) goto ccCzn; else goto ccCzm;
       ccCzn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCzm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCzl::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.324055739 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime1_closure" {
     System.CPUTime.Posix.Times.getCPUTime1_closure:
         const System.CPUTime.Posix.Times.getCPUTime1_info;
         const 0;
 },
 sat_scCwB_entry() //  [R1]
         { info_tbl: [(ccCzP,
                       label: sat_scCwB_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCzP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCzQ; else goto ccCzR;
       ccCzQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCzR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccCzK_info;
           R3 = System.CPUTime.Posix.Times.getCPUTime3_closure;
           R2 = System.CPUTime.Posix.Times.clockTicks_closure;
           I64[Sp - 32] = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCzK() //  [R1]
         { info_tbl: [(ccCzK,
                       label: block_ccCzK_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCzK: // global
           if (R1 == 1) goto ccCzO; else goto ccCzN;
       ccCzO: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccCzN: // global
           I64[Sp] = block_ccCzU_info;
           R2 = I64[Sp + 16];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCzU() //  [R1]
         { info_tbl: [(ccCzU,
                       label: block_ccCzU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCzU: // global
           _scCwq::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_ccCzY_info;
           R2 = _scCwq::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCzY() //  [R1]
         { info_tbl: [(ccCzY,
                       label: block_ccCzY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCzY: // global
           _scCwy::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCA2_info;
           R3 = _scCwy::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCA2() //  [R1]
         { info_tbl: [(ccCA2,
                       label: block_ccCA2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCA2: // global
           I64[Sp] = block_ccCA6_info;
           R3 = System.CPUTime.Posix.Times.getCPUTime2_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCA6() //  [R1]
         { info_tbl: [(ccCA6,
                       label: block_ccCA6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCA6: // global
           R3 = System.CPUTime.Posix.Times.clockTicks_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 System.CPUTime.Posix.Times.getCPUTime1_entry() //  []
         { info_tbl: [(ccCAi,
                       label: System.CPUTime.Posix.Times.getCPUTime1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCAi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccCAj; else goto ccCAk;
       ccCAj: // global
           R1 = System.CPUTime.Posix.Times.getCPUTime1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccCAk: // global
           I64[Sp - 8] = block_ccCzv_info;
           R1 = 32;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccCzv() //  [R1]
         { info_tbl: [(ccCzv,
                       label: block_ccCzv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCzv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccCAn; else goto ccCAm;
       ccCAn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccCAm: // global
           _scCwj::I64 = R1 + 16;
           (_scCwn::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] times(_scCwj::I64);
           _scCwq::I64 = I64[_scCwj::I64];
           _scCwu::I64 = I64[_scCwj::I64 + 8];
           call MO_Touch(R1);
           I64[Hp - 24] = sat_scCwB_info;
           I64[Hp - 8] = _scCwq::I64;
           I64[Hp] = _scCwu::I64;
           R1 = Hp - 24;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.326351981 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime_closure" {
     System.CPUTime.Posix.Times.getCPUTime_closure:
         const System.CPUTime.Posix.Times.getCPUTime_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime_entry() //  []
         { info_tbl: [(ccCAs,
                       label: System.CPUTime.Posix.Times.getCPUTime_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCAs: // global
           call System.CPUTime.Posix.Times.getCPUTime1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.327084052 UTC

[section ""relreadonly" . ScCwV_srt" {
     ScCwV_srt:
         const sat_scCw7_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$w$s$cround_closure;
         const System.CPUTime.Posix.Times.clockTicks_closure;
         const System.CPUTime.Posix.Times.getCPUTime2_closure;
         const System.CPUTime.Posix.Times.getCpuTimePrecision2_closure;
         const System.CPUTime.Posix.Times.getCpuTimePrecision1_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.divZeroError_closure;
         const System.CPUTime.Posix.Times.getCPUTime3_closure;
         const System.CPUTime.Posix.Times.getCPUTime1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.327971206 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:31.330495002 UTC

[section ""cstring" . System.CPUTime.Posix.Times.$trModule4_bytes" {
     System.CPUTime.Posix.Times.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.332350941 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule3_closure" {
     System.CPUTime.Posix.Times.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.CPUTime.Posix.Times.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.334079145 UTC

[section ""cstring" . System.CPUTime.Posix.Times.$trModule2_bytes" {
     System.CPUTime.Posix.Times.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,67,80,85,84,105,109,101,46,80,111,115,105,120,46,84,105,109,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.33575326 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule1_closure" {
     System.CPUTime.Posix.Times.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.CPUTime.Posix.Times.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.337562673 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule_closure" {
     System.CPUTime.Posix.Times.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.CPUTime.Posix.Times.$trModule3_closure+1;
         const System.CPUTime.Posix.Times.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.339754098 UTC

[section ""data" . System.CPUTime.Posix.Times.clockTicks_closure" {
     System.CPUTime.Posix.Times.clockTicks_closure:
         const System.CPUTime.Posix.Times.clockTicks_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.clockTicks_entry() //  [R1]
         { info_tbl: [(ccCAH,
                       label: System.CPUTime.Posix.Times.clockTicks_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCAH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCAI; else goto ccCAJ;
       ccCAI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCAJ: // global
           (_ccCAD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCAD::I64 == 0) goto ccCAF; else goto ccCAE;
       ccCAF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCAE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCAD::I64;
           (_scCw3::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] clk_tck();
           R2 = _scCw3::I64;
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.34427563 UTC

[section ""data" . sat_scCw5_closure" {
     sat_scCw5_closure:
         const GHC.Types.I#_con_info;
         const 465;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.346042212 UTC

[section ""data" . sat_scCw6_closure" {
     sat_scCw6_closure:
         const :_con_info;
         const sat_scCw5_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.347879905 UTC

[section ""data" . sat_scCw4_closure" {
     sat_scCw4_closure:
         const GHC.Types.I#_con_info;
         const 1420103680;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.34969619 UTC

[section ""data" . sat_scCw7_closure" {
     sat_scCw7_closure:
         const :_con_info;
         const sat_scCw4_closure+1;
         const sat_scCw6_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.351858996 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime2_closure" {
     System.CPUTime.Posix.Times.getCPUTime2_closure:
         const System.CPUTime.Posix.Times.getCPUTime2_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime2_entry() //  [R1]
         { info_tbl: [(ccCB1,
                       label: System.CPUTime.Posix.Times.getCPUTime2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCB1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCB2; else goto ccCB3;
       ccCB2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCB3: // global
           (_ccCAY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCAY::I64 == 0) goto ccCB0; else goto ccCAZ;
       ccCB0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCAZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCAY::I64;
           R3 = sat_scCw7_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.356858015 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision2_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision2_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision2_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision2_entry() //  [R1]
         { info_tbl: [(ccCBj,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCBj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccCBk; else goto ccCBl;
       ccCBk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCBl: // global
           (_ccCBe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCBe::I64 == 0) goto ccCBg; else goto ccCBf;
       ccCBg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCBf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCBe::I64;
           I64[Sp - 24] = block_ccCBh_info;
           R3 = System.CPUTime.Posix.Times.clockTicks_closure;
           R2 = System.CPUTime.Posix.Times.getCPUTime2_closure;
           Sp = Sp - 24;
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCBh() //  [R1, R2]
         { info_tbl: [(ccCBh,
                       label: block_ccCBh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCBh: // global
           R4 = R2;
           R3 = R1;
           R2 = GHC.Real.$fIntegralInteger_closure;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.365771843 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision1_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision1_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision1_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision1_entry() //  []
         { info_tbl: [(ccCBB,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCBB: // global
           R1 = System.CPUTime.Posix.Times.getCpuTimePrecision2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.369962995 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision_entry() //  []
         { info_tbl: [(ccCBN,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCBN: // global
           call System.CPUTime.Posix.Times.getCpuTimePrecision1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.374227999 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime3_closure" {
     System.CPUTime.Posix.Times.getCPUTime3_closure:
         const System.CPUTime.Posix.Times.getCPUTime3_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime3_entry() //  [R1]
         { info_tbl: [(ccCC0,
                       label: System.CPUTime.Posix.Times.getCPUTime3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCC0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCC1; else goto ccCC2;
       ccCC1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCC2: // global
           (_ccCBX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCBX::I64 == 0) goto ccCBZ; else goto ccCBY;
       ccCBZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCBY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCBX::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.380427332 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime1_closure" {
     System.CPUTime.Posix.Times.getCPUTime1_closure:
         const System.CPUTime.Posix.Times.getCPUTime1_info;
         const 0;
 },
 sat_scCwB_entry() //  [R1]
         { info_tbl: [(ccCCy,
                       label: sat_scCwB_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCCy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCCz; else goto ccCCA;
       ccCCz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCCA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccCCt_info;
           R3 = System.CPUTime.Posix.Times.getCPUTime3_closure;
           R2 = System.CPUTime.Posix.Times.clockTicks_closure;
           I64[Sp - 32] = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCCt() //  [R1]
         { info_tbl: [(ccCCt,
                       label: block_ccCCt_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCCt: // global
           if (R1 == 1) goto ccCCx; else goto ccCCw;
       ccCCx: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccCCw: // global
           I64[Sp] = block_ccCCD_info;
           R2 = I64[Sp + 16];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCCD() //  [R1]
         { info_tbl: [(ccCCD,
                       label: block_ccCCD_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCCD: // global
           _scCwq::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_ccCCH_info;
           R2 = _scCwq::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCCH() //  [R1]
         { info_tbl: [(ccCCH,
                       label: block_ccCCH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCCH: // global
           _scCwy::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCCL_info;
           R3 = _scCwy::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCCL() //  [R1]
         { info_tbl: [(ccCCL,
                       label: block_ccCCL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCCL: // global
           I64[Sp] = block_ccCCP_info;
           R3 = System.CPUTime.Posix.Times.getCPUTime2_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCCP() //  [R1]
         { info_tbl: [(ccCCP,
                       label: block_ccCCP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCCP: // global
           R3 = System.CPUTime.Posix.Times.clockTicks_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 System.CPUTime.Posix.Times.getCPUTime1_entry() //  []
         { info_tbl: [(ccCD1,
                       label: System.CPUTime.Posix.Times.getCPUTime1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCD1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccCD2; else goto ccCD3;
       ccCD2: // global
           R1 = System.CPUTime.Posix.Times.getCPUTime1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccCD3: // global
           I64[Sp - 8] = block_ccCCe_info;
           R1 = 32;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccCCe() //  [R1]
         { info_tbl: [(ccCCe,
                       label: block_ccCCe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCCe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccCD6; else goto ccCD5;
       ccCD6: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccCD5: // global
           _scCwj::I64 = R1 + 16;
           (_scCwn::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] times(_scCwj::I64);
           _scCwq::I64 = I64[_scCwj::I64];
           _scCwu::I64 = I64[_scCwj::I64 + 8];
           call MO_Touch(R1);
           I64[Hp - 24] = sat_scCwB_info;
           I64[Hp - 8] = _scCwq::I64;
           I64[Hp] = _scCwu::I64;
           R1 = Hp - 24;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.400588457 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime_closure" {
     System.CPUTime.Posix.Times.getCPUTime_closure:
         const System.CPUTime.Posix.Times.getCPUTime_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime_entry() //  []
         { info_tbl: [(ccCDF,
                       label: System.CPUTime.Posix.Times.getCPUTime_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCDF: // global
           call System.CPUTime.Posix.Times.getCPUTime1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.40459677 UTC

[section ""relreadonly" . ScCwV_srt" {
     ScCwV_srt:
         const sat_scCw7_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$w$s$cround_closure;
         const System.CPUTime.Posix.Times.clockTicks_closure;
         const System.CPUTime.Posix.Times.getCPUTime2_closure;
         const System.CPUTime.Posix.Times.getCpuTimePrecision2_closure;
         const System.CPUTime.Posix.Times.getCpuTimePrecision1_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.divZeroError_closure;
         const System.CPUTime.Posix.Times.getCPUTime3_closure;
         const System.CPUTime.Posix.Times.getCPUTime1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.494437925 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:07:31.495543769 UTC

[section ""cstring" . System.CPUTime.Posix.Times.$trModule4_bytes" {
     System.CPUTime.Posix.Times.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.497507477 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule3_closure" {
     System.CPUTime.Posix.Times.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const System.CPUTime.Posix.Times.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.499364933 UTC

[section ""cstring" . System.CPUTime.Posix.Times.$trModule2_bytes" {
     System.CPUTime.Posix.Times.$trModule2_bytes:
         I8[] [83,121,115,116,101,109,46,67,80,85,84,105,109,101,46,80,111,115,105,120,46,84,105,109,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.501169129 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule1_closure" {
     System.CPUTime.Posix.Times.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const System.CPUTime.Posix.Times.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.503054403 UTC

[section ""data" . System.CPUTime.Posix.Times.$trModule_closure" {
     System.CPUTime.Posix.Times.$trModule_closure:
         const GHC.Types.Module_con_info;
         const System.CPUTime.Posix.Times.$trModule3_closure+1;
         const System.CPUTime.Posix.Times.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.505536414 UTC

[section ""data" . System.CPUTime.Posix.Times.clockTicks_closure" {
     System.CPUTime.Posix.Times.clockTicks_closure:
         const System.CPUTime.Posix.Times.clockTicks_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.clockTicks_entry() //  [R1]
         { info_tbl: [(ccCEB,
                       label: System.CPUTime.Posix.Times.clockTicks_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCEB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCEC; else goto ccCED;
       ccCEC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCED: // global
           (_ccCEx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCEx::I64 == 0) goto ccCEz; else goto ccCEy;
       ccCEz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCEy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCEx::I64;
           (_scCDQ::I64) = call "ccall" arg hints:  []  result hints:  [‘signed’] clk_tck();
           R2 = _scCDQ::I64;
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.510301922 UTC

[section ""data" . sat_scCDS_closure" {
     sat_scCDS_closure:
         const GHC.Types.I#_con_info;
         const 465;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.512262854 UTC

[section ""data" . sat_scCDT_closure" {
     sat_scCDT_closure:
         const :_con_info;
         const sat_scCDS_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.514376903 UTC

[section ""data" . sat_scCDR_closure" {
     sat_scCDR_closure:
         const GHC.Types.I#_con_info;
         const 1420103680;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.516271875 UTC

[section ""data" . sat_scCDU_closure" {
     sat_scCDU_closure:
         const :_con_info;
         const sat_scCDR_closure+1;
         const sat_scCDT_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.518664789 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime2_closure" {
     System.CPUTime.Posix.Times.getCPUTime2_closure:
         const System.CPUTime.Posix.Times.getCPUTime2_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime2_entry() //  [R1]
         { info_tbl: [(ccCEW,
                       label: System.CPUTime.Posix.Times.getCPUTime2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCEW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCEX; else goto ccCEY;
       ccCEX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCEY: // global
           (_ccCET::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCET::I64 == 0) goto ccCEV; else goto ccCEU;
       ccCEV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCEU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCET::I64;
           R3 = sat_scCDU_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.524597078 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision2_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision2_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision2_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision2_entry() //  [R1]
         { info_tbl: [(ccCFh,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCFh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccCFi; else goto ccCFj;
       ccCFi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCFj: // global
           (_ccCFc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCFc::I64 == 0) goto ccCFe; else goto ccCFd;
       ccCFe: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCFd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCFc::I64;
           I64[Sp - 24] = block_ccCFf_info;
           R3 = System.CPUTime.Posix.Times.clockTicks_closure;
           R2 = System.CPUTime.Posix.Times.getCPUTime2_closure;
           Sp = Sp - 24;
           call GHC.Real.$w$s$cfromRational_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCFf() //  [R1, R2]
         { info_tbl: [(ccCFf,
                       label: block_ccCFf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCFf: // global
           R4 = R2;
           R3 = R1;
           R2 = GHC.Real.$fIntegralInteger_closure;
           Sp = Sp + 8;
           call GHC.Real.$w$s$cround_entry(R4,
                                           R3,
                                           R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.532109083 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision1_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision1_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision1_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision1_entry() //  []
         { info_tbl: [(ccCFB,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCFB: // global
           R1 = System.CPUTime.Posix.Times.getCpuTimePrecision2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.535913483 UTC

[section ""data" . System.CPUTime.Posix.Times.getCpuTimePrecision_closure" {
     System.CPUTime.Posix.Times.getCpuTimePrecision_closure:
         const System.CPUTime.Posix.Times.getCpuTimePrecision_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCpuTimePrecision_entry() //  []
         { info_tbl: [(ccCFN,
                       label: System.CPUTime.Posix.Times.getCpuTimePrecision_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCFN: // global
           call System.CPUTime.Posix.Times.getCpuTimePrecision1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.539711375 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime3_closure" {
     System.CPUTime.Posix.Times.getCPUTime3_closure:
         const System.CPUTime.Posix.Times.getCPUTime3_info;
         const 0;
         const 0;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime3_entry() //  [R1]
         { info_tbl: [(ccCG0,
                       label: System.CPUTime.Posix.Times.getCPUTime3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCG0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccCG1; else goto ccCG2;
       ccCG1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCG2: // global
           (_ccCFX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccCFX::I64 == 0) goto ccCFZ; else goto ccCFY;
       ccCFZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccCFY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccCFX::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.544952996 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime1_closure" {
     System.CPUTime.Posix.Times.getCPUTime1_closure:
         const System.CPUTime.Posix.Times.getCPUTime1_info;
         const 0;
 },
 sat_scCEo_entry() //  [R1]
         { info_tbl: [(ccCGB,
                       label: sat_scCEo_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCGB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ccCGC; else goto ccCGD;
       ccCGC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccCGD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ccCGw_info;
           R3 = System.CPUTime.Posix.Times.getCPUTime3_closure;
           R2 = System.CPUTime.Posix.Times.clockTicks_closure;
           I64[Sp - 32] = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCGw() //  [R1]
         { info_tbl: [(ccCGw,
                       label: block_ccCGw_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCGw: // global
           if (R1 == 1) goto ccCGA; else goto ccCGz;
       ccCGA: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       ccCGz: // global
           I64[Sp] = block_ccCGG_info;
           R2 = I64[Sp + 16];
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCGG() //  [R1]
         { info_tbl: [(ccCGG,
                       label: block_ccCGG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCGG: // global
           _scCEd::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_ccCGK_info;
           R2 = _scCEd::I64;
           P64[Sp + 16] = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCGK() //  [R1]
         { info_tbl: [(ccCGK,
                       label: block_ccCGK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCGK: // global
           _scCEl::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ccCGO_info;
           R3 = _scCEl::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCGO() //  [R1]
         { info_tbl: [(ccCGO,
                       label: block_ccCGO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCGO: // global
           I64[Sp] = block_ccCGS_info;
           R3 = System.CPUTime.Posix.Times.getCPUTime2_closure;
           R2 = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 24;
     }
 },
 _ccCGS() //  [R1]
         { info_tbl: [(ccCGS,
                       label: block_ccCGS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCGS: // global
           R3 = System.CPUTime.Posix.Times.clockTicks_closure;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.divInteger_entry(R3,
                                                  R2) args: 24, res: 0, upd: 24;
     }
 },
 System.CPUTime.Posix.Times.getCPUTime1_entry() //  []
         { info_tbl: [(ccCH4,
                       label: System.CPUTime.Posix.Times.getCPUTime1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCH4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccCH5; else goto ccCH6;
       ccCH5: // global
           R1 = System.CPUTime.Posix.Times.getCPUTime1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ccCH6: // global
           I64[Sp - 8] = block_ccCGh_info;
           R1 = 32;
           Sp = Sp - 8;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ccCGh() //  [R1]
         { info_tbl: [(ccCGh,
                       label: block_ccCGh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCGh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ccCH9; else goto ccCH8;
       ccCH9: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccCH8: // global
           _scCE6::I64 = R1 + 16;
           (_scCEa::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [‘signed’] times(_scCE6::I64);
           _scCEd::I64 = I64[_scCE6::I64];
           _scCEh::I64 = I64[_scCE6::I64 + 8];
           call MO_Touch(R1);
           I64[Hp - 24] = sat_scCEo_info;
           I64[Hp - 8] = _scCEd::I64;
           I64[Hp] = _scCEh::I64;
           R1 = Hp - 24;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.566619596 UTC

[section ""data" . System.CPUTime.Posix.Times.getCPUTime_closure" {
     System.CPUTime.Posix.Times.getCPUTime_closure:
         const System.CPUTime.Posix.Times.getCPUTime_info;
         const 0;
 },
 System.CPUTime.Posix.Times.getCPUTime_entry() //  []
         { info_tbl: [(ccCHQ,
                       label: System.CPUTime.Posix.Times.getCPUTime_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       ccCHQ: // global
           call System.CPUTime.Posix.Times.getCPUTime1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:07:31.571806954 UTC

[section ""relreadonly" . ScCEZ_srt" {
     ScCEZ_srt:
         const sat_scCDU_closure;
         const GHC.Real.$fIntegralInteger_closure;
         const GHC.Real.$w$s$cfromRational_closure;
         const GHC.Real.$w$s$cround_closure;
         const System.CPUTime.Posix.Times.clockTicks_closure;
         const System.CPUTime.Posix.Times.getCPUTime2_closure;
         const System.CPUTime.Posix.Times.getCpuTimePrecision2_closure;
         const System.CPUTime.Posix.Times.getCpuTimePrecision1_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Integer.Type.divInteger_closure;
         const GHC.Real.divZeroError_closure;
         const System.CPUTime.Posix.Times.getCPUTime3_closure;
         const System.CPUTime.Posix.Times.getCPUTime1_closure;
 }]

