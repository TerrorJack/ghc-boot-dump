
==================== Tidy Core ====================
2018-03-16 15:59:45.72905596 UTC

Result size of Tidy Core
  = {terms: 355, types: 189, coercions: 1,058, joins: 0/0}

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.Ptr.$fShowIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Show IntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: IntPtr
                       showSignedInt
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int -> [Char] -> [Char] :: *)
                                  ~R# (Int -> IntPtr -> [Char] -> [Char] :: *))
                       GHC.Show.$fShowInt_$cshow
                       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <[Char]>_R
                               :: (Int -> [Char] :: *) ~R# (IntPtr -> [Char] :: *))
                       GHC.Show.$fShowInt_$cshowList
                       `cast` (([Sym (Foreign.Ptr.N:IntPtr[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int] -> [Char] -> [Char] :: *)
                                  ~R# ([IntPtr] -> [Char] -> [Char] :: *))]
Foreign.Ptr.$fShowIntPtr
  = GHC.Show.C:Show
      @ IntPtr
      (showSignedInt
       `cast` (<Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int -> [Char] -> [Char] :: *)
                  ~R# (Int -> IntPtr -> [Char] -> [Char] :: *)))
      (GHC.Show.$fShowInt_$cshow
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <[Char]>_R
               :: (Int -> [Char] :: *) ~R# (IntPtr -> [Char] :: *)))
      (GHC.Show.$fShowInt_$cshowList
       `cast` (([Sym (Foreign.Ptr.N:IntPtr[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int] -> [Char] -> [Char] :: *)
                  ~R# ([IntPtr] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 34, joins: 0/0}
Foreign.Ptr.$fReadIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Read IntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: IntPtr
                       GHC.Read.$fReadInt_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.Ptr.N:IntPtr[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(IntPtr, [Char])] :: *))
                       GHC.Read.$fReadInt_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,) ([Sym (Foreign.Ptr.N:IntPtr[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int], [Char])] :: *)
                                  ~R# ([Char] -> [([IntPtr], [Char])] :: *))
                       GHC.Read.$fReadInt1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                   (Foreign.Ptr.N:IntPtr[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec IntPtr :: *))
                       GHC.Read.$fReadInt_$creadListPrec
                       `cast` ((Text.ParserCombinators.ReadPrec.ReadPrec
                                  ([Sym (Foreign.Ptr.N:IntPtr[0])])_R)_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Int] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [IntPtr] :: *))]
Foreign.Ptr.$fReadIntPtr
  = GHC.Read.C:Read
      @ IntPtr
      (GHC.Read.$fReadInt_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.Ptr.N:IntPtr[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(IntPtr, [Char])] :: *)))
      (GHC.Read.$fReadInt_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,) ([Sym (Foreign.Ptr.N:IntPtr[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int], [Char])] :: *)
                  ~R# ([Char] -> [([IntPtr], [Char])] :: *)))
      (GHC.Read.$fReadInt1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                   (Foreign.Ptr.N:IntPtr[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec IntPtr :: *)))
      (GHC.Read.$fReadInt_$creadListPrec
       `cast` ((Text.ParserCombinators.ReadPrec.ReadPrec
                  ([Sym (Foreign.Ptr.N:IntPtr[0])])_R)_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Int] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [IntPtr] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.Ptr.$fBoundedIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded IntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: IntPtr
                          minInt
                          `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                  :: (Int :: *) ~R# (IntPtr :: *))
                          maxInt
                          `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                  :: (Int :: *) ~R# (IntPtr :: *))]
Foreign.Ptr.$fBoundedIntPtr
  = GHC.Enum.C:Bounded
      @ IntPtr
      (minInt
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int :: *) ~R# (IntPtr :: *)))
      (maxInt
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int :: *) ~R# (IntPtr :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.Ptr.$fStorableIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable IntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: IntPtr
                                   Foreign.Storable.$fStorableInt_$calignment
                                   `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
                                           :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *))
                                   Foreign.Storable.$fStorableInt_$calignment
                                   `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
                                           :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *))
                                   GHC.Storable.readIntOffPtr1
                                   `cast` ((Ptr Univ(phantom phantom <*>_N :: Int, IntPtr))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:IntPtr[0]))
                                           :: (Ptr Int
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int #) :: *)
                                              ~R# (Ptr IntPtr -> Int -> IO IntPtr :: *))
                                   GHC.Storable.writeIntOffPtr1
                                   `cast` ((Ptr Univ(phantom phantom <*>_N :: Int, IntPtr))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int
                                               -> Int
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr IntPtr -> Int -> IntPtr -> IO () :: *))
                                   Foreign.Storable.$fStorableInt4
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:IntPtr[0]))
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO IntPtr :: *))
                                   Foreign.Storable.$fStorableInt3
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IntPtr -> IO () :: *))
                                   Foreign.Storable.$fStorableInt2
                                   `cast` ((Ptr Univ(phantom phantom <*>_N :: Int, IntPtr))_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:IntPtr[0]))
                                           :: (Ptr Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int #) :: *)
                                              ~R# (Ptr IntPtr -> IO IntPtr :: *))
                                   Foreign.Storable.$fStorableInt1
                                   `cast` ((Ptr Univ(phantom phantom <*>_N :: Int, IntPtr))_R
                                           ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr IntPtr -> IntPtr -> IO () :: *))]
Foreign.Ptr.$fStorableIntPtr
  = Foreign.Storable.C:Storable
      @ IntPtr
      (Foreign.Storable.$fStorableInt_$calignment
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
               :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *)))
      (Foreign.Storable.$fStorableInt_$calignment
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
               :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *)))
      (GHC.Storable.readIntOffPtr1
       `cast` ((Ptr Univ(phantom phantom <*>_N :: Int, IntPtr))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:IntPtr[0]))
               :: (Ptr Int
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int #) :: *)
                  ~R# (Ptr IntPtr -> Int -> IO IntPtr :: *)))
      (GHC.Storable.writeIntOffPtr1
       `cast` ((Ptr Univ(phantom phantom <*>_N :: Int, IntPtr))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int
                   -> Int
                   -> Int
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr IntPtr -> Int -> IntPtr -> IO () :: *)))
      (Foreign.Storable.$fStorableInt4
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:IntPtr[0]))
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO IntPtr :: *)))
      (Foreign.Storable.$fStorableInt3
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Int
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IntPtr -> IO () :: *)))
      (Foreign.Storable.$fStorableInt2
       `cast` ((Ptr Univ(phantom phantom <*>_N :: Int, IntPtr))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:IntPtr[0]))
               :: (Ptr Int
                   -> State# RealWorld -> (# State# RealWorld, Int #) :: *)
                  ~R# (Ptr IntPtr -> IO IntPtr :: *)))
      (Foreign.Storable.$fStorableInt1
       `cast` ((Ptr Univ(phantom phantom <*>_N :: Int, IntPtr))_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int
                   -> Int -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr IntPtr -> IntPtr -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.Ptr.$fEnumIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum IntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: IntPtr
                       GHC.Enum.$fEnumInt_$csucc
                       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                               :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *))
                       GHC.Enum.$fEnumInt_$cpred
                       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                               :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *))
                       GHC.Enum.$fEnumInt_$cfromEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                               :: (Int -> Int :: *) ~R# (Int -> IntPtr :: *))
                       GHC.Enum.$fEnumInt_$cfromEnum
                       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
                               :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *))
                       GHC.Enum.$fEnumInt_$cenumFrom
                       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R ([Sym (Foreign.Ptr.N:IntPtr[0])])_R
                               :: (Int -> [Int] :: *) ~R# (IntPtr -> [IntPtr] :: *))
                       GHC.Enum.$fEnumInt_$cenumFromThen
                       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R ([Sym (Foreign.Ptr.N:IntPtr[0])])_R
                               :: (Int -> Int -> [Int] :: *)
                                  ~R# (IntPtr -> IntPtr -> [IntPtr] :: *))
                       GHC.Enum.$fEnumInt_$cenumFromTo
                       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R ([Sym (Foreign.Ptr.N:IntPtr[0])])_R
                               :: (Int -> Int -> [Int] :: *)
                                  ~R# (IntPtr -> IntPtr -> [IntPtr] :: *))
                       GHC.Enum.$fEnumInt_$cenumFromThenTo
                       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                               ->_R ([Sym (Foreign.Ptr.N:IntPtr[0])])_R
                               :: (Int -> Int -> Int -> [Int] :: *)
                                  ~R# (IntPtr -> IntPtr -> IntPtr -> [IntPtr] :: *))]
Foreign.Ptr.$fEnumIntPtr
  = GHC.Enum.C:Enum
      @ IntPtr
      (GHC.Enum.$fEnumInt_$csucc
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *)))
      (GHC.Enum.$fEnumInt_$cpred
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *)))
      (GHC.Enum.$fEnumInt_$cfromEnum
       `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int :: *) ~R# (Int -> IntPtr :: *)))
      (GHC.Enum.$fEnumInt_$cfromEnum
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
               :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *)))
      (GHC.Enum.$fEnumInt_$cenumFrom
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R ([Sym (Foreign.Ptr.N:IntPtr[0])])_R
               :: (Int -> [Int] :: *) ~R# (IntPtr -> [IntPtr] :: *)))
      (GHC.Enum.$fEnumInt_$cenumFromThen
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R ([Sym (Foreign.Ptr.N:IntPtr[0])])_R
               :: (Int -> Int -> [Int] :: *)
                  ~R# (IntPtr -> IntPtr -> [IntPtr] :: *)))
      (GHC.Enum.$fEnumInt_$cenumFromTo
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R ([Sym (Foreign.Ptr.N:IntPtr[0])])_R
               :: (Int -> Int -> [Int] :: *)
                  ~R# (IntPtr -> IntPtr -> [IntPtr] :: *)))
      (GHC.Enum.$fEnumInt_$cenumFromThenTo
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R ([Sym (Foreign.Ptr.N:IntPtr[0])])_R
               :: (Int -> Int -> Int -> [Int] :: *)
                  ~R# (IntPtr -> IntPtr -> IntPtr -> [IntPtr] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.Ptr.$fNumIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Num IntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: IntPtr
                     GHC.Num.$fNumInt_$c+
                     `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                             ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                             ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                             :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                     GHC.Num.$fNumInt_$c-
                     `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                             ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                             ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                             :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                     GHC.Num.$fNumInt_$c*
                     `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                             ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                             ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                             :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                     GHC.Num.$fNumInt_$cnegate
                     `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                             ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                             :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *))
                     GHC.Num.$fNumInt_$cabs
                     `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                             ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                             :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *))
                     GHC.Num.$fNumInt_$csignum
                     `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                             ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                             :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *))
                     GHC.Num.$fNumInt_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                             :: (Integer -> Int :: *) ~R# (Integer -> IntPtr :: *))]
Foreign.Ptr.$fNumIntPtr
  = GHC.Num.C:Num
      @ IntPtr
      (GHC.Num.$fNumInt_$c+
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (GHC.Num.$fNumInt_$c-
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (GHC.Num.$fNumInt_$c*
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (GHC.Num.$fNumInt_$cnegate
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *)))
      (GHC.Num.$fNumInt_$cabs
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *)))
      (GHC.Num.$fNumInt_$csignum
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *)))
      (GHC.Num.$fNumInt_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Integer -> Int :: *) ~R# (Integer -> IntPtr :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.Ptr.$fEqIntPtr [InlPrag=NOUSERINLINE CONLIKE] :: Eq IntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: IntPtr
                        eqInt
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Bool>_R
                                :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *))
                        neInt
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Bool>_R
                                :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *))]
Foreign.Ptr.$fEqIntPtr
  = GHC.Classes.C:Eq
      @ IntPtr
      (eqInt
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Bool>_R
               :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *)))
      (neInt
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Bool>_R
               :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.Ptr.$fOrdIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord IntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: IntPtr
                         Foreign.Ptr.$fEqIntPtr
                         compareInt
                         `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R <Ordering>_R
                                 :: (Int -> Int -> Ordering :: *)
                                    ~R# (IntPtr -> IntPtr -> Ordering :: *))
                         ltInt
                         `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *))
                         leInt
                         `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *))
                         gtInt
                         `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *))
                         geInt
                         `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *))
                         GHC.Classes.$fOrdInt_$cmax
                         `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                 :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                         GHC.Classes.$fOrdInt_$cmin
                         `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                 :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *))]
Foreign.Ptr.$fOrdIntPtr
  = GHC.Classes.C:Ord
      @ IntPtr
      Foreign.Ptr.$fEqIntPtr
      (compareInt
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Ordering>_R
               :: (Int -> Int -> Ordering :: *)
                  ~R# (IntPtr -> IntPtr -> Ordering :: *)))
      (ltInt
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Bool>_R
               :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *)))
      (leInt
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Bool>_R
               :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *)))
      (gtInt
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Bool>_R
               :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *)))
      (geInt
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Bool>_R
               :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> IntPtr -> Bool :: *)))
      (GHC.Classes.$fOrdInt_$cmax
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (GHC.Classes.$fOrdInt_$cmin
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.Ptr.$fRealIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Real IntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: IntPtr
                       Foreign.Ptr.$fNumIntPtr
                       Foreign.Ptr.$fOrdIntPtr
                       GHC.Real.$fEnumRatio_$ctoRational
                       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Ratio Integer>_R
                               :: (Int -> Ratio Integer :: *) ~R# (IntPtr -> Ratio Integer :: *))]
Foreign.Ptr.$fRealIntPtr
  = GHC.Real.C:Real
      @ IntPtr
      Foreign.Ptr.$fNumIntPtr
      Foreign.Ptr.$fOrdIntPtr
      (GHC.Real.$fEnumRatio_$ctoRational
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Ratio Integer>_R
               :: (Int -> Ratio Integer :: *) ~R# (IntPtr -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.Ptr.$fIntegralIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral IntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: IntPtr
                           Foreign.Ptr.$fRealIntPtr
                           Foreign.Ptr.$fEnumIntPtr
                           GHC.Real.$fIntegralInt_$cquot
                           `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                   :: (Int -> Int -> Int :: *)
                                      ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                           GHC.Real.$fIntegralInt_$crem
                           `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                   :: (Int -> Int -> Int :: *)
                                      ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                           GHC.Real.$fIntegralInt_$cdiv
                           `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                   :: (Int -> Int -> Int :: *)
                                      ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                           GHC.Real.$fIntegralInt_$cmod
                           `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                   :: (Int -> Int -> Int :: *)
                                      ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                           GHC.Real.$fIntegralInt_$cquotRem
                           `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R ((,)
                                           (Sym (Foreign.Ptr.N:IntPtr[0]))
                                           (Sym (Foreign.Ptr.N:IntPtr[0])))_R
                                   :: (Int -> Int -> (Int, Int) :: *)
                                      ~R# (IntPtr -> IntPtr -> (IntPtr, IntPtr) :: *))
                           GHC.Real.$fIntegralInt_$cdivMod
                           `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                   ->_R ((,)
                                           (Sym (Foreign.Ptr.N:IntPtr[0]))
                                           (Sym (Foreign.Ptr.N:IntPtr[0])))_R
                                   :: (Int -> Int -> (Int, Int) :: *)
                                      ~R# (IntPtr -> IntPtr -> (IntPtr, IntPtr) :: *))
                           GHC.Real.$fIntegralInt_$ctoInteger
                           `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Integer>_R
                                   :: (Int -> Integer :: *) ~R# (IntPtr -> Integer :: *))]
Foreign.Ptr.$fIntegralIntPtr
  = GHC.Real.C:Integral
      @ IntPtr
      Foreign.Ptr.$fRealIntPtr
      Foreign.Ptr.$fEnumIntPtr
      (GHC.Real.$fIntegralInt_$cquot
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (GHC.Real.$fIntegralInt_$crem
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (GHC.Real.$fIntegralInt_$cdiv
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (GHC.Real.$fIntegralInt_$cmod
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (GHC.Real.$fIntegralInt_$cquotRem
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R ((,)
                       (Sym (Foreign.Ptr.N:IntPtr[0])) (Sym (Foreign.Ptr.N:IntPtr[0])))_R
               :: (Int -> Int -> (Int, Int) :: *)
                  ~R# (IntPtr -> IntPtr -> (IntPtr, IntPtr) :: *)))
      (GHC.Real.$fIntegralInt_$cdivMod
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R ((,)
                       (Sym (Foreign.Ptr.N:IntPtr[0])) (Sym (Foreign.Ptr.N:IntPtr[0])))_R
               :: (Int -> Int -> (Int, Int) :: *)
                  ~R# (IntPtr -> IntPtr -> (IntPtr, IntPtr) :: *)))
      (GHC.Real.$fIntegralInt_$ctoInteger
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Integer>_R
               :: (Int -> Integer :: *) ~R# (IntPtr -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.Ptr.$fBitsIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits IntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: IntPtr
                        Foreign.Ptr.$fEqIntPtr
                        Data.Bits.$fBitsInt_$c.&.
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$c.|.
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$cxor
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$ccomplement
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$cshift
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$crotate
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsBool2
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int :: *) ~R# (IntPtr :: *))
                        Data.Bits.$fBitsInt_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int :: *) ~R# (Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$csetBit
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$cclearBit
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$ccomplementBit
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$ctestBit
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int -> Bool>_R
                                :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> Int -> Bool :: *))
                        Data.Bits.$fBitsInt_$cbitSizeMaybe
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Maybe Int>_R
                                :: (Int -> Maybe Int :: *) ~R# (IntPtr -> Maybe Int :: *))
                        Data.Bits.$fBitsInt_$cfiniteBitSize
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
                                :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *))
                        Data.Bits.$fBitsInt_$cisSigned
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Bool>_R
                                :: (Int -> Bool :: *) ~R# (IntPtr -> Bool :: *))
                        Data.Bits.$fBitsInt_$cshiftL
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$cunsafeShiftL
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$cshiftR
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$cunsafeShiftR
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$crotateL
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$crotateR
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:IntPtr[0])
                                :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *))
                        Data.Bits.$fBitsInt_$cpopCount
                        `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
                                :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *))]
Foreign.Ptr.$fBitsIntPtr
  = Data.Bits.C:Bits
      @ IntPtr
      Foreign.Ptr.$fEqIntPtr
      (Data.Bits.$fBitsInt_$c.&.
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$c.|.
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$cxor
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> IntPtr -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$ccomplement
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int :: *) ~R# (IntPtr -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$cshift
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$crotate
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsBool2
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int :: *) ~R# (IntPtr :: *)))
      (Data.Bits.$fBitsInt_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int :: *) ~R# (Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$csetBit
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$cclearBit
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$ccomplementBit
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$ctestBit
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int -> Bool>_R
               :: (Int -> Int -> Bool :: *) ~R# (IntPtr -> Int -> Bool :: *)))
      (Data.Bits.$fBitsInt_$cbitSizeMaybe
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Maybe Int>_R
               :: (Int -> Maybe Int :: *) ~R# (IntPtr -> Maybe Int :: *)))
      (Data.Bits.$fBitsInt_$cfiniteBitSize
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
               :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *)))
      (Data.Bits.$fBitsInt_$cisSigned
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Bool>_R
               :: (Int -> Bool :: *) ~R# (IntPtr -> Bool :: *)))
      (Data.Bits.$fBitsInt_$cshiftL
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$cunsafeShiftL
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$cshiftR
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$cunsafeShiftR
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$crotateL
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$crotateR
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:IntPtr[0])
               :: (Int -> Int -> Int :: *) ~R# (IntPtr -> Int -> IntPtr :: *)))
      (Data.Bits.$fBitsInt_$cpopCount
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
               :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.Ptr.$fFiniteBitsIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits IntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: IntPtr
                              Foreign.Ptr.$fBitsIntPtr
                              Data.Bits.$fBitsInt_$cfiniteBitSize
                              `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
                                      :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *))
                              Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
                              `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
                                      :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *))
                              Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros
                              `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
                                      :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *))]
Foreign.Ptr.$fFiniteBitsIntPtr
  = Data.Bits.C:FiniteBits
      @ IntPtr
      Foreign.Ptr.$fBitsIntPtr
      (Data.Bits.$fBitsInt_$cfiniteBitSize
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
               :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *)))
      (Data.Bits.$fFiniteBitsInt_$ccountLeadingZeros
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
               :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *)))
      (Data.Bits.$fFiniteBitsInt_$ccountTrailingZeros
       `cast` (Sym (Foreign.Ptr.N:IntPtr[0]) ->_R <Int>_R
               :: (Int -> Int :: *) ~R# (IntPtr -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.Ptr.$fShowWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Show WordPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: WordPtr
                       GHC.Show.$fShowWord_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word -> [Char] -> [Char] :: *)
                                  ~R# (Int -> WordPtr -> [Char] -> [Char] :: *))
                       GHC.Show.$fShowWord_$cshow
                       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <[Char]>_R
                               :: (Word -> [Char] :: *) ~R# (WordPtr -> [Char] :: *))
                       GHC.Show.$fShowWord_$cshowList
                       `cast` (([Sym (Foreign.Ptr.N:WordPtr[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word] -> [Char] -> [Char] :: *)
                                  ~R# ([WordPtr] -> [Char] -> [Char] :: *))]
Foreign.Ptr.$fShowWordPtr
  = GHC.Show.C:Show
      @ WordPtr
      (GHC.Show.$fShowWord_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word -> [Char] -> [Char] :: *)
                  ~R# (Int -> WordPtr -> [Char] -> [Char] :: *)))
      (GHC.Show.$fShowWord_$cshow
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <[Char]>_R
               :: (Word -> [Char] :: *) ~R# (WordPtr -> [Char] :: *)))
      (GHC.Show.$fShowWord_$cshowList
       `cast` (([Sym (Foreign.Ptr.N:WordPtr[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word] -> [Char] -> [Char] :: *)
                  ~R# ([WordPtr] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.Ptr.$fReadWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Read WordPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: WordPtr
                       GHC.Read.$fReadWord_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.Ptr.N:WordPtr[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(WordPtr, [Char])] :: *))
                       GHC.Read.$fReadWord_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,) ([Sym (Foreign.Ptr.N:WordPtr[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word], [Char])] :: *)
                                  ~R# ([Char] -> [([WordPtr], [Char])] :: *))
                       GHC.Read.$fReadWord3
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                    (Foreign.Ptr.N:WordPtr[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec WordPtr :: *))
                       GHC.Read.$fReadWord1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      ([Foreign.Ptr.N:WordPtr[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [WordPtr] :: *))]
Foreign.Ptr.$fReadWordPtr
  = GHC.Read.C:Read
      @ WordPtr
      (GHC.Read.$fReadWord_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.Ptr.N:WordPtr[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(WordPtr, [Char])] :: *)))
      (GHC.Read.$fReadWord_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,) ([Sym (Foreign.Ptr.N:WordPtr[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word], [Char])] :: *)
                  ~R# ([Char] -> [([WordPtr], [Char])] :: *)))
      (GHC.Read.$fReadWord3
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                    (Foreign.Ptr.N:WordPtr[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec WordPtr :: *)))
      (GHC.Read.$fReadWord1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      ([Foreign.Ptr.N:WordPtr[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [WordPtr] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.Ptr.$fBoundedWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded WordPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: WordPtr
                          GHC.Enum.$fBoundedWord_$cminBound
                          `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                  :: (Word :: *) ~R# (WordPtr :: *))
                          GHC.Enum.$fBoundedWord_$cmaxBound
                          `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                  :: (Word :: *) ~R# (WordPtr :: *))]
Foreign.Ptr.$fBoundedWordPtr
  = GHC.Enum.C:Bounded
      @ WordPtr
      (GHC.Enum.$fBoundedWord_$cminBound
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word :: *) ~R# (WordPtr :: *)))
      (GHC.Enum.$fBoundedWord_$cmaxBound
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word :: *) ~R# (WordPtr :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.Ptr.$fStorableWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable WordPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: WordPtr
                                   Foreign.Storable.$fStorableWord_$calignment
                                   `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
                                           :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *))
                                   Foreign.Storable.$fStorableWord_$calignment
                                   `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
                                           :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *))
                                   GHC.Storable.readWordOffPtr1
                                   `cast` ((Ptr Univ(phantom phantom <*>_N :: Word, WordPtr))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:WordPtr[0]))
                                           :: (Ptr Word
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word #) :: *)
                                              ~R# (Ptr WordPtr -> Int -> IO WordPtr :: *))
                                   GHC.Storable.writeWordOffPtr1
                                   `cast` ((Ptr Univ(phantom phantom <*>_N :: Word, WordPtr))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word
                                               -> Int
                                               -> Word
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr WordPtr -> Int -> WordPtr -> IO () :: *))
                                   Foreign.Storable.$fStorableWord4
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:WordPtr[0]))
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO WordPtr :: *))
                                   Foreign.Storable.$fStorableWord3
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Word
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> WordPtr -> IO () :: *))
                                   Foreign.Storable.$fStorableWord2
                                   `cast` ((Ptr Univ(phantom phantom <*>_N :: Word, WordPtr))_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:WordPtr[0]))
                                           :: (Ptr Word
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word #) :: *)
                                              ~R# (Ptr WordPtr -> IO WordPtr :: *))
                                   Foreign.Storable.$fStorableWord1
                                   `cast` ((Ptr Univ(phantom phantom <*>_N :: Word, WordPtr))_R
                                           ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word
                                               -> Word
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr WordPtr -> WordPtr -> IO () :: *))]
Foreign.Ptr.$fStorableWordPtr
  = Foreign.Storable.C:Storable
      @ WordPtr
      (Foreign.Storable.$fStorableWord_$calignment
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
               :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *)))
      (Foreign.Storable.$fStorableWord_$calignment
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
               :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *)))
      (GHC.Storable.readWordOffPtr1
       `cast` ((Ptr Univ(phantom phantom <*>_N :: Word, WordPtr))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:WordPtr[0]))
               :: (Ptr Word
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word #) :: *)
                  ~R# (Ptr WordPtr -> Int -> IO WordPtr :: *)))
      (GHC.Storable.writeWordOffPtr1
       `cast` ((Ptr Univ(phantom phantom <*>_N :: Word, WordPtr))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word
                   -> Int
                   -> Word
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr WordPtr -> Int -> WordPtr -> IO () :: *)))
      (Foreign.Storable.$fStorableWord4
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:WordPtr[0]))
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO WordPtr :: *)))
      (Foreign.Storable.$fStorableWord3
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Word
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> WordPtr -> IO () :: *)))
      (Foreign.Storable.$fStorableWord2
       `cast` ((Ptr Univ(phantom phantom <*>_N :: Word, WordPtr))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.Ptr.N:WordPtr[0]))
               :: (Ptr Word
                   -> State# RealWorld -> (# State# RealWorld, Word #) :: *)
                  ~R# (Ptr WordPtr -> IO WordPtr :: *)))
      (Foreign.Storable.$fStorableWord1
       `cast` ((Ptr Univ(phantom phantom <*>_N :: Word, WordPtr))_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word
                   -> Word -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr WordPtr -> WordPtr -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.Ptr.$fEnumWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum WordPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: WordPtr
                       GHC.Enum.$fEnumWord_$csucc
                       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                               :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *))
                       GHC.Enum.$fEnumWord_$cpred
                       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                               :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *))
                       GHC.Enum.$fEnumWord_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                               :: (Int -> Word :: *) ~R# (Int -> WordPtr :: *))
                       GHC.Enum.$fEnumWord_$cfromEnum
                       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
                               :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *))
                       GHC.Enum.$fEnumWord_$cenumFrom
                       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R ([Sym (Foreign.Ptr.N:WordPtr[0])])_R
                               :: (Word -> [Word] :: *) ~R# (WordPtr -> [WordPtr] :: *))
                       GHC.Enum.$fEnumWord_$cenumFromThen
                       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R ([Sym (Foreign.Ptr.N:WordPtr[0])])_R
                               :: (Word -> Word -> [Word] :: *)
                                  ~R# (WordPtr -> WordPtr -> [WordPtr] :: *))
                       GHC.Enum.$fEnumWord_$cenumFromTo
                       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R ([Sym (Foreign.Ptr.N:WordPtr[0])])_R
                               :: (Word -> Word -> [Word] :: *)
                                  ~R# (WordPtr -> WordPtr -> [WordPtr] :: *))
                       GHC.Enum.$fEnumWord_$cenumFromThenTo
                       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                               ->_R ([Sym (Foreign.Ptr.N:WordPtr[0])])_R
                               :: (Word -> Word -> Word -> [Word] :: *)
                                  ~R# (WordPtr -> WordPtr -> WordPtr -> [WordPtr] :: *))]
Foreign.Ptr.$fEnumWordPtr
  = GHC.Enum.C:Enum
      @ WordPtr
      (GHC.Enum.$fEnumWord_$csucc
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *)))
      (GHC.Enum.$fEnumWord_$cpred
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *)))
      (GHC.Enum.$fEnumWord_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Int -> Word :: *) ~R# (Int -> WordPtr :: *)))
      (GHC.Enum.$fEnumWord_$cfromEnum
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
               :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *)))
      (GHC.Enum.$fEnumWord_$cenumFrom
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R ([Sym (Foreign.Ptr.N:WordPtr[0])])_R
               :: (Word -> [Word] :: *) ~R# (WordPtr -> [WordPtr] :: *)))
      (GHC.Enum.$fEnumWord_$cenumFromThen
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R ([Sym (Foreign.Ptr.N:WordPtr[0])])_R
               :: (Word -> Word -> [Word] :: *)
                  ~R# (WordPtr -> WordPtr -> [WordPtr] :: *)))
      (GHC.Enum.$fEnumWord_$cenumFromTo
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R ([Sym (Foreign.Ptr.N:WordPtr[0])])_R
               :: (Word -> Word -> [Word] :: *)
                  ~R# (WordPtr -> WordPtr -> [WordPtr] :: *)))
      (GHC.Enum.$fEnumWord_$cenumFromThenTo
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R ([Sym (Foreign.Ptr.N:WordPtr[0])])_R
               :: (Word -> Word -> Word -> [Word] :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr -> [WordPtr] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.Ptr.$fNumWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Num WordPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: WordPtr
                     GHC.Num.$fNumWord_$c+
                     `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                             ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                             ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                             :: (Word -> Word -> Word :: *)
                                ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                     GHC.Num.$fNumWord_$c-
                     `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                             ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                             ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                             :: (Word -> Word -> Word :: *)
                                ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                     GHC.Num.$fNumWord_$c*
                     `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                             ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                             ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                             :: (Word -> Word -> Word :: *)
                                ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                     GHC.Num.$fNumWord_$cnegate
                     `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                             ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                             :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *))
                     GHC.Num.$fNumWord_$cabs
                     `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                             ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                             :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *))
                     GHC.Num.$fNumWord_$csignum
                     `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                             ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                             :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *))
                     GHC.Num.$fNumWord_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                             :: (Integer -> Word :: *) ~R# (Integer -> WordPtr :: *))]
Foreign.Ptr.$fNumWordPtr
  = GHC.Num.C:Num
      @ WordPtr
      (GHC.Num.$fNumWord_$c+
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (GHC.Num.$fNumWord_$c-
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (GHC.Num.$fNumWord_$c*
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (GHC.Num.$fNumWord_$cnegate
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *)))
      (GHC.Num.$fNumWord_$cabs
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *)))
      (GHC.Num.$fNumWord_$csignum
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *)))
      (GHC.Num.$fNumWord_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Integer -> Word :: *) ~R# (Integer -> WordPtr :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.Ptr.$fEqWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq WordPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: WordPtr
                        eqWord
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Bool>_R
                                :: (Word -> Word -> Bool :: *)
                                   ~R# (WordPtr -> WordPtr -> Bool :: *))
                        neWord
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Bool>_R
                                :: (Word -> Word -> Bool :: *)
                                   ~R# (WordPtr -> WordPtr -> Bool :: *))]
Foreign.Ptr.$fEqWordPtr
  = GHC.Classes.C:Eq
      @ WordPtr
      (eqWord
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Bool>_R
               :: (Word -> Word -> Bool :: *)
                  ~R# (WordPtr -> WordPtr -> Bool :: *)))
      (neWord
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Bool>_R
               :: (Word -> Word -> Bool :: *)
                  ~R# (WordPtr -> WordPtr -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.Ptr.$fOrdWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord WordPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: WordPtr
                         Foreign.Ptr.$fEqWordPtr
                         compareWord
                         `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R <Ordering>_R
                                 :: (Word -> Word -> Ordering :: *)
                                    ~R# (WordPtr -> WordPtr -> Ordering :: *))
                         ltWord
                         `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R <Bool>_R
                                 :: (Word -> Word -> Bool :: *)
                                    ~R# (WordPtr -> WordPtr -> Bool :: *))
                         leWord
                         `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R <Bool>_R
                                 :: (Word -> Word -> Bool :: *)
                                    ~R# (WordPtr -> WordPtr -> Bool :: *))
                         gtWord
                         `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R <Bool>_R
                                 :: (Word -> Word -> Bool :: *)
                                    ~R# (WordPtr -> WordPtr -> Bool :: *))
                         geWord
                         `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R <Bool>_R
                                 :: (Word -> Word -> Bool :: *)
                                    ~R# (WordPtr -> WordPtr -> Bool :: *))
                         GHC.Classes.$fOrdWord_$cmax
                         `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                 :: (Word -> Word -> Word :: *)
                                    ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                         GHC.Classes.$fOrdWord_$cmin
                         `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                 ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                 :: (Word -> Word -> Word :: *)
                                    ~R# (WordPtr -> WordPtr -> WordPtr :: *))]
Foreign.Ptr.$fOrdWordPtr
  = GHC.Classes.C:Ord
      @ WordPtr
      Foreign.Ptr.$fEqWordPtr
      (compareWord
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Ordering>_R
               :: (Word -> Word -> Ordering :: *)
                  ~R# (WordPtr -> WordPtr -> Ordering :: *)))
      (ltWord
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Bool>_R
               :: (Word -> Word -> Bool :: *)
                  ~R# (WordPtr -> WordPtr -> Bool :: *)))
      (leWord
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Bool>_R
               :: (Word -> Word -> Bool :: *)
                  ~R# (WordPtr -> WordPtr -> Bool :: *)))
      (gtWord
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Bool>_R
               :: (Word -> Word -> Bool :: *)
                  ~R# (WordPtr -> WordPtr -> Bool :: *)))
      (geWord
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Bool>_R
               :: (Word -> Word -> Bool :: *)
                  ~R# (WordPtr -> WordPtr -> Bool :: *)))
      (GHC.Classes.$fOrdWord_$cmax
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (GHC.Classes.$fOrdWord_$cmin
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.Ptr.$fRealWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Real WordPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: WordPtr
                       Foreign.Ptr.$fNumWordPtr
                       Foreign.Ptr.$fOrdWordPtr
                       GHC.Real.$fRealWord_$ctoRational
                       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Ratio Integer>_R
                               :: (Word -> Ratio Integer :: *)
                                  ~R# (WordPtr -> Ratio Integer :: *))]
Foreign.Ptr.$fRealWordPtr
  = GHC.Real.C:Real
      @ WordPtr
      Foreign.Ptr.$fNumWordPtr
      Foreign.Ptr.$fOrdWordPtr
      (GHC.Real.$fRealWord_$ctoRational
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Ratio Integer>_R
               :: (Word -> Ratio Integer :: *)
                  ~R# (WordPtr -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.Ptr.$fIntegralWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral WordPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: WordPtr
                           Foreign.Ptr.$fRealWordPtr
                           Foreign.Ptr.$fEnumWordPtr
                           GHC.Real.$fIntegralWord_$cquot
                           `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                   :: (Word -> Word -> Word :: *)
                                      ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                           GHC.Real.$fIntegralWord_$crem
                           `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                   :: (Word -> Word -> Word :: *)
                                      ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                           GHC.Real.$fIntegralWord_$cquot
                           `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                   :: (Word -> Word -> Word :: *)
                                      ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                           GHC.Real.$fIntegralWord_$crem
                           `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                   :: (Word -> Word -> Word :: *)
                                      ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                           GHC.Real.$fIntegralWord_$cquotRem
                           `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R ((,)
                                           (Sym (Foreign.Ptr.N:WordPtr[0]))
                                           (Sym (Foreign.Ptr.N:WordPtr[0])))_R
                                   :: (Word -> Word -> (Word, Word) :: *)
                                      ~R# (WordPtr -> WordPtr -> (WordPtr, WordPtr) :: *))
                           GHC.Real.$fIntegralWord_$cdivMod
                           `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                   ->_R ((,)
                                           (Sym (Foreign.Ptr.N:WordPtr[0]))
                                           (Sym (Foreign.Ptr.N:WordPtr[0])))_R
                                   :: (Word -> Word -> (Word, Word) :: *)
                                      ~R# (WordPtr -> WordPtr -> (WordPtr, WordPtr) :: *))
                           GHC.Real.$fIntegralWord_$ctoInteger
                           `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Integer>_R
                                   :: (Word -> Integer :: *) ~R# (WordPtr -> Integer :: *))]
Foreign.Ptr.$fIntegralWordPtr
  = GHC.Real.C:Integral
      @ WordPtr
      Foreign.Ptr.$fRealWordPtr
      Foreign.Ptr.$fEnumWordPtr
      (GHC.Real.$fIntegralWord_$cquot
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (GHC.Real.$fIntegralWord_$crem
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (GHC.Real.$fIntegralWord_$cquot
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (GHC.Real.$fIntegralWord_$crem
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (GHC.Real.$fIntegralWord_$cquotRem
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R ((,)
                       (Sym (Foreign.Ptr.N:WordPtr[0]))
                       (Sym (Foreign.Ptr.N:WordPtr[0])))_R
               :: (Word -> Word -> (Word, Word) :: *)
                  ~R# (WordPtr -> WordPtr -> (WordPtr, WordPtr) :: *)))
      (GHC.Real.$fIntegralWord_$cdivMod
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R ((,)
                       (Sym (Foreign.Ptr.N:WordPtr[0]))
                       (Sym (Foreign.Ptr.N:WordPtr[0])))_R
               :: (Word -> Word -> (Word, Word) :: *)
                  ~R# (WordPtr -> WordPtr -> (WordPtr, WordPtr) :: *)))
      (GHC.Real.$fIntegralWord_$ctoInteger
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Integer>_R
               :: (Word -> Integer :: *) ~R# (WordPtr -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.Ptr.$fBitsWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits WordPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: WordPtr
                        Foreign.Ptr.$fEqWordPtr
                        Data.Bits.$fBitsWord_$c.&.
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Word -> Word :: *)
                                   ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$c.|.
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Word -> Word :: *)
                                   ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$cxor
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Word -> Word :: *)
                                   ~R# (WordPtr -> WordPtr -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$ccomplement
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$cshift
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$crotate
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord1
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word :: *) ~R# (WordPtr :: *))
                        Data.Bits.$fBitsWord_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Int -> Word :: *) ~R# (Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$csetBit
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$cclearBit
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$ccomplementBit
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$ctestBit
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int -> Bool>_R
                                :: (Word -> Int -> Bool :: *) ~R# (WordPtr -> Int -> Bool :: *))
                        Data.Bits.$fBitsWord_$cbitSizeMaybe
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Maybe Int>_R
                                :: (Word -> Maybe Int :: *) ~R# (WordPtr -> Maybe Int :: *))
                        Data.Bits.$fBitsWord_$cfiniteBitSize
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
                                :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *))
                        Data.Bits.$fBitsWord_$cisSigned
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Bool>_R
                                :: (Word -> Bool :: *) ~R# (WordPtr -> Bool :: *))
                        Data.Bits.$fBitsWord_$cshiftL
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$cunsafeShiftL
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$cshiftR
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$cunsafeShiftR
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$crotateL
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$crotateR
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.Ptr.N:WordPtr[0])
                                :: (Word -> Int -> Word :: *) ~R# (WordPtr -> Int -> WordPtr :: *))
                        Data.Bits.$fBitsWord_$cpopCount
                        `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
                                :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *))]
Foreign.Ptr.$fBitsWordPtr
  = Data.Bits.C:Bits
      @ WordPtr
      Foreign.Ptr.$fEqWordPtr
      (Data.Bits.$fBitsWord_$c.&.
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$c.|.
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$cxor
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word -> Word :: *)
                  ~R# (WordPtr -> WordPtr -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$ccomplement
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Word :: *) ~R# (WordPtr -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$cshift
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$crotate
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord1
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word :: *) ~R# (WordPtr :: *)))
      (Data.Bits.$fBitsWord_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Int -> Word :: *) ~R# (Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$csetBit
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$cclearBit
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$ccomplementBit
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$ctestBit
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int -> Bool>_R
               :: (Word -> Int -> Bool :: *) ~R# (WordPtr -> Int -> Bool :: *)))
      (Data.Bits.$fBitsWord_$cbitSizeMaybe
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Maybe Int>_R
               :: (Word -> Maybe Int :: *) ~R# (WordPtr -> Maybe Int :: *)))
      (Data.Bits.$fBitsWord_$cfiniteBitSize
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
               :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *)))
      (Data.Bits.$fBitsWord_$cisSigned
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Bool>_R
               :: (Word -> Bool :: *) ~R# (WordPtr -> Bool :: *)))
      (Data.Bits.$fBitsWord_$cshiftL
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$cunsafeShiftL
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$cshiftR
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$cunsafeShiftR
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$crotateL
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$crotateR
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.Ptr.N:WordPtr[0])
               :: (Word -> Int -> Word :: *)
                  ~R# (WordPtr -> Int -> WordPtr :: *)))
      (Data.Bits.$fBitsWord_$cpopCount
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
               :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.Ptr.$fFiniteBitsWordPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits WordPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: WordPtr
                              Foreign.Ptr.$fBitsWordPtr
                              Data.Bits.$fBitsWord_$cfiniteBitSize
                              `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
                                      :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *))
                              Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
                              `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
                                      :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *))
                              Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros
                              `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
                                      :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *))]
Foreign.Ptr.$fFiniteBitsWordPtr
  = Data.Bits.C:FiniteBits
      @ WordPtr
      Foreign.Ptr.$fBitsWordPtr
      (Data.Bits.$fBitsWord_$cfiniteBitSize
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
               :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *)))
      (Data.Bits.$fFiniteBitsWord_$ccountLeadingZeros
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
               :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *)))
      (Data.Bits.$fFiniteBitsWord_$ccountTrailingZeros
       `cast` (Sym (Foreign.Ptr.N:WordPtr[0]) ->_R <Int>_R
               :: (Word -> Int :: *) ~R# (WordPtr -> Int :: *)))

-- RHS size: {terms: 9, types: 7, coercions: 2, joins: 0/0}
ptrToWordPtr :: forall a. Ptr a -> WordPtr
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4QTo) (ds_d4RCR [Occ=Once!] :: Ptr a_a4QTo) ->
                 case ds_d4RCR of { Ptr a#_a4QCR [Occ=Once] ->
                 (GHC.Types.W# (int2Word# (addr2Int# a#_a4QCR)))
                 `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
                         :: (Word :: *) ~R# (WordPtr :: *))
                 }}]
ptrToWordPtr
  = \ (@ a_a4QTo) (ds_d4RCR :: Ptr a_a4QTo) ->
      case ds_d4RCR of { Ptr a#_a4QCR ->
      (GHC.Types.W# (int2Word# (addr2Int# a#_a4QCR)))
      `cast` (Sym (Foreign.Ptr.N:WordPtr[0])
              :: (Word :: *) ~R# (WordPtr :: *))
      }

-- RHS size: {terms: 9, types: 6, coercions: 1, joins: 0/0}
wordPtrToPtr :: forall a. WordPtr -> Ptr a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4QTl) (ds_d4RCK [Occ=Once] :: WordPtr) ->
                 case ds_d4RCK
                      `cast` (Foreign.Ptr.N:WordPtr[0] :: (WordPtr :: *) ~R# (Word :: *))
                 of
                 { W# w#_a4QCS [Occ=Once] ->
                 GHC.Ptr.Ptr @ a_a4QTl (int2Addr# (word2Int# w#_a4QCS))
                 }}]
wordPtrToPtr
  = \ (@ a_a4QTl) (ds_d4RCK :: WordPtr) ->
      case ds_d4RCK
           `cast` (Foreign.Ptr.N:WordPtr[0] :: (WordPtr :: *) ~R# (Word :: *))
      of
      { W# w#_a4QCS ->
      GHC.Ptr.Ptr @ a_a4QTl (int2Addr# (word2Int# w#_a4QCS))
      }

-- RHS size: {terms: 8, types: 7, coercions: 2, joins: 0/0}
ptrToIntPtr :: forall a. Ptr a -> IntPtr
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4QTj) (ds_d4RCG [Occ=Once!] :: Ptr a_a4QTj) ->
                 case ds_d4RCG of { Ptr a#_a4QCT [Occ=Once] ->
                 (GHC.Types.I# (addr2Int# a#_a4QCT))
                 `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
                         :: (Int :: *) ~R# (IntPtr :: *))
                 }}]
ptrToIntPtr
  = \ (@ a_a4QTj) (ds_d4RCG :: Ptr a_a4QTj) ->
      case ds_d4RCG of { Ptr a#_a4QCT ->
      (GHC.Types.I# (addr2Int# a#_a4QCT))
      `cast` (Sym (Foreign.Ptr.N:IntPtr[0])
              :: (Int :: *) ~R# (IntPtr :: *))
      }

-- RHS size: {terms: 8, types: 6, coercions: 1, joins: 0/0}
intPtrToPtr :: forall a. IntPtr -> Ptr a
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4QTg) (ds_d4RCz [Occ=Once] :: IntPtr) ->
                 case ds_d4RCz
                      `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *))
                 of
                 { I# i#_a4QCU [Occ=Once] ->
                 GHC.Ptr.Ptr @ a_a4QTg (int2Addr# i#_a4QCU)
                 }}]
intPtrToPtr
  = \ (@ a_a4QTg) (ds_d4RCz :: IntPtr) ->
      case ds_d4RCz
           `cast` (Foreign.Ptr.N:IntPtr[0] :: (IntPtr :: *) ~R# (Int :: *))
      of
      { I# i#_a4QCU ->
      GHC.Ptr.Ptr @ a_a4QTg (int2Addr# i#_a4QCU)
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Foreign.Ptr.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Ptr.$trModule3 = GHC.Types.TrNameS Foreign.Ptr.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Foreign.Ptr.$trModule2 = "Foreign.Ptr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Ptr.$trModule1 = GHC.Types.TrNameS Foreign.Ptr.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foreign.Ptr.$trModule
  = GHC.Types.Module Foreign.Ptr.$trModule3 Foreign.Ptr.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r4RLt :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r4RLt
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcWord (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_r4RLu :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_r4RLu
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcInt (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tcWordPtr2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.Ptr.$tcWordPtr2 = "WordPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tcWordPtr1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Ptr.$tcWordPtr1 = GHC.Types.TrNameS Foreign.Ptr.$tcWordPtr2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tcWordPtr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.Ptr.$tcWordPtr
  = GHC.Types.TyCon
      10827112719629138107##
      3588783739676187441##
      Foreign.Ptr.$trModule
      Foreign.Ptr.$tcWordPtr1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2_r4RLv :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_r4RLv
  = GHC.Types.KindRepTyConApp
      Foreign.Ptr.$tcWordPtr (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tc'WordPtr1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.Ptr.$tc'WordPtr1
  = GHC.Types.KindRepFun $krep_r4RLt $krep2_r4RLv

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tc'WordPtr3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.Ptr.$tc'WordPtr3 = "'WordPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tc'WordPtr2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Ptr.$tc'WordPtr2
  = GHC.Types.TrNameS Foreign.Ptr.$tc'WordPtr3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tc'WordPtr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.Ptr.$tc'WordPtr
  = GHC.Types.TyCon
      15588862172907192371##
      13878995573910308719##
      Foreign.Ptr.$trModule
      Foreign.Ptr.$tc'WordPtr2
      0#
      Foreign.Ptr.$tc'WordPtr1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tcIntPtr2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.Ptr.$tcIntPtr2 = "IntPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tcIntPtr1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Ptr.$tcIntPtr1 = GHC.Types.TrNameS Foreign.Ptr.$tcIntPtr2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tcIntPtr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.Ptr.$tcIntPtr
  = GHC.Types.TyCon
      12538429555661790394##
      9943980142794044772##
      Foreign.Ptr.$trModule
      Foreign.Ptr.$tcIntPtr1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3_r4RLw :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_r4RLw
  = GHC.Types.KindRepTyConApp
      Foreign.Ptr.$tcIntPtr (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tc'IntPtr1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.Ptr.$tc'IntPtr1
  = GHC.Types.KindRepFun $krep1_r4RLu $krep3_r4RLw

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tc'IntPtr3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.Ptr.$tc'IntPtr3 = "'IntPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tc'IntPtr2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Ptr.$tc'IntPtr2 = GHC.Types.TrNameS Foreign.Ptr.$tc'IntPtr3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.Ptr.$tc'IntPtr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.Ptr.$tc'IntPtr
  = GHC.Types.TyCon
      17038100807295602145##
      4458611784149765752##
      Foreign.Ptr.$trModule
      Foreign.Ptr.$tc'IntPtr2
      0#
      Foreign.Ptr.$tc'IntPtr1

-- RHS size: {terms: 14, types: 24, coercions: 0, joins: 0/0}
freeHaskellFunPtr1_r4RLx
  :: forall a.
     FunPtr a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []]
freeHaskellFunPtr1_r4RLx
  = \ (@ a_a4QCV)
      (ds_d4RCV :: FunPtr a_a4QCV)
      (eta_B1 :: State# RealWorld) ->
      case ds_d4RCV of { FunPtr ds2_d4RCX ->
      case {__pkg_ccall base-4.11.0.0 Addr#
                           -> State# RealWorld -> (# State# RealWorld #)}_d4RD0
             ds2_d4RCX eta_B1
      of
      { (# ds3_d4RCY #) ->
      (# ds3_d4RCY, GHC.Tuple.() #)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 9, joins: 0/0}
freeHaskellFunPtr :: forall a. FunPtr a -> IO ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ a_X4QEE) (ds_X4REF [Occ=Once!] :: FunPtr a_X4QEE) ->
                 case ds_X4REF of { FunPtr ds2_d4RCX [Occ=Once] ->
                 (\ (ds3_d4RCZ [Occ=Once] :: State# RealWorld) ->
                    case {__pkg_ccall base-4.11.0.0 Addr#
                           -> State# RealWorld -> (# State# RealWorld #)}_d4RD0
                           ds2_d4RCX ds3_d4RCZ
                    of
                    { (# ds4_d4RCY [Occ=Once] #) ->
                    (# ds4_d4RCY, GHC.Tuple.() #)
                    })
                 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)
                         :: (State# RealWorld -> (# State# RealWorld, () #) :: *)
                            ~R# (IO () :: *))
                 }}]
freeHaskellFunPtr
  = freeHaskellFunPtr1_r4RLx
    `cast` (forall (a :: <*>_N).
            <FunPtr a>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)
            :: (forall a.
                FunPtr a -> State# RealWorld -> (# State# RealWorld, () #) :: *)
               ~R# (forall a. FunPtr a -> IO () :: *))


