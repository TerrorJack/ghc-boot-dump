
==================== Pre unarise: ====================
2018-03-16 15:59:30.54852622 UTC

Foreign.Storable.sizeOf
  :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLL),U(U,A,A,A,A,A,A,A)>] =
    [] \r [v_s4Ffv]
        case v_s4Ffv of {
          Foreign.Storable.C:Storable v_s4Ffx [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Ffx;
        };

Foreign.Storable.alignment
  :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>] =
    [] \r [v_s4FfF]
        case v_s4FfF of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      v_s4FfI [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4FfI;
        };

Foreign.Storable.peekElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLL),U(A,A,U,A,A,A,A,A)>] =
    [] \r [v_s4FfP]
        case v_s4FfP of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4FfT [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4FfT;
        };

Foreign.Storable.pokeElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLL),U(A,A,A,U,A,A,A,A)>] =
    [] \r [v_s4FfZ]
        case v_s4FfZ of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Fg4 [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Fg4;
        };

Foreign.Storable.peekByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLL),U(A,A,A,A,U,A,A,A)>] =
    [] \r [v_s4Fg9]
        case v_s4Fg9 of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Fgf [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Fgf;
        };

Foreign.Storable.pokeByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLL),U(A,A,A,A,A,U,A,A)>] =
    [] \r [v_s4Fgj]
        case v_s4Fgj of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Fgq [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Fgq;
        };

Foreign.Storable.peek
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSL),U(A,A,A,A,A,A,U,A)>] =
    [] \r [v_s4Fgt]
        case v_s4Fgt of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4FgB [Occ=Once]
                                      _ [Occ=Dead] ->
              v_s4FgB;
        };

Foreign.Storable.poke
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLS),U(A,A,A,A,A,A,A,U)>] =
    [] \r [v_s4FgD]
        case v_s4FgD of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4FgM [Occ=Once] ->
              v_s4FgM;
        };

Foreign.Storable.$fStorable()7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Foreign.Storable.$fStorable()_$calignment :: () -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgN] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorable()8 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Foreign.Storable.$fStorable()_$csizeOf :: () -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgO] Foreign.Storable.$fStorable()8;

Foreign.Storable.$fStorableBool7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [4#];

Foreign.Storable.$fStorableChar_$calignment
  :: GHC.Types.Char -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgP] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableDouble5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

Foreign.Storable.$fStorableInt_$calignment
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgQ] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableWord_$calignment
  :: GHC.Types.Word -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgR] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorablePtr_$calignment
  :: forall a. GHC.Ptr.Ptr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgS] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFunPtr_$calignment
  :: forall a. GHC.Ptr.FunPtr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgT] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableStablePtr_$calignment
  :: forall a. GHC.Stable.StablePtr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgU] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFloat_$calignment
  :: GHC.Types.Float -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgV] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableDouble_$calignment
  :: GHC.Types.Double -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgW] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableWord8_$calignment
  :: GHC.Word.Word8 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgX] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorableInt10 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

Foreign.Storable.$fStorableWord16_$calignment
  :: GHC.Word.Word16 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgY] Foreign.Storable.$fStorableInt10;

Foreign.Storable.$fStorableWord32_$calignment
  :: GHC.Word.Word32 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgZ] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableWord64_$calignment
  :: GHC.Word.Word64 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fh0] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableInt8_$calignment
  :: GHC.Int.Int8 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fh1] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorableInt16_$calignment
  :: GHC.Int.Int16 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fh2] Foreign.Storable.$fStorableInt10;

Foreign.Storable.$fStorableInt32_$calignment
  :: GHC.Int.Int32 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fh3] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableInt64_$calignment
  :: GHC.Int.Int64 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fh4] Foreign.Storable.$fStorableDouble5;

lvl_r4Ff9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

lvl1_r4Ffa :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_r4Ff9;

Foreign.Storable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl2_r4Ffb :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Foreign.Storable.$trModule4;

Foreign.Storable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foreign.Storable"#;

lvl3_r4Ffc :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Foreign.Storable.$trModule2;

lvl4_r4Ffd :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Foreign/Storable.hs"#;

lvl5_r4Ffe :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_r4Ffd;

lvl6_r4Fff :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [238#];

lvl7_r4Ffg :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [30#];

lvl8_r4Ffh :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [39#];

lvl9_r4Ffi :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl6_r4Fff
                                           lvl7_r4Ffg
                                           lvl6_r4Fff
                                           lvl8_r4Ffh];

lvl10_r4Ffj :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl9_r4Ffi
                                                  GHC.Stack.Types.EmptyCallStack];

Foreign.Storable.$fStorableRatio8 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl10_r4Ffj;

Foreign.Storable.$fStorableRatio_$calignment
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(U),A,A,A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fh5 $dIntegral_s4Fh6]
        let {
          lvl20_s4Fh7 [Occ=OnceL] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4Fh5] \u []
                  Foreign.Storable.alignment
                      $dStorable_s4Fh5 Foreign.Storable.$fStorableRatio8; } in
        let {
          sat_s4Fh9 [Occ=OnceT[0]] :: GHC.Real.Ratio a_a4DgH -> GHC.Types.Int
          [LclId] =
              [lvl20_s4Fh7] \r [ds_s4Fh8] lvl20_s4Fh7;
        } in  sat_s4Fh9;

Foreign.Storable.$fStorableFingerprint_$calignment
  :: GHC.Fingerprint.Type.Fingerprint -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fha] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFingerprint7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [16#];

Foreign.Storable.$fStorableFingerprint_$csizeOf
  :: GHC.Fingerprint.Type.Fingerprint -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fhb] Foreign.Storable.$fStorableFingerprint7;

Foreign.Storable.$dmpoke
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fhc ptr_s4Fhd]
        Foreign.Storable.pokeElemOff
            $dStorable_s4Fhc ptr_s4Fhd Foreign.Storable.$fStorable()8;

Foreign.Storable.$dmpeek
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fhe ptr_s4Fhf]
        Foreign.Storable.peekElemOff
            $dStorable_s4Fhe ptr_s4Fhf Foreign.Storable.$fStorable()8;

Foreign.Storable.$dmpokeByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)),1*U(A,A,A,A,A,A,A,1*C1(U))><L,1*U(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fhg ptr_s4Fhh off_s4Fhi]
        let {
          sat_s4Fho [Occ=Once] :: GHC.Ptr.Ptr a_a4D8k
          [LclId] =
              [ptr_s4Fhh off_s4Fhi] \u []
                  case ptr_s4Fhh of {
                    GHC.Ptr.Ptr addr_s4Fhk [Occ=Once] ->
                        case off_s4Fhi of {
                          GHC.Types.I# d_s4Fhm [Occ=Once] ->
                              case plusAddr# [addr_s4Fhk d_s4Fhm] of sat_s4Fhn {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fhn];
                              };
                        };
                  };
        } in  Foreign.Storable.poke $dStorable_s4Fhg sat_s4Fho;

Foreign.Storable.$dmpeekByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(S)L),1*U(A,A,A,A,A,A,1*C1(U),A)><L,1*U(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fhp ptr_s4Fhq off_s4Fhr]
        let {
          sat_s4Fhx [Occ=Once] :: GHC.Ptr.Ptr a_a4D8k
          [LclId] =
              [ptr_s4Fhq off_s4Fhr] \u []
                  case ptr_s4Fhq of {
                    GHC.Ptr.Ptr addr_s4Fht [Occ=Once] ->
                        case off_s4Fhr of {
                          GHC.Types.I# d_s4Fhv [Occ=Once] ->
                              case plusAddr# [addr_s4Fht d_s4Fhv] of sat_s4Fhw {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fhw];
                              };
                        };
                  };
        } in  Foreign.Storable.peek $dStorable_s4Fhp sat_s4Fhx;

Foreign.Storable.$fStorableInt17
  :: GHC.Ptr.Ptr GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int64 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fhy eta_s4Fhz]
        case ptr_s4Fhy of {
          GHC.Ptr.Ptr a_s4FhB [Occ=Once] ->
              case readInt64OffAddr# [a_s4FhB 0# eta_s4Fhz] of {
                (#,#) ipv_s4FhD [Occ=Once] ipv1_s4FhE [Occ=Once] ->
                    let {
                      sat_s4FhF [Occ=Once] :: GHC.Int.Int64
                      [LclId] =
                          CCCS GHC.Int.I64#! [ipv1_s4FhE];
                    } in  (#,#) [ipv_s4FhD sat_s4FhF];
              };
        };

Foreign.Storable.$fStorableInt19
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FhG off_s4FhH eta_s4FhI]
        case ptr_s4FhG of {
          GHC.Ptr.Ptr addr_s4FhK [Occ=Once] ->
              case off_s4FhH of {
                GHC.Types.I# d_s4FhM [Occ=Once] ->
                    case plusAddr# [addr_s4FhK d_s4FhM] of sat_s4FhN {
                      __DEFAULT ->
                          case readInt64OffAddr# [sat_s4FhN 0# eta_s4FhI] of {
                            (#,#) ipv_s4FhP [Occ=Once] ipv1_s4FhQ [Occ=Once] ->
                                let {
                                  sat_s4FhR [Occ=Once] :: GHC.Int.Int64
                                  [LclId] =
                                      CCCS GHC.Int.I64#! [ipv1_s4FhQ];
                                } in  (#,#) [ipv_s4FhP sat_s4FhR];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt15
  :: GHC.Ptr.Ptr GHC.Int.Int64
     -> GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FhS ds2_s4FhT eta_s4FhU]
        case ptr_s4FhS of {
          GHC.Ptr.Ptr a_s4FhW [Occ=Once] ->
              case ds2_s4FhT of {
                GHC.Int.I64# x_s4FhY [Occ=Once] ->
                    case
                        writeInt64OffAddr# [a_s4FhW 0# x_s4FhY eta_s4FhU]
                    of
                    s2_s4FhZ
                    { __DEFAULT -> (#,#) [s2_s4FhZ GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt18
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fi0 off_s4Fi1 eta_s4Fi2 eta1_s4Fi3]
        case ptr_s4Fi0 of {
          GHC.Ptr.Ptr addr_s4Fi5 [Occ=Once] ->
              case off_s4Fi1 of {
                GHC.Types.I# d_s4Fi7 [Occ=Once] ->
                    case eta_s4Fi2 of {
                      GHC.Int.I64# x_s4Fi9 [Occ=Once] ->
                          case plusAddr# [addr_s4Fi5 d_s4Fi7] of sat_s4Fia {
                            __DEFAULT ->
                                case
                                    writeInt64OffAddr# [sat_s4Fia 0# x_s4Fi9 eta1_s4Fi3]
                                of
                                s2_s4Fib
                                { __DEFAULT -> (#,#) [s2_s4Fib GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int64
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt64_$calignment
                                                Foreign.Storable.$fStorableInt64_$calignment
                                                GHC.Storable.readInt64OffPtr1
                                                GHC.Storable.writeInt64OffPtr1
                                                Foreign.Storable.$fStorableInt19
                                                Foreign.Storable.$fStorableInt18
                                                Foreign.Storable.$fStorableInt17
                                                Foreign.Storable.$fStorableInt15];

Foreign.Storable.$fStorableInt12
  :: GHC.Ptr.Ptr GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int32 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fic eta_s4Fid]
        case ptr_s4Fic of {
          GHC.Ptr.Ptr a_s4Fif [Occ=Once] ->
              case readInt32OffAddr# [a_s4Fif 0# eta_s4Fid] of {
                (#,#) ipv_s4Fih [Occ=Once] ipv1_s4Fii [Occ=Once] ->
                    let {
                      sat_s4Fij [Occ=Once] :: GHC.Int.Int32
                      [LclId] =
                          CCCS GHC.Int.I32#! [ipv1_s4Fii];
                    } in  (#,#) [ipv_s4Fih sat_s4Fij];
              };
        };

Foreign.Storable.$fStorableInt14
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fik off_s4Fil eta_s4Fim]
        case ptr_s4Fik of {
          GHC.Ptr.Ptr addr_s4Fio [Occ=Once] ->
              case off_s4Fil of {
                GHC.Types.I# d_s4Fiq [Occ=Once] ->
                    case plusAddr# [addr_s4Fio d_s4Fiq] of sat_s4Fir {
                      __DEFAULT ->
                          case readInt32OffAddr# [sat_s4Fir 0# eta_s4Fim] of {
                            (#,#) ipv_s4Fit [Occ=Once] ipv1_s4Fiu [Occ=Once] ->
                                let {
                                  sat_s4Fiv [Occ=Once] :: GHC.Int.Int32
                                  [LclId] =
                                      CCCS GHC.Int.I32#! [ipv1_s4Fiu];
                                } in  (#,#) [ipv_s4Fit sat_s4Fiv];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt11
  :: GHC.Ptr.Ptr GHC.Int.Int32
     -> GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fiw ds2_s4Fix eta_s4Fiy]
        case ptr_s4Fiw of {
          GHC.Ptr.Ptr a_s4FiA [Occ=Once] ->
              case ds2_s4Fix of {
                GHC.Int.I32# x_s4FiC [Occ=Once] ->
                    case
                        writeInt32OffAddr# [a_s4FiA 0# x_s4FiC eta_s4Fiy]
                    of
                    s2_s4FiD
                    { __DEFAULT -> (#,#) [s2_s4FiD GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt13
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FiE off_s4FiF eta_s4FiG eta1_s4FiH]
        case ptr_s4FiE of {
          GHC.Ptr.Ptr addr_s4FiJ [Occ=Once] ->
              case off_s4FiF of {
                GHC.Types.I# d_s4FiL [Occ=Once] ->
                    case eta_s4FiG of {
                      GHC.Int.I32# x_s4FiN [Occ=Once] ->
                          case plusAddr# [addr_s4FiJ d_s4FiL] of sat_s4FiO {
                            __DEFAULT ->
                                case
                                    writeInt32OffAddr# [sat_s4FiO 0# x_s4FiN eta1_s4FiH]
                                of
                                s2_s4FiP
                                { __DEFAULT -> (#,#) [s2_s4FiP GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int32
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt32_$calignment
                                                Foreign.Storable.$fStorableInt32_$calignment
                                                GHC.Storable.readInt32OffPtr1
                                                GHC.Storable.writeInt32OffPtr1
                                                Foreign.Storable.$fStorableInt14
                                                Foreign.Storable.$fStorableInt13
                                                Foreign.Storable.$fStorableInt12
                                                Foreign.Storable.$fStorableInt11];

Foreign.Storable.$fStorableBool_$csizeOf
  :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FiQ] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableBool5
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Int
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [p_s4FiR i_s4FiS x_s4FiT eta_s4FiU]
        case p_s4FiR of {
          GHC.Ptr.Ptr a_s4FiW [Occ=Once*] ->
              case i_s4FiS of {
                GHC.Types.I# i1_s4FiY [Occ=Once*] ->
                    case x_s4FiT of {
                      GHC.Types.False ->
                          case
                              writeInt32OffAddr# [a_s4FiW i1_s4FiY 0# eta_s4FiU]
                          of
                          s2_s4Fj0
                          { __DEFAULT -> (#,#) [s2_s4Fj0 GHC.Tuple.()];
                          };
                      GHC.Types.True ->
                          case
                              writeInt32OffAddr# [a_s4FiW i1_s4FiY 1# eta_s4FiU]
                          of
                          s2_s4Fj1
                          { __DEFAULT -> (#,#) [s2_s4Fj1 GHC.Tuple.()];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt6
  :: GHC.Ptr.Ptr GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int16 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fj2 eta_s4Fj3]
        case ptr_s4Fj2 of {
          GHC.Ptr.Ptr a_s4Fj5 [Occ=Once] ->
              case readInt16OffAddr# [a_s4Fj5 0# eta_s4Fj3] of {
                (#,#) ipv_s4Fj7 [Occ=Once] ipv1_s4Fj8 [Occ=Once] ->
                    let {
                      sat_s4Fj9 [Occ=Once] :: GHC.Int.Int16
                      [LclId] =
                          CCCS GHC.Int.I16#! [ipv1_s4Fj8];
                    } in  (#,#) [ipv_s4Fj7 sat_s4Fj9];
              };
        };

Foreign.Storable.$fStorableInt9
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fja off_s4Fjb eta_s4Fjc]
        case ptr_s4Fja of {
          GHC.Ptr.Ptr addr_s4Fje [Occ=Once] ->
              case off_s4Fjb of {
                GHC.Types.I# d_s4Fjg [Occ=Once] ->
                    case plusAddr# [addr_s4Fje d_s4Fjg] of sat_s4Fjh {
                      __DEFAULT ->
                          case readInt16OffAddr# [sat_s4Fjh 0# eta_s4Fjc] of {
                            (#,#) ipv_s4Fjj [Occ=Once] ipv1_s4Fjk [Occ=Once] ->
                                let {
                                  sat_s4Fjl [Occ=Once] :: GHC.Int.Int16
                                  [LclId] =
                                      CCCS GHC.Int.I16#! [ipv1_s4Fjk];
                                } in  (#,#) [ipv_s4Fjj sat_s4Fjl];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt5
  :: GHC.Ptr.Ptr GHC.Int.Int16
     -> GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fjm ds2_s4Fjn eta_s4Fjo]
        case ptr_s4Fjm of {
          GHC.Ptr.Ptr a_s4Fjq [Occ=Once] ->
              case ds2_s4Fjn of {
                GHC.Int.I16# x_s4Fjs [Occ=Once] ->
                    case
                        writeInt16OffAddr# [a_s4Fjq 0# x_s4Fjs eta_s4Fjo]
                    of
                    s2_s4Fjt
                    { __DEFAULT -> (#,#) [s2_s4Fjt GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt7
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fju off_s4Fjv eta_s4Fjw eta1_s4Fjx]
        case ptr_s4Fju of {
          GHC.Ptr.Ptr addr_s4Fjz [Occ=Once] ->
              case off_s4Fjv of {
                GHC.Types.I# d_s4FjB [Occ=Once] ->
                    case eta_s4Fjw of {
                      GHC.Int.I16# x_s4FjD [Occ=Once] ->
                          case plusAddr# [addr_s4Fjz d_s4FjB] of sat_s4FjE {
                            __DEFAULT ->
                                case
                                    writeInt16OffAddr# [sat_s4FjE 0# x_s4FjD eta1_s4Fjx]
                                of
                                s2_s4FjF
                                { __DEFAULT -> (#,#) [s2_s4FjF GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int16
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt16_$calignment
                                                Foreign.Storable.$fStorableInt16_$calignment
                                                GHC.Storable.readInt16OffPtr1
                                                GHC.Storable.writeInt16OffPtr1
                                                Foreign.Storable.$fStorableInt9
                                                Foreign.Storable.$fStorableInt7
                                                Foreign.Storable.$fStorableInt6
                                                Foreign.Storable.$fStorableInt5];

Foreign.Storable.$fStorableInt21
  :: GHC.Ptr.Ptr GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int8 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FjG eta_s4FjH]
        case ptr_s4FjG of {
          GHC.Ptr.Ptr a_s4FjJ [Occ=Once] ->
              case readInt8OffAddr# [a_s4FjJ 0# eta_s4FjH] of {
                (#,#) ipv_s4FjL [Occ=Once] ipv1_s4FjM [Occ=Once] ->
                    let {
                      sat_s4FjN [Occ=Once] :: GHC.Int.Int8
                      [LclId] =
                          CCCS GHC.Int.I8#! [ipv1_s4FjM];
                    } in  (#,#) [ipv_s4FjL sat_s4FjN];
              };
        };

Foreign.Storable.$fStorableInt23
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FjO off_s4FjP eta_s4FjQ]
        case ptr_s4FjO of {
          GHC.Ptr.Ptr addr_s4FjS [Occ=Once] ->
              case off_s4FjP of {
                GHC.Types.I# d_s4FjU [Occ=Once] ->
                    case plusAddr# [addr_s4FjS d_s4FjU] of sat_s4FjV {
                      __DEFAULT ->
                          case readInt8OffAddr# [sat_s4FjV 0# eta_s4FjQ] of {
                            (#,#) ipv_s4FjX [Occ=Once] ipv1_s4FjY [Occ=Once] ->
                                let {
                                  sat_s4FjZ [Occ=Once] :: GHC.Int.Int8
                                  [LclId] =
                                      CCCS GHC.Int.I8#! [ipv1_s4FjY];
                                } in  (#,#) [ipv_s4FjX sat_s4FjZ];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt20
  :: GHC.Ptr.Ptr GHC.Int.Int8
     -> GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fk0 ds2_s4Fk1 eta_s4Fk2]
        case ptr_s4Fk0 of {
          GHC.Ptr.Ptr a_s4Fk4 [Occ=Once] ->
              case ds2_s4Fk1 of {
                GHC.Int.I8# x_s4Fk6 [Occ=Once] ->
                    case writeInt8OffAddr# [a_s4Fk4 0# x_s4Fk6 eta_s4Fk2] of s2_s4Fk7 {
                      __DEFAULT -> (#,#) [s2_s4Fk7 GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt22
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fk8 off_s4Fk9 eta_s4Fka eta1_s4Fkb]
        case ptr_s4Fk8 of {
          GHC.Ptr.Ptr addr_s4Fkd [Occ=Once] ->
              case off_s4Fk9 of {
                GHC.Types.I# d_s4Fkf [Occ=Once] ->
                    case eta_s4Fka of {
                      GHC.Int.I8# x_s4Fkh [Occ=Once] ->
                          case plusAddr# [addr_s4Fkd d_s4Fkf] of sat_s4Fki {
                            __DEFAULT ->
                                case
                                    writeInt8OffAddr# [sat_s4Fki 0# x_s4Fkh eta1_s4Fkb]
                                of
                                s2_s4Fkj
                                { __DEFAULT -> (#,#) [s2_s4Fkj GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int8
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt8_$calignment
                                                Foreign.Storable.$fStorableInt8_$calignment
                                                GHC.Storable.readInt8OffPtr1
                                                GHC.Storable.writeInt8OffPtr1
                                                Foreign.Storable.$fStorableInt23
                                                Foreign.Storable.$fStorableInt22
                                                Foreign.Storable.$fStorableInt21
                                                Foreign.Storable.$fStorableInt20];

Foreign.Storable.$fStorableWord15
  :: GHC.Ptr.Ptr GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fkk eta_s4Fkl]
        case ptr_s4Fkk of {
          GHC.Ptr.Ptr a_s4Fkn [Occ=Once] ->
              case readWord64OffAddr# [a_s4Fkn 0# eta_s4Fkl] of {
                (#,#) ipv_s4Fkp [Occ=Once] ipv1_s4Fkq [Occ=Once] ->
                    let {
                      sat_s4Fkr [Occ=Once] :: GHC.Word.Word64
                      [LclId] =
                          CCCS GHC.Word.W64#! [ipv1_s4Fkq];
                    } in  (#,#) [ipv_s4Fkp sat_s4Fkr];
              };
        };

Foreign.Storable.$fStorableWord18
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fks off_s4Fkt eta_s4Fku]
        case ptr_s4Fks of {
          GHC.Ptr.Ptr addr_s4Fkw [Occ=Once] ->
              case off_s4Fkt of {
                GHC.Types.I# d_s4Fky [Occ=Once] ->
                    case plusAddr# [addr_s4Fkw d_s4Fky] of sat_s4Fkz {
                      __DEFAULT ->
                          case readWord64OffAddr# [sat_s4Fkz 0# eta_s4Fku] of {
                            (#,#) ipv_s4FkB [Occ=Once] ipv1_s4FkC [Occ=Once] ->
                                let {
                                  sat_s4FkD [Occ=Once] :: GHC.Word.Word64
                                  [LclId] =
                                      CCCS GHC.Word.W64#! [ipv1_s4FkC];
                                } in  (#,#) [ipv_s4FkB sat_s4FkD];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord14
  :: GHC.Ptr.Ptr GHC.Word.Word64
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FkE ds2_s4FkF eta_s4FkG]
        case ptr_s4FkE of {
          GHC.Ptr.Ptr a_s4FkI [Occ=Once] ->
              case ds2_s4FkF of {
                GHC.Word.W64# x_s4FkK [Occ=Once] ->
                    case
                        writeWord64OffAddr# [a_s4FkI 0# x_s4FkK eta_s4FkG]
                    of
                    s2_s4FkL
                    { __DEFAULT -> (#,#) [s2_s4FkL GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord17
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FkM off_s4FkN eta_s4FkO eta1_s4FkP]
        case ptr_s4FkM of {
          GHC.Ptr.Ptr addr_s4FkR [Occ=Once] ->
              case off_s4FkN of {
                GHC.Types.I# d_s4FkT [Occ=Once] ->
                    case eta_s4FkO of {
                      GHC.Word.W64# x_s4FkV [Occ=Once] ->
                          case plusAddr# [addr_s4FkR d_s4FkT] of sat_s4FkW {
                            __DEFAULT ->
                                case
                                    writeWord64OffAddr# [sat_s4FkW 0# x_s4FkV eta1_s4FkP]
                                of
                                s2_s4FkX
                                { __DEFAULT -> (#,#) [s2_s4FkX GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word64
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord64_$calignment
                                                Foreign.Storable.$fStorableWord64_$calignment
                                                GHC.Storable.readWord64OffPtr1
                                                GHC.Storable.writeWord64OffPtr1
                                                Foreign.Storable.$fStorableWord18
                                                Foreign.Storable.$fStorableWord17
                                                Foreign.Storable.$fStorableWord15
                                                Foreign.Storable.$fStorableWord14];

Foreign.Storable.$fStorableWord11
  :: GHC.Ptr.Ptr GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word32 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FkY eta_s4FkZ]
        case ptr_s4FkY of {
          GHC.Ptr.Ptr a_s4Fl1 [Occ=Once] ->
              case readWord32OffAddr# [a_s4Fl1 0# eta_s4FkZ] of {
                (#,#) ipv_s4Fl3 [Occ=Once] ipv1_s4Fl4 [Occ=Once] ->
                    let {
                      sat_s4Fl5 [Occ=Once] :: GHC.Word.Word32
                      [LclId] =
                          CCCS GHC.Word.W32#! [ipv1_s4Fl4];
                    } in  (#,#) [ipv_s4Fl3 sat_s4Fl5];
              };
        };

Foreign.Storable.$fStorableWord13
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fl6 off_s4Fl7 eta_s4Fl8]
        case ptr_s4Fl6 of {
          GHC.Ptr.Ptr addr_s4Fla [Occ=Once] ->
              case off_s4Fl7 of {
                GHC.Types.I# d_s4Flc [Occ=Once] ->
                    case plusAddr# [addr_s4Fla d_s4Flc] of sat_s4Fld {
                      __DEFAULT ->
                          case readWord32OffAddr# [sat_s4Fld 0# eta_s4Fl8] of {
                            (#,#) ipv_s4Flf [Occ=Once] ipv1_s4Flg [Occ=Once] ->
                                let {
                                  sat_s4Flh [Occ=Once] :: GHC.Word.Word32
                                  [LclId] =
                                      CCCS GHC.Word.W32#! [ipv1_s4Flg];
                                } in  (#,#) [ipv_s4Flf sat_s4Flh];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord10
  :: GHC.Ptr.Ptr GHC.Word.Word32
     -> GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fli ds2_s4Flj eta_s4Flk]
        case ptr_s4Fli of {
          GHC.Ptr.Ptr a_s4Flm [Occ=Once] ->
              case ds2_s4Flj of {
                GHC.Word.W32# x_s4Flo [Occ=Once] ->
                    case
                        writeWord32OffAddr# [a_s4Flm 0# x_s4Flo eta_s4Flk]
                    of
                    s2_s4Flp
                    { __DEFAULT -> (#,#) [s2_s4Flp GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord12
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Flq off_s4Flr eta_s4Fls eta1_s4Flt]
        case ptr_s4Flq of {
          GHC.Ptr.Ptr addr_s4Flv [Occ=Once] ->
              case off_s4Flr of {
                GHC.Types.I# d_s4Flx [Occ=Once] ->
                    case eta_s4Fls of {
                      GHC.Word.W32# x_s4Flz [Occ=Once] ->
                          case plusAddr# [addr_s4Flv d_s4Flx] of sat_s4FlA {
                            __DEFAULT ->
                                case
                                    writeWord32OffAddr# [sat_s4FlA 0# x_s4Flz eta1_s4Flt]
                                of
                                s2_s4FlB
                                { __DEFAULT -> (#,#) [s2_s4FlB GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word32
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord32_$calignment
                                                Foreign.Storable.$fStorableWord32_$calignment
                                                GHC.Storable.readWord32OffPtr1
                                                GHC.Storable.writeWord32OffPtr1
                                                Foreign.Storable.$fStorableWord13
                                                Foreign.Storable.$fStorableWord12
                                                Foreign.Storable.$fStorableWord11
                                                Foreign.Storable.$fStorableWord10];

Foreign.Storable.$fStorableWord6
  :: GHC.Ptr.Ptr GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word16 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FlC eta_s4FlD]
        case ptr_s4FlC of {
          GHC.Ptr.Ptr a_s4FlF [Occ=Once] ->
              case readWord16OffAddr# [a_s4FlF 0# eta_s4FlD] of {
                (#,#) ipv_s4FlH [Occ=Once] ipv1_s4FlI [Occ=Once] ->
                    let {
                      sat_s4FlJ [Occ=Once] :: GHC.Word.Word16
                      [LclId] =
                          CCCS GHC.Word.W16#! [ipv1_s4FlI];
                    } in  (#,#) [ipv_s4FlH sat_s4FlJ];
              };
        };

Foreign.Storable.$fStorableWord9
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FlK off_s4FlL eta_s4FlM]
        case ptr_s4FlK of {
          GHC.Ptr.Ptr addr_s4FlO [Occ=Once] ->
              case off_s4FlL of {
                GHC.Types.I# d_s4FlQ [Occ=Once] ->
                    case plusAddr# [addr_s4FlO d_s4FlQ] of sat_s4FlR {
                      __DEFAULT ->
                          case readWord16OffAddr# [sat_s4FlR 0# eta_s4FlM] of {
                            (#,#) ipv_s4FlT [Occ=Once] ipv1_s4FlU [Occ=Once] ->
                                let {
                                  sat_s4FlV [Occ=Once] :: GHC.Word.Word16
                                  [LclId] =
                                      CCCS GHC.Word.W16#! [ipv1_s4FlU];
                                } in  (#,#) [ipv_s4FlT sat_s4FlV];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord5
  :: GHC.Ptr.Ptr GHC.Word.Word16
     -> GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FlW ds2_s4FlX eta_s4FlY]
        case ptr_s4FlW of {
          GHC.Ptr.Ptr a_s4Fm0 [Occ=Once] ->
              case ds2_s4FlX of {
                GHC.Word.W16# x_s4Fm2 [Occ=Once] ->
                    case
                        writeWord16OffAddr# [a_s4Fm0 0# x_s4Fm2 eta_s4FlY]
                    of
                    s2_s4Fm3
                    { __DEFAULT -> (#,#) [s2_s4Fm3 GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord7
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fm4 off_s4Fm5 eta_s4Fm6 eta1_s4Fm7]
        case ptr_s4Fm4 of {
          GHC.Ptr.Ptr addr_s4Fm9 [Occ=Once] ->
              case off_s4Fm5 of {
                GHC.Types.I# d_s4Fmb [Occ=Once] ->
                    case eta_s4Fm6 of {
                      GHC.Word.W16# x_s4Fmd [Occ=Once] ->
                          case plusAddr# [addr_s4Fm9 d_s4Fmb] of sat_s4Fme {
                            __DEFAULT ->
                                case
                                    writeWord16OffAddr# [sat_s4Fme 0# x_s4Fmd eta1_s4Fm7]
                                of
                                s2_s4Fmf
                                { __DEFAULT -> (#,#) [s2_s4Fmf GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word16
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord16_$calignment
                                                Foreign.Storable.$fStorableWord16_$calignment
                                                GHC.Storable.readWord16OffPtr1
                                                GHC.Storable.writeWord16OffPtr1
                                                Foreign.Storable.$fStorableWord9
                                                Foreign.Storable.$fStorableWord7
                                                Foreign.Storable.$fStorableWord6
                                                Foreign.Storable.$fStorableWord5];

Foreign.Storable.$fStorableDouble2
  :: GHC.Ptr.Ptr GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Double #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fmg eta_s4Fmh]
        case ptr_s4Fmg of {
          GHC.Ptr.Ptr a_s4Fmj [Occ=Once] ->
              case readDoubleOffAddr# [a_s4Fmj 0# eta_s4Fmh] of {
                (#,#) ipv_s4Fml [Occ=Once] ipv1_s4Fmm [Occ=Once] ->
                    let {
                      sat_s4Fmn [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [ipv1_s4Fmm];
                    } in  (#,#) [ipv_s4Fml sat_s4Fmn];
              };
        };

Foreign.Storable.$fStorableDouble4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Double #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fmo off_s4Fmp eta_s4Fmq]
        case ptr_s4Fmo of {
          GHC.Ptr.Ptr addr_s4Fms [Occ=Once] ->
              case off_s4Fmp of {
                GHC.Types.I# d_s4Fmu [Occ=Once] ->
                    case plusAddr# [addr_s4Fms d_s4Fmu] of sat_s4Fmv {
                      __DEFAULT ->
                          case readDoubleOffAddr# [sat_s4Fmv 0# eta_s4Fmq] of {
                            (#,#) ipv_s4Fmx [Occ=Once] ipv1_s4Fmy [Occ=Once] ->
                                let {
                                  sat_s4Fmz [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [ipv1_s4Fmy];
                                } in  (#,#) [ipv_s4Fmx sat_s4Fmz];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableDouble1
  :: GHC.Ptr.Ptr GHC.Types.Double
     -> GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FmA ds2_s4FmB eta_s4FmC]
        case ptr_s4FmA of {
          GHC.Ptr.Ptr a_s4FmE [Occ=Once] ->
              case ds2_s4FmB of {
                GHC.Types.D# x_s4FmG [Occ=Once] ->
                    case
                        writeDoubleOffAddr# [a_s4FmE 0# x_s4FmG eta_s4FmC]
                    of
                    s2_s4FmH
                    { __DEFAULT -> (#,#) [s2_s4FmH GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableDouble3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FmI off_s4FmJ eta_s4FmK eta1_s4FmL]
        case ptr_s4FmI of {
          GHC.Ptr.Ptr addr_s4FmN [Occ=Once] ->
              case off_s4FmJ of {
                GHC.Types.I# d_s4FmP [Occ=Once] ->
                    case eta_s4FmK of {
                      GHC.Types.D# x_s4FmR [Occ=Once] ->
                          case plusAddr# [addr_s4FmN d_s4FmP] of sat_s4FmS {
                            __DEFAULT ->
                                case
                                    writeDoubleOffAddr# [sat_s4FmS 0# x_s4FmR eta1_s4FmL]
                                of
                                s2_s4FmT
                                { __DEFAULT -> (#,#) [s2_s4FmT GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Double
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableDouble_$calignment
                                                Foreign.Storable.$fStorableDouble_$calignment
                                                GHC.Storable.readDoubleOffPtr1
                                                GHC.Storable.writeDoubleOffPtr1
                                                Foreign.Storable.$fStorableDouble4
                                                Foreign.Storable.$fStorableDouble3
                                                Foreign.Storable.$fStorableDouble2
                                                Foreign.Storable.$fStorableDouble1];

Foreign.Storable.$fStorableFloat2
  :: GHC.Ptr.Ptr GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Float #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FmU eta_s4FmV]
        case ptr_s4FmU of {
          GHC.Ptr.Ptr a_s4FmX [Occ=Once] ->
              case readFloatOffAddr# [a_s4FmX 0# eta_s4FmV] of {
                (#,#) ipv_s4FmZ [Occ=Once] ipv1_s4Fn0 [Occ=Once] ->
                    let {
                      sat_s4Fn1 [Occ=Once] :: GHC.Types.Float
                      [LclId] =
                          CCCS GHC.Types.F#! [ipv1_s4Fn0];
                    } in  (#,#) [ipv_s4FmZ sat_s4Fn1];
              };
        };

Foreign.Storable.$fStorableFloat4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Float #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fn2 off_s4Fn3 eta_s4Fn4]
        case ptr_s4Fn2 of {
          GHC.Ptr.Ptr addr_s4Fn6 [Occ=Once] ->
              case off_s4Fn3 of {
                GHC.Types.I# d_s4Fn8 [Occ=Once] ->
                    case plusAddr# [addr_s4Fn6 d_s4Fn8] of sat_s4Fn9 {
                      __DEFAULT ->
                          case readFloatOffAddr# [sat_s4Fn9 0# eta_s4Fn4] of {
                            (#,#) ipv_s4Fnb [Occ=Once] ipv1_s4Fnc [Occ=Once] ->
                                let {
                                  sat_s4Fnd [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [ipv1_s4Fnc];
                                } in  (#,#) [ipv_s4Fnb sat_s4Fnd];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFloat1
  :: GHC.Ptr.Ptr GHC.Types.Float
     -> GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fne ds2_s4Fnf eta_s4Fng]
        case ptr_s4Fne of {
          GHC.Ptr.Ptr a_s4Fni [Occ=Once] ->
              case ds2_s4Fnf of {
                GHC.Types.F# x_s4Fnk [Occ=Once] ->
                    case
                        writeFloatOffAddr# [a_s4Fni 0# x_s4Fnk eta_s4Fng]
                    of
                    s2_s4Fnl
                    { __DEFAULT -> (#,#) [s2_s4Fnl GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableFloat3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fnm off_s4Fnn eta_s4Fno eta1_s4Fnp]
        case ptr_s4Fnm of {
          GHC.Ptr.Ptr addr_s4Fnr [Occ=Once] ->
              case off_s4Fnn of {
                GHC.Types.I# d_s4Fnt [Occ=Once] ->
                    case eta_s4Fno of {
                      GHC.Types.F# x_s4Fnv [Occ=Once] ->
                          case plusAddr# [addr_s4Fnr d_s4Fnt] of sat_s4Fnw {
                            __DEFAULT ->
                                case
                                    writeFloatOffAddr# [sat_s4Fnw 0# x_s4Fnv eta1_s4Fnp]
                                of
                                s2_s4Fnx
                                { __DEFAULT -> (#,#) [s2_s4Fnx GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Float
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFloat_$calignment
                                                Foreign.Storable.$fStorableFloat_$calignment
                                                GHC.Storable.readFloatOffPtr1
                                                GHC.Storable.writeFloatOffPtr1
                                                Foreign.Storable.$fStorableFloat4
                                                Foreign.Storable.$fStorableFloat3
                                                Foreign.Storable.$fStorableFloat2
                                                Foreign.Storable.$fStorableFloat1];

Foreign.Storable.$fStorableStablePtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Stable.StablePtr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Stable.StablePtr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fny eta_s4Fnz]
        case ptr_s4Fny of {
          GHC.Ptr.Ptr a1_s4FnB [Occ=Once] ->
              case readStablePtrOffAddr# [a1_s4FnB 0# eta_s4Fnz] of {
                (#,#) ipv_s4FnD [Occ=Once] ipv1_s4FnE [Occ=Once] ->
                    let {
                      sat_s4FnF [Occ=Once] :: GHC.Stable.StablePtr a_a4DpH
                      [LclId] =
                          CCCS GHC.Stable.StablePtr! [ipv1_s4FnE];
                    } in  (#,#) [ipv_s4FnD sat_s4FnF];
              };
        };

Foreign.Storable.$fStorableStablePtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Stable.StablePtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FnG off_s4FnH eta_s4FnI]
        case ptr_s4FnG of {
          GHC.Ptr.Ptr addr_s4FnK [Occ=Once] ->
              case off_s4FnH of {
                GHC.Types.I# d_s4FnM [Occ=Once] ->
                    case plusAddr# [addr_s4FnK d_s4FnM] of sat_s4FnN {
                      __DEFAULT ->
                          case readStablePtrOffAddr# [sat_s4FnN 0# eta_s4FnI] of {
                            (#,#) ipv_s4FnP [Occ=Once] ipv1_s4FnQ [Occ=Once] ->
                                let {
                                  sat_s4FnR [Occ=Once] :: GHC.Stable.StablePtr a_a4DpH
                                  [LclId] =
                                      CCCS GHC.Stable.StablePtr! [ipv1_s4FnQ];
                                } in  (#,#) [ipv_s4FnP sat_s4FnR];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Stable.StablePtr a)
     -> GHC.Stable.StablePtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FnS ds2_s4FnT eta_s4FnU]
        case ptr_s4FnS of {
          GHC.Ptr.Ptr a1_s4FnW [Occ=Once] ->
              case ds2_s4FnT of {
                GHC.Stable.StablePtr x_s4FnY [Occ=Once] ->
                    case
                        writeStablePtrOffAddr# [a1_s4FnW 0# x_s4FnY eta_s4FnU]
                    of
                    s2_s4FnZ
                    { __DEFAULT -> (#,#) [s2_s4FnZ GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Stable.StablePtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fo0 off_s4Fo1 eta_s4Fo2 eta1_s4Fo3]
        case ptr_s4Fo0 of {
          GHC.Ptr.Ptr addr_s4Fo5 [Occ=Once] ->
              case off_s4Fo1 of {
                GHC.Types.I# d_s4Fo7 [Occ=Once] ->
                    case eta_s4Fo2 of {
                      GHC.Stable.StablePtr x_s4Fo9 [Occ=Once] ->
                          case plusAddr# [addr_s4Fo5 d_s4Fo7] of sat_s4Foa {
                            __DEFAULT ->
                                case
                                    writeStablePtrOffAddr# [sat_s4Foa 0# x_s4Fo9 eta1_s4Fo3]
                                of
                                s2_s4Fob
                                { __DEFAULT -> (#,#) [s2_s4Fob GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Stable.StablePtr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableStablePtr_$calignment
                                                Foreign.Storable.$fStorableStablePtr_$calignment
                                                GHC.Storable.readStablePtrOffPtr1
                                                GHC.Storable.writeStablePtrOffPtr1
                                                Foreign.Storable.$fStorableStablePtr4
                                                Foreign.Storable.$fStorableStablePtr3
                                                Foreign.Storable.$fStorableStablePtr2
                                                Foreign.Storable.$fStorableStablePtr1];

Foreign.Storable.$fStorableFunPtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.FunPtr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.FunPtr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Foc eta_s4Fod]
        case ptr_s4Foc of {
          GHC.Ptr.Ptr a1_s4Fof [Occ=Once] ->
              case readAddrOffAddr# [a1_s4Fof 0# eta_s4Fod] of {
                (#,#) ipv_s4Foh [Occ=Once] ipv1_s4Foi [Occ=Once] ->
                    let {
                      sat_s4Foj [Occ=Once] :: GHC.Ptr.FunPtr a_a4Dqs
                      [LclId] =
                          CCCS GHC.Ptr.FunPtr! [ipv1_s4Foi];
                    } in  (#,#) [ipv_s4Foh sat_s4Foj];
              };
        };

Foreign.Storable.$fStorableFunPtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.FunPtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fok off_s4Fol eta_s4Fom]
        case ptr_s4Fok of {
          GHC.Ptr.Ptr addr_s4Foo [Occ=Once] ->
              case off_s4Fol of {
                GHC.Types.I# d_s4Foq [Occ=Once] ->
                    case plusAddr# [addr_s4Foo d_s4Foq] of sat_s4For {
                      __DEFAULT ->
                          case readAddrOffAddr# [sat_s4For 0# eta_s4Fom] of {
                            (#,#) ipv_s4Fot [Occ=Once] ipv1_s4Fou [Occ=Once] ->
                                let {
                                  sat_s4Fov [Occ=Once] :: GHC.Ptr.FunPtr a_a4Dqs
                                  [LclId] =
                                      CCCS GHC.Ptr.FunPtr! [ipv1_s4Fou];
                                } in  (#,#) [ipv_s4Fot sat_s4Fov];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.FunPtr a)
     -> GHC.Ptr.FunPtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fow ds2_s4Fox eta_s4Foy]
        case ptr_s4Fow of {
          GHC.Ptr.Ptr a1_s4FoA [Occ=Once] ->
              case ds2_s4Fox of {
                GHC.Ptr.FunPtr x_s4FoC [Occ=Once] ->
                    case
                        writeAddrOffAddr# [a1_s4FoA 0# x_s4FoC eta_s4Foy]
                    of
                    s2_s4FoD
                    { __DEFAULT -> (#,#) [s2_s4FoD GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Ptr.FunPtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FoE off_s4FoF eta_s4FoG eta1_s4FoH]
        case ptr_s4FoE of {
          GHC.Ptr.Ptr addr_s4FoJ [Occ=Once] ->
              case off_s4FoF of {
                GHC.Types.I# d_s4FoL [Occ=Once] ->
                    case eta_s4FoG of {
                      GHC.Ptr.FunPtr x_s4FoN [Occ=Once] ->
                          case plusAddr# [addr_s4FoJ d_s4FoL] of sat_s4FoO {
                            __DEFAULT ->
                                case
                                    writeAddrOffAddr# [sat_s4FoO 0# x_s4FoN eta1_s4FoH]
                                of
                                s2_s4FoP
                                { __DEFAULT -> (#,#) [s2_s4FoP GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Ptr.FunPtr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFunPtr_$calignment
                                                Foreign.Storable.$fStorableFunPtr_$calignment
                                                GHC.Storable.readFunPtrOffPtr1
                                                GHC.Storable.writeFunPtrOffPtr1
                                                Foreign.Storable.$fStorableFunPtr4
                                                Foreign.Storable.$fStorableFunPtr3
                                                Foreign.Storable.$fStorableFunPtr2
                                                Foreign.Storable.$fStorableFunPtr1];

Foreign.Storable.$fStorablePtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.Ptr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.Ptr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FoQ eta_s4FoR]
        case ptr_s4FoQ of {
          GHC.Ptr.Ptr a1_s4FoT [Occ=Once] ->
              case readAddrOffAddr# [a1_s4FoT 0# eta_s4FoR] of {
                (#,#) ipv_s4FoV [Occ=Once] ipv1_s4FoW [Occ=Once] ->
                    let {
                      sat_s4FoX [Occ=Once] :: GHC.Ptr.Ptr a_a4Drd
                      [LclId] =
                          CCCS GHC.Ptr.Ptr! [ipv1_s4FoW];
                    } in  (#,#) [ipv_s4FoV sat_s4FoX];
              };
        };

Foreign.Storable.$fStorablePtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.Ptr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FoY off_s4FoZ eta_s4Fp0]
        case ptr_s4FoY of {
          GHC.Ptr.Ptr addr_s4Fp2 [Occ=Once] ->
              case off_s4FoZ of {
                GHC.Types.I# d_s4Fp4 [Occ=Once] ->
                    case plusAddr# [addr_s4Fp2 d_s4Fp4] of sat_s4Fp5 {
                      __DEFAULT ->
                          case readAddrOffAddr# [sat_s4Fp5 0# eta_s4Fp0] of {
                            (#,#) ipv_s4Fp7 [Occ=Once] ipv1_s4Fp8 [Occ=Once] ->
                                let {
                                  sat_s4Fp9 [Occ=Once] :: GHC.Ptr.Ptr a_a4Drd
                                  [LclId] =
                                      CCCS GHC.Ptr.Ptr! [ipv1_s4Fp8];
                                } in  (#,#) [ipv_s4Fp7 sat_s4Fp9];
                          };
                    };
              };
        };

Foreign.Storable.$fStorablePtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.Ptr a)
     -> GHC.Ptr.Ptr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fpa ds2_s4Fpb eta_s4Fpc]
        case ptr_s4Fpa of {
          GHC.Ptr.Ptr a1_s4Fpe [Occ=Once] ->
              case ds2_s4Fpb of {
                GHC.Ptr.Ptr x_s4Fpg [Occ=Once] ->
                    case
                        writeAddrOffAddr# [a1_s4Fpe 0# x_s4Fpg eta_s4Fpc]
                    of
                    s2_s4Fph
                    { __DEFAULT -> (#,#) [s2_s4Fph GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorablePtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Ptr.Ptr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fpi off_s4Fpj eta_s4Fpk eta1_s4Fpl]
        case ptr_s4Fpi of {
          GHC.Ptr.Ptr addr_s4Fpn [Occ=Once] ->
              case off_s4Fpj of {
                GHC.Types.I# d_s4Fpp [Occ=Once] ->
                    case eta_s4Fpk of {
                      GHC.Ptr.Ptr x_s4Fpr [Occ=Once] ->
                          case plusAddr# [addr_s4Fpn d_s4Fpp] of sat_s4Fps {
                            __DEFAULT ->
                                case
                                    writeAddrOffAddr# [sat_s4Fps 0# x_s4Fpr eta1_s4Fpl]
                                of
                                s2_s4Fpt
                                { __DEFAULT -> (#,#) [s2_s4Fpt GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorablePtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Ptr.Ptr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorablePtr_$calignment
                                                Foreign.Storable.$fStorablePtr_$calignment
                                                GHC.Storable.readPtrOffPtr1
                                                GHC.Storable.writePtrOffPtr1
                                                Foreign.Storable.$fStorablePtr4
                                                Foreign.Storable.$fStorablePtr3
                                                Foreign.Storable.$fStorablePtr2
                                                Foreign.Storable.$fStorablePtr1];

Foreign.Storable.$fStorableWord2
  :: GHC.Ptr.Ptr GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Word #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fpu eta_s4Fpv]
        case ptr_s4Fpu of {
          GHC.Ptr.Ptr a_s4Fpx [Occ=Once] ->
              case readWordOffAddr# [a_s4Fpx 0# eta_s4Fpv] of {
                (#,#) ipv_s4Fpz [Occ=Once] ipv1_s4FpA [Occ=Once] ->
                    let {
                      sat_s4FpB [Occ=Once] :: GHC.Types.Word
                      [LclId] =
                          CCCS GHC.Types.W#! [ipv1_s4FpA];
                    } in  (#,#) [ipv_s4Fpz sat_s4FpB];
              };
        };

Foreign.Storable.$fStorableWord4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Word #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FpC off_s4FpD eta_s4FpE]
        case ptr_s4FpC of {
          GHC.Ptr.Ptr addr_s4FpG [Occ=Once] ->
              case off_s4FpD of {
                GHC.Types.I# d_s4FpI [Occ=Once] ->
                    case plusAddr# [addr_s4FpG d_s4FpI] of sat_s4FpJ {
                      __DEFAULT ->
                          case readWordOffAddr# [sat_s4FpJ 0# eta_s4FpE] of {
                            (#,#) ipv_s4FpL [Occ=Once] ipv1_s4FpM [Occ=Once] ->
                                let {
                                  sat_s4FpN [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv1_s4FpM];
                                } in  (#,#) [ipv_s4FpL sat_s4FpN];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord1
  :: GHC.Ptr.Ptr GHC.Types.Word
     -> GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FpO ds2_s4FpP eta_s4FpQ]
        case ptr_s4FpO of {
          GHC.Ptr.Ptr a_s4FpS [Occ=Once] ->
              case ds2_s4FpP of {
                GHC.Types.W# x_s4FpU [Occ=Once] ->
                    case writeWordOffAddr# [a_s4FpS 0# x_s4FpU eta_s4FpQ] of s2_s4FpV {
                      __DEFAULT -> (#,#) [s2_s4FpV GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FpW off_s4FpX eta_s4FpY eta1_s4FpZ]
        case ptr_s4FpW of {
          GHC.Ptr.Ptr addr_s4Fq1 [Occ=Once] ->
              case off_s4FpX of {
                GHC.Types.I# d_s4Fq3 [Occ=Once] ->
                    case eta_s4FpY of {
                      GHC.Types.W# x_s4Fq5 [Occ=Once] ->
                          case plusAddr# [addr_s4Fq1 d_s4Fq3] of sat_s4Fq6 {
                            __DEFAULT ->
                                case
                                    writeWordOffAddr# [sat_s4Fq6 0# x_s4Fq5 eta1_s4FpZ]
                                of
                                s2_s4Fq7
                                { __DEFAULT -> (#,#) [s2_s4Fq7 GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord_$calignment
                                                Foreign.Storable.$fStorableWord_$calignment
                                                GHC.Storable.readWordOffPtr1
                                                GHC.Storable.writeWordOffPtr1
                                                Foreign.Storable.$fStorableWord4
                                                Foreign.Storable.$fStorableWord3
                                                Foreign.Storable.$fStorableWord2
                                                Foreign.Storable.$fStorableWord1];

Foreign.Storable.$fStorableInt2
  :: GHC.Ptr.Ptr GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fq8 eta_s4Fq9]
        case ptr_s4Fq8 of {
          GHC.Ptr.Ptr a_s4Fqb [Occ=Once] ->
              case readIntOffAddr# [a_s4Fqb 0# eta_s4Fq9] of {
                (#,#) ipv_s4Fqd [Occ=Once] ipv1_s4Fqe [Occ=Once] ->
                    let {
                      sat_s4Fqf [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [ipv1_s4Fqe];
                    } in  (#,#) [ipv_s4Fqd sat_s4Fqf];
              };
        };

Foreign.Storable.$fStorableInt4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fqg off_s4Fqh eta_s4Fqi]
        case ptr_s4Fqg of {
          GHC.Ptr.Ptr addr_s4Fqk [Occ=Once] ->
              case off_s4Fqh of {
                GHC.Types.I# d_s4Fqm [Occ=Once] ->
                    case plusAddr# [addr_s4Fqk d_s4Fqm] of sat_s4Fqn {
                      __DEFAULT ->
                          case readIntOffAddr# [sat_s4Fqn 0# eta_s4Fqi] of {
                            (#,#) ipv_s4Fqp [Occ=Once] ipv1_s4Fqq [Occ=Once] ->
                                let {
                                  sat_s4Fqr [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s4Fqq];
                                } in  (#,#) [ipv_s4Fqp sat_s4Fqr];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt1
  :: GHC.Ptr.Ptr GHC.Types.Int
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fqs ds2_s4Fqt eta_s4Fqu]
        case ptr_s4Fqs of {
          GHC.Ptr.Ptr a_s4Fqw [Occ=Once] ->
              case ds2_s4Fqt of {
                GHC.Types.I# x_s4Fqy [Occ=Once] ->
                    case writeIntOffAddr# [a_s4Fqw 0# x_s4Fqy eta_s4Fqu] of s2_s4Fqz {
                      __DEFAULT -> (#,#) [s2_s4Fqz GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FqA off_s4FqB eta_s4FqC eta1_s4FqD]
        case ptr_s4FqA of {
          GHC.Ptr.Ptr addr_s4FqF [Occ=Once] ->
              case off_s4FqB of {
                GHC.Types.I# d_s4FqH [Occ=Once] ->
                    case eta_s4FqC of {
                      GHC.Types.I# x_s4FqJ [Occ=Once] ->
                          case plusAddr# [addr_s4FqF d_s4FqH] of sat_s4FqK {
                            __DEFAULT ->
                                case
                                    writeIntOffAddr# [sat_s4FqK 0# x_s4FqJ eta1_s4FqD]
                                of
                                s2_s4FqL
                                { __DEFAULT -> (#,#) [s2_s4FqL GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt_$calignment
                                                Foreign.Storable.$fStorableInt_$calignment
                                                GHC.Storable.readIntOffPtr1
                                                GHC.Storable.writeIntOffPtr1
                                                Foreign.Storable.$fStorableInt4
                                                Foreign.Storable.$fStorableInt3
                                                Foreign.Storable.$fStorableInt2
                                                Foreign.Storable.$fStorableInt1];

Foreign.Storable.$fStorableChar2
  :: GHC.Ptr.Ptr GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Char #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FqM eta_s4FqN]
        case ptr_s4FqM of {
          GHC.Ptr.Ptr a_s4FqP [Occ=Once] ->
              case readWideCharOffAddr# [a_s4FqP 0# eta_s4FqN] of {
                (#,#) ipv_s4FqR [Occ=Once] ipv1_s4FqS [Occ=Once] ->
                    let {
                      sat_s4FqT [Occ=Once] :: GHC.Types.Char
                      [LclId] =
                          CCCS GHC.Types.C#! [ipv1_s4FqS];
                    } in  (#,#) [ipv_s4FqR sat_s4FqT];
              };
        };

Foreign.Storable.$fStorableChar4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Char #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FqU off_s4FqV eta_s4FqW]
        case ptr_s4FqU of {
          GHC.Ptr.Ptr addr_s4FqY [Occ=Once] ->
              case off_s4FqV of {
                GHC.Types.I# d_s4Fr0 [Occ=Once] ->
                    case plusAddr# [addr_s4FqY d_s4Fr0] of sat_s4Fr1 {
                      __DEFAULT ->
                          case readWideCharOffAddr# [sat_s4Fr1 0# eta_s4FqW] of {
                            (#,#) ipv_s4Fr3 [Occ=Once] ipv1_s4Fr4 [Occ=Once] ->
                                let {
                                  sat_s4Fr5 [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ipv1_s4Fr4];
                                } in  (#,#) [ipv_s4Fr3 sat_s4Fr5];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableChar1
  :: GHC.Ptr.Ptr GHC.Types.Char
     -> GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fr6 ds2_s4Fr7 eta_s4Fr8]
        case ptr_s4Fr6 of {
          GHC.Ptr.Ptr a_s4Fra [Occ=Once] ->
              case ds2_s4Fr7 of {
                GHC.Types.C# x_s4Frc [Occ=Once] ->
                    case
                        writeWideCharOffAddr# [a_s4Fra 0# x_s4Frc eta_s4Fr8]
                    of
                    s2_s4Frd
                    { __DEFAULT -> (#,#) [s2_s4Frd GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableChar3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fre off_s4Frf eta_s4Frg eta1_s4Frh]
        case ptr_s4Fre of {
          GHC.Ptr.Ptr addr_s4Frj [Occ=Once] ->
              case off_s4Frf of {
                GHC.Types.I# d_s4Frl [Occ=Once] ->
                    case eta_s4Frg of {
                      GHC.Types.C# x_s4Frn [Occ=Once] ->
                          case plusAddr# [addr_s4Frj d_s4Frl] of sat_s4Fro {
                            __DEFAULT ->
                                case
                                    writeWideCharOffAddr# [sat_s4Fro 0# x_s4Frn eta1_s4Frh]
                                of
                                s2_s4Frp
                                { __DEFAULT -> (#,#) [s2_s4Frp GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Char
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableChar_$calignment
                                                Foreign.Storable.$fStorableChar_$calignment
                                                GHC.Storable.readWideCharOffPtr1
                                                GHC.Storable.writeWideCharOffPtr1
                                                Foreign.Storable.$fStorableChar4
                                                Foreign.Storable.$fStorableChar3
                                                Foreign.Storable.$fStorableChar2
                                                Foreign.Storable.$fStorableChar1];

Foreign.Storable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$trModule4];

Foreign.Storable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$trModule2];

Foreign.Storable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Foreign.Storable.$trModule3
                                     Foreign.Storable.$trModule1];

$krep_r4Ffk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Foreign.Storable.$tcStorable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep_r4Ffk];

Foreign.Storable.$tcStorable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Storable"#;

Foreign.Storable.$tcStorable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$tcStorable3];

Foreign.Storable.$tcStorable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9192657549155052097##
                                    13909834202100645491##
                                    Foreign.Storable.$trModule
                                    Foreign.Storable.$tcStorable2
                                    0#
                                    Foreign.Storable.$tcStorable1];

Foreign.Storable.$fStorableWord20
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word8 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Frq eta_s4Frr]
        case ptr_s4Frq of {
          GHC.Ptr.Ptr a_s4Frt [Occ=Once] ->
              case readWord8OffAddr# [a_s4Frt 0# eta_s4Frr] of {
                (#,#) ipv_s4Frv [Occ=Once] ipv1_s4Frw [Occ=Once] ->
                    let {
                      sat_s4Frx [Occ=Once] :: GHC.Word.Word8
                      [LclId] =
                          CCCS GHC.Word.W8#! [ipv1_s4Frw];
                    } in  (#,#) [ipv_s4Frv sat_s4Frx];
              };
        };

Foreign.Storable.$fStorableWord22
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fry off_s4Frz eta_s4FrA]
        case ptr_s4Fry of {
          GHC.Ptr.Ptr addr_s4FrC [Occ=Once] ->
              case off_s4Frz of {
                GHC.Types.I# d_s4FrE [Occ=Once] ->
                    case plusAddr# [addr_s4FrC d_s4FrE] of sat_s4FrF {
                      __DEFAULT ->
                          case readWord8OffAddr# [sat_s4FrF 0# eta_s4FrA] of {
                            (#,#) ipv_s4FrH [Occ=Once] ipv1_s4FrI [Occ=Once] ->
                                let {
                                  sat_s4FrJ [Occ=Once] :: GHC.Word.Word8
                                  [LclId] =
                                      CCCS GHC.Word.W8#! [ipv1_s4FrI];
                                } in  (#,#) [ipv_s4FrH sat_s4FrJ];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord19
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FrK ds2_s4FrL eta_s4FrM]
        case ptr_s4FrK of {
          GHC.Ptr.Ptr a_s4FrO [Occ=Once] ->
              case ds2_s4FrL of {
                GHC.Word.W8# x_s4FrQ [Occ=Once] ->
                    case
                        writeWord8OffAddr# [a_s4FrO 0# x_s4FrQ eta_s4FrM]
                    of
                    s2_s4FrR
                    { __DEFAULT -> (#,#) [s2_s4FrR GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord21
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FrS off_s4FrT eta_s4FrU eta1_s4FrV]
        case ptr_s4FrS of {
          GHC.Ptr.Ptr addr_s4FrX [Occ=Once] ->
              case off_s4FrT of {
                GHC.Types.I# d_s4FrZ [Occ=Once] ->
                    case eta_s4FrU of {
                      GHC.Word.W8# x_s4Fs1 [Occ=Once] ->
                          case plusAddr# [addr_s4FrX d_s4FrZ] of sat_s4Fs2 {
                            __DEFAULT ->
                                case
                                    writeWord8OffAddr# [sat_s4Fs2 0# x_s4Fs1 eta1_s4FrV]
                                of
                                s2_s4Fs3
                                { __DEFAULT -> (#,#) [s2_s4Fs3 GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word8
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord8_$calignment
                                                Foreign.Storable.$fStorableWord8_$calignment
                                                GHC.Storable.readWord8OffPtr1
                                                GHC.Storable.writeWord8OffPtr1
                                                Foreign.Storable.$fStorableWord22
                                                Foreign.Storable.$fStorableWord21
                                                Foreign.Storable.$fStorableWord20
                                                Foreign.Storable.$fStorableWord19];

Foreign.Storable.$fStorableRatio2
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=4,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,1*C1(C1(C1(U(U,U)))),A,A,A,1*C1(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fs4 $dIntegral_s4Fs5 p_s4Fs6 s_s4Fs7]
        case Foreign.Storable.peek $dStorable_s4Fs4 p_s4Fs6 s_s4Fs7 of {
          (#,#) ipv_s4Fs9 [Occ=Once] ipv1_s4Fsa [Occ=Once] ->
              case
                  Foreign.Storable.peekElemOff
                      $dStorable_s4Fs4 p_s4Fs6 Foreign.Storable.$fStorable()7 ipv_s4Fs9
              of
              { (#,#) ipv2_s4Fsc [Occ=Once] ipv3_s4Fsd [Occ=Once] ->
                    let {
                      sat_s4Fse [Occ=Once] :: GHC.Real.Ratio a_a4DgH
                      [LclId] =
                          [$dIntegral_s4Fs5 ipv1_s4Fsa ipv3_s4Fsd] \u []
                              GHC.Real.% $dIntegral_s4Fs5 ipv1_s4Fsa ipv3_s4Fsd;
                    } in  (#,#) [ipv2_s4Fsc sat_s4Fse];
              };
        };

Foreign.Storable.$fStorableRatio1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,A><L,U><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Fsf w1_s4Fsg w2_s4Fsh w3_s4Fsi w4_s4Fsj]
        case w3_s4Fsi of {
          GHC.Real.:% ww1_s4Fsl [Occ=Once] ww2_s4Fsm [Occ=Once] ->
              case Foreign.Storable.poke w_s4Fsf w2_s4Fsh ww1_s4Fsl w4_s4Fsj of {
                (#,#) ipv_s4Fso [Occ=Once] _ [Occ=Dead] ->
                    Foreign.Storable.pokeElemOff
                        w_s4Fsf
                        w2_s4Fsh
                        Foreign.Storable.$fStorable()7
                        ww2_s4Fsm
                        ipv_s4Fso;
              };
        };

Foreign.Storable.$fStorableBool6
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [p_s4Fsq i_s4Fsr eta_s4Fss]
        case p_s4Fsq of {
          GHC.Ptr.Ptr a_s4Fsu [Occ=Once] ->
              case i_s4Fsr of {
                GHC.Types.I# i1_s4Fsw [Occ=Once] ->
                    case readInt32OffAddr# [a_s4Fsu i1_s4Fsw eta_s4Fss] of {
                      (#,#) ipv_s4Fsy [Occ=Once] ipv1_s4Fsz [Occ=Once!] ->
                          let {
                            sat_s4FsB [Occ=Once] :: GHC.Types.Bool
                            [LclId] =
                                [ipv1_s4Fsz] \u []
                                    case ipv1_s4Fsz of {
                                      __DEFAULT -> GHC.Types.True [];
                                      0# -> GHC.Types.False [];
                                    };
                          } in  (#,#) [ipv_s4Fsy sat_s4FsB];
                    };
              };
        };

Foreign.Storable.$fStorableBool2
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FsC eta_s4FsD]
        case ptr_s4FsC of {
          GHC.Ptr.Ptr a_s4FsF [Occ=Once] ->
              case readInt32OffAddr# [a_s4FsF 0# eta_s4FsD] of {
                (#,#) ipv_s4FsH [Occ=Once] ipv1_s4FsI [Occ=Once!] ->
                    let {
                      sat_s4FsK [Occ=Once] :: GHC.Types.Bool
                      [LclId] =
                          [ipv1_s4FsI] \u []
                              case ipv1_s4FsI of {
                                __DEFAULT -> GHC.Types.True [];
                                0# -> GHC.Types.False [];
                              };
                    } in  (#,#) [ipv_s4FsH sat_s4FsK];
              };
        };

Foreign.Storable.$fStorableBool4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FsL off_s4FsM eta_s4FsN]
        case ptr_s4FsL of {
          GHC.Ptr.Ptr addr_s4FsP [Occ=Once] ->
              case off_s4FsM of {
                GHC.Types.I# d_s4FsR [Occ=Once] ->
                    case plusAddr# [addr_s4FsP d_s4FsR] of sat_s4FsS {
                      __DEFAULT ->
                          case readInt32OffAddr# [sat_s4FsS 0# eta_s4FsN] of {
                            (#,#) ipv_s4FsU [Occ=Once] ipv1_s4FsV [Occ=Once!] ->
                                let {
                                  sat_s4FsX [Occ=Once] :: GHC.Types.Bool
                                  [LclId] =
                                      [ipv1_s4FsV] \u []
                                          case ipv1_s4FsV of {
                                            __DEFAULT -> GHC.Types.True [];
                                            0# -> GHC.Types.False [];
                                          };
                                } in  (#,#) [ipv_s4FsU sat_s4FsX];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableBool1
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FsY x_s4FsZ eta_s4Ft0]
        case ptr_s4FsY of {
          GHC.Ptr.Ptr a_s4Ft2 [Occ=Once*] ->
              case x_s4FsZ of {
                GHC.Types.False ->
                    case writeInt32OffAddr# [a_s4Ft2 0# 0# eta_s4Ft0] of s2_s4Ft4 {
                      __DEFAULT -> (#,#) [s2_s4Ft4 GHC.Tuple.()];
                    };
                GHC.Types.True ->
                    case writeInt32OffAddr# [a_s4Ft2 0# 1# eta_s4Ft0] of s2_s4Ft5 {
                      __DEFAULT -> (#,#) [s2_s4Ft5 GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableBool3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ft6 off_s4Ft7 eta_s4Ft8 eta1_s4Ft9]
        case ptr_s4Ft6 of {
          GHC.Ptr.Ptr addr_s4Ftb [Occ=Once*] ->
              case off_s4Ft7 of {
                GHC.Types.I# d_s4Ftd [Occ=Once*] ->
                    case eta_s4Ft8 of {
                      GHC.Types.False ->
                          case plusAddr# [addr_s4Ftb d_s4Ftd] of sat_s4Ftf {
                            __DEFAULT ->
                                case writeInt32OffAddr# [sat_s4Ftf 0# 0# eta1_s4Ft9] of s2_s4Ftg {
                                  __DEFAULT -> (#,#) [s2_s4Ftg GHC.Tuple.()];
                                };
                          };
                      GHC.Types.True ->
                          case plusAddr# [addr_s4Ftb d_s4Ftd] of sat_s4Fth {
                            __DEFAULT ->
                                case writeInt32OffAddr# [sat_s4Fth 0# 1# eta1_s4Ft9] of s2_s4Fti {
                                  __DEFAULT -> (#,#) [s2_s4Fti GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableBool_$csizeOf
                                                Foreign.Storable.$fStorableBool_$csizeOf
                                                Foreign.Storable.$fStorableBool6
                                                Foreign.Storable.$fStorableBool5
                                                Foreign.Storable.$fStorableBool4
                                                Foreign.Storable.$fStorableBool3
                                                Foreign.Storable.$fStorableBool2
                                                Foreign.Storable.$fStorableBool1];

Foreign.Storable.$fStorable()2
  :: GHC.Ptr.Ptr ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><S,U>, Unf=OtherCon []] =
    [] \r [ds_s4Ftj s_s4Ftk] (#,#) [s_s4Ftk GHC.Tuple.()];

Foreign.Storable.$fStorable()1
  :: GHC.Ptr.Ptr ()
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_s4Ftl ds1_s4Ftm s_s4Ftn] (#,#) [s_s4Ftn GHC.Tuple.()];

lvl11_r4Ffl :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [137#];

lvl12_r4Ffm :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [31#];

lvl13_r4Ffn :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [40#];

lvl14_r4Ffo :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl11_r4Ffl
                                           lvl12_r4Ffm
                                           lvl11_r4Ffl
                                           lvl13_r4Ffn];

lvl15_r4Ffp :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl14_r4Ffo
                                                  GHC.Stack.Types.EmptyCallStack];

lvl16_r4Ffq :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl15_r4Ffp;

Foreign.Storable.$dmpeekElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
[GblId,
 Arity=3,
 Str=<S(LLLLC(C(S))LLL),U(1*C1(U(U)),A,A,A,1*C1(C1(U)),A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fto ptr_s4Ftp off_s4Ftq]
        let {
          sat_s4Ftw [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4Fto off_s4Ftq] \u []
                  case off_s4Ftq of {
                    GHC.Types.I# x_s4Fts [Occ=Once] ->
                        case Foreign.Storable.sizeOf $dStorable_s4Fto lvl16_r4Ffq of {
                          GHC.Types.I# y_s4Ftu [Occ=Once] ->
                              case *# [x_s4Fts y_s4Ftu] of sat_s4Ftv {
                                __DEFAULT -> GHC.Types.I# [sat_s4Ftv];
                              };
                        };
                  };
        } in 
          Foreign.Storable.peekByteOff $dStorable_s4Fto ptr_s4Ftp sat_s4Ftw;

Foreign.Storable.$dmpokeElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(C(S)))LL),U(1*C1(U(U)),A,A,A,A,1*C1(C1(C1(U))),A,A)><L,U><L,1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Ftx ptr_s4Fty off_s4Ftz val_s4FtA]
        let {
          sat_s4FtG [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4Ftx off_s4Ftz val_s4FtA] \u []
                  case off_s4Ftz of {
                    GHC.Types.I# x_s4FtC [Occ=Once] ->
                        case Foreign.Storable.sizeOf $dStorable_s4Ftx val_s4FtA of {
                          GHC.Types.I# y_s4FtE [Occ=Once] ->
                              case *# [x_s4FtC y_s4FtE] of sat_s4FtF {
                                __DEFAULT -> GHC.Types.I# [sat_s4FtF];
                              };
                        };
                  };
        } in 
          Foreign.Storable.pokeByteOff
              $dStorable_s4Ftx ptr_s4Fty sat_s4FtG val_s4FtA;

Foreign.Storable.$fStorable()4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FtH off_s4FtI s_s4FtJ] (#,#) [s_s4FtJ GHC.Tuple.()];

Foreign.Storable.$fStorable()6
  :: GHC.Ptr.Ptr ()
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FtK off_s4FtL s_s4FtM] (#,#) [s_s4FtM GHC.Tuple.()];

Foreign.Storable.$fStorable()3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FtN off_s4FtO ds_s4FtP s_s4FtQ]
        (#,#) [s_s4FtQ GHC.Tuple.()];

Foreign.Storable.$fStorable()5
  :: GHC.Ptr.Ptr ()
     -> GHC.Types.Int
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FtR off_s4FtS val_s4FtT eta_s4FtU]
        (#,#) [eta_s4FtU GHC.Tuple.()];

Foreign.Storable.$fStorable() [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorable()_$csizeOf
                                                Foreign.Storable.$fStorable()_$calignment
                                                Foreign.Storable.$fStorable()6
                                                Foreign.Storable.$fStorable()5
                                                Foreign.Storable.$fStorable()4
                                                Foreign.Storable.$fStorable()3
                                                Foreign.Storable.$fStorable()2
                                                Foreign.Storable.$fStorable()1];

lvl17_r4Ffr :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [237#];

lvl18_r4Ffs :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl17_r4Ffr
                                           lvl12_r4Ffm
                                           lvl17_r4Ffr
                                           lvl13_r4Ffn];

lvl19_r4Fft :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl18_r4Ffs
                                                  GHC.Stack.Types.EmptyCallStack];

Foreign.Storable.$fStorableRatio6 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl19_r4Fft;

Foreign.Storable.$fStorableRatio_$csizeOf
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(U(U)),A,A,A,A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4FtV $dIntegral_s4FtW]
        let {
          lvl20_s4FtX [Occ=OnceL!, Dmd=<L,U(U)>] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4FtV] \u []
                  Foreign.Storable.sizeOf
                      $dStorable_s4FtV Foreign.Storable.$fStorableRatio6; } in
        let {
          sat_s4Fu2 [Occ=OnceT[0]] :: GHC.Real.Ratio a_X4DnT -> GHC.Types.Int
          [LclId] =
              [lvl20_s4FtX] \r [ds_s4FtY]
                  case lvl20_s4FtX of {
                    GHC.Types.I# y_s4Fu0 [Occ=Once] ->
                        case *# [2# y_s4Fu0] of sat_s4Fu1 {
                          __DEFAULT -> GHC.Types.I# [sat_s4Fu1];
                        };
                  };
        } in  sat_s4Fu2;

Foreign.Storable.$fStorableRatio4
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fu3
           $dIntegral_s4Fu4
           ptr_s4Fu5
           off_s4Fu6
           eta_s4Fu7]
        let {
          sat_s4Fud [Occ=Once] :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnX)
          [LclId] =
              [ptr_s4Fu5 off_s4Fu6] \u []
                  case ptr_s4Fu5 of {
                    GHC.Ptr.Ptr addr_s4Fu9 [Occ=Once] ->
                        case off_s4Fu6 of {
                          GHC.Types.I# d_s4Fub [Occ=Once] ->
                              case plusAddr# [addr_s4Fu9 d_s4Fub] of sat_s4Fuc {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fuc];
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableRatio2
              $dStorable_s4Fu3 $dIntegral_s4Fu4 sat_s4Fud eta_s4Fu7;

Foreign.Storable.$fStorableRatio7
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S(SL)))L),U(1*C1(U(U)),A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fue
           $dIntegral_s4Fuf
           ptr_s4Fug
           off_s4Fuh
           eta_s4Fui]
        let {
          sat_s4Fus [Occ=Once] :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnY)
          [LclId] =
              [$dStorable_s4Fue ptr_s4Fug off_s4Fuh] \u []
                  case ptr_s4Fug of {
                    GHC.Ptr.Ptr addr_s4Fuk [Occ=Once] ->
                        case off_s4Fuh of {
                          GHC.Types.I# x_s4Fum [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf
                                      $dStorable_s4Fue Foreign.Storable.$fStorableRatio6
                              of
                              { GHC.Types.I# y_s4Fuo [Occ=Once] ->
                                    case *# [2# y_s4Fuo] of sat_s4Fup {
                                      __DEFAULT ->
                                          case *# [x_s4Fum sat_s4Fup] of sat_s4Fuq {
                                            __DEFAULT ->
                                                case plusAddr# [addr_s4Fuk sat_s4Fuq] of sat_s4Fur {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fur];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableRatio2
              $dStorable_s4Fue $dIntegral_s4Fuf sat_s4Fus eta_s4Fui;

Foreign.Storable.$w$cpokeByteOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Fut w1_s4Fuu w2_s4Fuv ww_s4Fuw ww1_s4Fux w3_s4Fuy]
        let {
          p_s4Fuz :: GHC.Ptr.Ptr (GHC.Real.Ratio a_s4EvU)
          [LclId] =
              [w1_s4Fuu w2_s4Fuv] \u []
                  case w1_s4Fuu of {
                    GHC.Ptr.Ptr addr_s4FuB [Occ=Once] ->
                        case w2_s4Fuv of {
                          GHC.Types.I# d_s4FuD [Occ=Once] ->
                              case plusAddr# [addr_s4FuB d_s4FuD] of sat_s4FuE {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4FuE];
                              };
                        };
                  };
        } in 
          case Foreign.Storable.poke w_s4Fut p_s4Fuz ww_s4Fuw w3_s4Fuy of {
            (#,#) ipv_s4FuG [Occ=Once] _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_s4Fut p_s4Fuz Foreign.Storable.$fStorable()7 ww1_s4Fux ipv_s4FuG;
          };

Foreign.Storable.$fStorableRatio3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,A><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4FuI w1_s4FuJ w2_s4FuK w3_s4FuL w4_s4FuM w5_s4FuN]
        case w4_s4FuM of {
          GHC.Real.:% ww1_s4FuP [Occ=Once] ww2_s4FuQ [Occ=Once] ->
              Foreign.Storable.$w$cpokeByteOff
                  w_s4FuI w2_s4FuK w3_s4FuL ww1_s4FuP ww2_s4FuQ w5_s4FuN;
        };

Foreign.Storable.$w$cpokeElemOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(1*C1(U(U)),A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4FuR w1_s4FuS w2_s4FuT ww_s4FuU ww1_s4FuV w3_s4FuW]
        let {
          p_s4FuX :: GHC.Ptr.Ptr (GHC.Real.Ratio a_s4Ew8)
          [LclId] =
              [w_s4FuR w1_s4FuS w2_s4FuT] \u []
                  case w1_s4FuS of {
                    GHC.Ptr.Ptr addr_s4FuZ [Occ=Once] ->
                        case w2_s4FuT of {
                          GHC.Types.I# x_s4Fv1 [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf w_s4FuR Foreign.Storable.$fStorableRatio6
                              of
                              { GHC.Types.I# y_s4Fv3 [Occ=Once] ->
                                    case *# [2# y_s4Fv3] of sat_s4Fv4 {
                                      __DEFAULT ->
                                          case *# [x_s4Fv1 sat_s4Fv4] of sat_s4Fv5 {
                                            __DEFAULT ->
                                                case plusAddr# [addr_s4FuZ sat_s4Fv5] of sat_s4Fv6 {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fv6];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case Foreign.Storable.poke w_s4FuR p_s4FuX ww_s4FuU w3_s4FuW of {
            (#,#) ipv_s4Fv8 [Occ=Once] _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_s4FuR p_s4FuX Foreign.Storable.$fStorable()7 ww1_s4FuV ipv_s4Fv8;
          };

Foreign.Storable.$fStorableRatio5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(C(U(U)),A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,A><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Fva w1_s4Fvb w2_s4Fvc w3_s4Fvd w4_s4Fve w5_s4Fvf]
        case w4_s4Fve of {
          GHC.Real.:% ww1_s4Fvh [Occ=Once] ww2_s4Fvi [Occ=Once] ->
              Foreign.Storable.$w$cpokeElemOff
                  w_s4Fva w2_s4Fvc w3_s4Fvd ww1_s4Fvh ww2_s4Fvi w5_s4Fvf;
        };

Foreign.Storable.$fStorableRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     Foreign.Storable.Storable (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(U(U)),1*C1(U),C(C1(C1(U(U,U)))),C(C1(C1(C1(U(U,U))))),A,A,C(C1(U(U,U))),C(C1(C1(U(U,A)))))><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dStorable_s4Fvj $dIntegral_s4Fvk]
        let {
          sat_s4Fvs [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B3 eta_B2 eta_B1]
                  Foreign.Storable.$fStorableRatio1
                      $dStorable_s4Fvj $dIntegral_s4Fvk eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s4Fvr [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B2 eta_B1]
                  Foreign.Storable.$fStorableRatio2
                      $dStorable_s4Fvj $dIntegral_s4Fvk eta_B2 eta_B1; } in
        let {
          sat_s4Fvq [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B4
                                                      eta_B3
                                                      eta_B2
                                                      eta_B1]
                  Foreign.Storable.$fStorableRatio3
                      $dStorable_s4Fvj $dIntegral_s4Fvk eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s4Fvp [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B3 eta_B2 eta_B1]
                  Foreign.Storable.$fStorableRatio4
                      $dStorable_s4Fvj $dIntegral_s4Fvk eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s4Fvo [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.Int -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B4
                                                      eta_B3
                                                      eta_B2
                                                      eta_B1]
                  Foreign.Storable.$fStorableRatio5
                      $dStorable_s4Fvj $dIntegral_s4Fvk eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s4Fvn [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.Int -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B3 eta_B2 eta_B1]
                  Foreign.Storable.$fStorableRatio7
                      $dStorable_s4Fvj $dIntegral_s4Fvk eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s4Fvm [Occ=Once] :: GHC.Real.Ratio a_X4DnU -> GHC.Types.Int
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \u []
                  Foreign.Storable.$fStorableRatio_$calignment
                      $dStorable_s4Fvj $dIntegral_s4Fvk; } in
        let {
          sat_s4Fvl [Occ=Once] :: GHC.Real.Ratio a_X4DnU -> GHC.Types.Int
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \u []
                  Foreign.Storable.$fStorableRatio_$csizeOf
                      $dStorable_s4Fvj $dIntegral_s4Fvk;
        } in 
          Foreign.Storable.C:Storable [sat_s4Fvl
                                       sat_s4Fvm
                                       sat_s4Fvn
                                       sat_s4Fvo
                                       sat_s4Fvp
                                       sat_s4Fvq
                                       sat_s4Fvr
                                       sat_s4Fvs];

Foreign.Storable.$wpokeW64 [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.Int#
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><S,1*U><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Fvt ww_s4Fvu w1_s4Fvv w2_s4Fvw]
        case ww_s4Fvu of ds_s4Fvx {
          __DEFAULT ->
              case w1_s4Fvv of {
                GHC.Word.W64# ipv_s4Fvz ->
                    case w_s4Fvt of wild_s4FvA {
                      GHC.Ptr.Ptr a_s4FvB [Occ=Once] ->
                          case narrow8Word# [ipv_s4Fvz] of sat_s4FvD {
                            __DEFAULT ->
                                case -# [ds_s4Fvx 1#] of sat_s4FvC {
                                  __DEFAULT ->
                                      case
                                          writeWord8OffAddr# [a_s4FvB sat_s4FvC sat_s4FvD w2_s4Fvw]
                                      of
                                      s2_s4FvE
                                      { __DEFAULT ->
                                            case uncheckedShiftRL# [ipv_s4Fvz 8#] of sat_s4FvG {
                                              __DEFAULT ->
                                                  let {
                                                    sat_s4FvH [Occ=Once] :: GHC.Word.Word64
                                                    [LclId] =
                                                        CCCS GHC.Word.W64#! [sat_s4FvG];
                                                  } in 
                                                    case -# [ds_s4Fvx 1#] of sat_s4FvF {
                                                      __DEFAULT ->
                                                          Foreign.Storable.$wpokeW64
                                                              wild_s4FvA
                                                              sat_s4FvF
                                                              sat_s4FvH
                                                              s2_s4FvE;
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
          0# -> (#,#) [w2_s4Fvw GHC.Tuple.()];
        };

Foreign.Storable.$w$cpoke [InlPrag=NOUSERINLINE[0]]
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.Word#
     -> GHC.Prim.Word#
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4FvI ww_s4FvJ ww1_s4FvK w1_s4FvL]
        let {
          sat_s4FvM [Occ=Once] :: GHC.Word.Word64
          [LclId] =
              CCCS GHC.Word.W64#! [ww_s4FvJ];
        } in 
          case Foreign.Storable.$wpokeW64 w_s4FvI 8# sat_s4FvM w1_s4FvL of {
            (#,#) ipv_s4FvO [Occ=Once] _ [Occ=Dead] ->
                let {
                  sat_s4FvU [Occ=Once] :: GHC.Word.Word64
                  [LclId] =
                      CCCS GHC.Word.W64#! [ww1_s4FvK]; } in
                let {
                  sat_s4FvT [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Ptr.Ptr GHC.Word.Word8
                  [LclId] =
                      [w_s4FvI] \s []
                          case w_s4FvI of {
                            GHC.Ptr.Ptr addr_s4FvR [Occ=Once] ->
                                case plusAddr# [addr_s4FvR 8#] of sat_s4FvS {
                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4FvS];
                                };
                          };
                } in  Foreign.Storable.$wpokeW64 sat_s4FvT 8# sat_s4FvU ipv_s4FvO;
          };

Foreign.Storable.$fStorableFingerprint1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4FvV w1_s4FvW w2_s4FvX]
        case w1_s4FvW of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4FvZ [Occ=Once]
                                           ww2_s4Fw0 [Occ=Once] ->
              Foreign.Storable.$w$cpoke w_s4FvV ww1_s4FvZ ww2_s4Fw0 w2_s4FvX;
        };

Foreign.Storable.$wpeekW64 [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.Int#
     -> GHC.Prim.Word#
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><S,1*U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Fw1 ww_s4Fw2 ww1_s4Fw3 w1_s4Fw4]
        case ww_s4Fw2 of ds_s4Fw5 {
          __DEFAULT ->
              case w_s4Fw1 of {
                GHC.Ptr.Ptr ipv_s4Fw7 ->
                    case readWord8OffAddr# [ipv_s4Fw7 0# w1_s4Fw4] of {
                      (#,#) ipv1_s4Fw9 [Occ=Once] ipv2_s4Fwa [Occ=Once] ->
                          case uncheckedShiftL# [ww1_s4Fw3 8#] of sat_s4Fwe {
                            __DEFAULT ->
                                case or# [sat_s4Fwe ipv2_s4Fwa] of sat_s4Fwf {
                                  __DEFAULT ->
                                      case -# [ds_s4Fw5 1#] of sat_s4Fwd {
                                        __DEFAULT ->
                                            case plusAddr# [ipv_s4Fw7 1#] of sat_s4Fwb {
                                              __DEFAULT ->
                                                  let {
                                                    sat_s4Fwc [Occ=Once]
                                                      :: GHC.Ptr.Ptr GHC.Word.Word8
                                                    [LclId] =
                                                        CCCS GHC.Ptr.Ptr! [sat_s4Fwb];
                                                  } in 
                                                    Foreign.Storable.$wpeekW64
                                                        sat_s4Fwc sat_s4Fwd sat_s4Fwf ipv1_s4Fw9;
                                            };
                                      };
                                };
                          };
                    };
              };
          0# ->
              let {
                sat_s4Fwg [Occ=Once] :: GHC.Word.Word64
                [LclId] =
                    CCCS GHC.Word.W64#! [ww1_s4Fw3];
              } in  (#,#) [w1_s4Fw4 sat_s4Fwg];
        };

Foreign.Storable.$fStorableFingerprint2
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [p0_s4Fwh eta_s4Fwi]
        case Foreign.Storable.$wpeekW64 p0_s4Fwh 8# 0## eta_s4Fwi of {
          (#,#) ipv_s4Fwk [Occ=Once] ipv1_s4Fwl [Occ=Once] ->
              let {
                sat_s4Fwp [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Ptr.Ptr GHC.Word.Word8
                [LclId] =
                    [p0_s4Fwh] \s []
                        case p0_s4Fwh of {
                          GHC.Ptr.Ptr addr_s4Fwn [Occ=Once] ->
                              case plusAddr# [addr_s4Fwn 8#] of sat_s4Fwo {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fwo];
                              };
                        };
              } in 
                case Foreign.Storable.$wpeekW64 sat_s4Fwp 8# 0## ipv_s4Fwk of {
                  (#,#) ipv2_s4Fwr [Occ=Once] ipv3_s4Fws [Occ=Once] ->
                      let {
                        sat_s4Fwt [Occ=Once] :: GHC.Fingerprint.Type.Fingerprint
                        [LclId] =
                            [ipv1_s4Fwl ipv3_s4Fws] \u []
                                GHC.Fingerprint.Type.$WFingerprint ipv1_s4Fwl ipv3_s4Fws;
                      } in  (#,#) [ipv2_s4Fwr sat_s4Fwt];
                };
        };

Foreign.Storable.$fStorableFingerprint4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fwu off_s4Fwv eta_s4Fww]
        let {
          sat_s4FwC [Occ=Once, Dmd=<L,U(U)>]
            :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
          [LclId] =
              [ptr_s4Fwu off_s4Fwv] \u []
                  case ptr_s4Fwu of {
                    GHC.Ptr.Ptr addr_s4Fwy [Occ=Once] ->
                        case off_s4Fwv of {
                          GHC.Types.I# d_s4FwA [Occ=Once] ->
                              case plusAddr# [addr_s4Fwy d_s4FwA] of sat_s4FwB {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4FwB];
                              };
                        };
                  };
        } in  Foreign.Storable.$fStorableFingerprint2 sat_s4FwC eta_s4Fww;

Foreign.Storable.$fStorableFingerprint6
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FwD off_s4FwE eta_s4FwF]
        let {
          sat_s4FwM [Occ=Once, Dmd=<L,U(U)>]
            :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
          [LclId] =
              [ptr_s4FwD off_s4FwE] \u []
                  case ptr_s4FwD of {
                    GHC.Ptr.Ptr addr_s4FwH [Occ=Once] ->
                        case off_s4FwE of {
                          GHC.Types.I# x_s4FwJ [Occ=Once] ->
                              case *# [x_s4FwJ 16#] of sat_s4FwK {
                                __DEFAULT ->
                                    case plusAddr# [addr_s4FwH sat_s4FwK] of sat_s4FwL {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_s4FwL];
                                    };
                              };
                        };
                  };
        } in  Foreign.Storable.$fStorableFingerprint2 sat_s4FwM eta_s4FwF;

Foreign.Storable.$fStorableFingerprint3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FwN off_s4FwO eta_s4FwP eta1_s4FwQ]
        case eta_s4FwP of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4FwS [Occ=Once]
                                           ww2_s4FwT [Occ=Once] ->
              let {
                sat_s4FwZ [Occ=Once, Dmd=<L,U(U)>]
                  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
                [LclId] =
                    [ptr_s4FwN off_s4FwO] \u []
                        case ptr_s4FwN of {
                          GHC.Ptr.Ptr addr_s4FwV [Occ=Once] ->
                              case off_s4FwO of {
                                GHC.Types.I# d_s4FwX [Occ=Once] ->
                                    case plusAddr# [addr_s4FwV d_s4FwX] of sat_s4FwY {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_s4FwY];
                                    };
                              };
                        };
              } in 
                Foreign.Storable.$w$cpoke sat_s4FwZ ww1_s4FwS ww2_s4FwT eta1_s4FwQ;
        };

Foreign.Storable.$fStorableFingerprint5
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Types.Int
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fx0 off_s4Fx1 val_s4Fx2 eta_s4Fx3]
        case val_s4Fx2 of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4Fx5 [Occ=Once]
                                           ww2_s4Fx6 [Occ=Once] ->
              let {
                sat_s4Fxd [Occ=Once, Dmd=<L,U(U)>]
                  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
                [LclId] =
                    [ptr_s4Fx0 off_s4Fx1] \u []
                        case ptr_s4Fx0 of {
                          GHC.Ptr.Ptr addr_s4Fx8 [Occ=Once] ->
                              case off_s4Fx1 of {
                                GHC.Types.I# x_s4Fxa [Occ=Once] ->
                                    case *# [x_s4Fxa 16#] of sat_s4Fxb {
                                      __DEFAULT ->
                                          case plusAddr# [addr_s4Fx8 sat_s4Fxb] of sat_s4Fxc {
                                            __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fxc];
                                          };
                                    };
                              };
                        };
              } in 
                Foreign.Storable.$w$cpoke sat_s4Fxd ww1_s4Fx5 ww2_s4Fx6 eta_s4Fx3;
        };

Foreign.Storable.$fStorableFingerprint [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFingerprint_$csizeOf
                                                Foreign.Storable.$fStorableFingerprint_$calignment
                                                Foreign.Storable.$fStorableFingerprint6
                                                Foreign.Storable.$fStorableFingerprint5
                                                Foreign.Storable.$fStorableFingerprint4
                                                Foreign.Storable.$fStorableFingerprint3
                                                Foreign.Storable.$fStorableFingerprint2
                                                Foreign.Storable.$fStorableFingerprint1];

Foreign.Storable.C:Storable
  :: forall a.
     (a -> GHC.Types.Int)
     -> (a -> GHC.Types.Int)
     -> (GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a)
     -> (GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ())
     -> (forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a)
     -> (forall b.
         GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ())
     -> (GHC.Ptr.Ptr a -> GHC.Types.IO a)
     -> (GHC.Ptr.Ptr a -> a -> GHC.Types.IO ())
     -> Foreign.Storable.Storable a
[GblId[DataCon],
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B8 eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Foreign.Storable.C:Storable [eta_B8
                                     eta_B7
                                     eta_B6
                                     eta_B5
                                     eta_B4
                                     eta_B3
                                     eta_B2
                                     eta_B1];


==================== STG syntax: ====================
2018-03-16 15:59:30.60491222 UTC

Foreign.Storable.sizeOf
  :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLL),U(U,A,A,A,A,A,A,A)>] =
    [] \r [v_s4Ffv]
        case v_s4Ffv of {
          Foreign.Storable.C:Storable v_s4Ffx [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Ffx;
        };

Foreign.Storable.alignment
  :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>] =
    [] \r [v_s4FfF]
        case v_s4FfF of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      v_s4FfI [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4FfI;
        };

Foreign.Storable.peekElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLL),U(A,A,U,A,A,A,A,A)>] =
    [] \r [v_s4FfP]
        case v_s4FfP of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4FfT [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4FfT;
        };

Foreign.Storable.pokeElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLL),U(A,A,A,U,A,A,A,A)>] =
    [] \r [v_s4FfZ]
        case v_s4FfZ of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Fg4 [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Fg4;
        };

Foreign.Storable.peekByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLL),U(A,A,A,A,U,A,A,A)>] =
    [] \r [v_s4Fg9]
        case v_s4Fg9 of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Fgf [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Fgf;
        };

Foreign.Storable.pokeByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLL),U(A,A,A,A,A,U,A,A)>] =
    [] \r [v_s4Fgj]
        case v_s4Fgj of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Fgq [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Fgq;
        };

Foreign.Storable.peek
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSL),U(A,A,A,A,A,A,U,A)>] =
    [] \r [v_s4Fgt]
        case v_s4Fgt of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4FgB [Occ=Once]
                                      _ [Occ=Dead] ->
              v_s4FgB;
        };

Foreign.Storable.poke
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLS),U(A,A,A,A,A,A,A,U)>] =
    [] \r [v_s4FgD]
        case v_s4FgD of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4FgM [Occ=Once] ->
              v_s4FgM;
        };

Foreign.Storable.$fStorable()7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Foreign.Storable.$fStorable()_$calignment :: () -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgN] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorable()8 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Foreign.Storable.$fStorable()_$csizeOf :: () -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgO] Foreign.Storable.$fStorable()8;

Foreign.Storable.$fStorableBool7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [4#];

Foreign.Storable.$fStorableChar_$calignment
  :: GHC.Types.Char -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgP] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableDouble5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

Foreign.Storable.$fStorableInt_$calignment
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgQ] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableWord_$calignment
  :: GHC.Types.Word -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgR] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorablePtr_$calignment
  :: forall a. GHC.Ptr.Ptr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgS] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFunPtr_$calignment
  :: forall a. GHC.Ptr.FunPtr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgT] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableStablePtr_$calignment
  :: forall a. GHC.Stable.StablePtr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgU] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFloat_$calignment
  :: GHC.Types.Float -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgV] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableDouble_$calignment
  :: GHC.Types.Double -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgW] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableWord8_$calignment
  :: GHC.Word.Word8 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgX] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorableInt10 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

Foreign.Storable.$fStorableWord16_$calignment
  :: GHC.Word.Word16 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgY] Foreign.Storable.$fStorableInt10;

Foreign.Storable.$fStorableWord32_$calignment
  :: GHC.Word.Word32 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FgZ] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableWord64_$calignment
  :: GHC.Word.Word64 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fh0] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableInt8_$calignment
  :: GHC.Int.Int8 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fh1] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorableInt16_$calignment
  :: GHC.Int.Int16 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fh2] Foreign.Storable.$fStorableInt10;

Foreign.Storable.$fStorableInt32_$calignment
  :: GHC.Int.Int32 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fh3] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableInt64_$calignment
  :: GHC.Int.Int64 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fh4] Foreign.Storable.$fStorableDouble5;

lvl_r4Ff9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

lvl1_r4Ffa :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_r4Ff9;

Foreign.Storable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl2_r4Ffb :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Foreign.Storable.$trModule4;

Foreign.Storable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foreign.Storable"#;

lvl3_r4Ffc :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Foreign.Storable.$trModule2;

lvl4_r4Ffd :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Foreign/Storable.hs"#;

lvl5_r4Ffe :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_r4Ffd;

lvl6_r4Fff :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [238#];

lvl7_r4Ffg :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [30#];

lvl8_r4Ffh :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [39#];

lvl9_r4Ffi :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl6_r4Fff
                                           lvl7_r4Ffg
                                           lvl6_r4Fff
                                           lvl8_r4Ffh];

lvl10_r4Ffj :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl9_r4Ffi
                                                  GHC.Stack.Types.EmptyCallStack];

Foreign.Storable.$fStorableRatio8 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl10_r4Ffj;

Foreign.Storable.$fStorableRatio_$calignment
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(U),A,A,A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fh5 $dIntegral_s4Fh6]
        let {
          lvl20_s4Fh7 [Occ=OnceL] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4Fh5] \u []
                  Foreign.Storable.alignment
                      $dStorable_s4Fh5 Foreign.Storable.$fStorableRatio8; } in
        let {
          sat_s4Fh9 [Occ=OnceT[0]] :: GHC.Real.Ratio a_a4DgH -> GHC.Types.Int
          [LclId] =
              [lvl20_s4Fh7] \r [ds_s4Fh8] lvl20_s4Fh7;
        } in  sat_s4Fh9;

Foreign.Storable.$fStorableFingerprint_$calignment
  :: GHC.Fingerprint.Type.Fingerprint -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fha] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFingerprint7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [16#];

Foreign.Storable.$fStorableFingerprint_$csizeOf
  :: GHC.Fingerprint.Type.Fingerprint -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Fhb] Foreign.Storable.$fStorableFingerprint7;

Foreign.Storable.$dmpoke
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fhc ptr_s4Fhd]
        Foreign.Storable.pokeElemOff
            $dStorable_s4Fhc ptr_s4Fhd Foreign.Storable.$fStorable()8;

Foreign.Storable.$dmpeek
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fhe ptr_s4Fhf]
        Foreign.Storable.peekElemOff
            $dStorable_s4Fhe ptr_s4Fhf Foreign.Storable.$fStorable()8;

Foreign.Storable.$dmpokeByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)),1*U(A,A,A,A,A,A,A,1*C1(U))><L,1*U(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fhg ptr_s4Fhh off_s4Fhi]
        let {
          sat_s4Fho [Occ=Once] :: GHC.Ptr.Ptr a_a4D8k
          [LclId] =
              [ptr_s4Fhh off_s4Fhi] \u []
                  case ptr_s4Fhh of {
                    GHC.Ptr.Ptr addr_s4Fhk [Occ=Once] ->
                        case off_s4Fhi of {
                          GHC.Types.I# d_s4Fhm [Occ=Once] ->
                              case plusAddr# [addr_s4Fhk d_s4Fhm] of sat_s4Fhn {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fhn];
                              };
                        };
                  };
        } in  Foreign.Storable.poke $dStorable_s4Fhg sat_s4Fho;

Foreign.Storable.$dmpeekByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(S)L),1*U(A,A,A,A,A,A,1*C1(U),A)><L,1*U(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fhp ptr_s4Fhq off_s4Fhr]
        let {
          sat_s4Fhx [Occ=Once] :: GHC.Ptr.Ptr a_a4D8k
          [LclId] =
              [ptr_s4Fhq off_s4Fhr] \u []
                  case ptr_s4Fhq of {
                    GHC.Ptr.Ptr addr_s4Fht [Occ=Once] ->
                        case off_s4Fhr of {
                          GHC.Types.I# d_s4Fhv [Occ=Once] ->
                              case plusAddr# [addr_s4Fht d_s4Fhv] of sat_s4Fhw {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fhw];
                              };
                        };
                  };
        } in  Foreign.Storable.peek $dStorable_s4Fhp sat_s4Fhx;

Foreign.Storable.$fStorableInt17
  :: GHC.Ptr.Ptr GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int64 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fhy void_0E]
        case ptr_s4Fhy of {
          GHC.Ptr.Ptr a_s4FhB [Occ=Once] ->
              case readInt64OffAddr# [a_s4FhB 0# GHC.Prim.void#] of {
                Unit# ipv1_s4FhE [Occ=Once] ->
                    let {
                      sat_s4FhF [Occ=Once] :: GHC.Int.Int64
                      [LclId] =
                          CCCS GHC.Int.I64#! [ipv1_s4FhE];
                    } in  Unit# [sat_s4FhF];
              };
        };

Foreign.Storable.$fStorableInt19
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FhG off_s4FhH void_0E]
        case ptr_s4FhG of {
          GHC.Ptr.Ptr addr_s4FhK [Occ=Once] ->
              case off_s4FhH of {
                GHC.Types.I# d_s4FhM [Occ=Once] ->
                    case plusAddr# [addr_s4FhK d_s4FhM] of sat_s4FhN {
                      __DEFAULT ->
                          case readInt64OffAddr# [sat_s4FhN 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4FhQ [Occ=Once] ->
                                let {
                                  sat_s4FhR [Occ=Once] :: GHC.Int.Int64
                                  [LclId] =
                                      CCCS GHC.Int.I64#! [ipv1_s4FhQ];
                                } in  Unit# [sat_s4FhR];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt15
  :: GHC.Ptr.Ptr GHC.Int.Int64
     -> GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FhS ds2_s4FhT void_0E]
        case ptr_s4FhS of {
          GHC.Ptr.Ptr a_s4FhW [Occ=Once] ->
              case ds2_s4FhT of {
                GHC.Int.I64# x_s4FhY [Occ=Once] ->
                    case
                        writeInt64OffAddr# [a_s4FhW 0# x_s4FhY GHC.Prim.void#]
                    of
                    s2_s4FhZ
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt18
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fi0 off_s4Fi1 eta_s4Fi2 void_0E]
        case ptr_s4Fi0 of {
          GHC.Ptr.Ptr addr_s4Fi5 [Occ=Once] ->
              case off_s4Fi1 of {
                GHC.Types.I# d_s4Fi7 [Occ=Once] ->
                    case eta_s4Fi2 of {
                      GHC.Int.I64# x_s4Fi9 [Occ=Once] ->
                          case plusAddr# [addr_s4Fi5 d_s4Fi7] of sat_s4Fia {
                            __DEFAULT ->
                                case
                                    writeInt64OffAddr# [sat_s4Fia 0# x_s4Fi9 GHC.Prim.void#]
                                of
                                s2_s4Fib
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int64
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt64_$calignment
                                                Foreign.Storable.$fStorableInt64_$calignment
                                                GHC.Storable.readInt64OffPtr1
                                                GHC.Storable.writeInt64OffPtr1
                                                Foreign.Storable.$fStorableInt19
                                                Foreign.Storable.$fStorableInt18
                                                Foreign.Storable.$fStorableInt17
                                                Foreign.Storable.$fStorableInt15];

Foreign.Storable.$fStorableInt12
  :: GHC.Ptr.Ptr GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int32 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fic void_0E]
        case ptr_s4Fic of {
          GHC.Ptr.Ptr a_s4Fif [Occ=Once] ->
              case readInt32OffAddr# [a_s4Fif 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Fii [Occ=Once] ->
                    let {
                      sat_s4Fij [Occ=Once] :: GHC.Int.Int32
                      [LclId] =
                          CCCS GHC.Int.I32#! [ipv1_s4Fii];
                    } in  Unit# [sat_s4Fij];
              };
        };

Foreign.Storable.$fStorableInt14
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fik off_s4Fil void_0E]
        case ptr_s4Fik of {
          GHC.Ptr.Ptr addr_s4Fio [Occ=Once] ->
              case off_s4Fil of {
                GHC.Types.I# d_s4Fiq [Occ=Once] ->
                    case plusAddr# [addr_s4Fio d_s4Fiq] of sat_s4Fir {
                      __DEFAULT ->
                          case readInt32OffAddr# [sat_s4Fir 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Fiu [Occ=Once] ->
                                let {
                                  sat_s4Fiv [Occ=Once] :: GHC.Int.Int32
                                  [LclId] =
                                      CCCS GHC.Int.I32#! [ipv1_s4Fiu];
                                } in  Unit# [sat_s4Fiv];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt11
  :: GHC.Ptr.Ptr GHC.Int.Int32
     -> GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fiw ds2_s4Fix void_0E]
        case ptr_s4Fiw of {
          GHC.Ptr.Ptr a_s4FiA [Occ=Once] ->
              case ds2_s4Fix of {
                GHC.Int.I32# x_s4FiC [Occ=Once] ->
                    case
                        writeInt32OffAddr# [a_s4FiA 0# x_s4FiC GHC.Prim.void#]
                    of
                    s2_s4FiD
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt13
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FiE off_s4FiF eta_s4FiG void_0E]
        case ptr_s4FiE of {
          GHC.Ptr.Ptr addr_s4FiJ [Occ=Once] ->
              case off_s4FiF of {
                GHC.Types.I# d_s4FiL [Occ=Once] ->
                    case eta_s4FiG of {
                      GHC.Int.I32# x_s4FiN [Occ=Once] ->
                          case plusAddr# [addr_s4FiJ d_s4FiL] of sat_s4FiO {
                            __DEFAULT ->
                                case
                                    writeInt32OffAddr# [sat_s4FiO 0# x_s4FiN GHC.Prim.void#]
                                of
                                s2_s4FiP
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int32
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt32_$calignment
                                                Foreign.Storable.$fStorableInt32_$calignment
                                                GHC.Storable.readInt32OffPtr1
                                                GHC.Storable.writeInt32OffPtr1
                                                Foreign.Storable.$fStorableInt14
                                                Foreign.Storable.$fStorableInt13
                                                Foreign.Storable.$fStorableInt12
                                                Foreign.Storable.$fStorableInt11];

Foreign.Storable.$fStorableBool_$csizeOf
  :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4FiQ] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableBool5
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Int
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [p_s4FiR i_s4FiS x_s4FiT void_0E]
        case p_s4FiR of {
          GHC.Ptr.Ptr a_s4FiW [Occ=Once*] ->
              case i_s4FiS of {
                GHC.Types.I# i1_s4FiY [Occ=Once*] ->
                    case x_s4FiT of {
                      GHC.Types.False ->
                          case
                              writeInt32OffAddr# [a_s4FiW i1_s4FiY 0# GHC.Prim.void#]
                          of
                          s2_s4Fj0
                          { (##) -> Unit# [GHC.Tuple.()];
                          };
                      GHC.Types.True ->
                          case
                              writeInt32OffAddr# [a_s4FiW i1_s4FiY 1# GHC.Prim.void#]
                          of
                          s2_s4Fj1
                          { (##) -> Unit# [GHC.Tuple.()];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt6
  :: GHC.Ptr.Ptr GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int16 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fj2 void_0E]
        case ptr_s4Fj2 of {
          GHC.Ptr.Ptr a_s4Fj5 [Occ=Once] ->
              case readInt16OffAddr# [a_s4Fj5 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Fj8 [Occ=Once] ->
                    let {
                      sat_s4Fj9 [Occ=Once] :: GHC.Int.Int16
                      [LclId] =
                          CCCS GHC.Int.I16#! [ipv1_s4Fj8];
                    } in  Unit# [sat_s4Fj9];
              };
        };

Foreign.Storable.$fStorableInt9
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fja off_s4Fjb void_0E]
        case ptr_s4Fja of {
          GHC.Ptr.Ptr addr_s4Fje [Occ=Once] ->
              case off_s4Fjb of {
                GHC.Types.I# d_s4Fjg [Occ=Once] ->
                    case plusAddr# [addr_s4Fje d_s4Fjg] of sat_s4Fjh {
                      __DEFAULT ->
                          case readInt16OffAddr# [sat_s4Fjh 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Fjk [Occ=Once] ->
                                let {
                                  sat_s4Fjl [Occ=Once] :: GHC.Int.Int16
                                  [LclId] =
                                      CCCS GHC.Int.I16#! [ipv1_s4Fjk];
                                } in  Unit# [sat_s4Fjl];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt5
  :: GHC.Ptr.Ptr GHC.Int.Int16
     -> GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fjm ds2_s4Fjn void_0E]
        case ptr_s4Fjm of {
          GHC.Ptr.Ptr a_s4Fjq [Occ=Once] ->
              case ds2_s4Fjn of {
                GHC.Int.I16# x_s4Fjs [Occ=Once] ->
                    case
                        writeInt16OffAddr# [a_s4Fjq 0# x_s4Fjs GHC.Prim.void#]
                    of
                    s2_s4Fjt
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt7
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fju off_s4Fjv eta_s4Fjw void_0E]
        case ptr_s4Fju of {
          GHC.Ptr.Ptr addr_s4Fjz [Occ=Once] ->
              case off_s4Fjv of {
                GHC.Types.I# d_s4FjB [Occ=Once] ->
                    case eta_s4Fjw of {
                      GHC.Int.I16# x_s4FjD [Occ=Once] ->
                          case plusAddr# [addr_s4Fjz d_s4FjB] of sat_s4FjE {
                            __DEFAULT ->
                                case
                                    writeInt16OffAddr# [sat_s4FjE 0# x_s4FjD GHC.Prim.void#]
                                of
                                s2_s4FjF
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int16
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt16_$calignment
                                                Foreign.Storable.$fStorableInt16_$calignment
                                                GHC.Storable.readInt16OffPtr1
                                                GHC.Storable.writeInt16OffPtr1
                                                Foreign.Storable.$fStorableInt9
                                                Foreign.Storable.$fStorableInt7
                                                Foreign.Storable.$fStorableInt6
                                                Foreign.Storable.$fStorableInt5];

Foreign.Storable.$fStorableInt21
  :: GHC.Ptr.Ptr GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int8 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FjG void_0E]
        case ptr_s4FjG of {
          GHC.Ptr.Ptr a_s4FjJ [Occ=Once] ->
              case readInt8OffAddr# [a_s4FjJ 0# GHC.Prim.void#] of {
                Unit# ipv1_s4FjM [Occ=Once] ->
                    let {
                      sat_s4FjN [Occ=Once] :: GHC.Int.Int8
                      [LclId] =
                          CCCS GHC.Int.I8#! [ipv1_s4FjM];
                    } in  Unit# [sat_s4FjN];
              };
        };

Foreign.Storable.$fStorableInt23
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FjO off_s4FjP void_0E]
        case ptr_s4FjO of {
          GHC.Ptr.Ptr addr_s4FjS [Occ=Once] ->
              case off_s4FjP of {
                GHC.Types.I# d_s4FjU [Occ=Once] ->
                    case plusAddr# [addr_s4FjS d_s4FjU] of sat_s4FjV {
                      __DEFAULT ->
                          case readInt8OffAddr# [sat_s4FjV 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4FjY [Occ=Once] ->
                                let {
                                  sat_s4FjZ [Occ=Once] :: GHC.Int.Int8
                                  [LclId] =
                                      CCCS GHC.Int.I8#! [ipv1_s4FjY];
                                } in  Unit# [sat_s4FjZ];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt20
  :: GHC.Ptr.Ptr GHC.Int.Int8
     -> GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fk0 ds2_s4Fk1 void_0E]
        case ptr_s4Fk0 of {
          GHC.Ptr.Ptr a_s4Fk4 [Occ=Once] ->
              case ds2_s4Fk1 of {
                GHC.Int.I8# x_s4Fk6 [Occ=Once] ->
                    case
                        writeInt8OffAddr# [a_s4Fk4 0# x_s4Fk6 GHC.Prim.void#]
                    of
                    s2_s4Fk7
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt22
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fk8 off_s4Fk9 eta_s4Fka void_0E]
        case ptr_s4Fk8 of {
          GHC.Ptr.Ptr addr_s4Fkd [Occ=Once] ->
              case off_s4Fk9 of {
                GHC.Types.I# d_s4Fkf [Occ=Once] ->
                    case eta_s4Fka of {
                      GHC.Int.I8# x_s4Fkh [Occ=Once] ->
                          case plusAddr# [addr_s4Fkd d_s4Fkf] of sat_s4Fki {
                            __DEFAULT ->
                                case
                                    writeInt8OffAddr# [sat_s4Fki 0# x_s4Fkh GHC.Prim.void#]
                                of
                                s2_s4Fkj
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int8
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt8_$calignment
                                                Foreign.Storable.$fStorableInt8_$calignment
                                                GHC.Storable.readInt8OffPtr1
                                                GHC.Storable.writeInt8OffPtr1
                                                Foreign.Storable.$fStorableInt23
                                                Foreign.Storable.$fStorableInt22
                                                Foreign.Storable.$fStorableInt21
                                                Foreign.Storable.$fStorableInt20];

Foreign.Storable.$fStorableWord15
  :: GHC.Ptr.Ptr GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fkk void_0E]
        case ptr_s4Fkk of {
          GHC.Ptr.Ptr a_s4Fkn [Occ=Once] ->
              case readWord64OffAddr# [a_s4Fkn 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Fkq [Occ=Once] ->
                    let {
                      sat_s4Fkr [Occ=Once] :: GHC.Word.Word64
                      [LclId] =
                          CCCS GHC.Word.W64#! [ipv1_s4Fkq];
                    } in  Unit# [sat_s4Fkr];
              };
        };

Foreign.Storable.$fStorableWord18
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fks off_s4Fkt void_0E]
        case ptr_s4Fks of {
          GHC.Ptr.Ptr addr_s4Fkw [Occ=Once] ->
              case off_s4Fkt of {
                GHC.Types.I# d_s4Fky [Occ=Once] ->
                    case plusAddr# [addr_s4Fkw d_s4Fky] of sat_s4Fkz {
                      __DEFAULT ->
                          case readWord64OffAddr# [sat_s4Fkz 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4FkC [Occ=Once] ->
                                let {
                                  sat_s4FkD [Occ=Once] :: GHC.Word.Word64
                                  [LclId] =
                                      CCCS GHC.Word.W64#! [ipv1_s4FkC];
                                } in  Unit# [sat_s4FkD];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord14
  :: GHC.Ptr.Ptr GHC.Word.Word64
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FkE ds2_s4FkF void_0E]
        case ptr_s4FkE of {
          GHC.Ptr.Ptr a_s4FkI [Occ=Once] ->
              case ds2_s4FkF of {
                GHC.Word.W64# x_s4FkK [Occ=Once] ->
                    case
                        writeWord64OffAddr# [a_s4FkI 0# x_s4FkK GHC.Prim.void#]
                    of
                    s2_s4FkL
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord17
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FkM off_s4FkN eta_s4FkO void_0E]
        case ptr_s4FkM of {
          GHC.Ptr.Ptr addr_s4FkR [Occ=Once] ->
              case off_s4FkN of {
                GHC.Types.I# d_s4FkT [Occ=Once] ->
                    case eta_s4FkO of {
                      GHC.Word.W64# x_s4FkV [Occ=Once] ->
                          case plusAddr# [addr_s4FkR d_s4FkT] of sat_s4FkW {
                            __DEFAULT ->
                                case
                                    writeWord64OffAddr# [sat_s4FkW 0# x_s4FkV GHC.Prim.void#]
                                of
                                s2_s4FkX
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word64
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord64_$calignment
                                                Foreign.Storable.$fStorableWord64_$calignment
                                                GHC.Storable.readWord64OffPtr1
                                                GHC.Storable.writeWord64OffPtr1
                                                Foreign.Storable.$fStorableWord18
                                                Foreign.Storable.$fStorableWord17
                                                Foreign.Storable.$fStorableWord15
                                                Foreign.Storable.$fStorableWord14];

Foreign.Storable.$fStorableWord11
  :: GHC.Ptr.Ptr GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word32 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FkY void_0E]
        case ptr_s4FkY of {
          GHC.Ptr.Ptr a_s4Fl1 [Occ=Once] ->
              case readWord32OffAddr# [a_s4Fl1 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Fl4 [Occ=Once] ->
                    let {
                      sat_s4Fl5 [Occ=Once] :: GHC.Word.Word32
                      [LclId] =
                          CCCS GHC.Word.W32#! [ipv1_s4Fl4];
                    } in  Unit# [sat_s4Fl5];
              };
        };

Foreign.Storable.$fStorableWord13
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fl6 off_s4Fl7 void_0E]
        case ptr_s4Fl6 of {
          GHC.Ptr.Ptr addr_s4Fla [Occ=Once] ->
              case off_s4Fl7 of {
                GHC.Types.I# d_s4Flc [Occ=Once] ->
                    case plusAddr# [addr_s4Fla d_s4Flc] of sat_s4Fld {
                      __DEFAULT ->
                          case readWord32OffAddr# [sat_s4Fld 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Flg [Occ=Once] ->
                                let {
                                  sat_s4Flh [Occ=Once] :: GHC.Word.Word32
                                  [LclId] =
                                      CCCS GHC.Word.W32#! [ipv1_s4Flg];
                                } in  Unit# [sat_s4Flh];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord10
  :: GHC.Ptr.Ptr GHC.Word.Word32
     -> GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fli ds2_s4Flj void_0E]
        case ptr_s4Fli of {
          GHC.Ptr.Ptr a_s4Flm [Occ=Once] ->
              case ds2_s4Flj of {
                GHC.Word.W32# x_s4Flo [Occ=Once] ->
                    case
                        writeWord32OffAddr# [a_s4Flm 0# x_s4Flo GHC.Prim.void#]
                    of
                    s2_s4Flp
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord12
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Flq off_s4Flr eta_s4Fls void_0E]
        case ptr_s4Flq of {
          GHC.Ptr.Ptr addr_s4Flv [Occ=Once] ->
              case off_s4Flr of {
                GHC.Types.I# d_s4Flx [Occ=Once] ->
                    case eta_s4Fls of {
                      GHC.Word.W32# x_s4Flz [Occ=Once] ->
                          case plusAddr# [addr_s4Flv d_s4Flx] of sat_s4FlA {
                            __DEFAULT ->
                                case
                                    writeWord32OffAddr# [sat_s4FlA 0# x_s4Flz GHC.Prim.void#]
                                of
                                s2_s4FlB
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word32
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord32_$calignment
                                                Foreign.Storable.$fStorableWord32_$calignment
                                                GHC.Storable.readWord32OffPtr1
                                                GHC.Storable.writeWord32OffPtr1
                                                Foreign.Storable.$fStorableWord13
                                                Foreign.Storable.$fStorableWord12
                                                Foreign.Storable.$fStorableWord11
                                                Foreign.Storable.$fStorableWord10];

Foreign.Storable.$fStorableWord6
  :: GHC.Ptr.Ptr GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word16 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FlC void_0E]
        case ptr_s4FlC of {
          GHC.Ptr.Ptr a_s4FlF [Occ=Once] ->
              case readWord16OffAddr# [a_s4FlF 0# GHC.Prim.void#] of {
                Unit# ipv1_s4FlI [Occ=Once] ->
                    let {
                      sat_s4FlJ [Occ=Once] :: GHC.Word.Word16
                      [LclId] =
                          CCCS GHC.Word.W16#! [ipv1_s4FlI];
                    } in  Unit# [sat_s4FlJ];
              };
        };

Foreign.Storable.$fStorableWord9
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FlK off_s4FlL void_0E]
        case ptr_s4FlK of {
          GHC.Ptr.Ptr addr_s4FlO [Occ=Once] ->
              case off_s4FlL of {
                GHC.Types.I# d_s4FlQ [Occ=Once] ->
                    case plusAddr# [addr_s4FlO d_s4FlQ] of sat_s4FlR {
                      __DEFAULT ->
                          case readWord16OffAddr# [sat_s4FlR 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4FlU [Occ=Once] ->
                                let {
                                  sat_s4FlV [Occ=Once] :: GHC.Word.Word16
                                  [LclId] =
                                      CCCS GHC.Word.W16#! [ipv1_s4FlU];
                                } in  Unit# [sat_s4FlV];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord5
  :: GHC.Ptr.Ptr GHC.Word.Word16
     -> GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FlW ds2_s4FlX void_0E]
        case ptr_s4FlW of {
          GHC.Ptr.Ptr a_s4Fm0 [Occ=Once] ->
              case ds2_s4FlX of {
                GHC.Word.W16# x_s4Fm2 [Occ=Once] ->
                    case
                        writeWord16OffAddr# [a_s4Fm0 0# x_s4Fm2 GHC.Prim.void#]
                    of
                    s2_s4Fm3
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord7
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fm4 off_s4Fm5 eta_s4Fm6 void_0E]
        case ptr_s4Fm4 of {
          GHC.Ptr.Ptr addr_s4Fm9 [Occ=Once] ->
              case off_s4Fm5 of {
                GHC.Types.I# d_s4Fmb [Occ=Once] ->
                    case eta_s4Fm6 of {
                      GHC.Word.W16# x_s4Fmd [Occ=Once] ->
                          case plusAddr# [addr_s4Fm9 d_s4Fmb] of sat_s4Fme {
                            __DEFAULT ->
                                case
                                    writeWord16OffAddr# [sat_s4Fme 0# x_s4Fmd GHC.Prim.void#]
                                of
                                s2_s4Fmf
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word16
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord16_$calignment
                                                Foreign.Storable.$fStorableWord16_$calignment
                                                GHC.Storable.readWord16OffPtr1
                                                GHC.Storable.writeWord16OffPtr1
                                                Foreign.Storable.$fStorableWord9
                                                Foreign.Storable.$fStorableWord7
                                                Foreign.Storable.$fStorableWord6
                                                Foreign.Storable.$fStorableWord5];

Foreign.Storable.$fStorableDouble2
  :: GHC.Ptr.Ptr GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Double #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fmg void_0E]
        case ptr_s4Fmg of {
          GHC.Ptr.Ptr a_s4Fmj [Occ=Once] ->
              case readDoubleOffAddr# [a_s4Fmj 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Fmm [Occ=Once] ->
                    let {
                      sat_s4Fmn [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [ipv1_s4Fmm];
                    } in  Unit# [sat_s4Fmn];
              };
        };

Foreign.Storable.$fStorableDouble4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Double #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fmo off_s4Fmp void_0E]
        case ptr_s4Fmo of {
          GHC.Ptr.Ptr addr_s4Fms [Occ=Once] ->
              case off_s4Fmp of {
                GHC.Types.I# d_s4Fmu [Occ=Once] ->
                    case plusAddr# [addr_s4Fms d_s4Fmu] of sat_s4Fmv {
                      __DEFAULT ->
                          case readDoubleOffAddr# [sat_s4Fmv 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Fmy [Occ=Once] ->
                                let {
                                  sat_s4Fmz [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [ipv1_s4Fmy];
                                } in  Unit# [sat_s4Fmz];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableDouble1
  :: GHC.Ptr.Ptr GHC.Types.Double
     -> GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FmA ds2_s4FmB void_0E]
        case ptr_s4FmA of {
          GHC.Ptr.Ptr a_s4FmE [Occ=Once] ->
              case ds2_s4FmB of {
                GHC.Types.D# x_s4FmG [Occ=Once] ->
                    case
                        writeDoubleOffAddr# [a_s4FmE 0# x_s4FmG GHC.Prim.void#]
                    of
                    s2_s4FmH
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableDouble3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FmI off_s4FmJ eta_s4FmK void_0E]
        case ptr_s4FmI of {
          GHC.Ptr.Ptr addr_s4FmN [Occ=Once] ->
              case off_s4FmJ of {
                GHC.Types.I# d_s4FmP [Occ=Once] ->
                    case eta_s4FmK of {
                      GHC.Types.D# x_s4FmR [Occ=Once] ->
                          case plusAddr# [addr_s4FmN d_s4FmP] of sat_s4FmS {
                            __DEFAULT ->
                                case
                                    writeDoubleOffAddr# [sat_s4FmS 0# x_s4FmR GHC.Prim.void#]
                                of
                                s2_s4FmT
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Double
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableDouble_$calignment
                                                Foreign.Storable.$fStorableDouble_$calignment
                                                GHC.Storable.readDoubleOffPtr1
                                                GHC.Storable.writeDoubleOffPtr1
                                                Foreign.Storable.$fStorableDouble4
                                                Foreign.Storable.$fStorableDouble3
                                                Foreign.Storable.$fStorableDouble2
                                                Foreign.Storable.$fStorableDouble1];

Foreign.Storable.$fStorableFloat2
  :: GHC.Ptr.Ptr GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Float #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FmU void_0E]
        case ptr_s4FmU of {
          GHC.Ptr.Ptr a_s4FmX [Occ=Once] ->
              case readFloatOffAddr# [a_s4FmX 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Fn0 [Occ=Once] ->
                    let {
                      sat_s4Fn1 [Occ=Once] :: GHC.Types.Float
                      [LclId] =
                          CCCS GHC.Types.F#! [ipv1_s4Fn0];
                    } in  Unit# [sat_s4Fn1];
              };
        };

Foreign.Storable.$fStorableFloat4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Float #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fn2 off_s4Fn3 void_0E]
        case ptr_s4Fn2 of {
          GHC.Ptr.Ptr addr_s4Fn6 [Occ=Once] ->
              case off_s4Fn3 of {
                GHC.Types.I# d_s4Fn8 [Occ=Once] ->
                    case plusAddr# [addr_s4Fn6 d_s4Fn8] of sat_s4Fn9 {
                      __DEFAULT ->
                          case readFloatOffAddr# [sat_s4Fn9 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Fnc [Occ=Once] ->
                                let {
                                  sat_s4Fnd [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [ipv1_s4Fnc];
                                } in  Unit# [sat_s4Fnd];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFloat1
  :: GHC.Ptr.Ptr GHC.Types.Float
     -> GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fne ds2_s4Fnf void_0E]
        case ptr_s4Fne of {
          GHC.Ptr.Ptr a_s4Fni [Occ=Once] ->
              case ds2_s4Fnf of {
                GHC.Types.F# x_s4Fnk [Occ=Once] ->
                    case
                        writeFloatOffAddr# [a_s4Fni 0# x_s4Fnk GHC.Prim.void#]
                    of
                    s2_s4Fnl
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableFloat3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fnm off_s4Fnn eta_s4Fno void_0E]
        case ptr_s4Fnm of {
          GHC.Ptr.Ptr addr_s4Fnr [Occ=Once] ->
              case off_s4Fnn of {
                GHC.Types.I# d_s4Fnt [Occ=Once] ->
                    case eta_s4Fno of {
                      GHC.Types.F# x_s4Fnv [Occ=Once] ->
                          case plusAddr# [addr_s4Fnr d_s4Fnt] of sat_s4Fnw {
                            __DEFAULT ->
                                case
                                    writeFloatOffAddr# [sat_s4Fnw 0# x_s4Fnv GHC.Prim.void#]
                                of
                                s2_s4Fnx
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Float
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFloat_$calignment
                                                Foreign.Storable.$fStorableFloat_$calignment
                                                GHC.Storable.readFloatOffPtr1
                                                GHC.Storable.writeFloatOffPtr1
                                                Foreign.Storable.$fStorableFloat4
                                                Foreign.Storable.$fStorableFloat3
                                                Foreign.Storable.$fStorableFloat2
                                                Foreign.Storable.$fStorableFloat1];

Foreign.Storable.$fStorableStablePtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Stable.StablePtr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Stable.StablePtr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fny void_0E]
        case ptr_s4Fny of {
          GHC.Ptr.Ptr a1_s4FnB [Occ=Once] ->
              case readStablePtrOffAddr# [a1_s4FnB 0# GHC.Prim.void#] of {
                Unit# ipv1_s4FnE [Occ=Once] ->
                    let {
                      sat_s4FnF [Occ=Once] :: GHC.Stable.StablePtr a_a4DpH
                      [LclId] =
                          CCCS GHC.Stable.StablePtr! [ipv1_s4FnE];
                    } in  Unit# [sat_s4FnF];
              };
        };

Foreign.Storable.$fStorableStablePtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Stable.StablePtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FnG off_s4FnH void_0E]
        case ptr_s4FnG of {
          GHC.Ptr.Ptr addr_s4FnK [Occ=Once] ->
              case off_s4FnH of {
                GHC.Types.I# d_s4FnM [Occ=Once] ->
                    case plusAddr# [addr_s4FnK d_s4FnM] of sat_s4FnN {
                      __DEFAULT ->
                          case readStablePtrOffAddr# [sat_s4FnN 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4FnQ [Occ=Once] ->
                                let {
                                  sat_s4FnR [Occ=Once] :: GHC.Stable.StablePtr a_a4DpH
                                  [LclId] =
                                      CCCS GHC.Stable.StablePtr! [ipv1_s4FnQ];
                                } in  Unit# [sat_s4FnR];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Stable.StablePtr a)
     -> GHC.Stable.StablePtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FnS ds2_s4FnT void_0E]
        case ptr_s4FnS of {
          GHC.Ptr.Ptr a1_s4FnW [Occ=Once] ->
              case ds2_s4FnT of {
                GHC.Stable.StablePtr x_s4FnY [Occ=Once] ->
                    case
                        writeStablePtrOffAddr# [a1_s4FnW 0# x_s4FnY GHC.Prim.void#]
                    of
                    s2_s4FnZ
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Stable.StablePtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fo0 off_s4Fo1 eta_s4Fo2 void_0E]
        case ptr_s4Fo0 of {
          GHC.Ptr.Ptr addr_s4Fo5 [Occ=Once] ->
              case off_s4Fo1 of {
                GHC.Types.I# d_s4Fo7 [Occ=Once] ->
                    case eta_s4Fo2 of {
                      GHC.Stable.StablePtr x_s4Fo9 [Occ=Once] ->
                          case plusAddr# [addr_s4Fo5 d_s4Fo7] of sat_s4Foa {
                            __DEFAULT ->
                                case
                                    writeStablePtrOffAddr# [sat_s4Foa 0# x_s4Fo9 GHC.Prim.void#]
                                of
                                s2_s4Fob
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Stable.StablePtr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableStablePtr_$calignment
                                                Foreign.Storable.$fStorableStablePtr_$calignment
                                                GHC.Storable.readStablePtrOffPtr1
                                                GHC.Storable.writeStablePtrOffPtr1
                                                Foreign.Storable.$fStorableStablePtr4
                                                Foreign.Storable.$fStorableStablePtr3
                                                Foreign.Storable.$fStorableStablePtr2
                                                Foreign.Storable.$fStorableStablePtr1];

Foreign.Storable.$fStorableFunPtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.FunPtr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.FunPtr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Foc void_0E]
        case ptr_s4Foc of {
          GHC.Ptr.Ptr a1_s4Fof [Occ=Once] ->
              case readAddrOffAddr# [a1_s4Fof 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Foi [Occ=Once] ->
                    let {
                      sat_s4Foj [Occ=Once] :: GHC.Ptr.FunPtr a_a4Dqs
                      [LclId] =
                          CCCS GHC.Ptr.FunPtr! [ipv1_s4Foi];
                    } in  Unit# [sat_s4Foj];
              };
        };

Foreign.Storable.$fStorableFunPtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.FunPtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fok off_s4Fol void_0E]
        case ptr_s4Fok of {
          GHC.Ptr.Ptr addr_s4Foo [Occ=Once] ->
              case off_s4Fol of {
                GHC.Types.I# d_s4Foq [Occ=Once] ->
                    case plusAddr# [addr_s4Foo d_s4Foq] of sat_s4For {
                      __DEFAULT ->
                          case readAddrOffAddr# [sat_s4For 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Fou [Occ=Once] ->
                                let {
                                  sat_s4Fov [Occ=Once] :: GHC.Ptr.FunPtr a_a4Dqs
                                  [LclId] =
                                      CCCS GHC.Ptr.FunPtr! [ipv1_s4Fou];
                                } in  Unit# [sat_s4Fov];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.FunPtr a)
     -> GHC.Ptr.FunPtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fow ds2_s4Fox void_0E]
        case ptr_s4Fow of {
          GHC.Ptr.Ptr a1_s4FoA [Occ=Once] ->
              case ds2_s4Fox of {
                GHC.Ptr.FunPtr x_s4FoC [Occ=Once] ->
                    case
                        writeAddrOffAddr# [a1_s4FoA 0# x_s4FoC GHC.Prim.void#]
                    of
                    s2_s4FoD
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Ptr.FunPtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FoE off_s4FoF eta_s4FoG void_0E]
        case ptr_s4FoE of {
          GHC.Ptr.Ptr addr_s4FoJ [Occ=Once] ->
              case off_s4FoF of {
                GHC.Types.I# d_s4FoL [Occ=Once] ->
                    case eta_s4FoG of {
                      GHC.Ptr.FunPtr x_s4FoN [Occ=Once] ->
                          case plusAddr# [addr_s4FoJ d_s4FoL] of sat_s4FoO {
                            __DEFAULT ->
                                case
                                    writeAddrOffAddr# [sat_s4FoO 0# x_s4FoN GHC.Prim.void#]
                                of
                                s2_s4FoP
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Ptr.FunPtr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFunPtr_$calignment
                                                Foreign.Storable.$fStorableFunPtr_$calignment
                                                GHC.Storable.readFunPtrOffPtr1
                                                GHC.Storable.writeFunPtrOffPtr1
                                                Foreign.Storable.$fStorableFunPtr4
                                                Foreign.Storable.$fStorableFunPtr3
                                                Foreign.Storable.$fStorableFunPtr2
                                                Foreign.Storable.$fStorableFunPtr1];

Foreign.Storable.$fStorablePtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.Ptr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.Ptr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FoQ void_0E]
        case ptr_s4FoQ of {
          GHC.Ptr.Ptr a1_s4FoT [Occ=Once] ->
              case readAddrOffAddr# [a1_s4FoT 0# GHC.Prim.void#] of {
                Unit# ipv1_s4FoW [Occ=Once] ->
                    let {
                      sat_s4FoX [Occ=Once] :: GHC.Ptr.Ptr a_a4Drd
                      [LclId] =
                          CCCS GHC.Ptr.Ptr! [ipv1_s4FoW];
                    } in  Unit# [sat_s4FoX];
              };
        };

Foreign.Storable.$fStorablePtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.Ptr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FoY off_s4FoZ void_0E]
        case ptr_s4FoY of {
          GHC.Ptr.Ptr addr_s4Fp2 [Occ=Once] ->
              case off_s4FoZ of {
                GHC.Types.I# d_s4Fp4 [Occ=Once] ->
                    case plusAddr# [addr_s4Fp2 d_s4Fp4] of sat_s4Fp5 {
                      __DEFAULT ->
                          case readAddrOffAddr# [sat_s4Fp5 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Fp8 [Occ=Once] ->
                                let {
                                  sat_s4Fp9 [Occ=Once] :: GHC.Ptr.Ptr a_a4Drd
                                  [LclId] =
                                      CCCS GHC.Ptr.Ptr! [ipv1_s4Fp8];
                                } in  Unit# [sat_s4Fp9];
                          };
                    };
              };
        };

Foreign.Storable.$fStorablePtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.Ptr a)
     -> GHC.Ptr.Ptr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fpa ds2_s4Fpb void_0E]
        case ptr_s4Fpa of {
          GHC.Ptr.Ptr a1_s4Fpe [Occ=Once] ->
              case ds2_s4Fpb of {
                GHC.Ptr.Ptr x_s4Fpg [Occ=Once] ->
                    case
                        writeAddrOffAddr# [a1_s4Fpe 0# x_s4Fpg GHC.Prim.void#]
                    of
                    s2_s4Fph
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorablePtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Ptr.Ptr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fpi off_s4Fpj eta_s4Fpk void_0E]
        case ptr_s4Fpi of {
          GHC.Ptr.Ptr addr_s4Fpn [Occ=Once] ->
              case off_s4Fpj of {
                GHC.Types.I# d_s4Fpp [Occ=Once] ->
                    case eta_s4Fpk of {
                      GHC.Ptr.Ptr x_s4Fpr [Occ=Once] ->
                          case plusAddr# [addr_s4Fpn d_s4Fpp] of sat_s4Fps {
                            __DEFAULT ->
                                case
                                    writeAddrOffAddr# [sat_s4Fps 0# x_s4Fpr GHC.Prim.void#]
                                of
                                s2_s4Fpt
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorablePtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Ptr.Ptr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorablePtr_$calignment
                                                Foreign.Storable.$fStorablePtr_$calignment
                                                GHC.Storable.readPtrOffPtr1
                                                GHC.Storable.writePtrOffPtr1
                                                Foreign.Storable.$fStorablePtr4
                                                Foreign.Storable.$fStorablePtr3
                                                Foreign.Storable.$fStorablePtr2
                                                Foreign.Storable.$fStorablePtr1];

Foreign.Storable.$fStorableWord2
  :: GHC.Ptr.Ptr GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Word #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fpu void_0E]
        case ptr_s4Fpu of {
          GHC.Ptr.Ptr a_s4Fpx [Occ=Once] ->
              case readWordOffAddr# [a_s4Fpx 0# GHC.Prim.void#] of {
                Unit# ipv1_s4FpA [Occ=Once] ->
                    let {
                      sat_s4FpB [Occ=Once] :: GHC.Types.Word
                      [LclId] =
                          CCCS GHC.Types.W#! [ipv1_s4FpA];
                    } in  Unit# [sat_s4FpB];
              };
        };

Foreign.Storable.$fStorableWord4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Word #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FpC off_s4FpD void_0E]
        case ptr_s4FpC of {
          GHC.Ptr.Ptr addr_s4FpG [Occ=Once] ->
              case off_s4FpD of {
                GHC.Types.I# d_s4FpI [Occ=Once] ->
                    case plusAddr# [addr_s4FpG d_s4FpI] of sat_s4FpJ {
                      __DEFAULT ->
                          case readWordOffAddr# [sat_s4FpJ 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4FpM [Occ=Once] ->
                                let {
                                  sat_s4FpN [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv1_s4FpM];
                                } in  Unit# [sat_s4FpN];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord1
  :: GHC.Ptr.Ptr GHC.Types.Word
     -> GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FpO ds2_s4FpP void_0E]
        case ptr_s4FpO of {
          GHC.Ptr.Ptr a_s4FpS [Occ=Once] ->
              case ds2_s4FpP of {
                GHC.Types.W# x_s4FpU [Occ=Once] ->
                    case
                        writeWordOffAddr# [a_s4FpS 0# x_s4FpU GHC.Prim.void#]
                    of
                    s2_s4FpV
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FpW off_s4FpX eta_s4FpY void_0E]
        case ptr_s4FpW of {
          GHC.Ptr.Ptr addr_s4Fq1 [Occ=Once] ->
              case off_s4FpX of {
                GHC.Types.I# d_s4Fq3 [Occ=Once] ->
                    case eta_s4FpY of {
                      GHC.Types.W# x_s4Fq5 [Occ=Once] ->
                          case plusAddr# [addr_s4Fq1 d_s4Fq3] of sat_s4Fq6 {
                            __DEFAULT ->
                                case
                                    writeWordOffAddr# [sat_s4Fq6 0# x_s4Fq5 GHC.Prim.void#]
                                of
                                s2_s4Fq7
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord_$calignment
                                                Foreign.Storable.$fStorableWord_$calignment
                                                GHC.Storable.readWordOffPtr1
                                                GHC.Storable.writeWordOffPtr1
                                                Foreign.Storable.$fStorableWord4
                                                Foreign.Storable.$fStorableWord3
                                                Foreign.Storable.$fStorableWord2
                                                Foreign.Storable.$fStorableWord1];

Foreign.Storable.$fStorableInt2
  :: GHC.Ptr.Ptr GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fq8 void_0E]
        case ptr_s4Fq8 of {
          GHC.Ptr.Ptr a_s4Fqb [Occ=Once] ->
              case readIntOffAddr# [a_s4Fqb 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Fqe [Occ=Once] ->
                    let {
                      sat_s4Fqf [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [ipv1_s4Fqe];
                    } in  Unit# [sat_s4Fqf];
              };
        };

Foreign.Storable.$fStorableInt4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fqg off_s4Fqh void_0E]
        case ptr_s4Fqg of {
          GHC.Ptr.Ptr addr_s4Fqk [Occ=Once] ->
              case off_s4Fqh of {
                GHC.Types.I# d_s4Fqm [Occ=Once] ->
                    case plusAddr# [addr_s4Fqk d_s4Fqm] of sat_s4Fqn {
                      __DEFAULT ->
                          case readIntOffAddr# [sat_s4Fqn 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Fqq [Occ=Once] ->
                                let {
                                  sat_s4Fqr [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s4Fqq];
                                } in  Unit# [sat_s4Fqr];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt1
  :: GHC.Ptr.Ptr GHC.Types.Int
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fqs ds2_s4Fqt void_0E]
        case ptr_s4Fqs of {
          GHC.Ptr.Ptr a_s4Fqw [Occ=Once] ->
              case ds2_s4Fqt of {
                GHC.Types.I# x_s4Fqy [Occ=Once] ->
                    case
                        writeIntOffAddr# [a_s4Fqw 0# x_s4Fqy GHC.Prim.void#]
                    of
                    s2_s4Fqz
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FqA off_s4FqB eta_s4FqC void_0E]
        case ptr_s4FqA of {
          GHC.Ptr.Ptr addr_s4FqF [Occ=Once] ->
              case off_s4FqB of {
                GHC.Types.I# d_s4FqH [Occ=Once] ->
                    case eta_s4FqC of {
                      GHC.Types.I# x_s4FqJ [Occ=Once] ->
                          case plusAddr# [addr_s4FqF d_s4FqH] of sat_s4FqK {
                            __DEFAULT ->
                                case
                                    writeIntOffAddr# [sat_s4FqK 0# x_s4FqJ GHC.Prim.void#]
                                of
                                s2_s4FqL
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt_$calignment
                                                Foreign.Storable.$fStorableInt_$calignment
                                                GHC.Storable.readIntOffPtr1
                                                GHC.Storable.writeIntOffPtr1
                                                Foreign.Storable.$fStorableInt4
                                                Foreign.Storable.$fStorableInt3
                                                Foreign.Storable.$fStorableInt2
                                                Foreign.Storable.$fStorableInt1];

Foreign.Storable.$fStorableChar2
  :: GHC.Ptr.Ptr GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Char #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FqM void_0E]
        case ptr_s4FqM of {
          GHC.Ptr.Ptr a_s4FqP [Occ=Once] ->
              case readWideCharOffAddr# [a_s4FqP 0# GHC.Prim.void#] of {
                Unit# ipv1_s4FqS [Occ=Once] ->
                    let {
                      sat_s4FqT [Occ=Once] :: GHC.Types.Char
                      [LclId] =
                          CCCS GHC.Types.C#! [ipv1_s4FqS];
                    } in  Unit# [sat_s4FqT];
              };
        };

Foreign.Storable.$fStorableChar4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Char #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FqU off_s4FqV void_0E]
        case ptr_s4FqU of {
          GHC.Ptr.Ptr addr_s4FqY [Occ=Once] ->
              case off_s4FqV of {
                GHC.Types.I# d_s4Fr0 [Occ=Once] ->
                    case plusAddr# [addr_s4FqY d_s4Fr0] of sat_s4Fr1 {
                      __DEFAULT ->
                          case readWideCharOffAddr# [sat_s4Fr1 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Fr4 [Occ=Once] ->
                                let {
                                  sat_s4Fr5 [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ipv1_s4Fr4];
                                } in  Unit# [sat_s4Fr5];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableChar1
  :: GHC.Ptr.Ptr GHC.Types.Char
     -> GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fr6 ds2_s4Fr7 void_0E]
        case ptr_s4Fr6 of {
          GHC.Ptr.Ptr a_s4Fra [Occ=Once] ->
              case ds2_s4Fr7 of {
                GHC.Types.C# x_s4Frc [Occ=Once] ->
                    case
                        writeWideCharOffAddr# [a_s4Fra 0# x_s4Frc GHC.Prim.void#]
                    of
                    s2_s4Frd
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableChar3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fre off_s4Frf eta_s4Frg void_0E]
        case ptr_s4Fre of {
          GHC.Ptr.Ptr addr_s4Frj [Occ=Once] ->
              case off_s4Frf of {
                GHC.Types.I# d_s4Frl [Occ=Once] ->
                    case eta_s4Frg of {
                      GHC.Types.C# x_s4Frn [Occ=Once] ->
                          case plusAddr# [addr_s4Frj d_s4Frl] of sat_s4Fro {
                            __DEFAULT ->
                                case
                                    writeWideCharOffAddr# [sat_s4Fro 0# x_s4Frn GHC.Prim.void#]
                                of
                                s2_s4Frp
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Char
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableChar_$calignment
                                                Foreign.Storable.$fStorableChar_$calignment
                                                GHC.Storable.readWideCharOffPtr1
                                                GHC.Storable.writeWideCharOffPtr1
                                                Foreign.Storable.$fStorableChar4
                                                Foreign.Storable.$fStorableChar3
                                                Foreign.Storable.$fStorableChar2
                                                Foreign.Storable.$fStorableChar1];

Foreign.Storable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$trModule4];

Foreign.Storable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$trModule2];

Foreign.Storable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Foreign.Storable.$trModule3
                                     Foreign.Storable.$trModule1];

$krep_r4Ffk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Foreign.Storable.$tcStorable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep_r4Ffk];

Foreign.Storable.$tcStorable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Storable"#;

Foreign.Storable.$tcStorable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$tcStorable3];

Foreign.Storable.$tcStorable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9192657549155052097##
                                    13909834202100645491##
                                    Foreign.Storable.$trModule
                                    Foreign.Storable.$tcStorable2
                                    0#
                                    Foreign.Storable.$tcStorable1];

Foreign.Storable.$fStorableWord20
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word8 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Frq void_0E]
        case ptr_s4Frq of {
          GHC.Ptr.Ptr a_s4Frt [Occ=Once] ->
              case readWord8OffAddr# [a_s4Frt 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Frw [Occ=Once] ->
                    let {
                      sat_s4Frx [Occ=Once] :: GHC.Word.Word8
                      [LclId] =
                          CCCS GHC.Word.W8#! [ipv1_s4Frw];
                    } in  Unit# [sat_s4Frx];
              };
        };

Foreign.Storable.$fStorableWord22
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fry off_s4Frz void_0E]
        case ptr_s4Fry of {
          GHC.Ptr.Ptr addr_s4FrC [Occ=Once] ->
              case off_s4Frz of {
                GHC.Types.I# d_s4FrE [Occ=Once] ->
                    case plusAddr# [addr_s4FrC d_s4FrE] of sat_s4FrF {
                      __DEFAULT ->
                          case readWord8OffAddr# [sat_s4FrF 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4FrI [Occ=Once] ->
                                let {
                                  sat_s4FrJ [Occ=Once] :: GHC.Word.Word8
                                  [LclId] =
                                      CCCS GHC.Word.W8#! [ipv1_s4FrI];
                                } in  Unit# [sat_s4FrJ];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord19
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FrK ds2_s4FrL void_0E]
        case ptr_s4FrK of {
          GHC.Ptr.Ptr a_s4FrO [Occ=Once] ->
              case ds2_s4FrL of {
                GHC.Word.W8# x_s4FrQ [Occ=Once] ->
                    case
                        writeWord8OffAddr# [a_s4FrO 0# x_s4FrQ GHC.Prim.void#]
                    of
                    s2_s4FrR
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord21
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FrS off_s4FrT eta_s4FrU void_0E]
        case ptr_s4FrS of {
          GHC.Ptr.Ptr addr_s4FrX [Occ=Once] ->
              case off_s4FrT of {
                GHC.Types.I# d_s4FrZ [Occ=Once] ->
                    case eta_s4FrU of {
                      GHC.Word.W8# x_s4Fs1 [Occ=Once] ->
                          case plusAddr# [addr_s4FrX d_s4FrZ] of sat_s4Fs2 {
                            __DEFAULT ->
                                case
                                    writeWord8OffAddr# [sat_s4Fs2 0# x_s4Fs1 GHC.Prim.void#]
                                of
                                s2_s4Fs3
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word8
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord8_$calignment
                                                Foreign.Storable.$fStorableWord8_$calignment
                                                GHC.Storable.readWord8OffPtr1
                                                GHC.Storable.writeWord8OffPtr1
                                                Foreign.Storable.$fStorableWord22
                                                Foreign.Storable.$fStorableWord21
                                                Foreign.Storable.$fStorableWord20
                                                Foreign.Storable.$fStorableWord19];

Foreign.Storable.$fStorableRatio2
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=4,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,1*C1(C1(C1(U(U,U)))),A,A,A,1*C1(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fs4 $dIntegral_s4Fs5 p_s4Fs6 void_0E]
        case
            Foreign.Storable.peek $dStorable_s4Fs4 p_s4Fs6 GHC.Prim.void#
        of
        { Unit# ipv1_s4Fsa [Occ=Once] ->
              case
                  Foreign.Storable.peekElemOff
                      $dStorable_s4Fs4
                      p_s4Fs6
                      Foreign.Storable.$fStorable()7
                      GHC.Prim.void#
              of
              { Unit# ipv3_s4Fsd [Occ=Once] ->
                    let {
                      sat_s4Fse [Occ=Once] :: GHC.Real.Ratio a_a4DgH
                      [LclId] =
                          [$dIntegral_s4Fs5 ipv1_s4Fsa ipv3_s4Fsd] \u []
                              GHC.Real.% $dIntegral_s4Fs5 ipv1_s4Fsa ipv3_s4Fsd;
                    } in  Unit# [sat_s4Fse];
              };
        };

Foreign.Storable.$fStorableRatio1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,A><L,U><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Fsf w1_s4Fsg w2_s4Fsh w3_s4Fsi void_0E]
        case w3_s4Fsi of {
          GHC.Real.:% ww1_s4Fsl [Occ=Once] ww2_s4Fsm [Occ=Once] ->
              case
                  Foreign.Storable.poke w_s4Fsf w2_s4Fsh ww1_s4Fsl GHC.Prim.void#
              of
              { Unit# _ [Occ=Dead] ->
                    Foreign.Storable.pokeElemOff
                        w_s4Fsf
                        w2_s4Fsh
                        Foreign.Storable.$fStorable()7
                        ww2_s4Fsm
                        GHC.Prim.void#;
              };
        };

Foreign.Storable.$fStorableBool6
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [p_s4Fsq i_s4Fsr void_0E]
        case p_s4Fsq of {
          GHC.Ptr.Ptr a_s4Fsu [Occ=Once] ->
              case i_s4Fsr of {
                GHC.Types.I# i1_s4Fsw [Occ=Once] ->
                    case readInt32OffAddr# [a_s4Fsu i1_s4Fsw GHC.Prim.void#] of {
                      Unit# ipv1_s4Fsz [Occ=Once!] ->
                          let {
                            sat_s4FsB [Occ=Once] :: GHC.Types.Bool
                            [LclId] =
                                [ipv1_s4Fsz] \u []
                                    case ipv1_s4Fsz of {
                                      __DEFAULT -> GHC.Types.True [];
                                      0# -> GHC.Types.False [];
                                    };
                          } in  Unit# [sat_s4FsB];
                    };
              };
        };

Foreign.Storable.$fStorableBool2
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FsC void_0E]
        case ptr_s4FsC of {
          GHC.Ptr.Ptr a_s4FsF [Occ=Once] ->
              case readInt32OffAddr# [a_s4FsF 0# GHC.Prim.void#] of {
                Unit# ipv1_s4FsI [Occ=Once!] ->
                    let {
                      sat_s4FsK [Occ=Once] :: GHC.Types.Bool
                      [LclId] =
                          [ipv1_s4FsI] \u []
                              case ipv1_s4FsI of {
                                __DEFAULT -> GHC.Types.True [];
                                0# -> GHC.Types.False [];
                              };
                    } in  Unit# [sat_s4FsK];
              };
        };

Foreign.Storable.$fStorableBool4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FsL off_s4FsM void_0E]
        case ptr_s4FsL of {
          GHC.Ptr.Ptr addr_s4FsP [Occ=Once] ->
              case off_s4FsM of {
                GHC.Types.I# d_s4FsR [Occ=Once] ->
                    case plusAddr# [addr_s4FsP d_s4FsR] of sat_s4FsS {
                      __DEFAULT ->
                          case readInt32OffAddr# [sat_s4FsS 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4FsV [Occ=Once!] ->
                                let {
                                  sat_s4FsX [Occ=Once] :: GHC.Types.Bool
                                  [LclId] =
                                      [ipv1_s4FsV] \u []
                                          case ipv1_s4FsV of {
                                            __DEFAULT -> GHC.Types.True [];
                                            0# -> GHC.Types.False [];
                                          };
                                } in  Unit# [sat_s4FsX];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableBool1
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FsY x_s4FsZ void_0E]
        case ptr_s4FsY of {
          GHC.Ptr.Ptr a_s4Ft2 [Occ=Once*] ->
              case x_s4FsZ of {
                GHC.Types.False ->
                    case
                        writeInt32OffAddr# [a_s4Ft2 0# 0# GHC.Prim.void#]
                    of
                    s2_s4Ft4
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
                GHC.Types.True ->
                    case
                        writeInt32OffAddr# [a_s4Ft2 0# 1# GHC.Prim.void#]
                    of
                    s2_s4Ft5
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableBool3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ft6 off_s4Ft7 eta_s4Ft8 void_0E]
        case ptr_s4Ft6 of {
          GHC.Ptr.Ptr addr_s4Ftb [Occ=Once*] ->
              case off_s4Ft7 of {
                GHC.Types.I# d_s4Ftd [Occ=Once*] ->
                    case eta_s4Ft8 of {
                      GHC.Types.False ->
                          case plusAddr# [addr_s4Ftb d_s4Ftd] of sat_s4Ftf {
                            __DEFAULT ->
                                case
                                    writeInt32OffAddr# [sat_s4Ftf 0# 0# GHC.Prim.void#]
                                of
                                s2_s4Ftg
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                      GHC.Types.True ->
                          case plusAddr# [addr_s4Ftb d_s4Ftd] of sat_s4Fth {
                            __DEFAULT ->
                                case
                                    writeInt32OffAddr# [sat_s4Fth 0# 1# GHC.Prim.void#]
                                of
                                s2_s4Fti
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableBool_$csizeOf
                                                Foreign.Storable.$fStorableBool_$csizeOf
                                                Foreign.Storable.$fStorableBool6
                                                Foreign.Storable.$fStorableBool5
                                                Foreign.Storable.$fStorableBool4
                                                Foreign.Storable.$fStorableBool3
                                                Foreign.Storable.$fStorableBool2
                                                Foreign.Storable.$fStorableBool1];

Foreign.Storable.$fStorable()2
  :: GHC.Ptr.Ptr ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><S,U>, Unf=OtherCon []] =
    [] \r [ds_s4Ftj void_0E] Unit# [GHC.Tuple.()];

Foreign.Storable.$fStorable()1
  :: GHC.Ptr.Ptr ()
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_s4Ftl ds1_s4Ftm void_0E] Unit# [GHC.Tuple.()];

lvl11_r4Ffl :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [137#];

lvl12_r4Ffm :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [31#];

lvl13_r4Ffn :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [40#];

lvl14_r4Ffo :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl11_r4Ffl
                                           lvl12_r4Ffm
                                           lvl11_r4Ffl
                                           lvl13_r4Ffn];

lvl15_r4Ffp :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl14_r4Ffo
                                                  GHC.Stack.Types.EmptyCallStack];

lvl16_r4Ffq :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl15_r4Ffp;

Foreign.Storable.$dmpeekElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
[GblId,
 Arity=3,
 Str=<S(LLLLC(C(S))LLL),U(1*C1(U(U)),A,A,A,1*C1(C1(U)),A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fto ptr_s4Ftp off_s4Ftq]
        let {
          sat_s4Ftw [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4Fto off_s4Ftq] \u []
                  case off_s4Ftq of {
                    GHC.Types.I# x_s4Fts [Occ=Once] ->
                        case Foreign.Storable.sizeOf $dStorable_s4Fto lvl16_r4Ffq of {
                          GHC.Types.I# y_s4Ftu [Occ=Once] ->
                              case *# [x_s4Fts y_s4Ftu] of sat_s4Ftv {
                                __DEFAULT -> GHC.Types.I# [sat_s4Ftv];
                              };
                        };
                  };
        } in 
          Foreign.Storable.peekByteOff $dStorable_s4Fto ptr_s4Ftp sat_s4Ftw;

Foreign.Storable.$dmpokeElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(C(S)))LL),U(1*C1(U(U)),A,A,A,A,1*C1(C1(C1(U))),A,A)><L,U><L,1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Ftx ptr_s4Fty off_s4Ftz val_s4FtA]
        let {
          sat_s4FtG [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4Ftx off_s4Ftz val_s4FtA] \u []
                  case off_s4Ftz of {
                    GHC.Types.I# x_s4FtC [Occ=Once] ->
                        case Foreign.Storable.sizeOf $dStorable_s4Ftx val_s4FtA of {
                          GHC.Types.I# y_s4FtE [Occ=Once] ->
                              case *# [x_s4FtC y_s4FtE] of sat_s4FtF {
                                __DEFAULT -> GHC.Types.I# [sat_s4FtF];
                              };
                        };
                  };
        } in 
          Foreign.Storable.pokeByteOff
              $dStorable_s4Ftx ptr_s4Fty sat_s4FtG val_s4FtA;

Foreign.Storable.$fStorable()4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FtH off_s4FtI void_0E] Unit# [GHC.Tuple.()];

Foreign.Storable.$fStorable()6
  :: GHC.Ptr.Ptr ()
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FtK off_s4FtL void_0E] Unit# [GHC.Tuple.()];

Foreign.Storable.$fStorable()3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FtN off_s4FtO ds_s4FtP void_0E] Unit# [GHC.Tuple.()];

Foreign.Storable.$fStorable()5
  :: GHC.Ptr.Ptr ()
     -> GHC.Types.Int
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FtR off_s4FtS val_s4FtT void_0E] Unit# [GHC.Tuple.()];

Foreign.Storable.$fStorable() [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorable()_$csizeOf
                                                Foreign.Storable.$fStorable()_$calignment
                                                Foreign.Storable.$fStorable()6
                                                Foreign.Storable.$fStorable()5
                                                Foreign.Storable.$fStorable()4
                                                Foreign.Storable.$fStorable()3
                                                Foreign.Storable.$fStorable()2
                                                Foreign.Storable.$fStorable()1];

lvl17_r4Ffr :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [237#];

lvl18_r4Ffs :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl17_r4Ffr
                                           lvl12_r4Ffm
                                           lvl17_r4Ffr
                                           lvl13_r4Ffn];

lvl19_r4Fft :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl18_r4Ffs
                                                  GHC.Stack.Types.EmptyCallStack];

Foreign.Storable.$fStorableRatio6 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl19_r4Fft;

Foreign.Storable.$fStorableRatio_$csizeOf
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(U(U)),A,A,A,A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4FtV $dIntegral_s4FtW]
        let {
          lvl20_s4FtX [Occ=OnceL!, Dmd=<L,U(U)>] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4FtV] \u []
                  Foreign.Storable.sizeOf
                      $dStorable_s4FtV Foreign.Storable.$fStorableRatio6; } in
        let {
          sat_s4Fu2 [Occ=OnceT[0]] :: GHC.Real.Ratio a_X4DnT -> GHC.Types.Int
          [LclId] =
              [lvl20_s4FtX] \r [ds_s4FtY]
                  case lvl20_s4FtX of {
                    GHC.Types.I# y_s4Fu0 [Occ=Once] ->
                        case *# [2# y_s4Fu0] of sat_s4Fu1 {
                          __DEFAULT -> GHC.Types.I# [sat_s4Fu1];
                        };
                  };
        } in  sat_s4Fu2;

Foreign.Storable.$fStorableRatio4
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fu3
           $dIntegral_s4Fu4
           ptr_s4Fu5
           off_s4Fu6
           void_0E]
        let {
          sat_s4Fud [Occ=Once] :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnX)
          [LclId] =
              [ptr_s4Fu5 off_s4Fu6] \u []
                  case ptr_s4Fu5 of {
                    GHC.Ptr.Ptr addr_s4Fu9 [Occ=Once] ->
                        case off_s4Fu6 of {
                          GHC.Types.I# d_s4Fub [Occ=Once] ->
                              case plusAddr# [addr_s4Fu9 d_s4Fub] of sat_s4Fuc {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fuc];
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableRatio2
              $dStorable_s4Fu3 $dIntegral_s4Fu4 sat_s4Fud GHC.Prim.void#;

Foreign.Storable.$fStorableRatio7
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S(SL)))L),U(1*C1(U(U)),A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Fue
           $dIntegral_s4Fuf
           ptr_s4Fug
           off_s4Fuh
           void_0E]
        let {
          sat_s4Fus [Occ=Once] :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnY)
          [LclId] =
              [$dStorable_s4Fue ptr_s4Fug off_s4Fuh] \u []
                  case ptr_s4Fug of {
                    GHC.Ptr.Ptr addr_s4Fuk [Occ=Once] ->
                        case off_s4Fuh of {
                          GHC.Types.I# x_s4Fum [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf
                                      $dStorable_s4Fue Foreign.Storable.$fStorableRatio6
                              of
                              { GHC.Types.I# y_s4Fuo [Occ=Once] ->
                                    case *# [2# y_s4Fuo] of sat_s4Fup {
                                      __DEFAULT ->
                                          case *# [x_s4Fum sat_s4Fup] of sat_s4Fuq {
                                            __DEFAULT ->
                                                case plusAddr# [addr_s4Fuk sat_s4Fuq] of sat_s4Fur {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fur];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableRatio2
              $dStorable_s4Fue $dIntegral_s4Fuf sat_s4Fus GHC.Prim.void#;

Foreign.Storable.$w$cpokeByteOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Fut w1_s4Fuu w2_s4Fuv ww_s4Fuw ww1_s4Fux void_0E]
        let {
          p_s4Fuz :: GHC.Ptr.Ptr (GHC.Real.Ratio a_s4EvU)
          [LclId] =
              [w1_s4Fuu w2_s4Fuv] \u []
                  case w1_s4Fuu of {
                    GHC.Ptr.Ptr addr_s4FuB [Occ=Once] ->
                        case w2_s4Fuv of {
                          GHC.Types.I# d_s4FuD [Occ=Once] ->
                              case plusAddr# [addr_s4FuB d_s4FuD] of sat_s4FuE {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4FuE];
                              };
                        };
                  };
        } in 
          case
              Foreign.Storable.poke w_s4Fut p_s4Fuz ww_s4Fuw GHC.Prim.void#
          of
          { Unit# _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_s4Fut
                    p_s4Fuz
                    Foreign.Storable.$fStorable()7
                    ww1_s4Fux
                    GHC.Prim.void#;
          };

Foreign.Storable.$fStorableRatio3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,A><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4FuI w1_s4FuJ w2_s4FuK w3_s4FuL w4_s4FuM void_0E]
        case w4_s4FuM of {
          GHC.Real.:% ww1_s4FuP [Occ=Once] ww2_s4FuQ [Occ=Once] ->
              Foreign.Storable.$w$cpokeByteOff
                  w_s4FuI w2_s4FuK w3_s4FuL ww1_s4FuP ww2_s4FuQ GHC.Prim.void#;
        };

Foreign.Storable.$w$cpokeElemOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(1*C1(U(U)),A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4FuR w1_s4FuS w2_s4FuT ww_s4FuU ww1_s4FuV void_0E]
        let {
          p_s4FuX :: GHC.Ptr.Ptr (GHC.Real.Ratio a_s4Ew8)
          [LclId] =
              [w_s4FuR w1_s4FuS w2_s4FuT] \u []
                  case w1_s4FuS of {
                    GHC.Ptr.Ptr addr_s4FuZ [Occ=Once] ->
                        case w2_s4FuT of {
                          GHC.Types.I# x_s4Fv1 [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf w_s4FuR Foreign.Storable.$fStorableRatio6
                              of
                              { GHC.Types.I# y_s4Fv3 [Occ=Once] ->
                                    case *# [2# y_s4Fv3] of sat_s4Fv4 {
                                      __DEFAULT ->
                                          case *# [x_s4Fv1 sat_s4Fv4] of sat_s4Fv5 {
                                            __DEFAULT ->
                                                case plusAddr# [addr_s4FuZ sat_s4Fv5] of sat_s4Fv6 {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fv6];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case
              Foreign.Storable.poke w_s4FuR p_s4FuX ww_s4FuU GHC.Prim.void#
          of
          { Unit# _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_s4FuR
                    p_s4FuX
                    Foreign.Storable.$fStorable()7
                    ww1_s4FuV
                    GHC.Prim.void#;
          };

Foreign.Storable.$fStorableRatio5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(C(U(U)),A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,A><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Fva w1_s4Fvb w2_s4Fvc w3_s4Fvd w4_s4Fve void_0E]
        case w4_s4Fve of {
          GHC.Real.:% ww1_s4Fvh [Occ=Once] ww2_s4Fvi [Occ=Once] ->
              Foreign.Storable.$w$cpokeElemOff
                  w_s4Fva w2_s4Fvc w3_s4Fvd ww1_s4Fvh ww2_s4Fvi GHC.Prim.void#;
        };

Foreign.Storable.$fStorableRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     Foreign.Storable.Storable (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(U(U)),1*C1(U),C(C1(C1(U(U,U)))),C(C1(C1(C1(U(U,U))))),A,A,C(C1(U(U,U))),C(C1(C1(U(U,A)))))><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dStorable_s4Fvj $dIntegral_s4Fvk]
        let {
          sat_s4Fvs [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B3 eta_B2 void_0E]
                  Foreign.Storable.$fStorableRatio1
                      $dStorable_s4Fvj
                      $dIntegral_s4Fvk
                      eta_B3
                      eta_B2
                      GHC.Prim.void#; } in
        let {
          sat_s4Fvr [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B2 void_0E]
                  Foreign.Storable.$fStorableRatio2
                      $dStorable_s4Fvj $dIntegral_s4Fvk eta_B2 GHC.Prim.void#; } in
        let {
          sat_s4Fvq [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B4
                                                      eta_B3
                                                      eta_B2
                                                      void_0E]
                  Foreign.Storable.$fStorableRatio3
                      $dStorable_s4Fvj
                      $dIntegral_s4Fvk
                      eta_B4
                      eta_B3
                      eta_B2
                      GHC.Prim.void#; } in
        let {
          sat_s4Fvp [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B3 eta_B2 void_0E]
                  Foreign.Storable.$fStorableRatio4
                      $dStorable_s4Fvj
                      $dIntegral_s4Fvk
                      eta_B3
                      eta_B2
                      GHC.Prim.void#; } in
        let {
          sat_s4Fvo [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.Int -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B4
                                                      eta_B3
                                                      eta_B2
                                                      void_0E]
                  Foreign.Storable.$fStorableRatio5
                      $dStorable_s4Fvj
                      $dIntegral_s4Fvk
                      eta_B4
                      eta_B3
                      eta_B2
                      GHC.Prim.void#; } in
        let {
          sat_s4Fvn [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.Int -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \r [eta_B3 eta_B2 void_0E]
                  Foreign.Storable.$fStorableRatio7
                      $dStorable_s4Fvj
                      $dIntegral_s4Fvk
                      eta_B3
                      eta_B2
                      GHC.Prim.void#; } in
        let {
          sat_s4Fvm [Occ=Once] :: GHC.Real.Ratio a_X4DnU -> GHC.Types.Int
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \u []
                  Foreign.Storable.$fStorableRatio_$calignment
                      $dStorable_s4Fvj $dIntegral_s4Fvk; } in
        let {
          sat_s4Fvl [Occ=Once] :: GHC.Real.Ratio a_X4DnU -> GHC.Types.Int
          [LclId] =
              [$dStorable_s4Fvj $dIntegral_s4Fvk] \u []
                  Foreign.Storable.$fStorableRatio_$csizeOf
                      $dStorable_s4Fvj $dIntegral_s4Fvk;
        } in 
          Foreign.Storable.C:Storable [sat_s4Fvl
                                       sat_s4Fvm
                                       sat_s4Fvn
                                       sat_s4Fvo
                                       sat_s4Fvp
                                       sat_s4Fvq
                                       sat_s4Fvr
                                       sat_s4Fvs];

Foreign.Storable.$wpokeW64 [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.Int#
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><S,1*U><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Fvt ww_s4Fvu w1_s4Fvv void_0E]
        case ww_s4Fvu of ds_s4Fvx {
          __DEFAULT ->
              case w1_s4Fvv of {
                GHC.Word.W64# ipv_s4Fvz ->
                    case w_s4Fvt of wild_s4FvA {
                      GHC.Ptr.Ptr a_s4FvB [Occ=Once] ->
                          case narrow8Word# [ipv_s4Fvz] of sat_s4FvD {
                            __DEFAULT ->
                                case -# [ds_s4Fvx 1#] of sat_s4FvC {
                                  __DEFAULT ->
                                      case
                                          writeWord8OffAddr# [a_s4FvB
                                                              sat_s4FvC
                                                              sat_s4FvD
                                                              GHC.Prim.void#]
                                      of
                                      s2_s4FvE
                                      { (##) ->
                                            case uncheckedShiftRL# [ipv_s4Fvz 8#] of sat_s4FvG {
                                              __DEFAULT ->
                                                  let {
                                                    sat_s4FvH [Occ=Once] :: GHC.Word.Word64
                                                    [LclId] =
                                                        CCCS GHC.Word.W64#! [sat_s4FvG];
                                                  } in 
                                                    case -# [ds_s4Fvx 1#] of sat_s4FvF {
                                                      __DEFAULT ->
                                                          Foreign.Storable.$wpokeW64
                                                              wild_s4FvA
                                                              sat_s4FvF
                                                              sat_s4FvH
                                                              GHC.Prim.void#;
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
          0# -> Unit# [GHC.Tuple.()];
        };

Foreign.Storable.$w$cpoke [InlPrag=NOUSERINLINE[0]]
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.Word#
     -> GHC.Prim.Word#
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4FvI ww_s4FvJ ww1_s4FvK void_0E]
        let {
          sat_s4FvM [Occ=Once] :: GHC.Word.Word64
          [LclId] =
              CCCS GHC.Word.W64#! [ww_s4FvJ];
        } in 
          case
              Foreign.Storable.$wpokeW64 w_s4FvI 8# sat_s4FvM GHC.Prim.void#
          of
          { Unit# _ [Occ=Dead] ->
                let {
                  sat_s4FvU [Occ=Once] :: GHC.Word.Word64
                  [LclId] =
                      CCCS GHC.Word.W64#! [ww1_s4FvK]; } in
                let {
                  sat_s4FvT [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Ptr.Ptr GHC.Word.Word8
                  [LclId] =
                      [w_s4FvI] \s []
                          case w_s4FvI of {
                            GHC.Ptr.Ptr addr_s4FvR [Occ=Once] ->
                                case plusAddr# [addr_s4FvR 8#] of sat_s4FvS {
                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4FvS];
                                };
                          };
                } in 
                  Foreign.Storable.$wpokeW64 sat_s4FvT 8# sat_s4FvU GHC.Prim.void#;
          };

Foreign.Storable.$fStorableFingerprint1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4FvV w1_s4FvW void_0E]
        case w1_s4FvW of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4FvZ [Occ=Once]
                                           ww2_s4Fw0 [Occ=Once] ->
              Foreign.Storable.$w$cpoke
                  w_s4FvV ww1_s4FvZ ww2_s4Fw0 GHC.Prim.void#;
        };

Foreign.Storable.$wpeekW64 [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.Int#
     -> GHC.Prim.Word#
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><S,1*U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Fw1 ww_s4Fw2 ww1_s4Fw3 void_0E]
        case ww_s4Fw2 of ds_s4Fw5 {
          __DEFAULT ->
              case w_s4Fw1 of {
                GHC.Ptr.Ptr ipv_s4Fw7 ->
                    case readWord8OffAddr# [ipv_s4Fw7 0# GHC.Prim.void#] of {
                      Unit# ipv2_s4Fwa [Occ=Once] ->
                          case uncheckedShiftL# [ww1_s4Fw3 8#] of sat_s4Fwe {
                            __DEFAULT ->
                                case or# [sat_s4Fwe ipv2_s4Fwa] of sat_s4Fwf {
                                  __DEFAULT ->
                                      case -# [ds_s4Fw5 1#] of sat_s4Fwd {
                                        __DEFAULT ->
                                            case plusAddr# [ipv_s4Fw7 1#] of sat_s4Fwb {
                                              __DEFAULT ->
                                                  let {
                                                    sat_s4Fwc [Occ=Once]
                                                      :: GHC.Ptr.Ptr GHC.Word.Word8
                                                    [LclId] =
                                                        CCCS GHC.Ptr.Ptr! [sat_s4Fwb];
                                                  } in 
                                                    Foreign.Storable.$wpeekW64
                                                        sat_s4Fwc
                                                        sat_s4Fwd
                                                        sat_s4Fwf
                                                        GHC.Prim.void#;
                                            };
                                      };
                                };
                          };
                    };
              };
          0# ->
              let {
                sat_s4Fwg [Occ=Once] :: GHC.Word.Word64
                [LclId] =
                    CCCS GHC.Word.W64#! [ww1_s4Fw3];
              } in  Unit# [sat_s4Fwg];
        };

Foreign.Storable.$fStorableFingerprint2
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [p0_s4Fwh void_0E]
        case Foreign.Storable.$wpeekW64 p0_s4Fwh 8# 0## GHC.Prim.void# of {
          Unit# ipv1_s4Fwl [Occ=Once] ->
              let {
                sat_s4Fwp [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Ptr.Ptr GHC.Word.Word8
                [LclId] =
                    [p0_s4Fwh] \s []
                        case p0_s4Fwh of {
                          GHC.Ptr.Ptr addr_s4Fwn [Occ=Once] ->
                              case plusAddr# [addr_s4Fwn 8#] of sat_s4Fwo {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fwo];
                              };
                        };
              } in 
                case
                    Foreign.Storable.$wpeekW64 sat_s4Fwp 8# 0## GHC.Prim.void#
                of
                { Unit# ipv3_s4Fws [Occ=Once] ->
                      let {
                        sat_s4Fwt [Occ=Once] :: GHC.Fingerprint.Type.Fingerprint
                        [LclId] =
                            [ipv1_s4Fwl ipv3_s4Fws] \u []
                                GHC.Fingerprint.Type.$WFingerprint ipv1_s4Fwl ipv3_s4Fws;
                      } in  Unit# [sat_s4Fwt];
                };
        };

Foreign.Storable.$fStorableFingerprint4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fwu off_s4Fwv void_0E]
        let {
          sat_s4FwC [Occ=Once, Dmd=<L,U(U)>]
            :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
          [LclId] =
              [ptr_s4Fwu off_s4Fwv] \u []
                  case ptr_s4Fwu of {
                    GHC.Ptr.Ptr addr_s4Fwy [Occ=Once] ->
                        case off_s4Fwv of {
                          GHC.Types.I# d_s4FwA [Occ=Once] ->
                              case plusAddr# [addr_s4Fwy d_s4FwA] of sat_s4FwB {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4FwB];
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableFingerprint2 sat_s4FwC GHC.Prim.void#;

Foreign.Storable.$fStorableFingerprint6
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FwD off_s4FwE void_0E]
        let {
          sat_s4FwM [Occ=Once, Dmd=<L,U(U)>]
            :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
          [LclId] =
              [ptr_s4FwD off_s4FwE] \u []
                  case ptr_s4FwD of {
                    GHC.Ptr.Ptr addr_s4FwH [Occ=Once] ->
                        case off_s4FwE of {
                          GHC.Types.I# x_s4FwJ [Occ=Once] ->
                              case *# [x_s4FwJ 16#] of sat_s4FwK {
                                __DEFAULT ->
                                    case plusAddr# [addr_s4FwH sat_s4FwK] of sat_s4FwL {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_s4FwL];
                                    };
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableFingerprint2 sat_s4FwM GHC.Prim.void#;

Foreign.Storable.$fStorableFingerprint3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4FwN off_s4FwO eta_s4FwP void_0E]
        case eta_s4FwP of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4FwS [Occ=Once]
                                           ww2_s4FwT [Occ=Once] ->
              let {
                sat_s4FwZ [Occ=Once, Dmd=<L,U(U)>]
                  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
                [LclId] =
                    [ptr_s4FwN off_s4FwO] \u []
                        case ptr_s4FwN of {
                          GHC.Ptr.Ptr addr_s4FwV [Occ=Once] ->
                              case off_s4FwO of {
                                GHC.Types.I# d_s4FwX [Occ=Once] ->
                                    case plusAddr# [addr_s4FwV d_s4FwX] of sat_s4FwY {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_s4FwY];
                                    };
                              };
                        };
              } in 
                Foreign.Storable.$w$cpoke
                    sat_s4FwZ ww1_s4FwS ww2_s4FwT GHC.Prim.void#;
        };

Foreign.Storable.$fStorableFingerprint5
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Types.Int
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Fx0 off_s4Fx1 val_s4Fx2 void_0E]
        case val_s4Fx2 of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4Fx5 [Occ=Once]
                                           ww2_s4Fx6 [Occ=Once] ->
              let {
                sat_s4Fxd [Occ=Once, Dmd=<L,U(U)>]
                  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
                [LclId] =
                    [ptr_s4Fx0 off_s4Fx1] \u []
                        case ptr_s4Fx0 of {
                          GHC.Ptr.Ptr addr_s4Fx8 [Occ=Once] ->
                              case off_s4Fx1 of {
                                GHC.Types.I# x_s4Fxa [Occ=Once] ->
                                    case *# [x_s4Fxa 16#] of sat_s4Fxb {
                                      __DEFAULT ->
                                          case plusAddr# [addr_s4Fx8 sat_s4Fxb] of sat_s4Fxc {
                                            __DEFAULT -> GHC.Ptr.Ptr [sat_s4Fxc];
                                          };
                                    };
                              };
                        };
              } in 
                Foreign.Storable.$w$cpoke
                    sat_s4Fxd ww1_s4Fx5 ww2_s4Fx6 GHC.Prim.void#;
        };

Foreign.Storable.$fStorableFingerprint [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFingerprint_$csizeOf
                                                Foreign.Storable.$fStorableFingerprint_$calignment
                                                Foreign.Storable.$fStorableFingerprint6
                                                Foreign.Storable.$fStorableFingerprint5
                                                Foreign.Storable.$fStorableFingerprint4
                                                Foreign.Storable.$fStorableFingerprint3
                                                Foreign.Storable.$fStorableFingerprint2
                                                Foreign.Storable.$fStorableFingerprint1];

Foreign.Storable.C:Storable
  :: forall a.
     (a -> GHC.Types.Int)
     -> (a -> GHC.Types.Int)
     -> (GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a)
     -> (GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ())
     -> (forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a)
     -> (forall b.
         GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ())
     -> (GHC.Ptr.Ptr a -> GHC.Types.IO a)
     -> (GHC.Ptr.Ptr a -> a -> GHC.Types.IO ())
     -> Foreign.Storable.Storable a
[GblId[DataCon],
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B8 eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Foreign.Storable.C:Storable [eta_B8
                                     eta_B7
                                     eta_B6
                                     eta_B5
                                     eta_B4
                                     eta_B3
                                     eta_B2
                                     eta_B1];


==================== Pre unarise: ====================
2018-03-16 15:59:36.830775564 UTC

Foreign.Storable.sizeOf
  :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLL),U(U,A,A,A,A,A,A,A)>] =
    [] \r [v_s4IlN]
        case v_s4IlN of {
          Foreign.Storable.C:Storable v_s4IlP [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4IlP;
        };

Foreign.Storable.alignment
  :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>] =
    [] \r [v_s4IlX]
        case v_s4IlX of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      v_s4Im0 [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Im0;
        };

Foreign.Storable.peekElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLL),U(A,A,U,A,A,A,A,A)>] =
    [] \r [v_s4Im7]
        case v_s4Im7 of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Imb [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Imb;
        };

Foreign.Storable.pokeElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLL),U(A,A,A,U,A,A,A,A)>] =
    [] \r [v_s4Imh]
        case v_s4Imh of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Imm [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Imm;
        };

Foreign.Storable.peekByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLL),U(A,A,A,A,U,A,A,A)>] =
    [] \r [v_s4Imr]
        case v_s4Imr of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Imx [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Imx;
        };

Foreign.Storable.pokeByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLL),U(A,A,A,A,A,U,A,A)>] =
    [] \r [v_s4ImB]
        case v_s4ImB of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4ImI [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4ImI;
        };

Foreign.Storable.peek
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSL),U(A,A,A,A,A,A,U,A)>] =
    [] \r [v_s4ImL]
        case v_s4ImL of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4ImT [Occ=Once]
                                      _ [Occ=Dead] ->
              v_s4ImT;
        };

Foreign.Storable.poke
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLS),U(A,A,A,A,A,A,A,U)>] =
    [] \r [v_s4ImV]
        case v_s4ImV of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4In4 [Occ=Once] ->
              v_s4In4;
        };

Foreign.Storable.$fStorable()7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Foreign.Storable.$fStorable()_$calignment :: () -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4In5] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorable()8 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Foreign.Storable.$fStorable()_$csizeOf :: () -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4In6] Foreign.Storable.$fStorable()8;

Foreign.Storable.$fStorableBool7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [4#];

Foreign.Storable.$fStorableChar_$calignment
  :: GHC.Types.Char -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4In7] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableDouble5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

Foreign.Storable.$fStorableInt_$calignment
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4In8] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableWord_$calignment
  :: GHC.Types.Word -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4In9] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorablePtr_$calignment
  :: forall a. GHC.Ptr.Ptr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ina] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFunPtr_$calignment
  :: forall a. GHC.Ptr.FunPtr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inb] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableStablePtr_$calignment
  :: forall a. GHC.Stable.StablePtr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inc] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFloat_$calignment
  :: GHC.Types.Float -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ind] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableDouble_$calignment
  :: GHC.Types.Double -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ine] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableWord8_$calignment
  :: GHC.Word.Word8 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inf] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorableInt10 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

Foreign.Storable.$fStorableWord16_$calignment
  :: GHC.Word.Word16 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ing] Foreign.Storable.$fStorableInt10;

Foreign.Storable.$fStorableWord32_$calignment
  :: GHC.Word.Word32 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inh] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableWord64_$calignment
  :: GHC.Word.Word64 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ini] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableInt8_$calignment
  :: GHC.Int.Int8 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inj] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorableInt16_$calignment
  :: GHC.Int.Int16 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ink] Foreign.Storable.$fStorableInt10;

Foreign.Storable.$fStorableInt32_$calignment
  :: GHC.Int.Int32 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inl] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableInt64_$calignment
  :: GHC.Int.Int64 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inm] Foreign.Storable.$fStorableDouble5;

lvl_r4Ff9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

lvl1_r4Ffa :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_r4Ff9;

Foreign.Storable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl2_r4Ffb :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Foreign.Storable.$trModule4;

Foreign.Storable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foreign.Storable"#;

lvl3_r4Ffc :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Foreign.Storable.$trModule2;

lvl4_r4Ffd :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Foreign/Storable.hs"#;

lvl5_r4Ffe :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_r4Ffd;

lvl6_r4Fff :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [238#];

lvl7_r4Ffg :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [30#];

lvl8_r4Ffh :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [39#];

lvl9_r4Ffi :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl6_r4Fff
                                           lvl7_r4Ffg
                                           lvl6_r4Fff
                                           lvl8_r4Ffh];

lvl10_r4Ffj :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl9_r4Ffi
                                                  GHC.Stack.Types.EmptyCallStack];

Foreign.Storable.$fStorableRatio8 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl10_r4Ffj;

Foreign.Storable.$fStorableRatio_$calignment
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(U),A,A,A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Inn $dIntegral_s4Ino]
        let {
          lvl20_s4Inp [Occ=OnceL] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4Inn] \u []
                  Foreign.Storable.alignment
                      $dStorable_s4Inn Foreign.Storable.$fStorableRatio8; } in
        let {
          sat_s4Inr [Occ=OnceT[0]] :: GHC.Real.Ratio a_a4DgH -> GHC.Types.Int
          [LclId] =
              [lvl20_s4Inp] \r [ds_s4Inq] lvl20_s4Inp;
        } in  sat_s4Inr;

Foreign.Storable.$fStorableFingerprint_$calignment
  :: GHC.Fingerprint.Type.Fingerprint -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ins] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFingerprint7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [16#];

Foreign.Storable.$fStorableFingerprint_$csizeOf
  :: GHC.Fingerprint.Type.Fingerprint -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Int] Foreign.Storable.$fStorableFingerprint7;

Foreign.Storable.$dmpoke
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Inu ptr_s4Inv]
        Foreign.Storable.pokeElemOff
            $dStorable_s4Inu ptr_s4Inv Foreign.Storable.$fStorable()8;

Foreign.Storable.$dmpeek
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Inw ptr_s4Inx]
        Foreign.Storable.peekElemOff
            $dStorable_s4Inw ptr_s4Inx Foreign.Storable.$fStorable()8;

Foreign.Storable.$dmpokeByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)),1*U(A,A,A,A,A,A,A,1*C1(U))><L,1*U(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Iny ptr_s4Inz off_s4InA]
        let {
          sat_s4InG [Occ=Once] :: GHC.Ptr.Ptr a_a4D8k
          [LclId] =
              [ptr_s4Inz off_s4InA] \u []
                  case ptr_s4Inz of {
                    GHC.Ptr.Ptr addr_s4InC [Occ=Once] ->
                        case off_s4InA of {
                          GHC.Types.I# d_s4InE [Occ=Once] ->
                              case plusAddr# [addr_s4InC d_s4InE] of sat_s4InF {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4InF];
                              };
                        };
                  };
        } in  Foreign.Storable.poke $dStorable_s4Iny sat_s4InG;

Foreign.Storable.$dmpeekByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(S)L),1*U(A,A,A,A,A,A,1*C1(U),A)><L,1*U(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4InH ptr_s4InI off_s4InJ]
        let {
          sat_s4InP [Occ=Once] :: GHC.Ptr.Ptr a_a4D8k
          [LclId] =
              [ptr_s4InI off_s4InJ] \u []
                  case ptr_s4InI of {
                    GHC.Ptr.Ptr addr_s4InL [Occ=Once] ->
                        case off_s4InJ of {
                          GHC.Types.I# d_s4InN [Occ=Once] ->
                              case plusAddr# [addr_s4InL d_s4InN] of sat_s4InO {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4InO];
                              };
                        };
                  };
        } in  Foreign.Storable.peek $dStorable_s4InH sat_s4InP;

Foreign.Storable.$fStorableInt17
  :: GHC.Ptr.Ptr GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int64 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4InQ eta_s4InR]
        case ptr_s4InQ of {
          GHC.Ptr.Ptr a_s4InT [Occ=Once] ->
              case readInt64OffAddr# [a_s4InT 0# eta_s4InR] of {
                (#,#) ipv_s4InV [Occ=Once] ipv1_s4InW [Occ=Once] ->
                    let {
                      sat_s4InX [Occ=Once] :: GHC.Int.Int64
                      [LclId] =
                          CCCS GHC.Int.I64#! [ipv1_s4InW];
                    } in  (#,#) [ipv_s4InV sat_s4InX];
              };
        };

Foreign.Storable.$fStorableInt19
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4InY off_s4InZ eta_s4Io0]
        case ptr_s4InY of {
          GHC.Ptr.Ptr addr_s4Io2 [Occ=Once] ->
              case off_s4InZ of {
                GHC.Types.I# d_s4Io4 [Occ=Once] ->
                    case plusAddr# [addr_s4Io2 d_s4Io4] of sat_s4Io5 {
                      __DEFAULT ->
                          case readInt64OffAddr# [sat_s4Io5 0# eta_s4Io0] of {
                            (#,#) ipv_s4Io7 [Occ=Once] ipv1_s4Io8 [Occ=Once] ->
                                let {
                                  sat_s4Io9 [Occ=Once] :: GHC.Int.Int64
                                  [LclId] =
                                      CCCS GHC.Int.I64#! [ipv1_s4Io8];
                                } in  (#,#) [ipv_s4Io7 sat_s4Io9];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt15
  :: GHC.Ptr.Ptr GHC.Int.Int64
     -> GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ioa ds2_s4Iob eta_s4Ioc]
        case ptr_s4Ioa of {
          GHC.Ptr.Ptr a_s4Ioe [Occ=Once] ->
              case ds2_s4Iob of {
                GHC.Int.I64# x_s4Iog [Occ=Once] ->
                    case
                        writeInt64OffAddr# [a_s4Ioe 0# x_s4Iog eta_s4Ioc]
                    of
                    s2_s4Ioh
                    { __DEFAULT -> (#,#) [s2_s4Ioh GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt18
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ioi off_s4Ioj eta_s4Iok eta1_s4Iol]
        case ptr_s4Ioi of {
          GHC.Ptr.Ptr addr_s4Ion [Occ=Once] ->
              case off_s4Ioj of {
                GHC.Types.I# d_s4Iop [Occ=Once] ->
                    case eta_s4Iok of {
                      GHC.Int.I64# x_s4Ior [Occ=Once] ->
                          case plusAddr# [addr_s4Ion d_s4Iop] of sat_s4Ios {
                            __DEFAULT ->
                                case
                                    writeInt64OffAddr# [sat_s4Ios 0# x_s4Ior eta1_s4Iol]
                                of
                                s2_s4Iot
                                { __DEFAULT -> (#,#) [s2_s4Iot GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int64
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt64_$calignment
                                                Foreign.Storable.$fStorableInt64_$calignment
                                                GHC.Storable.readInt64OffPtr1
                                                GHC.Storable.writeInt64OffPtr1
                                                Foreign.Storable.$fStorableInt19
                                                Foreign.Storable.$fStorableInt18
                                                Foreign.Storable.$fStorableInt17
                                                Foreign.Storable.$fStorableInt15];

Foreign.Storable.$fStorableInt12
  :: GHC.Ptr.Ptr GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int32 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iou eta_s4Iov]
        case ptr_s4Iou of {
          GHC.Ptr.Ptr a_s4Iox [Occ=Once] ->
              case readInt32OffAddr# [a_s4Iox 0# eta_s4Iov] of {
                (#,#) ipv_s4Ioz [Occ=Once] ipv1_s4IoA [Occ=Once] ->
                    let {
                      sat_s4IoB [Occ=Once] :: GHC.Int.Int32
                      [LclId] =
                          CCCS GHC.Int.I32#! [ipv1_s4IoA];
                    } in  (#,#) [ipv_s4Ioz sat_s4IoB];
              };
        };

Foreign.Storable.$fStorableInt14
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IoC off_s4IoD eta_s4IoE]
        case ptr_s4IoC of {
          GHC.Ptr.Ptr addr_s4IoG [Occ=Once] ->
              case off_s4IoD of {
                GHC.Types.I# d_s4IoI [Occ=Once] ->
                    case plusAddr# [addr_s4IoG d_s4IoI] of sat_s4IoJ {
                      __DEFAULT ->
                          case readInt32OffAddr# [sat_s4IoJ 0# eta_s4IoE] of {
                            (#,#) ipv_s4IoL [Occ=Once] ipv1_s4IoM [Occ=Once] ->
                                let {
                                  sat_s4IoN [Occ=Once] :: GHC.Int.Int32
                                  [LclId] =
                                      CCCS GHC.Int.I32#! [ipv1_s4IoM];
                                } in  (#,#) [ipv_s4IoL sat_s4IoN];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt11
  :: GHC.Ptr.Ptr GHC.Int.Int32
     -> GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IoO ds2_s4IoP eta_s4IoQ]
        case ptr_s4IoO of {
          GHC.Ptr.Ptr a_s4IoS [Occ=Once] ->
              case ds2_s4IoP of {
                GHC.Int.I32# x_s4IoU [Occ=Once] ->
                    case
                        writeInt32OffAddr# [a_s4IoS 0# x_s4IoU eta_s4IoQ]
                    of
                    s2_s4IoV
                    { __DEFAULT -> (#,#) [s2_s4IoV GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt13
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IoW off_s4IoX eta_s4IoY eta1_s4IoZ]
        case ptr_s4IoW of {
          GHC.Ptr.Ptr addr_s4Ip1 [Occ=Once] ->
              case off_s4IoX of {
                GHC.Types.I# d_s4Ip3 [Occ=Once] ->
                    case eta_s4IoY of {
                      GHC.Int.I32# x_s4Ip5 [Occ=Once] ->
                          case plusAddr# [addr_s4Ip1 d_s4Ip3] of sat_s4Ip6 {
                            __DEFAULT ->
                                case
                                    writeInt32OffAddr# [sat_s4Ip6 0# x_s4Ip5 eta1_s4IoZ]
                                of
                                s2_s4Ip7
                                { __DEFAULT -> (#,#) [s2_s4Ip7 GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int32
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt32_$calignment
                                                Foreign.Storable.$fStorableInt32_$calignment
                                                GHC.Storable.readInt32OffPtr1
                                                GHC.Storable.writeInt32OffPtr1
                                                Foreign.Storable.$fStorableInt14
                                                Foreign.Storable.$fStorableInt13
                                                Foreign.Storable.$fStorableInt12
                                                Foreign.Storable.$fStorableInt11];

Foreign.Storable.$fStorableBool_$csizeOf
  :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ip8] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableBool5
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Int
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [p_s4Ip9 i_s4Ipa x_s4Ipb eta_s4Ipc]
        case p_s4Ip9 of {
          GHC.Ptr.Ptr a_s4Ipe [Occ=Once*] ->
              case i_s4Ipa of {
                GHC.Types.I# i1_s4Ipg [Occ=Once*] ->
                    case x_s4Ipb of {
                      GHC.Types.False ->
                          case
                              writeInt32OffAddr# [a_s4Ipe i1_s4Ipg 0# eta_s4Ipc]
                          of
                          s2_s4Ipi
                          { __DEFAULT -> (#,#) [s2_s4Ipi GHC.Tuple.()];
                          };
                      GHC.Types.True ->
                          case
                              writeInt32OffAddr# [a_s4Ipe i1_s4Ipg 1# eta_s4Ipc]
                          of
                          s2_s4Ipj
                          { __DEFAULT -> (#,#) [s2_s4Ipj GHC.Tuple.()];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt6
  :: GHC.Ptr.Ptr GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int16 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ipk eta_s4Ipl]
        case ptr_s4Ipk of {
          GHC.Ptr.Ptr a_s4Ipn [Occ=Once] ->
              case readInt16OffAddr# [a_s4Ipn 0# eta_s4Ipl] of {
                (#,#) ipv_s4Ipp [Occ=Once] ipv1_s4Ipq [Occ=Once] ->
                    let {
                      sat_s4Ipr [Occ=Once] :: GHC.Int.Int16
                      [LclId] =
                          CCCS GHC.Int.I16#! [ipv1_s4Ipq];
                    } in  (#,#) [ipv_s4Ipp sat_s4Ipr];
              };
        };

Foreign.Storable.$fStorableInt9
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ips off_s4Ipt eta_s4Ipu]
        case ptr_s4Ips of {
          GHC.Ptr.Ptr addr_s4Ipw [Occ=Once] ->
              case off_s4Ipt of {
                GHC.Types.I# d_s4Ipy [Occ=Once] ->
                    case plusAddr# [addr_s4Ipw d_s4Ipy] of sat_s4Ipz {
                      __DEFAULT ->
                          case readInt16OffAddr# [sat_s4Ipz 0# eta_s4Ipu] of {
                            (#,#) ipv_s4IpB [Occ=Once] ipv1_s4IpC [Occ=Once] ->
                                let {
                                  sat_s4IpD [Occ=Once] :: GHC.Int.Int16
                                  [LclId] =
                                      CCCS GHC.Int.I16#! [ipv1_s4IpC];
                                } in  (#,#) [ipv_s4IpB sat_s4IpD];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt5
  :: GHC.Ptr.Ptr GHC.Int.Int16
     -> GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IpE ds2_s4IpF eta_s4IpG]
        case ptr_s4IpE of {
          GHC.Ptr.Ptr a_s4IpI [Occ=Once] ->
              case ds2_s4IpF of {
                GHC.Int.I16# x_s4IpK [Occ=Once] ->
                    case
                        writeInt16OffAddr# [a_s4IpI 0# x_s4IpK eta_s4IpG]
                    of
                    s2_s4IpL
                    { __DEFAULT -> (#,#) [s2_s4IpL GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt7
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IpM off_s4IpN eta_s4IpO eta1_s4IpP]
        case ptr_s4IpM of {
          GHC.Ptr.Ptr addr_s4IpR [Occ=Once] ->
              case off_s4IpN of {
                GHC.Types.I# d_s4IpT [Occ=Once] ->
                    case eta_s4IpO of {
                      GHC.Int.I16# x_s4IpV [Occ=Once] ->
                          case plusAddr# [addr_s4IpR d_s4IpT] of sat_s4IpW {
                            __DEFAULT ->
                                case
                                    writeInt16OffAddr# [sat_s4IpW 0# x_s4IpV eta1_s4IpP]
                                of
                                s2_s4IpX
                                { __DEFAULT -> (#,#) [s2_s4IpX GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int16
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt16_$calignment
                                                Foreign.Storable.$fStorableInt16_$calignment
                                                GHC.Storable.readInt16OffPtr1
                                                GHC.Storable.writeInt16OffPtr1
                                                Foreign.Storable.$fStorableInt9
                                                Foreign.Storable.$fStorableInt7
                                                Foreign.Storable.$fStorableInt6
                                                Foreign.Storable.$fStorableInt5];

Foreign.Storable.$fStorableInt21
  :: GHC.Ptr.Ptr GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int8 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IpY eta_s4IpZ]
        case ptr_s4IpY of {
          GHC.Ptr.Ptr a_s4Iq1 [Occ=Once] ->
              case readInt8OffAddr# [a_s4Iq1 0# eta_s4IpZ] of {
                (#,#) ipv_s4Iq3 [Occ=Once] ipv1_s4Iq4 [Occ=Once] ->
                    let {
                      sat_s4Iq5 [Occ=Once] :: GHC.Int.Int8
                      [LclId] =
                          CCCS GHC.Int.I8#! [ipv1_s4Iq4];
                    } in  (#,#) [ipv_s4Iq3 sat_s4Iq5];
              };
        };

Foreign.Storable.$fStorableInt23
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iq6 off_s4Iq7 eta_s4Iq8]
        case ptr_s4Iq6 of {
          GHC.Ptr.Ptr addr_s4Iqa [Occ=Once] ->
              case off_s4Iq7 of {
                GHC.Types.I# d_s4Iqc [Occ=Once] ->
                    case plusAddr# [addr_s4Iqa d_s4Iqc] of sat_s4Iqd {
                      __DEFAULT ->
                          case readInt8OffAddr# [sat_s4Iqd 0# eta_s4Iq8] of {
                            (#,#) ipv_s4Iqf [Occ=Once] ipv1_s4Iqg [Occ=Once] ->
                                let {
                                  sat_s4Iqh [Occ=Once] :: GHC.Int.Int8
                                  [LclId] =
                                      CCCS GHC.Int.I8#! [ipv1_s4Iqg];
                                } in  (#,#) [ipv_s4Iqf sat_s4Iqh];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt20
  :: GHC.Ptr.Ptr GHC.Int.Int8
     -> GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iqi ds2_s4Iqj eta_s4Iqk]
        case ptr_s4Iqi of {
          GHC.Ptr.Ptr a_s4Iqm [Occ=Once] ->
              case ds2_s4Iqj of {
                GHC.Int.I8# x_s4Iqo [Occ=Once] ->
                    case writeInt8OffAddr# [a_s4Iqm 0# x_s4Iqo eta_s4Iqk] of s2_s4Iqp {
                      __DEFAULT -> (#,#) [s2_s4Iqp GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt22
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iqq off_s4Iqr eta_s4Iqs eta1_s4Iqt]
        case ptr_s4Iqq of {
          GHC.Ptr.Ptr addr_s4Iqv [Occ=Once] ->
              case off_s4Iqr of {
                GHC.Types.I# d_s4Iqx [Occ=Once] ->
                    case eta_s4Iqs of {
                      GHC.Int.I8# x_s4Iqz [Occ=Once] ->
                          case plusAddr# [addr_s4Iqv d_s4Iqx] of sat_s4IqA {
                            __DEFAULT ->
                                case
                                    writeInt8OffAddr# [sat_s4IqA 0# x_s4Iqz eta1_s4Iqt]
                                of
                                s2_s4IqB
                                { __DEFAULT -> (#,#) [s2_s4IqB GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int8
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt8_$calignment
                                                Foreign.Storable.$fStorableInt8_$calignment
                                                GHC.Storable.readInt8OffPtr1
                                                GHC.Storable.writeInt8OffPtr1
                                                Foreign.Storable.$fStorableInt23
                                                Foreign.Storable.$fStorableInt22
                                                Foreign.Storable.$fStorableInt21
                                                Foreign.Storable.$fStorableInt20];

Foreign.Storable.$fStorableWord15
  :: GHC.Ptr.Ptr GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IqC eta_s4IqD]
        case ptr_s4IqC of {
          GHC.Ptr.Ptr a_s4IqF [Occ=Once] ->
              case readWord64OffAddr# [a_s4IqF 0# eta_s4IqD] of {
                (#,#) ipv_s4IqH [Occ=Once] ipv1_s4IqI [Occ=Once] ->
                    let {
                      sat_s4IqJ [Occ=Once] :: GHC.Word.Word64
                      [LclId] =
                          CCCS GHC.Word.W64#! [ipv1_s4IqI];
                    } in  (#,#) [ipv_s4IqH sat_s4IqJ];
              };
        };

Foreign.Storable.$fStorableWord18
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IqK off_s4IqL eta_s4IqM]
        case ptr_s4IqK of {
          GHC.Ptr.Ptr addr_s4IqO [Occ=Once] ->
              case off_s4IqL of {
                GHC.Types.I# d_s4IqQ [Occ=Once] ->
                    case plusAddr# [addr_s4IqO d_s4IqQ] of sat_s4IqR {
                      __DEFAULT ->
                          case readWord64OffAddr# [sat_s4IqR 0# eta_s4IqM] of {
                            (#,#) ipv_s4IqT [Occ=Once] ipv1_s4IqU [Occ=Once] ->
                                let {
                                  sat_s4IqV [Occ=Once] :: GHC.Word.Word64
                                  [LclId] =
                                      CCCS GHC.Word.W64#! [ipv1_s4IqU];
                                } in  (#,#) [ipv_s4IqT sat_s4IqV];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord14
  :: GHC.Ptr.Ptr GHC.Word.Word64
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IqW ds2_s4IqX eta_s4IqY]
        case ptr_s4IqW of {
          GHC.Ptr.Ptr a_s4Ir0 [Occ=Once] ->
              case ds2_s4IqX of {
                GHC.Word.W64# x_s4Ir2 [Occ=Once] ->
                    case
                        writeWord64OffAddr# [a_s4Ir0 0# x_s4Ir2 eta_s4IqY]
                    of
                    s2_s4Ir3
                    { __DEFAULT -> (#,#) [s2_s4Ir3 GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord17
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ir4 off_s4Ir5 eta_s4Ir6 eta1_s4Ir7]
        case ptr_s4Ir4 of {
          GHC.Ptr.Ptr addr_s4Ir9 [Occ=Once] ->
              case off_s4Ir5 of {
                GHC.Types.I# d_s4Irb [Occ=Once] ->
                    case eta_s4Ir6 of {
                      GHC.Word.W64# x_s4Ird [Occ=Once] ->
                          case plusAddr# [addr_s4Ir9 d_s4Irb] of sat_s4Ire {
                            __DEFAULT ->
                                case
                                    writeWord64OffAddr# [sat_s4Ire 0# x_s4Ird eta1_s4Ir7]
                                of
                                s2_s4Irf
                                { __DEFAULT -> (#,#) [s2_s4Irf GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word64
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord64_$calignment
                                                Foreign.Storable.$fStorableWord64_$calignment
                                                GHC.Storable.readWord64OffPtr1
                                                GHC.Storable.writeWord64OffPtr1
                                                Foreign.Storable.$fStorableWord18
                                                Foreign.Storable.$fStorableWord17
                                                Foreign.Storable.$fStorableWord15
                                                Foreign.Storable.$fStorableWord14];

Foreign.Storable.$fStorableWord11
  :: GHC.Ptr.Ptr GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word32 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Irg eta_s4Irh]
        case ptr_s4Irg of {
          GHC.Ptr.Ptr a_s4Irj [Occ=Once] ->
              case readWord32OffAddr# [a_s4Irj 0# eta_s4Irh] of {
                (#,#) ipv_s4Irl [Occ=Once] ipv1_s4Irm [Occ=Once] ->
                    let {
                      sat_s4Irn [Occ=Once] :: GHC.Word.Word32
                      [LclId] =
                          CCCS GHC.Word.W32#! [ipv1_s4Irm];
                    } in  (#,#) [ipv_s4Irl sat_s4Irn];
              };
        };

Foreign.Storable.$fStorableWord13
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iro off_s4Irp eta_s4Irq]
        case ptr_s4Iro of {
          GHC.Ptr.Ptr addr_s4Irs [Occ=Once] ->
              case off_s4Irp of {
                GHC.Types.I# d_s4Iru [Occ=Once] ->
                    case plusAddr# [addr_s4Irs d_s4Iru] of sat_s4Irv {
                      __DEFAULT ->
                          case readWord32OffAddr# [sat_s4Irv 0# eta_s4Irq] of {
                            (#,#) ipv_s4Irx [Occ=Once] ipv1_s4Iry [Occ=Once] ->
                                let {
                                  sat_s4Irz [Occ=Once] :: GHC.Word.Word32
                                  [LclId] =
                                      CCCS GHC.Word.W32#! [ipv1_s4Iry];
                                } in  (#,#) [ipv_s4Irx sat_s4Irz];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord10
  :: GHC.Ptr.Ptr GHC.Word.Word32
     -> GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IrA ds2_s4IrB eta_s4IrC]
        case ptr_s4IrA of {
          GHC.Ptr.Ptr a_s4IrE [Occ=Once] ->
              case ds2_s4IrB of {
                GHC.Word.W32# x_s4IrG [Occ=Once] ->
                    case
                        writeWord32OffAddr# [a_s4IrE 0# x_s4IrG eta_s4IrC]
                    of
                    s2_s4IrH
                    { __DEFAULT -> (#,#) [s2_s4IrH GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord12
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IrI off_s4IrJ eta_s4IrK eta1_s4IrL]
        case ptr_s4IrI of {
          GHC.Ptr.Ptr addr_s4IrN [Occ=Once] ->
              case off_s4IrJ of {
                GHC.Types.I# d_s4IrP [Occ=Once] ->
                    case eta_s4IrK of {
                      GHC.Word.W32# x_s4IrR [Occ=Once] ->
                          case plusAddr# [addr_s4IrN d_s4IrP] of sat_s4IrS {
                            __DEFAULT ->
                                case
                                    writeWord32OffAddr# [sat_s4IrS 0# x_s4IrR eta1_s4IrL]
                                of
                                s2_s4IrT
                                { __DEFAULT -> (#,#) [s2_s4IrT GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word32
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord32_$calignment
                                                Foreign.Storable.$fStorableWord32_$calignment
                                                GHC.Storable.readWord32OffPtr1
                                                GHC.Storable.writeWord32OffPtr1
                                                Foreign.Storable.$fStorableWord13
                                                Foreign.Storable.$fStorableWord12
                                                Foreign.Storable.$fStorableWord11
                                                Foreign.Storable.$fStorableWord10];

Foreign.Storable.$fStorableWord6
  :: GHC.Ptr.Ptr GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word16 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IrU eta_s4IrV]
        case ptr_s4IrU of {
          GHC.Ptr.Ptr a_s4IrX [Occ=Once] ->
              case readWord16OffAddr# [a_s4IrX 0# eta_s4IrV] of {
                (#,#) ipv_s4IrZ [Occ=Once] ipv1_s4Is0 [Occ=Once] ->
                    let {
                      sat_s4Is1 [Occ=Once] :: GHC.Word.Word16
                      [LclId] =
                          CCCS GHC.Word.W16#! [ipv1_s4Is0];
                    } in  (#,#) [ipv_s4IrZ sat_s4Is1];
              };
        };

Foreign.Storable.$fStorableWord9
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Is2 off_s4Is3 eta_s4Is4]
        case ptr_s4Is2 of {
          GHC.Ptr.Ptr addr_s4Is6 [Occ=Once] ->
              case off_s4Is3 of {
                GHC.Types.I# d_s4Is8 [Occ=Once] ->
                    case plusAddr# [addr_s4Is6 d_s4Is8] of sat_s4Is9 {
                      __DEFAULT ->
                          case readWord16OffAddr# [sat_s4Is9 0# eta_s4Is4] of {
                            (#,#) ipv_s4Isb [Occ=Once] ipv1_s4Isc [Occ=Once] ->
                                let {
                                  sat_s4Isd [Occ=Once] :: GHC.Word.Word16
                                  [LclId] =
                                      CCCS GHC.Word.W16#! [ipv1_s4Isc];
                                } in  (#,#) [ipv_s4Isb sat_s4Isd];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord5
  :: GHC.Ptr.Ptr GHC.Word.Word16
     -> GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ise ds2_s4Isf eta_s4Isg]
        case ptr_s4Ise of {
          GHC.Ptr.Ptr a_s4Isi [Occ=Once] ->
              case ds2_s4Isf of {
                GHC.Word.W16# x_s4Isk [Occ=Once] ->
                    case
                        writeWord16OffAddr# [a_s4Isi 0# x_s4Isk eta_s4Isg]
                    of
                    s2_s4Isl
                    { __DEFAULT -> (#,#) [s2_s4Isl GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord7
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ism off_s4Isn eta_s4Iso eta1_s4Isp]
        case ptr_s4Ism of {
          GHC.Ptr.Ptr addr_s4Isr [Occ=Once] ->
              case off_s4Isn of {
                GHC.Types.I# d_s4Ist [Occ=Once] ->
                    case eta_s4Iso of {
                      GHC.Word.W16# x_s4Isv [Occ=Once] ->
                          case plusAddr# [addr_s4Isr d_s4Ist] of sat_s4Isw {
                            __DEFAULT ->
                                case
                                    writeWord16OffAddr# [sat_s4Isw 0# x_s4Isv eta1_s4Isp]
                                of
                                s2_s4Isx
                                { __DEFAULT -> (#,#) [s2_s4Isx GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word16
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord16_$calignment
                                                Foreign.Storable.$fStorableWord16_$calignment
                                                GHC.Storable.readWord16OffPtr1
                                                GHC.Storable.writeWord16OffPtr1
                                                Foreign.Storable.$fStorableWord9
                                                Foreign.Storable.$fStorableWord7
                                                Foreign.Storable.$fStorableWord6
                                                Foreign.Storable.$fStorableWord5];

Foreign.Storable.$fStorableDouble2
  :: GHC.Ptr.Ptr GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Double #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Isy eta_s4Isz]
        case ptr_s4Isy of {
          GHC.Ptr.Ptr a_s4IsB [Occ=Once] ->
              case readDoubleOffAddr# [a_s4IsB 0# eta_s4Isz] of {
                (#,#) ipv_s4IsD [Occ=Once] ipv1_s4IsE [Occ=Once] ->
                    let {
                      sat_s4IsF [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [ipv1_s4IsE];
                    } in  (#,#) [ipv_s4IsD sat_s4IsF];
              };
        };

Foreign.Storable.$fStorableDouble4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Double #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IsG off_s4IsH eta_s4IsI]
        case ptr_s4IsG of {
          GHC.Ptr.Ptr addr_s4IsK [Occ=Once] ->
              case off_s4IsH of {
                GHC.Types.I# d_s4IsM [Occ=Once] ->
                    case plusAddr# [addr_s4IsK d_s4IsM] of sat_s4IsN {
                      __DEFAULT ->
                          case readDoubleOffAddr# [sat_s4IsN 0# eta_s4IsI] of {
                            (#,#) ipv_s4IsP [Occ=Once] ipv1_s4IsQ [Occ=Once] ->
                                let {
                                  sat_s4IsR [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [ipv1_s4IsQ];
                                } in  (#,#) [ipv_s4IsP sat_s4IsR];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableDouble1
  :: GHC.Ptr.Ptr GHC.Types.Double
     -> GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IsS ds2_s4IsT eta_s4IsU]
        case ptr_s4IsS of {
          GHC.Ptr.Ptr a_s4IsW [Occ=Once] ->
              case ds2_s4IsT of {
                GHC.Types.D# x_s4IsY [Occ=Once] ->
                    case
                        writeDoubleOffAddr# [a_s4IsW 0# x_s4IsY eta_s4IsU]
                    of
                    s2_s4IsZ
                    { __DEFAULT -> (#,#) [s2_s4IsZ GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableDouble3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4It0 off_s4It1 eta_s4It2 eta1_s4It3]
        case ptr_s4It0 of {
          GHC.Ptr.Ptr addr_s4It5 [Occ=Once] ->
              case off_s4It1 of {
                GHC.Types.I# d_s4It7 [Occ=Once] ->
                    case eta_s4It2 of {
                      GHC.Types.D# x_s4It9 [Occ=Once] ->
                          case plusAddr# [addr_s4It5 d_s4It7] of sat_s4Ita {
                            __DEFAULT ->
                                case
                                    writeDoubleOffAddr# [sat_s4Ita 0# x_s4It9 eta1_s4It3]
                                of
                                s2_s4Itb
                                { __DEFAULT -> (#,#) [s2_s4Itb GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Double
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableDouble_$calignment
                                                Foreign.Storable.$fStorableDouble_$calignment
                                                GHC.Storable.readDoubleOffPtr1
                                                GHC.Storable.writeDoubleOffPtr1
                                                Foreign.Storable.$fStorableDouble4
                                                Foreign.Storable.$fStorableDouble3
                                                Foreign.Storable.$fStorableDouble2
                                                Foreign.Storable.$fStorableDouble1];

Foreign.Storable.$fStorableFloat2
  :: GHC.Ptr.Ptr GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Float #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Itc eta_s4Itd]
        case ptr_s4Itc of {
          GHC.Ptr.Ptr a_s4Itf [Occ=Once] ->
              case readFloatOffAddr# [a_s4Itf 0# eta_s4Itd] of {
                (#,#) ipv_s4Ith [Occ=Once] ipv1_s4Iti [Occ=Once] ->
                    let {
                      sat_s4Itj [Occ=Once] :: GHC.Types.Float
                      [LclId] =
                          CCCS GHC.Types.F#! [ipv1_s4Iti];
                    } in  (#,#) [ipv_s4Ith sat_s4Itj];
              };
        };

Foreign.Storable.$fStorableFloat4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Float #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Itk off_s4Itl eta_s4Itm]
        case ptr_s4Itk of {
          GHC.Ptr.Ptr addr_s4Ito [Occ=Once] ->
              case off_s4Itl of {
                GHC.Types.I# d_s4Itq [Occ=Once] ->
                    case plusAddr# [addr_s4Ito d_s4Itq] of sat_s4Itr {
                      __DEFAULT ->
                          case readFloatOffAddr# [sat_s4Itr 0# eta_s4Itm] of {
                            (#,#) ipv_s4Itt [Occ=Once] ipv1_s4Itu [Occ=Once] ->
                                let {
                                  sat_s4Itv [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [ipv1_s4Itu];
                                } in  (#,#) [ipv_s4Itt sat_s4Itv];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFloat1
  :: GHC.Ptr.Ptr GHC.Types.Float
     -> GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Itw ds2_s4Itx eta_s4Ity]
        case ptr_s4Itw of {
          GHC.Ptr.Ptr a_s4ItA [Occ=Once] ->
              case ds2_s4Itx of {
                GHC.Types.F# x_s4ItC [Occ=Once] ->
                    case
                        writeFloatOffAddr# [a_s4ItA 0# x_s4ItC eta_s4Ity]
                    of
                    s2_s4ItD
                    { __DEFAULT -> (#,#) [s2_s4ItD GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableFloat3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ItE off_s4ItF eta_s4ItG eta1_s4ItH]
        case ptr_s4ItE of {
          GHC.Ptr.Ptr addr_s4ItJ [Occ=Once] ->
              case off_s4ItF of {
                GHC.Types.I# d_s4ItL [Occ=Once] ->
                    case eta_s4ItG of {
                      GHC.Types.F# x_s4ItN [Occ=Once] ->
                          case plusAddr# [addr_s4ItJ d_s4ItL] of sat_s4ItO {
                            __DEFAULT ->
                                case
                                    writeFloatOffAddr# [sat_s4ItO 0# x_s4ItN eta1_s4ItH]
                                of
                                s2_s4ItP
                                { __DEFAULT -> (#,#) [s2_s4ItP GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Float
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFloat_$calignment
                                                Foreign.Storable.$fStorableFloat_$calignment
                                                GHC.Storable.readFloatOffPtr1
                                                GHC.Storable.writeFloatOffPtr1
                                                Foreign.Storable.$fStorableFloat4
                                                Foreign.Storable.$fStorableFloat3
                                                Foreign.Storable.$fStorableFloat2
                                                Foreign.Storable.$fStorableFloat1];

Foreign.Storable.$fStorableStablePtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Stable.StablePtr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Stable.StablePtr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ItQ eta_s4ItR]
        case ptr_s4ItQ of {
          GHC.Ptr.Ptr a1_s4ItT [Occ=Once] ->
              case readStablePtrOffAddr# [a1_s4ItT 0# eta_s4ItR] of {
                (#,#) ipv_s4ItV [Occ=Once] ipv1_s4ItW [Occ=Once] ->
                    let {
                      sat_s4ItX [Occ=Once] :: GHC.Stable.StablePtr a_a4DpH
                      [LclId] =
                          CCCS GHC.Stable.StablePtr! [ipv1_s4ItW];
                    } in  (#,#) [ipv_s4ItV sat_s4ItX];
              };
        };

Foreign.Storable.$fStorableStablePtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Stable.StablePtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ItY off_s4ItZ eta_s4Iu0]
        case ptr_s4ItY of {
          GHC.Ptr.Ptr addr_s4Iu2 [Occ=Once] ->
              case off_s4ItZ of {
                GHC.Types.I# d_s4Iu4 [Occ=Once] ->
                    case plusAddr# [addr_s4Iu2 d_s4Iu4] of sat_s4Iu5 {
                      __DEFAULT ->
                          case readStablePtrOffAddr# [sat_s4Iu5 0# eta_s4Iu0] of {
                            (#,#) ipv_s4Iu7 [Occ=Once] ipv1_s4Iu8 [Occ=Once] ->
                                let {
                                  sat_s4Iu9 [Occ=Once] :: GHC.Stable.StablePtr a_a4DpH
                                  [LclId] =
                                      CCCS GHC.Stable.StablePtr! [ipv1_s4Iu8];
                                } in  (#,#) [ipv_s4Iu7 sat_s4Iu9];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Stable.StablePtr a)
     -> GHC.Stable.StablePtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iua ds2_s4Iub eta_s4Iuc]
        case ptr_s4Iua of {
          GHC.Ptr.Ptr a1_s4Iue [Occ=Once] ->
              case ds2_s4Iub of {
                GHC.Stable.StablePtr x_s4Iug [Occ=Once] ->
                    case
                        writeStablePtrOffAddr# [a1_s4Iue 0# x_s4Iug eta_s4Iuc]
                    of
                    s2_s4Iuh
                    { __DEFAULT -> (#,#) [s2_s4Iuh GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Stable.StablePtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iui off_s4Iuj eta_s4Iuk eta1_s4Iul]
        case ptr_s4Iui of {
          GHC.Ptr.Ptr addr_s4Iun [Occ=Once] ->
              case off_s4Iuj of {
                GHC.Types.I# d_s4Iup [Occ=Once] ->
                    case eta_s4Iuk of {
                      GHC.Stable.StablePtr x_s4Iur [Occ=Once] ->
                          case plusAddr# [addr_s4Iun d_s4Iup] of sat_s4Ius {
                            __DEFAULT ->
                                case
                                    writeStablePtrOffAddr# [sat_s4Ius 0# x_s4Iur eta1_s4Iul]
                                of
                                s2_s4Iut
                                { __DEFAULT -> (#,#) [s2_s4Iut GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Stable.StablePtr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableStablePtr_$calignment
                                                Foreign.Storable.$fStorableStablePtr_$calignment
                                                GHC.Storable.readStablePtrOffPtr1
                                                GHC.Storable.writeStablePtrOffPtr1
                                                Foreign.Storable.$fStorableStablePtr4
                                                Foreign.Storable.$fStorableStablePtr3
                                                Foreign.Storable.$fStorableStablePtr2
                                                Foreign.Storable.$fStorableStablePtr1];

Foreign.Storable.$fStorableFunPtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.FunPtr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.FunPtr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iuu eta_s4Iuv]
        case ptr_s4Iuu of {
          GHC.Ptr.Ptr a1_s4Iux [Occ=Once] ->
              case readAddrOffAddr# [a1_s4Iux 0# eta_s4Iuv] of {
                (#,#) ipv_s4Iuz [Occ=Once] ipv1_s4IuA [Occ=Once] ->
                    let {
                      sat_s4IuB [Occ=Once] :: GHC.Ptr.FunPtr a_a4Dqs
                      [LclId] =
                          CCCS GHC.Ptr.FunPtr! [ipv1_s4IuA];
                    } in  (#,#) [ipv_s4Iuz sat_s4IuB];
              };
        };

Foreign.Storable.$fStorableFunPtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.FunPtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IuC off_s4IuD eta_s4IuE]
        case ptr_s4IuC of {
          GHC.Ptr.Ptr addr_s4IuG [Occ=Once] ->
              case off_s4IuD of {
                GHC.Types.I# d_s4IuI [Occ=Once] ->
                    case plusAddr# [addr_s4IuG d_s4IuI] of sat_s4IuJ {
                      __DEFAULT ->
                          case readAddrOffAddr# [sat_s4IuJ 0# eta_s4IuE] of {
                            (#,#) ipv_s4IuL [Occ=Once] ipv1_s4IuM [Occ=Once] ->
                                let {
                                  sat_s4IuN [Occ=Once] :: GHC.Ptr.FunPtr a_a4Dqs
                                  [LclId] =
                                      CCCS GHC.Ptr.FunPtr! [ipv1_s4IuM];
                                } in  (#,#) [ipv_s4IuL sat_s4IuN];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.FunPtr a)
     -> GHC.Ptr.FunPtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IuO ds2_s4IuP eta_s4IuQ]
        case ptr_s4IuO of {
          GHC.Ptr.Ptr a1_s4IuS [Occ=Once] ->
              case ds2_s4IuP of {
                GHC.Ptr.FunPtr x_s4IuU [Occ=Once] ->
                    case
                        writeAddrOffAddr# [a1_s4IuS 0# x_s4IuU eta_s4IuQ]
                    of
                    s2_s4IuV
                    { __DEFAULT -> (#,#) [s2_s4IuV GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Ptr.FunPtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IuW off_s4IuX eta_s4IuY eta1_s4IuZ]
        case ptr_s4IuW of {
          GHC.Ptr.Ptr addr_s4Iv1 [Occ=Once] ->
              case off_s4IuX of {
                GHC.Types.I# d_s4Iv3 [Occ=Once] ->
                    case eta_s4IuY of {
                      GHC.Ptr.FunPtr x_s4Iv5 [Occ=Once] ->
                          case plusAddr# [addr_s4Iv1 d_s4Iv3] of sat_s4Iv6 {
                            __DEFAULT ->
                                case
                                    writeAddrOffAddr# [sat_s4Iv6 0# x_s4Iv5 eta1_s4IuZ]
                                of
                                s2_s4Iv7
                                { __DEFAULT -> (#,#) [s2_s4Iv7 GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Ptr.FunPtr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFunPtr_$calignment
                                                Foreign.Storable.$fStorableFunPtr_$calignment
                                                GHC.Storable.readFunPtrOffPtr1
                                                GHC.Storable.writeFunPtrOffPtr1
                                                Foreign.Storable.$fStorableFunPtr4
                                                Foreign.Storable.$fStorableFunPtr3
                                                Foreign.Storable.$fStorableFunPtr2
                                                Foreign.Storable.$fStorableFunPtr1];

Foreign.Storable.$fStorablePtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.Ptr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.Ptr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iv8 eta_s4Iv9]
        case ptr_s4Iv8 of {
          GHC.Ptr.Ptr a1_s4Ivb [Occ=Once] ->
              case readAddrOffAddr# [a1_s4Ivb 0# eta_s4Iv9] of {
                (#,#) ipv_s4Ivd [Occ=Once] ipv1_s4Ive [Occ=Once] ->
                    let {
                      sat_s4Ivf [Occ=Once] :: GHC.Ptr.Ptr a_a4Drd
                      [LclId] =
                          CCCS GHC.Ptr.Ptr! [ipv1_s4Ive];
                    } in  (#,#) [ipv_s4Ivd sat_s4Ivf];
              };
        };

Foreign.Storable.$fStorablePtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.Ptr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ivg off_s4Ivh eta_s4Ivi]
        case ptr_s4Ivg of {
          GHC.Ptr.Ptr addr_s4Ivk [Occ=Once] ->
              case off_s4Ivh of {
                GHC.Types.I# d_s4Ivm [Occ=Once] ->
                    case plusAddr# [addr_s4Ivk d_s4Ivm] of sat_s4Ivn {
                      __DEFAULT ->
                          case readAddrOffAddr# [sat_s4Ivn 0# eta_s4Ivi] of {
                            (#,#) ipv_s4Ivp [Occ=Once] ipv1_s4Ivq [Occ=Once] ->
                                let {
                                  sat_s4Ivr [Occ=Once] :: GHC.Ptr.Ptr a_a4Drd
                                  [LclId] =
                                      CCCS GHC.Ptr.Ptr! [ipv1_s4Ivq];
                                } in  (#,#) [ipv_s4Ivp sat_s4Ivr];
                          };
                    };
              };
        };

Foreign.Storable.$fStorablePtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.Ptr a)
     -> GHC.Ptr.Ptr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ivs ds2_s4Ivt eta_s4Ivu]
        case ptr_s4Ivs of {
          GHC.Ptr.Ptr a1_s4Ivw [Occ=Once] ->
              case ds2_s4Ivt of {
                GHC.Ptr.Ptr x_s4Ivy [Occ=Once] ->
                    case
                        writeAddrOffAddr# [a1_s4Ivw 0# x_s4Ivy eta_s4Ivu]
                    of
                    s2_s4Ivz
                    { __DEFAULT -> (#,#) [s2_s4Ivz GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorablePtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Ptr.Ptr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IvA off_s4IvB eta_s4IvC eta1_s4IvD]
        case ptr_s4IvA of {
          GHC.Ptr.Ptr addr_s4IvF [Occ=Once] ->
              case off_s4IvB of {
                GHC.Types.I# d_s4IvH [Occ=Once] ->
                    case eta_s4IvC of {
                      GHC.Ptr.Ptr x_s4IvJ [Occ=Once] ->
                          case plusAddr# [addr_s4IvF d_s4IvH] of sat_s4IvK {
                            __DEFAULT ->
                                case
                                    writeAddrOffAddr# [sat_s4IvK 0# x_s4IvJ eta1_s4IvD]
                                of
                                s2_s4IvL
                                { __DEFAULT -> (#,#) [s2_s4IvL GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorablePtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Ptr.Ptr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorablePtr_$calignment
                                                Foreign.Storable.$fStorablePtr_$calignment
                                                GHC.Storable.readPtrOffPtr1
                                                GHC.Storable.writePtrOffPtr1
                                                Foreign.Storable.$fStorablePtr4
                                                Foreign.Storable.$fStorablePtr3
                                                Foreign.Storable.$fStorablePtr2
                                                Foreign.Storable.$fStorablePtr1];

Foreign.Storable.$fStorableWord2
  :: GHC.Ptr.Ptr GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Word #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IvM eta_s4IvN]
        case ptr_s4IvM of {
          GHC.Ptr.Ptr a_s4IvP [Occ=Once] ->
              case readWordOffAddr# [a_s4IvP 0# eta_s4IvN] of {
                (#,#) ipv_s4IvR [Occ=Once] ipv1_s4IvS [Occ=Once] ->
                    let {
                      sat_s4IvT [Occ=Once] :: GHC.Types.Word
                      [LclId] =
                          CCCS GHC.Types.W#! [ipv1_s4IvS];
                    } in  (#,#) [ipv_s4IvR sat_s4IvT];
              };
        };

Foreign.Storable.$fStorableWord4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Word #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IvU off_s4IvV eta_s4IvW]
        case ptr_s4IvU of {
          GHC.Ptr.Ptr addr_s4IvY [Occ=Once] ->
              case off_s4IvV of {
                GHC.Types.I# d_s4Iw0 [Occ=Once] ->
                    case plusAddr# [addr_s4IvY d_s4Iw0] of sat_s4Iw1 {
                      __DEFAULT ->
                          case readWordOffAddr# [sat_s4Iw1 0# eta_s4IvW] of {
                            (#,#) ipv_s4Iw3 [Occ=Once] ipv1_s4Iw4 [Occ=Once] ->
                                let {
                                  sat_s4Iw5 [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv1_s4Iw4];
                                } in  (#,#) [ipv_s4Iw3 sat_s4Iw5];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord1
  :: GHC.Ptr.Ptr GHC.Types.Word
     -> GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iw6 ds2_s4Iw7 eta_s4Iw8]
        case ptr_s4Iw6 of {
          GHC.Ptr.Ptr a_s4Iwa [Occ=Once] ->
              case ds2_s4Iw7 of {
                GHC.Types.W# x_s4Iwc [Occ=Once] ->
                    case writeWordOffAddr# [a_s4Iwa 0# x_s4Iwc eta_s4Iw8] of s2_s4Iwd {
                      __DEFAULT -> (#,#) [s2_s4Iwd GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iwe off_s4Iwf eta_s4Iwg eta1_s4Iwh]
        case ptr_s4Iwe of {
          GHC.Ptr.Ptr addr_s4Iwj [Occ=Once] ->
              case off_s4Iwf of {
                GHC.Types.I# d_s4Iwl [Occ=Once] ->
                    case eta_s4Iwg of {
                      GHC.Types.W# x_s4Iwn [Occ=Once] ->
                          case plusAddr# [addr_s4Iwj d_s4Iwl] of sat_s4Iwo {
                            __DEFAULT ->
                                case
                                    writeWordOffAddr# [sat_s4Iwo 0# x_s4Iwn eta1_s4Iwh]
                                of
                                s2_s4Iwp
                                { __DEFAULT -> (#,#) [s2_s4Iwp GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord_$calignment
                                                Foreign.Storable.$fStorableWord_$calignment
                                                GHC.Storable.readWordOffPtr1
                                                GHC.Storable.writeWordOffPtr1
                                                Foreign.Storable.$fStorableWord4
                                                Foreign.Storable.$fStorableWord3
                                                Foreign.Storable.$fStorableWord2
                                                Foreign.Storable.$fStorableWord1];

Foreign.Storable.$fStorableInt2
  :: GHC.Ptr.Ptr GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iwq eta_s4Iwr]
        case ptr_s4Iwq of {
          GHC.Ptr.Ptr a_s4Iwt [Occ=Once] ->
              case readIntOffAddr# [a_s4Iwt 0# eta_s4Iwr] of {
                (#,#) ipv_s4Iwv [Occ=Once] ipv1_s4Iww [Occ=Once] ->
                    let {
                      sat_s4Iwx [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [ipv1_s4Iww];
                    } in  (#,#) [ipv_s4Iwv sat_s4Iwx];
              };
        };

Foreign.Storable.$fStorableInt4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iwy off_s4Iwz eta_s4IwA]
        case ptr_s4Iwy of {
          GHC.Ptr.Ptr addr_s4IwC [Occ=Once] ->
              case off_s4Iwz of {
                GHC.Types.I# d_s4IwE [Occ=Once] ->
                    case plusAddr# [addr_s4IwC d_s4IwE] of sat_s4IwF {
                      __DEFAULT ->
                          case readIntOffAddr# [sat_s4IwF 0# eta_s4IwA] of {
                            (#,#) ipv_s4IwH [Occ=Once] ipv1_s4IwI [Occ=Once] ->
                                let {
                                  sat_s4IwJ [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s4IwI];
                                } in  (#,#) [ipv_s4IwH sat_s4IwJ];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt1
  :: GHC.Ptr.Ptr GHC.Types.Int
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IwK ds2_s4IwL eta_s4IwM]
        case ptr_s4IwK of {
          GHC.Ptr.Ptr a_s4IwO [Occ=Once] ->
              case ds2_s4IwL of {
                GHC.Types.I# x_s4IwQ [Occ=Once] ->
                    case writeIntOffAddr# [a_s4IwO 0# x_s4IwQ eta_s4IwM] of s2_s4IwR {
                      __DEFAULT -> (#,#) [s2_s4IwR GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IwS off_s4IwT eta_s4IwU eta1_s4IwV]
        case ptr_s4IwS of {
          GHC.Ptr.Ptr addr_s4IwX [Occ=Once] ->
              case off_s4IwT of {
                GHC.Types.I# d_s4IwZ [Occ=Once] ->
                    case eta_s4IwU of {
                      GHC.Types.I# x_s4Ix1 [Occ=Once] ->
                          case plusAddr# [addr_s4IwX d_s4IwZ] of sat_s4Ix2 {
                            __DEFAULT ->
                                case
                                    writeIntOffAddr# [sat_s4Ix2 0# x_s4Ix1 eta1_s4IwV]
                                of
                                s2_s4Ix3
                                { __DEFAULT -> (#,#) [s2_s4Ix3 GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt_$calignment
                                                Foreign.Storable.$fStorableInt_$calignment
                                                GHC.Storable.readIntOffPtr1
                                                GHC.Storable.writeIntOffPtr1
                                                Foreign.Storable.$fStorableInt4
                                                Foreign.Storable.$fStorableInt3
                                                Foreign.Storable.$fStorableInt2
                                                Foreign.Storable.$fStorableInt1];

Foreign.Storable.$fStorableChar2
  :: GHC.Ptr.Ptr GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Char #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ix4 eta_s4Ix5]
        case ptr_s4Ix4 of {
          GHC.Ptr.Ptr a_s4Ix7 [Occ=Once] ->
              case readWideCharOffAddr# [a_s4Ix7 0# eta_s4Ix5] of {
                (#,#) ipv_s4Ix9 [Occ=Once] ipv1_s4Ixa [Occ=Once] ->
                    let {
                      sat_s4Ixb [Occ=Once] :: GHC.Types.Char
                      [LclId] =
                          CCCS GHC.Types.C#! [ipv1_s4Ixa];
                    } in  (#,#) [ipv_s4Ix9 sat_s4Ixb];
              };
        };

Foreign.Storable.$fStorableChar4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Char #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ixc off_s4Ixd eta_s4Ixe]
        case ptr_s4Ixc of {
          GHC.Ptr.Ptr addr_s4Ixg [Occ=Once] ->
              case off_s4Ixd of {
                GHC.Types.I# d_s4Ixi [Occ=Once] ->
                    case plusAddr# [addr_s4Ixg d_s4Ixi] of sat_s4Ixj {
                      __DEFAULT ->
                          case readWideCharOffAddr# [sat_s4Ixj 0# eta_s4Ixe] of {
                            (#,#) ipv_s4Ixl [Occ=Once] ipv1_s4Ixm [Occ=Once] ->
                                let {
                                  sat_s4Ixn [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ipv1_s4Ixm];
                                } in  (#,#) [ipv_s4Ixl sat_s4Ixn];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableChar1
  :: GHC.Ptr.Ptr GHC.Types.Char
     -> GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ixo ds2_s4Ixp eta_s4Ixq]
        case ptr_s4Ixo of {
          GHC.Ptr.Ptr a_s4Ixs [Occ=Once] ->
              case ds2_s4Ixp of {
                GHC.Types.C# x_s4Ixu [Occ=Once] ->
                    case
                        writeWideCharOffAddr# [a_s4Ixs 0# x_s4Ixu eta_s4Ixq]
                    of
                    s2_s4Ixv
                    { __DEFAULT -> (#,#) [s2_s4Ixv GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableChar3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ixw off_s4Ixx eta_s4Ixy eta1_s4Ixz]
        case ptr_s4Ixw of {
          GHC.Ptr.Ptr addr_s4IxB [Occ=Once] ->
              case off_s4Ixx of {
                GHC.Types.I# d_s4IxD [Occ=Once] ->
                    case eta_s4Ixy of {
                      GHC.Types.C# x_s4IxF [Occ=Once] ->
                          case plusAddr# [addr_s4IxB d_s4IxD] of sat_s4IxG {
                            __DEFAULT ->
                                case
                                    writeWideCharOffAddr# [sat_s4IxG 0# x_s4IxF eta1_s4Ixz]
                                of
                                s2_s4IxH
                                { __DEFAULT -> (#,#) [s2_s4IxH GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Char
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableChar_$calignment
                                                Foreign.Storable.$fStorableChar_$calignment
                                                GHC.Storable.readWideCharOffPtr1
                                                GHC.Storable.writeWideCharOffPtr1
                                                Foreign.Storable.$fStorableChar4
                                                Foreign.Storable.$fStorableChar3
                                                Foreign.Storable.$fStorableChar2
                                                Foreign.Storable.$fStorableChar1];

Foreign.Storable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$trModule4];

Foreign.Storable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$trModule2];

Foreign.Storable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Foreign.Storable.$trModule3
                                     Foreign.Storable.$trModule1];

$krep_r4Ffk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Foreign.Storable.$tcStorable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep_r4Ffk];

Foreign.Storable.$tcStorable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Storable"#;

Foreign.Storable.$tcStorable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$tcStorable3];

Foreign.Storable.$tcStorable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9192657549155052097##
                                    13909834202100645491##
                                    Foreign.Storable.$trModule
                                    Foreign.Storable.$tcStorable2
                                    0#
                                    Foreign.Storable.$tcStorable1];

Foreign.Storable.$fStorableWord20
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word8 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IxI eta_s4IxJ]
        case ptr_s4IxI of {
          GHC.Ptr.Ptr a_s4IxL [Occ=Once] ->
              case readWord8OffAddr# [a_s4IxL 0# eta_s4IxJ] of {
                (#,#) ipv_s4IxN [Occ=Once] ipv1_s4IxO [Occ=Once] ->
                    let {
                      sat_s4IxP [Occ=Once] :: GHC.Word.Word8
                      [LclId] =
                          CCCS GHC.Word.W8#! [ipv1_s4IxO];
                    } in  (#,#) [ipv_s4IxN sat_s4IxP];
              };
        };

Foreign.Storable.$fStorableWord22
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IxQ off_s4IxR eta_s4IxS]
        case ptr_s4IxQ of {
          GHC.Ptr.Ptr addr_s4IxU [Occ=Once] ->
              case off_s4IxR of {
                GHC.Types.I# d_s4IxW [Occ=Once] ->
                    case plusAddr# [addr_s4IxU d_s4IxW] of sat_s4IxX {
                      __DEFAULT ->
                          case readWord8OffAddr# [sat_s4IxX 0# eta_s4IxS] of {
                            (#,#) ipv_s4IxZ [Occ=Once] ipv1_s4Iy0 [Occ=Once] ->
                                let {
                                  sat_s4Iy1 [Occ=Once] :: GHC.Word.Word8
                                  [LclId] =
                                      CCCS GHC.Word.W8#! [ipv1_s4Iy0];
                                } in  (#,#) [ipv_s4IxZ sat_s4Iy1];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord19
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iy2 ds2_s4Iy3 eta_s4Iy4]
        case ptr_s4Iy2 of {
          GHC.Ptr.Ptr a_s4Iy6 [Occ=Once] ->
              case ds2_s4Iy3 of {
                GHC.Word.W8# x_s4Iy8 [Occ=Once] ->
                    case
                        writeWord8OffAddr# [a_s4Iy6 0# x_s4Iy8 eta_s4Iy4]
                    of
                    s2_s4Iy9
                    { __DEFAULT -> (#,#) [s2_s4Iy9 GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord21
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iya off_s4Iyb eta_s4Iyc eta1_s4Iyd]
        case ptr_s4Iya of {
          GHC.Ptr.Ptr addr_s4Iyf [Occ=Once] ->
              case off_s4Iyb of {
                GHC.Types.I# d_s4Iyh [Occ=Once] ->
                    case eta_s4Iyc of {
                      GHC.Word.W8# x_s4Iyj [Occ=Once] ->
                          case plusAddr# [addr_s4Iyf d_s4Iyh] of sat_s4Iyk {
                            __DEFAULT ->
                                case
                                    writeWord8OffAddr# [sat_s4Iyk 0# x_s4Iyj eta1_s4Iyd]
                                of
                                s2_s4Iyl
                                { __DEFAULT -> (#,#) [s2_s4Iyl GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word8
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord8_$calignment
                                                Foreign.Storable.$fStorableWord8_$calignment
                                                GHC.Storable.readWord8OffPtr1
                                                GHC.Storable.writeWord8OffPtr1
                                                Foreign.Storable.$fStorableWord22
                                                Foreign.Storable.$fStorableWord21
                                                Foreign.Storable.$fStorableWord20
                                                Foreign.Storable.$fStorableWord19];

Foreign.Storable.$fStorableRatio2
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=4,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,1*C1(C1(C1(U(U,U)))),A,A,A,1*C1(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Iym $dIntegral_s4Iyn p_s4Iyo s_s4Iyp]
        case Foreign.Storable.peek $dStorable_s4Iym p_s4Iyo s_s4Iyp of {
          (#,#) ipv_s4Iyr [Occ=Once] ipv1_s4Iys [Occ=Once] ->
              case
                  Foreign.Storable.peekElemOff
                      $dStorable_s4Iym p_s4Iyo Foreign.Storable.$fStorable()7 ipv_s4Iyr
              of
              { (#,#) ipv2_s4Iyu [Occ=Once] ipv3_s4Iyv [Occ=Once] ->
                    let {
                      sat_s4Iyw [Occ=Once] :: GHC.Real.Ratio a_a4DgH
                      [LclId] =
                          [$dIntegral_s4Iyn ipv1_s4Iys ipv3_s4Iyv] \u []
                              GHC.Real.% $dIntegral_s4Iyn ipv1_s4Iys ipv3_s4Iyv;
                    } in  (#,#) [ipv2_s4Iyu sat_s4Iyw];
              };
        };

Foreign.Storable.$fStorableRatio1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,A><L,U><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Iyx w1_s4Iyy w2_s4Iyz w3_s4IyA w4_s4IyB]
        case w3_s4IyA of {
          GHC.Real.:% ww1_s4IyD [Occ=Once] ww2_s4IyE [Occ=Once] ->
              case Foreign.Storable.poke w_s4Iyx w2_s4Iyz ww1_s4IyD w4_s4IyB of {
                (#,#) ipv_s4IyG [Occ=Once] _ [Occ=Dead] ->
                    Foreign.Storable.pokeElemOff
                        w_s4Iyx
                        w2_s4Iyz
                        Foreign.Storable.$fStorable()7
                        ww2_s4IyE
                        ipv_s4IyG;
              };
        };

Foreign.Storable.$fStorableBool6
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [p_s4IyI i_s4IyJ eta_s4IyK]
        case p_s4IyI of {
          GHC.Ptr.Ptr a_s4IyM [Occ=Once] ->
              case i_s4IyJ of {
                GHC.Types.I# i1_s4IyO [Occ=Once] ->
                    case readInt32OffAddr# [a_s4IyM i1_s4IyO eta_s4IyK] of {
                      (#,#) ipv_s4IyQ [Occ=Once] ipv1_s4IyR [Occ=Once!] ->
                          let {
                            sat_s4IyT [Occ=Once] :: GHC.Types.Bool
                            [LclId] =
                                [ipv1_s4IyR] \u []
                                    case ipv1_s4IyR of {
                                      __DEFAULT -> GHC.Types.True [];
                                      0# -> GHC.Types.False [];
                                    };
                          } in  (#,#) [ipv_s4IyQ sat_s4IyT];
                    };
              };
        };

Foreign.Storable.$fStorableBool2
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IyU eta_s4IyV]
        case ptr_s4IyU of {
          GHC.Ptr.Ptr a_s4IyX [Occ=Once] ->
              case readInt32OffAddr# [a_s4IyX 0# eta_s4IyV] of {
                (#,#) ipv_s4IyZ [Occ=Once] ipv1_s4Iz0 [Occ=Once!] ->
                    let {
                      sat_s4Iz2 [Occ=Once] :: GHC.Types.Bool
                      [LclId] =
                          [ipv1_s4Iz0] \u []
                              case ipv1_s4Iz0 of {
                                __DEFAULT -> GHC.Types.True [];
                                0# -> GHC.Types.False [];
                              };
                    } in  (#,#) [ipv_s4IyZ sat_s4Iz2];
              };
        };

Foreign.Storable.$fStorableBool4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iz3 off_s4Iz4 eta_s4Iz5]
        case ptr_s4Iz3 of {
          GHC.Ptr.Ptr addr_s4Iz7 [Occ=Once] ->
              case off_s4Iz4 of {
                GHC.Types.I# d_s4Iz9 [Occ=Once] ->
                    case plusAddr# [addr_s4Iz7 d_s4Iz9] of sat_s4Iza {
                      __DEFAULT ->
                          case readInt32OffAddr# [sat_s4Iza 0# eta_s4Iz5] of {
                            (#,#) ipv_s4Izc [Occ=Once] ipv1_s4Izd [Occ=Once!] ->
                                let {
                                  sat_s4Izf [Occ=Once] :: GHC.Types.Bool
                                  [LclId] =
                                      [ipv1_s4Izd] \u []
                                          case ipv1_s4Izd of {
                                            __DEFAULT -> GHC.Types.True [];
                                            0# -> GHC.Types.False [];
                                          };
                                } in  (#,#) [ipv_s4Izc sat_s4Izf];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableBool1
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Izg x_s4Izh eta_s4Izi]
        case ptr_s4Izg of {
          GHC.Ptr.Ptr a_s4Izk [Occ=Once*] ->
              case x_s4Izh of {
                GHC.Types.False ->
                    case writeInt32OffAddr# [a_s4Izk 0# 0# eta_s4Izi] of s2_s4Izm {
                      __DEFAULT -> (#,#) [s2_s4Izm GHC.Tuple.()];
                    };
                GHC.Types.True ->
                    case writeInt32OffAddr# [a_s4Izk 0# 1# eta_s4Izi] of s2_s4Izn {
                      __DEFAULT -> (#,#) [s2_s4Izn GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableBool3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Izo off_s4Izp eta_s4Izq eta1_s4Izr]
        case ptr_s4Izo of {
          GHC.Ptr.Ptr addr_s4Izt [Occ=Once*] ->
              case off_s4Izp of {
                GHC.Types.I# d_s4Izv [Occ=Once*] ->
                    case eta_s4Izq of {
                      GHC.Types.False ->
                          case plusAddr# [addr_s4Izt d_s4Izv] of sat_s4Izx {
                            __DEFAULT ->
                                case writeInt32OffAddr# [sat_s4Izx 0# 0# eta1_s4Izr] of s2_s4Izy {
                                  __DEFAULT -> (#,#) [s2_s4Izy GHC.Tuple.()];
                                };
                          };
                      GHC.Types.True ->
                          case plusAddr# [addr_s4Izt d_s4Izv] of sat_s4Izz {
                            __DEFAULT ->
                                case writeInt32OffAddr# [sat_s4Izz 0# 1# eta1_s4Izr] of s2_s4IzA {
                                  __DEFAULT -> (#,#) [s2_s4IzA GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableBool_$csizeOf
                                                Foreign.Storable.$fStorableBool_$csizeOf
                                                Foreign.Storable.$fStorableBool6
                                                Foreign.Storable.$fStorableBool5
                                                Foreign.Storable.$fStorableBool4
                                                Foreign.Storable.$fStorableBool3
                                                Foreign.Storable.$fStorableBool2
                                                Foreign.Storable.$fStorableBool1];

Foreign.Storable.$fStorable()2
  :: GHC.Ptr.Ptr ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><S,U>, Unf=OtherCon []] =
    [] \r [ds_s4IzB s_s4IzC] (#,#) [s_s4IzC GHC.Tuple.()];

Foreign.Storable.$fStorable()1
  :: GHC.Ptr.Ptr ()
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_s4IzD ds1_s4IzE s_s4IzF] (#,#) [s_s4IzF GHC.Tuple.()];

lvl11_r4Ffl :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [137#];

lvl12_r4Ffm :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [31#];

lvl13_r4Ffn :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [40#];

lvl14_r4Ffo :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl11_r4Ffl
                                           lvl12_r4Ffm
                                           lvl11_r4Ffl
                                           lvl13_r4Ffn];

lvl15_r4Ffp :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl14_r4Ffo
                                                  GHC.Stack.Types.EmptyCallStack];

lvl16_r4Ffq :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl15_r4Ffp;

Foreign.Storable.$dmpeekElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
[GblId,
 Arity=3,
 Str=<S(LLLLC(C(S))LLL),U(1*C1(U(U)),A,A,A,1*C1(C1(U)),A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4IzG ptr_s4IzH off_s4IzI]
        let {
          sat_s4IzO [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4IzG off_s4IzI] \u []
                  case off_s4IzI of {
                    GHC.Types.I# x_s4IzK [Occ=Once] ->
                        case Foreign.Storable.sizeOf $dStorable_s4IzG lvl16_r4Ffq of {
                          GHC.Types.I# y_s4IzM [Occ=Once] ->
                              case *# [x_s4IzK y_s4IzM] of sat_s4IzN {
                                __DEFAULT -> GHC.Types.I# [sat_s4IzN];
                              };
                        };
                  };
        } in 
          Foreign.Storable.peekByteOff $dStorable_s4IzG ptr_s4IzH sat_s4IzO;

Foreign.Storable.$dmpokeElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(C(S)))LL),U(1*C1(U(U)),A,A,A,A,1*C1(C1(C1(U))),A,A)><L,U><L,1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4IzP ptr_s4IzQ off_s4IzR val_s4IzS]
        let {
          sat_s4IzY [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4IzP off_s4IzR val_s4IzS] \u []
                  case off_s4IzR of {
                    GHC.Types.I# x_s4IzU [Occ=Once] ->
                        case Foreign.Storable.sizeOf $dStorable_s4IzP val_s4IzS of {
                          GHC.Types.I# y_s4IzW [Occ=Once] ->
                              case *# [x_s4IzU y_s4IzW] of sat_s4IzX {
                                __DEFAULT -> GHC.Types.I# [sat_s4IzX];
                              };
                        };
                  };
        } in 
          Foreign.Storable.pokeByteOff
              $dStorable_s4IzP ptr_s4IzQ sat_s4IzY val_s4IzS;

Foreign.Storable.$fStorable()4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IzZ off_s4IA0 s_s4IA1] (#,#) [s_s4IA1 GHC.Tuple.()];

Foreign.Storable.$fStorable()6
  :: GHC.Ptr.Ptr ()
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IA2 off_s4IA3 s_s4IA4] (#,#) [s_s4IA4 GHC.Tuple.()];

Foreign.Storable.$fStorable()3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IA5 off_s4IA6 ds_s4IA7 s_s4IA8]
        (#,#) [s_s4IA8 GHC.Tuple.()];

Foreign.Storable.$fStorable()5
  :: GHC.Ptr.Ptr ()
     -> GHC.Types.Int
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IA9 off_s4IAa val_s4IAb eta_s4IAc]
        (#,#) [eta_s4IAc GHC.Tuple.()];

Foreign.Storable.$fStorable() [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorable()_$csizeOf
                                                Foreign.Storable.$fStorable()_$calignment
                                                Foreign.Storable.$fStorable()6
                                                Foreign.Storable.$fStorable()5
                                                Foreign.Storable.$fStorable()4
                                                Foreign.Storable.$fStorable()3
                                                Foreign.Storable.$fStorable()2
                                                Foreign.Storable.$fStorable()1];

lvl17_r4Ffr :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [237#];

lvl18_r4Ffs :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl17_r4Ffr
                                           lvl12_r4Ffm
                                           lvl17_r4Ffr
                                           lvl13_r4Ffn];

lvl19_r4Fft :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl18_r4Ffs
                                                  GHC.Stack.Types.EmptyCallStack];

Foreign.Storable.$fStorableRatio6 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl19_r4Fft;

Foreign.Storable.$fStorableRatio_$csizeOf
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(U(U)),A,A,A,A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4IAd $dIntegral_s4IAe]
        let {
          lvl20_s4IAf [Occ=OnceL!, Dmd=<L,U(U)>] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4IAd] \u []
                  Foreign.Storable.sizeOf
                      $dStorable_s4IAd Foreign.Storable.$fStorableRatio6; } in
        let {
          sat_s4IAk [Occ=OnceT[0]] :: GHC.Real.Ratio a_X4DnT -> GHC.Types.Int
          [LclId] =
              [lvl20_s4IAf] \r [ds_s4IAg]
                  case lvl20_s4IAf of {
                    GHC.Types.I# y_s4IAi [Occ=Once] ->
                        case *# [2# y_s4IAi] of sat_s4IAj {
                          __DEFAULT -> GHC.Types.I# [sat_s4IAj];
                        };
                  };
        } in  sat_s4IAk;

Foreign.Storable.$fStorableRatio4
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4IAl
           $dIntegral_s4IAm
           ptr_s4IAn
           off_s4IAo
           eta_s4IAp]
        let {
          sat_s4IAv [Occ=Once] :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnX)
          [LclId] =
              [ptr_s4IAn off_s4IAo] \u []
                  case ptr_s4IAn of {
                    GHC.Ptr.Ptr addr_s4IAr [Occ=Once] ->
                        case off_s4IAo of {
                          GHC.Types.I# d_s4IAt [Occ=Once] ->
                              case plusAddr# [addr_s4IAr d_s4IAt] of sat_s4IAu {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4IAu];
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableRatio2
              $dStorable_s4IAl $dIntegral_s4IAm sat_s4IAv eta_s4IAp;

Foreign.Storable.$fStorableRatio7
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S(SL)))L),U(1*C1(U(U)),A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4IAw
           $dIntegral_s4IAx
           ptr_s4IAy
           off_s4IAz
           eta_s4IAA]
        let {
          sat_s4IAK [Occ=Once] :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnY)
          [LclId] =
              [$dStorable_s4IAw ptr_s4IAy off_s4IAz] \u []
                  case ptr_s4IAy of {
                    GHC.Ptr.Ptr addr_s4IAC [Occ=Once] ->
                        case off_s4IAz of {
                          GHC.Types.I# x_s4IAE [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf
                                      $dStorable_s4IAw Foreign.Storable.$fStorableRatio6
                              of
                              { GHC.Types.I# y_s4IAG [Occ=Once] ->
                                    case *# [2# y_s4IAG] of sat_s4IAH {
                                      __DEFAULT ->
                                          case *# [x_s4IAE sat_s4IAH] of sat_s4IAI {
                                            __DEFAULT ->
                                                case plusAddr# [addr_s4IAC sat_s4IAI] of sat_s4IAJ {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4IAJ];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableRatio2
              $dStorable_s4IAw $dIntegral_s4IAx sat_s4IAK eta_s4IAA;

Foreign.Storable.$w$cpokeByteOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IAL w1_s4IAM w2_s4IAN ww_s4IAO ww1_s4IAP w3_s4IAQ]
        let {
          p_s4IAR :: GHC.Ptr.Ptr (GHC.Real.Ratio a_s4EvU)
          [LclId] =
              [w1_s4IAM w2_s4IAN] \u []
                  case w1_s4IAM of {
                    GHC.Ptr.Ptr addr_s4IAT [Occ=Once] ->
                        case w2_s4IAN of {
                          GHC.Types.I# d_s4IAV [Occ=Once] ->
                              case plusAddr# [addr_s4IAT d_s4IAV] of sat_s4IAW {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4IAW];
                              };
                        };
                  };
        } in 
          case Foreign.Storable.poke w_s4IAL p_s4IAR ww_s4IAO w3_s4IAQ of {
            (#,#) ipv_s4IAY [Occ=Once] _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_s4IAL p_s4IAR Foreign.Storable.$fStorable()7 ww1_s4IAP ipv_s4IAY;
          };

Foreign.Storable.$fStorableRatio3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,A><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IB0 w1_s4IB1 w2_s4IB2 w3_s4IB3 w4_s4IB4 w5_s4IB5]
        case w4_s4IB4 of {
          GHC.Real.:% ww1_s4IB7 [Occ=Once] ww2_s4IB8 [Occ=Once] ->
              Foreign.Storable.$w$cpokeByteOff
                  w_s4IB0 w2_s4IB2 w3_s4IB3 ww1_s4IB7 ww2_s4IB8 w5_s4IB5;
        };

Foreign.Storable.$w$cpokeElemOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(1*C1(U(U)),A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IB9 w1_s4IBa w2_s4IBb ww_s4IBc ww1_s4IBd w3_s4IBe]
        let {
          p_s4IBf :: GHC.Ptr.Ptr (GHC.Real.Ratio a_s4Ew8)
          [LclId] =
              [w_s4IB9 w1_s4IBa w2_s4IBb] \u []
                  case w1_s4IBa of {
                    GHC.Ptr.Ptr addr_s4IBh [Occ=Once] ->
                        case w2_s4IBb of {
                          GHC.Types.I# x_s4IBj [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf w_s4IB9 Foreign.Storable.$fStorableRatio6
                              of
                              { GHC.Types.I# y_s4IBl [Occ=Once] ->
                                    case *# [2# y_s4IBl] of sat_s4IBm {
                                      __DEFAULT ->
                                          case *# [x_s4IBj sat_s4IBm] of sat_s4IBn {
                                            __DEFAULT ->
                                                case plusAddr# [addr_s4IBh sat_s4IBn] of sat_s4IBo {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4IBo];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case Foreign.Storable.poke w_s4IB9 p_s4IBf ww_s4IBc w3_s4IBe of {
            (#,#) ipv_s4IBq [Occ=Once] _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_s4IB9 p_s4IBf Foreign.Storable.$fStorable()7 ww1_s4IBd ipv_s4IBq;
          };

Foreign.Storable.$fStorableRatio5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(C(U(U)),A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,A><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IBs w1_s4IBt w2_s4IBu w3_s4IBv w4_s4IBw w5_s4IBx]
        case w4_s4IBw of {
          GHC.Real.:% ww1_s4IBz [Occ=Once] ww2_s4IBA [Occ=Once] ->
              Foreign.Storable.$w$cpokeElemOff
                  w_s4IBs w2_s4IBu w3_s4IBv ww1_s4IBz ww2_s4IBA w5_s4IBx;
        };

Foreign.Storable.$fStorableRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     Foreign.Storable.Storable (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(U(U)),1*C1(U),C(C1(C1(U(U,U)))),C(C1(C1(C1(U(U,U))))),A,A,C(C1(U(U,U))),C(C1(C1(U(U,A)))))><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dStorable_s4IBB $dIntegral_s4IBC]
        let {
          sat_s4IBK [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B3 eta_B2 eta_B1]
                  Foreign.Storable.$fStorableRatio1
                      $dStorable_s4IBB $dIntegral_s4IBC eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s4IBJ [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B2 eta_B1]
                  Foreign.Storable.$fStorableRatio2
                      $dStorable_s4IBB $dIntegral_s4IBC eta_B2 eta_B1; } in
        let {
          sat_s4IBI [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B4
                                                      eta_B3
                                                      eta_B2
                                                      eta_B1]
                  Foreign.Storable.$fStorableRatio3
                      $dStorable_s4IBB $dIntegral_s4IBC eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s4IBH [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B3 eta_B2 eta_B1]
                  Foreign.Storable.$fStorableRatio4
                      $dStorable_s4IBB $dIntegral_s4IBC eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s4IBG [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.Int -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B4
                                                      eta_B3
                                                      eta_B2
                                                      eta_B1]
                  Foreign.Storable.$fStorableRatio5
                      $dStorable_s4IBB $dIntegral_s4IBC eta_B4 eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s4IBF [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.Int -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B3 eta_B2 eta_B1]
                  Foreign.Storable.$fStorableRatio7
                      $dStorable_s4IBB $dIntegral_s4IBC eta_B3 eta_B2 eta_B1; } in
        let {
          sat_s4IBE [Occ=Once] :: GHC.Real.Ratio a_X4DnU -> GHC.Types.Int
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \u []
                  Foreign.Storable.$fStorableRatio_$calignment
                      $dStorable_s4IBB $dIntegral_s4IBC; } in
        let {
          sat_s4IBD [Occ=Once] :: GHC.Real.Ratio a_X4DnU -> GHC.Types.Int
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \u []
                  Foreign.Storable.$fStorableRatio_$csizeOf
                      $dStorable_s4IBB $dIntegral_s4IBC;
        } in 
          Foreign.Storable.C:Storable [sat_s4IBD
                                       sat_s4IBE
                                       sat_s4IBF
                                       sat_s4IBG
                                       sat_s4IBH
                                       sat_s4IBI
                                       sat_s4IBJ
                                       sat_s4IBK];

Foreign.Storable.$wpokeW64 [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.Int#
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><S,1*U><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IBL ww_s4IBM w1_s4IBN w2_s4IBO]
        case ww_s4IBM of ds_s4IBP {
          __DEFAULT ->
              case w1_s4IBN of {
                GHC.Word.W64# ipv_s4IBR ->
                    case w_s4IBL of wild_s4IBS {
                      GHC.Ptr.Ptr a_s4IBT [Occ=Once] ->
                          case narrow8Word# [ipv_s4IBR] of sat_s4IBV {
                            __DEFAULT ->
                                case -# [ds_s4IBP 1#] of sat_s4IBU {
                                  __DEFAULT ->
                                      case
                                          writeWord8OffAddr# [a_s4IBT sat_s4IBU sat_s4IBV w2_s4IBO]
                                      of
                                      s2_s4IBW
                                      { __DEFAULT ->
                                            case uncheckedShiftRL# [ipv_s4IBR 8#] of sat_s4IBY {
                                              __DEFAULT ->
                                                  let {
                                                    sat_s4IBZ [Occ=Once] :: GHC.Word.Word64
                                                    [LclId] =
                                                        CCCS GHC.Word.W64#! [sat_s4IBY];
                                                  } in 
                                                    case -# [ds_s4IBP 1#] of sat_s4IBX {
                                                      __DEFAULT ->
                                                          Foreign.Storable.$wpokeW64
                                                              wild_s4IBS
                                                              sat_s4IBX
                                                              sat_s4IBZ
                                                              s2_s4IBW;
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
          0# -> (#,#) [w2_s4IBO GHC.Tuple.()];
        };

Foreign.Storable.$w$cpoke [InlPrag=NOUSERINLINE[0]]
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.Word#
     -> GHC.Prim.Word#
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IC0 ww_s4IC1 ww1_s4IC2 w1_s4IC3]
        let {
          sat_s4IC4 [Occ=Once] :: GHC.Word.Word64
          [LclId] =
              CCCS GHC.Word.W64#! [ww_s4IC1];
        } in 
          case Foreign.Storable.$wpokeW64 w_s4IC0 8# sat_s4IC4 w1_s4IC3 of {
            (#,#) ipv_s4IC6 [Occ=Once] _ [Occ=Dead] ->
                let {
                  sat_s4ICc [Occ=Once] :: GHC.Word.Word64
                  [LclId] =
                      CCCS GHC.Word.W64#! [ww1_s4IC2]; } in
                let {
                  sat_s4ICb [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Ptr.Ptr GHC.Word.Word8
                  [LclId] =
                      [w_s4IC0] \s []
                          case w_s4IC0 of {
                            GHC.Ptr.Ptr addr_s4IC9 [Occ=Once] ->
                                case plusAddr# [addr_s4IC9 8#] of sat_s4ICa {
                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4ICa];
                                };
                          };
                } in  Foreign.Storable.$wpokeW64 sat_s4ICb 8# sat_s4ICc ipv_s4IC6;
          };

Foreign.Storable.$fStorableFingerprint1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4ICd w1_s4ICe w2_s4ICf]
        case w1_s4ICe of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4ICh [Occ=Once]
                                           ww2_s4ICi [Occ=Once] ->
              Foreign.Storable.$w$cpoke w_s4ICd ww1_s4ICh ww2_s4ICi w2_s4ICf;
        };

Foreign.Storable.$wpeekW64 [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.Int#
     -> GHC.Prim.Word#
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><S,1*U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4ICj ww_s4ICk ww1_s4ICl w1_s4ICm]
        case ww_s4ICk of ds_s4ICn {
          __DEFAULT ->
              case w_s4ICj of {
                GHC.Ptr.Ptr ipv_s4ICp ->
                    case readWord8OffAddr# [ipv_s4ICp 0# w1_s4ICm] of {
                      (#,#) ipv1_s4ICr [Occ=Once] ipv2_s4ICs [Occ=Once] ->
                          case uncheckedShiftL# [ww1_s4ICl 8#] of sat_s4ICw {
                            __DEFAULT ->
                                case or# [sat_s4ICw ipv2_s4ICs] of sat_s4ICx {
                                  __DEFAULT ->
                                      case -# [ds_s4ICn 1#] of sat_s4ICv {
                                        __DEFAULT ->
                                            case plusAddr# [ipv_s4ICp 1#] of sat_s4ICt {
                                              __DEFAULT ->
                                                  let {
                                                    sat_s4ICu [Occ=Once]
                                                      :: GHC.Ptr.Ptr GHC.Word.Word8
                                                    [LclId] =
                                                        CCCS GHC.Ptr.Ptr! [sat_s4ICt];
                                                  } in 
                                                    Foreign.Storable.$wpeekW64
                                                        sat_s4ICu sat_s4ICv sat_s4ICx ipv1_s4ICr;
                                            };
                                      };
                                };
                          };
                    };
              };
          0# ->
              let {
                sat_s4ICy [Occ=Once] :: GHC.Word.Word64
                [LclId] =
                    CCCS GHC.Word.W64#! [ww1_s4ICl];
              } in  (#,#) [w1_s4ICm sat_s4ICy];
        };

Foreign.Storable.$fStorableFingerprint2
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [p0_s4ICz eta_s4ICA]
        case Foreign.Storable.$wpeekW64 p0_s4ICz 8# 0## eta_s4ICA of {
          (#,#) ipv_s4ICC [Occ=Once] ipv1_s4ICD [Occ=Once] ->
              let {
                sat_s4ICH [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Ptr.Ptr GHC.Word.Word8
                [LclId] =
                    [p0_s4ICz] \s []
                        case p0_s4ICz of {
                          GHC.Ptr.Ptr addr_s4ICF [Occ=Once] ->
                              case plusAddr# [addr_s4ICF 8#] of sat_s4ICG {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4ICG];
                              };
                        };
              } in 
                case Foreign.Storable.$wpeekW64 sat_s4ICH 8# 0## ipv_s4ICC of {
                  (#,#) ipv2_s4ICJ [Occ=Once] ipv3_s4ICK [Occ=Once] ->
                      let {
                        sat_s4ICL [Occ=Once] :: GHC.Fingerprint.Type.Fingerprint
                        [LclId] =
                            [ipv1_s4ICD ipv3_s4ICK] \u []
                                GHC.Fingerprint.Type.$WFingerprint ipv1_s4ICD ipv3_s4ICK;
                      } in  (#,#) [ipv2_s4ICJ sat_s4ICL];
                };
        };

Foreign.Storable.$fStorableFingerprint4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ICM off_s4ICN eta_s4ICO]
        let {
          sat_s4ICU [Occ=Once, Dmd=<L,U(U)>]
            :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
          [LclId] =
              [ptr_s4ICM off_s4ICN] \u []
                  case ptr_s4ICM of {
                    GHC.Ptr.Ptr addr_s4ICQ [Occ=Once] ->
                        case off_s4ICN of {
                          GHC.Types.I# d_s4ICS [Occ=Once] ->
                              case plusAddr# [addr_s4ICQ d_s4ICS] of sat_s4ICT {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4ICT];
                              };
                        };
                  };
        } in  Foreign.Storable.$fStorableFingerprint2 sat_s4ICU eta_s4ICO;

Foreign.Storable.$fStorableFingerprint6
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ICV off_s4ICW eta_s4ICX]
        let {
          sat_s4ID4 [Occ=Once, Dmd=<L,U(U)>]
            :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
          [LclId] =
              [ptr_s4ICV off_s4ICW] \u []
                  case ptr_s4ICV of {
                    GHC.Ptr.Ptr addr_s4ICZ [Occ=Once] ->
                        case off_s4ICW of {
                          GHC.Types.I# x_s4ID1 [Occ=Once] ->
                              case *# [x_s4ID1 16#] of sat_s4ID2 {
                                __DEFAULT ->
                                    case plusAddr# [addr_s4ICZ sat_s4ID2] of sat_s4ID3 {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_s4ID3];
                                    };
                              };
                        };
                  };
        } in  Foreign.Storable.$fStorableFingerprint2 sat_s4ID4 eta_s4ICX;

Foreign.Storable.$fStorableFingerprint3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ID5 off_s4ID6 eta_s4ID7 eta1_s4ID8]
        case eta_s4ID7 of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4IDa [Occ=Once]
                                           ww2_s4IDb [Occ=Once] ->
              let {
                sat_s4IDh [Occ=Once, Dmd=<L,U(U)>]
                  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
                [LclId] =
                    [ptr_s4ID5 off_s4ID6] \u []
                        case ptr_s4ID5 of {
                          GHC.Ptr.Ptr addr_s4IDd [Occ=Once] ->
                              case off_s4ID6 of {
                                GHC.Types.I# d_s4IDf [Occ=Once] ->
                                    case plusAddr# [addr_s4IDd d_s4IDf] of sat_s4IDg {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_s4IDg];
                                    };
                              };
                        };
              } in 
                Foreign.Storable.$w$cpoke sat_s4IDh ww1_s4IDa ww2_s4IDb eta1_s4ID8;
        };

Foreign.Storable.$fStorableFingerprint5
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Types.Int
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IDi off_s4IDj val_s4IDk eta_s4IDl]
        case val_s4IDk of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4IDn [Occ=Once]
                                           ww2_s4IDo [Occ=Once] ->
              let {
                sat_s4IDv [Occ=Once, Dmd=<L,U(U)>]
                  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
                [LclId] =
                    [ptr_s4IDi off_s4IDj] \u []
                        case ptr_s4IDi of {
                          GHC.Ptr.Ptr addr_s4IDq [Occ=Once] ->
                              case off_s4IDj of {
                                GHC.Types.I# x_s4IDs [Occ=Once] ->
                                    case *# [x_s4IDs 16#] of sat_s4IDt {
                                      __DEFAULT ->
                                          case plusAddr# [addr_s4IDq sat_s4IDt] of sat_s4IDu {
                                            __DEFAULT -> GHC.Ptr.Ptr [sat_s4IDu];
                                          };
                                    };
                              };
                        };
              } in 
                Foreign.Storable.$w$cpoke sat_s4IDv ww1_s4IDn ww2_s4IDo eta_s4IDl;
        };

Foreign.Storable.$fStorableFingerprint [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFingerprint_$csizeOf
                                                Foreign.Storable.$fStorableFingerprint_$calignment
                                                Foreign.Storable.$fStorableFingerprint6
                                                Foreign.Storable.$fStorableFingerprint5
                                                Foreign.Storable.$fStorableFingerprint4
                                                Foreign.Storable.$fStorableFingerprint3
                                                Foreign.Storable.$fStorableFingerprint2
                                                Foreign.Storable.$fStorableFingerprint1];

Foreign.Storable.C:Storable
  :: forall a.
     (a -> GHC.Types.Int)
     -> (a -> GHC.Types.Int)
     -> (GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a)
     -> (GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ())
     -> (forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a)
     -> (forall b.
         GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ())
     -> (GHC.Ptr.Ptr a -> GHC.Types.IO a)
     -> (GHC.Ptr.Ptr a -> a -> GHC.Types.IO ())
     -> Foreign.Storable.Storable a
[GblId[DataCon],
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B8 eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Foreign.Storable.C:Storable [eta_B8
                                     eta_B7
                                     eta_B6
                                     eta_B5
                                     eta_B4
                                     eta_B3
                                     eta_B2
                                     eta_B1];


==================== STG syntax: ====================
2018-03-16 15:59:36.985357777 UTC

Foreign.Storable.sizeOf
  :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLL),U(U,A,A,A,A,A,A,A)>] =
    [] \r [v_s4IlN]
        case v_s4IlN of {
          Foreign.Storable.C:Storable v_s4IlP [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4IlP;
        };

Foreign.Storable.alignment
  :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>] =
    [] \r [v_s4IlX]
        case v_s4IlX of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      v_s4Im0 [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Im0;
        };

Foreign.Storable.peekElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLL),U(A,A,U,A,A,A,A,A)>] =
    [] \r [v_s4Im7]
        case v_s4Im7 of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Imb [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Imb;
        };

Foreign.Storable.pokeElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLL),U(A,A,A,U,A,A,A,A)>] =
    [] \r [v_s4Imh]
        case v_s4Imh of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Imm [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Imm;
        };

Foreign.Storable.peekByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLL),U(A,A,A,A,U,A,A,A)>] =
    [] \r [v_s4Imr]
        case v_s4Imr of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4Imx [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4Imx;
        };

Foreign.Storable.pokeByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLL),U(A,A,A,A,A,U,A,A)>] =
    [] \r [v_s4ImB]
        case v_s4ImB of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4ImI [Occ=Once]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead] ->
              v_s4ImI;
        };

Foreign.Storable.peek
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSL),U(A,A,A,A,A,A,U,A)>] =
    [] \r [v_s4ImL]
        case v_s4ImL of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4ImT [Occ=Once]
                                      _ [Occ=Dead] ->
              v_s4ImT;
        };

Foreign.Storable.poke
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLS),U(A,A,A,A,A,A,A,U)>] =
    [] \r [v_s4ImV]
        case v_s4ImV of {
          Foreign.Storable.C:Storable _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      _ [Occ=Dead]
                                      v_s4In4 [Occ=Once] ->
              v_s4In4;
        };

Foreign.Storable.$fStorable()7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

Foreign.Storable.$fStorable()_$calignment :: () -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4In5] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorable()8 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [0#];

Foreign.Storable.$fStorable()_$csizeOf :: () -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4In6] Foreign.Storable.$fStorable()8;

Foreign.Storable.$fStorableBool7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [4#];

Foreign.Storable.$fStorableChar_$calignment
  :: GHC.Types.Char -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4In7] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableDouble5 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

Foreign.Storable.$fStorableInt_$calignment
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4In8] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableWord_$calignment
  :: GHC.Types.Word -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4In9] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorablePtr_$calignment
  :: forall a. GHC.Ptr.Ptr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ina] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFunPtr_$calignment
  :: forall a. GHC.Ptr.FunPtr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inb] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableStablePtr_$calignment
  :: forall a. GHC.Stable.StablePtr a -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inc] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFloat_$calignment
  :: GHC.Types.Float -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ind] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableDouble_$calignment
  :: GHC.Types.Double -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ine] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableWord8_$calignment
  :: GHC.Word.Word8 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inf] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorableInt10 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

Foreign.Storable.$fStorableWord16_$calignment
  :: GHC.Word.Word16 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ing] Foreign.Storable.$fStorableInt10;

Foreign.Storable.$fStorableWord32_$calignment
  :: GHC.Word.Word32 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inh] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableWord64_$calignment
  :: GHC.Word.Word64 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ini] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableInt8_$calignment
  :: GHC.Int.Int8 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inj] Foreign.Storable.$fStorable()7;

Foreign.Storable.$fStorableInt16_$calignment
  :: GHC.Int.Int16 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ink] Foreign.Storable.$fStorableInt10;

Foreign.Storable.$fStorableInt32_$calignment
  :: GHC.Int.Int32 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inl] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableInt64_$calignment
  :: GHC.Int.Int64 -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Inm] Foreign.Storable.$fStorableDouble5;

lvl_r4Ff9 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "undefined"#;

lvl1_r4Ffa :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_r4Ff9;

Foreign.Storable.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

lvl2_r4Ffb :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Foreign.Storable.$trModule4;

Foreign.Storable.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Foreign.Storable"#;

lvl3_r4Ffc :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Foreign.Storable.$trModule2;

lvl4_r4Ffd :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "./Foreign/Storable.hs"#;

lvl5_r4Ffe :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_r4Ffd;

lvl6_r4Fff :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [238#];

lvl7_r4Ffg :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [30#];

lvl8_r4Ffh :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [39#];

lvl9_r4Ffi :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl6_r4Fff
                                           lvl7_r4Ffg
                                           lvl6_r4Fff
                                           lvl8_r4Ffh];

lvl10_r4Ffj :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl9_r4Ffi
                                                  GHC.Stack.Types.EmptyCallStack];

Foreign.Storable.$fStorableRatio8 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl10_r4Ffj;

Foreign.Storable.$fStorableRatio_$calignment
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(U),A,A,A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Inn $dIntegral_s4Ino]
        let {
          lvl20_s4Inp [Occ=OnceL] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4Inn] \u []
                  Foreign.Storable.alignment
                      $dStorable_s4Inn Foreign.Storable.$fStorableRatio8; } in
        let {
          sat_s4Inr [Occ=OnceT[0]] :: GHC.Real.Ratio a_a4DgH -> GHC.Types.Int
          [LclId] =
              [lvl20_s4Inp] \r [ds_s4Inq] lvl20_s4Inp;
        } in  sat_s4Inr;

Foreign.Storable.$fStorableFingerprint_$calignment
  :: GHC.Fingerprint.Type.Fingerprint -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ins] Foreign.Storable.$fStorableDouble5;

Foreign.Storable.$fStorableFingerprint7 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [16#];

Foreign.Storable.$fStorableFingerprint_$csizeOf
  :: GHC.Fingerprint.Type.Fingerprint -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Int] Foreign.Storable.$fStorableFingerprint7;

Foreign.Storable.$dmpoke
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Inu ptr_s4Inv]
        Foreign.Storable.pokeElemOff
            $dStorable_s4Inu ptr_s4Inv Foreign.Storable.$fStorable()8;

Foreign.Storable.$dmpeek
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Inw ptr_s4Inx]
        Foreign.Storable.peekElemOff
            $dStorable_s4Inw ptr_s4Inx Foreign.Storable.$fStorable()8;

Foreign.Storable.$dmpokeByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)),1*U(A,A,A,A,A,A,A,1*C1(U))><L,1*U(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Iny ptr_s4Inz off_s4InA]
        let {
          sat_s4InG [Occ=Once] :: GHC.Ptr.Ptr a_a4D8k
          [LclId] =
              [ptr_s4Inz off_s4InA] \u []
                  case ptr_s4Inz of {
                    GHC.Ptr.Ptr addr_s4InC [Occ=Once] ->
                        case off_s4InA of {
                          GHC.Types.I# d_s4InE [Occ=Once] ->
                              case plusAddr# [addr_s4InC d_s4InE] of sat_s4InF {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4InF];
                              };
                        };
                  };
        } in  Foreign.Storable.poke $dStorable_s4Iny sat_s4InG;

Foreign.Storable.$dmpeekByteOff
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(S)L),1*U(A,A,A,A,A,A,1*C1(U),A)><L,1*U(U)><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4InH ptr_s4InI off_s4InJ]
        let {
          sat_s4InP [Occ=Once] :: GHC.Ptr.Ptr a_a4D8k
          [LclId] =
              [ptr_s4InI off_s4InJ] \u []
                  case ptr_s4InI of {
                    GHC.Ptr.Ptr addr_s4InL [Occ=Once] ->
                        case off_s4InJ of {
                          GHC.Types.I# d_s4InN [Occ=Once] ->
                              case plusAddr# [addr_s4InL d_s4InN] of sat_s4InO {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4InO];
                              };
                        };
                  };
        } in  Foreign.Storable.peek $dStorable_s4InH sat_s4InP;

Foreign.Storable.$fStorableInt17
  :: GHC.Ptr.Ptr GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int64 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4InQ void_0E]
        case ptr_s4InQ of {
          GHC.Ptr.Ptr a_s4InT [Occ=Once] ->
              case readInt64OffAddr# [a_s4InT 0# GHC.Prim.void#] of {
                Unit# ipv1_s4InW [Occ=Once] ->
                    let {
                      sat_s4InX [Occ=Once] :: GHC.Int.Int64
                      [LclId] =
                          CCCS GHC.Int.I64#! [ipv1_s4InW];
                    } in  Unit# [sat_s4InX];
              };
        };

Foreign.Storable.$fStorableInt19
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4InY off_s4InZ void_0E]
        case ptr_s4InY of {
          GHC.Ptr.Ptr addr_s4Io2 [Occ=Once] ->
              case off_s4InZ of {
                GHC.Types.I# d_s4Io4 [Occ=Once] ->
                    case plusAddr# [addr_s4Io2 d_s4Io4] of sat_s4Io5 {
                      __DEFAULT ->
                          case readInt64OffAddr# [sat_s4Io5 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Io8 [Occ=Once] ->
                                let {
                                  sat_s4Io9 [Occ=Once] :: GHC.Int.Int64
                                  [LclId] =
                                      CCCS GHC.Int.I64#! [ipv1_s4Io8];
                                } in  Unit# [sat_s4Io9];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt15
  :: GHC.Ptr.Ptr GHC.Int.Int64
     -> GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ioa ds2_s4Iob void_0E]
        case ptr_s4Ioa of {
          GHC.Ptr.Ptr a_s4Ioe [Occ=Once] ->
              case ds2_s4Iob of {
                GHC.Int.I64# x_s4Iog [Occ=Once] ->
                    case
                        writeInt64OffAddr# [a_s4Ioe 0# x_s4Iog GHC.Prim.void#]
                    of
                    s2_s4Ioh
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt18
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ioi off_s4Ioj eta_s4Iok void_0E]
        case ptr_s4Ioi of {
          GHC.Ptr.Ptr addr_s4Ion [Occ=Once] ->
              case off_s4Ioj of {
                GHC.Types.I# d_s4Iop [Occ=Once] ->
                    case eta_s4Iok of {
                      GHC.Int.I64# x_s4Ior [Occ=Once] ->
                          case plusAddr# [addr_s4Ion d_s4Iop] of sat_s4Ios {
                            __DEFAULT ->
                                case
                                    writeInt64OffAddr# [sat_s4Ios 0# x_s4Ior GHC.Prim.void#]
                                of
                                s2_s4Iot
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int64
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt64_$calignment
                                                Foreign.Storable.$fStorableInt64_$calignment
                                                GHC.Storable.readInt64OffPtr1
                                                GHC.Storable.writeInt64OffPtr1
                                                Foreign.Storable.$fStorableInt19
                                                Foreign.Storable.$fStorableInt18
                                                Foreign.Storable.$fStorableInt17
                                                Foreign.Storable.$fStorableInt15];

Foreign.Storable.$fStorableInt12
  :: GHC.Ptr.Ptr GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int32 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iou void_0E]
        case ptr_s4Iou of {
          GHC.Ptr.Ptr a_s4Iox [Occ=Once] ->
              case readInt32OffAddr# [a_s4Iox 0# GHC.Prim.void#] of {
                Unit# ipv1_s4IoA [Occ=Once] ->
                    let {
                      sat_s4IoB [Occ=Once] :: GHC.Int.Int32
                      [LclId] =
                          CCCS GHC.Int.I32#! [ipv1_s4IoA];
                    } in  Unit# [sat_s4IoB];
              };
        };

Foreign.Storable.$fStorableInt14
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IoC off_s4IoD void_0E]
        case ptr_s4IoC of {
          GHC.Ptr.Ptr addr_s4IoG [Occ=Once] ->
              case off_s4IoD of {
                GHC.Types.I# d_s4IoI [Occ=Once] ->
                    case plusAddr# [addr_s4IoG d_s4IoI] of sat_s4IoJ {
                      __DEFAULT ->
                          case readInt32OffAddr# [sat_s4IoJ 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4IoM [Occ=Once] ->
                                let {
                                  sat_s4IoN [Occ=Once] :: GHC.Int.Int32
                                  [LclId] =
                                      CCCS GHC.Int.I32#! [ipv1_s4IoM];
                                } in  Unit# [sat_s4IoN];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt11
  :: GHC.Ptr.Ptr GHC.Int.Int32
     -> GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IoO ds2_s4IoP void_0E]
        case ptr_s4IoO of {
          GHC.Ptr.Ptr a_s4IoS [Occ=Once] ->
              case ds2_s4IoP of {
                GHC.Int.I32# x_s4IoU [Occ=Once] ->
                    case
                        writeInt32OffAddr# [a_s4IoS 0# x_s4IoU GHC.Prim.void#]
                    of
                    s2_s4IoV
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt13
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IoW off_s4IoX eta_s4IoY void_0E]
        case ptr_s4IoW of {
          GHC.Ptr.Ptr addr_s4Ip1 [Occ=Once] ->
              case off_s4IoX of {
                GHC.Types.I# d_s4Ip3 [Occ=Once] ->
                    case eta_s4IoY of {
                      GHC.Int.I32# x_s4Ip5 [Occ=Once] ->
                          case plusAddr# [addr_s4Ip1 d_s4Ip3] of sat_s4Ip6 {
                            __DEFAULT ->
                                case
                                    writeInt32OffAddr# [sat_s4Ip6 0# x_s4Ip5 GHC.Prim.void#]
                                of
                                s2_s4Ip7
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int32
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt32_$calignment
                                                Foreign.Storable.$fStorableInt32_$calignment
                                                GHC.Storable.readInt32OffPtr1
                                                GHC.Storable.writeInt32OffPtr1
                                                Foreign.Storable.$fStorableInt14
                                                Foreign.Storable.$fStorableInt13
                                                Foreign.Storable.$fStorableInt12
                                                Foreign.Storable.$fStorableInt11];

Foreign.Storable.$fStorableBool_$csizeOf
  :: GHC.Types.Bool -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,A>m, Unf=OtherCon []] =
    [] \r [ds_s4Ip8] Foreign.Storable.$fStorableBool7;

Foreign.Storable.$fStorableBool5
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Int
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [p_s4Ip9 i_s4Ipa x_s4Ipb void_0E]
        case p_s4Ip9 of {
          GHC.Ptr.Ptr a_s4Ipe [Occ=Once*] ->
              case i_s4Ipa of {
                GHC.Types.I# i1_s4Ipg [Occ=Once*] ->
                    case x_s4Ipb of {
                      GHC.Types.False ->
                          case
                              writeInt32OffAddr# [a_s4Ipe i1_s4Ipg 0# GHC.Prim.void#]
                          of
                          s2_s4Ipi
                          { (##) -> Unit# [GHC.Tuple.()];
                          };
                      GHC.Types.True ->
                          case
                              writeInt32OffAddr# [a_s4Ipe i1_s4Ipg 1# GHC.Prim.void#]
                          of
                          s2_s4Ipj
                          { (##) -> Unit# [GHC.Tuple.()];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt6
  :: GHC.Ptr.Ptr GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int16 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ipk void_0E]
        case ptr_s4Ipk of {
          GHC.Ptr.Ptr a_s4Ipn [Occ=Once] ->
              case readInt16OffAddr# [a_s4Ipn 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Ipq [Occ=Once] ->
                    let {
                      sat_s4Ipr [Occ=Once] :: GHC.Int.Int16
                      [LclId] =
                          CCCS GHC.Int.I16#! [ipv1_s4Ipq];
                    } in  Unit# [sat_s4Ipr];
              };
        };

Foreign.Storable.$fStorableInt9
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ips off_s4Ipt void_0E]
        case ptr_s4Ips of {
          GHC.Ptr.Ptr addr_s4Ipw [Occ=Once] ->
              case off_s4Ipt of {
                GHC.Types.I# d_s4Ipy [Occ=Once] ->
                    case plusAddr# [addr_s4Ipw d_s4Ipy] of sat_s4Ipz {
                      __DEFAULT ->
                          case readInt16OffAddr# [sat_s4Ipz 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4IpC [Occ=Once] ->
                                let {
                                  sat_s4IpD [Occ=Once] :: GHC.Int.Int16
                                  [LclId] =
                                      CCCS GHC.Int.I16#! [ipv1_s4IpC];
                                } in  Unit# [sat_s4IpD];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt5
  :: GHC.Ptr.Ptr GHC.Int.Int16
     -> GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IpE ds2_s4IpF void_0E]
        case ptr_s4IpE of {
          GHC.Ptr.Ptr a_s4IpI [Occ=Once] ->
              case ds2_s4IpF of {
                GHC.Int.I16# x_s4IpK [Occ=Once] ->
                    case
                        writeInt16OffAddr# [a_s4IpI 0# x_s4IpK GHC.Prim.void#]
                    of
                    s2_s4IpL
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt7
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IpM off_s4IpN eta_s4IpO void_0E]
        case ptr_s4IpM of {
          GHC.Ptr.Ptr addr_s4IpR [Occ=Once] ->
              case off_s4IpN of {
                GHC.Types.I# d_s4IpT [Occ=Once] ->
                    case eta_s4IpO of {
                      GHC.Int.I16# x_s4IpV [Occ=Once] ->
                          case plusAddr# [addr_s4IpR d_s4IpT] of sat_s4IpW {
                            __DEFAULT ->
                                case
                                    writeInt16OffAddr# [sat_s4IpW 0# x_s4IpV GHC.Prim.void#]
                                of
                                s2_s4IpX
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int16
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt16_$calignment
                                                Foreign.Storable.$fStorableInt16_$calignment
                                                GHC.Storable.readInt16OffPtr1
                                                GHC.Storable.writeInt16OffPtr1
                                                Foreign.Storable.$fStorableInt9
                                                Foreign.Storable.$fStorableInt7
                                                Foreign.Storable.$fStorableInt6
                                                Foreign.Storable.$fStorableInt5];

Foreign.Storable.$fStorableInt21
  :: GHC.Ptr.Ptr GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int8 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IpY void_0E]
        case ptr_s4IpY of {
          GHC.Ptr.Ptr a_s4Iq1 [Occ=Once] ->
              case readInt8OffAddr# [a_s4Iq1 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Iq4 [Occ=Once] ->
                    let {
                      sat_s4Iq5 [Occ=Once] :: GHC.Int.Int8
                      [LclId] =
                          CCCS GHC.Int.I8#! [ipv1_s4Iq4];
                    } in  Unit# [sat_s4Iq5];
              };
        };

Foreign.Storable.$fStorableInt23
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Int.Int8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iq6 off_s4Iq7 void_0E]
        case ptr_s4Iq6 of {
          GHC.Ptr.Ptr addr_s4Iqa [Occ=Once] ->
              case off_s4Iq7 of {
                GHC.Types.I# d_s4Iqc [Occ=Once] ->
                    case plusAddr# [addr_s4Iqa d_s4Iqc] of sat_s4Iqd {
                      __DEFAULT ->
                          case readInt8OffAddr# [sat_s4Iqd 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Iqg [Occ=Once] ->
                                let {
                                  sat_s4Iqh [Occ=Once] :: GHC.Int.Int8
                                  [LclId] =
                                      CCCS GHC.Int.I8#! [ipv1_s4Iqg];
                                } in  Unit# [sat_s4Iqh];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt20
  :: GHC.Ptr.Ptr GHC.Int.Int8
     -> GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iqi ds2_s4Iqj void_0E]
        case ptr_s4Iqi of {
          GHC.Ptr.Ptr a_s4Iqm [Occ=Once] ->
              case ds2_s4Iqj of {
                GHC.Int.I8# x_s4Iqo [Occ=Once] ->
                    case
                        writeInt8OffAddr# [a_s4Iqm 0# x_s4Iqo GHC.Prim.void#]
                    of
                    s2_s4Iqp
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt22
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Int.Int8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iqq off_s4Iqr eta_s4Iqs void_0E]
        case ptr_s4Iqq of {
          GHC.Ptr.Ptr addr_s4Iqv [Occ=Once] ->
              case off_s4Iqr of {
                GHC.Types.I# d_s4Iqx [Occ=Once] ->
                    case eta_s4Iqs of {
                      GHC.Int.I8# x_s4Iqz [Occ=Once] ->
                          case plusAddr# [addr_s4Iqv d_s4Iqx] of sat_s4IqA {
                            __DEFAULT ->
                                case
                                    writeInt8OffAddr# [sat_s4IqA 0# x_s4Iqz GHC.Prim.void#]
                                of
                                s2_s4IqB
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Int.Int8
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt8_$calignment
                                                Foreign.Storable.$fStorableInt8_$calignment
                                                GHC.Storable.readInt8OffPtr1
                                                GHC.Storable.writeInt8OffPtr1
                                                Foreign.Storable.$fStorableInt23
                                                Foreign.Storable.$fStorableInt22
                                                Foreign.Storable.$fStorableInt21
                                                Foreign.Storable.$fStorableInt20];

Foreign.Storable.$fStorableWord15
  :: GHC.Ptr.Ptr GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IqC void_0E]
        case ptr_s4IqC of {
          GHC.Ptr.Ptr a_s4IqF [Occ=Once] ->
              case readWord64OffAddr# [a_s4IqF 0# GHC.Prim.void#] of {
                Unit# ipv1_s4IqI [Occ=Once] ->
                    let {
                      sat_s4IqJ [Occ=Once] :: GHC.Word.Word64
                      [LclId] =
                          CCCS GHC.Word.W64#! [ipv1_s4IqI];
                    } in  Unit# [sat_s4IqJ];
              };
        };

Foreign.Storable.$fStorableWord18
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IqK off_s4IqL void_0E]
        case ptr_s4IqK of {
          GHC.Ptr.Ptr addr_s4IqO [Occ=Once] ->
              case off_s4IqL of {
                GHC.Types.I# d_s4IqQ [Occ=Once] ->
                    case plusAddr# [addr_s4IqO d_s4IqQ] of sat_s4IqR {
                      __DEFAULT ->
                          case readWord64OffAddr# [sat_s4IqR 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4IqU [Occ=Once] ->
                                let {
                                  sat_s4IqV [Occ=Once] :: GHC.Word.Word64
                                  [LclId] =
                                      CCCS GHC.Word.W64#! [ipv1_s4IqU];
                                } in  Unit# [sat_s4IqV];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord14
  :: GHC.Ptr.Ptr GHC.Word.Word64
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IqW ds2_s4IqX void_0E]
        case ptr_s4IqW of {
          GHC.Ptr.Ptr a_s4Ir0 [Occ=Once] ->
              case ds2_s4IqX of {
                GHC.Word.W64# x_s4Ir2 [Occ=Once] ->
                    case
                        writeWord64OffAddr# [a_s4Ir0 0# x_s4Ir2 GHC.Prim.void#]
                    of
                    s2_s4Ir3
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord17
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ir4 off_s4Ir5 eta_s4Ir6 void_0E]
        case ptr_s4Ir4 of {
          GHC.Ptr.Ptr addr_s4Ir9 [Occ=Once] ->
              case off_s4Ir5 of {
                GHC.Types.I# d_s4Irb [Occ=Once] ->
                    case eta_s4Ir6 of {
                      GHC.Word.W64# x_s4Ird [Occ=Once] ->
                          case plusAddr# [addr_s4Ir9 d_s4Irb] of sat_s4Ire {
                            __DEFAULT ->
                                case
                                    writeWord64OffAddr# [sat_s4Ire 0# x_s4Ird GHC.Prim.void#]
                                of
                                s2_s4Irf
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word64
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord64_$calignment
                                                Foreign.Storable.$fStorableWord64_$calignment
                                                GHC.Storable.readWord64OffPtr1
                                                GHC.Storable.writeWord64OffPtr1
                                                Foreign.Storable.$fStorableWord18
                                                Foreign.Storable.$fStorableWord17
                                                Foreign.Storable.$fStorableWord15
                                                Foreign.Storable.$fStorableWord14];

Foreign.Storable.$fStorableWord11
  :: GHC.Ptr.Ptr GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word32 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Irg void_0E]
        case ptr_s4Irg of {
          GHC.Ptr.Ptr a_s4Irj [Occ=Once] ->
              case readWord32OffAddr# [a_s4Irj 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Irm [Occ=Once] ->
                    let {
                      sat_s4Irn [Occ=Once] :: GHC.Word.Word32
                      [LclId] =
                          CCCS GHC.Word.W32#! [ipv1_s4Irm];
                    } in  Unit# [sat_s4Irn];
              };
        };

Foreign.Storable.$fStorableWord13
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iro off_s4Irp void_0E]
        case ptr_s4Iro of {
          GHC.Ptr.Ptr addr_s4Irs [Occ=Once] ->
              case off_s4Irp of {
                GHC.Types.I# d_s4Iru [Occ=Once] ->
                    case plusAddr# [addr_s4Irs d_s4Iru] of sat_s4Irv {
                      __DEFAULT ->
                          case readWord32OffAddr# [sat_s4Irv 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Iry [Occ=Once] ->
                                let {
                                  sat_s4Irz [Occ=Once] :: GHC.Word.Word32
                                  [LclId] =
                                      CCCS GHC.Word.W32#! [ipv1_s4Iry];
                                } in  Unit# [sat_s4Irz];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord10
  :: GHC.Ptr.Ptr GHC.Word.Word32
     -> GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IrA ds2_s4IrB void_0E]
        case ptr_s4IrA of {
          GHC.Ptr.Ptr a_s4IrE [Occ=Once] ->
              case ds2_s4IrB of {
                GHC.Word.W32# x_s4IrG [Occ=Once] ->
                    case
                        writeWord32OffAddr# [a_s4IrE 0# x_s4IrG GHC.Prim.void#]
                    of
                    s2_s4IrH
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord12
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word32
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IrI off_s4IrJ eta_s4IrK void_0E]
        case ptr_s4IrI of {
          GHC.Ptr.Ptr addr_s4IrN [Occ=Once] ->
              case off_s4IrJ of {
                GHC.Types.I# d_s4IrP [Occ=Once] ->
                    case eta_s4IrK of {
                      GHC.Word.W32# x_s4IrR [Occ=Once] ->
                          case plusAddr# [addr_s4IrN d_s4IrP] of sat_s4IrS {
                            __DEFAULT ->
                                case
                                    writeWord32OffAddr# [sat_s4IrS 0# x_s4IrR GHC.Prim.void#]
                                of
                                s2_s4IrT
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word32
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord32_$calignment
                                                Foreign.Storable.$fStorableWord32_$calignment
                                                GHC.Storable.readWord32OffPtr1
                                                GHC.Storable.writeWord32OffPtr1
                                                Foreign.Storable.$fStorableWord13
                                                Foreign.Storable.$fStorableWord12
                                                Foreign.Storable.$fStorableWord11
                                                Foreign.Storable.$fStorableWord10];

Foreign.Storable.$fStorableWord6
  :: GHC.Ptr.Ptr GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word16 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IrU void_0E]
        case ptr_s4IrU of {
          GHC.Ptr.Ptr a_s4IrX [Occ=Once] ->
              case readWord16OffAddr# [a_s4IrX 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Is0 [Occ=Once] ->
                    let {
                      sat_s4Is1 [Occ=Once] :: GHC.Word.Word16
                      [LclId] =
                          CCCS GHC.Word.W16#! [ipv1_s4Is0];
                    } in  Unit# [sat_s4Is1];
              };
        };

Foreign.Storable.$fStorableWord9
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Is2 off_s4Is3 void_0E]
        case ptr_s4Is2 of {
          GHC.Ptr.Ptr addr_s4Is6 [Occ=Once] ->
              case off_s4Is3 of {
                GHC.Types.I# d_s4Is8 [Occ=Once] ->
                    case plusAddr# [addr_s4Is6 d_s4Is8] of sat_s4Is9 {
                      __DEFAULT ->
                          case readWord16OffAddr# [sat_s4Is9 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Isc [Occ=Once] ->
                                let {
                                  sat_s4Isd [Occ=Once] :: GHC.Word.Word16
                                  [LclId] =
                                      CCCS GHC.Word.W16#! [ipv1_s4Isc];
                                } in  Unit# [sat_s4Isd];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord5
  :: GHC.Ptr.Ptr GHC.Word.Word16
     -> GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ise ds2_s4Isf void_0E]
        case ptr_s4Ise of {
          GHC.Ptr.Ptr a_s4Isi [Occ=Once] ->
              case ds2_s4Isf of {
                GHC.Word.W16# x_s4Isk [Occ=Once] ->
                    case
                        writeWord16OffAddr# [a_s4Isi 0# x_s4Isk GHC.Prim.void#]
                    of
                    s2_s4Isl
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord7
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word16
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ism off_s4Isn eta_s4Iso void_0E]
        case ptr_s4Ism of {
          GHC.Ptr.Ptr addr_s4Isr [Occ=Once] ->
              case off_s4Isn of {
                GHC.Types.I# d_s4Ist [Occ=Once] ->
                    case eta_s4Iso of {
                      GHC.Word.W16# x_s4Isv [Occ=Once] ->
                          case plusAddr# [addr_s4Isr d_s4Ist] of sat_s4Isw {
                            __DEFAULT ->
                                case
                                    writeWord16OffAddr# [sat_s4Isw 0# x_s4Isv GHC.Prim.void#]
                                of
                                s2_s4Isx
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word16
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord16_$calignment
                                                Foreign.Storable.$fStorableWord16_$calignment
                                                GHC.Storable.readWord16OffPtr1
                                                GHC.Storable.writeWord16OffPtr1
                                                Foreign.Storable.$fStorableWord9
                                                Foreign.Storable.$fStorableWord7
                                                Foreign.Storable.$fStorableWord6
                                                Foreign.Storable.$fStorableWord5];

Foreign.Storable.$fStorableDouble2
  :: GHC.Ptr.Ptr GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Double #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Isy void_0E]
        case ptr_s4Isy of {
          GHC.Ptr.Ptr a_s4IsB [Occ=Once] ->
              case readDoubleOffAddr# [a_s4IsB 0# GHC.Prim.void#] of {
                Unit# ipv1_s4IsE [Occ=Once] ->
                    let {
                      sat_s4IsF [Occ=Once] :: GHC.Types.Double
                      [LclId] =
                          CCCS GHC.Types.D#! [ipv1_s4IsE];
                    } in  Unit# [sat_s4IsF];
              };
        };

Foreign.Storable.$fStorableDouble4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Double #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IsG off_s4IsH void_0E]
        case ptr_s4IsG of {
          GHC.Ptr.Ptr addr_s4IsK [Occ=Once] ->
              case off_s4IsH of {
                GHC.Types.I# d_s4IsM [Occ=Once] ->
                    case plusAddr# [addr_s4IsK d_s4IsM] of sat_s4IsN {
                      __DEFAULT ->
                          case readDoubleOffAddr# [sat_s4IsN 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4IsQ [Occ=Once] ->
                                let {
                                  sat_s4IsR [Occ=Once] :: GHC.Types.Double
                                  [LclId] =
                                      CCCS GHC.Types.D#! [ipv1_s4IsQ];
                                } in  Unit# [sat_s4IsR];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableDouble1
  :: GHC.Ptr.Ptr GHC.Types.Double
     -> GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IsS ds2_s4IsT void_0E]
        case ptr_s4IsS of {
          GHC.Ptr.Ptr a_s4IsW [Occ=Once] ->
              case ds2_s4IsT of {
                GHC.Types.D# x_s4IsY [Occ=Once] ->
                    case
                        writeDoubleOffAddr# [a_s4IsW 0# x_s4IsY GHC.Prim.void#]
                    of
                    s2_s4IsZ
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableDouble3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Double
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4It0 off_s4It1 eta_s4It2 void_0E]
        case ptr_s4It0 of {
          GHC.Ptr.Ptr addr_s4It5 [Occ=Once] ->
              case off_s4It1 of {
                GHC.Types.I# d_s4It7 [Occ=Once] ->
                    case eta_s4It2 of {
                      GHC.Types.D# x_s4It9 [Occ=Once] ->
                          case plusAddr# [addr_s4It5 d_s4It7] of sat_s4Ita {
                            __DEFAULT ->
                                case
                                    writeDoubleOffAddr# [sat_s4Ita 0# x_s4It9 GHC.Prim.void#]
                                of
                                s2_s4Itb
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Double
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableDouble_$calignment
                                                Foreign.Storable.$fStorableDouble_$calignment
                                                GHC.Storable.readDoubleOffPtr1
                                                GHC.Storable.writeDoubleOffPtr1
                                                Foreign.Storable.$fStorableDouble4
                                                Foreign.Storable.$fStorableDouble3
                                                Foreign.Storable.$fStorableDouble2
                                                Foreign.Storable.$fStorableDouble1];

Foreign.Storable.$fStorableFloat2
  :: GHC.Ptr.Ptr GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Float #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Itc void_0E]
        case ptr_s4Itc of {
          GHC.Ptr.Ptr a_s4Itf [Occ=Once] ->
              case readFloatOffAddr# [a_s4Itf 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Iti [Occ=Once] ->
                    let {
                      sat_s4Itj [Occ=Once] :: GHC.Types.Float
                      [LclId] =
                          CCCS GHC.Types.F#! [ipv1_s4Iti];
                    } in  Unit# [sat_s4Itj];
              };
        };

Foreign.Storable.$fStorableFloat4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Float #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Itk off_s4Itl void_0E]
        case ptr_s4Itk of {
          GHC.Ptr.Ptr addr_s4Ito [Occ=Once] ->
              case off_s4Itl of {
                GHC.Types.I# d_s4Itq [Occ=Once] ->
                    case plusAddr# [addr_s4Ito d_s4Itq] of sat_s4Itr {
                      __DEFAULT ->
                          case readFloatOffAddr# [sat_s4Itr 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Itu [Occ=Once] ->
                                let {
                                  sat_s4Itv [Occ=Once] :: GHC.Types.Float
                                  [LclId] =
                                      CCCS GHC.Types.F#! [ipv1_s4Itu];
                                } in  Unit# [sat_s4Itv];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFloat1
  :: GHC.Ptr.Ptr GHC.Types.Float
     -> GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Itw ds2_s4Itx void_0E]
        case ptr_s4Itw of {
          GHC.Ptr.Ptr a_s4ItA [Occ=Once] ->
              case ds2_s4Itx of {
                GHC.Types.F# x_s4ItC [Occ=Once] ->
                    case
                        writeFloatOffAddr# [a_s4ItA 0# x_s4ItC GHC.Prim.void#]
                    of
                    s2_s4ItD
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableFloat3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Float
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ItE off_s4ItF eta_s4ItG void_0E]
        case ptr_s4ItE of {
          GHC.Ptr.Ptr addr_s4ItJ [Occ=Once] ->
              case off_s4ItF of {
                GHC.Types.I# d_s4ItL [Occ=Once] ->
                    case eta_s4ItG of {
                      GHC.Types.F# x_s4ItN [Occ=Once] ->
                          case plusAddr# [addr_s4ItJ d_s4ItL] of sat_s4ItO {
                            __DEFAULT ->
                                case
                                    writeFloatOffAddr# [sat_s4ItO 0# x_s4ItN GHC.Prim.void#]
                                of
                                s2_s4ItP
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Float
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFloat_$calignment
                                                Foreign.Storable.$fStorableFloat_$calignment
                                                GHC.Storable.readFloatOffPtr1
                                                GHC.Storable.writeFloatOffPtr1
                                                Foreign.Storable.$fStorableFloat4
                                                Foreign.Storable.$fStorableFloat3
                                                Foreign.Storable.$fStorableFloat2
                                                Foreign.Storable.$fStorableFloat1];

Foreign.Storable.$fStorableStablePtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Stable.StablePtr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Stable.StablePtr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ItQ void_0E]
        case ptr_s4ItQ of {
          GHC.Ptr.Ptr a1_s4ItT [Occ=Once] ->
              case readStablePtrOffAddr# [a1_s4ItT 0# GHC.Prim.void#] of {
                Unit# ipv1_s4ItW [Occ=Once] ->
                    let {
                      sat_s4ItX [Occ=Once] :: GHC.Stable.StablePtr a_a4DpH
                      [LclId] =
                          CCCS GHC.Stable.StablePtr! [ipv1_s4ItW];
                    } in  Unit# [sat_s4ItX];
              };
        };

Foreign.Storable.$fStorableStablePtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Stable.StablePtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ItY off_s4ItZ void_0E]
        case ptr_s4ItY of {
          GHC.Ptr.Ptr addr_s4Iu2 [Occ=Once] ->
              case off_s4ItZ of {
                GHC.Types.I# d_s4Iu4 [Occ=Once] ->
                    case plusAddr# [addr_s4Iu2 d_s4Iu4] of sat_s4Iu5 {
                      __DEFAULT ->
                          case readStablePtrOffAddr# [sat_s4Iu5 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Iu8 [Occ=Once] ->
                                let {
                                  sat_s4Iu9 [Occ=Once] :: GHC.Stable.StablePtr a_a4DpH
                                  [LclId] =
                                      CCCS GHC.Stable.StablePtr! [ipv1_s4Iu8];
                                } in  Unit# [sat_s4Iu9];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Stable.StablePtr a)
     -> GHC.Stable.StablePtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iua ds2_s4Iub void_0E]
        case ptr_s4Iua of {
          GHC.Ptr.Ptr a1_s4Iue [Occ=Once] ->
              case ds2_s4Iub of {
                GHC.Stable.StablePtr x_s4Iug [Occ=Once] ->
                    case
                        writeStablePtrOffAddr# [a1_s4Iue 0# x_s4Iug GHC.Prim.void#]
                    of
                    s2_s4Iuh
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Stable.StablePtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iui off_s4Iuj eta_s4Iuk void_0E]
        case ptr_s4Iui of {
          GHC.Ptr.Ptr addr_s4Iun [Occ=Once] ->
              case off_s4Iuj of {
                GHC.Types.I# d_s4Iup [Occ=Once] ->
                    case eta_s4Iuk of {
                      GHC.Stable.StablePtr x_s4Iur [Occ=Once] ->
                          case plusAddr# [addr_s4Iun d_s4Iup] of sat_s4Ius {
                            __DEFAULT ->
                                case
                                    writeStablePtrOffAddr# [sat_s4Ius 0# x_s4Iur GHC.Prim.void#]
                                of
                                s2_s4Iut
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableStablePtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Stable.StablePtr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableStablePtr_$calignment
                                                Foreign.Storable.$fStorableStablePtr_$calignment
                                                GHC.Storable.readStablePtrOffPtr1
                                                GHC.Storable.writeStablePtrOffPtr1
                                                Foreign.Storable.$fStorableStablePtr4
                                                Foreign.Storable.$fStorableStablePtr3
                                                Foreign.Storable.$fStorableStablePtr2
                                                Foreign.Storable.$fStorableStablePtr1];

Foreign.Storable.$fStorableFunPtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.FunPtr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.FunPtr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iuu void_0E]
        case ptr_s4Iuu of {
          GHC.Ptr.Ptr a1_s4Iux [Occ=Once] ->
              case readAddrOffAddr# [a1_s4Iux 0# GHC.Prim.void#] of {
                Unit# ipv1_s4IuA [Occ=Once] ->
                    let {
                      sat_s4IuB [Occ=Once] :: GHC.Ptr.FunPtr a_a4Dqs
                      [LclId] =
                          CCCS GHC.Ptr.FunPtr! [ipv1_s4IuA];
                    } in  Unit# [sat_s4IuB];
              };
        };

Foreign.Storable.$fStorableFunPtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.FunPtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IuC off_s4IuD void_0E]
        case ptr_s4IuC of {
          GHC.Ptr.Ptr addr_s4IuG [Occ=Once] ->
              case off_s4IuD of {
                GHC.Types.I# d_s4IuI [Occ=Once] ->
                    case plusAddr# [addr_s4IuG d_s4IuI] of sat_s4IuJ {
                      __DEFAULT ->
                          case readAddrOffAddr# [sat_s4IuJ 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4IuM [Occ=Once] ->
                                let {
                                  sat_s4IuN [Occ=Once] :: GHC.Ptr.FunPtr a_a4Dqs
                                  [LclId] =
                                      CCCS GHC.Ptr.FunPtr! [ipv1_s4IuM];
                                } in  Unit# [sat_s4IuN];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.FunPtr a)
     -> GHC.Ptr.FunPtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IuO ds2_s4IuP void_0E]
        case ptr_s4IuO of {
          GHC.Ptr.Ptr a1_s4IuS [Occ=Once] ->
              case ds2_s4IuP of {
                GHC.Ptr.FunPtr x_s4IuU [Occ=Once] ->
                    case
                        writeAddrOffAddr# [a1_s4IuS 0# x_s4IuU GHC.Prim.void#]
                    of
                    s2_s4IuV
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Ptr.FunPtr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IuW off_s4IuX eta_s4IuY void_0E]
        case ptr_s4IuW of {
          GHC.Ptr.Ptr addr_s4Iv1 [Occ=Once] ->
              case off_s4IuX of {
                GHC.Types.I# d_s4Iv3 [Occ=Once] ->
                    case eta_s4IuY of {
                      GHC.Ptr.FunPtr x_s4Iv5 [Occ=Once] ->
                          case plusAddr# [addr_s4Iv1 d_s4Iv3] of sat_s4Iv6 {
                            __DEFAULT ->
                                case
                                    writeAddrOffAddr# [sat_s4Iv6 0# x_s4Iv5 GHC.Prim.void#]
                                of
                                s2_s4Iv7
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableFunPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Ptr.FunPtr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFunPtr_$calignment
                                                Foreign.Storable.$fStorableFunPtr_$calignment
                                                GHC.Storable.readFunPtrOffPtr1
                                                GHC.Storable.writeFunPtrOffPtr1
                                                Foreign.Storable.$fStorableFunPtr4
                                                Foreign.Storable.$fStorableFunPtr3
                                                Foreign.Storable.$fStorableFunPtr2
                                                Foreign.Storable.$fStorableFunPtr1];

Foreign.Storable.$fStorablePtr2
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.Ptr a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.Ptr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iv8 void_0E]
        case ptr_s4Iv8 of {
          GHC.Ptr.Ptr a1_s4Ivb [Occ=Once] ->
              case readAddrOffAddr# [a1_s4Ivb 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Ive [Occ=Once] ->
                    let {
                      sat_s4Ivf [Occ=Once] :: GHC.Ptr.Ptr a_a4Drd
                      [LclId] =
                          CCCS GHC.Ptr.Ptr! [ipv1_s4Ive];
                    } in  Unit# [sat_s4Ivf];
              };
        };

Foreign.Storable.$fStorablePtr4
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Ptr.Ptr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ivg off_s4Ivh void_0E]
        case ptr_s4Ivg of {
          GHC.Ptr.Ptr addr_s4Ivk [Occ=Once] ->
              case off_s4Ivh of {
                GHC.Types.I# d_s4Ivm [Occ=Once] ->
                    case plusAddr# [addr_s4Ivk d_s4Ivm] of sat_s4Ivn {
                      __DEFAULT ->
                          case readAddrOffAddr# [sat_s4Ivn 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Ivq [Occ=Once] ->
                                let {
                                  sat_s4Ivr [Occ=Once] :: GHC.Ptr.Ptr a_a4Drd
                                  [LclId] =
                                      CCCS GHC.Ptr.Ptr! [ipv1_s4Ivq];
                                } in  Unit# [sat_s4Ivr];
                          };
                    };
              };
        };

Foreign.Storable.$fStorablePtr1
  :: forall a.
     GHC.Ptr.Ptr (GHC.Ptr.Ptr a)
     -> GHC.Ptr.Ptr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ivs ds2_s4Ivt void_0E]
        case ptr_s4Ivs of {
          GHC.Ptr.Ptr a1_s4Ivw [Occ=Once] ->
              case ds2_s4Ivt of {
                GHC.Ptr.Ptr x_s4Ivy [Occ=Once] ->
                    case
                        writeAddrOffAddr# [a1_s4Ivw 0# x_s4Ivy GHC.Prim.void#]
                    of
                    s2_s4Ivz
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorablePtr3
  :: forall a b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Ptr.Ptr a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IvA off_s4IvB eta_s4IvC void_0E]
        case ptr_s4IvA of {
          GHC.Ptr.Ptr addr_s4IvF [Occ=Once] ->
              case off_s4IvB of {
                GHC.Types.I# d_s4IvH [Occ=Once] ->
                    case eta_s4IvC of {
                      GHC.Ptr.Ptr x_s4IvJ [Occ=Once] ->
                          case plusAddr# [addr_s4IvF d_s4IvH] of sat_s4IvK {
                            __DEFAULT ->
                                case
                                    writeAddrOffAddr# [sat_s4IvK 0# x_s4IvJ GHC.Prim.void#]
                                of
                                s2_s4IvL
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorablePtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Foreign.Storable.Storable (GHC.Ptr.Ptr a)
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorablePtr_$calignment
                                                Foreign.Storable.$fStorablePtr_$calignment
                                                GHC.Storable.readPtrOffPtr1
                                                GHC.Storable.writePtrOffPtr1
                                                Foreign.Storable.$fStorablePtr4
                                                Foreign.Storable.$fStorablePtr3
                                                Foreign.Storable.$fStorablePtr2
                                                Foreign.Storable.$fStorablePtr1];

Foreign.Storable.$fStorableWord2
  :: GHC.Ptr.Ptr GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Word #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IvM void_0E]
        case ptr_s4IvM of {
          GHC.Ptr.Ptr a_s4IvP [Occ=Once] ->
              case readWordOffAddr# [a_s4IvP 0# GHC.Prim.void#] of {
                Unit# ipv1_s4IvS [Occ=Once] ->
                    let {
                      sat_s4IvT [Occ=Once] :: GHC.Types.Word
                      [LclId] =
                          CCCS GHC.Types.W#! [ipv1_s4IvS];
                    } in  Unit# [sat_s4IvT];
              };
        };

Foreign.Storable.$fStorableWord4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Word #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IvU off_s4IvV void_0E]
        case ptr_s4IvU of {
          GHC.Ptr.Ptr addr_s4IvY [Occ=Once] ->
              case off_s4IvV of {
                GHC.Types.I# d_s4Iw0 [Occ=Once] ->
                    case plusAddr# [addr_s4IvY d_s4Iw0] of sat_s4Iw1 {
                      __DEFAULT ->
                          case readWordOffAddr# [sat_s4Iw1 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Iw4 [Occ=Once] ->
                                let {
                                  sat_s4Iw5 [Occ=Once] :: GHC.Types.Word
                                  [LclId] =
                                      CCCS GHC.Types.W#! [ipv1_s4Iw4];
                                } in  Unit# [sat_s4Iw5];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord1
  :: GHC.Ptr.Ptr GHC.Types.Word
     -> GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iw6 ds2_s4Iw7 void_0E]
        case ptr_s4Iw6 of {
          GHC.Ptr.Ptr a_s4Iwa [Occ=Once] ->
              case ds2_s4Iw7 of {
                GHC.Types.W# x_s4Iwc [Occ=Once] ->
                    case
                        writeWordOffAddr# [a_s4Iwa 0# x_s4Iwc GHC.Prim.void#]
                    of
                    s2_s4Iwd
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Word
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iwe off_s4Iwf eta_s4Iwg void_0E]
        case ptr_s4Iwe of {
          GHC.Ptr.Ptr addr_s4Iwj [Occ=Once] ->
              case off_s4Iwf of {
                GHC.Types.I# d_s4Iwl [Occ=Once] ->
                    case eta_s4Iwg of {
                      GHC.Types.W# x_s4Iwn [Occ=Once] ->
                          case plusAddr# [addr_s4Iwj d_s4Iwl] of sat_s4Iwo {
                            __DEFAULT ->
                                case
                                    writeWordOffAddr# [sat_s4Iwo 0# x_s4Iwn GHC.Prim.void#]
                                of
                                s2_s4Iwp
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Word
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord_$calignment
                                                Foreign.Storable.$fStorableWord_$calignment
                                                GHC.Storable.readWordOffPtr1
                                                GHC.Storable.writeWordOffPtr1
                                                Foreign.Storable.$fStorableWord4
                                                Foreign.Storable.$fStorableWord3
                                                Foreign.Storable.$fStorableWord2
                                                Foreign.Storable.$fStorableWord1];

Foreign.Storable.$fStorableInt2
  :: GHC.Ptr.Ptr GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iwq void_0E]
        case ptr_s4Iwq of {
          GHC.Ptr.Ptr a_s4Iwt [Occ=Once] ->
              case readIntOffAddr# [a_s4Iwt 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Iww [Occ=Once] ->
                    let {
                      sat_s4Iwx [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [ipv1_s4Iww];
                    } in  Unit# [sat_s4Iwx];
              };
        };

Foreign.Storable.$fStorableInt4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iwy off_s4Iwz void_0E]
        case ptr_s4Iwy of {
          GHC.Ptr.Ptr addr_s4IwC [Occ=Once] ->
              case off_s4Iwz of {
                GHC.Types.I# d_s4IwE [Occ=Once] ->
                    case plusAddr# [addr_s4IwC d_s4IwE] of sat_s4IwF {
                      __DEFAULT ->
                          case readIntOffAddr# [sat_s4IwF 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4IwI [Occ=Once] ->
                                let {
                                  sat_s4IwJ [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s4IwI];
                                } in  Unit# [sat_s4IwJ];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt1
  :: GHC.Ptr.Ptr GHC.Types.Int
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IwK ds2_s4IwL void_0E]
        case ptr_s4IwK of {
          GHC.Ptr.Ptr a_s4IwO [Occ=Once] ->
              case ds2_s4IwL of {
                GHC.Types.I# x_s4IwQ [Occ=Once] ->
                    case
                        writeIntOffAddr# [a_s4IwO 0# x_s4IwQ GHC.Prim.void#]
                    of
                    s2_s4IwR
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableInt3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IwS off_s4IwT eta_s4IwU void_0E]
        case ptr_s4IwS of {
          GHC.Ptr.Ptr addr_s4IwX [Occ=Once] ->
              case off_s4IwT of {
                GHC.Types.I# d_s4IwZ [Occ=Once] ->
                    case eta_s4IwU of {
                      GHC.Types.I# x_s4Ix1 [Occ=Once] ->
                          case plusAddr# [addr_s4IwX d_s4IwZ] of sat_s4Ix2 {
                            __DEFAULT ->
                                case
                                    writeIntOffAddr# [sat_s4Ix2 0# x_s4Ix1 GHC.Prim.void#]
                                of
                                s2_s4Ix3
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Int
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableInt_$calignment
                                                Foreign.Storable.$fStorableInt_$calignment
                                                GHC.Storable.readIntOffPtr1
                                                GHC.Storable.writeIntOffPtr1
                                                Foreign.Storable.$fStorableInt4
                                                Foreign.Storable.$fStorableInt3
                                                Foreign.Storable.$fStorableInt2
                                                Foreign.Storable.$fStorableInt1];

Foreign.Storable.$fStorableChar2
  :: GHC.Ptr.Ptr GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Char #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ix4 void_0E]
        case ptr_s4Ix4 of {
          GHC.Ptr.Ptr a_s4Ix7 [Occ=Once] ->
              case readWideCharOffAddr# [a_s4Ix7 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Ixa [Occ=Once] ->
                    let {
                      sat_s4Ixb [Occ=Once] :: GHC.Types.Char
                      [LclId] =
                          CCCS GHC.Types.C#! [ipv1_s4Ixa];
                    } in  Unit# [sat_s4Ixb];
              };
        };

Foreign.Storable.$fStorableChar4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Char #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ixc off_s4Ixd void_0E]
        case ptr_s4Ixc of {
          GHC.Ptr.Ptr addr_s4Ixg [Occ=Once] ->
              case off_s4Ixd of {
                GHC.Types.I# d_s4Ixi [Occ=Once] ->
                    case plusAddr# [addr_s4Ixg d_s4Ixi] of sat_s4Ixj {
                      __DEFAULT ->
                          case readWideCharOffAddr# [sat_s4Ixj 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Ixm [Occ=Once] ->
                                let {
                                  sat_s4Ixn [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ipv1_s4Ixm];
                                } in  Unit# [sat_s4Ixn];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableChar1
  :: GHC.Ptr.Ptr GHC.Types.Char
     -> GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ixo ds2_s4Ixp void_0E]
        case ptr_s4Ixo of {
          GHC.Ptr.Ptr a_s4Ixs [Occ=Once] ->
              case ds2_s4Ixp of {
                GHC.Types.C# x_s4Ixu [Occ=Once] ->
                    case
                        writeWideCharOffAddr# [a_s4Ixs 0# x_s4Ixu GHC.Prim.void#]
                    of
                    s2_s4Ixv
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableChar3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Char
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Ixw off_s4Ixx eta_s4Ixy void_0E]
        case ptr_s4Ixw of {
          GHC.Ptr.Ptr addr_s4IxB [Occ=Once] ->
              case off_s4Ixx of {
                GHC.Types.I# d_s4IxD [Occ=Once] ->
                    case eta_s4Ixy of {
                      GHC.Types.C# x_s4IxF [Occ=Once] ->
                          case plusAddr# [addr_s4IxB d_s4IxD] of sat_s4IxG {
                            __DEFAULT ->
                                case
                                    writeWideCharOffAddr# [sat_s4IxG 0# x_s4IxF GHC.Prim.void#]
                                of
                                s2_s4IxH
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Char
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableChar_$calignment
                                                Foreign.Storable.$fStorableChar_$calignment
                                                GHC.Storable.readWideCharOffPtr1
                                                GHC.Storable.writeWideCharOffPtr1
                                                Foreign.Storable.$fStorableChar4
                                                Foreign.Storable.$fStorableChar3
                                                Foreign.Storable.$fStorableChar2
                                                Foreign.Storable.$fStorableChar1];

Foreign.Storable.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$trModule4];

Foreign.Storable.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$trModule2];

Foreign.Storable.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Foreign.Storable.$trModule3
                                     Foreign.Storable.$trModule1];

$krep_r4Ffk :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepTyConApp! [GHC.Types.$tcConstraint
                                              GHC.Types.[]];

Foreign.Storable.$tcStorable1 [InlPrag=NOUSERINLINE[~]]
  :: GHC.Types.KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.KindRepFun! [GHC.Types.krep$* $krep_r4Ffk];

Foreign.Storable.$tcStorable3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Storable"#;

Foreign.Storable.$tcStorable2 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Foreign.Storable.$tcStorable3];

Foreign.Storable.$tcStorable :: GHC.Types.TyCon
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TyCon! [9192657549155052097##
                                    13909834202100645491##
                                    Foreign.Storable.$trModule
                                    Foreign.Storable.$tcStorable2
                                    0#
                                    Foreign.Storable.$tcStorable1];

Foreign.Storable.$fStorableWord20
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word8 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IxI void_0E]
        case ptr_s4IxI of {
          GHC.Ptr.Ptr a_s4IxL [Occ=Once] ->
              case readWord8OffAddr# [a_s4IxL 0# GHC.Prim.void#] of {
                Unit# ipv1_s4IxO [Occ=Once] ->
                    let {
                      sat_s4IxP [Occ=Once] :: GHC.Word.Word8
                      [LclId] =
                          CCCS GHC.Word.W8#! [ipv1_s4IxO];
                    } in  Unit# [sat_s4IxP];
              };
        };

Foreign.Storable.$fStorableWord22
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IxQ off_s4IxR void_0E]
        case ptr_s4IxQ of {
          GHC.Ptr.Ptr addr_s4IxU [Occ=Once] ->
              case off_s4IxR of {
                GHC.Types.I# d_s4IxW [Occ=Once] ->
                    case plusAddr# [addr_s4IxU d_s4IxW] of sat_s4IxX {
                      __DEFAULT ->
                          case readWord8OffAddr# [sat_s4IxX 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Iy0 [Occ=Once] ->
                                let {
                                  sat_s4Iy1 [Occ=Once] :: GHC.Word.Word8
                                  [LclId] =
                                      CCCS GHC.Word.W8#! [ipv1_s4Iy0];
                                } in  Unit# [sat_s4Iy1];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord19
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iy2 ds2_s4Iy3 void_0E]
        case ptr_s4Iy2 of {
          GHC.Ptr.Ptr a_s4Iy6 [Occ=Once] ->
              case ds2_s4Iy3 of {
                GHC.Word.W8# x_s4Iy8 [Occ=Once] ->
                    case
                        writeWord8OffAddr# [a_s4Iy6 0# x_s4Iy8 GHC.Prim.void#]
                    of
                    s2_s4Iy9
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableWord21
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Word.Word8
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iya off_s4Iyb eta_s4Iyc void_0E]
        case ptr_s4Iya of {
          GHC.Ptr.Ptr addr_s4Iyf [Occ=Once] ->
              case off_s4Iyb of {
                GHC.Types.I# d_s4Iyh [Occ=Once] ->
                    case eta_s4Iyc of {
                      GHC.Word.W8# x_s4Iyj [Occ=Once] ->
                          case plusAddr# [addr_s4Iyf d_s4Iyh] of sat_s4Iyk {
                            __DEFAULT ->
                                case
                                    writeWord8OffAddr# [sat_s4Iyk 0# x_s4Iyj GHC.Prim.void#]
                                of
                                s2_s4Iyl
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableWord8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Word.Word8
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableWord8_$calignment
                                                Foreign.Storable.$fStorableWord8_$calignment
                                                GHC.Storable.readWord8OffPtr1
                                                GHC.Storable.writeWord8OffPtr1
                                                Foreign.Storable.$fStorableWord22
                                                Foreign.Storable.$fStorableWord21
                                                Foreign.Storable.$fStorableWord20
                                                Foreign.Storable.$fStorableWord19];

Foreign.Storable.$fStorableRatio2
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=4,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,1*C1(C1(C1(U(U,U)))),A,A,A,1*C1(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4Iym $dIntegral_s4Iyn p_s4Iyo void_0E]
        case
            Foreign.Storable.peek $dStorable_s4Iym p_s4Iyo GHC.Prim.void#
        of
        { Unit# ipv1_s4Iys [Occ=Once] ->
              case
                  Foreign.Storable.peekElemOff
                      $dStorable_s4Iym
                      p_s4Iyo
                      Foreign.Storable.$fStorable()7
                      GHC.Prim.void#
              of
              { Unit# ipv3_s4Iyv [Occ=Once] ->
                    let {
                      sat_s4Iyw [Occ=Once] :: GHC.Real.Ratio a_a4DgH
                      [LclId] =
                          [$dIntegral_s4Iyn ipv1_s4Iys ipv3_s4Iyv] \u []
                              GHC.Real.% $dIntegral_s4Iyn ipv1_s4Iys ipv3_s4Iyv;
                    } in  Unit# [sat_s4Iyw];
              };
        };

Foreign.Storable.$fStorableRatio1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,A><L,U><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4Iyx w1_s4Iyy w2_s4Iyz w3_s4IyA void_0E]
        case w3_s4IyA of {
          GHC.Real.:% ww1_s4IyD [Occ=Once] ww2_s4IyE [Occ=Once] ->
              case
                  Foreign.Storable.poke w_s4Iyx w2_s4Iyz ww1_s4IyD GHC.Prim.void#
              of
              { Unit# _ [Occ=Dead] ->
                    Foreign.Storable.pokeElemOff
                        w_s4Iyx
                        w2_s4Iyz
                        Foreign.Storable.$fStorable()7
                        ww2_s4IyE
                        GHC.Prim.void#;
              };
        };

Foreign.Storable.$fStorableBool6
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [p_s4IyI i_s4IyJ void_0E]
        case p_s4IyI of {
          GHC.Ptr.Ptr a_s4IyM [Occ=Once] ->
              case i_s4IyJ of {
                GHC.Types.I# i1_s4IyO [Occ=Once] ->
                    case readInt32OffAddr# [a_s4IyM i1_s4IyO GHC.Prim.void#] of {
                      Unit# ipv1_s4IyR [Occ=Once!] ->
                          let {
                            sat_s4IyT [Occ=Once] :: GHC.Types.Bool
                            [LclId] =
                                [ipv1_s4IyR] \u []
                                    case ipv1_s4IyR of {
                                      __DEFAULT -> GHC.Types.True [];
                                      0# -> GHC.Types.False [];
                                    };
                          } in  Unit# [sat_s4IyT];
                    };
              };
        };

Foreign.Storable.$fStorableBool2
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IyU void_0E]
        case ptr_s4IyU of {
          GHC.Ptr.Ptr a_s4IyX [Occ=Once] ->
              case readInt32OffAddr# [a_s4IyX 0# GHC.Prim.void#] of {
                Unit# ipv1_s4Iz0 [Occ=Once!] ->
                    let {
                      sat_s4Iz2 [Occ=Once] :: GHC.Types.Bool
                      [LclId] =
                          [ipv1_s4Iz0] \u []
                              case ipv1_s4Iz0 of {
                                __DEFAULT -> GHC.Types.True [];
                                0# -> GHC.Types.False [];
                              };
                    } in  Unit# [sat_s4Iz2];
              };
        };

Foreign.Storable.$fStorableBool4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Iz3 off_s4Iz4 void_0E]
        case ptr_s4Iz3 of {
          GHC.Ptr.Ptr addr_s4Iz7 [Occ=Once] ->
              case off_s4Iz4 of {
                GHC.Types.I# d_s4Iz9 [Occ=Once] ->
                    case plusAddr# [addr_s4Iz7 d_s4Iz9] of sat_s4Iza {
                      __DEFAULT ->
                          case readInt32OffAddr# [sat_s4Iza 0# GHC.Prim.void#] of {
                            Unit# ipv1_s4Izd [Occ=Once!] ->
                                let {
                                  sat_s4Izf [Occ=Once] :: GHC.Types.Bool
                                  [LclId] =
                                      [ipv1_s4Izd] \u []
                                          case ipv1_s4Izd of {
                                            __DEFAULT -> GHC.Types.True [];
                                            0# -> GHC.Types.False [];
                                          };
                                } in  Unit# [sat_s4Izf];
                          };
                    };
              };
        };

Foreign.Storable.$fStorableBool1
  :: GHC.Ptr.Ptr GHC.Types.Bool
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Izg x_s4Izh void_0E]
        case ptr_s4Izg of {
          GHC.Ptr.Ptr a_s4Izk [Occ=Once*] ->
              case x_s4Izh of {
                GHC.Types.False ->
                    case
                        writeInt32OffAddr# [a_s4Izk 0# 0# GHC.Prim.void#]
                    of
                    s2_s4Izm
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
                GHC.Types.True ->
                    case
                        writeInt32OffAddr# [a_s4Izk 0# 1# GHC.Prim.void#]
                    of
                    s2_s4Izn
                    { (##) -> Unit# [GHC.Tuple.()];
                    };
              };
        };

Foreign.Storable.$fStorableBool3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Types.Bool
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4Izo off_s4Izp eta_s4Izq void_0E]
        case ptr_s4Izo of {
          GHC.Ptr.Ptr addr_s4Izt [Occ=Once*] ->
              case off_s4Izp of {
                GHC.Types.I# d_s4Izv [Occ=Once*] ->
                    case eta_s4Izq of {
                      GHC.Types.False ->
                          case plusAddr# [addr_s4Izt d_s4Izv] of sat_s4Izx {
                            __DEFAULT ->
                                case
                                    writeInt32OffAddr# [sat_s4Izx 0# 0# GHC.Prim.void#]
                                of
                                s2_s4Izy
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                      GHC.Types.True ->
                          case plusAddr# [addr_s4Izt d_s4Izv] of sat_s4Izz {
                            __DEFAULT ->
                                case
                                    writeInt32OffAddr# [sat_s4Izz 0# 1# GHC.Prim.void#]
                                of
                                s2_s4IzA
                                { (##) -> Unit# [GHC.Tuple.()];
                                };
                          };
                    };
              };
        };

Foreign.Storable.$fStorableBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Types.Bool
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableBool_$csizeOf
                                                Foreign.Storable.$fStorableBool_$csizeOf
                                                Foreign.Storable.$fStorableBool6
                                                Foreign.Storable.$fStorableBool5
                                                Foreign.Storable.$fStorableBool4
                                                Foreign.Storable.$fStorableBool3
                                                Foreign.Storable.$fStorableBool2
                                                Foreign.Storable.$fStorableBool1];

Foreign.Storable.$fStorable()2
  :: GHC.Ptr.Ptr ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId, Arity=2, Caf=NoCafRefs, Str=<L,A><S,U>, Unf=OtherCon []] =
    [] \r [ds_s4IzB void_0E] Unit# [GHC.Tuple.()];

Foreign.Storable.$fStorable()1
  :: GHC.Ptr.Ptr ()
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_s4IzD ds1_s4IzE void_0E] Unit# [GHC.Tuple.()];

lvl11_r4Ffl :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [137#];

lvl12_r4Ffm :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [31#];

lvl13_r4Ffn :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [40#];

lvl14_r4Ffo :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl11_r4Ffl
                                           lvl12_r4Ffm
                                           lvl11_r4Ffl
                                           lvl13_r4Ffn];

lvl15_r4Ffp :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl14_r4Ffo
                                                  GHC.Stack.Types.EmptyCallStack];

lvl16_r4Ffq :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl15_r4Ffp;

Foreign.Storable.$dmpeekElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
[GblId,
 Arity=3,
 Str=<S(LLLLC(C(S))LLL),U(1*C1(U(U)),A,A,A,1*C1(C1(U)),A,A,A)><L,U><L,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4IzG ptr_s4IzH off_s4IzI]
        let {
          sat_s4IzO [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4IzG off_s4IzI] \u []
                  case off_s4IzI of {
                    GHC.Types.I# x_s4IzK [Occ=Once] ->
                        case Foreign.Storable.sizeOf $dStorable_s4IzG lvl16_r4Ffq of {
                          GHC.Types.I# y_s4IzM [Occ=Once] ->
                              case *# [x_s4IzK y_s4IzM] of sat_s4IzN {
                                __DEFAULT -> GHC.Types.I# [sat_s4IzN];
                              };
                        };
                  };
        } in 
          Foreign.Storable.peekByteOff $dStorable_s4IzG ptr_s4IzH sat_s4IzO;

Foreign.Storable.$dmpokeElemOff
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(C(S)))LL),U(1*C1(U(U)),A,A,A,A,1*C1(C1(C1(U))),A,A)><L,U><L,1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4IzP ptr_s4IzQ off_s4IzR val_s4IzS]
        let {
          sat_s4IzY [Occ=Once] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4IzP off_s4IzR val_s4IzS] \u []
                  case off_s4IzR of {
                    GHC.Types.I# x_s4IzU [Occ=Once] ->
                        case Foreign.Storable.sizeOf $dStorable_s4IzP val_s4IzS of {
                          GHC.Types.I# y_s4IzW [Occ=Once] ->
                              case *# [x_s4IzU y_s4IzW] of sat_s4IzX {
                                __DEFAULT -> GHC.Types.I# [sat_s4IzX];
                              };
                        };
                  };
        } in 
          Foreign.Storable.pokeByteOff
              $dStorable_s4IzP ptr_s4IzQ sat_s4IzY val_s4IzS;

Foreign.Storable.$fStorable()4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IzZ off_s4IA0 void_0E] Unit# [GHC.Tuple.()];

Foreign.Storable.$fStorable()6
  :: GHC.Ptr.Ptr ()
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IA2 off_s4IA3 void_0E] Unit# [GHC.Tuple.()];

Foreign.Storable.$fStorable()3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IA5 off_s4IA6 ds_s4IA7 void_0E] Unit# [GHC.Tuple.()];

Foreign.Storable.$fStorable()5
  :: GHC.Ptr.Ptr ()
     -> GHC.Types.Int
     -> ()
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IA9 off_s4IAa val_s4IAb void_0E] Unit# [GHC.Tuple.()];

Foreign.Storable.$fStorable() [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable ()
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorable()_$csizeOf
                                                Foreign.Storable.$fStorable()_$calignment
                                                Foreign.Storable.$fStorable()6
                                                Foreign.Storable.$fStorable()5
                                                Foreign.Storable.$fStorable()4
                                                Foreign.Storable.$fStorable()3
                                                Foreign.Storable.$fStorable()2
                                                Foreign.Storable.$fStorable()1];

lvl17_r4Ffr :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [237#];

lvl18_r4Ffs :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [lvl2_r4Ffb
                                           lvl3_r4Ffc
                                           lvl5_r4Ffe
                                           lvl17_r4Ffr
                                           lvl12_r4Ffm
                                           lvl17_r4Ffr
                                           lvl13_r4Ffn];

lvl19_r4Fft :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [lvl1_r4Ffa
                                                  lvl18_r4Ffs
                                                  GHC.Stack.Types.EmptyCallStack];

Foreign.Storable.$fStorableRatio6 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.undefined lvl19_r4Fft;

Foreign.Storable.$fStorableRatio_$csizeOf
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Real.Ratio a -> GHC.Types.Int
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(U(U)),A,A,A,A,A,A,A)><L,A>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4IAd $dIntegral_s4IAe]
        let {
          lvl20_s4IAf [Occ=OnceL!, Dmd=<L,U(U)>] :: GHC.Types.Int
          [LclId] =
              [$dStorable_s4IAd] \u []
                  Foreign.Storable.sizeOf
                      $dStorable_s4IAd Foreign.Storable.$fStorableRatio6; } in
        let {
          sat_s4IAk [Occ=OnceT[0]] :: GHC.Real.Ratio a_X4DnT -> GHC.Types.Int
          [LclId] =
              [lvl20_s4IAf] \r [ds_s4IAg]
                  case lvl20_s4IAf of {
                    GHC.Types.I# y_s4IAi [Occ=Once] ->
                        case *# [2# y_s4IAi] of sat_s4IAj {
                          __DEFAULT -> GHC.Types.I# [sat_s4IAj];
                        };
                  };
        } in  sat_s4IAk;

Foreign.Storable.$fStorableRatio4
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4IAl
           $dIntegral_s4IAm
           ptr_s4IAn
           off_s4IAo
           void_0E]
        let {
          sat_s4IAv [Occ=Once] :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnX)
          [LclId] =
              [ptr_s4IAn off_s4IAo] \u []
                  case ptr_s4IAn of {
                    GHC.Ptr.Ptr addr_s4IAr [Occ=Once] ->
                        case off_s4IAo of {
                          GHC.Types.I# d_s4IAt [Occ=Once] ->
                              case plusAddr# [addr_s4IAr d_s4IAt] of sat_s4IAu {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4IAu];
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableRatio2
              $dStorable_s4IAl $dIntegral_s4IAm sat_s4IAv GHC.Prim.void#;

Foreign.Storable.$fStorableRatio7
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Real.Ratio a #)
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S(SL)))L),U(1*C1(U(U)),A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [$dStorable_s4IAw
           $dIntegral_s4IAx
           ptr_s4IAy
           off_s4IAz
           void_0E]
        let {
          sat_s4IAK [Occ=Once] :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnY)
          [LclId] =
              [$dStorable_s4IAw ptr_s4IAy off_s4IAz] \u []
                  case ptr_s4IAy of {
                    GHC.Ptr.Ptr addr_s4IAC [Occ=Once] ->
                        case off_s4IAz of {
                          GHC.Types.I# x_s4IAE [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf
                                      $dStorable_s4IAw Foreign.Storable.$fStorableRatio6
                              of
                              { GHC.Types.I# y_s4IAG [Occ=Once] ->
                                    case *# [2# y_s4IAG] of sat_s4IAH {
                                      __DEFAULT ->
                                          case *# [x_s4IAE sat_s4IAH] of sat_s4IAI {
                                            __DEFAULT ->
                                                case plusAddr# [addr_s4IAC sat_s4IAI] of sat_s4IAJ {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4IAJ];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableRatio2
              $dStorable_s4IAw $dIntegral_s4IAx sat_s4IAK GHC.Prim.void#;

Foreign.Storable.$w$cpokeByteOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IAL w1_s4IAM w2_s4IAN ww_s4IAO ww1_s4IAP void_0E]
        let {
          p_s4IAR :: GHC.Ptr.Ptr (GHC.Real.Ratio a_s4EvU)
          [LclId] =
              [w1_s4IAM w2_s4IAN] \u []
                  case w1_s4IAM of {
                    GHC.Ptr.Ptr addr_s4IAT [Occ=Once] ->
                        case w2_s4IAN of {
                          GHC.Types.I# d_s4IAV [Occ=Once] ->
                              case plusAddr# [addr_s4IAT d_s4IAV] of sat_s4IAW {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4IAW];
                              };
                        };
                  };
        } in 
          case
              Foreign.Storable.poke w_s4IAL p_s4IAR ww_s4IAO GHC.Prim.void#
          of
          { Unit# _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_s4IAL
                    p_s4IAR
                    Foreign.Storable.$fStorable()7
                    ww1_s4IAP
                    GHC.Prim.void#;
          };

Foreign.Storable.$fStorableRatio3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,A><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IB0 w1_s4IB1 w2_s4IB2 w3_s4IB3 w4_s4IB4 void_0E]
        case w4_s4IB4 of {
          GHC.Real.:% ww1_s4IB7 [Occ=Once] ww2_s4IB8 [Occ=Once] ->
              Foreign.Storable.$w$cpokeByteOff
                  w_s4IB0 w2_s4IB2 w3_s4IB3 ww1_s4IB7 ww2_s4IB8 GHC.Prim.void#;
        };

Foreign.Storable.$w$cpokeElemOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Foreign.Storable.Storable a =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> a
     -> a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(1*C1(U(U)),A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IB9 w1_s4IBa w2_s4IBb ww_s4IBc ww1_s4IBd void_0E]
        let {
          p_s4IBf :: GHC.Ptr.Ptr (GHC.Real.Ratio a_s4Ew8)
          [LclId] =
              [w_s4IB9 w1_s4IBa w2_s4IBb] \u []
                  case w1_s4IBa of {
                    GHC.Ptr.Ptr addr_s4IBh [Occ=Once] ->
                        case w2_s4IBb of {
                          GHC.Types.I# x_s4IBj [Occ=Once] ->
                              case
                                  Foreign.Storable.sizeOf w_s4IB9 Foreign.Storable.$fStorableRatio6
                              of
                              { GHC.Types.I# y_s4IBl [Occ=Once] ->
                                    case *# [2# y_s4IBl] of sat_s4IBm {
                                      __DEFAULT ->
                                          case *# [x_s4IBj sat_s4IBm] of sat_s4IBn {
                                            __DEFAULT ->
                                                case plusAddr# [addr_s4IBh sat_s4IBn] of sat_s4IBo {
                                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4IBo];
                                                };
                                          };
                                    };
                              };
                        };
                  };
        } in 
          case
              Foreign.Storable.poke w_s4IB9 p_s4IBf ww_s4IBc GHC.Prim.void#
          of
          { Unit# _ [Occ=Dead] ->
                Foreign.Storable.pokeElemOff
                    w_s4IB9
                    p_s4IBf
                    Foreign.Storable.$fStorable()7
                    ww1_s4IBd
                    GHC.Prim.void#;
          };

Foreign.Storable.$fStorableRatio5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     GHC.Ptr.Ptr (GHC.Real.Ratio a)
     -> GHC.Types.Int
     -> GHC.Real.Ratio a
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=6,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(C(U(U)),A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,A><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IBs w1_s4IBt w2_s4IBu w3_s4IBv w4_s4IBw void_0E]
        case w4_s4IBw of {
          GHC.Real.:% ww1_s4IBz [Occ=Once] ww2_s4IBA [Occ=Once] ->
              Foreign.Storable.$w$cpokeElemOff
                  w_s4IBs w2_s4IBu w3_s4IBv ww1_s4IBz ww2_s4IBA GHC.Prim.void#;
        };

Foreign.Storable.$fStorableRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a.
     (Foreign.Storable.Storable a, GHC.Real.Integral a) =>
     Foreign.Storable.Storable (GHC.Real.Ratio a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(U(U)),1*C1(U),C(C1(C1(U(U,U)))),C(C1(C1(C1(U(U,U))))),A,A,C(C1(U(U,U))),C(C1(C1(U(U,A)))))><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m] =
    [] \r [$dStorable_s4IBB $dIntegral_s4IBC]
        let {
          sat_s4IBK [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B3 eta_B2 void_0E]
                  Foreign.Storable.$fStorableRatio1
                      $dStorable_s4IBB
                      $dIntegral_s4IBC
                      eta_B3
                      eta_B2
                      GHC.Prim.void#; } in
        let {
          sat_s4IBJ [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B2 void_0E]
                  Foreign.Storable.$fStorableRatio2
                      $dStorable_s4IBB $dIntegral_s4IBC eta_B2 GHC.Prim.void#; } in
        let {
          sat_s4IBI [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B4
                                                      eta_B3
                                                      eta_B2
                                                      void_0E]
                  Foreign.Storable.$fStorableRatio3
                      $dStorable_s4IBB
                      $dIntegral_s4IBC
                      eta_B4
                      eta_B3
                      eta_B2
                      GHC.Prim.void#; } in
        let {
          sat_s4IBH [Occ=Once]
            :: forall b.
               GHC.Ptr.Ptr b
               -> GHC.Types.Int -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B3 eta_B2 void_0E]
                  Foreign.Storable.$fStorableRatio4
                      $dStorable_s4IBB
                      $dIntegral_s4IBC
                      eta_B3
                      eta_B2
                      GHC.Prim.void#; } in
        let {
          sat_s4IBG [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.Int -> GHC.Real.Ratio a_X4DnU -> GHC.Types.IO ()
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B4
                                                      eta_B3
                                                      eta_B2
                                                      void_0E]
                  Foreign.Storable.$fStorableRatio5
                      $dStorable_s4IBB
                      $dIntegral_s4IBC
                      eta_B4
                      eta_B3
                      eta_B2
                      GHC.Prim.void#; } in
        let {
          sat_s4IBF [Occ=Once]
            :: GHC.Ptr.Ptr (GHC.Real.Ratio a_X4DnU)
               -> GHC.Types.Int -> GHC.Types.IO (GHC.Real.Ratio a_X4DnU)
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \r [eta_B3 eta_B2 void_0E]
                  Foreign.Storable.$fStorableRatio7
                      $dStorable_s4IBB
                      $dIntegral_s4IBC
                      eta_B3
                      eta_B2
                      GHC.Prim.void#; } in
        let {
          sat_s4IBE [Occ=Once] :: GHC.Real.Ratio a_X4DnU -> GHC.Types.Int
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \u []
                  Foreign.Storable.$fStorableRatio_$calignment
                      $dStorable_s4IBB $dIntegral_s4IBC; } in
        let {
          sat_s4IBD [Occ=Once] :: GHC.Real.Ratio a_X4DnU -> GHC.Types.Int
          [LclId] =
              [$dStorable_s4IBB $dIntegral_s4IBC] \u []
                  Foreign.Storable.$fStorableRatio_$csizeOf
                      $dStorable_s4IBB $dIntegral_s4IBC;
        } in 
          Foreign.Storable.C:Storable [sat_s4IBD
                                       sat_s4IBE
                                       sat_s4IBF
                                       sat_s4IBG
                                       sat_s4IBH
                                       sat_s4IBI
                                       sat_s4IBJ
                                       sat_s4IBK];

Foreign.Storable.$wpokeW64 [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.Int#
     -> GHC.Word.Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><S,1*U><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IBL ww_s4IBM w1_s4IBN void_0E]
        case ww_s4IBM of ds_s4IBP {
          __DEFAULT ->
              case w1_s4IBN of {
                GHC.Word.W64# ipv_s4IBR ->
                    case w_s4IBL of wild_s4IBS {
                      GHC.Ptr.Ptr a_s4IBT [Occ=Once] ->
                          case narrow8Word# [ipv_s4IBR] of sat_s4IBV {
                            __DEFAULT ->
                                case -# [ds_s4IBP 1#] of sat_s4IBU {
                                  __DEFAULT ->
                                      case
                                          writeWord8OffAddr# [a_s4IBT
                                                              sat_s4IBU
                                                              sat_s4IBV
                                                              GHC.Prim.void#]
                                      of
                                      s2_s4IBW
                                      { (##) ->
                                            case uncheckedShiftRL# [ipv_s4IBR 8#] of sat_s4IBY {
                                              __DEFAULT ->
                                                  let {
                                                    sat_s4IBZ [Occ=Once] :: GHC.Word.Word64
                                                    [LclId] =
                                                        CCCS GHC.Word.W64#! [sat_s4IBY];
                                                  } in 
                                                    case -# [ds_s4IBP 1#] of sat_s4IBX {
                                                      __DEFAULT ->
                                                          Foreign.Storable.$wpokeW64
                                                              wild_s4IBS
                                                              sat_s4IBX
                                                              sat_s4IBZ
                                                              GHC.Prim.void#;
                                                    };
                                            };
                                      };
                                };
                          };
                    };
              };
          0# -> Unit# [GHC.Tuple.()];
        };

Foreign.Storable.$w$cpoke [InlPrag=NOUSERINLINE[0]]
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.Word#
     -> GHC.Prim.Word#
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4IC0 ww_s4IC1 ww1_s4IC2 void_0E]
        let {
          sat_s4IC4 [Occ=Once] :: GHC.Word.Word64
          [LclId] =
              CCCS GHC.Word.W64#! [ww_s4IC1];
        } in 
          case
              Foreign.Storable.$wpokeW64 w_s4IC0 8# sat_s4IC4 GHC.Prim.void#
          of
          { Unit# _ [Occ=Dead] ->
                let {
                  sat_s4ICc [Occ=Once] :: GHC.Word.Word64
                  [LclId] =
                      CCCS GHC.Word.W64#! [ww1_s4IC2]; } in
                let {
                  sat_s4ICb [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Ptr.Ptr GHC.Word.Word8
                  [LclId] =
                      [w_s4IC0] \s []
                          case w_s4IC0 of {
                            GHC.Ptr.Ptr addr_s4IC9 [Occ=Once] ->
                                case plusAddr# [addr_s4IC9 8#] of sat_s4ICa {
                                  __DEFAULT -> GHC.Ptr.Ptr [sat_s4ICa];
                                };
                          };
                } in 
                  Foreign.Storable.$wpokeW64 sat_s4ICb 8# sat_s4ICc GHC.Prim.void#;
          };

Foreign.Storable.$fStorableFingerprint1 [InlPrag=NOUSERINLINE[0]]
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4ICd w1_s4ICe void_0E]
        case w1_s4ICe of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4ICh [Occ=Once]
                                           ww2_s4ICi [Occ=Once] ->
              Foreign.Storable.$w$cpoke
                  w_s4ICd ww1_s4ICh ww2_s4ICi GHC.Prim.void#;
        };

Foreign.Storable.$wpeekW64 [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: GHC.Ptr.Ptr GHC.Word.Word8
     -> GHC.Prim.Int#
     -> GHC.Prim.Word#
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Word.Word64 #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><S,1*U><L,U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_s4ICj ww_s4ICk ww1_s4ICl void_0E]
        case ww_s4ICk of ds_s4ICn {
          __DEFAULT ->
              case w_s4ICj of {
                GHC.Ptr.Ptr ipv_s4ICp ->
                    case readWord8OffAddr# [ipv_s4ICp 0# GHC.Prim.void#] of {
                      Unit# ipv2_s4ICs [Occ=Once] ->
                          case uncheckedShiftL# [ww1_s4ICl 8#] of sat_s4ICw {
                            __DEFAULT ->
                                case or# [sat_s4ICw ipv2_s4ICs] of sat_s4ICx {
                                  __DEFAULT ->
                                      case -# [ds_s4ICn 1#] of sat_s4ICv {
                                        __DEFAULT ->
                                            case plusAddr# [ipv_s4ICp 1#] of sat_s4ICt {
                                              __DEFAULT ->
                                                  let {
                                                    sat_s4ICu [Occ=Once]
                                                      :: GHC.Ptr.Ptr GHC.Word.Word8
                                                    [LclId] =
                                                        CCCS GHC.Ptr.Ptr! [sat_s4ICt];
                                                  } in 
                                                    Foreign.Storable.$wpeekW64
                                                        sat_s4ICu
                                                        sat_s4ICv
                                                        sat_s4ICx
                                                        GHC.Prim.void#;
                                            };
                                      };
                                };
                          };
                    };
              };
          0# ->
              let {
                sat_s4ICy [Occ=Once] :: GHC.Word.Word64
                [LclId] =
                    CCCS GHC.Word.W64#! [ww1_s4ICl];
              } in  Unit# [sat_s4ICy];
        };

Foreign.Storable.$fStorableFingerprint2
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [p0_s4ICz void_0E]
        case Foreign.Storable.$wpeekW64 p0_s4ICz 8# 0## GHC.Prim.void# of {
          Unit# ipv1_s4ICD [Occ=Once] ->
              let {
                sat_s4ICH [Occ=Once, Dmd=<L,1*U(U)>] :: GHC.Ptr.Ptr GHC.Word.Word8
                [LclId] =
                    [p0_s4ICz] \s []
                        case p0_s4ICz of {
                          GHC.Ptr.Ptr addr_s4ICF [Occ=Once] ->
                              case plusAddr# [addr_s4ICF 8#] of sat_s4ICG {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4ICG];
                              };
                        };
              } in 
                case
                    Foreign.Storable.$wpeekW64 sat_s4ICH 8# 0## GHC.Prim.void#
                of
                { Unit# ipv3_s4ICK [Occ=Once] ->
                      let {
                        sat_s4ICL [Occ=Once] :: GHC.Fingerprint.Type.Fingerprint
                        [LclId] =
                            [ipv1_s4ICD ipv3_s4ICK] \u []
                                GHC.Fingerprint.Type.$WFingerprint ipv1_s4ICD ipv3_s4ICK;
                      } in  Unit# [sat_s4ICL];
                };
        };

Foreign.Storable.$fStorableFingerprint4
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ICM off_s4ICN void_0E]
        let {
          sat_s4ICU [Occ=Once, Dmd=<L,U(U)>]
            :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
          [LclId] =
              [ptr_s4ICM off_s4ICN] \u []
                  case ptr_s4ICM of {
                    GHC.Ptr.Ptr addr_s4ICQ [Occ=Once] ->
                        case off_s4ICN of {
                          GHC.Types.I# d_s4ICS [Occ=Once] ->
                              case plusAddr# [addr_s4ICQ d_s4ICS] of sat_s4ICT {
                                __DEFAULT -> GHC.Ptr.Ptr [sat_s4ICT];
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableFingerprint2 sat_s4ICU GHC.Prim.void#;

Foreign.Storable.$fStorableFingerprint6
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Types.Int
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
           GHC.Fingerprint.Type.Fingerprint #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ICV off_s4ICW void_0E]
        let {
          sat_s4ID4 [Occ=Once, Dmd=<L,U(U)>]
            :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
          [LclId] =
              [ptr_s4ICV off_s4ICW] \u []
                  case ptr_s4ICV of {
                    GHC.Ptr.Ptr addr_s4ICZ [Occ=Once] ->
                        case off_s4ICW of {
                          GHC.Types.I# x_s4ID1 [Occ=Once] ->
                              case *# [x_s4ID1 16#] of sat_s4ID2 {
                                __DEFAULT ->
                                    case plusAddr# [addr_s4ICZ sat_s4ID2] of sat_s4ID3 {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_s4ID3];
                                    };
                              };
                        };
                  };
        } in 
          Foreign.Storable.$fStorableFingerprint2 sat_s4ID4 GHC.Prim.void#;

Foreign.Storable.$fStorableFingerprint3
  :: forall b.
     GHC.Ptr.Ptr b
     -> GHC.Types.Int
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4ID5 off_s4ID6 eta_s4ID7 void_0E]
        case eta_s4ID7 of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4IDa [Occ=Once]
                                           ww2_s4IDb [Occ=Once] ->
              let {
                sat_s4IDh [Occ=Once, Dmd=<L,U(U)>]
                  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
                [LclId] =
                    [ptr_s4ID5 off_s4ID6] \u []
                        case ptr_s4ID5 of {
                          GHC.Ptr.Ptr addr_s4IDd [Occ=Once] ->
                              case off_s4ID6 of {
                                GHC.Types.I# d_s4IDf [Occ=Once] ->
                                    case plusAddr# [addr_s4IDd d_s4IDf] of sat_s4IDg {
                                      __DEFAULT -> GHC.Ptr.Ptr [sat_s4IDg];
                                    };
                              };
                        };
              } in 
                Foreign.Storable.$w$cpoke
                    sat_s4IDh ww1_s4IDa ww2_s4IDb GHC.Prim.void#;
        };

Foreign.Storable.$fStorableFingerprint5
  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
     -> GHC.Types.Int
     -> GHC.Fingerprint.Type.Fingerprint
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=OtherCon []] =
    [] \r [ptr_s4IDi off_s4IDj val_s4IDk void_0E]
        case val_s4IDk of {
          GHC.Fingerprint.Type.Fingerprint ww1_s4IDn [Occ=Once]
                                           ww2_s4IDo [Occ=Once] ->
              let {
                sat_s4IDv [Occ=Once, Dmd=<L,U(U)>]
                  :: GHC.Ptr.Ptr GHC.Fingerprint.Type.Fingerprint
                [LclId] =
                    [ptr_s4IDi off_s4IDj] \u []
                        case ptr_s4IDi of {
                          GHC.Ptr.Ptr addr_s4IDq [Occ=Once] ->
                              case off_s4IDj of {
                                GHC.Types.I# x_s4IDs [Occ=Once] ->
                                    case *# [x_s4IDs 16#] of sat_s4IDt {
                                      __DEFAULT ->
                                          case plusAddr# [addr_s4IDq sat_s4IDt] of sat_s4IDu {
                                            __DEFAULT -> GHC.Ptr.Ptr [sat_s4IDu];
                                          };
                                    };
                              };
                        };
              } in 
                Foreign.Storable.$w$cpoke
                    sat_s4IDv ww1_s4IDn ww2_s4IDo GHC.Prim.void#;
        };

Foreign.Storable.$fStorableFingerprint [InlPrag=NOUSERINLINE CONLIKE]
  :: Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint
[GblId[DFunId], Caf=NoCafRefs, Str=m] =
    CCS_DONT_CARE Foreign.Storable.C:Storable! [Foreign.Storable.$fStorableFingerprint_$csizeOf
                                                Foreign.Storable.$fStorableFingerprint_$calignment
                                                Foreign.Storable.$fStorableFingerprint6
                                                Foreign.Storable.$fStorableFingerprint5
                                                Foreign.Storable.$fStorableFingerprint4
                                                Foreign.Storable.$fStorableFingerprint3
                                                Foreign.Storable.$fStorableFingerprint2
                                                Foreign.Storable.$fStorableFingerprint1];

Foreign.Storable.C:Storable
  :: forall a.
     (a -> GHC.Types.Int)
     -> (a -> GHC.Types.Int)
     -> (GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a)
     -> (GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ())
     -> (forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a)
     -> (forall b.
         GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ())
     -> (GHC.Ptr.Ptr a -> GHC.Types.IO a)
     -> (GHC.Ptr.Ptr a -> a -> GHC.Types.IO ())
     -> Foreign.Storable.Storable a
[GblId[DataCon],
 Arity=8,
 Caf=NoCafRefs,
 Str=<L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>m,
 Unf=OtherCon []] =
    [] \r [eta_B8 eta_B7 eta_B6 eta_B5 eta_B4 eta_B3 eta_B2 eta_B1]
        Foreign.Storable.C:Storable [eta_B8
                                     eta_B7
                                     eta_B6
                                     eta_B5
                                     eta_B4
                                     eta_B3
                                     eta_B2
                                     eta_B1];

