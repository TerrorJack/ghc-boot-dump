
==================== Output Cmm ====================
2018-03-16 16:03:56.714705215 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:56.715914167 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytes1_closure" {
     Foreign.Marshal.Alloc.allocaBytes1_closure:
         const Foreign.Marshal.Alloc.allocaBytes1_info;
 },
 Foreign.Marshal.Alloc.allocaBytes1_entry() //  [R2, R3]
         { info_tbl: [(c8N9a,
                       label: Foreign.Marshal.Alloc.allocaBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N9a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8N9b; else goto c8N9c;
       c8N9b: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.allocaBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8N9c: // global
           I64[Sp - 16] = block_c8N97_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8N9t; else goto c8N98;
       u8N9t: // global
           call _c8N97(R1) args: 0, res: 0, upd: 0;
       c8N98: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8N97() //  [R1]
         { info_tbl: [(c8N97,
                       label: block_c8N97_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N97: // global
           I64[Sp] = block_c8N9f_info;
           R1 = I64[R1 + 7];
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8N9f() //  [R1]
         { info_tbl: [(c8N9f,
                       label: block_c8N9f_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N9f: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8N9k; else goto c8N9j;
       c8N9k: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8N9j: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8N9p_info;
           R2 = Hp - 7;
           _s8N6P::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8N6P::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8N9p() //  [R1]
         { info_tbl: [(c8N9p,
                       label: block_c8N9p_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N9p: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.717516925 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytes_closure" {
     Foreign.Marshal.Alloc.allocaBytes_closure:
         const Foreign.Marshal.Alloc.allocaBytes_info;
 },
 Foreign.Marshal.Alloc.allocaBytes_entry() //  [R2, R3]
         { info_tbl: [(c8N9y,
                       label: Foreign.Marshal.Alloc.allocaBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N9y: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.allocaBytes1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.71872164 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytesAligned1_closure" {
     Foreign.Marshal.Alloc.allocaBytesAligned1_closure:
         const Foreign.Marshal.Alloc.allocaBytesAligned1_info;
 },
 Foreign.Marshal.Alloc.allocaBytesAligned1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8N9I,
                       label: Foreign.Marshal.Alloc.allocaBytesAligned1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N9I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8N9M; else goto c8N9N;
       c8N9M: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.allocaBytesAligned1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8N9N: // global
           I64[Sp - 24] = block_c8N9F_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Na8; else goto c8N9G;
       u8Na8: // global
           call _c8N9F(R1) args: 0, res: 0, upd: 0;
       c8N9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8N9F() //  [R1]
         { info_tbl: [(c8N9F,
                       label: block_c8N9F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N9F: // global
           I64[Sp] = block_c8N9L_info;
           _s8N71::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8N71::I64;
           if (R1 & 7 != 0) goto u8Na7; else goto c8N9P;
       u8Na7: // global
           call _c8N9L(R1) args: 0, res: 0, upd: 0;
       c8N9P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8N9L() //  [R1]
         { info_tbl: [(c8N9L,
                       label: block_c8N9L_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N9L: // global
           _s8N71::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8N9T_info;
           R2 = I64[R1 + 7];
           R1 = _s8N71::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8N9T() //  [R1]
         { info_tbl: [(c8N9T,
                       label: block_c8N9T_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8N9T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8N9Y; else goto c8N9X;
       c8N9Y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8N9X: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8Na3_info;
           R2 = Hp - 7;
           _s8N79::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8N79::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Na3() //  [R1]
         { info_tbl: [(c8Na3,
                       label: block_c8Na3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Na3: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.720466196 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytesAligned_closure" {
     Foreign.Marshal.Alloc.allocaBytesAligned_closure:
         const Foreign.Marshal.Alloc.allocaBytesAligned_info;
 },
 Foreign.Marshal.Alloc.allocaBytesAligned_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Nad,
                       label: Foreign.Marshal.Alloc.allocaBytesAligned_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nad: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.allocaBytesAligned1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.721280611 UTC

[section ""cstring" . lvl_r8N65_bytes" {
     lvl_r8N65_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.722008549 UTC

[section ""data" . lvl1_r8N66_closure" {
     lvl1_r8N66_closure:
         const lvl1_r8N66_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8N66_entry() //  [R1]
         { info_tbl: [(c8Nam,
                       label: lvl1_r8N66_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nam: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nan; else goto c8Nao;
       c8Nan: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nao: // global
           (_c8Naj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Naj::I64 == 0) goto c8Nal; else goto c8Nak;
       c8Nal: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nak: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Naj::I64;
           R2 = lvl_r8N65_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.722885446 UTC

[section ""cstring" . Foreign.Marshal.Alloc.$trModule4_bytes" {
     Foreign.Marshal.Alloc.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.723589595 UTC

[section ""data" . lvl2_r8N67_closure" {
     lvl2_r8N67_closure:
         const lvl2_r8N67_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8N67_entry() //  [R1]
         { info_tbl: [(c8Nav,
                       label: lvl2_r8N67_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nav: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Naw; else goto c8Nax;
       c8Naw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nax: // global
           (_c8Nas::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nas::I64 == 0) goto c8Nau; else goto c8Nat;
       c8Nau: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nat: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nas::I64;
           R2 = Foreign.Marshal.Alloc.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.724493493 UTC

[section ""cstring" . Foreign.Marshal.Alloc.$trModule2_bytes" {
     Foreign.Marshal.Alloc.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.72522113 UTC

[section ""data" . lvl3_r8N68_closure" {
     lvl3_r8N68_closure:
         const lvl3_r8N68_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8N68_entry() //  [R1]
         { info_tbl: [(c8NaE,
                       label: lvl3_r8N68_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NaE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NaF; else goto c8NaG;
       c8NaF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NaG: // global
           (_c8NaB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NaB::I64 == 0) goto c8NaD; else goto c8NaC;
       c8NaD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NaC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NaB::I64;
           R2 = Foreign.Marshal.Alloc.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.726189837 UTC

[section ""cstring" . lvl4_r8N69_bytes" {
     lvl4_r8N69_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,108,108,111,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.72693069 UTC

[section ""data" . lvl5_r8N6a_closure" {
     lvl5_r8N6a_closure:
         const lvl5_r8N6a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8N6a_entry() //  [R1]
         { info_tbl: [(c8NaN,
                       label: lvl5_r8N6a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NaN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NaO; else goto c8NaP;
       c8NaO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NaP: // global
           (_c8NaK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NaK::I64 == 0) goto c8NaM; else goto c8NaL;
       c8NaM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NaL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NaK::I64;
           R2 = lvl4_r8N69_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.727781777 UTC

[section ""data" . lvl6_r8N6b_closure" {
     lvl6_r8N6b_closure:
         const GHC.Types.I#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.728379427 UTC

[section ""data" . lvl7_r8N6c_closure" {
     lvl7_r8N6c_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.728976346 UTC

[section ""data" . lvl8_r8N6d_closure" {
     lvl8_r8N6d_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.72960917 UTC

[section ""data" . lvl9_r8N6e_closure" {
     lvl9_r8N6e_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl6_r8N6b_closure+1;
         const lvl7_r8N6c_closure+1;
         const lvl6_r8N6b_closure+1;
         const lvl8_r8N6d_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.730250518 UTC

[section ""data" . lvl10_r8N6f_closure" {
     lvl10_r8N6f_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl9_r8N6e_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.731048799 UTC

[section ""data" . lvl11_r8N6g_closure" {
     lvl11_r8N6g_closure:
         const lvl11_r8N6g_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_r8N6g_entry() //  [R1]
         { info_tbl: [(c8NaW,
                       label: lvl11_r8N6g_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NaW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NaX; else goto c8NaY;
       c8NaX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NaY: // global
           (_c8NaT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NaT::I64 == 0) goto c8NaV; else goto c8NaU;
       c8NaV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NaU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NaT::I64;
           R2 = lvl10_r8N6f_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.732069478 UTC

[section ""data" . lvl12_r8N6h_closure" {
     lvl12_r8N6h_closure:
         const GHC.Types.I#_con_info;
         const 60;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.732664872 UTC

[section ""data" . lvl13_r8N6i_closure" {
     lvl13_r8N6i_closure:
         const GHC.Types.I#_con_info;
         const 69;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.733267886 UTC

[section ""data" . lvl14_r8N6j_closure" {
     lvl14_r8N6j_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl6_r8N6b_closure+1;
         const lvl12_r8N6h_closure+1;
         const lvl6_r8N6b_closure+1;
         const lvl13_r8N6i_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.733940472 UTC

[section ""data" . lvl15_r8N6k_closure" {
     lvl15_r8N6k_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl14_r8N6j_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.734754958 UTC

[section ""data" . lvl16_r8N6l_closure" {
     lvl16_r8N6l_closure:
         const lvl16_r8N6l_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_r8N6l_entry() //  [R1]
         { info_tbl: [(c8Nb6,
                       label: lvl16_r8N6l_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nb6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nb7; else goto c8Nb8;
       c8Nb7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nb8: // global
           (_c8Nb3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nb3::I64 == 0) goto c8Nb5; else goto c8Nb4;
       c8Nb5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nb4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nb3::I64;
           R2 = lvl15_r8N6k_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.736650988 UTC

[section ""data" . Foreign.Marshal.Alloc.alloca_closure" {
     Foreign.Marshal.Alloc.alloca_closure:
         const Foreign.Marshal.Alloc.alloca_info;
         const 0;
 },
 ds_s8N7h_entry() //  [R1]
         { info_tbl: [(c8Nbh,
                       label: ds_s8N7h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nbh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Nbi; else goto c8Nbj;
       c8Nbi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nbj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl11_r8N6g_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds1_s8N7i_entry() //  [R1]
         { info_tbl: [(c8Nbo,
                       label: ds1_s8N7i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nbo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Nbp; else goto c8Nbq;
       c8Nbp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nbq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl16_r8N6l_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8N7B_entry() //  [R1, R2]
         { info_tbl: [(c8Nbz,
                       label: sat_s8N7B_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nbz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NbD; else goto c8NbE;
       c8NbD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NbE: // global
           I64[Sp - 24] = block_c8Nbw_info;
           _s8N7i::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8N7i::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8NbZ; else goto c8Nbx;
       u8NbZ: // global
           call _c8Nbw(R1) args: 0, res: 0, upd: 0;
       c8Nbx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nbw() //  [R1]
         { info_tbl: [(c8Nbw,
                       label: block_c8Nbw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nbw: // global
           I64[Sp] = block_c8NbC_info;
           _s8N7m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8N7m::I64;
           if (R1 & 7 != 0) goto u8NbY; else goto c8NbG;
       u8NbY: // global
           call _c8NbC(R1) args: 0, res: 0, upd: 0;
       c8NbG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NbC() //  [R1]
         { info_tbl: [(c8NbC,
                       label: block_c8NbC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NbC: // global
           _s8N7m::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8NbK_info;
           R2 = I64[R1 + 7];
           R1 = _s8N7m::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NbK() //  [R1]
         { info_tbl: [(c8NbK,
                       label: block_c8NbK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NbK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NbP; else goto c8NbO;
       c8NbP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NbO: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8NbU_info;
           R2 = Hp - 7;
           _s8N7u::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8N7u::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NbU() //  [R1]
         { info_tbl: [(c8NbU,
                       label: block_c8NbU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NbU: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Alloc.alloca_entry() //  [R2]
         { info_tbl: [(c8Nc0,
                       label: Foreign.Marshal.Alloc.alloca_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nc0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Nc4; else goto c8Nc3;
       c8Nc4: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.alloca_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Nc3: // global
           I64[Hp - 64] = ds_s8N7h_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ds1_s8N7i_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8N7B_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.739471018 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule3_closure" {
     Foreign.Marshal.Alloc.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Alloc.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.740085259 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule1_closure" {
     Foreign.Marshal.Alloc.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Alloc.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.740684091 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule_closure" {
     Foreign.Marshal.Alloc.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Alloc.$trModule3_closure+1;
         const Foreign.Marshal.Alloc.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.741351487 UTC

[section ""cstring" . Foreign.Marshal.Alloc.malloc4_bytes" {
     Foreign.Marshal.Alloc.malloc4_bytes:
         I8[] [109,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.742196372 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc3_closure" {
     Foreign.Marshal.Alloc.malloc3_closure:
         const Foreign.Marshal.Alloc.malloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc3_entry() //  [R1]
         { info_tbl: [(c8Ncb,
                       label: Foreign.Marshal.Alloc.malloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ncb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ncc; else goto c8Ncd;
       c8Ncc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ncd: // global
           (_c8Nc8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nc8::I64 == 0) goto c8Nca; else goto c8Nc9;
       c8Nca: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nc9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nc8::I64;
           R2 = Foreign.Marshal.Alloc.malloc4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.743163139 UTC

[section ""cstring" . Foreign.Marshal.Alloc.calloc4_bytes" {
     Foreign.Marshal.Alloc.calloc4_bytes:
         I8[] [111,117,116,32,111,102,32,109,101,109,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.743968198 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc3_closure" {
     Foreign.Marshal.Alloc.calloc3_closure:
         const Foreign.Marshal.Alloc.calloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc3_entry() //  [R1]
         { info_tbl: [(c8Nck,
                       label: Foreign.Marshal.Alloc.calloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nck: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ncl; else goto c8Ncm;
       c8Ncl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ncm: // global
           (_c8Nch::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nch::I64 == 0) goto c8Ncj; else goto c8Nci;
       c8Ncj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nci: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nch::I64;
           R2 = Foreign.Marshal.Alloc.calloc4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.746158395 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc2_closure" {
     Foreign.Marshal.Alloc.malloc2_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.malloc3_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.746965639 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc1_closure" {
     Foreign.Marshal.Alloc.malloc1_closure:
         const Foreign.Marshal.Alloc.malloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc1_entry() //  [R1]
         { info_tbl: [(c8Nct,
                       label: Foreign.Marshal.Alloc.malloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nct: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ncu; else goto c8Ncv;
       c8Ncu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ncv: // global
           (_c8Ncq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Ncq::I64 == 0) goto c8Ncs; else goto c8Ncr;
       c8Ncs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ncr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Ncq::I64;
           R2 = Foreign.Marshal.Alloc.malloc2_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.74826153 UTC

[section ""data" . Foreign.Marshal.Alloc.mallocBytes1_closure" {
     Foreign.Marshal.Alloc.mallocBytes1_closure:
         const Foreign.Marshal.Alloc.mallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.mallocBytes1_entry() //  [R2]
         { info_tbl: [(c8NcD,
                       label: Foreign.Marshal.Alloc.mallocBytes1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NcD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8NcE; else goto c8NcF;
       c8NcE: // global
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.mallocBytes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NcF: // global
           I64[Sp - 8] = block_c8NcA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8NcX; else goto c8NcB;
       u8NcX: // global
           call _c8NcA(R1) args: 0, res: 0, upd: 0;
       c8NcB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NcA() //  [R1]
         { info_tbl: [(c8NcA,
                       label: block_c8NcA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NcA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NcK; else goto c8NcJ;
       c8NcK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NcJ: // global
           (_s8N7K::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8N7K::I64 == 0) goto c8NcW; else goto c8NcV;
       c8NcW: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NcV: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N7K::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.74992899 UTC

[section ""data" . Foreign.Marshal.Alloc.mallocBytes_closure" {
     Foreign.Marshal.Alloc.mallocBytes_closure:
         const Foreign.Marshal.Alloc.mallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.mallocBytes_entry() //  [R2]
         { info_tbl: [(c8Nd2,
                       label: Foreign.Marshal.Alloc.mallocBytes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nd2: // global
           R2 = R2;
           call Foreign.Marshal.Alloc.mallocBytes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.75062838 UTC

[section ""data" . lvl17_r8N6m_closure" {
     lvl17_r8N6m_closure:
         const GHC.Types.I#_con_info;
         const 84;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.751144508 UTC

[section ""data" . lvl18_r8N6n_closure" {
     lvl18_r8N6n_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.751693384 UTC

[section ""data" . lvl19_r8N6o_closure" {
     lvl19_r8N6o_closure:
         const GHC.Types.I#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.752264182 UTC

[section ""data" . lvl20_r8N6p_closure" {
     lvl20_r8N6p_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl17_r8N6m_closure+1;
         const lvl18_r8N6n_closure+1;
         const lvl17_r8N6m_closure+1;
         const lvl19_r8N6o_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.752880093 UTC

[section ""data" . lvl21_r8N6q_closure" {
     lvl21_r8N6q_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl20_r8N6p_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.753700718 UTC

[section ""data" . lvl22_r8N6r_closure" {
     lvl22_r8N6r_closure:
         const lvl22_r8N6r_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_r8N6r_entry() //  [R1]
         { info_tbl: [(c8Ndb,
                       label: lvl22_r8N6r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ndb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ndc; else goto c8Ndd;
       c8Ndc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ndd: // global
           (_c8Nd8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nd8::I64 == 0) goto c8Nda; else goto c8Nd9;
       c8Nda: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nd9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nd8::I64;
           R2 = lvl21_r8N6q_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.754999274 UTC

[section ""data" . malloc5_r8N6s_closure" {
     malloc5_r8N6s_closure:
         const malloc5_r8N6s_info;
         const 0;
 },
 malloc5_r8N6s_entry() //  [R2]
         { info_tbl: [(c8Ndk,
                       label: malloc5_r8N6s_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ndk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ndl; else goto c8Ndm;
       c8Ndl: // global
           R2 = R2;
           R1 = malloc5_r8N6s_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Ndm: // global
           I64[Sp - 8] = block_c8Ndi_info;
           R2 = R2;
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = lvl22_r8N6r_closure;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Ndi() //  [R1]
         { info_tbl: [(c8Ndi,
                       label: block_c8Ndi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ndi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Ndr; else goto c8Ndq;
       c8Ndr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ndq: // global
           (_s8N7V::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8N7V::I64 == 0) goto c8NdD; else goto c8NdC;
       c8NdD: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NdC: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N7V::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.756288742 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc_closure" {
     Foreign.Marshal.Alloc.malloc_closure:
         const Foreign.Marshal.Alloc.malloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc_entry() //  [R2]
         { info_tbl: [(c8NdI,
                       label: Foreign.Marshal.Alloc.malloc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NdI: // global
           R2 = R2;
           call malloc5_r8N6s_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.757001285 UTC

[section ""cstring" . Foreign.Marshal.Alloc.calloc6_bytes" {
     Foreign.Marshal.Alloc.calloc6_bytes:
         I8[] [99,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.758013671 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc5_closure" {
     Foreign.Marshal.Alloc.calloc5_closure:
         const Foreign.Marshal.Alloc.calloc5_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc5_entry() //  [R1]
         { info_tbl: [(c8NdR,
                       label: Foreign.Marshal.Alloc.calloc5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NdR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NdS; else goto c8NdT;
       c8NdS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NdT: // global
           (_c8NdO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NdO::I64 == 0) goto c8NdQ; else goto c8NdP;
       c8NdQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NdP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NdO::I64;
           R2 = Foreign.Marshal.Alloc.calloc6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.758933176 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc2_closure" {
     Foreign.Marshal.Alloc.calloc2_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.calloc5_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.759725971 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc1_closure" {
     Foreign.Marshal.Alloc.calloc1_closure:
         const Foreign.Marshal.Alloc.calloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc1_entry() //  [R1]
         { info_tbl: [(c8Ne0,
                       label: Foreign.Marshal.Alloc.calloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ne0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ne1; else goto c8Ne2;
       c8Ne1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ne2: // global
           (_c8NdX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NdX::I64 == 0) goto c8NdZ; else goto c8NdY;
       c8NdZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NdY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NdX::I64;
           R2 = Foreign.Marshal.Alloc.calloc2_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.761029302 UTC

[section ""data" . Foreign.Marshal.Alloc.callocBytes1_closure" {
     Foreign.Marshal.Alloc.callocBytes1_closure:
         const Foreign.Marshal.Alloc.callocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.callocBytes1_entry() //  [R2]
         { info_tbl: [(c8Nea,
                       label: Foreign.Marshal.Alloc.callocBytes1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nea: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Neb; else goto c8Nec;
       c8Neb: // global
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.callocBytes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Nec: // global
           I64[Sp - 8] = block_c8Ne7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Nev; else goto c8Ne8;
       u8Nev: // global
           call _c8Ne7(R1) args: 0, res: 0, upd: 0;
       c8Ne8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ne7() //  [R1]
         { info_tbl: [(c8Ne7,
                       label: block_c8Ne7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ne7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Neh; else goto c8Neg;
       c8Neh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Neg: // global
           (_s8N86::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[R1 + 7]);
           if (_s8N86::I64 == 0) goto c8Neu; else goto c8Net;
       c8Neu: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Net: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N86::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.762371228 UTC

[section ""data" . Foreign.Marshal.Alloc.callocBytes_closure" {
     Foreign.Marshal.Alloc.callocBytes_closure:
         const Foreign.Marshal.Alloc.callocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.callocBytes_entry() //  [R2]
         { info_tbl: [(c8NeA,
                       label: Foreign.Marshal.Alloc.callocBytes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NeA: // global
           R2 = R2;
           call Foreign.Marshal.Alloc.callocBytes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.763076562 UTC

[section ""data" . lvl23_r8N6t_closure" {
     lvl23_r8N6t_closure:
         const GHC.Types.I#_con_info;
         const 90;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.763669547 UTC

[section ""data" . lvl24_r8N6u_closure" {
     lvl24_r8N6u_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl23_r8N6t_closure+1;
         const lvl7_r8N6c_closure+1;
         const lvl23_r8N6t_closure+1;
         const lvl8_r8N6d_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.764296477 UTC

[section ""data" . lvl25_r8N6v_closure" {
     lvl25_r8N6v_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl24_r8N6u_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.765017808 UTC

[section ""data" . lvl26_r8N6w_closure" {
     lvl26_r8N6w_closure:
         const lvl26_r8N6w_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_r8N6w_entry() //  [R1]
         { info_tbl: [(c8NeJ,
                       label: lvl26_r8N6w_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NeJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NeK; else goto c8NeL;
       c8NeK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NeL: // global
           (_c8NeG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NeG::I64 == 0) goto c8NeI; else goto c8NeH;
       c8NeI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NeH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NeG::I64;
           R2 = lvl25_r8N6v_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.766303798 UTC

[section ""data" . calloc7_r8N6x_closure" {
     calloc7_r8N6x_closure:
         const calloc7_r8N6x_info;
         const 0;
 },
 calloc7_r8N6x_entry() //  [R2]
         { info_tbl: [(c8NeS,
                       label: calloc7_r8N6x_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NeS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NeT; else goto c8NeU;
       c8NeT: // global
           R2 = R2;
           R1 = calloc7_r8N6x_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NeU: // global
           I64[Sp - 8] = block_c8NeQ_info;
           R2 = R2;
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = lvl26_r8N6w_closure;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8NeQ() //  [R1]
         { info_tbl: [(c8NeQ,
                       label: block_c8NeQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NeQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NeZ; else goto c8NeY;
       c8NeZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NeY: // global
           (_s8N8h::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[R1 + 7]);
           if (_s8N8h::I64 == 0) goto c8Nfc; else goto c8Nfb;
       c8Nfc: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Nfb: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N8h::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.767605538 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc_closure" {
     Foreign.Marshal.Alloc.calloc_closure:
         const Foreign.Marshal.Alloc.calloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc_entry() //  [R2]
         { info_tbl: [(c8Nfh,
                       label: Foreign.Marshal.Alloc.calloc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nfh: // global
           R2 = R2;
           call calloc7_r8N6x_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.768306653 UTC

[section ""cstring" . Foreign.Marshal.Alloc.realloc5_bytes" {
     Foreign.Marshal.Alloc.realloc5_bytes:
         I8[] [114,101,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.769034488 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc4_closure" {
     Foreign.Marshal.Alloc.realloc4_closure:
         const Foreign.Marshal.Alloc.realloc4_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc4_entry() //  [R1]
         { info_tbl: [(c8Nfq,
                       label: Foreign.Marshal.Alloc.realloc4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nfq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nfr; else goto c8Nfs;
       c8Nfr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nfs: // global
           (_c8Nfn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nfn::I64 == 0) goto c8Nfp; else goto c8Nfo;
       c8Nfp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nfo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nfn::I64;
           R2 = Foreign.Marshal.Alloc.realloc5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.769948184 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc3_closure" {
     Foreign.Marshal.Alloc.realloc3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.realloc4_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.770712213 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc2_closure" {
     Foreign.Marshal.Alloc.realloc2_closure:
         const Foreign.Marshal.Alloc.realloc2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc2_entry() //  [R1]
         { info_tbl: [(c8Nfz,
                       label: Foreign.Marshal.Alloc.realloc2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nfz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NfA; else goto c8NfB;
       c8NfA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NfB: // global
           (_c8Nfw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nfw::I64 == 0) goto c8Nfy; else goto c8Nfx;
       c8Nfy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nfx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nfw::I64;
           R2 = Foreign.Marshal.Alloc.realloc3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.771655443 UTC

[section ""data" . lvl27_r8N6y_closure" {
     lvl27_r8N6y_closure:
         const GHC.Types.I#_con_info;
         const 162;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.772233919 UTC

[section ""data" . lvl28_r8N6z_closure" {
     lvl28_r8N6z_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.77283058 UTC

[section ""data" . lvl29_r8N6A_closure" {
     lvl29_r8N6A_closure:
         const GHC.Types.I#_con_info;
         const 43;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.773424674 UTC

[section ""data" . lvl30_r8N6B_closure" {
     lvl30_r8N6B_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl27_r8N6y_closure+1;
         const lvl28_r8N6z_closure+1;
         const lvl27_r8N6y_closure+1;
         const lvl29_r8N6A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.774080705 UTC

[section ""data" . lvl31_r8N6C_closure" {
     lvl31_r8N6C_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl30_r8N6B_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.774858474 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc6_closure" {
     Foreign.Marshal.Alloc.realloc6_closure:
         const Foreign.Marshal.Alloc.realloc6_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc6_entry() //  [R1]
         { info_tbl: [(c8NfI,
                       label: Foreign.Marshal.Alloc.realloc6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NfI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NfJ; else goto c8NfK;
       c8NfJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NfK: // global
           (_c8NfF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NfF::I64 == 0) goto c8NfH; else goto c8NfG;
       c8NfH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NfG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NfF::I64;
           R2 = lvl31_r8N6C_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.776264656 UTC

[section ""data" . Foreign.Marshal.Alloc.$wrealloc_closure" {
     Foreign.Marshal.Alloc.$wrealloc_closure:
         const Foreign.Marshal.Alloc.$wrealloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.$wrealloc_entry() //  [R2, R3]
         { info_tbl: [(c8NfR,
                       label: Foreign.Marshal.Alloc.$wrealloc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NfR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8NfS; else goto c8NfT;
       c8NfS: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.$wrealloc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NfT: // global
           I64[Sp - 16] = block_c8NfP_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Alloc.realloc6_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8NfP() //  [R1]
         { info_tbl: [(c8NfP,
                       label: block_c8NfP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NfP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NfY; else goto c8NfX;
       c8NfY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NfX: // global
           (_s8N8t::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], I64[R1 + 7]);
           if (_s8N8t::I64 == 0) goto c8Ngb; else goto c8Nga;
       c8Ngb: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Nga: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N8t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.777734439 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc1_closure" {
     Foreign.Marshal.Alloc.realloc1_closure:
         const Foreign.Marshal.Alloc.realloc1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc1_entry() //  [R2, R3]
         { info_tbl: [(c8Ngj,
                       label: Foreign.Marshal.Alloc.realloc1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ngj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ngk; else goto c8Ngl;
       c8Ngk: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.realloc1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ngl: // global
           I64[Sp - 16] = block_c8Ngg_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Ngp; else goto c8Ngh;
       u8Ngp: // global
           call _c8Ngg(R1) args: 0, res: 0, upd: 0;
       c8Ngh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ngg() //  [R1]
         { info_tbl: [(c8Ngg,
                       label: block_c8Ngg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ngg: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Alloc.$wrealloc_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.778897275 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc_closure" {
     Foreign.Marshal.Alloc.realloc_closure:
         const Foreign.Marshal.Alloc.realloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc_entry() //  [R2, R3]
         { info_tbl: [(c8Ngu,
                       label: Foreign.Marshal.Alloc.realloc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ngu: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.realloc1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.779863128 UTC

[section ""data" . free1_r8N6D_closure" {
     free1_r8N6D_closure:
         const free1_r8N6D_info;
 },
 free1_r8N6D_entry() //  [R2]
         { info_tbl: [(c8NgE,
                       label: free1_r8N6D_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NgE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8NgF; else goto c8NgG;
       c8NgF: // global
           R2 = R2;
           R1 = free1_r8N6D_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NgG: // global
           I64[Sp - 8] = block_c8NgB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8NgM; else goto c8NgC;
       u8NgM: // global
           call _c8NgB(R1) args: 0, res: 0, upd: 0;
       c8NgC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NgB() //  [R1]
         { info_tbl: [(c8NgB,
                       label: block_c8NgB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NgB: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.781020786 UTC

[section ""data" . Foreign.Marshal.Alloc.free_closure" {
     Foreign.Marshal.Alloc.free_closure:
         const Foreign.Marshal.Alloc.free_info;
 },
 Foreign.Marshal.Alloc.free_entry() //  [R2]
         { info_tbl: [(c8NgR,
                       label: Foreign.Marshal.Alloc.free_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NgR: // global
           R2 = R2;
           call free1_r8N6D_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.78266495 UTC

[section ""data" . Foreign.Marshal.Alloc.$wreallocBytes_closure" {
     Foreign.Marshal.Alloc.$wreallocBytes_closure:
         const Foreign.Marshal.Alloc.$wreallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.$wreallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c8Nh2,
                       label: Foreign.Marshal.Alloc.$wreallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nh2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Nh6; else goto c8Nh5;
       c8Nh6: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.$wreallocBytes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Nh5: // global
           if (R3 == 0) goto c8Nh1; else goto c8Nh0;
       c8Nh1: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(R2);
           Hp = Hp - 16;
           R1 = GHC.Ptr.nullPtr_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Nh0: // global
           _c8Nhd::I64 = R3;
           (_s8N8Q::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(R2, _c8Nhd::I64);
           if (_s8N8Q::I64 == 0) goto c8Nhk; else goto c8Nhj;
       c8Nhk: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Nhj: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N8Q::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.784026329 UTC

[section ""data" . Foreign.Marshal.Alloc.reallocBytes1_closure" {
     Foreign.Marshal.Alloc.reallocBytes1_closure:
         const Foreign.Marshal.Alloc.reallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.reallocBytes1_entry() //  [R2, R3]
         { info_tbl: [(c8Nhv,
                       label: Foreign.Marshal.Alloc.reallocBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nhv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nhz; else goto c8NhA;
       c8Nhz: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.reallocBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NhA: // global
           I64[Sp - 16] = block_c8Nhs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8NhI; else goto c8Nht;
       u8NhI: // global
           call _c8Nhs(R1) args: 0, res: 0, upd: 0;
       c8Nht: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nhs() //  [R1]
         { info_tbl: [(c8Nhs,
                       label: block_c8Nhs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nhs: // global
           I64[Sp] = block_c8Nhy_info;
           _s8N90::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8N90::I64;
           if (R1 & 7 != 0) goto u8NhH; else goto c8NhC;
       u8NhH: // global
           call _c8Nhy(R1) args: 0, res: 0, upd: 0;
       c8NhC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nhy() //  [R1]
         { info_tbl: [(c8Nhy,
                       label: block_c8Nhy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nhy: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Alloc.$wreallocBytes_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.785474108 UTC

[section ""data" . Foreign.Marshal.Alloc.reallocBytes_closure" {
     Foreign.Marshal.Alloc.reallocBytes_closure:
         const Foreign.Marshal.Alloc.reallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.reallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c8NhN,
                       label: Foreign.Marshal.Alloc.reallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NhN: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.reallocBytes1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.787418263 UTC

[section ""data" . Foreign.Marshal.Alloc.finalizerFree_closure" {
     Foreign.Marshal.Alloc.finalizerFree_closure:
         const GHC.Ptr.FunPtr_con_info;
         const free;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.788022747 UTC

[section ""relreadonly" . S8NaZ_srt" {
     S8NaZ_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r8N6f_closure;
         const lvl15_r8N6k_closure;
         const lvl11_r8N6g_closure;
         const lvl16_r8N6l_closure;
         const Foreign.Marshal.Alloc.alloca_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const Foreign.Marshal.Alloc.malloc2_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.mallocBytes1_closure;
         const lvl21_r8N6q_closure;
         const lvl22_r8N6r_closure;
         const malloc5_r8N6s_closure;
         const Foreign.Marshal.Alloc.calloc2_closure;
         const Foreign.Marshal.Alloc.calloc1_closure;
         const Foreign.Marshal.Alloc.callocBytes1_closure;
         const lvl25_r8N6v_closure;
         const lvl26_r8N6w_closure;
         const calloc7_r8N6x_closure;
         const Foreign.Marshal.Alloc.realloc3_closure;
         const lvl31_r8N6C_closure;
         const Foreign.Marshal.Alloc.$wrealloc_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Alloc.realloc6_closure;
         const Foreign.Marshal.Alloc.realloc1_closure;
         const Foreign.Marshal.Alloc.$wreallocBytes_closure;
         const Foreign.Marshal.Alloc.reallocBytes1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.78871298 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:56.789717112 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytes1_closure" {
     Foreign.Marshal.Alloc.allocaBytes1_closure:
         const Foreign.Marshal.Alloc.allocaBytes1_info;
 },
 Foreign.Marshal.Alloc.allocaBytes1_entry() //  [R2, R3]
         { info_tbl: [(c8NhX,
                       label: Foreign.Marshal.Alloc.allocaBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NhX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NhY; else goto c8NhZ;
       c8NhY: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.allocaBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NhZ: // global
           I64[Sp - 16] = block_c8NhU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Nig; else goto c8NhV;
       u8Nig: // global
           call _c8NhU(R1) args: 0, res: 0, upd: 0;
       c8NhV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NhU() //  [R1]
         { info_tbl: [(c8NhU,
                       label: block_c8NhU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NhU: // global
           I64[Sp] = block_c8Ni2_info;
           R1 = I64[R1 + 7];
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ni2() //  [R1]
         { info_tbl: [(c8Ni2,
                       label: block_c8Ni2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ni2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Ni7; else goto c8Ni6;
       c8Ni7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ni6: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8Nic_info;
           R2 = Hp - 7;
           _s8N6P::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8N6P::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nic() //  [R1]
         { info_tbl: [(c8Nic,
                       label: block_c8Nic_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nic: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.791209459 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytes_closure" {
     Foreign.Marshal.Alloc.allocaBytes_closure:
         const Foreign.Marshal.Alloc.allocaBytes_info;
 },
 Foreign.Marshal.Alloc.allocaBytes_entry() //  [R2, R3]
         { info_tbl: [(c8Nil,
                       label: Foreign.Marshal.Alloc.allocaBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nil: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.allocaBytes1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.792414894 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytesAligned1_closure" {
     Foreign.Marshal.Alloc.allocaBytesAligned1_closure:
         const Foreign.Marshal.Alloc.allocaBytesAligned1_info;
 },
 Foreign.Marshal.Alloc.allocaBytesAligned1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Niv,
                       label: Foreign.Marshal.Alloc.allocaBytesAligned1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Niv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Niz; else goto c8NiA;
       c8Niz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.allocaBytesAligned1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NiA: // global
           I64[Sp - 24] = block_c8Nis_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8NiV; else goto c8Nit;
       u8NiV: // global
           call _c8Nis(R1) args: 0, res: 0, upd: 0;
       c8Nit: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nis() //  [R1]
         { info_tbl: [(c8Nis,
                       label: block_c8Nis_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nis: // global
           I64[Sp] = block_c8Niy_info;
           _s8N71::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8N71::I64;
           if (R1 & 7 != 0) goto u8NiU; else goto c8NiC;
       u8NiU: // global
           call _c8Niy(R1) args: 0, res: 0, upd: 0;
       c8NiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Niy() //  [R1]
         { info_tbl: [(c8Niy,
                       label: block_c8Niy_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Niy: // global
           _s8N71::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8NiG_info;
           R2 = I64[R1 + 7];
           R1 = _s8N71::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NiG() //  [R1]
         { info_tbl: [(c8NiG,
                       label: block_c8NiG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NiG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NiL; else goto c8NiK;
       c8NiL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NiK: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8NiQ_info;
           R2 = Hp - 7;
           _s8N79::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8N79::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NiQ() //  [R1]
         { info_tbl: [(c8NiQ,
                       label: block_c8NiQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NiQ: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.794499916 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytesAligned_closure" {
     Foreign.Marshal.Alloc.allocaBytesAligned_closure:
         const Foreign.Marshal.Alloc.allocaBytesAligned_info;
 },
 Foreign.Marshal.Alloc.allocaBytesAligned_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Nj0,
                       label: Foreign.Marshal.Alloc.allocaBytesAligned_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nj0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.allocaBytesAligned1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.795224357 UTC

[section ""cstring" . lvl_r8N65_bytes" {
     lvl_r8N65_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.795959823 UTC

[section ""data" . lvl1_r8N66_closure" {
     lvl1_r8N66_closure:
         const lvl1_r8N66_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8N66_entry() //  [R1]
         { info_tbl: [(c8Nj9,
                       label: lvl1_r8N66_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nj9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nja; else goto c8Njb;
       c8Nja: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Njb: // global
           (_c8Nj6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nj6::I64 == 0) goto c8Nj8; else goto c8Nj7;
       c8Nj8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nj7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nj6::I64;
           R2 = lvl_r8N65_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.796862351 UTC

[section ""cstring" . Foreign.Marshal.Alloc.$trModule4_bytes" {
     Foreign.Marshal.Alloc.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.797632188 UTC

[section ""data" . lvl2_r8N67_closure" {
     lvl2_r8N67_closure:
         const lvl2_r8N67_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8N67_entry() //  [R1]
         { info_tbl: [(c8Nji,
                       label: lvl2_r8N67_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nji: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Njj; else goto c8Njk;
       c8Njj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Njk: // global
           (_c8Njf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Njf::I64 == 0) goto c8Njh; else goto c8Njg;
       c8Njh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Njg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Njf::I64;
           R2 = Foreign.Marshal.Alloc.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.798491673 UTC

[section ""cstring" . Foreign.Marshal.Alloc.$trModule2_bytes" {
     Foreign.Marshal.Alloc.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.799269022 UTC

[section ""data" . lvl3_r8N68_closure" {
     lvl3_r8N68_closure:
         const lvl3_r8N68_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8N68_entry() //  [R1]
         { info_tbl: [(c8Njr,
                       label: lvl3_r8N68_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Njr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Njs; else goto c8Njt;
       c8Njs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Njt: // global
           (_c8Njo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Njo::I64 == 0) goto c8Njq; else goto c8Njp;
       c8Njq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Njp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Njo::I64;
           R2 = Foreign.Marshal.Alloc.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.800133274 UTC

[section ""cstring" . lvl4_r8N69_bytes" {
     lvl4_r8N69_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,108,108,111,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.800826515 UTC

[section ""data" . lvl5_r8N6a_closure" {
     lvl5_r8N6a_closure:
         const lvl5_r8N6a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8N6a_entry() //  [R1]
         { info_tbl: [(c8NjA,
                       label: lvl5_r8N6a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NjA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NjB; else goto c8NjC;
       c8NjB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NjC: // global
           (_c8Njx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Njx::I64 == 0) goto c8Njz; else goto c8Njy;
       c8Njz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Njy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Njx::I64;
           R2 = lvl4_r8N69_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.801725295 UTC

[section ""data" . lvl6_r8N6b_closure" {
     lvl6_r8N6b_closure:
         const GHC.Types.I#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.80227406 UTC

[section ""data" . lvl7_r8N6c_closure" {
     lvl7_r8N6c_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.802823137 UTC

[section ""data" . lvl8_r8N6d_closure" {
     lvl8_r8N6d_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.803361383 UTC

[section ""data" . lvl9_r8N6e_closure" {
     lvl9_r8N6e_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl6_r8N6b_closure+1;
         const lvl7_r8N6c_closure+1;
         const lvl6_r8N6b_closure+1;
         const lvl8_r8N6d_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.803975559 UTC

[section ""data" . lvl10_r8N6f_closure" {
     lvl10_r8N6f_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl9_r8N6e_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.804764253 UTC

[section ""data" . lvl11_r8N6g_closure" {
     lvl11_r8N6g_closure:
         const lvl11_r8N6g_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_r8N6g_entry() //  [R1]
         { info_tbl: [(c8NjJ,
                       label: lvl11_r8N6g_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NjJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NjK; else goto c8NjL;
       c8NjK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NjL: // global
           (_c8NjG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NjG::I64 == 0) goto c8NjI; else goto c8NjH;
       c8NjI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NjH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NjG::I64;
           R2 = lvl10_r8N6f_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.805737803 UTC

[section ""data" . lvl12_r8N6h_closure" {
     lvl12_r8N6h_closure:
         const GHC.Types.I#_con_info;
         const 60;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.806362187 UTC

[section ""data" . lvl13_r8N6i_closure" {
     lvl13_r8N6i_closure:
         const GHC.Types.I#_con_info;
         const 69;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.806937363 UTC

[section ""data" . lvl14_r8N6j_closure" {
     lvl14_r8N6j_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl6_r8N6b_closure+1;
         const lvl12_r8N6h_closure+1;
         const lvl6_r8N6b_closure+1;
         const lvl13_r8N6i_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.807559626 UTC

[section ""data" . lvl15_r8N6k_closure" {
     lvl15_r8N6k_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl14_r8N6j_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.808354798 UTC

[section ""data" . lvl16_r8N6l_closure" {
     lvl16_r8N6l_closure:
         const lvl16_r8N6l_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_r8N6l_entry() //  [R1]
         { info_tbl: [(c8NjS,
                       label: lvl16_r8N6l_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NjS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NjT; else goto c8NjU;
       c8NjT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NjU: // global
           (_c8NjP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NjP::I64 == 0) goto c8NjR; else goto c8NjQ;
       c8NjR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NjQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NjP::I64;
           R2 = lvl15_r8N6k_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.810445075 UTC

[section ""data" . Foreign.Marshal.Alloc.alloca_closure" {
     Foreign.Marshal.Alloc.alloca_closure:
         const Foreign.Marshal.Alloc.alloca_info;
         const 0;
 },
 ds_s8N7h_entry() //  [R1]
         { info_tbl: [(c8Nk3,
                       label: ds_s8N7h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nk3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Nk4; else goto c8Nk5;
       c8Nk4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nk5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl11_r8N6g_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds1_s8N7i_entry() //  [R1]
         { info_tbl: [(c8Nka,
                       label: ds1_s8N7i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nka: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Nkb; else goto c8Nkc;
       c8Nkb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nkc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl16_r8N6l_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8N7B_entry() //  [R1, R2]
         { info_tbl: [(c8Nkl,
                       label: sat_s8N7B_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nkl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Nkp; else goto c8Nkq;
       c8Nkp: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Nkq: // global
           I64[Sp - 24] = block_c8Nki_info;
           _s8N7i::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8N7i::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8NkL; else goto c8Nkj;
       u8NkL: // global
           call _c8Nki(R1) args: 0, res: 0, upd: 0;
       c8Nkj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nki() //  [R1]
         { info_tbl: [(c8Nki,
                       label: block_c8Nki_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nki: // global
           I64[Sp] = block_c8Nko_info;
           _s8N7m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8N7m::I64;
           if (R1 & 7 != 0) goto u8NkK; else goto c8Nks;
       u8NkK: // global
           call _c8Nko(R1) args: 0, res: 0, upd: 0;
       c8Nks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nko() //  [R1]
         { info_tbl: [(c8Nko,
                       label: block_c8Nko_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nko: // global
           _s8N7m::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8Nkw_info;
           R2 = I64[R1 + 7];
           R1 = _s8N7m::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nkw() //  [R1]
         { info_tbl: [(c8Nkw,
                       label: block_c8Nkw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nkw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NkB; else goto c8NkA;
       c8NkB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NkA: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8NkG_info;
           R2 = Hp - 7;
           _s8N7u::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8N7u::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NkG() //  [R1]
         { info_tbl: [(c8NkG,
                       label: block_c8NkG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NkG: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Alloc.alloca_entry() //  [R2]
         { info_tbl: [(c8NkM,
                       label: Foreign.Marshal.Alloc.alloca_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NkM: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8NkQ; else goto c8NkP;
       c8NkQ: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.alloca_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NkP: // global
           I64[Hp - 64] = ds_s8N7h_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ds1_s8N7i_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8N7B_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.812841654 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule3_closure" {
     Foreign.Marshal.Alloc.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Alloc.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.813470483 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule1_closure" {
     Foreign.Marshal.Alloc.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Alloc.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.814057109 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule_closure" {
     Foreign.Marshal.Alloc.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Alloc.$trModule3_closure+1;
         const Foreign.Marshal.Alloc.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.814667651 UTC

[section ""cstring" . Foreign.Marshal.Alloc.malloc4_bytes" {
     Foreign.Marshal.Alloc.malloc4_bytes:
         I8[] [109,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.815469627 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc3_closure" {
     Foreign.Marshal.Alloc.malloc3_closure:
         const Foreign.Marshal.Alloc.malloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc3_entry() //  [R1]
         { info_tbl: [(c8NkX,
                       label: Foreign.Marshal.Alloc.malloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NkX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NkY; else goto c8NkZ;
       c8NkY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NkZ: // global
           (_c8NkU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NkU::I64 == 0) goto c8NkW; else goto c8NkV;
       c8NkW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NkV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NkU::I64;
           R2 = Foreign.Marshal.Alloc.malloc4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.816402631 UTC

[section ""cstring" . Foreign.Marshal.Alloc.calloc4_bytes" {
     Foreign.Marshal.Alloc.calloc4_bytes:
         I8[] [111,117,116,32,111,102,32,109,101,109,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.817134869 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc3_closure" {
     Foreign.Marshal.Alloc.calloc3_closure:
         const Foreign.Marshal.Alloc.calloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc3_entry() //  [R1]
         { info_tbl: [(c8Nl6,
                       label: Foreign.Marshal.Alloc.calloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nl6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nl7; else goto c8Nl8;
       c8Nl7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nl8: // global
           (_c8Nl3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nl3::I64 == 0) goto c8Nl5; else goto c8Nl4;
       c8Nl5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nl4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nl3::I64;
           R2 = Foreign.Marshal.Alloc.calloc4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.818099138 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc2_closure" {
     Foreign.Marshal.Alloc.malloc2_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.malloc3_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.818879611 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc1_closure" {
     Foreign.Marshal.Alloc.malloc1_closure:
         const Foreign.Marshal.Alloc.malloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc1_entry() //  [R1]
         { info_tbl: [(c8Nlf,
                       label: Foreign.Marshal.Alloc.malloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nlf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nlg; else goto c8Nlh;
       c8Nlg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nlh: // global
           (_c8Nlc::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nlc::I64 == 0) goto c8Nle; else goto c8Nld;
       c8Nle: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nld: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nlc::I64;
           R2 = Foreign.Marshal.Alloc.malloc2_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.820266694 UTC

[section ""data" . Foreign.Marshal.Alloc.mallocBytes1_closure" {
     Foreign.Marshal.Alloc.mallocBytes1_closure:
         const Foreign.Marshal.Alloc.mallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.mallocBytes1_entry() //  [R2]
         { info_tbl: [(c8Nlp,
                       label: Foreign.Marshal.Alloc.mallocBytes1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nlp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Nlq; else goto c8Nlr;
       c8Nlq: // global
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.mallocBytes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Nlr: // global
           I64[Sp - 8] = block_c8Nlm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8NlJ; else goto c8Nln;
       u8NlJ: // global
           call _c8Nlm(R1) args: 0, res: 0, upd: 0;
       c8Nln: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nlm() //  [R1]
         { info_tbl: [(c8Nlm,
                       label: block_c8Nlm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nlm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Nlw; else goto c8Nlv;
       c8Nlw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Nlv: // global
           (_s8N7K::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8N7K::I64 == 0) goto c8NlI; else goto c8NlH;
       c8NlI: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NlH: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N7K::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.822107424 UTC

[section ""data" . Foreign.Marshal.Alloc.mallocBytes_closure" {
     Foreign.Marshal.Alloc.mallocBytes_closure:
         const Foreign.Marshal.Alloc.mallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.mallocBytes_entry() //  [R2]
         { info_tbl: [(c8NlO,
                       label: Foreign.Marshal.Alloc.mallocBytes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NlO: // global
           R2 = R2;
           call Foreign.Marshal.Alloc.mallocBytes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.822836902 UTC

[section ""data" . lvl17_r8N6m_closure" {
     lvl17_r8N6m_closure:
         const GHC.Types.I#_con_info;
         const 84;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.823444041 UTC

[section ""data" . lvl18_r8N6n_closure" {
     lvl18_r8N6n_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.824059407 UTC

[section ""data" . lvl19_r8N6o_closure" {
     lvl19_r8N6o_closure:
         const GHC.Types.I#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.824661136 UTC

[section ""data" . lvl20_r8N6p_closure" {
     lvl20_r8N6p_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl17_r8N6m_closure+1;
         const lvl18_r8N6n_closure+1;
         const lvl17_r8N6m_closure+1;
         const lvl19_r8N6o_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.825341893 UTC

[section ""data" . lvl21_r8N6q_closure" {
     lvl21_r8N6q_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl20_r8N6p_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.827301329 UTC

[section ""data" . lvl22_r8N6r_closure" {
     lvl22_r8N6r_closure:
         const lvl22_r8N6r_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_r8N6r_entry() //  [R1]
         { info_tbl: [(c8NlX,
                       label: lvl22_r8N6r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NlX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NlY; else goto c8NlZ;
       c8NlY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NlZ: // global
           (_c8NlU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NlU::I64 == 0) goto c8NlW; else goto c8NlV;
       c8NlW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NlV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NlU::I64;
           R2 = lvl21_r8N6q_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.828667926 UTC

[section ""data" . malloc5_r8N6s_closure" {
     malloc5_r8N6s_closure:
         const malloc5_r8N6s_info;
         const 0;
 },
 malloc5_r8N6s_entry() //  [R2]
         { info_tbl: [(c8Nm6,
                       label: malloc5_r8N6s_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nm6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Nm7; else goto c8Nm8;
       c8Nm7: // global
           R2 = R2;
           R1 = malloc5_r8N6s_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Nm8: // global
           I64[Sp - 8] = block_c8Nm4_info;
           R2 = R2;
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = lvl22_r8N6r_closure;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Nm4() //  [R1]
         { info_tbl: [(c8Nm4,
                       label: block_c8Nm4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nm4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Nmd; else goto c8Nmc;
       c8Nmd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Nmc: // global
           (_s8N7V::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8N7V::I64 == 0) goto c8Nmp; else goto c8Nmo;
       c8Nmp: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Nmo: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N7V::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.829930307 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc_closure" {
     Foreign.Marshal.Alloc.malloc_closure:
         const Foreign.Marshal.Alloc.malloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc_entry() //  [R2]
         { info_tbl: [(c8Nmu,
                       label: Foreign.Marshal.Alloc.malloc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nmu: // global
           R2 = R2;
           call malloc5_r8N6s_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.830631133 UTC

[section ""cstring" . Foreign.Marshal.Alloc.calloc6_bytes" {
     Foreign.Marshal.Alloc.calloc6_bytes:
         I8[] [99,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.831355215 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc5_closure" {
     Foreign.Marshal.Alloc.calloc5_closure:
         const Foreign.Marshal.Alloc.calloc5_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc5_entry() //  [R1]
         { info_tbl: [(c8NmD,
                       label: Foreign.Marshal.Alloc.calloc5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NmD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NmE; else goto c8NmF;
       c8NmE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NmF: // global
           (_c8NmA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NmA::I64 == 0) goto c8NmC; else goto c8NmB;
       c8NmC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NmB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NmA::I64;
           R2 = Foreign.Marshal.Alloc.calloc6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.832262223 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc2_closure" {
     Foreign.Marshal.Alloc.calloc2_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.calloc5_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.833022375 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc1_closure" {
     Foreign.Marshal.Alloc.calloc1_closure:
         const Foreign.Marshal.Alloc.calloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc1_entry() //  [R1]
         { info_tbl: [(c8NmM,
                       label: Foreign.Marshal.Alloc.calloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NmM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NmN; else goto c8NmO;
       c8NmN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NmO: // global
           (_c8NmJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NmJ::I64 == 0) goto c8NmL; else goto c8NmK;
       c8NmL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NmK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NmJ::I64;
           R2 = Foreign.Marshal.Alloc.calloc2_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.834574237 UTC

[section ""data" . Foreign.Marshal.Alloc.callocBytes1_closure" {
     Foreign.Marshal.Alloc.callocBytes1_closure:
         const Foreign.Marshal.Alloc.callocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.callocBytes1_entry() //  [R2]
         { info_tbl: [(c8NmW,
                       label: Foreign.Marshal.Alloc.callocBytes1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NmW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8NmX; else goto c8NmY;
       c8NmX: // global
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.callocBytes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NmY: // global
           I64[Sp - 8] = block_c8NmT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Nnh; else goto c8NmU;
       u8Nnh: // global
           call _c8NmT(R1) args: 0, res: 0, upd: 0;
       c8NmU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NmT() //  [R1]
         { info_tbl: [(c8NmT,
                       label: block_c8NmT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NmT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Nn3; else goto c8Nn2;
       c8Nn3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Nn2: // global
           (_s8N86::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[R1 + 7]);
           if (_s8N86::I64 == 0) goto c8Nng; else goto c8Nnf;
       c8Nng: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Nnf: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N86::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.835889898 UTC

[section ""data" . Foreign.Marshal.Alloc.callocBytes_closure" {
     Foreign.Marshal.Alloc.callocBytes_closure:
         const Foreign.Marshal.Alloc.callocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.callocBytes_entry() //  [R2]
         { info_tbl: [(c8Nnm,
                       label: Foreign.Marshal.Alloc.callocBytes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nnm: // global
           R2 = R2;
           call Foreign.Marshal.Alloc.callocBytes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.836631428 UTC

[section ""data" . lvl23_r8N6t_closure" {
     lvl23_r8N6t_closure:
         const GHC.Types.I#_con_info;
         const 90;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.837185361 UTC

[section ""data" . lvl24_r8N6u_closure" {
     lvl24_r8N6u_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl23_r8N6t_closure+1;
         const lvl7_r8N6c_closure+1;
         const lvl23_r8N6t_closure+1;
         const lvl8_r8N6d_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.83784826 UTC

[section ""data" . lvl25_r8N6v_closure" {
     lvl25_r8N6v_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl24_r8N6u_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.838548212 UTC

[section ""data" . lvl26_r8N6w_closure" {
     lvl26_r8N6w_closure:
         const lvl26_r8N6w_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_r8N6w_entry() //  [R1]
         { info_tbl: [(c8Nnv,
                       label: lvl26_r8N6w_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nnv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nnw; else goto c8Nnx;
       c8Nnw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nnx: // global
           (_c8Nns::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nns::I64 == 0) goto c8Nnu; else goto c8Nnt;
       c8Nnu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nnt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nns::I64;
           R2 = lvl25_r8N6v_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.839756994 UTC

[section ""data" . calloc7_r8N6x_closure" {
     calloc7_r8N6x_closure:
         const calloc7_r8N6x_info;
         const 0;
 },
 calloc7_r8N6x_entry() //  [R2]
         { info_tbl: [(c8NnE,
                       label: calloc7_r8N6x_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NnE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NnF; else goto c8NnG;
       c8NnF: // global
           R2 = R2;
           R1 = calloc7_r8N6x_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NnG: // global
           I64[Sp - 8] = block_c8NnC_info;
           R2 = R2;
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = lvl26_r8N6w_closure;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8NnC() //  [R1]
         { info_tbl: [(c8NnC,
                       label: block_c8NnC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NnC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NnL; else goto c8NnK;
       c8NnL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NnK: // global
           (_s8N8h::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[R1 + 7]);
           if (_s8N8h::I64 == 0) goto c8NnY; else goto c8NnX;
       c8NnY: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NnX: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N8h::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.841035787 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc_closure" {
     Foreign.Marshal.Alloc.calloc_closure:
         const Foreign.Marshal.Alloc.calloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc_entry() //  [R2]
         { info_tbl: [(c8No3,
                       label: Foreign.Marshal.Alloc.calloc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8No3: // global
           R2 = R2;
           call calloc7_r8N6x_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.841783199 UTC

[section ""cstring" . Foreign.Marshal.Alloc.realloc5_bytes" {
     Foreign.Marshal.Alloc.realloc5_bytes:
         I8[] [114,101,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.842504739 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc4_closure" {
     Foreign.Marshal.Alloc.realloc4_closure:
         const Foreign.Marshal.Alloc.realloc4_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc4_entry() //  [R1]
         { info_tbl: [(c8Noc,
                       label: Foreign.Marshal.Alloc.realloc4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Noc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nod; else goto c8Noe;
       c8Nod: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Noe: // global
           (_c8No9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8No9::I64 == 0) goto c8Nob; else goto c8Noa;
       c8Nob: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Noa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8No9::I64;
           R2 = Foreign.Marshal.Alloc.realloc5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.843347404 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc3_closure" {
     Foreign.Marshal.Alloc.realloc3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.realloc4_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.844099925 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc2_closure" {
     Foreign.Marshal.Alloc.realloc2_closure:
         const Foreign.Marshal.Alloc.realloc2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc2_entry() //  [R1]
         { info_tbl: [(c8Nol,
                       label: Foreign.Marshal.Alloc.realloc2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nol: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nom; else goto c8Non;
       c8Nom: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Non: // global
           (_c8Noi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Noi::I64 == 0) goto c8Nok; else goto c8Noj;
       c8Nok: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Noj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Noi::I64;
           R2 = Foreign.Marshal.Alloc.realloc3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.844961963 UTC

[section ""data" . lvl27_r8N6y_closure" {
     lvl27_r8N6y_closure:
         const GHC.Types.I#_con_info;
         const 162;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.845817338 UTC

[section ""data" . lvl28_r8N6z_closure" {
     lvl28_r8N6z_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.846426696 UTC

[section ""data" . lvl29_r8N6A_closure" {
     lvl29_r8N6A_closure:
         const GHC.Types.I#_con_info;
         const 43;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.847015458 UTC

[section ""data" . lvl30_r8N6B_closure" {
     lvl30_r8N6B_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl27_r8N6y_closure+1;
         const lvl28_r8N6z_closure+1;
         const lvl27_r8N6y_closure+1;
         const lvl29_r8N6A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.847665374 UTC

[section ""data" . lvl31_r8N6C_closure" {
     lvl31_r8N6C_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl30_r8N6B_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.848648777 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc6_closure" {
     Foreign.Marshal.Alloc.realloc6_closure:
         const Foreign.Marshal.Alloc.realloc6_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc6_entry() //  [R1]
         { info_tbl: [(c8Nou,
                       label: Foreign.Marshal.Alloc.realloc6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nou: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nov; else goto c8Now;
       c8Nov: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Now: // global
           (_c8Nor::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nor::I64 == 0) goto c8Not; else goto c8Nos;
       c8Not: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nos: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nor::I64;
           R2 = lvl31_r8N6C_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.850268153 UTC

[section ""data" . Foreign.Marshal.Alloc.$wrealloc_closure" {
     Foreign.Marshal.Alloc.$wrealloc_closure:
         const Foreign.Marshal.Alloc.$wrealloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.$wrealloc_entry() //  [R2, R3]
         { info_tbl: [(c8NoD,
                       label: Foreign.Marshal.Alloc.$wrealloc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NoD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8NoE; else goto c8NoF;
       c8NoE: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.$wrealloc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NoF: // global
           I64[Sp - 16] = block_c8NoB_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Alloc.realloc6_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8NoB() //  [R1]
         { info_tbl: [(c8NoB,
                       label: block_c8NoB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NoB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NoK; else goto c8NoJ;
       c8NoK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NoJ: // global
           (_s8N8t::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], I64[R1 + 7]);
           if (_s8N8t::I64 == 0) goto c8NoX; else goto c8NoW;
       c8NoX: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NoW: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N8t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.851849511 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc1_closure" {
     Foreign.Marshal.Alloc.realloc1_closure:
         const Foreign.Marshal.Alloc.realloc1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc1_entry() //  [R2, R3]
         { info_tbl: [(c8Np5,
                       label: Foreign.Marshal.Alloc.realloc1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Np5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Np6; else goto c8Np7;
       c8Np6: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.realloc1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Np7: // global
           I64[Sp - 16] = block_c8Np2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Npb; else goto c8Np3;
       u8Npb: // global
           call _c8Np2(R1) args: 0, res: 0, upd: 0;
       c8Np3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Np2() //  [R1]
         { info_tbl: [(c8Np2,
                       label: block_c8Np2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Np2: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Alloc.$wrealloc_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.853102217 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc_closure" {
     Foreign.Marshal.Alloc.realloc_closure:
         const Foreign.Marshal.Alloc.realloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc_entry() //  [R2, R3]
         { info_tbl: [(c8Npg,
                       label: Foreign.Marshal.Alloc.realloc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Npg: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.realloc1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.854180814 UTC

[section ""data" . free1_r8N6D_closure" {
     free1_r8N6D_closure:
         const free1_r8N6D_info;
 },
 free1_r8N6D_entry() //  [R2]
         { info_tbl: [(c8Npq,
                       label: free1_r8N6D_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Npq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Npr; else goto c8Nps;
       c8Npr: // global
           R2 = R2;
           R1 = free1_r8N6D_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Nps: // global
           I64[Sp - 8] = block_c8Npn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Npy; else goto c8Npo;
       u8Npy: // global
           call _c8Npn(R1) args: 0, res: 0, upd: 0;
       c8Npo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Npn() //  [R1]
         { info_tbl: [(c8Npn,
                       label: block_c8Npn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Npn: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.855322533 UTC

[section ""data" . Foreign.Marshal.Alloc.free_closure" {
     Foreign.Marshal.Alloc.free_closure:
         const Foreign.Marshal.Alloc.free_info;
 },
 Foreign.Marshal.Alloc.free_entry() //  [R2]
         { info_tbl: [(c8NpD,
                       label: Foreign.Marshal.Alloc.free_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NpD: // global
           R2 = R2;
           call free1_r8N6D_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.856462072 UTC

[section ""data" . Foreign.Marshal.Alloc.$wreallocBytes_closure" {
     Foreign.Marshal.Alloc.$wreallocBytes_closure:
         const Foreign.Marshal.Alloc.$wreallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.$wreallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c8NpO,
                       label: Foreign.Marshal.Alloc.$wreallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NpO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NpS; else goto c8NpR;
       c8NpS: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.$wreallocBytes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NpR: // global
           if (R3 == 0) goto c8NpN; else goto c8NpM;
       c8NpN: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(R2);
           Hp = Hp - 16;
           R1 = GHC.Ptr.nullPtr_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8NpM: // global
           _c8NpZ::I64 = R3;
           (_s8N8Q::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(R2, _c8NpZ::I64);
           if (_s8N8Q::I64 == 0) goto c8Nq6; else goto c8Nq5;
       c8Nq6: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Nq5: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N8Q::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.857915441 UTC

[section ""data" . Foreign.Marshal.Alloc.reallocBytes1_closure" {
     Foreign.Marshal.Alloc.reallocBytes1_closure:
         const Foreign.Marshal.Alloc.reallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.reallocBytes1_entry() //  [R2, R3]
         { info_tbl: [(c8Nqh,
                       label: Foreign.Marshal.Alloc.reallocBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nqh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nql; else goto c8Nqm;
       c8Nql: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.reallocBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Nqm: // global
           I64[Sp - 16] = block_c8Nqe_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Nqu; else goto c8Nqf;
       u8Nqu: // global
           call _c8Nqe(R1) args: 0, res: 0, upd: 0;
       c8Nqf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nqe() //  [R1]
         { info_tbl: [(c8Nqe,
                       label: block_c8Nqe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nqe: // global
           I64[Sp] = block_c8Nqk_info;
           _s8N90::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8N90::I64;
           if (R1 & 7 != 0) goto u8Nqt; else goto c8Nqo;
       u8Nqt: // global
           call _c8Nqk(R1) args: 0, res: 0, upd: 0;
       c8Nqo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nqk() //  [R1]
         { info_tbl: [(c8Nqk,
                       label: block_c8Nqk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nqk: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Alloc.$wreallocBytes_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.859367951 UTC

[section ""data" . Foreign.Marshal.Alloc.reallocBytes_closure" {
     Foreign.Marshal.Alloc.reallocBytes_closure:
         const Foreign.Marshal.Alloc.reallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.reallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c8Nqz,
                       label: Foreign.Marshal.Alloc.reallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nqz: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.reallocBytes1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.860169933 UTC

[section ""data" . Foreign.Marshal.Alloc.finalizerFree_closure" {
     Foreign.Marshal.Alloc.finalizerFree_closure:
         const GHC.Ptr.FunPtr_con_info;
         const free;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.860796025 UTC

[section ""relreadonly" . S8NaZ_srt" {
     S8NaZ_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r8N6f_closure;
         const lvl15_r8N6k_closure;
         const lvl11_r8N6g_closure;
         const lvl16_r8N6l_closure;
         const Foreign.Marshal.Alloc.alloca_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const Foreign.Marshal.Alloc.malloc2_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.mallocBytes1_closure;
         const lvl21_r8N6q_closure;
         const lvl22_r8N6r_closure;
         const malloc5_r8N6s_closure;
         const Foreign.Marshal.Alloc.calloc2_closure;
         const Foreign.Marshal.Alloc.calloc1_closure;
         const Foreign.Marshal.Alloc.callocBytes1_closure;
         const lvl25_r8N6v_closure;
         const lvl26_r8N6w_closure;
         const calloc7_r8N6x_closure;
         const Foreign.Marshal.Alloc.realloc3_closure;
         const lvl31_r8N6C_closure;
         const Foreign.Marshal.Alloc.$wrealloc_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Alloc.realloc6_closure;
         const Foreign.Marshal.Alloc.realloc1_closure;
         const Foreign.Marshal.Alloc.$wreallocBytes_closure;
         const Foreign.Marshal.Alloc.reallocBytes1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.861853804 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:56.863524146 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytes1_closure" {
     Foreign.Marshal.Alloc.allocaBytes1_closure:
         const Foreign.Marshal.Alloc.allocaBytes1_info;
 },
 Foreign.Marshal.Alloc.allocaBytes1_entry() //  [R2, R3]
         { info_tbl: [(c8NqJ,
                       label: Foreign.Marshal.Alloc.allocaBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NqJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NqK; else goto c8NqL;
       c8NqK: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.allocaBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NqL: // global
           I64[Sp - 16] = block_c8NqG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Nr2; else goto c8NqH;
       u8Nr2: // global
           call _c8NqG(R1) args: 0, res: 0, upd: 0;
       c8NqH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NqG() //  [R1]
         { info_tbl: [(c8NqG,
                       label: block_c8NqG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NqG: // global
           I64[Sp] = block_c8NqO_info;
           R1 = I64[R1 + 7];
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NqO() //  [R1]
         { info_tbl: [(c8NqO,
                       label: block_c8NqO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NqO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NqT; else goto c8NqS;
       c8NqT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NqS: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8NqY_info;
           R2 = Hp - 7;
           _s8N6P::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8N6P::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NqY() //  [R1]
         { info_tbl: [(c8NqY,
                       label: block_c8NqY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NqY: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.875050077 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytes_closure" {
     Foreign.Marshal.Alloc.allocaBytes_closure:
         const Foreign.Marshal.Alloc.allocaBytes_info;
 },
 Foreign.Marshal.Alloc.allocaBytes_entry() //  [R2, R3]
         { info_tbl: [(c8Nro,
                       label: Foreign.Marshal.Alloc.allocaBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nro: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.allocaBytes1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.879123668 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytesAligned1_closure" {
     Foreign.Marshal.Alloc.allocaBytesAligned1_closure:
         const Foreign.Marshal.Alloc.allocaBytesAligned1_info;
 },
 Foreign.Marshal.Alloc.allocaBytesAligned1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8NrC,
                       label: Foreign.Marshal.Alloc.allocaBytesAligned1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NrC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NrG; else goto c8NrH;
       c8NrG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.allocaBytesAligned1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NrH: // global
           I64[Sp - 24] = block_c8Nrz_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Ns2; else goto c8NrA;
       u8Ns2: // global
           call _c8Nrz(R1) args: 0, res: 0, upd: 0;
       c8NrA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nrz() //  [R1]
         { info_tbl: [(c8Nrz,
                       label: block_c8Nrz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nrz: // global
           I64[Sp] = block_c8NrF_info;
           _s8N71::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8N71::I64;
           if (R1 & 7 != 0) goto u8Ns1; else goto c8NrJ;
       u8Ns1: // global
           call _c8NrF(R1) args: 0, res: 0, upd: 0;
       c8NrJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NrF() //  [R1]
         { info_tbl: [(c8NrF,
                       label: block_c8NrF_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NrF: // global
           _s8N71::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8NrN_info;
           R2 = I64[R1 + 7];
           R1 = _s8N71::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NrN() //  [R1]
         { info_tbl: [(c8NrN,
                       label: block_c8NrN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NrN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NrS; else goto c8NrR;
       c8NrS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NrR: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8NrX_info;
           R2 = Hp - 7;
           _s8N79::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8N79::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NrX() //  [R1]
         { info_tbl: [(c8NrX,
                       label: block_c8NrX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NrX: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.890737321 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytesAligned_closure" {
     Foreign.Marshal.Alloc.allocaBytesAligned_closure:
         const Foreign.Marshal.Alloc.allocaBytesAligned_info;
 },
 Foreign.Marshal.Alloc.allocaBytesAligned_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Nss,
                       label: Foreign.Marshal.Alloc.allocaBytesAligned_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nss: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.allocaBytesAligned1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.894493713 UTC

[section ""cstring" . lvl_r8N65_bytes" {
     lvl_r8N65_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.896568256 UTC

[section ""data" . lvl1_r8N66_closure" {
     lvl1_r8N66_closure:
         const lvl1_r8N66_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8N66_entry() //  [R1]
         { info_tbl: [(c8NsG,
                       label: lvl1_r8N66_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NsG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NsH; else goto c8NsI;
       c8NsH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NsI: // global
           (_c8NsD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NsD::I64 == 0) goto c8NsF; else goto c8NsE;
       c8NsF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NsE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NsD::I64;
           R2 = lvl_r8N65_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.900742165 UTC

[section ""cstring" . Foreign.Marshal.Alloc.$trModule4_bytes" {
     Foreign.Marshal.Alloc.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.902731156 UTC

[section ""data" . lvl2_r8N67_closure" {
     lvl2_r8N67_closure:
         const lvl2_r8N67_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8N67_entry() //  [R1]
         { info_tbl: [(c8NsX,
                       label: lvl2_r8N67_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NsX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NsY; else goto c8NsZ;
       c8NsY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NsZ: // global
           (_c8NsU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NsU::I64 == 0) goto c8NsW; else goto c8NsV;
       c8NsW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NsV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NsU::I64;
           R2 = Foreign.Marshal.Alloc.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.908140876 UTC

[section ""cstring" . Foreign.Marshal.Alloc.$trModule2_bytes" {
     Foreign.Marshal.Alloc.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.910102756 UTC

[section ""data" . lvl3_r8N68_closure" {
     lvl3_r8N68_closure:
         const lvl3_r8N68_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8N68_entry() //  [R1]
         { info_tbl: [(c8Nte,
                       label: lvl3_r8N68_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nte: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ntf; else goto c8Ntg;
       c8Ntf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ntg: // global
           (_c8Ntb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Ntb::I64 == 0) goto c8Ntd; else goto c8Ntc;
       c8Ntd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ntc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Ntb::I64;
           R2 = Foreign.Marshal.Alloc.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.914233197 UTC

[section ""cstring" . lvl4_r8N69_bytes" {
     lvl4_r8N69_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,108,108,111,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.91622517 UTC

[section ""data" . lvl5_r8N6a_closure" {
     lvl5_r8N6a_closure:
         const lvl5_r8N6a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8N6a_entry() //  [R1]
         { info_tbl: [(c8Ntv,
                       label: lvl5_r8N6a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ntv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ntw; else goto c8Ntx;
       c8Ntw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ntx: // global
           (_c8Nts::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nts::I64 == 0) goto c8Ntu; else goto c8Ntt;
       c8Ntu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ntt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nts::I64;
           R2 = lvl4_r8N69_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.920595315 UTC

[section ""data" . lvl6_r8N6b_closure" {
     lvl6_r8N6b_closure:
         const GHC.Types.I#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.922375463 UTC

[section ""data" . lvl7_r8N6c_closure" {
     lvl7_r8N6c_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.924169488 UTC

[section ""data" . lvl8_r8N6d_closure" {
     lvl8_r8N6d_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.925955393 UTC

[section ""data" . lvl9_r8N6e_closure" {
     lvl9_r8N6e_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl6_r8N6b_closure+1;
         const lvl7_r8N6c_closure+1;
         const lvl6_r8N6b_closure+1;
         const lvl8_r8N6d_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.928208624 UTC

[section ""data" . lvl10_r8N6f_closure" {
     lvl10_r8N6f_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl9_r8N6e_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.930339153 UTC

[section ""data" . lvl11_r8N6g_closure" {
     lvl11_r8N6g_closure:
         const lvl11_r8N6g_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_r8N6g_entry() //  [R1]
         { info_tbl: [(c8NtQ,
                       label: lvl11_r8N6g_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NtQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NtR; else goto c8NtS;
       c8NtR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NtS: // global
           (_c8NtN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NtN::I64 == 0) goto c8NtP; else goto c8NtO;
       c8NtP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NtO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NtN::I64;
           R2 = lvl10_r8N6f_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.934459055 UTC

[section ""data" . lvl12_r8N6h_closure" {
     lvl12_r8N6h_closure:
         const GHC.Types.I#_con_info;
         const 60;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.936216593 UTC

[section ""data" . lvl13_r8N6i_closure" {
     lvl13_r8N6i_closure:
         const GHC.Types.I#_con_info;
         const 69;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.938532983 UTC

[section ""data" . lvl14_r8N6j_closure" {
     lvl14_r8N6j_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl6_r8N6b_closure+1;
         const lvl12_r8N6h_closure+1;
         const lvl6_r8N6b_closure+1;
         const lvl13_r8N6i_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.940388302 UTC

[section ""data" . lvl15_r8N6k_closure" {
     lvl15_r8N6k_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl14_r8N6j_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.94240618 UTC

[section ""data" . lvl16_r8N6l_closure" {
     lvl16_r8N6l_closure:
         const lvl16_r8N6l_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_r8N6l_entry() //  [R1]
         { info_tbl: [(c8Nua,
                       label: lvl16_r8N6l_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nua: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nub; else goto c8Nuc;
       c8Nub: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nuc: // global
           (_c8Nu7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nu7::I64 == 0) goto c8Nu9; else goto c8Nu8;
       c8Nu9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nu8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nu7::I64;
           R2 = lvl15_r8N6k_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.947332083 UTC

[section ""data" . Foreign.Marshal.Alloc.alloca_closure" {
     Foreign.Marshal.Alloc.alloca_closure:
         const Foreign.Marshal.Alloc.alloca_info;
         const 0;
 },
 ds_s8N7h_entry() //  [R1]
         { info_tbl: [(c8Nus,
                       label: ds_s8N7h_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nus: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Nut; else goto c8Nuu;
       c8Nut: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nuu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl11_r8N6g_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds1_s8N7i_entry() //  [R1]
         { info_tbl: [(c8Nuz,
                       label: ds1_s8N7i_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nuz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8NuA; else goto c8NuB;
       c8NuA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NuB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl16_r8N6l_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8N7B_entry() //  [R1, R2]
         { info_tbl: [(c8NuK,
                       label: sat_s8N7B_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NuK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NuO; else goto c8NuP;
       c8NuO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NuP: // global
           I64[Sp - 24] = block_c8NuH_info;
           _s8N7i::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8N7i::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Nva; else goto c8NuI;
       u8Nva: // global
           call _c8NuH(R1) args: 0, res: 0, upd: 0;
       c8NuI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NuH() //  [R1]
         { info_tbl: [(c8NuH,
                       label: block_c8NuH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NuH: // global
           I64[Sp] = block_c8NuN_info;
           _s8N7m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8N7m::I64;
           if (R1 & 7 != 0) goto u8Nv9; else goto c8NuR;
       u8Nv9: // global
           call _c8NuN(R1) args: 0, res: 0, upd: 0;
       c8NuR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NuN() //  [R1]
         { info_tbl: [(c8NuN,
                       label: block_c8NuN_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NuN: // global
           _s8N7m::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8NuV_info;
           R2 = I64[R1 + 7];
           R1 = _s8N7m::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NuV() //  [R1]
         { info_tbl: [(c8NuV,
                       label: block_c8NuV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NuV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Nv0; else goto c8NuZ;
       c8Nv0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NuZ: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8Nv5_info;
           R2 = Hp - 7;
           _s8N7u::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8N7u::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nv5() //  [R1]
         { info_tbl: [(c8Nv5,
                       label: block_c8Nv5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nv5: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Alloc.alloca_entry() //  [R2]
         { info_tbl: [(c8Nvb,
                       label: Foreign.Marshal.Alloc.alloca_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nvb: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Nvf; else goto c8Nve;
       c8Nvf: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.alloca_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Nve: // global
           I64[Hp - 64] = ds_s8N7h_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ds1_s8N7i_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8N7B_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.963865308 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule3_closure" {
     Foreign.Marshal.Alloc.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Alloc.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.965583803 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule1_closure" {
     Foreign.Marshal.Alloc.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Alloc.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.96730253 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule_closure" {
     Foreign.Marshal.Alloc.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Alloc.$trModule3_closure+1;
         const Foreign.Marshal.Alloc.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.96907989 UTC

[section ""cstring" . Foreign.Marshal.Alloc.malloc4_bytes" {
     Foreign.Marshal.Alloc.malloc4_bytes:
         I8[] [109,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.971915614 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc3_closure" {
     Foreign.Marshal.Alloc.malloc3_closure:
         const Foreign.Marshal.Alloc.malloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc3_entry() //  [R1]
         { info_tbl: [(c8NvZ,
                       label: Foreign.Marshal.Alloc.malloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NvZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nw0; else goto c8Nw1;
       c8Nw0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nw1: // global
           (_c8NvW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NvW::I64 == 0) goto c8NvY; else goto c8NvX;
       c8NvY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NvX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NvW::I64;
           R2 = Foreign.Marshal.Alloc.malloc4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.976497483 UTC

[section ""cstring" . Foreign.Marshal.Alloc.calloc4_bytes" {
     Foreign.Marshal.Alloc.calloc4_bytes:
         I8[] [111,117,116,32,111,102,32,109,101,109,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.978654195 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc3_closure" {
     Foreign.Marshal.Alloc.calloc3_closure:
         const Foreign.Marshal.Alloc.calloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc3_entry() //  [R1]
         { info_tbl: [(c8Nwg,
                       label: Foreign.Marshal.Alloc.calloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nwg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nwh; else goto c8Nwi;
       c8Nwh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nwi: // global
           (_c8Nwd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nwd::I64 == 0) goto c8Nwf; else goto c8Nwe;
       c8Nwf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nwe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nwd::I64;
           R2 = Foreign.Marshal.Alloc.calloc4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.982916908 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc2_closure" {
     Foreign.Marshal.Alloc.malloc2_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.malloc3_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.985087449 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc1_closure" {
     Foreign.Marshal.Alloc.malloc1_closure:
         const Foreign.Marshal.Alloc.malloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc1_entry() //  [R1]
         { info_tbl: [(c8Nwx,
                       label: Foreign.Marshal.Alloc.malloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nwx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Nwy; else goto c8Nwz;
       c8Nwy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Nwz: // global
           (_c8Nwu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Nwu::I64 == 0) goto c8Nww; else goto c8Nwv;
       c8Nww: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Nwv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Nwu::I64;
           R2 = Foreign.Marshal.Alloc.malloc2_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.989624603 UTC

[section ""data" . Foreign.Marshal.Alloc.mallocBytes1_closure" {
     Foreign.Marshal.Alloc.mallocBytes1_closure:
         const Foreign.Marshal.Alloc.mallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.mallocBytes1_entry() //  [R2]
         { info_tbl: [(c8NwO,
                       label: Foreign.Marshal.Alloc.mallocBytes1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NwO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8NwP; else goto c8NwQ;
       c8NwP: // global
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.mallocBytes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NwQ: // global
           I64[Sp - 8] = block_c8NwL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Nx8; else goto c8NwM;
       u8Nx8: // global
           call _c8NwL(R1) args: 0, res: 0, upd: 0;
       c8NwM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NwL() //  [R1]
         { info_tbl: [(c8NwL,
                       label: block_c8NwL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NwL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NwV; else goto c8NwU;
       c8NwV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NwU: // global
           (_s8N7K::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8N7K::I64 == 0) goto c8Nx7; else goto c8Nx6;
       c8Nx7: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Nx6: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N7K::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.99562189 UTC

[section ""data" . Foreign.Marshal.Alloc.mallocBytes_closure" {
     Foreign.Marshal.Alloc.mallocBytes_closure:
         const Foreign.Marshal.Alloc.mallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.mallocBytes_entry() //  [R2]
         { info_tbl: [(c8Nxn,
                       label: Foreign.Marshal.Alloc.mallocBytes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nxn: // global
           R2 = R2;
           call Foreign.Marshal.Alloc.mallocBytes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.998760757 UTC

[section ""data" . lvl17_r8N6m_closure" {
     lvl17_r8N6m_closure:
         const GHC.Types.I#_con_info;
         const 84;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.000352827 UTC

[section ""data" . lvl18_r8N6n_closure" {
     lvl18_r8N6n_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.001992434 UTC

[section ""data" . lvl19_r8N6o_closure" {
     lvl19_r8N6o_closure:
         const GHC.Types.I#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.004183928 UTC

[section ""data" . lvl20_r8N6p_closure" {
     lvl20_r8N6p_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl17_r8N6m_closure+1;
         const lvl18_r8N6n_closure+1;
         const lvl17_r8N6m_closure+1;
         const lvl19_r8N6o_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.006556672 UTC

[section ""data" . lvl21_r8N6q_closure" {
     lvl21_r8N6q_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl20_r8N6p_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.00865336 UTC

[section ""data" . lvl22_r8N6r_closure" {
     lvl22_r8N6r_closure:
         const lvl22_r8N6r_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_r8N6r_entry() //  [R1]
         { info_tbl: [(c8NxF,
                       label: lvl22_r8N6r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NxF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NxG; else goto c8NxH;
       c8NxG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NxH: // global
           (_c8NxC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NxC::I64 == 0) goto c8NxE; else goto c8NxD;
       c8NxE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NxD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NxC::I64;
           R2 = lvl21_r8N6q_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.013394259 UTC

[section ""data" . malloc5_r8N6s_closure" {
     malloc5_r8N6s_closure:
         const malloc5_r8N6s_info;
         const 0;
 },
 malloc5_r8N6s_entry() //  [R2]
         { info_tbl: [(c8NxV,
                       label: malloc5_r8N6s_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NxV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NxW; else goto c8NxX;
       c8NxW: // global
           R2 = R2;
           R1 = malloc5_r8N6s_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NxX: // global
           I64[Sp - 8] = block_c8NxT_info;
           R2 = R2;
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = lvl22_r8N6r_closure;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8NxT() //  [R1]
         { info_tbl: [(c8NxT,
                       label: block_c8NxT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NxT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Ny2; else goto c8Ny1;
       c8Ny2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ny1: // global
           (_s8N7V::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8N7V::I64 == 0) goto c8Nye; else goto c8Nyd;
       c8Nye: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Nyd: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N7V::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.019752436 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc_closure" {
     Foreign.Marshal.Alloc.malloc_closure:
         const Foreign.Marshal.Alloc.malloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc_entry() //  [R2]
         { info_tbl: [(c8Nys,
                       label: Foreign.Marshal.Alloc.malloc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nys: // global
           R2 = R2;
           call malloc5_r8N6s_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.023161813 UTC

[section ""cstring" . Foreign.Marshal.Alloc.calloc6_bytes" {
     Foreign.Marshal.Alloc.calloc6_bytes:
         I8[] [99,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.025319874 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc5_closure" {
     Foreign.Marshal.Alloc.calloc5_closure:
         const Foreign.Marshal.Alloc.calloc5_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc5_entry() //  [R1]
         { info_tbl: [(c8NyG,
                       label: Foreign.Marshal.Alloc.calloc5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NyG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NyH; else goto c8NyI;
       c8NyH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NyI: // global
           (_c8NyD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NyD::I64 == 0) goto c8NyF; else goto c8NyE;
       c8NyF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NyE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NyD::I64;
           R2 = Foreign.Marshal.Alloc.calloc6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.029563076 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc2_closure" {
     Foreign.Marshal.Alloc.calloc2_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.calloc5_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.031723614 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc1_closure" {
     Foreign.Marshal.Alloc.calloc1_closure:
         const Foreign.Marshal.Alloc.calloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc1_entry() //  [R1]
         { info_tbl: [(c8NyX,
                       label: Foreign.Marshal.Alloc.calloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NyX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NyY; else goto c8NyZ;
       c8NyY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NyZ: // global
           (_c8NyU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NyU::I64 == 0) goto c8NyW; else goto c8NyV;
       c8NyW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NyV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NyU::I64;
           R2 = Foreign.Marshal.Alloc.calloc2_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.036014024 UTC

[section ""data" . Foreign.Marshal.Alloc.callocBytes1_closure" {
     Foreign.Marshal.Alloc.callocBytes1_closure:
         const Foreign.Marshal.Alloc.callocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.callocBytes1_entry() //  [R2]
         { info_tbl: [(c8Nze,
                       label: Foreign.Marshal.Alloc.callocBytes1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nze: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Nzf; else goto c8Nzg;
       c8Nzf: // global
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.callocBytes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Nzg: // global
           I64[Sp - 8] = block_c8Nzb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Nzz; else goto c8Nzc;
       u8Nzz: // global
           call _c8Nzb(R1) args: 0, res: 0, upd: 0;
       c8Nzc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Nzb() //  [R1]
         { info_tbl: [(c8Nzb,
                       label: block_c8Nzb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Nzb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Nzl; else goto c8Nzk;
       c8Nzl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Nzk: // global
           (_s8N86::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[R1 + 7]);
           if (_s8N86::I64 == 0) goto c8Nzy; else goto c8Nzx;
       c8Nzy: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Nzx: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N86::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.042692594 UTC

[section ""data" . Foreign.Marshal.Alloc.callocBytes_closure" {
     Foreign.Marshal.Alloc.callocBytes_closure:
         const Foreign.Marshal.Alloc.callocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.callocBytes_entry() //  [R2]
         { info_tbl: [(c8NzO,
                       label: Foreign.Marshal.Alloc.callocBytes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NzO: // global
           R2 = R2;
           call Foreign.Marshal.Alloc.callocBytes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.046806623 UTC

[section ""data" . lvl23_r8N6t_closure" {
     lvl23_r8N6t_closure:
         const GHC.Types.I#_con_info;
         const 90;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.048607458 UTC

[section ""data" . lvl24_r8N6u_closure" {
     lvl24_r8N6u_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl23_r8N6t_closure+1;
         const lvl7_r8N6c_closure+1;
         const lvl23_r8N6t_closure+1;
         const lvl8_r8N6d_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.050569604 UTC

[section ""data" . lvl25_r8N6v_closure" {
     lvl25_r8N6v_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl24_r8N6u_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.052725904 UTC

[section ""data" . lvl26_r8N6w_closure" {
     lvl26_r8N6w_closure:
         const lvl26_r8N6w_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_r8N6w_entry() //  [R1]
         { info_tbl: [(c8NA4,
                       label: lvl26_r8N6w_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NA4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NA5; else goto c8NA6;
       c8NA5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NA6: // global
           (_c8NA1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NA1::I64 == 0) goto c8NA3; else goto c8NA2;
       c8NA3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NA2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NA1::I64;
           R2 = lvl25_r8N6v_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.057371934 UTC

[section ""data" . calloc7_r8N6x_closure" {
     calloc7_r8N6x_closure:
         const calloc7_r8N6x_info;
         const 0;
 },
 calloc7_r8N6x_entry() //  [R2]
         { info_tbl: [(c8NAk,
                       label: calloc7_r8N6x_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NAk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NAl; else goto c8NAm;
       c8NAl: // global
           R2 = R2;
           R1 = calloc7_r8N6x_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NAm: // global
           I64[Sp - 8] = block_c8NAi_info;
           R2 = R2;
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = lvl26_r8N6w_closure;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8NAi() //  [R1]
         { info_tbl: [(c8NAi,
                       label: block_c8NAi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NAi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NAr; else goto c8NAq;
       c8NAr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NAq: // global
           (_s8N8h::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[R1 + 7]);
           if (_s8N8h::I64 == 0) goto c8NAE; else goto c8NAD;
       c8NAE: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NAD: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N8h::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.063833623 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc_closure" {
     Foreign.Marshal.Alloc.calloc_closure:
         const Foreign.Marshal.Alloc.calloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc_entry() //  [R2]
         { info_tbl: [(c8NAS,
                       label: Foreign.Marshal.Alloc.calloc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NAS: // global
           R2 = R2;
           call calloc7_r8N6x_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.067351555 UTC

[section ""cstring" . Foreign.Marshal.Alloc.realloc5_bytes" {
     Foreign.Marshal.Alloc.realloc5_bytes:
         I8[] [114,101,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.069407589 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc4_closure" {
     Foreign.Marshal.Alloc.realloc4_closure:
         const Foreign.Marshal.Alloc.realloc4_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc4_entry() //  [R1]
         { info_tbl: [(c8NB6,
                       label: Foreign.Marshal.Alloc.realloc4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NB6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NB7; else goto c8NB8;
       c8NB7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NB8: // global
           (_c8NB3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NB3::I64 == 0) goto c8NB5; else goto c8NB4;
       c8NB5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NB4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NB3::I64;
           R2 = Foreign.Marshal.Alloc.realloc5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.073746445 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc3_closure" {
     Foreign.Marshal.Alloc.realloc3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.realloc4_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.075800598 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc2_closure" {
     Foreign.Marshal.Alloc.realloc2_closure:
         const Foreign.Marshal.Alloc.realloc2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc2_entry() //  [R1]
         { info_tbl: [(c8NBn,
                       label: Foreign.Marshal.Alloc.realloc2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NBn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NBo; else goto c8NBp;
       c8NBo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NBp: // global
           (_c8NBk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NBk::I64 == 0) goto c8NBm; else goto c8NBl;
       c8NBm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NBl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NBk::I64;
           R2 = Foreign.Marshal.Alloc.realloc3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.080026038 UTC

[section ""data" . lvl27_r8N6y_closure" {
     lvl27_r8N6y_closure:
         const GHC.Types.I#_con_info;
         const 162;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.081793302 UTC

[section ""data" . lvl28_r8N6z_closure" {
     lvl28_r8N6z_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.083610851 UTC

[section ""data" . lvl29_r8N6A_closure" {
     lvl29_r8N6A_closure:
         const GHC.Types.I#_con_info;
         const 43;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.085501041 UTC

[section ""data" . lvl30_r8N6B_closure" {
     lvl30_r8N6B_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl27_r8N6y_closure+1;
         const lvl28_r8N6z_closure+1;
         const lvl27_r8N6y_closure+1;
         const lvl29_r8N6A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.08746112 UTC

[section ""data" . lvl31_r8N6C_closure" {
     lvl31_r8N6C_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl30_r8N6B_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.089620948 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc6_closure" {
     Foreign.Marshal.Alloc.realloc6_closure:
         const Foreign.Marshal.Alloc.realloc6_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc6_entry() //  [R1]
         { info_tbl: [(c8NBI,
                       label: Foreign.Marshal.Alloc.realloc6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NBI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NBJ; else goto c8NBK;
       c8NBJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NBK: // global
           (_c8NBF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NBF::I64 == 0) goto c8NBH; else goto c8NBG;
       c8NBH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NBG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NBF::I64;
           R2 = lvl31_r8N6C_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.094517703 UTC

[section ""data" . Foreign.Marshal.Alloc.$wrealloc_closure" {
     Foreign.Marshal.Alloc.$wrealloc_closure:
         const Foreign.Marshal.Alloc.$wrealloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.$wrealloc_entry() //  [R2, R3]
         { info_tbl: [(c8NBY,
                       label: Foreign.Marshal.Alloc.$wrealloc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NBY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8NBZ; else goto c8NC0;
       c8NBZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.$wrealloc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NC0: // global
           I64[Sp - 16] = block_c8NBW_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Alloc.realloc6_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8NBW() //  [R1]
         { info_tbl: [(c8NBW,
                       label: block_c8NBW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NBW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NC5; else goto c8NC4;
       c8NC5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NC4: // global
           (_s8N8t::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], I64[R1 + 7]);
           if (_s8N8t::I64 == 0) goto c8NCi; else goto c8NCh;
       c8NCi: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NCh: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N8t::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.100555419 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc1_closure" {
     Foreign.Marshal.Alloc.realloc1_closure:
         const Foreign.Marshal.Alloc.realloc1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc1_entry() //  [R2, R3]
         { info_tbl: [(c8NCz,
                       label: Foreign.Marshal.Alloc.realloc1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NCz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NCA; else goto c8NCB;
       c8NCA: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.realloc1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NCB: // global
           I64[Sp - 16] = block_c8NCw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8NCF; else goto c8NCx;
       u8NCF: // global
           call _c8NCw(R1) args: 0, res: 0, upd: 0;
       c8NCx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NCw() //  [R1]
         { info_tbl: [(c8NCw,
                       label: block_c8NCw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NCw: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Alloc.$wrealloc_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.10593501 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc_closure" {
     Foreign.Marshal.Alloc.realloc_closure:
         const Foreign.Marshal.Alloc.realloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc_entry() //  [R2, R3]
         { info_tbl: [(c8NCT,
                       label: Foreign.Marshal.Alloc.realloc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NCT: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.realloc1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.10983409 UTC

[section ""data" . free1_r8N6D_closure" {
     free1_r8N6D_closure:
         const free1_r8N6D_info;
 },
 free1_r8N6D_entry() //  [R2]
         { info_tbl: [(c8ND7,
                       label: free1_r8N6D_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ND7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ND8; else goto c8ND9;
       c8ND8: // global
           R2 = R2;
           R1 = free1_r8N6D_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ND9: // global
           I64[Sp - 8] = block_c8ND4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8NDf; else goto c8ND5;
       u8NDf: // global
           call _c8ND4(R1) args: 0, res: 0, upd: 0;
       c8ND5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ND4() //  [R1]
         { info_tbl: [(c8ND4,
                       label: block_c8ND4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ND4: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.115070998 UTC

[section ""data" . Foreign.Marshal.Alloc.free_closure" {
     Foreign.Marshal.Alloc.free_closure:
         const Foreign.Marshal.Alloc.free_info;
 },
 Foreign.Marshal.Alloc.free_entry() //  [R2]
         { info_tbl: [(c8NDu,
                       label: Foreign.Marshal.Alloc.free_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NDu: // global
           R2 = R2;
           call free1_r8N6D_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.118566115 UTC

[section ""data" . Foreign.Marshal.Alloc.$wreallocBytes_closure" {
     Foreign.Marshal.Alloc.$wreallocBytes_closure:
         const Foreign.Marshal.Alloc.$wreallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.$wreallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c8NDJ,
                       label: Foreign.Marshal.Alloc.$wreallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NDJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NDN; else goto c8NDM;
       c8NDN: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.$wreallocBytes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NDM: // global
           if (R3 == 0) goto c8NDI; else goto c8NDH;
       c8NDI: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(R2);
           Hp = Hp - 16;
           R1 = GHC.Ptr.nullPtr_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8NDH: // global
           _c8NDU::I64 = R3;
           (_s8N8Q::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(R2, _c8NDU::I64);
           if (_s8N8Q::I64 == 0) goto c8NE1; else goto c8NE0;
       c8NE1: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NE0: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8N8Q::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.123511536 UTC

[section ""data" . Foreign.Marshal.Alloc.reallocBytes1_closure" {
     Foreign.Marshal.Alloc.reallocBytes1_closure:
         const Foreign.Marshal.Alloc.reallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.reallocBytes1_entry() //  [R2, R3]
         { info_tbl: [(c8NEj,
                       label: Foreign.Marshal.Alloc.reallocBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NEj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NEn; else goto c8NEo;
       c8NEn: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.reallocBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NEo: // global
           I64[Sp - 16] = block_c8NEg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8NEw; else goto c8NEh;
       u8NEw: // global
           call _c8NEg(R1) args: 0, res: 0, upd: 0;
       c8NEh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NEg() //  [R1]
         { info_tbl: [(c8NEg,
                       label: block_c8NEg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NEg: // global
           I64[Sp] = block_c8NEm_info;
           _s8N90::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8N90::I64;
           if (R1 & 7 != 0) goto u8NEv; else goto c8NEq;
       u8NEv: // global
           call _c8NEm(R1) args: 0, res: 0, upd: 0;
       c8NEq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NEm() //  [R1]
         { info_tbl: [(c8NEm,
                       label: block_c8NEm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NEm: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Alloc.$wreallocBytes_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.130494043 UTC

[section ""data" . Foreign.Marshal.Alloc.reallocBytes_closure" {
     Foreign.Marshal.Alloc.reallocBytes_closure:
         const Foreign.Marshal.Alloc.reallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.reallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c8NEO,
                       label: Foreign.Marshal.Alloc.reallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NEO: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.reallocBytes1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.134333951 UTC

[section ""data" . Foreign.Marshal.Alloc.finalizerFree_closure" {
     Foreign.Marshal.Alloc.finalizerFree_closure:
         const GHC.Ptr.FunPtr_con_info;
         const free;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.136032522 UTC

[section ""relreadonly" . S8NaZ_srt" {
     S8NaZ_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r8N6f_closure;
         const lvl15_r8N6k_closure;
         const lvl11_r8N6g_closure;
         const lvl16_r8N6l_closure;
         const Foreign.Marshal.Alloc.alloca_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const Foreign.Marshal.Alloc.malloc2_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.mallocBytes1_closure;
         const lvl21_r8N6q_closure;
         const lvl22_r8N6r_closure;
         const malloc5_r8N6s_closure;
         const Foreign.Marshal.Alloc.calloc2_closure;
         const Foreign.Marshal.Alloc.calloc1_closure;
         const Foreign.Marshal.Alloc.callocBytes1_closure;
         const lvl25_r8N6v_closure;
         const lvl26_r8N6w_closure;
         const calloc7_r8N6x_closure;
         const Foreign.Marshal.Alloc.realloc3_closure;
         const lvl31_r8N6C_closure;
         const Foreign.Marshal.Alloc.$wrealloc_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Alloc.realloc6_closure;
         const Foreign.Marshal.Alloc.realloc1_closure;
         const Foreign.Marshal.Alloc.$wreallocBytes_closure;
         const Foreign.Marshal.Alloc.reallocBytes1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.575514884 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:57.577532832 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytes1_closure" {
     Foreign.Marshal.Alloc.allocaBytes1_closure:
         const Foreign.Marshal.Alloc.allocaBytes1_info;
 },
 Foreign.Marshal.Alloc.allocaBytes1_entry() //  [R2, R3]
         { info_tbl: [(c8NHs,
                       label: Foreign.Marshal.Alloc.allocaBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NHs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NHt; else goto c8NHu;
       c8NHt: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.allocaBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NHu: // global
           I64[Sp - 16] = block_c8NHp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8NHL; else goto c8NHq;
       u8NHL: // global
           call _c8NHp(R1) args: 0, res: 0, upd: 0;
       c8NHq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NHp() //  [R1]
         { info_tbl: [(c8NHp,
                       label: block_c8NHp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NHp: // global
           I64[Sp] = block_c8NHx_info;
           R1 = I64[R1 + 7];
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NHx() //  [R1]
         { info_tbl: [(c8NHx,
                       label: block_c8NHx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NHx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NHC; else goto c8NHB;
       c8NHC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NHB: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8NHH_info;
           R2 = Hp - 7;
           _s8NF7::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8NF7::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NHH() //  [R1]
         { info_tbl: [(c8NHH,
                       label: block_c8NHH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NHH: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.587408414 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytes_closure" {
     Foreign.Marshal.Alloc.allocaBytes_closure:
         const Foreign.Marshal.Alloc.allocaBytes_info;
 },
 Foreign.Marshal.Alloc.allocaBytes_entry() //  [R2, R3]
         { info_tbl: [(c8NIb,
                       label: Foreign.Marshal.Alloc.allocaBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NIb: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.allocaBytes1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.591753042 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytesAligned1_closure" {
     Foreign.Marshal.Alloc.allocaBytesAligned1_closure:
         const Foreign.Marshal.Alloc.allocaBytesAligned1_info;
 },
 Foreign.Marshal.Alloc.allocaBytesAligned1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8NIp,
                       label: Foreign.Marshal.Alloc.allocaBytesAligned1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NIp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NIt; else goto c8NIu;
       c8NIt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.allocaBytesAligned1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NIu: // global
           I64[Sp - 24] = block_c8NIm_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8NIP; else goto c8NIn;
       u8NIP: // global
           call _c8NIm(R1) args: 0, res: 0, upd: 0;
       c8NIn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NIm() //  [R1]
         { info_tbl: [(c8NIm,
                       label: block_c8NIm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NIm: // global
           I64[Sp] = block_c8NIs_info;
           _s8NFj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8NFj::I64;
           if (R1 & 7 != 0) goto u8NIO; else goto c8NIw;
       u8NIO: // global
           call _c8NIs(R1) args: 0, res: 0, upd: 0;
       c8NIw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NIs() //  [R1]
         { info_tbl: [(c8NIs,
                       label: block_c8NIs_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NIs: // global
           _s8NFj::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8NIA_info;
           R2 = I64[R1 + 7];
           R1 = _s8NFj::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NIA() //  [R1]
         { info_tbl: [(c8NIA,
                       label: block_c8NIA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NIA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NIF; else goto c8NIE;
       c8NIF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NIE: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8NIK_info;
           R2 = Hp - 7;
           _s8NFr::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8NFr::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NIK() //  [R1]
         { info_tbl: [(c8NIK,
                       label: block_c8NIK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NIK: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.605201376 UTC

[section ""data" . Foreign.Marshal.Alloc.allocaBytesAligned_closure" {
     Foreign.Marshal.Alloc.allocaBytesAligned_closure:
         const Foreign.Marshal.Alloc.allocaBytesAligned_info;
 },
 Foreign.Marshal.Alloc.allocaBytesAligned_entry() //  [R2, R3, R4]
         { info_tbl: [(c8NJk,
                       label: Foreign.Marshal.Alloc.allocaBytesAligned_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NJk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.allocaBytesAligned1_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.609059129 UTC

[section ""cstring" . lvl_r8N65_bytes" {
     lvl_r8N65_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.611228668 UTC

[section ""data" . lvl1_r8N66_closure" {
     lvl1_r8N66_closure:
         const lvl1_r8N66_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8N66_entry() //  [R1]
         { info_tbl: [(c8NJy,
                       label: lvl1_r8N66_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NJy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NJz; else goto c8NJA;
       c8NJz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NJA: // global
           (_c8NJv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NJv::I64 == 0) goto c8NJx; else goto c8NJw;
       c8NJx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NJw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NJv::I64;
           R2 = lvl_r8N65_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.61559408 UTC

[section ""cstring" . Foreign.Marshal.Alloc.$trModule4_bytes" {
     Foreign.Marshal.Alloc.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.617783491 UTC

[section ""data" . lvl2_r8N67_closure" {
     lvl2_r8N67_closure:
         const lvl2_r8N67_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8N67_entry() //  [R1]
         { info_tbl: [(c8NJQ,
                       label: lvl2_r8N67_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NJQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NJR; else goto c8NJS;
       c8NJR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NJS: // global
           (_c8NJN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NJN::I64 == 0) goto c8NJP; else goto c8NJO;
       c8NJP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NJO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NJN::I64;
           R2 = Foreign.Marshal.Alloc.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.622291197 UTC

[section ""cstring" . Foreign.Marshal.Alloc.$trModule2_bytes" {
     Foreign.Marshal.Alloc.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.624439633 UTC

[section ""data" . lvl3_r8N68_closure" {
     lvl3_r8N68_closure:
         const lvl3_r8N68_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8N68_entry() //  [R1]
         { info_tbl: [(c8NK8,
                       label: lvl3_r8N68_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NK8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NK9; else goto c8NKa;
       c8NK9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NKa: // global
           (_c8NK5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NK5::I64 == 0) goto c8NK7; else goto c8NK6;
       c8NK7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NK6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NK5::I64;
           R2 = Foreign.Marshal.Alloc.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.628861507 UTC

[section ""cstring" . lvl4_r8N69_bytes" {
     lvl4_r8N69_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,108,108,111,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.631839399 UTC

[section ""data" . lvl5_r8N6a_closure" {
     lvl5_r8N6a_closure:
         const lvl5_r8N6a_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8N6a_entry() //  [R1]
         { info_tbl: [(c8NKq,
                       label: lvl5_r8N6a_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NKq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NKr; else goto c8NKs;
       c8NKr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NKs: // global
           (_c8NKn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NKn::I64 == 0) goto c8NKp; else goto c8NKo;
       c8NKp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NKo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NKn::I64;
           R2 = lvl4_r8N69_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.636462158 UTC

[section ""data" . lvl6_r8N6b_closure" {
     lvl6_r8N6b_closure:
         const GHC.Types.I#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.639132989 UTC

[section ""data" . lvl7_r8N6c_closure" {
     lvl7_r8N6c_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.640994002 UTC

[section ""data" . lvl8_r8N6d_closure" {
     lvl8_r8N6d_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.643017764 UTC

[section ""data" . lvl9_r8N6e_closure" {
     lvl9_r8N6e_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl6_r8N6b_closure+1;
         const lvl7_r8N6c_closure+1;
         const lvl6_r8N6b_closure+1;
         const lvl8_r8N6d_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.644804129 UTC

[section ""data" . lvl10_r8N6f_closure" {
     lvl10_r8N6f_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl9_r8N6e_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.646851129 UTC

[section ""data" . lvl11_r8N6g_closure" {
     lvl11_r8N6g_closure:
         const lvl11_r8N6g_info;
         const 0;
         const 0;
         const 0;
 },
 lvl11_r8N6g_entry() //  [R1]
         { info_tbl: [(c8NKM,
                       label: lvl11_r8N6g_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NKM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NKN; else goto c8NKO;
       c8NKN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NKO: // global
           (_c8NKJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NKJ::I64 == 0) goto c8NKL; else goto c8NKK;
       c8NKL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NKK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NKJ::I64;
           R2 = lvl10_r8N6f_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.650988403 UTC

[section ""data" . lvl12_r8N6h_closure" {
     lvl12_r8N6h_closure:
         const GHC.Types.I#_con_info;
         const 60;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.652735146 UTC

[section ""data" . lvl13_r8N6i_closure" {
     lvl13_r8N6i_closure:
         const GHC.Types.I#_con_info;
         const 69;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.654536955 UTC

[section ""data" . lvl14_r8N6j_closure" {
     lvl14_r8N6j_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl6_r8N6b_closure+1;
         const lvl12_r8N6h_closure+1;
         const lvl6_r8N6b_closure+1;
         const lvl13_r8N6i_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.656408727 UTC

[section ""data" . lvl15_r8N6k_closure" {
     lvl15_r8N6k_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl14_r8N6j_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.658471091 UTC

[section ""data" . lvl16_r8N6l_closure" {
     lvl16_r8N6l_closure:
         const lvl16_r8N6l_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_r8N6l_entry() //  [R1]
         { info_tbl: [(c8NL8,
                       label: lvl16_r8N6l_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NL8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NL9; else goto c8NLa;
       c8NL9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NLa: // global
           (_c8NL5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NL5::I64 == 0) goto c8NL7; else goto c8NL6;
       c8NL7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NL6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NL5::I64;
           R2 = lvl15_r8N6k_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.663457379 UTC

[section ""data" . Foreign.Marshal.Alloc.alloca_closure" {
     Foreign.Marshal.Alloc.alloca_closure:
         const Foreign.Marshal.Alloc.alloca_info;
         const 0;
 },
 ds_s8NFz_entry() //  [R1]
         { info_tbl: [(c8NLr,
                       label: ds_s8NFz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NLr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8NLs; else goto c8NLt;
       c8NLs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NLt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl11_r8N6g_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds1_s8NFA_entry() //  [R1]
         { info_tbl: [(c8NLy,
                       label: ds1_s8NFA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NLy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8NLz; else goto c8NLA;
       c8NLz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NLA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl16_r8N6l_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8NFT_entry() //  [R1, R2]
         { info_tbl: [(c8NLJ,
                       label: sat_s8NFT_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NLJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NLN; else goto c8NLO;
       c8NLN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NLO: // global
           I64[Sp - 24] = block_c8NLG_info;
           _s8NFA::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8NFA::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8NM9; else goto c8NLH;
       u8NM9: // global
           call _c8NLG(R1) args: 0, res: 0, upd: 0;
       c8NLH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NLG() //  [R1]
         { info_tbl: [(c8NLG,
                       label: block_c8NLG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NLG: // global
           I64[Sp] = block_c8NLM_info;
           _s8NFE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8NFE::I64;
           if (R1 & 7 != 0) goto u8NM8; else goto c8NLQ;
       u8NM8: // global
           call _c8NLM(R1) args: 0, res: 0, upd: 0;
       c8NLQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NLM() //  [R1]
         { info_tbl: [(c8NLM,
                       label: block_c8NLM_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NLM: // global
           _s8NFE::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8NLU_info;
           R2 = I64[R1 + 7];
           R1 = _s8NFE::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NLU() //  [R1]
         { info_tbl: [(c8NLU,
                       label: block_c8NLU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NLU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NLZ; else goto c8NLY;
       c8NLZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NLY: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8NM4_info;
           R2 = Hp - 7;
           _s8NFM::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8NFM::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NM4() //  [R1]
         { info_tbl: [(c8NM4,
                       label: block_c8NM4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NM4: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Alloc.alloca_entry() //  [R2]
         { info_tbl: [(c8NMa,
                       label: Foreign.Marshal.Alloc.alloca_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NMa: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8NMe; else goto c8NMd;
       c8NMe: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.alloca_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NMd: // global
           I64[Hp - 64] = ds_s8NFz_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ds1_s8NFA_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8NFT_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.681729716 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule3_closure" {
     Foreign.Marshal.Alloc.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Alloc.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.6835491 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule1_closure" {
     Foreign.Marshal.Alloc.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Alloc.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.685397616 UTC

[section ""data" . Foreign.Marshal.Alloc.$trModule_closure" {
     Foreign.Marshal.Alloc.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Alloc.$trModule3_closure+1;
         const Foreign.Marshal.Alloc.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.687323234 UTC

[section ""cstring" . Foreign.Marshal.Alloc.malloc4_bytes" {
     Foreign.Marshal.Alloc.malloc4_bytes:
         I8[] [109,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.689588039 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc3_closure" {
     Foreign.Marshal.Alloc.malloc3_closure:
         const Foreign.Marshal.Alloc.malloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc3_entry() //  [R1]
         { info_tbl: [(c8NNc,
                       label: Foreign.Marshal.Alloc.malloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NNc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NNd; else goto c8NNe;
       c8NNd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NNe: // global
           (_c8NN9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NN9::I64 == 0) goto c8NNb; else goto c8NNa;
       c8NNb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NNa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NN9::I64;
           R2 = Foreign.Marshal.Alloc.malloc4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.693952936 UTC

[section ""cstring" . Foreign.Marshal.Alloc.calloc4_bytes" {
     Foreign.Marshal.Alloc.calloc4_bytes:
         I8[] [111,117,116,32,111,102,32,109,101,109,111,114,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.696036394 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc3_closure" {
     Foreign.Marshal.Alloc.calloc3_closure:
         const Foreign.Marshal.Alloc.calloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc3_entry() //  [R1]
         { info_tbl: [(c8NNu,
                       label: Foreign.Marshal.Alloc.calloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NNu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NNv; else goto c8NNw;
       c8NNv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NNw: // global
           (_c8NNr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NNr::I64 == 0) goto c8NNt; else goto c8NNs;
       c8NNt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NNs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NNr::I64;
           R2 = Foreign.Marshal.Alloc.calloc4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.70035086 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc2_closure" {
     Foreign.Marshal.Alloc.malloc2_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.malloc3_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.703077849 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc1_closure" {
     Foreign.Marshal.Alloc.malloc1_closure:
         const Foreign.Marshal.Alloc.malloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc1_entry() //  [R1]
         { info_tbl: [(c8NNM,
                       label: Foreign.Marshal.Alloc.malloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NNM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NNN; else goto c8NNO;
       c8NNN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NNO: // global
           (_c8NNJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NNJ::I64 == 0) goto c8NNL; else goto c8NNK;
       c8NNL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NNK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NNJ::I64;
           R2 = Foreign.Marshal.Alloc.malloc2_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.708446548 UTC

[section ""data" . Foreign.Marshal.Alloc.mallocBytes1_closure" {
     Foreign.Marshal.Alloc.mallocBytes1_closure:
         const Foreign.Marshal.Alloc.mallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.mallocBytes1_entry() //  [R2]
         { info_tbl: [(c8NO4,
                       label: Foreign.Marshal.Alloc.mallocBytes1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NO4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8NO5; else goto c8NO6;
       c8NO5: // global
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.mallocBytes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NO6: // global
           I64[Sp - 8] = block_c8NO1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8NOo; else goto c8NO2;
       u8NOo: // global
           call _c8NO1(R1) args: 0, res: 0, upd: 0;
       c8NO2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NO1() //  [R1]
         { info_tbl: [(c8NO1,
                       label: block_c8NO1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NO1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NOb; else goto c8NOa;
       c8NOb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NOa: // global
           (_s8NG2::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8NG2::I64 == 0) goto c8NOn; else goto c8NOm;
       c8NOn: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NOm: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8NG2::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.715318294 UTC

[section ""data" . Foreign.Marshal.Alloc.mallocBytes_closure" {
     Foreign.Marshal.Alloc.mallocBytes_closure:
         const Foreign.Marshal.Alloc.mallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.mallocBytes_entry() //  [R2]
         { info_tbl: [(c8NOF,
                       label: Foreign.Marshal.Alloc.mallocBytes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NOF: // global
           R2 = R2;
           call Foreign.Marshal.Alloc.mallocBytes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.718933315 UTC

[section ""data" . lvl17_r8N6m_closure" {
     lvl17_r8N6m_closure:
         const GHC.Types.I#_con_info;
         const 84;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.720759052 UTC

[section ""data" . lvl18_r8N6n_closure" {
     lvl18_r8N6n_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.722616364 UTC

[section ""data" . lvl19_r8N6o_closure" {
     lvl19_r8N6o_closure:
         const GHC.Types.I#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.724525271 UTC

[section ""data" . lvl20_r8N6p_closure" {
     lvl20_r8N6p_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl17_r8N6m_closure+1;
         const lvl18_r8N6n_closure+1;
         const lvl17_r8N6m_closure+1;
         const lvl19_r8N6o_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.726578266 UTC

[section ""data" . lvl21_r8N6q_closure" {
     lvl21_r8N6q_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl20_r8N6p_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.728879954 UTC

[section ""data" . lvl22_r8N6r_closure" {
     lvl22_r8N6r_closure:
         const lvl22_r8N6r_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_r8N6r_entry() //  [R1]
         { info_tbl: [(c8NOX,
                       label: lvl22_r8N6r_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NOX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NOY; else goto c8NOZ;
       c8NOY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NOZ: // global
           (_c8NOU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NOU::I64 == 0) goto c8NOW; else goto c8NOV;
       c8NOW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NOV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NOU::I64;
           R2 = lvl21_r8N6q_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.734127819 UTC

[section ""data" . malloc5_r8N6s_closure" {
     malloc5_r8N6s_closure:
         const malloc5_r8N6s_info;
         const 0;
 },
 malloc5_r8N6s_entry() //  [R2]
         { info_tbl: [(c8NPe,
                       label: malloc5_r8N6s_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NPe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NPf; else goto c8NPg;
       c8NPf: // global
           R2 = R2;
           R1 = malloc5_r8N6s_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NPg: // global
           I64[Sp - 8] = block_c8NPc_info;
           R2 = R2;
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = lvl22_r8N6r_closure;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8NPc() //  [R1]
         { info_tbl: [(c8NPc,
                       label: block_c8NPc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NPc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NPl; else goto c8NPk;
       c8NPl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NPk: // global
           (_s8NGd::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8NGd::I64 == 0) goto c8NPx; else goto c8NPw;
       c8NPx: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NPw: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8NGd::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.741100333 UTC

[section ""data" . Foreign.Marshal.Alloc.malloc_closure" {
     Foreign.Marshal.Alloc.malloc_closure:
         const Foreign.Marshal.Alloc.malloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.malloc_entry() //  [R2]
         { info_tbl: [(c8NPP,
                       label: Foreign.Marshal.Alloc.malloc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NPP: // global
           R2 = R2;
           call malloc5_r8N6s_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.745185981 UTC

[section ""cstring" . Foreign.Marshal.Alloc.calloc6_bytes" {
     Foreign.Marshal.Alloc.calloc6_bytes:
         I8[] [99,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.747376635 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc5_closure" {
     Foreign.Marshal.Alloc.calloc5_closure:
         const Foreign.Marshal.Alloc.calloc5_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc5_entry() //  [R1]
         { info_tbl: [(c8NQ3,
                       label: Foreign.Marshal.Alloc.calloc5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NQ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NQ4; else goto c8NQ5;
       c8NQ4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NQ5: // global
           (_c8NQ0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NQ0::I64 == 0) goto c8NQ2; else goto c8NQ1;
       c8NQ2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NQ1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NQ0::I64;
           R2 = Foreign.Marshal.Alloc.calloc6_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.751534544 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc2_closure" {
     Foreign.Marshal.Alloc.calloc2_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.calloc5_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.753641698 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc1_closure" {
     Foreign.Marshal.Alloc.calloc1_closure:
         const Foreign.Marshal.Alloc.calloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc1_entry() //  [R1]
         { info_tbl: [(c8NQl,
                       label: Foreign.Marshal.Alloc.calloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NQl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NQm; else goto c8NQn;
       c8NQm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NQn: // global
           (_c8NQi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NQi::I64 == 0) goto c8NQk; else goto c8NQj;
       c8NQk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NQj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NQi::I64;
           R2 = Foreign.Marshal.Alloc.calloc2_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.758062041 UTC

[section ""data" . Foreign.Marshal.Alloc.callocBytes1_closure" {
     Foreign.Marshal.Alloc.callocBytes1_closure:
         const Foreign.Marshal.Alloc.callocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.callocBytes1_entry() //  [R2]
         { info_tbl: [(c8NQD,
                       label: Foreign.Marshal.Alloc.callocBytes1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NQD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8NQE; else goto c8NQF;
       c8NQE: // global
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.callocBytes1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NQF: // global
           I64[Sp - 8] = block_c8NQA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8NQY; else goto c8NQB;
       u8NQY: // global
           call _c8NQA(R1) args: 0, res: 0, upd: 0;
       c8NQB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NQA() //  [R1]
         { info_tbl: [(c8NQA,
                       label: block_c8NQA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NQA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NQK; else goto c8NQJ;
       c8NQK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NQJ: // global
           (_s8NGo::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[R1 + 7]);
           if (_s8NGo::I64 == 0) goto c8NQX; else goto c8NQW;
       c8NQX: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NQW: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8NGo::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.764165037 UTC

[section ""data" . Foreign.Marshal.Alloc.callocBytes_closure" {
     Foreign.Marshal.Alloc.callocBytes_closure:
         const Foreign.Marshal.Alloc.callocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.callocBytes_entry() //  [R2]
         { info_tbl: [(c8NRf,
                       label: Foreign.Marshal.Alloc.callocBytes_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NRf: // global
           R2 = R2;
           call Foreign.Marshal.Alloc.callocBytes1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.767456939 UTC

[section ""data" . lvl23_r8N6t_closure" {
     lvl23_r8N6t_closure:
         const GHC.Types.I#_con_info;
         const 90;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.769170828 UTC

[section ""data" . lvl24_r8N6u_closure" {
     lvl24_r8N6u_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl23_r8N6t_closure+1;
         const lvl7_r8N6c_closure+1;
         const lvl23_r8N6t_closure+1;
         const lvl8_r8N6d_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.770983128 UTC

[section ""data" . lvl25_r8N6v_closure" {
     lvl25_r8N6v_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl24_r8N6u_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.772940819 UTC

[section ""data" . lvl26_r8N6w_closure" {
     lvl26_r8N6w_closure:
         const lvl26_r8N6w_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_r8N6w_entry() //  [R1]
         { info_tbl: [(c8NRv,
                       label: lvl26_r8N6w_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NRv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NRw; else goto c8NRx;
       c8NRw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NRx: // global
           (_c8NRs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NRs::I64 == 0) goto c8NRu; else goto c8NRt;
       c8NRu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NRt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NRs::I64;
           R2 = lvl25_r8N6v_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.77828465 UTC

[section ""data" . calloc7_r8N6x_closure" {
     calloc7_r8N6x_closure:
         const calloc7_r8N6x_info;
         const 0;
 },
 calloc7_r8N6x_entry() //  [R2]
         { info_tbl: [(c8NRM,
                       label: calloc7_r8N6x_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NRM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8NRN; else goto c8NRO;
       c8NRN: // global
           R2 = R2;
           R1 = calloc7_r8N6x_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NRO: // global
           I64[Sp - 8] = block_c8NRK_info;
           R2 = R2;
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = lvl26_r8N6w_closure;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8NRK() //  [R1]
         { info_tbl: [(c8NRK,
                       label: block_c8NRK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NRK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NRT; else goto c8NRS;
       c8NRT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NRS: // global
           (_s8NGz::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[R1 + 7]);
           if (_s8NGz::I64 == 0) goto c8NS6; else goto c8NS5;
       c8NS6: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 8;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NS5: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8NGz::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.78419225 UTC

[section ""data" . Foreign.Marshal.Alloc.calloc_closure" {
     Foreign.Marshal.Alloc.calloc_closure:
         const Foreign.Marshal.Alloc.calloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.calloc_entry() //  [R2]
         { info_tbl: [(c8NSo,
                       label: Foreign.Marshal.Alloc.calloc_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NSo: // global
           R2 = R2;
           call calloc7_r8N6x_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.78770556 UTC

[section ""cstring" . Foreign.Marshal.Alloc.realloc5_bytes" {
     Foreign.Marshal.Alloc.realloc5_bytes:
         I8[] [114,101,97,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.789569917 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc4_closure" {
     Foreign.Marshal.Alloc.realloc4_closure:
         const Foreign.Marshal.Alloc.realloc4_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc4_entry() //  [R1]
         { info_tbl: [(c8NSC,
                       label: Foreign.Marshal.Alloc.realloc4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NSC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NSD; else goto c8NSE;
       c8NSD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NSE: // global
           (_c8NSz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NSz::I64 == 0) goto c8NSB; else goto c8NSA;
       c8NSB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NSA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NSz::I64;
           R2 = Foreign.Marshal.Alloc.realloc5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.793489192 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc3_closure" {
     Foreign.Marshal.Alloc.realloc3_closure:
         const GHC.IO.Exception.IOError_con_info;
         const GHC.Base.Nothing_closure+1;
         const GHC.IO.Exception.ResourceExhausted_closure+1;
         const Foreign.Marshal.Alloc.realloc4_closure;
         const Foreign.Marshal.Alloc.calloc3_closure;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.795473631 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc2_closure" {
     Foreign.Marshal.Alloc.realloc2_closure:
         const Foreign.Marshal.Alloc.realloc2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc2_entry() //  [R1]
         { info_tbl: [(c8NSU,
                       label: Foreign.Marshal.Alloc.realloc2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NSU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NSV; else goto c8NSW;
       c8NSV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NSW: // global
           (_c8NSR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NSR::I64 == 0) goto c8NST; else goto c8NSS;
       c8NST: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NSS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NSR::I64;
           R2 = Foreign.Marshal.Alloc.realloc3_closure+1;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.799625366 UTC

[section ""data" . lvl27_r8N6y_closure" {
     lvl27_r8N6y_closure:
         const GHC.Types.I#_con_info;
         const 162;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.801270877 UTC

[section ""data" . lvl28_r8N6z_closure" {
     lvl28_r8N6z_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.802989231 UTC

[section ""data" . lvl29_r8N6A_closure" {
     lvl29_r8N6A_closure:
         const GHC.Types.I#_con_info;
         const 43;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.804650995 UTC

[section ""data" . lvl30_r8N6B_closure" {
     lvl30_r8N6B_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8N67_closure;
         const lvl3_r8N68_closure;
         const lvl5_r8N6a_closure;
         const lvl27_r8N6y_closure+1;
         const lvl28_r8N6z_closure+1;
         const lvl27_r8N6y_closure+1;
         const lvl29_r8N6A_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.806474172 UTC

[section ""data" . lvl31_r8N6C_closure" {
     lvl31_r8N6C_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8N66_closure;
         const lvl30_r8N6B_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.808986567 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc6_closure" {
     Foreign.Marshal.Alloc.realloc6_closure:
         const Foreign.Marshal.Alloc.realloc6_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc6_entry() //  [R1]
         { info_tbl: [(c8NTg,
                       label: Foreign.Marshal.Alloc.realloc6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NTg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NTh; else goto c8NTi;
       c8NTh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8NTi: // global
           (_c8NTd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8NTd::I64 == 0) goto c8NTf; else goto c8NTe;
       c8NTf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8NTe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8NTd::I64;
           R2 = lvl31_r8N6C_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.813811203 UTC

[section ""data" . Foreign.Marshal.Alloc.$wrealloc_closure" {
     Foreign.Marshal.Alloc.$wrealloc_closure:
         const Foreign.Marshal.Alloc.$wrealloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.$wrealloc_entry() //  [R2, R3]
         { info_tbl: [(c8NTx,
                       label: Foreign.Marshal.Alloc.$wrealloc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NTx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8NTy; else goto c8NTz;
       c8NTy: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.$wrealloc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NTz: // global
           I64[Sp - 16] = block_c8NTv_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Alloc.realloc6_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8NTv() //  [R1]
         { info_tbl: [(c8NTv,
                       label: block_c8NTv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NTv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NTE; else goto c8NTD;
       c8NTE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8NTD: // global
           (_s8NGL::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], I64[R1 + 7]);
           if (_s8NGL::I64 == 0) goto c8NTR; else goto c8NTQ;
       c8NTR: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NTQ: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8NGL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.819973095 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc1_closure" {
     Foreign.Marshal.Alloc.realloc1_closure:
         const Foreign.Marshal.Alloc.realloc1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc1_entry() //  [R2, R3]
         { info_tbl: [(c8NUc,
                       label: Foreign.Marshal.Alloc.realloc1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NUc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NUd; else goto c8NUe;
       c8NUd: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.realloc1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NUe: // global
           I64[Sp - 16] = block_c8NU9_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8NUi; else goto c8NUa;
       u8NUi: // global
           call _c8NU9(R1) args: 0, res: 0, upd: 0;
       c8NUa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NU9() //  [R1]
         { info_tbl: [(c8NU9,
                       label: block_c8NU9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NU9: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Alloc.$wrealloc_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.826004931 UTC

[section ""data" . Foreign.Marshal.Alloc.realloc_closure" {
     Foreign.Marshal.Alloc.realloc_closure:
         const Foreign.Marshal.Alloc.realloc_info;
         const 0;
 },
 Foreign.Marshal.Alloc.realloc_entry() //  [R2, R3]
         { info_tbl: [(c8NUx,
                       label: Foreign.Marshal.Alloc.realloc_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NUx: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.realloc1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.82955102 UTC

[section ""data" . free1_r8N6D_closure" {
     free1_r8N6D_closure:
         const free1_r8N6D_info;
 },
 free1_r8N6D_entry() //  [R2]
         { info_tbl: [(c8NUL,
                       label: free1_r8N6D_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NUL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8NUM; else goto c8NUN;
       c8NUM: // global
           R2 = R2;
           R1 = free1_r8N6D_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8NUN: // global
           I64[Sp - 8] = block_c8NUI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8NUT; else goto c8NUJ;
       u8NUT: // global
           call _c8NUI(R1) args: 0, res: 0, upd: 0;
       c8NUJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NUI() //  [R1]
         { info_tbl: [(c8NUI,
                       label: block_c8NUI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NUI: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.835090063 UTC

[section ""data" . Foreign.Marshal.Alloc.free_closure" {
     Foreign.Marshal.Alloc.free_closure:
         const Foreign.Marshal.Alloc.free_info;
 },
 Foreign.Marshal.Alloc.free_entry() //  [R2]
         { info_tbl: [(c8NVa,
                       label: Foreign.Marshal.Alloc.free_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NVa: // global
           R2 = R2;
           call free1_r8N6D_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.838648158 UTC

[section ""data" . Foreign.Marshal.Alloc.$wreallocBytes_closure" {
     Foreign.Marshal.Alloc.$wreallocBytes_closure:
         const Foreign.Marshal.Alloc.$wreallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.$wreallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c8NVp,
                       label: Foreign.Marshal.Alloc.$wreallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NVp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8NVt; else goto c8NVs;
       c8NVt: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.$wreallocBytes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NVs: // global
           if (R3 == 0) goto c8NVo; else goto c8NVn;
       c8NVo: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(R2);
           Hp = Hp - 16;
           R1 = GHC.Ptr.nullPtr_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8NVn: // global
           _c8NVA::I64 = R3;
           (_s8NH8::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(R2, _c8NVA::I64);
           if (_s8NH8::I64 == 0) goto c8NVH; else goto c8NVG;
       c8NVH: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8NVG: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8NH8::I64;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.844067426 UTC

[section ""data" . Foreign.Marshal.Alloc.reallocBytes1_closure" {
     Foreign.Marshal.Alloc.reallocBytes1_closure:
         const Foreign.Marshal.Alloc.reallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Alloc.reallocBytes1_entry() //  [R2, R3]
         { info_tbl: [(c8NW0,
                       label: Foreign.Marshal.Alloc.reallocBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NW0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8NW4; else goto c8NW5;
       c8NW4: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Alloc.reallocBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8NW5: // global
           I64[Sp - 16] = block_c8NVX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8NWd; else goto c8NVY;
       u8NWd: // global
           call _c8NVX(R1) args: 0, res: 0, upd: 0;
       c8NVY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NVX() //  [R1]
         { info_tbl: [(c8NVX,
                       label: block_c8NVX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NVX: // global
           I64[Sp] = block_c8NW3_info;
           _s8NHi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8NHi::I64;
           if (R1 & 7 != 0) goto u8NWc; else goto c8NW7;
       u8NWc: // global
           call _c8NW3(R1) args: 0, res: 0, upd: 0;
       c8NW7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8NW3() //  [R1]
         { info_tbl: [(c8NW3,
                       label: block_c8NW3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NW3: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Alloc.$wreallocBytes_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.851369518 UTC

[section ""data" . Foreign.Marshal.Alloc.reallocBytes_closure" {
     Foreign.Marshal.Alloc.reallocBytes_closure:
         const Foreign.Marshal.Alloc.reallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Alloc.reallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c8NWx,
                       label: Foreign.Marshal.Alloc.reallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8NWx: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Alloc.reallocBytes1_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.854626228 UTC

[section ""data" . Foreign.Marshal.Alloc.finalizerFree_closure" {
     Foreign.Marshal.Alloc.finalizerFree_closure:
         const GHC.Ptr.FunPtr_con_info;
         const free;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.856871793 UTC

[section ""relreadonly" . S8NKP_srt" {
     S8NKP_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r8N6f_closure;
         const lvl15_r8N6k_closure;
         const lvl11_r8N6g_closure;
         const lvl16_r8N6l_closure;
         const Foreign.Marshal.Alloc.alloca_closure;
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const Foreign.Marshal.Alloc.malloc2_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.mallocBytes1_closure;
         const lvl21_r8N6q_closure;
         const lvl22_r8N6r_closure;
         const malloc5_r8N6s_closure;
         const Foreign.Marshal.Alloc.calloc2_closure;
         const Foreign.Marshal.Alloc.calloc1_closure;
         const Foreign.Marshal.Alloc.callocBytes1_closure;
         const lvl25_r8N6v_closure;
         const lvl26_r8N6w_closure;
         const calloc7_r8N6x_closure;
         const Foreign.Marshal.Alloc.realloc3_closure;
         const lvl31_r8N6C_closure;
         const Foreign.Marshal.Alloc.$wrealloc_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Alloc.realloc6_closure;
         const Foreign.Marshal.Alloc.realloc1_closure;
         const Foreign.Marshal.Alloc.$wreallocBytes_closure;
         const Foreign.Marshal.Alloc.reallocBytes1_closure;
 }]

