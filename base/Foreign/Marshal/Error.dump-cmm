
==================== Output Cmm ====================
2018-03-16 16:03:56.09975617 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:56.100828513 UTC

[section ""data" . Foreign.Marshal.Error.throwIf2_closure" {
     Foreign.Marshal.Error.throwIf2_closure:
         const Foreign.Marshal.Error.throwIf2_info;
         const 0;
 },
 sat_s8Mei_entry() //  [R1]
         { info_tbl: [(c8Mfp,
                       label: sat_s8Mei_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mfp: // global
           _s8Mei::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Mfq; else goto c8Mfr;
       c8Mfr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8Mft; else goto c8Mfs;
       c8Mft: // global
           HpAlloc = 88;
           goto c8Mfq;
       c8Mfq: // global
           R1 = _s8Mei::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mfs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Mei::P64;
           _s8Med::P64 = P64[_s8Mei::P64 + 16];
           _s8Mee::P64 = P64[_s8Mei::P64 + 24];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = _s8Mee::P64;
           P64[Hp - 56] = _s8Med::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Error.throwIf2_entry() //  [R2, R3]
         { info_tbl: [(c8Mfu,
                       label: Foreign.Marshal.Error.throwIf2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mfu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Mfy; else goto c8Mfx;
       c8Mfy: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mfx: // global
           I64[Hp - 24] = sat_s8Mei_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.102573505 UTC

[section ""data" . Foreign.Marshal.Error.throwIf1_closure" {
     Foreign.Marshal.Error.throwIf1_closure:
         const Foreign.Marshal.Error.throwIf1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8MfM,
                       label: Foreign.Marshal.Error.throwIf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MfM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8MfN; else goto c8MfO;
       c8MfN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MfO: // global
           I64[Sp - 24] = block_c8MfE_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MfE() //  [R1]
         { info_tbl: [(c8MfE,
                       label: block_c8MfE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MfE: // global
           I64[Sp] = block_c8MfG_info;
           R2 = R1;
           _s8Mep::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8Mep::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MfG() //  [R1]
         { info_tbl: [(c8MfG,
                       label: block_c8MfG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MfG: // global
           _s8Mep::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8MfJ; else goto c8MfK;
       c8MfJ: // global
           R1 = _s8Mep::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8MfK: // global
           R3 = P64[Sp + 16];
           R2 = _s8Mep::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.104249225 UTC

[section ""data" . Foreign.Marshal.Error.throwIf_closure" {
     Foreign.Marshal.Error.throwIf_closure:
         const Foreign.Marshal.Error.throwIf_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Mg0,
                       label: Foreign.Marshal.Error.throwIf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mg0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIf1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.105484654 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg1_closure" {
     Foreign.Marshal.Error.throwIfNeg1_closure:
         const Foreign.Marshal.Error.throwIfNeg1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNeg1_entry() //  [R1]
         { info_tbl: [(c8Mg9,
                       label: Foreign.Marshal.Error.throwIfNeg1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mg9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Mga; else goto c8Mgb;
       c8Mga: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mgb: // global
           (_c8Mg6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Mg6::I64 == 0) goto c8Mg8; else goto c8Mg7;
       c8Mg8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Mg7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Mg6::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.107443162 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg_closure" {
     Foreign.Marshal.Error.throwIfNeg_closure:
         const Foreign.Marshal.Error.throwIfNeg_info;
         const 0;
 },
 ds_s8Met_entry() //  [R1]
         { info_tbl: [(c8Mgk,
                       label: ds_s8Met_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mgk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Mgl; else goto c8Mgm;
       c8Mgl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mgm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Error.throwIfNeg1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8MeB_entry() //  [R1, R2, R3]
         { info_tbl: [(c8MgA,
                       label: sat_s8MeB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MgA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8MgB; else goto c8MgC;
       c8MgB: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MgC: // global
           I64[Sp - 32] = block_c8Mgs_info;
           _s8Mer::P64 = P64[R1 + 5];
           _s8Met::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s8Mer::P64;
           P64[Sp - 16] = _s8Met::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mgs() //  [R1]
         { info_tbl: [(c8Mgs,
                       label: block_c8Mgs_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mgs: // global
           _s8Mer::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Mgu_info;
           R2 = _s8Mer::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = R1;
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8Mgu() //  [R1]
         { info_tbl: [(c8Mgu,
                       label: block_c8Mgu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mgu: // global
           _s8Mez::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8Mgx; else goto c8Mgy;
       c8Mgx: // global
           R1 = _s8Mez::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Mgy: // global
           R3 = P64[Sp + 16];
           R2 = _s8Mez::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Error.throwIfNeg_entry() //  [R2, R3]
         { info_tbl: [(c8MgK,
                       label: Foreign.Marshal.Error.throwIfNeg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MgK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8MgO; else goto c8MgN;
       c8MgO: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNeg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MgN: // global
           I64[Hp - 40] = ds_s8Met_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8MeB_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.110318607 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull2_closure" {
     Foreign.Marshal.Error.throwIfNull2_closure:
         const Foreign.Marshal.Error.throwIfNull2_info;
         const 0;
 },
 sat_s8MeF_entry() //  [R1]
         { info_tbl: [(c8MgY,
                       label: sat_s8MeF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MgY: // global
           _s8MeF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8MgZ; else goto c8Mh0;
       c8Mh0: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Mh2; else goto c8Mh1;
       c8Mh2: // global
           HpAlloc = 56;
           goto c8MgZ;
       c8MgZ: // global
           R1 = _s8MeF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mh1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8MeF::P64;
           _s8MeC::P64 = P64[_s8MeF::P64 + 16];
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = _s8MeC::P64;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Error.throwIfNull2_entry() //  [R2]
         { info_tbl: [(c8Mh3,
                       label: Foreign.Marshal.Error.throwIfNull2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mh3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Mh7; else goto c8Mh6;
       c8Mh7: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNull2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Mh6: // global
           I64[Hp - 16] = sat_s8MeF_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.112383762 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull1_closure" {
     Foreign.Marshal.Error.throwIfNull1_closure:
         const Foreign.Marshal.Error.throwIfNull1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNull1_entry() //  [R2, R3]
         { info_tbl: [(c8Mhh,
                       label: Foreign.Marshal.Error.throwIfNull1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mhh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Mhi; else goto c8Mhj;
       c8Mhi: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNull1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mhj: // global
           I64[Sp - 16] = block_c8Mhc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mhc() //  [R1]
         { info_tbl: [(c8Mhc,
                       label: block_c8Mhc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mhc: // global
           I64[Sp - 8] = block_c8Mhe_info;
           _s8MeL::P64 = R1;
           R1 = R1;
           P64[Sp] = _s8MeL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Mht; else goto c8Mhf;
       u8Mht: // global
           call _c8Mhe(R1) args: 0, res: 0, upd: 0;
       c8Mhf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mhe() //  [R1]
         { info_tbl: [(c8Mhe,
                       label: block_c8Mhe_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mhe: // global
           if (I64[R1 + 7] == 0) goto c8Mhs; else goto c8Mhr;
       c8Mhs: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIfNull2_entry(R2) args: 8, res: 0, upd: 8;
       c8Mhr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.114375724 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull_closure" {
     Foreign.Marshal.Error.throwIfNull_closure:
         const Foreign.Marshal.Error.throwIfNull_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNull_entry() //  [R2, R3]
         { info_tbl: [(c8Mhy,
                       label: Foreign.Marshal.Error.throwIfNull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mhy: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIfNull1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.115550242 UTC

[section ""data" . Foreign.Marshal.Error.void1_closure" {
     Foreign.Marshal.Error.void1_closure:
         const Foreign.Marshal.Error.void1_info;
 },
 Foreign.Marshal.Error.void1_entry() //  [R2]
         { info_tbl: [(c8MhH,
                       label: Foreign.Marshal.Error.void1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MhH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8MhI; else goto c8MhJ;
       c8MhI: // global
           R2 = R2;
           R1 = Foreign.Marshal.Error.void1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8MhJ: // global
           I64[Sp - 8] = block_c8MhF_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MhF() //  []
         { info_tbl: [(c8MhF,
                       label: block_c8MhF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MhF: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.116898352 UTC

[section ""data" . Foreign.Marshal.Error.void_closure" {
     Foreign.Marshal.Error.void_closure:
         const Foreign.Marshal.Error.void_info;
 },
 Foreign.Marshal.Error.void_entry() //  [R2]
         { info_tbl: [(c8MhP,
                       label: Foreign.Marshal.Error.void_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MhP: // global
           R2 = R2;
           call Foreign.Marshal.Error.void1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.118233947 UTC

[section ""data" . Foreign.Marshal.Error.throwIf_1_closure" {
     Foreign.Marshal.Error.throwIf_1_closure:
         const Foreign.Marshal.Error.throwIf_1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf_1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Mi4,
                       label: Foreign.Marshal.Error.throwIf_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mi4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Mi5; else goto c8Mi6;
       c8Mi5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mi6: // global
           I64[Sp - 24] = block_c8MhW_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MhW() //  [R1]
         { info_tbl: [(c8MhW,
                       label: block_c8MhW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MhW: // global
           I64[Sp] = block_c8MhY_info;
           R2 = R1;
           _s8Mf0::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8Mf0::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MhY() //  [R1]
         { info_tbl: [(c8MhY,
                       label: block_c8MhY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MhY: // global
           if (R1 & 7 == 1) goto c8Mi1; else goto c8Mi2;
       c8Mi1: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Mi2: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.119995102 UTC

[section ""data" . Foreign.Marshal.Error.throwIf__closure" {
     Foreign.Marshal.Error.throwIf__closure:
         const Foreign.Marshal.Error.throwIf__info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf__entry() //  [R2, R3, R4]
         { info_tbl: [(c8Mii,
                       label: Foreign.Marshal.Error.throwIf__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mii: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIf_1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.121655414 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg__closure" {
     Foreign.Marshal.Error.throwIfNeg__closure:
         const Foreign.Marshal.Error.throwIfNeg__info;
         const 0;
 },
 ds_s8Mf5_entry() //  [R1]
         { info_tbl: [(c8Mit,
                       label: ds_s8Mf5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mit: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Miu; else goto c8Miv;
       c8Miu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Miv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Error.throwIfNeg1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8Mfe_entry() //  [R1, R2, R3]
         { info_tbl: [(c8MiJ,
                       label: sat_s8Mfe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MiJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8MiK; else goto c8MiL;
       c8MiK: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MiL: // global
           I64[Sp - 32] = block_c8MiB_info;
           _s8Mf3::P64 = P64[R1 + 5];
           _s8Mf5::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s8Mf3::P64;
           P64[Sp - 16] = _s8Mf5::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MiB() //  [R1]
         { info_tbl: [(c8MiB,
                       label: block_c8MiB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MiB: // global
           _s8Mf3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8MiD_info;
           R2 = _s8Mf3::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = R1;
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8MiD() //  [R1]
         { info_tbl: [(c8MiD,
                       label: block_c8MiD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MiD: // global
           if (R1 & 7 == 1) goto c8MiG; else goto c8MiH;
       c8MiG: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8MiH: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Error.throwIfNeg__entry() //  [R2, R3]
         { info_tbl: [(c8MiT,
                       label: Foreign.Marshal.Error.throwIfNeg__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MiT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8MiX; else goto c8MiW;
       c8MiX: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNeg__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MiW: // global
           I64[Hp - 40] = ds_s8Mf5_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8Mfe_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.123491559 UTC

[section ""cstring" . Foreign.Marshal.Error.$trModule4_bytes" {
     Foreign.Marshal.Error.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.124049624 UTC

[section ""data" . Foreign.Marshal.Error.$trModule3_closure" {
     Foreign.Marshal.Error.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Error.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.124575982 UTC

[section ""cstring" . Foreign.Marshal.Error.$trModule2_bytes" {
     Foreign.Marshal.Error.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.125115725 UTC

[section ""data" . Foreign.Marshal.Error.$trModule1_closure" {
     Foreign.Marshal.Error.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Error.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.125877264 UTC

[section ""data" . Foreign.Marshal.Error.$trModule_closure" {
     Foreign.Marshal.Error.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Error.$trModule3_closure+1;
         const Foreign.Marshal.Error.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.126433902 UTC

[section ""relreadonly" . S8Mfz_srt" {
     S8Mfz_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const Foreign.Marshal.Error.throwIf2_closure;
         const Foreign.Marshal.Error.throwIf1_closure;
         const Foreign.Marshal.Error.throwIfNeg1_closure;
         const Foreign.Marshal.Error.throwIfNeg_closure;
         const Foreign.Marshal.Error.throwIfNull2_closure;
         const Foreign.Marshal.Error.throwIfNull1_closure;
         const Foreign.Marshal.Error.throwIf_1_closure;
         const Foreign.Marshal.Error.throwIfNeg__closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.127036128 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:56.127919953 UTC

[section ""data" . Foreign.Marshal.Error.throwIf2_closure" {
     Foreign.Marshal.Error.throwIf2_closure:
         const Foreign.Marshal.Error.throwIf2_info;
         const 0;
 },
 sat_s8Mei_entry() //  [R1]
         { info_tbl: [(c8Mj8,
                       label: sat_s8Mei_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mj8: // global
           _s8Mei::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Mj9; else goto c8Mja;
       c8Mja: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8Mjc; else goto c8Mjb;
       c8Mjc: // global
           HpAlloc = 88;
           goto c8Mj9;
       c8Mj9: // global
           R1 = _s8Mei::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mjb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Mei::P64;
           _s8Med::P64 = P64[_s8Mei::P64 + 16];
           _s8Mee::P64 = P64[_s8Mei::P64 + 24];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = _s8Mee::P64;
           P64[Hp - 56] = _s8Med::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Error.throwIf2_entry() //  [R2, R3]
         { info_tbl: [(c8Mjd,
                       label: Foreign.Marshal.Error.throwIf2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mjd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Mjh; else goto c8Mjg;
       c8Mjh: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mjg: // global
           I64[Hp - 24] = sat_s8Mei_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.129546072 UTC

[section ""data" . Foreign.Marshal.Error.throwIf1_closure" {
     Foreign.Marshal.Error.throwIf1_closure:
         const Foreign.Marshal.Error.throwIf1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Mju,
                       label: Foreign.Marshal.Error.throwIf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mju: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Mjv; else goto c8Mjw;
       c8Mjv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mjw: // global
           I64[Sp - 24] = block_c8Mjm_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mjm() //  [R1]
         { info_tbl: [(c8Mjm,
                       label: block_c8Mjm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mjm: // global
           I64[Sp] = block_c8Mjo_info;
           R2 = R1;
           _s8Mep::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8Mep::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mjo() //  [R1]
         { info_tbl: [(c8Mjo,
                       label: block_c8Mjo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mjo: // global
           _s8Mep::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8Mjr; else goto c8Mjs;
       c8Mjr: // global
           R1 = _s8Mep::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Mjs: // global
           R3 = P64[Sp + 16];
           R2 = _s8Mep::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.13086759 UTC

[section ""data" . Foreign.Marshal.Error.throwIf_closure" {
     Foreign.Marshal.Error.throwIf_closure:
         const Foreign.Marshal.Error.throwIf_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf_entry() //  [R2, R3, R4]
         { info_tbl: [(c8MjI,
                       label: Foreign.Marshal.Error.throwIf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MjI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIf1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.13180935 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg1_closure" {
     Foreign.Marshal.Error.throwIfNeg1_closure:
         const Foreign.Marshal.Error.throwIfNeg1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNeg1_entry() //  [R1]
         { info_tbl: [(c8MjR,
                       label: Foreign.Marshal.Error.throwIfNeg1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MjR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8MjS; else goto c8MjT;
       c8MjS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8MjT: // global
           (_c8MjO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8MjO::I64 == 0) goto c8MjQ; else goto c8MjP;
       c8MjQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8MjP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8MjO::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.133322435 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg_closure" {
     Foreign.Marshal.Error.throwIfNeg_closure:
         const Foreign.Marshal.Error.throwIfNeg_info;
         const 0;
 },
 ds_s8Met_entry() //  [R1]
         { info_tbl: [(c8Mk2,
                       label: ds_s8Met_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mk2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Mk3; else goto c8Mk4;
       c8Mk3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mk4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Error.throwIfNeg1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8MeB_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Mki,
                       label: sat_s8MeB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mki: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8Mkj; else goto c8Mkk;
       c8Mkj: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mkk: // global
           I64[Sp - 32] = block_c8Mka_info;
           _s8Mer::P64 = P64[R1 + 5];
           _s8Met::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s8Mer::P64;
           P64[Sp - 16] = _s8Met::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mka() //  [R1]
         { info_tbl: [(c8Mka,
                       label: block_c8Mka_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mka: // global
           _s8Mer::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Mkc_info;
           R2 = _s8Mer::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = R1;
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8Mkc() //  [R1]
         { info_tbl: [(c8Mkc,
                       label: block_c8Mkc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mkc: // global
           _s8Mez::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8Mkf; else goto c8Mkg;
       c8Mkf: // global
           R1 = _s8Mez::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Mkg: // global
           R3 = P64[Sp + 16];
           R2 = _s8Mez::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Error.throwIfNeg_entry() //  [R2, R3]
         { info_tbl: [(c8Mks,
                       label: Foreign.Marshal.Error.throwIfNeg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mks: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Mkw; else goto c8Mkv;
       c8Mkw: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNeg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mkv: // global
           I64[Hp - 40] = ds_s8Met_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8MeB_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.13548071 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull2_closure" {
     Foreign.Marshal.Error.throwIfNull2_closure:
         const Foreign.Marshal.Error.throwIfNull2_info;
         const 0;
 },
 sat_s8MeF_entry() //  [R1]
         { info_tbl: [(c8MkG,
                       label: sat_s8MeF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MkG: // global
           _s8MeF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8MkH; else goto c8MkI;
       c8MkI: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8MkK; else goto c8MkJ;
       c8MkK: // global
           HpAlloc = 56;
           goto c8MkH;
       c8MkH: // global
           R1 = _s8MeF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8MkJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8MeF::P64;
           _s8MeC::P64 = P64[_s8MeF::P64 + 16];
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = _s8MeC::P64;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Error.throwIfNull2_entry() //  [R2]
         { info_tbl: [(c8MkL,
                       label: Foreign.Marshal.Error.throwIfNull2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MkL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8MkP; else goto c8MkO;
       c8MkP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNull2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8MkO: // global
           I64[Hp - 16] = sat_s8MeF_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.13707543 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull1_closure" {
     Foreign.Marshal.Error.throwIfNull1_closure:
         const Foreign.Marshal.Error.throwIfNull1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNull1_entry() //  [R2, R3]
         { info_tbl: [(c8MkZ,
                       label: Foreign.Marshal.Error.throwIfNull1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MkZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ml0; else goto c8Ml1;
       c8Ml0: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNull1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ml1: // global
           I64[Sp - 16] = block_c8MkU_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MkU() //  [R1]
         { info_tbl: [(c8MkU,
                       label: block_c8MkU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MkU: // global
           I64[Sp - 8] = block_c8MkW_info;
           _s8MeL::P64 = R1;
           R1 = R1;
           P64[Sp] = _s8MeL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Mlb; else goto c8MkX;
       u8Mlb: // global
           call _c8MkW(R1) args: 0, res: 0, upd: 0;
       c8MkX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MkW() //  [R1]
         { info_tbl: [(c8MkW,
                       label: block_c8MkW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MkW: // global
           if (I64[R1 + 7] == 0) goto c8Mla; else goto c8Ml9;
       c8Mla: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIfNull2_entry(R2) args: 8, res: 0, upd: 8;
       c8Ml9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.138683943 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull_closure" {
     Foreign.Marshal.Error.throwIfNull_closure:
         const Foreign.Marshal.Error.throwIfNull_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNull_entry() //  [R2, R3]
         { info_tbl: [(c8Mlg,
                       label: Foreign.Marshal.Error.throwIfNull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mlg: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIfNull1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.13960786 UTC

[section ""data" . Foreign.Marshal.Error.void1_closure" {
     Foreign.Marshal.Error.void1_closure:
         const Foreign.Marshal.Error.void1_info;
 },
 Foreign.Marshal.Error.void1_entry() //  [R2]
         { info_tbl: [(c8Mlp,
                       label: Foreign.Marshal.Error.void1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mlp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Mlq; else goto c8Mlr;
       c8Mlq: // global
           R2 = R2;
           R1 = Foreign.Marshal.Error.void1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Mlr: // global
           I64[Sp - 8] = block_c8Mln_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mln() //  []
         { info_tbl: [(c8Mln,
                       label: block_c8Mln_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mln: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.140577683 UTC

[section ""data" . Foreign.Marshal.Error.void_closure" {
     Foreign.Marshal.Error.void_closure:
         const Foreign.Marshal.Error.void_info;
 },
 Foreign.Marshal.Error.void_entry() //  [R2]
         { info_tbl: [(c8Mlx,
                       label: Foreign.Marshal.Error.void_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mlx: // global
           R2 = R2;
           call Foreign.Marshal.Error.void1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.141638353 UTC

[section ""data" . Foreign.Marshal.Error.throwIf_1_closure" {
     Foreign.Marshal.Error.throwIf_1_closure:
         const Foreign.Marshal.Error.throwIf_1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf_1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8MlM,
                       label: Foreign.Marshal.Error.throwIf_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MlM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8MlN; else goto c8MlO;
       c8MlN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MlO: // global
           I64[Sp - 24] = block_c8MlE_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MlE() //  [R1]
         { info_tbl: [(c8MlE,
                       label: block_c8MlE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MlE: // global
           I64[Sp] = block_c8MlG_info;
           R2 = R1;
           _s8Mf0::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8Mf0::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MlG() //  [R1]
         { info_tbl: [(c8MlG,
                       label: block_c8MlG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MlG: // global
           if (R1 & 7 == 1) goto c8MlJ; else goto c8MlK;
       c8MlJ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8MlK: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.143008734 UTC

[section ""data" . Foreign.Marshal.Error.throwIf__closure" {
     Foreign.Marshal.Error.throwIf__closure:
         const Foreign.Marshal.Error.throwIf__info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf__entry() //  [R2, R3, R4]
         { info_tbl: [(c8Mm0,
                       label: Foreign.Marshal.Error.throwIf__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mm0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIf_1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.144386719 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg__closure" {
     Foreign.Marshal.Error.throwIfNeg__closure:
         const Foreign.Marshal.Error.throwIfNeg__info;
         const 0;
 },
 ds_s8Mf5_entry() //  [R1]
         { info_tbl: [(c8Mmb,
                       label: ds_s8Mf5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mmb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Mmc; else goto c8Mmd;
       c8Mmc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mmd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Error.throwIfNeg1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8Mfe_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Mmr,
                       label: sat_s8Mfe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mmr: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8Mms; else goto c8Mmt;
       c8Mms: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mmt: // global
           I64[Sp - 32] = block_c8Mmj_info;
           _s8Mf3::P64 = P64[R1 + 5];
           _s8Mf5::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s8Mf3::P64;
           P64[Sp - 16] = _s8Mf5::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mmj() //  [R1]
         { info_tbl: [(c8Mmj,
                       label: block_c8Mmj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mmj: // global
           _s8Mf3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Mml_info;
           R2 = _s8Mf3::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = R1;
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8Mml() //  [R1]
         { info_tbl: [(c8Mml,
                       label: block_c8Mml_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mml: // global
           if (R1 & 7 == 1) goto c8Mmo; else goto c8Mmp;
       c8Mmo: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Mmp: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Error.throwIfNeg__entry() //  [R2, R3]
         { info_tbl: [(c8MmB,
                       label: Foreign.Marshal.Error.throwIfNeg__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MmB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8MmF; else goto c8MmE;
       c8MmF: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNeg__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MmE: // global
           I64[Hp - 40] = ds_s8Mf5_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8Mfe_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.146357091 UTC

[section ""cstring" . Foreign.Marshal.Error.$trModule4_bytes" {
     Foreign.Marshal.Error.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.146982404 UTC

[section ""data" . Foreign.Marshal.Error.$trModule3_closure" {
     Foreign.Marshal.Error.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Error.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.147574179 UTC

[section ""cstring" . Foreign.Marshal.Error.$trModule2_bytes" {
     Foreign.Marshal.Error.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.149718205 UTC

[section ""data" . Foreign.Marshal.Error.$trModule1_closure" {
     Foreign.Marshal.Error.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Error.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.150330415 UTC

[section ""data" . Foreign.Marshal.Error.$trModule_closure" {
     Foreign.Marshal.Error.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Error.$trModule3_closure+1;
         const Foreign.Marshal.Error.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.151220365 UTC

[section ""relreadonly" . S8Mfz_srt" {
     S8Mfz_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const Foreign.Marshal.Error.throwIf2_closure;
         const Foreign.Marshal.Error.throwIf1_closure;
         const Foreign.Marshal.Error.throwIfNeg1_closure;
         const Foreign.Marshal.Error.throwIfNeg_closure;
         const Foreign.Marshal.Error.throwIfNull2_closure;
         const Foreign.Marshal.Error.throwIfNull1_closure;
         const Foreign.Marshal.Error.throwIf_1_closure;
         const Foreign.Marshal.Error.throwIfNeg__closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.152184771 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:56.154027262 UTC

[section ""data" . Foreign.Marshal.Error.throwIf2_closure" {
     Foreign.Marshal.Error.throwIf2_closure:
         const Foreign.Marshal.Error.throwIf2_info;
         const 0;
 },
 sat_s8Mei_entry() //  [R1]
         { info_tbl: [(c8MmQ,
                       label: sat_s8Mei_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MmQ: // global
           _s8Mei::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8MmR; else goto c8MmS;
       c8MmS: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8MmU; else goto c8MmT;
       c8MmU: // global
           HpAlloc = 88;
           goto c8MmR;
       c8MmR: // global
           R1 = _s8Mei::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8MmT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Mei::P64;
           _s8Med::P64 = P64[_s8Mei::P64 + 16];
           _s8Mee::P64 = P64[_s8Mei::P64 + 24];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = _s8Mee::P64;
           P64[Hp - 56] = _s8Med::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Error.throwIf2_entry() //  [R2, R3]
         { info_tbl: [(c8MmV,
                       label: Foreign.Marshal.Error.throwIf2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MmV: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8MmZ; else goto c8MmY;
       c8MmZ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MmY: // global
           I64[Hp - 24] = sat_s8Mei_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.16127833 UTC

[section ""data" . Foreign.Marshal.Error.throwIf1_closure" {
     Foreign.Marshal.Error.throwIf1_closure:
         const Foreign.Marshal.Error.throwIf1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Mnl,
                       label: Foreign.Marshal.Error.throwIf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mnl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Mnm; else goto c8Mnn;
       c8Mnm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mnn: // global
           I64[Sp - 24] = block_c8Mnd_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mnd() //  [R1]
         { info_tbl: [(c8Mnd,
                       label: block_c8Mnd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mnd: // global
           I64[Sp] = block_c8Mnf_info;
           R2 = R1;
           _s8Mep::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8Mep::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mnf() //  [R1]
         { info_tbl: [(c8Mnf,
                       label: block_c8Mnf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mnf: // global
           _s8Mep::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8Mni; else goto c8Mnj;
       c8Mni: // global
           R1 = _s8Mep::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Mnj: // global
           R3 = P64[Sp + 16];
           R2 = _s8Mep::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.168387715 UTC

[section ""data" . Foreign.Marshal.Error.throwIf_closure" {
     Foreign.Marshal.Error.throwIf_closure:
         const Foreign.Marshal.Error.throwIf_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf_entry() //  [R2, R3, R4]
         { info_tbl: [(c8MnN,
                       label: Foreign.Marshal.Error.throwIf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MnN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIf1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.171872895 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg1_closure" {
     Foreign.Marshal.Error.throwIfNeg1_closure:
         const Foreign.Marshal.Error.throwIfNeg1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNeg1_entry() //  [R1]
         { info_tbl: [(c8Mo0,
                       label: Foreign.Marshal.Error.throwIfNeg1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mo0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Mo1; else goto c8Mo2;
       c8Mo1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mo2: // global
           (_c8MnX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8MnX::I64 == 0) goto c8MnZ; else goto c8MnY;
       c8MnZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8MnY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8MnX::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.176559837 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg_closure" {
     Foreign.Marshal.Error.throwIfNeg_closure:
         const Foreign.Marshal.Error.throwIfNeg_info;
         const 0;
 },
 ds_s8Met_entry() //  [R1]
         { info_tbl: [(c8Moi,
                       label: ds_s8Met_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Moi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Moj; else goto c8Mok;
       c8Moj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mok: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Error.throwIfNeg1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8MeB_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Moy,
                       label: sat_s8MeB_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Moy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8Moz; else goto c8MoA;
       c8Moz: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MoA: // global
           I64[Sp - 32] = block_c8Moq_info;
           _s8Mer::P64 = P64[R1 + 5];
           _s8Met::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s8Mer::P64;
           P64[Sp - 16] = _s8Met::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Moq() //  [R1]
         { info_tbl: [(c8Moq,
                       label: block_c8Moq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Moq: // global
           _s8Mer::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Mos_info;
           R2 = _s8Mer::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = R1;
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8Mos() //  [R1]
         { info_tbl: [(c8Mos,
                       label: block_c8Mos_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mos: // global
           _s8Mez::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8Mov; else goto c8Mow;
       c8Mov: // global
           R1 = _s8Mez::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Mow: // global
           R3 = P64[Sp + 16];
           R2 = _s8Mez::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Error.throwIfNeg_entry() //  [R2, R3]
         { info_tbl: [(c8MoI,
                       label: Foreign.Marshal.Error.throwIfNeg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MoI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8MoM; else goto c8MoL;
       c8MoM: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNeg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MoL: // global
           I64[Hp - 40] = ds_s8Met_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8MeB_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.189853824 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull2_closure" {
     Foreign.Marshal.Error.throwIfNull2_closure:
         const Foreign.Marshal.Error.throwIfNull2_info;
         const 0;
 },
 sat_s8MeF_entry() //  [R1]
         { info_tbl: [(c8Mpk,
                       label: sat_s8MeF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mpk: // global
           _s8MeF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Mpl; else goto c8Mpm;
       c8Mpm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Mpo; else goto c8Mpn;
       c8Mpo: // global
           HpAlloc = 56;
           goto c8Mpl;
       c8Mpl: // global
           R1 = _s8MeF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mpn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8MeF::P64;
           _s8MeC::P64 = P64[_s8MeF::P64 + 16];
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = _s8MeC::P64;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Error.throwIfNull2_entry() //  [R2]
         { info_tbl: [(c8Mpp,
                       label: Foreign.Marshal.Error.throwIfNull2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mpp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Mpt; else goto c8Mps;
       c8Mpt: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNull2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Mps: // global
           I64[Hp - 16] = sat_s8MeF_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.196883151 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull1_closure" {
     Foreign.Marshal.Error.throwIfNull1_closure:
         const Foreign.Marshal.Error.throwIfNull1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNull1_entry() //  [R2, R3]
         { info_tbl: [(c8MpL,
                       label: Foreign.Marshal.Error.throwIfNull1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MpL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8MpM; else goto c8MpN;
       c8MpM: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNull1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MpN: // global
           I64[Sp - 16] = block_c8MpG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MpG() //  [R1]
         { info_tbl: [(c8MpG,
                       label: block_c8MpG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MpG: // global
           I64[Sp - 8] = block_c8MpI_info;
           _s8MeL::P64 = R1;
           R1 = R1;
           P64[Sp] = _s8MeL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8MpX; else goto c8MpJ;
       u8MpX: // global
           call _c8MpI(R1) args: 0, res: 0, upd: 0;
       c8MpJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MpI() //  [R1]
         { info_tbl: [(c8MpI,
                       label: block_c8MpI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MpI: // global
           if (I64[R1 + 7] == 0) goto c8MpW; else goto c8MpV;
       c8MpW: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIfNull2_entry(R2) args: 8, res: 0, upd: 8;
       c8MpV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.20470398 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull_closure" {
     Foreign.Marshal.Error.throwIfNull_closure:
         const Foreign.Marshal.Error.throwIfNull_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNull_entry() //  [R2, R3]
         { info_tbl: [(c8Mqf,
                       label: Foreign.Marshal.Error.throwIfNull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mqf: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIfNull1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.208500185 UTC

[section ""data" . Foreign.Marshal.Error.void1_closure" {
     Foreign.Marshal.Error.void1_closure:
         const Foreign.Marshal.Error.void1_info;
 },
 Foreign.Marshal.Error.void1_entry() //  [R2]
         { info_tbl: [(c8Mqs,
                       label: Foreign.Marshal.Error.void1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mqs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Mqt; else goto c8Mqu;
       c8Mqt: // global
           R2 = R2;
           R1 = Foreign.Marshal.Error.void1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Mqu: // global
           I64[Sp - 8] = block_c8Mqq_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mqq() //  []
         { info_tbl: [(c8Mqq,
                       label: block_c8Mqq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mqq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.214183993 UTC

[section ""data" . Foreign.Marshal.Error.void_closure" {
     Foreign.Marshal.Error.void_closure:
         const Foreign.Marshal.Error.void_info;
 },
 Foreign.Marshal.Error.void_entry() //  [R2]
         { info_tbl: [(c8MqJ,
                       label: Foreign.Marshal.Error.void_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MqJ: // global
           R2 = R2;
           call Foreign.Marshal.Error.void1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.217919579 UTC

[section ""data" . Foreign.Marshal.Error.throwIf_1_closure" {
     Foreign.Marshal.Error.throwIf_1_closure:
         const Foreign.Marshal.Error.throwIf_1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf_1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Mr2,
                       label: Foreign.Marshal.Error.throwIf_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mr2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Mr3; else goto c8Mr4;
       c8Mr3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mr4: // global
           I64[Sp - 24] = block_c8MqU_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MqU() //  [R1]
         { info_tbl: [(c8MqU,
                       label: block_c8MqU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MqU: // global
           I64[Sp] = block_c8MqW_info;
           R2 = R1;
           _s8Mf0::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8Mf0::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MqW() //  [R1]
         { info_tbl: [(c8MqW,
                       label: block_c8MqW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MqW: // global
           if (R1 & 7 == 1) goto c8MqZ; else goto c8Mr0;
       c8MqZ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Mr0: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.225819499 UTC

[section ""data" . Foreign.Marshal.Error.throwIf__closure" {
     Foreign.Marshal.Error.throwIf__closure:
         const Foreign.Marshal.Error.throwIf__info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf__entry() //  [R2, R3, R4]
         { info_tbl: [(c8Mru,
                       label: Foreign.Marshal.Error.throwIf__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mru: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIf_1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.230079764 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg__closure" {
     Foreign.Marshal.Error.throwIfNeg__closure:
         const Foreign.Marshal.Error.throwIfNeg__info;
         const 0;
 },
 ds_s8Mf5_entry() //  [R1]
         { info_tbl: [(c8MrJ,
                       label: ds_s8Mf5_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MrJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8MrK; else goto c8MrL;
       c8MrK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8MrL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Error.throwIfNeg1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8Mfe_entry() //  [R1, R2, R3]
         { info_tbl: [(c8MrZ,
                       label: sat_s8Mfe_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MrZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8Ms0; else goto c8Ms1;
       c8Ms0: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ms1: // global
           I64[Sp - 32] = block_c8MrR_info;
           _s8Mf3::P64 = P64[R1 + 5];
           _s8Mf5::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s8Mf3::P64;
           P64[Sp - 16] = _s8Mf5::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MrR() //  [R1]
         { info_tbl: [(c8MrR,
                       label: block_c8MrR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MrR: // global
           _s8Mf3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8MrT_info;
           R2 = _s8Mf3::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = R1;
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8MrT() //  [R1]
         { info_tbl: [(c8MrT,
                       label: block_c8MrT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MrT: // global
           if (R1 & 7 == 1) goto c8MrW; else goto c8MrX;
       c8MrW: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8MrX: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Error.throwIfNeg__entry() //  [R2, R3]
         { info_tbl: [(c8Ms9,
                       label: Foreign.Marshal.Error.throwIfNeg__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ms9: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Msd; else goto c8Msc;
       c8Msd: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNeg__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Msc: // global
           I64[Hp - 40] = ds_s8Mf5_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8Mfe_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.241921239 UTC

[section ""cstring" . Foreign.Marshal.Error.$trModule4_bytes" {
     Foreign.Marshal.Error.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.243766381 UTC

[section ""data" . Foreign.Marshal.Error.$trModule3_closure" {
     Foreign.Marshal.Error.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Error.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.245635534 UTC

[section ""cstring" . Foreign.Marshal.Error.$trModule2_bytes" {
     Foreign.Marshal.Error.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.247402416 UTC

[section ""data" . Foreign.Marshal.Error.$trModule1_closure" {
     Foreign.Marshal.Error.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Error.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.24912962 UTC

[section ""data" . Foreign.Marshal.Error.$trModule_closure" {
     Foreign.Marshal.Error.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Error.$trModule3_closure+1;
         const Foreign.Marshal.Error.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.25096451 UTC

[section ""relreadonly" . S8Mfz_srt" {
     S8Mfz_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const Foreign.Marshal.Error.throwIf2_closure;
         const Foreign.Marshal.Error.throwIf1_closure;
         const Foreign.Marshal.Error.throwIfNeg1_closure;
         const Foreign.Marshal.Error.throwIfNeg_closure;
         const Foreign.Marshal.Error.throwIfNull2_closure;
         const Foreign.Marshal.Error.throwIfNull1_closure;
         const Foreign.Marshal.Error.throwIf_1_closure;
         const Foreign.Marshal.Error.throwIfNeg__closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.452114397 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:56.45455162 UTC

[section ""data" . Foreign.Marshal.Error.throwIf2_closure" {
     Foreign.Marshal.Error.throwIf2_closure:
         const Foreign.Marshal.Error.throwIf2_info;
         const 0;
 },
 sat_s8MsN_entry() //  [R1]
         { info_tbl: [(c8MtU,
                       label: sat_s8MsN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MtU: // global
           _s8MsN::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8MtV; else goto c8MtW;
       c8MtW: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8MtY; else goto c8MtX;
       c8MtY: // global
           HpAlloc = 88;
           goto c8MtV;
       c8MtV: // global
           R1 = _s8MsN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8MtX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8MsN::P64;
           _s8MsI::P64 = P64[_s8MsN::P64 + 16];
           _s8MsJ::P64 = P64[_s8MsN::P64 + 24];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = _s8MsJ::P64;
           P64[Hp - 56] = _s8MsI::P64;
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Error.throwIf2_entry() //  [R2, R3]
         { info_tbl: [(c8MtZ,
                       label: Foreign.Marshal.Error.throwIf2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MtZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Mu3; else goto c8Mu2;
       c8Mu3: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mu2: // global
           I64[Hp - 24] = sat_s8MsN_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.462274229 UTC

[section ""data" . Foreign.Marshal.Error.throwIf1_closure" {
     Foreign.Marshal.Error.throwIf1_closure:
         const Foreign.Marshal.Error.throwIf1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8MuE,
                       label: Foreign.Marshal.Error.throwIf1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MuE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8MuF; else goto c8MuG;
       c8MuF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MuG: // global
           I64[Sp - 24] = block_c8Muw_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Muw() //  [R1]
         { info_tbl: [(c8Muw,
                       label: block_c8Muw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Muw: // global
           I64[Sp] = block_c8Muy_info;
           R2 = R1;
           _s8MsU::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8MsU::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Muy() //  [R1]
         { info_tbl: [(c8Muy,
                       label: block_c8Muy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Muy: // global
           _s8MsU::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8MuB; else goto c8MuC;
       c8MuB: // global
           R1 = _s8MsU::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8MuC: // global
           R3 = P64[Sp + 16];
           R2 = _s8MsU::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.470194164 UTC

[section ""data" . Foreign.Marshal.Error.throwIf_closure" {
     Foreign.Marshal.Error.throwIf_closure:
         const Foreign.Marshal.Error.throwIf_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Mv8,
                       label: Foreign.Marshal.Error.throwIf_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mv8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIf1_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.473984146 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg1_closure" {
     Foreign.Marshal.Error.throwIfNeg1_closure:
         const Foreign.Marshal.Error.throwIfNeg1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNeg1_entry() //  [R1]
         { info_tbl: [(c8Mvl,
                       label: Foreign.Marshal.Error.throwIfNeg1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mvl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Mvm; else goto c8Mvn;
       c8Mvm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Mvn: // global
           (_c8Mvi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Mvi::I64 == 0) goto c8Mvk; else goto c8Mvj;
       c8Mvk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Mvj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Mvi::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.479381537 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg_closure" {
     Foreign.Marshal.Error.throwIfNeg_closure:
         const Foreign.Marshal.Error.throwIfNeg_info;
         const 0;
 },
 ds_s8MsY_entry() //  [R1]
         { info_tbl: [(c8MvG,
                       label: ds_s8MsY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MvG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8MvH; else goto c8MvI;
       c8MvH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8MvI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Error.throwIfNeg1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8Mt6_entry() //  [R1, R2, R3]
         { info_tbl: [(c8MvW,
                       label: sat_s8Mt6_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MvW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8MvX; else goto c8MvY;
       c8MvX: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MvY: // global
           I64[Sp - 32] = block_c8MvO_info;
           _s8MsW::P64 = P64[R1 + 5];
           _s8MsY::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s8MsW::P64;
           P64[Sp - 16] = _s8MsY::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MvO() //  [R1]
         { info_tbl: [(c8MvO,
                       label: block_c8MvO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MvO: // global
           _s8MsW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8MvQ_info;
           R2 = _s8MsW::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = R1;
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8MvQ() //  [R1]
         { info_tbl: [(c8MvQ,
                       label: block_c8MvQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MvQ: // global
           _s8Mt4::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8MvT; else goto c8MvU;
       c8MvT: // global
           R1 = _s8Mt4::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8MvU: // global
           R3 = P64[Sp + 16];
           R2 = _s8Mt4::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Error.throwIfNeg_entry() //  [R2, R3]
         { info_tbl: [(c8Mw6,
                       label: Foreign.Marshal.Error.throwIfNeg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mw6: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Mwa; else goto c8Mw9;
       c8Mwa: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNeg_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mw9: // global
           I64[Hp - 40] = ds_s8MsY_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8Mt6_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.491921011 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull2_closure" {
     Foreign.Marshal.Error.throwIfNull2_closure:
         const Foreign.Marshal.Error.throwIfNull2_info;
         const 0;
 },
 sat_s8Mta_entry() //  [R1]
         { info_tbl: [(c8MwQ,
                       label: sat_s8Mta_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MwQ: // global
           _s8Mta::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8MwR; else goto c8MwS;
       c8MwS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8MwU; else goto c8MwT;
       c8MwU: // global
           HpAlloc = 56;
           goto c8MwR;
       c8MwR: // global
           R1 = _s8Mta::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8MwT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Mta::P64;
           _s8Mt7::P64 = P64[_s8Mta::P64 + 16];
           I64[Hp - 48] = GHC.IO.Exception.IOError_con_info;
           P64[Hp - 40] = GHC.Base.Nothing_closure+1;
           P64[Hp - 32] = GHC.IO.Exception.UserError_closure+1;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           P64[Hp - 16] = _s8Mt7::P64;
           P64[Hp - 8] = GHC.Base.Nothing_closure+1;
           P64[Hp] = GHC.Base.Nothing_closure+1;
           R2 = Hp - 47;
           Sp = Sp - 16;
           call GHC.IO.Exception.$fExceptionIOException_$ctoException_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Error.throwIfNull2_entry() //  [R2]
         { info_tbl: [(c8MwV,
                       label: Foreign.Marshal.Error.throwIfNull2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MwV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8MwZ; else goto c8MwY;
       c8MwZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNull2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8MwY: // global
           I64[Hp - 16] = sat_s8Mta_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.499669632 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull1_closure" {
     Foreign.Marshal.Error.throwIfNull1_closure:
         const Foreign.Marshal.Error.throwIfNull1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNull1_entry() //  [R2, R3]
         { info_tbl: [(c8Mxu,
                       label: Foreign.Marshal.Error.throwIfNull1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mxu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Mxv; else goto c8Mxw;
       c8Mxv: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNull1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Mxw: // global
           I64[Sp - 16] = block_c8Mxp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mxp() //  [R1]
         { info_tbl: [(c8Mxp,
                       label: block_c8Mxp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mxp: // global
           I64[Sp - 8] = block_c8Mxr_info;
           _s8Mtg::P64 = R1;
           R1 = R1;
           P64[Sp] = _s8Mtg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8MxG; else goto c8Mxs;
       u8MxG: // global
           call _c8Mxr(R1) args: 0, res: 0, upd: 0;
       c8Mxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Mxr() //  [R1]
         { info_tbl: [(c8Mxr,
                       label: block_c8Mxr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mxr: // global
           if (I64[R1 + 7] == 0) goto c8MxF; else goto c8MxE;
       c8MxF: // global
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIfNull2_entry(R2) args: 8, res: 0, upd: 8;
       c8MxE: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.507395608 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNull_closure" {
     Foreign.Marshal.Error.throwIfNull_closure:
         const Foreign.Marshal.Error.throwIfNull_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIfNull_entry() //  [R2, R3]
         { info_tbl: [(c8My0,
                       label: Foreign.Marshal.Error.throwIfNull_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8My0: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIfNull1_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.511086985 UTC

[section ""data" . Foreign.Marshal.Error.void1_closure" {
     Foreign.Marshal.Error.void1_closure:
         const Foreign.Marshal.Error.void1_info;
 },
 Foreign.Marshal.Error.void1_entry() //  [R2]
         { info_tbl: [(c8Myd,
                       label: Foreign.Marshal.Error.void1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Myd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Mye; else goto c8Myf;
       c8Mye: // global
           R2 = R2;
           R1 = Foreign.Marshal.Error.void1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Myf: // global
           I64[Sp - 8] = block_c8Myb_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Myb() //  []
         { info_tbl: [(c8Myb,
                       label: block_c8Myb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Myb: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.517194508 UTC

[section ""data" . Foreign.Marshal.Error.void_closure" {
     Foreign.Marshal.Error.void_closure:
         const Foreign.Marshal.Error.void_info;
 },
 Foreign.Marshal.Error.void_entry() //  [R2]
         { info_tbl: [(c8Myw,
                       label: Foreign.Marshal.Error.void_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Myw: // global
           R2 = R2;
           call Foreign.Marshal.Error.void1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.520957932 UTC

[section ""data" . Foreign.Marshal.Error.throwIf_1_closure" {
     Foreign.Marshal.Error.throwIf_1_closure:
         const Foreign.Marshal.Error.throwIf_1_info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf_1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8MyP,
                       label: Foreign.Marshal.Error.throwIf_1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MyP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8MyQ; else goto c8MyR;
       c8MyQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIf_1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MyR: // global
           I64[Sp - 24] = block_c8MyH_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MyH() //  [R1]
         { info_tbl: [(c8MyH,
                       label: block_c8MyH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MyH: // global
           I64[Sp] = block_c8MyJ_info;
           R2 = R1;
           _s8Mtv::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8Mtv::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MyJ() //  [R1]
         { info_tbl: [(c8MyJ,
                       label: block_c8MyJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MyJ: // global
           if (R1 & 7 == 1) goto c8MyM; else goto c8MyN;
       c8MyM: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8MyN: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.529739104 UTC

[section ""data" . Foreign.Marshal.Error.throwIf__closure" {
     Foreign.Marshal.Error.throwIf__closure:
         const Foreign.Marshal.Error.throwIf__info;
         const 0;
 },
 Foreign.Marshal.Error.throwIf__entry() //  [R2, R3, R4]
         { info_tbl: [(c8Mzk,
                       label: Foreign.Marshal.Error.throwIf__info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mzk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Error.throwIf_1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.534755629 UTC

[section ""data" . Foreign.Marshal.Error.throwIfNeg__closure" {
     Foreign.Marshal.Error.throwIfNeg__closure:
         const Foreign.Marshal.Error.throwIfNeg__info;
         const 0;
 },
 ds_s8MtA_entry() //  [R1]
         { info_tbl: [(c8Mzz,
                       label: ds_s8MtA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Mzz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8MzA; else goto c8MzB;
       c8MzA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8MzB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Error.throwIfNeg1_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8MtJ_entry() //  [R1, R2, R3]
         { info_tbl: [(c8MzP,
                       label: sat_s8MtJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MzP: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8MzQ; else goto c8MzR;
       c8MzQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MzR: // global
           I64[Sp - 32] = block_c8MzH_info;
           _s8Mty::P64 = P64[R1 + 5];
           _s8MtA::P64 = P64[R1 + 13];
           R1 = R3;
           P64[Sp - 24] = _s8Mty::P64;
           P64[Sp - 16] = _s8MtA::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8MzH() //  [R1]
         { info_tbl: [(c8MzH,
                       label: block_c8MzH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MzH: // global
           _s8Mty::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8MzJ_info;
           R2 = _s8Mty::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = R1;
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8MzJ() //  [R1]
         { info_tbl: [(c8MzJ,
                       label: block_c8MzJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MzJ: // global
           if (R1 & 7 == 1) goto c8MzM; else goto c8MzN;
       c8MzM: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8MzN: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Error.throwIfNeg__entry() //  [R2, R3]
         { info_tbl: [(c8MzZ,
                       label: Foreign.Marshal.Error.throwIfNeg__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8MzZ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8MA3; else goto c8MA2;
       c8MA3: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Error.throwIfNeg__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8MA2: // global
           I64[Hp - 40] = ds_s8MtA_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8MtJ_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.547139102 UTC

[section ""cstring" . Foreign.Marshal.Error.$trModule4_bytes" {
     Foreign.Marshal.Error.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.549045381 UTC

[section ""data" . Foreign.Marshal.Error.$trModule3_closure" {
     Foreign.Marshal.Error.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Error.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.551193665 UTC

[section ""cstring" . Foreign.Marshal.Error.$trModule2_bytes" {
     Foreign.Marshal.Error.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,69,114,114,111,114]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.552952102 UTC

[section ""data" . Foreign.Marshal.Error.$trModule1_closure" {
     Foreign.Marshal.Error.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Error.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.554801721 UTC

[section ""data" . Foreign.Marshal.Error.$trModule_closure" {
     Foreign.Marshal.Error.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Error.$trModule3_closure+1;
         const Foreign.Marshal.Error.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:56.556750736 UTC

[section ""relreadonly" . S8Mu4_srt" {
     S8Mu4_srt:
         const GHC.IO.Exception.$fExceptionIOException_$ctoException_closure;
         const Foreign.Marshal.Error.throwIf2_closure;
         const Foreign.Marshal.Error.throwIf1_closure;
         const Foreign.Marshal.Error.throwIfNeg1_closure;
         const Foreign.Marshal.Error.throwIfNeg_closure;
         const Foreign.Marshal.Error.throwIfNull2_closure;
         const Foreign.Marshal.Error.throwIfNull1_closure;
         const Foreign.Marshal.Error.throwIf_1_closure;
         const Foreign.Marshal.Error.throwIfNeg__closure;
 }]

